/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 1);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/dom7/dist/dom7.module.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_ssr_window__ = __webpack_require__("./node_modules/ssr-window/dist/ssr-window.esm.js");
/**
 * Dom7 2.0.5
 * Minimalistic JavaScript library for DOM manipulation, with a jQuery-compatible API
 * http://framework7.io/docs/dom.html
 *
 * Copyright 2018, Vladimir Kharlampidi
 * The iDangero.us
 * http://www.idangero.us/
 *
 * Licensed under MIT
 *
 * Released on: April 20, 2018
 */


class Dom7 {
  constructor(arr) {
    const self = this;
    // Create array-like object
    for (let i = 0; i < arr.length; i += 1) {
      self[i] = arr[i];
    }
    self.length = arr.length;
    // Return collection with methods
    return this;
  }
}

function $$1(selector, context) {
  const arr = [];
  let i = 0;
  if (selector && !context) {
    if (selector instanceof Dom7) {
      return selector;
    }
  }
  if (selector) {
      // String
    if (typeof selector === 'string') {
      let els;
      let tempParent;
      const html = selector.trim();
      if (html.indexOf('<') >= 0 && html.indexOf('>') >= 0) {
        let toCreate = 'div';
        if (html.indexOf('<li') === 0) toCreate = 'ul';
        if (html.indexOf('<tr') === 0) toCreate = 'tbody';
        if (html.indexOf('<td') === 0 || html.indexOf('<th') === 0) toCreate = 'tr';
        if (html.indexOf('<tbody') === 0) toCreate = 'table';
        if (html.indexOf('<option') === 0) toCreate = 'select';
        tempParent = __WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */].createElement(toCreate);
        tempParent.innerHTML = html;
        for (i = 0; i < tempParent.childNodes.length; i += 1) {
          arr.push(tempParent.childNodes[i]);
        }
      } else {
        if (!context && selector[0] === '#' && !selector.match(/[ .<>:~]/)) {
          // Pure ID selector
          els = [__WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */].getElementById(selector.trim().split('#')[1])];
        } else {
          // Other selectors
          els = (context || __WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */]).querySelectorAll(selector.trim());
        }
        for (i = 0; i < els.length; i += 1) {
          if (els[i]) arr.push(els[i]);
        }
      }
    } else if (selector.nodeType || selector === __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */] || selector === __WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */]) {
      // Node/element
      arr.push(selector);
    } else if (selector.length > 0 && selector[0].nodeType) {
      // Array of elements or instance of Dom
      for (i = 0; i < selector.length; i += 1) {
        arr.push(selector[i]);
      }
    }
  }
  return new Dom7(arr);
}

$$1.fn = Dom7.prototype;
$$1.Class = Dom7;
$$1.Dom7 = Dom7;

function unique(arr) {
  const uniqueArray = [];
  for (let i = 0; i < arr.length; i += 1) {
    if (uniqueArray.indexOf(arr[i]) === -1) uniqueArray.push(arr[i]);
  }
  return uniqueArray;
}
function toCamelCase(string) {
  return string.toLowerCase().replace(/-(.)/g, (match, group1) => group1.toUpperCase());
}

function requestAnimationFrame(callback) {
  if (__WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].requestAnimationFrame) return __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].requestAnimationFrame(callback);
  else if (__WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].webkitRequestAnimationFrame) return __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].webkitRequestAnimationFrame(callback);
  return __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].setTimeout(callback, 1000 / 60);
}
function cancelAnimationFrame(id) {
  if (__WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].cancelAnimationFrame) return __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].cancelAnimationFrame(id);
  else if (__WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].webkitCancelAnimationFrame) return __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].webkitCancelAnimationFrame(id);
  return __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].clearTimeout(id);
}

// Classes and attributes
function addClass(className) {
  if (typeof className === 'undefined') {
    return this;
  }
  const classes = className.split(' ');
  for (let i = 0; i < classes.length; i += 1) {
    for (let j = 0; j < this.length; j += 1) {
      if (typeof this[j].classList !== 'undefined') this[j].classList.add(classes[i]);
    }
  }
  return this;
}
function removeClass(className) {
  const classes = className.split(' ');
  for (let i = 0; i < classes.length; i += 1) {
    for (let j = 0; j < this.length; j += 1) {
      if (typeof this[j].classList !== 'undefined') this[j].classList.remove(classes[i]);
    }
  }
  return this;
}
function hasClass(className) {
  if (!this[0]) return false;
  return this[0].classList.contains(className);
}
function toggleClass(className) {
  const classes = className.split(' ');
  for (let i = 0; i < classes.length; i += 1) {
    for (let j = 0; j < this.length; j += 1) {
      if (typeof this[j].classList !== 'undefined') this[j].classList.toggle(classes[i]);
    }
  }
  return this;
}
function attr(attrs, value) {
  if (arguments.length === 1 && typeof attrs === 'string') {
    // Get attr
    if (this[0]) return this[0].getAttribute(attrs);
    return undefined;
  }

  // Set attrs
  for (let i = 0; i < this.length; i += 1) {
    if (arguments.length === 2) {
      // String
      this[i].setAttribute(attrs, value);
    } else {
      // Object
      // eslint-disable-next-line
      for (const attrName in attrs) {
        this[i][attrName] = attrs[attrName];
        this[i].setAttribute(attrName, attrs[attrName]);
      }
    }
  }
  return this;
}
// eslint-disable-next-line
function removeAttr(attr) {
  for (let i = 0; i < this.length; i += 1) {
    this[i].removeAttribute(attr);
  }
  return this;
}
// eslint-disable-next-line
function prop(props, value) {
  if (arguments.length === 1 && typeof props === 'string') {
    // Get prop
    if (this[0]) return this[0][props];
  } else {
    // Set props
    for (let i = 0; i < this.length; i += 1) {
      if (arguments.length === 2) {
        // String
        this[i][props] = value;
      } else {
        // Object
        // eslint-disable-next-line
        for (const propName in props) {
          this[i][propName] = props[propName];
        }
      }
    }
    return this;
  }
}
function data(key, value) {
  let el;
  if (typeof value === 'undefined') {
    el = this[0];
    // Get value
    if (el) {
      if (el.dom7ElementDataStorage && (key in el.dom7ElementDataStorage)) {
        return el.dom7ElementDataStorage[key];
      }

      const dataKey = el.getAttribute(`data-${key}`);
      if (dataKey) {
        return dataKey;
      }
      return undefined;
    }
    return undefined;
  }

  // Set value
  for (let i = 0; i < this.length; i += 1) {
    el = this[i];
    if (!el.dom7ElementDataStorage) el.dom7ElementDataStorage = {};
    el.dom7ElementDataStorage[key] = value;
  }
  return this;
}
function removeData(key) {
  for (let i = 0; i < this.length; i += 1) {
    const el = this[i];
    if (el.dom7ElementDataStorage && el.dom7ElementDataStorage[key]) {
      el.dom7ElementDataStorage[key] = null;
      delete el.dom7ElementDataStorage[key];
    }
  }
}
function dataset() {
  const el = this[0];
  if (!el) return undefined;
  const dataset = {}; // eslint-disable-line
  if (el.dataset) {
    // eslint-disable-next-line
    for (const dataKey in el.dataset) {
      dataset[dataKey] = el.dataset[dataKey];
    }
  } else {
    for (let i = 0; i < el.attributes.length; i += 1) {
      // eslint-disable-next-line
      const attr = el.attributes[i];
      if (attr.name.indexOf('data-') >= 0) {
        dataset[toCamelCase(attr.name.split('data-')[1])] = attr.value;
      }
    }
  }
  // eslint-disable-next-line
  for (const key in dataset) {
    if (dataset[key] === 'false') dataset[key] = false;
    else if (dataset[key] === 'true') dataset[key] = true;
    else if (parseFloat(dataset[key]) === dataset[key] * 1) dataset[key] *= 1;
  }
  return dataset;
}
function val(value) {
  const dom = this;
  if (typeof value === 'undefined') {
    if (dom[0]) {
      if (dom[0].multiple && dom[0].nodeName.toLowerCase() === 'select') {
        const values = [];
        for (let i = 0; i < dom[0].selectedOptions.length; i += 1) {
          values.push(dom[0].selectedOptions[i].value);
        }
        return values;
      }
      return dom[0].value;
    }
    return undefined;
  }

  for (let i = 0; i < dom.length; i += 1) {
    const el = dom[i];
    if (Array.isArray(value) && el.multiple && el.nodeName.toLowerCase() === 'select') {
      for (let j = 0; j < el.options.length; j += 1) {
        el.options[j].selected = value.indexOf(el.options[j].value) >= 0;
      }
    } else {
      el.value = value;
    }
  }
  return dom;
}
// Transforms
// eslint-disable-next-line
function transform(transform) {
  for (let i = 0; i < this.length; i += 1) {
    const elStyle = this[i].style;
    elStyle.webkitTransform = transform;
    elStyle.transform = transform;
  }
  return this;
}
function transition(duration) {
  if (typeof duration !== 'string') {
    duration = `${duration}ms`; // eslint-disable-line
  }
  for (let i = 0; i < this.length; i += 1) {
    const elStyle = this[i].style;
    elStyle.webkitTransitionDuration = duration;
    elStyle.transitionDuration = duration;
  }
  return this;
}
// Events
function on(...args) {
  let [eventType, targetSelector, listener, capture] = args;
  if (typeof args[1] === 'function') {
    [eventType, listener, capture] = args;
    targetSelector = undefined;
  }
  if (!capture) capture = false;

  function handleLiveEvent(e) {
    const target = e.target;
    if (!target) return;
    const eventData = e.target.dom7EventData || [];
    if (eventData.indexOf(e) < 0) {
      eventData.unshift(e);
    }
    if ($$1(target).is(targetSelector)) listener.apply(target, eventData);
    else {
      const parents = $$1(target).parents(); // eslint-disable-line
      for (let k = 0; k < parents.length; k += 1) {
        if ($$1(parents[k]).is(targetSelector)) listener.apply(parents[k], eventData);
      }
    }
  }
  function handleEvent(e) {
    const eventData = e && e.target ? e.target.dom7EventData || [] : [];
    if (eventData.indexOf(e) < 0) {
      eventData.unshift(e);
    }
    listener.apply(this, eventData);
  }
  const events = eventType.split(' ');
  let j;
  for (let i = 0; i < this.length; i += 1) {
    const el = this[i];
    if (!targetSelector) {
      for (j = 0; j < events.length; j += 1) {
        const event = events[j];
        if (!el.dom7Listeners) el.dom7Listeners = {};
        if (!el.dom7Listeners[event]) el.dom7Listeners[event] = [];
        el.dom7Listeners[event].push({
          listener,
          proxyListener: handleEvent,
        });
        el.addEventListener(event, handleEvent, capture);
      }
    } else {
      // Live events
      for (j = 0; j < events.length; j += 1) {
        const event = events[j];
        if (!el.dom7LiveListeners) el.dom7LiveListeners = {};
        if (!el.dom7LiveListeners[event]) el.dom7LiveListeners[event] = [];
        el.dom7LiveListeners[event].push({
          listener,
          proxyListener: handleLiveEvent,
        });
        el.addEventListener(event, handleLiveEvent, capture);
      }
    }
  }
  return this;
}
function off(...args) {
  let [eventType, targetSelector, listener, capture] = args;
  if (typeof args[1] === 'function') {
    [eventType, listener, capture] = args;
    targetSelector = undefined;
  }
  if (!capture) capture = false;

  const events = eventType.split(' ');
  for (let i = 0; i < events.length; i += 1) {
    const event = events[i];
    for (let j = 0; j < this.length; j += 1) {
      const el = this[j];
      let handlers;
      if (!targetSelector && el.dom7Listeners) {
        handlers = el.dom7Listeners[event];
      } else if (targetSelector && el.dom7LiveListeners) {
        handlers = el.dom7LiveListeners[event];
      }
      for (let k = handlers.length - 1; k >= 0; k -= 1) {
        const handler = handlers[k];
        if (listener && handler.listener === listener) {
          el.removeEventListener(event, handler.proxyListener, capture);
          handlers.splice(k, 1);
        } else if (!listener) {
          el.removeEventListener(event, handler.proxyListener, capture);
          handlers.splice(k, 1);
        }
      }
    }
  }
  return this;
}
function once(...args) {
  const dom = this;
  let [eventName, targetSelector, listener, capture] = args;
  if (typeof args[1] === 'function') {
    [eventName, listener, capture] = args;
    targetSelector = undefined;
  }
  function proxy(...eventArgs) {
    listener.apply(this, eventArgs);
    dom.off(eventName, targetSelector, proxy, capture);
  }
  return dom.on(eventName, targetSelector, proxy, capture);
}
function trigger(...args) {
  const events = args[0].split(' ');
  const eventData = args[1];
  for (let i = 0; i < events.length; i += 1) {
    const event = events[i];
    for (let j = 0; j < this.length; j += 1) {
      const el = this[j];
      let evt;
      try {
        evt = new __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].CustomEvent(event, {
          detail: eventData,
          bubbles: true,
          cancelable: true,
        });
      } catch (e) {
        evt = __WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */].createEvent('Event');
        evt.initEvent(event, true, true);
        evt.detail = eventData;
      }
      // eslint-disable-next-line
      el.dom7EventData = args.filter((data, dataIndex) => dataIndex > 0);
      el.dispatchEvent(evt);
      el.dom7EventData = [];
      delete el.dom7EventData;
    }
  }
  return this;
}
function transitionEnd(callback) {
  const events = ['webkitTransitionEnd', 'transitionend'];
  const dom = this;
  let i;
  function fireCallBack(e) {
    /* jshint validthis:true */
    if (e.target !== this) return;
    callback.call(this, e);
    for (i = 0; i < events.length; i += 1) {
      dom.off(events[i], fireCallBack);
    }
  }
  if (callback) {
    for (i = 0; i < events.length; i += 1) {
      dom.on(events[i], fireCallBack);
    }
  }
  return this;
}
function animationEnd(callback) {
  const events = ['webkitAnimationEnd', 'animationend'];
  const dom = this;
  let i;
  function fireCallBack(e) {
    if (e.target !== this) return;
    callback.call(this, e);
    for (i = 0; i < events.length; i += 1) {
      dom.off(events[i], fireCallBack);
    }
  }
  if (callback) {
    for (i = 0; i < events.length; i += 1) {
      dom.on(events[i], fireCallBack);
    }
  }
  return this;
}
// Sizing/Styles
function width() {
  if (this[0] === __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */]) {
    return __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].innerWidth;
  }

  if (this.length > 0) {
    return parseFloat(this.css('width'));
  }

  return null;
}
function outerWidth(includeMargins) {
  if (this.length > 0) {
    if (includeMargins) {
      // eslint-disable-next-line
      const styles = this.styles();
      return this[0].offsetWidth + parseFloat(styles.getPropertyValue('margin-right')) + parseFloat(styles.getPropertyValue('margin-left'));
    }
    return this[0].offsetWidth;
  }
  return null;
}
function height() {
  if (this[0] === __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */]) {
    return __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].innerHeight;
  }

  if (this.length > 0) {
    return parseFloat(this.css('height'));
  }

  return null;
}
function outerHeight(includeMargins) {
  if (this.length > 0) {
    if (includeMargins) {
      // eslint-disable-next-line
      const styles = this.styles();
      return this[0].offsetHeight + parseFloat(styles.getPropertyValue('margin-top')) + parseFloat(styles.getPropertyValue('margin-bottom'));
    }
    return this[0].offsetHeight;
  }
  return null;
}
function offset() {
  if (this.length > 0) {
    const el = this[0];
    const box = el.getBoundingClientRect();
    const body = __WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */].body;
    const clientTop = el.clientTop || body.clientTop || 0;
    const clientLeft = el.clientLeft || body.clientLeft || 0;
    const scrollTop = el === __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */] ? __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].scrollY : el.scrollTop;
    const scrollLeft = el === __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */] ? __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].scrollX : el.scrollLeft;
    return {
      top: (box.top + scrollTop) - clientTop,
      left: (box.left + scrollLeft) - clientLeft,
    };
  }

  return null;
}
function hide() {
  for (let i = 0; i < this.length; i += 1) {
    this[i].style.display = 'none';
  }
  return this;
}
function show() {
  for (let i = 0; i < this.length; i += 1) {
    const el = this[i];
    if (el.style.display === 'none') {
      el.style.display = '';
    }
    if (__WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].getComputedStyle(el, null).getPropertyValue('display') === 'none') {
      // Still not visible
      el.style.display = 'block';
    }
  }
  return this;
}
function styles() {
  if (this[0]) return __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].getComputedStyle(this[0], null);
  return {};
}
function css(props, value) {
  let i;
  if (arguments.length === 1) {
    if (typeof props === 'string') {
      if (this[0]) return __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].getComputedStyle(this[0], null).getPropertyValue(props);
    } else {
      for (i = 0; i < this.length; i += 1) {
        // eslint-disable-next-line
        for (let prop in props) {
          this[i].style[prop] = props[prop];
        }
      }
      return this;
    }
  }
  if (arguments.length === 2 && typeof props === 'string') {
    for (i = 0; i < this.length; i += 1) {
      this[i].style[props] = value;
    }
    return this;
  }
  return this;
}

// Dom manipulation
function toArray() {
  const arr = [];
  for (let i = 0; i < this.length; i += 1) {
    arr.push(this[i]);
  }
  return arr;
}
// Iterate over the collection passing elements to `callback`
function each(callback) {
  // Don't bother continuing without a callback
  if (!callback) return this;
  // Iterate over the current collection
  for (let i = 0; i < this.length; i += 1) {
    // If the callback returns false
    if (callback.call(this[i], i, this[i]) === false) {
      // End the loop early
      return this;
    }
  }
  // Return `this` to allow chained DOM operations
  return this;
}
function forEach(callback) {
  // Don't bother continuing without a callback
  if (!callback) return this;
  // Iterate over the current collection
  for (let i = 0; i < this.length; i += 1) {
    // If the callback returns false
    if (callback.call(this[i], this[i], i) === false) {
      // End the loop early
      return this;
    }
  }
  // Return `this` to allow chained DOM operations
  return this;
}
function filter(callback) {
  const matchedItems = [];
  const dom = this;
  for (let i = 0; i < dom.length; i += 1) {
    if (callback.call(dom[i], i, dom[i])) matchedItems.push(dom[i]);
  }
  return new Dom7(matchedItems);
}
function map(callback) {
  const modifiedItems = [];
  const dom = this;
  for (let i = 0; i < dom.length; i += 1) {
    modifiedItems.push(callback.call(dom[i], i, dom[i]));
  }
  return new Dom7(modifiedItems);
}
// eslint-disable-next-line
function html(html) {
  if (typeof html === 'undefined') {
    return this[0] ? this[0].innerHTML : undefined;
  }

  for (let i = 0; i < this.length; i += 1) {
    this[i].innerHTML = html;
  }
  return this;
}
// eslint-disable-next-line
function text(text) {
  if (typeof text === 'undefined') {
    if (this[0]) {
      return this[0].textContent.trim();
    }
    return null;
  }

  for (let i = 0; i < this.length; i += 1) {
    this[i].textContent = text;
  }
  return this;
}
function is(selector) {
  const el = this[0];
  let compareWith;
  let i;
  if (!el || typeof selector === 'undefined') return false;
  if (typeof selector === 'string') {
    if (el.matches) return el.matches(selector);
    else if (el.webkitMatchesSelector) return el.webkitMatchesSelector(selector);
    else if (el.msMatchesSelector) return el.msMatchesSelector(selector);

    compareWith = $$1(selector);
    for (i = 0; i < compareWith.length; i += 1) {
      if (compareWith[i] === el) return true;
    }
    return false;
  } else if (selector === __WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */]) return el === __WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */];
  else if (selector === __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */]) return el === __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */];

  if (selector.nodeType || selector instanceof Dom7) {
    compareWith = selector.nodeType ? [selector] : selector;
    for (i = 0; i < compareWith.length; i += 1) {
      if (compareWith[i] === el) return true;
    }
    return false;
  }
  return false;
}
function indexOf(el) {
  for (let i = 0; i < this.length; i += 1) {
    if (this[i] === el) return i;
  }
  return -1;
}
function index() {
  let child = this[0];
  let i;
  if (child) {
    i = 0;
    // eslint-disable-next-line
    while ((child = child.previousSibling) !== null) {
      if (child.nodeType === 1) i += 1;
    }
    return i;
  }
  return undefined;
}
// eslint-disable-next-line
function eq(index) {
  if (typeof index === 'undefined') return this;
  const length = this.length;
  let returnIndex;
  if (index > length - 1) {
    return new Dom7([]);
  }
  if (index < 0) {
    returnIndex = length + index;
    if (returnIndex < 0) return new Dom7([]);
    return new Dom7([this[returnIndex]]);
  }
  return new Dom7([this[index]]);
}
function append(...args) {
  let newChild;

  for (let k = 0; k < args.length; k += 1) {
    newChild = args[k];
    for (let i = 0; i < this.length; i += 1) {
      if (typeof newChild === 'string') {
        const tempDiv = __WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */].createElement('div');
        tempDiv.innerHTML = newChild;
        while (tempDiv.firstChild) {
          this[i].appendChild(tempDiv.firstChild);
        }
      } else if (newChild instanceof Dom7) {
        for (let j = 0; j < newChild.length; j += 1) {
          this[i].appendChild(newChild[j]);
        }
      } else {
        this[i].appendChild(newChild);
      }
    }
  }

  return this;
}
 // eslint-disable-next-line
function appendTo(parent) {
  $$1(parent).append(this);
  return this;
}
function prepend(newChild) {
  let i;
  let j;
  for (i = 0; i < this.length; i += 1) {
    if (typeof newChild === 'string') {
      const tempDiv = __WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */].createElement('div');
      tempDiv.innerHTML = newChild;
      for (j = tempDiv.childNodes.length - 1; j >= 0; j -= 1) {
        this[i].insertBefore(tempDiv.childNodes[j], this[i].childNodes[0]);
      }
    } else if (newChild instanceof Dom7) {
      for (j = 0; j < newChild.length; j += 1) {
        this[i].insertBefore(newChild[j], this[i].childNodes[0]);
      }
    } else {
      this[i].insertBefore(newChild, this[i].childNodes[0]);
    }
  }
  return this;
}
 // eslint-disable-next-line
function prependTo(parent) {
  $$1(parent).prepend(this);
  return this;
}
function insertBefore(selector) {
  const before = $$1(selector);
  for (let i = 0; i < this.length; i += 1) {
    if (before.length === 1) {
      before[0].parentNode.insertBefore(this[i], before[0]);
    } else if (before.length > 1) {
      for (let j = 0; j < before.length; j += 1) {
        before[j].parentNode.insertBefore(this[i].cloneNode(true), before[j]);
      }
    }
  }
}
function insertAfter(selector) {
  const after = $$1(selector);
  for (let i = 0; i < this.length; i += 1) {
    if (after.length === 1) {
      after[0].parentNode.insertBefore(this[i], after[0].nextSibling);
    } else if (after.length > 1) {
      for (let j = 0; j < after.length; j += 1) {
        after[j].parentNode.insertBefore(this[i].cloneNode(true), after[j].nextSibling);
      }
    }
  }
}
function next(selector) {
  if (this.length > 0) {
    if (selector) {
      if (this[0].nextElementSibling && $$1(this[0].nextElementSibling).is(selector)) {
        return new Dom7([this[0].nextElementSibling]);
      }
      return new Dom7([]);
    }

    if (this[0].nextElementSibling) return new Dom7([this[0].nextElementSibling]);
    return new Dom7([]);
  }
  return new Dom7([]);
}
function nextAll(selector) {
  const nextEls = [];
  let el = this[0];
  if (!el) return new Dom7([]);
  while (el.nextElementSibling) {
    const next = el.nextElementSibling; // eslint-disable-line
    if (selector) {
      if ($$1(next).is(selector)) nextEls.push(next);
    } else nextEls.push(next);
    el = next;
  }
  return new Dom7(nextEls);
}
function prev(selector) {
  if (this.length > 0) {
    const el = this[0];
    if (selector) {
      if (el.previousElementSibling && $$1(el.previousElementSibling).is(selector)) {
        return new Dom7([el.previousElementSibling]);
      }
      return new Dom7([]);
    }

    if (el.previousElementSibling) return new Dom7([el.previousElementSibling]);
    return new Dom7([]);
  }
  return new Dom7([]);
}
function prevAll(selector) {
  const prevEls = [];
  let el = this[0];
  if (!el) return new Dom7([]);
  while (el.previousElementSibling) {
    const prev = el.previousElementSibling; // eslint-disable-line
    if (selector) {
      if ($$1(prev).is(selector)) prevEls.push(prev);
    } else prevEls.push(prev);
    el = prev;
  }
  return new Dom7(prevEls);
}
function siblings(selector) {
  return this.nextAll(selector).add(this.prevAll(selector));
}
function parent(selector) {
  const parents = []; // eslint-disable-line
  for (let i = 0; i < this.length; i += 1) {
    if (this[i].parentNode !== null) {
      if (selector) {
        if ($$1(this[i].parentNode).is(selector)) parents.push(this[i].parentNode);
      } else {
        parents.push(this[i].parentNode);
      }
    }
  }
  return $$1(unique(parents));
}
function parents(selector) {
  const parents = []; // eslint-disable-line
  for (let i = 0; i < this.length; i += 1) {
    let parent = this[i].parentNode; // eslint-disable-line
    while (parent) {
      if (selector) {
        if ($$1(parent).is(selector)) parents.push(parent);
      } else {
        parents.push(parent);
      }
      parent = parent.parentNode;
    }
  }
  return $$1(unique(parents));
}
function closest(selector) {
  let closest = this; // eslint-disable-line
  if (typeof selector === 'undefined') {
    return new Dom7([]);
  }
  if (!closest.is(selector)) {
    closest = closest.parents(selector).eq(0);
  }
  return closest;
}
function find(selector) {
  const foundElements = [];
  for (let i = 0; i < this.length; i += 1) {
    const found = this[i].querySelectorAll(selector);
    for (let j = 0; j < found.length; j += 1) {
      foundElements.push(found[j]);
    }
  }
  return new Dom7(foundElements);
}
function children(selector) {
  const children = []; // eslint-disable-line
  for (let i = 0; i < this.length; i += 1) {
    const childNodes = this[i].childNodes;

    for (let j = 0; j < childNodes.length; j += 1) {
      if (!selector) {
        if (childNodes[j].nodeType === 1) children.push(childNodes[j]);
      } else if (childNodes[j].nodeType === 1 && $$1(childNodes[j]).is(selector)) {
        children.push(childNodes[j]);
      }
    }
  }
  return new Dom7(unique(children));
}
function remove() {
  for (let i = 0; i < this.length; i += 1) {
    if (this[i].parentNode) this[i].parentNode.removeChild(this[i]);
  }
  return this;
}
function detach() {
  return this.remove();
}
function add(...args) {
  const dom = this;
  let i;
  let j;
  for (i = 0; i < args.length; i += 1) {
    const toAdd = $$1(args[i]);
    for (j = 0; j < toAdd.length; j += 1) {
      dom[dom.length] = toAdd[j];
      dom.length += 1;
    }
  }
  return dom;
}
function empty() {
  for (let i = 0; i < this.length; i += 1) {
    const el = this[i];
    if (el.nodeType === 1) {
      for (let j = 0; j < el.childNodes.length; j += 1) {
        if (el.childNodes[j].parentNode) {
          el.childNodes[j].parentNode.removeChild(el.childNodes[j]);
        }
      }
      el.textContent = '';
    }
  }
  return this;
}




var Methods = Object.freeze({
	addClass: addClass,
	removeClass: removeClass,
	hasClass: hasClass,
	toggleClass: toggleClass,
	attr: attr,
	removeAttr: removeAttr,
	prop: prop,
	data: data,
	removeData: removeData,
	dataset: dataset,
	val: val,
	transform: transform,
	transition: transition,
	on: on,
	off: off,
	once: once,
	trigger: trigger,
	transitionEnd: transitionEnd,
	animationEnd: animationEnd,
	width: width,
	outerWidth: outerWidth,
	height: height,
	outerHeight: outerHeight,
	offset: offset,
	hide: hide,
	show: show,
	styles: styles,
	css: css,
	toArray: toArray,
	each: each,
	forEach: forEach,
	filter: filter,
	map: map,
	html: html,
	text: text,
	is: is,
	indexOf: indexOf,
	index: index,
	eq: eq,
	append: append,
	appendTo: appendTo,
	prepend: prepend,
	prependTo: prependTo,
	insertBefore: insertBefore,
	insertAfter: insertAfter,
	next: next,
	nextAll: nextAll,
	prev: prev,
	prevAll: prevAll,
	siblings: siblings,
	parent: parent,
	parents: parents,
	closest: closest,
	find: find,
	children: children,
	remove: remove,
	detach: detach,
	add: add,
	empty: empty
});

function scrollTo(...args) {
  let [left, top, duration, easing, callback] = args;
  if (args.length === 4 && typeof easing === 'function') {
    callback = easing;
    [left, top, duration, callback, easing] = args;
  }
  if (typeof easing === 'undefined') easing = 'swing';

  return this.each(function animate() {
    const el = this;
    let currentTop;
    let currentLeft;
    let maxTop;
    let maxLeft;
    let newTop;
    let newLeft;
    let scrollTop; // eslint-disable-line
    let scrollLeft; // eslint-disable-line
    let animateTop = top > 0 || top === 0;
    let animateLeft = left > 0 || left === 0;
    if (typeof easing === 'undefined') {
      easing = 'swing';
    }
    if (animateTop) {
      currentTop = el.scrollTop;
      if (!duration) {
        el.scrollTop = top;
      }
    }
    if (animateLeft) {
      currentLeft = el.scrollLeft;
      if (!duration) {
        el.scrollLeft = left;
      }
    }
    if (!duration) return;
    if (animateTop) {
      maxTop = el.scrollHeight - el.offsetHeight;
      newTop = Math.max(Math.min(top, maxTop), 0);
    }
    if (animateLeft) {
      maxLeft = el.scrollWidth - el.offsetWidth;
      newLeft = Math.max(Math.min(left, maxLeft), 0);
    }
    let startTime = null;
    if (animateTop && newTop === currentTop) animateTop = false;
    if (animateLeft && newLeft === currentLeft) animateLeft = false;
    function render(time = new Date().getTime()) {
      if (startTime === null) {
        startTime = time;
      }
      const progress = Math.max(Math.min((time - startTime) / duration, 1), 0);
      const easeProgress = easing === 'linear' ? progress : (0.5 - (Math.cos(progress * Math.PI) / 2));
      let done;
      if (animateTop) scrollTop = currentTop + (easeProgress * (newTop - currentTop));
      if (animateLeft) scrollLeft = currentLeft + (easeProgress * (newLeft - currentLeft));
      if (animateTop && newTop > currentTop && scrollTop >= newTop) {
        el.scrollTop = newTop;
        done = true;
      }
      if (animateTop && newTop < currentTop && scrollTop <= newTop) {
        el.scrollTop = newTop;
        done = true;
      }
      if (animateLeft && newLeft > currentLeft && scrollLeft >= newLeft) {
        el.scrollLeft = newLeft;
        done = true;
      }
      if (animateLeft && newLeft < currentLeft && scrollLeft <= newLeft) {
        el.scrollLeft = newLeft;
        done = true;
      }

      if (done) {
        if (callback) callback();
        return;
      }
      if (animateTop) el.scrollTop = scrollTop;
      if (animateLeft) el.scrollLeft = scrollLeft;
      requestAnimationFrame(render);
    }
    requestAnimationFrame(render);
  });
}
// scrollTop(top, duration, easing, callback) {
function scrollTop(...args) {
  let [top, duration, easing, callback] = args;
  if (args.length === 3 && typeof easing === 'function') {
    [top, duration, callback, easing] = args;
  }
  const dom = this;
  if (typeof top === 'undefined') {
    if (dom.length > 0) return dom[0].scrollTop;
    return null;
  }
  return dom.scrollTo(undefined, top, duration, easing, callback);
}
function scrollLeft(...args) {
  let [left, duration, easing, callback] = args;
  if (args.length === 3 && typeof easing === 'function') {
    [left, duration, callback, easing] = args;
  }
  const dom = this;
  if (typeof left === 'undefined') {
    if (dom.length > 0) return dom[0].scrollLeft;
    return null;
  }
  return dom.scrollTo(left, undefined, duration, easing, callback);
}




var Scroll = Object.freeze({
	scrollTo: scrollTo,
	scrollTop: scrollTop,
	scrollLeft: scrollLeft
});

function animate(initialProps, initialParams) {
  const els = this;
  const a = {
    props: Object.assign({}, initialProps),
    params: Object.assign({
      duration: 300,
      easing: 'swing', // or 'linear'
      /* Callbacks
      begin(elements)
      complete(elements)
      progress(elements, complete, remaining, start, tweenValue)
      */
    }, initialParams),

    elements: els,
    animating: false,
    que: [],

    easingProgress(easing, progress) {
      if (easing === 'swing') {
        return 0.5 - (Math.cos(progress * Math.PI) / 2);
      }
      if (typeof easing === 'function') {
        return easing(progress);
      }
      return progress;
    },
    stop() {
      if (a.frameId) {
        cancelAnimationFrame(a.frameId);
      }
      a.animating = false;
      a.elements.each((index, el) => {
        const element = el;
        delete element.dom7AnimateInstance;
      });
      a.que = [];
    },
    done(complete) {
      a.animating = false;
      a.elements.each((index, el) => {
        const element = el;
        delete element.dom7AnimateInstance;
      });
      if (complete) complete(els);
      if (a.que.length > 0) {
        const que = a.que.shift();
        a.animate(que[0], que[1]);
      }
    },
    animate(props, params) {
      if (a.animating) {
        a.que.push([props, params]);
        return a;
      }
      const elements = [];

      // Define & Cache Initials & Units
      a.elements.each((index, el) => {
        let initialFullValue;
        let initialValue;
        let unit;
        let finalValue;
        let finalFullValue;

        if (!el.dom7AnimateInstance) a.elements[index].dom7AnimateInstance = a;

        elements[index] = {
          container: el,
        };
        Object.keys(props).forEach((prop) => {
          initialFullValue = __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].getComputedStyle(el, null).getPropertyValue(prop).replace(',', '.');
          initialValue = parseFloat(initialFullValue);
          unit = initialFullValue.replace(initialValue, '');
          finalValue = parseFloat(props[prop]);
          finalFullValue = props[prop] + unit;
          elements[index][prop] = {
            initialFullValue,
            initialValue,
            unit,
            finalValue,
            finalFullValue,
            currentValue: initialValue,
          };
        });
      });

      let startTime = null;
      let time;
      let elementsDone = 0;
      let propsDone = 0;
      let done;
      let began = false;

      a.animating = true;

      function render() {
        time = new Date().getTime();
        let progress;
        let easeProgress;
        // let el;
        if (!began) {
          began = true;
          if (params.begin) params.begin(els);
        }
        if (startTime === null) {
          startTime = time;
        }
        if (params.progress) {
          // eslint-disable-next-line
          params.progress(els, Math.max(Math.min((time - startTime) / params.duration, 1), 0), ((startTime + params.duration) - time < 0 ? 0 : (startTime + params.duration) - time), startTime);
        }

        elements.forEach((element) => {
          const el = element;
          if (done || el.done) return;
          Object.keys(props).forEach((prop) => {
            if (done || el.done) return;
            progress = Math.max(Math.min((time - startTime) / params.duration, 1), 0);
            easeProgress = a.easingProgress(params.easing, progress);
            const { initialValue, finalValue, unit } = el[prop];
            el[prop].currentValue = initialValue + (easeProgress * (finalValue - initialValue));
            const currentValue = el[prop].currentValue;

            if (
              (finalValue > initialValue && currentValue >= finalValue) ||
              (finalValue < initialValue && currentValue <= finalValue)) {
              el.container.style[prop] = finalValue + unit;
              propsDone += 1;
              if (propsDone === Object.keys(props).length) {
                el.done = true;
                elementsDone += 1;
              }
              if (elementsDone === elements.length) {
                done = true;
              }
            }
            if (done) {
              a.done(params.complete);
              return;
            }
            el.container.style[prop] = currentValue + unit;
          });
        });
        if (done) return;
        // Then call
        a.frameId = requestAnimationFrame(render);
      }
      a.frameId = requestAnimationFrame(render);
      return a;
    },
  };

  if (a.elements.length === 0) {
    return els;
  }

  let animateInstance;
  for (let i = 0; i < a.elements.length; i += 1) {
    if (a.elements[i].dom7AnimateInstance) {
      animateInstance = a.elements[i].dom7AnimateInstance;
    } else a.elements[i].dom7AnimateInstance = a;
  }
  if (!animateInstance) {
    animateInstance = a;
  }

  if (initialProps === 'stop') {
    animateInstance.stop();
  } else {
    animateInstance.animate(a.props, a.params);
  }

  return els;
}

function stop() {
  const els = this;
  for (let i = 0; i < els.length; i += 1) {
    if (els[i].dom7AnimateInstance) {
      els[i].dom7AnimateInstance.stop();
    }
  }
}




var Animate = Object.freeze({
	animate: animate,
	stop: stop
});

const noTrigger = ('resize scroll').split(' ');
function eventShortcut(name, ...args) {
  if (typeof args[0] === 'undefined') {
    for (let i = 0; i < this.length; i += 1) {
      if (noTrigger.indexOf(name) < 0) {
        if (name in this[i]) this[i][name]();
        else {
          $$1(this[i]).trigger(name);
        }
      }
    }
    return this;
  }
  return this.on(name, ...args);
}

function click(...args) {
  return eventShortcut.bind(this)('click', ...args);
}
function blur(...args) {
  return eventShortcut.bind(this)('blur', ...args);
}
function focus(...args) {
  return eventShortcut.bind(this)('focus', ...args);
}
function focusin(...args) {
  return eventShortcut.bind(this)('focusin', ...args);
}
function focusout(...args) {
  return eventShortcut.bind(this)('focusout', ...args);
}
function keyup(...args) {
  return eventShortcut.bind(this)('keyup', ...args);
}
function keydown(...args) {
  return eventShortcut.bind(this)('keydown', ...args);
}
function keypress(...args) {
  return eventShortcut.bind(this)('keypress', ...args);
}
function submit(...args) {
  return eventShortcut.bind(this)('submit', ...args);
}
function change(...args) {
  return eventShortcut.bind(this)('change', ...args);
}
function mousedown(...args) {
  return eventShortcut.bind(this)('mousedown', ...args);
}
function mousemove(...args) {
  return eventShortcut.bind(this)('mousemove', ...args);
}
function mouseup(...args) {
  return eventShortcut.bind(this)('mouseup', ...args);
}
function mouseenter(...args) {
  return eventShortcut.bind(this)('mouseenter', ...args);
}
function mouseleave(...args) {
  return eventShortcut.bind(this)('mouseleave', ...args);
}
function mouseout(...args) {
  return eventShortcut.bind(this)('mouseout', ...args);
}
function mouseover(...args) {
  return eventShortcut.bind(this)('mouseover', ...args);
}
function touchstart(...args) {
  return eventShortcut.bind(this)('touchstart', ...args);
}
function touchend(...args) {
  return eventShortcut.bind(this)('touchend', ...args);
}
function touchmove(...args) {
  return eventShortcut.bind(this)('touchmove', ...args);
}
function resize(...args) {
  return eventShortcut.bind(this)('resize', ...args);
}
function scroll(...args) {
  return eventShortcut.bind(this)('scroll', ...args);
}




var eventShortcuts = Object.freeze({
	click: click,
	blur: blur,
	focus: focus,
	focusin: focusin,
	focusout: focusout,
	keyup: keyup,
	keydown: keydown,
	keypress: keypress,
	submit: submit,
	change: change,
	mousedown: mousedown,
	mousemove: mousemove,
	mouseup: mouseup,
	mouseenter: mouseenter,
	mouseleave: mouseleave,
	mouseout: mouseout,
	mouseover: mouseover,
	touchstart: touchstart,
	touchend: touchend,
	touchmove: touchmove,
	resize: resize,
	scroll: scroll
});

[Methods, Scroll, Animate, eventShortcuts].forEach((group) => {
  Object.keys(group).forEach((methodName) => {
    $$1.fn[methodName] = group[methodName];
  });
});

/* harmony default export */ __webpack_exports__["a"] = ($$1);


/***/ }),

/***/ "./node_modules/framework7-vue/dist/framework7-vue.esm.bundle.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Framework7 Vue 2.2.5
 * Build full featured iOS & Android apps using Framework7 & Vue
 * http://framework7.io/vue/
 *
 * Copyright 2014-2018 Vladimir Kharlampidi
 *
 * Released under the MIT License
 *
 * Released on: April 29, 2018
 */

const Utils = {
  isTrueProp(val) {
    return val === true || val === '';
  },
  isStringProp(val) {
    return typeof val === 'string' && val !== '';
  },
  isObject(o) {
    return typeof o === 'object' && o !== null && o.constructor && o.constructor === Object;
  },
  now() {
    return Date.now();
  },
  extend(...args) {
    let deep = true;
    let to;
    let from;
    if (typeof args[0] === 'boolean') {
      [deep, to] = args;
      args.splice(0, 2);
      from = args;
    } else {
      [to] = args;
      args.splice(0, 1);
      from = args;
    }
    for (let i = 0; i < from.length; i += 1) {
      const nextSource = args[i];
      if (nextSource !== undefined && nextSource !== null) {
        const keysArray = Object.keys(Object(nextSource));
        for (let nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {
          const nextKey = keysArray[nextIndex];
          const desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
          if (desc !== undefined && desc.enumerable) {
            if (!deep) {
              to[nextKey] = nextSource[nextKey];
            } else if (Utils.isObject(to[nextKey]) && Utils.isObject(nextSource[nextKey])) {
              Utils.extend(to[nextKey], nextSource[nextKey]);
            } else if (!Utils.isObject(to[nextKey]) && Utils.isObject(nextSource[nextKey])) {
              to[nextKey] = {};
              Utils.extend(to[nextKey], nextSource[nextKey]);
            } else {
              to[nextKey] = nextSource[nextKey];
            }
          }
        }
      }
    }
    return to;
  },
};

const Directives = {};
['color', 'color-theme', 'text-color', 'bg-color', 'border-color', 'ripple-color'].forEach((name) => {
  Directives[`f7-${name}`] = function f7ColorDirective(el, binding) {
    const { value, oldValue } = binding;
    if (value === oldValue) return;
    if (!value && !oldValue) return;
    if (oldValue) {
      el.classList.remove(`${name}-${oldValue}`);
    }
    if (value) {
      el.classList.add(`${name}-${value}`);
    }
  };
});

/* eslint no-underscore-dangle: "off" */

let routerComponentIdCounter = 0;

var VueRouter = {
  proto: {
    pageComponentLoader(routerEl, component, componentUrl, options, resolve, reject) {
      const router = this;
      const el = router.$el[0];
      let routerVue;
      function findRouterVue(vueComponent) {
        if (routerVue) return;
        if (
          vueComponent.$vnode &&
          vueComponent.$vnode.tag &&
          vueComponent.$vnode.tag.indexOf('f7-view') >= 0 &&
          vueComponent.pages
        ) {
          routerVue = vueComponent;
          return;
        }
        if (!vueComponent.$children || vueComponent.$children.length === 0) return;
        vueComponent.$children.forEach((childComponent) => {
          findRouterVue(childComponent);
        });
      }

      findRouterVue(el.__vue__);

      if (!routerVue || !routerVue.pages) {
        reject();
        return;
      }
      const id = `${Utils.now()}_${(routerComponentIdCounter += 1)}`;
      const pageData = {
        component,
        id,
        params: Utils.extend({}, options.route.params),
      };
      routerVue.$f7route = options.route;
      routerVue.pages.push(pageData);
      routerVue.$nextTick(() => {
        const pageEl = el.children[el.children.length - 1];
        pageData.el = pageEl;

        let pageEvents;
        if (component.on) {
          let pageVueFound;
          let pageVue = pageEl.__vue__;
          while (pageVue.$parent && !pageVueFound) {
            if (pageVue.$parent.$el === pageEl) {
              pageVue = pageVue.$parent;
            } else {
              pageVueFound = true;
            }
          }
          if (pageVue) {
            pageEvents = Utils.extend({}, component.on);
            Object.keys(pageEvents).forEach((pageEvent) => {
              pageEvents[pageEvent] = pageEvents[pageEvent].bind(pageVue);
            });
          }
        }

        resolve(pageEl, { on: pageEvents });
      });
    },
    removePage($pageEl) {
      if (!$pageEl) return;
      const router = this;
      const routerVue = router.$el[0].__vue__;

      let pageEl;
      if ('length' in $pageEl) {
        // Dom7
        if ($pageEl.length === 0) return;
        pageEl = $pageEl[0];
      } else {
        pageEl = $pageEl;
      }
      if (!pageEl) return;
      let pageVueFound;
      routerVue.pages.forEach((page, index) => {
        if (page.el === pageEl) {
          pageVueFound = true;
          routerVue.pages.splice(index, 1);
        }
      });
      if (!pageVueFound) {
        pageEl.parentNode.removeChild(pageEl);
      }
    },
    tabComponentLoader(tabEl, component, componentUrl, options, resolve, reject) {
      if (!tabEl) reject();

      const tabVue = tabEl.__vue__;
      if (!tabVue) reject();

      const id = `${Utils.now()}_${(routerComponentIdCounter += 1)}`;
      tabVue.$set(tabVue, 'tabContent', {
        id,
        component,
        params: Utils.extend({}, options.route.params),
      });

      let pageEvents;
      if (component.on) {
        pageEvents = Utils.extend({}, component.on);
        Object.keys(pageEvents).forEach((pageEvent) => {
          pageEvents[pageEvent] = pageEvents[pageEvent].bind(tabVue);
        });
      }

      tabVue.$nextTick(() => {
        const tabContentEl = tabEl.children[0];
        resolve(tabContentEl, { on: pageEvents });
      });
    },
    removeTabContent(tabEl) {
      if (!tabEl) return;

      const tabVue = tabEl.__vue__;
      if (!tabVue) {
        tabEl.innerHTML = ''; // eslint-disable-line
        return;
      }

      tabVue.$set(tabVue, 'tabContent', null);
    },
    modalComponentLoader(rootEl, component, componentUrl, options, resolve, reject) {
      const router = this;
      const modalsEl = document.querySelector('.framework7-modals');
      if (!modalsEl) {
        reject();
        return;
      }

      const modalsVue = modalsEl.__vue__;
      if (!modalsVue) {
        reject();
        return;
      }

      const id = `${Utils.now()}_${(routerComponentIdCounter += 1)}`;
      const modalData = {
        component,
        id,
        params: Utils.extend({}, options.route.params),
      };
      modalsVue.$f7route = options.route;
      modalsVue.modals.push(modalData);

      modalsVue.$nextTick(() => {
        const modalEl = modalsEl.children[modalsEl.children.length - 1];
        modalData.el = modalEl;

        let modalEvents;
        let modalVueFound;
        let modalVue = modalEl.__vue__;
        while (modalVue.$parent && !modalVueFound) {
          if (modalVue.$parent.$el === modalEl) {
            modalVue = modalVue.$parent;
          } else {
            modalVueFound = true;
          }
        }
        if (component.on && modalVue) {
          modalEvents = Utils.extend({}, component.on);
          Object.keys(modalEvents).forEach((pageEvent) => {
            modalEvents[pageEvent] = modalEvents[pageEvent].bind(modalVue);
          });
        }

        modalEl.addEventListener('modal:closed', () => {
          modalsVue.$nextTick(() => {
            router.removeModal(modalEl, modalVue);
          });
        });

        resolve(modalEl, { on: modalEvents });
      });
    },
    removeModal(modalEl, modalVue) {
      if (!modalVue) return;

      const modalsEl = document.querySelector('.framework7-modals');
      if (!modalsEl) return;

      const modalsVue = modalsEl.__vue__;
      if (!modalsVue) return;

      let modalVueFound;
      modalsVue.modals.forEach((modal, index) => {
        if (modal.el === modalEl) {
          modalVueFound = true;
          modalsVue.modals.splice(index, 1);
        }
      });

      if (!modalVueFound) {
        modalEl.parentNode.removeChild(modalEl);
      }
    },
  },
};

const Mixins = {
  colorProps: {
    color: String,
    colorTheme: String,
    textColor: String,
    bgColor: String,
    borderColor: String,
    rippleColor: String,
    themeDark: Boolean,
  },
  colorClasses(self) {
    const {
      color,
      colorTheme,
      textColor,
      bgColor,
      borderColor,
      rippleColor,
      themeDark,
    } = self;

    return {
      'theme-dark': themeDark,
      [`color-${color}`]: color,
      [`color-theme-${colorTheme}`]: colorTheme,
      [`text-color-${textColor}`]: textColor,
      [`bg-color-${bgColor}`]: bgColor,
      [`border-color-${borderColor}`]: borderColor,
      [`ripple-color-${rippleColor}`]: rippleColor,
    };
  },
  linkIconProps: {
    icon: String,
    iconMaterial: String,
    iconIon: String,
    iconFa: String,
    iconF7: String,
    iconIfMd: String,
    iconIfIos: String,
    iconColor: String,
    iconSize: [String, Number],
  },
  linkRouterProps: {
    back: Boolean,
    external: Boolean,
    force: Boolean,
    animate: Boolean,
    ignoreCache: Boolean,
    pageName: String,
    reloadCurrent: Boolean,
    reloadAll: Boolean,
    reloadPrevious: Boolean,
    routeTabId: String,
    view: String,
  },
  linkRouterAttrs(self) {
    const {
      force,
      reloadCurrent,
      reloadPrevious,
      reloadAll,
      animate,
      ignoreCache,
      routeTabId,
      view,
    } = self;

    return {
      'data-force': force,
      'data-reload-current': reloadCurrent,
      'data-reload-all': reloadAll,
      'data-reload-previous': reloadPrevious,
      'data-animate': ('animate' in self.$options.propsData) ? animate.toString() : undefined,
      'data-ignore-cache': ignoreCache,
      'data-route-tab-id': routeTabId,
      'data-view': Utils.isStringProp(view) ? view : false,
    };
  },
  linkRouterClasses(self) {
    const { back, linkBack, external } = self;

    return {
      back: back || linkBack,
      external,
    };
  },
  linkActionsProps: {
    // Panel
    panelOpen: [Boolean, String],
    panelClose: [Boolean, String],

    // Popup
    popupOpen: [Boolean, String],
    popupClose: [Boolean, String],

    // Actions
    actionsOpen: [Boolean, String],
    actionsClose: [Boolean, String],

    // Popover
    popoverOpen: [Boolean, String],
    popoverClose: [Boolean, String],

    // Login Screen
    loginScreenOpen: [Boolean, String],
    loginScreenClose: [Boolean, String],

    // Picker
    sheetOpen: [Boolean, String],
    sheetClose: [Boolean, String],

    // Sortable
    sortableEnable: [Boolean, String],
    sortableDisable: [Boolean, String],
    sortableToggle: [Boolean, String],
  },
  linkActionsAttrs(self) {
    const {
      panelOpen,
      panelClose,
      popupOpen,
      popupClose,
      actionsOpen,
      actionsClose,
      popoverOpen,
      popoverClose,
      loginScreenOpen,
      loginScreenClose,
      sheetOpen,
      sheetClose,
      sortableEnable,
      sortableDisable,
      sortableToggle,
    } = self;

    return {
      'data-panel': (Utils.isStringProp(panelOpen) && panelOpen) ||
                    (Utils.isStringProp(panelClose) && panelClose),
      'data-popup': (Utils.isStringProp(popupOpen) && popupOpen) ||
                    (Utils.isStringProp(popupClose) && popupClose),
      'data-actions': (Utils.isStringProp(actionsOpen) && actionsOpen) ||
                    (Utils.isStringProp(actionsClose) && actionsClose),
      'data-popover': (Utils.isStringProp(popoverOpen) && popoverOpen) ||
                      (Utils.isStringProp(popoverClose) && popoverClose),
      'data-sheet': (Utils.isStringProp(sheetOpen) && sheetOpen) ||
                    (Utils.isStringProp(sheetClose) && sheetClose),
      'data-login-screen': (Utils.isStringProp(loginScreenOpen) && loginScreenOpen) ||
                           (Utils.isStringProp(loginScreenClose) && loginScreenClose),
      'data-sortable': (Utils.isStringProp(sortableEnable) && sortableEnable) ||
                       (Utils.isStringProp(sortableDisable) && sortableDisable) ||
                       (Utils.isStringProp(sortableToggle) && sortableToggle),
    };
  },
  linkActionsClasses(self) {
    const {
      panelOpen,
      panelClose,
      popupOpen,
      actionsClose,
      actionsOpen,
      popupClose,
      popoverOpen,
      popoverClose,
      loginScreenOpen,
      loginScreenClose,
      sheetOpen,
      sheetClose,
      sortableEnable,
      sortableDisable,
      sortableToggle,
    } = self;
    return {
      'panel-close': Utils.isTrueProp(panelClose),
      'panel-open': panelOpen || panelOpen === '',
      'popup-close': Utils.isTrueProp(popupClose),
      'popup-open': popupOpen || popupOpen === '',
      'actions-close': Utils.isTrueProp(actionsClose),
      'actions-open': actionsOpen || actionsOpen === '',
      'popover-close': Utils.isTrueProp(popoverClose),
      'popover-open': popoverOpen || popoverOpen === '',
      'sheet-close': Utils.isTrueProp(sheetClose),
      'sheet-open': sheetOpen || sheetOpen === '',
      'login-screen-close': Utils.isTrueProp(loginScreenClose),
      'login-screen-open': loginScreenOpen || loginScreenOpen === '',
      'sortable-enable': Utils.isTrueProp(sortableEnable),
      'sortable-disable': Utils.isTrueProp(sortableDisable),
      'sortable-toggle': sortableToggle === true || sortableToggle.length,
    };
  },
};

var f7AccordionContent = {render: function(){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"accordion-item-content",class:_vm.classes},[_vm._t("default")],2)},staticRenderFns: [],
  props: Mixins.colorProps,
  name: 'f7-accordion-content',
  computed: {
    classes() {
      const self = this;
      return Mixins.colorClasses(self);
    },
  },
};

const AccordionItemProps = Utils.extend(
  {
    opened: Boolean,
  },
  Mixins.colorProps
);

var f7AccordionItem = {render: function(){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"accordion-item",class:_vm.classes,on:{"accordion:open":_vm.onOpen,"accordion:opened":_vm.onOpened,"accordion:close":_vm.onClose,"accordion:closed":_vm.onClosed}},[_vm._t("default")],2)},staticRenderFns: [],
  name: 'f7-accordion-item',
  props: AccordionItemProps,
  computed: {
    classes() {
      const self = this;
      return Utils.extend(
        {
          'accordion-item-opened': self.opened,
        },
        Mixins.colorClasses(self)
      );
    },
  },
  methods: {
    onOpen(event) {
      this.$emit('accordion:open', event);
    },
    onOpened(event) {
      this.$emit('accordion:opened', event);
    },
    onClose(event) {
      this.$emit('accordion:close', event);
    },
    onClosed(event) {
      this.$emit('accordion:closed', event);
    },
  },
};

var f7AccordionToggle = {render: function(){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"accordion-item-toggle",class:_vm.classes},[_vm._t("default")],2)},staticRenderFns: [],
  props: Mixins.colorProps,
  name: 'f7-accordion-toggle',
  computed: {
    classes() {
      const self = this;
      return Mixins.colorClasses(self);
    },
  },
};

var f7Accordion = {render: function(){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"accordion-list",class:_vm.classes},[_vm._t("default")],2)},staticRenderFns: [],
  props: Mixins.colorProps,
  name: 'f7-accordion',
  computed: {
    classes() {
      const self = this;
      return Mixins.colorClasses(self);
    },
  },
};

const ActionsButtonProps = Utils.extend(
  {
    bold: Boolean,
    close: {
      type: Boolean,
      default: true,
    },
  },
  Mixins.colorProps
);

var f7ActionsButton = {
  name: 'f7-actions-button',
  render(c) {
    const self = this;
    let mediaEl;
    if (self.$slots.media && self.$slots.media.length) {
      mediaEl = c('div', {
        staticClass: 'actions-button-media',
      }, self.$slots.media);
    }
    const textEl = c('div', {
      staticClass: 'actions-button-text',
    }, self.$slots.default);

    return c('div', {
      staticClass: 'actions-button',
      class: self.classes,
      on: {
        click: self.onClick,
      },
    }, [mediaEl, textEl]);
  },
  props: ActionsButtonProps,
  computed: {
    classes() {
      const self = this;

      return Utils.extend({
        'actions-button-bold': self.bold,
      }, Mixins.colorClasses(self));
    },
  },
  methods: {
    onClick(event) {
      const self = this;
      const $$ = self.$$;
      if (self.close && self.$f7) {
        self.$f7.actions.close($$(self.$el).parents('.actions-modal'));
      }
      self.$emit('click', event);
    },
  },
};

var f7ActionsGroup = {
  name: 'f7-actions-group',
  render(c) {
    const self = this;
    return c('div', { staticClass: 'actions-group' }, self.$slots.default);
  },
};

const ActionsLabelProps = Utils.extend(
  {
    bold: Boolean,
  },
  Mixins.colorProps
);
var f7ActionsLabel = {
  name: 'f7-actions-label',
  render(c) {
    const self = this;
    return c('div', {
      staticClass: 'actions-label',
      class: self.classes,
      on: {
        click: self.onClick,
      },
    }, self.$slots.default);
  },
  props: ActionsLabelProps,
  computed: {
    classes() {
      const self = this;
      return Utils.extend({
        'actions-button-bold': self.bold,
      }, Mixins.colorClasses(self));
    },
  },
  methods: {
    onClick(event) {
      this.$emit('click', event);
    },
  },
};

const ActionsProps = Utils.extend(
  {
    opened: Boolean,
    grid: Boolean,
    convertToPopover: Boolean,
    forceToPopover: Boolean,
    target: [String, Object],
  },
  Mixins.colorProps
);

var f7Actions = {
  name: 'f7-actions',
  render(c) {
    const self = this;

    return c('div', {
      staticClass: 'actions-modal',
      class: self.classes,
      on: {
        'actions:open': self.onOpen,
        'actions:opened': self.onOpened,
        'actions:close': self.onClose,
        'actions:closed': self.onClosed,
      },
    }, self.$slots.default);
  },
  watch: {
    opened(opened) {
      const self = this;
      if (!self.f7Actions) return;
      if (opened) {
        self.f7Actions.open();
      } else {
        self.f7Actions.close();
      }
    },
  },
  props: ActionsProps,
  computed: {
    classes() {
      const self = this;
      return Utils.extend({
        'actions-grid': self.grid,
      }, Mixins.colorClasses(self));
    },
  },
  beforeDestroy() {
    const self = this;
    if (self.f7Actions) self.f7Actions.destroy();
  },
  methods: {
    onOpen(event) {
      this.$emit('actions:open', event);
    },
    onOpened(event) {
      this.$emit('actions:opened', event);
    },
    onClose(event) {
      this.$emit('actions:close', event);
    },
    onClosed(event) {
      this.$emit('actions:closed', event);
    },
    open(animate) {
      const self = this;
      if (!self.$f7) return undefined;
      return self.$f7.actions.open(self.$el, animate);
    },
    close(animate) {
      const self = this;
      if (!self.$f7) return undefined;
      return self.$f7.actions.close(self.$el, animate);
    },
    onF7Ready() {
      const self = this;

      const actionsParams = {
        el: self.$el,
        grid: self.grid,
      };
      if (self.target) actionsParams.targetEl = self.target;
      if (typeof self.$options.propsData.convertToPopover !== 'undefined') actionsParams.convertToPopover = self.convertToPopover;
      if (typeof self.$options.propsData.forceToPopover !== 'undefined') actionsParams.forceToPopover = self.forceToPopover;

      self.f7Actions = self.$f7.actions.create(actionsParams);

      if (self.opened) {
        self.f7Actions.open(false);
      }
    },
  },
};

var f7Badge = {render: function(){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('span',{staticClass:"badge",class:_vm.classes},[_vm._t("default")],2)},staticRenderFns: [],
  props: Mixins.colorProps,
  name: 'f7-badge',
  computed: {
    classes() {
      const self = this;
      return Mixins.colorClasses(self);
    },
  },
};

var f7BlockFooter = {render: function(){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"block-footer",class:_vm.classes},[_vm._t("default")],2)},staticRenderFns: [],
  name: 'f7-block-footer',
  props: Mixins.colorProps,
  computed: {
    classes() {
      const self = this;
      return Mixins.colorClasses(self);
    },
  },
};

var f7BlockHeader = {render: function(){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"block-header",class:_vm.classes},[_vm._t("default")],2)},staticRenderFns: [],
  props: Mixins.colorProps,
  name: 'f7-block-header',
  computed: {
    classes() {
      const self = this;
      return Mixins.colorClasses(self);
    },
  },
};

var f7BlockTitle = {render: function(){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"block-title",class:_vm.classes},[_vm._t("default")],2)},staticRenderFns: [],
  props: Mixins.colorProps,
  name: 'f7-block-title',
  computed: {
    classes() {
      const self = this;
      return Mixins.colorClasses(self);
    },
  },
};

const BlockProps = Utils.extend(
  {
    inset: Boolean,
    tabletInset: Boolean,
    strong: Boolean,
    tabs: Boolean,
    tab: Boolean,
    tabActive: Boolean,
    accordionList: Boolean,
    noHairlines: Boolean,
    noHairlinesMd: Boolean,
    noHairlinesIos: Boolean,
  },
  Mixins.colorProps
);

var f7Block = {render: function(){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"block",class:_vm.classes,on:{"tab:show":_vm.onTabShow,"tab:hide":_vm.onTabHide}},[_vm._t("default")],2)},staticRenderFns: [],
  name: 'f7-block',
  props: BlockProps,
  computed: {
    classes() {
      const self = this;
      return Utils.extend(
        {
          inset: self.inset,
          'block-strong': self.strong,
          'accordion-list': self.accordionList,
          'tablet-inset': self.tabletInset,
          tabs: self.tabs,
          tab: self.tab,
          'tab-active': self.tabActive,
          'no-hairlines': self.noHairlines,
          'no-hairlines-md': self.noHairlinesMd,
          'no-hairlines-ios': self.noHairlinesIos,
        },
        Mixins.colorClasses(self)
      );
    },
  },
  methods: {
    onTabShow(e) {
      this.$emit('tab:show', e);
    },
    onTabHide(e) {
      this.$emit('tab:hide', e);
    },
  },
};

const IconProps = Utils.extend(
  {
    material: String, // Material Icons
    f7: String, // Framework7 Icons
    ion: String, // Ionicons
    fa: String, // Font Awesome
    icon: String, // Custom
    ifMd: String,
    ifIos: String,
    size: [String, Number],
  },
  Mixins.colorProps
);

var f7Icon = {render: function(){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('i',{staticClass:"icon",class:_vm.classes,style:({'font-size':_vm.sizeComputed})},[_vm._v(_vm._s(_vm.iconTextComputed)),_vm._t("default")],2)},staticRenderFns: [],
  name: 'f7-icon',
  props: IconProps,
  computed: {
    sizeComputed() {
      const self = this;
      let size = self.size;
      if (typeof size === 'number' || parseFloat(size) === size * 1) {
        size = `${size}px`;
      }
      return size;
    },
    iconTextComputed() {
      const self = this;
      let text = self.material || self.f7;
      if (self.ifMd && self.$theme.md && (self.ifMd.indexOf('material:') >= 0 || self.ifMd.indexOf('f7:') >= 0)) {
        text = self.ifMd.split(':')[1];
      } else if (self.ifIos && self.$theme.ios && (self.ifIos.indexOf('material:') >= 0 || self.ifIos.indexOf('f7:') >= 0)) {
        text = self.ifIos.split(':')[1];
      }
      return text;
    },
    classes() {
      let classes = {};
      const self = this;
      if (self.ifMd || self.ifIos) {
        const parts = self[self.$theme.md ? 'ifMd' : 'ifIos'].split(':');
        const prop = parts[0];
        const value = parts[1];
        if (prop === 'material' || prop === 'fa' || prop === 'f7') {
          classes.fa = prop === 'fa';
          classes['material-icons'] = prop === 'material';
          classes['f7-icons'] = prop === 'f7';
        }
        if (prop === 'fa' || prop === 'ion') {
          classes[`${prop}-${value}`] = true;
        }
        if (prop === 'icon') {
          classes[value] = true;
        }
      } else {
        classes = {
          'material-icons': this.material,
          'f7-icons': this.f7,
          fa: this.fa,
        };
        if (this.ion) classes[`ion-${this.ion}`] = true;
        if (this.fa) classes[`fa-${this.fa}`] = true;
        if (this.icon) classes[this.icon] = true;
      }
      return Utils.extend(classes, Mixins.colorClasses(self));
    },
  },
};

const ButtonProps = Utils.extend(
  {
    noFastclick: Boolean,
    noFastClick: Boolean,
    text: String,
    tabLink: [Boolean, String],
    tabLinkActive: Boolean,
    href: {
      type: [String, Boolean],
      default: '#',
    },

    round: Boolean,
    roundMd: Boolean,
    roundIos: Boolean,
    fill: Boolean,
    fillMd: Boolean,
    fillIos: Boolean,
    big: Boolean,
    bigMd: Boolean,
    bigIos: Boolean,
    small: Boolean,
    smallMd: Boolean,
    smallIos: Boolean,
    raised: Boolean,
    outline: Boolean,
    active: Boolean,
    disabled: Boolean,
  },
  Mixins.colorProps,
  Mixins.linkIconProps,
  Mixins.linkRouterProps,
  Mixins.linkActionsProps
);

var f7Button = {
  name: 'f7-button',
  components: {
    f7Icon,
  },
  props: ButtonProps,
  render(c) {
    const self = this;
    let iconEl;
    let textEl;
    if (self.text) {
      textEl = c('span', {}, self.text);
    }
    if (self.icon || self.iconMaterial || self.iconIon || self.iconFa || self.iconF7 || self.iconIfMd || self.iconIfIos) {
      iconEl = c('f7-icon', {
        props: {
          material: self.iconMaterial,
          ion: self.iconIon,
          fa: self.iconFa,
          f7: self.iconF7,
          icon: self.icon,
          ifMd: self.iconIfMd,
          ifIos: self.iconIfIos,
          color: self.iconColor,
          size: self.iconSize,
        },
      });
    }
    self.classes.button = true;
    const linkEl = c('a', {
      class: self.classes,
      attrs: self.attrs,
      on: {
        click: self.onClick,
      },
    }, [iconEl, textEl, self.$slots.default]);

    return linkEl;
  },
  computed: {
    attrs() {
      const self = this;
      const { href, target, tabLink } = self;
      let hrefComputed = href;
      if (href === true) hrefComputed = '#';
      if (href === false) hrefComputed = undefined; // no href attribute
      return Utils.extend(
        {
          href: hrefComputed,
          target,
          'data-tab': Utils.isStringProp(tabLink) && tabLink,
        },
        Mixins.linkRouterAttrs(self),
        Mixins.linkActionsAttrs(self)
      );
    },
    classes() {
      const self = this;
      const {
        noFastclick,
        noFastClick,
        tabLink,
        tabLinkActive,
        round,
        roundIos,
        roundMd,
        fill,
        fillIos,
        fillMd,
        big,
        bigIos,
        bigMd,
        small,
        smallIos,
        smallMd,
        raised,
        active,
        outline,
        disabled,
      } = self;

      return Utils.extend(
        {
          'tab-link': tabLink || tabLink === '',
          'tab-link-active': tabLinkActive,
          'no-fastclick': noFastclick || noFastClick,

          'button-round': round,
          'button-round-ios': roundIos,
          'button-round-md': roundMd,
          'button-fill': fill,
          'button-fill-ios': fillIos,
          'button-fill-md': fillMd,
          'button-big': big,
          'button-big-ios': bigIos,
          'button-big-md': bigMd,
          'button-small': small,
          'button-small-ios': smallIos,
          'button-small-md': smallMd,
          'button-raised': raised,
          'button-active': active,
          'button-outline': outline,

          disabled,
        },
        Mixins.colorClasses(self),
        Mixins.linkRouterClasses(self),
        Mixins.linkActionsClasses(self)
      );
    },
  },
  methods: {
    onClick(event) {
      this.$emit('click', event);
    },
  },
};

const CardContentProps = Utils.extend(
  {
    padding: {
      type: Boolean,
      default: true,
    },
  },
  Mixins.colorProps
);

var f7CardContent = {render: function(){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"card-content",class:_vm.classes},[_vm._t("default")],2)},staticRenderFns: [],
  name: 'f7-card-content',
  props: CardContentProps,
  computed: {
    classes() {
      const self = this;
      return Utils.extend(
        {
          'card-content-padding': self.padding,
        },
        Mixins.colorClasses(self)
      );
    },
  },
};

var f7CardFooter = {render: function(){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"card-footer",class:_vm.classes},[_vm._t("default")],2)},staticRenderFns: [],
  props: Mixins.colorProps,
  name: 'f7-card-footer',
  computed: {
    classes() {
      const self = this;
      return Mixins.colorClasses(self);
    },
  },
};

var f7CardHeader = {render: function(){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"card-header",class:_vm.classes},[_vm._t("default")],2)},staticRenderFns: [],
  props: Mixins.colorProps,
  name: 'f7-card-header',
  computed: {
    classes() {
      const self = this;
      return Mixins.colorClasses(self);
    },
  },
};

const CardProps = Utils.extend(
  {
    title: [String, Number],
    content: [String, Number],
    footer: [String, Number],
    padding: {
      type: Boolean,
      default: true,
    },
  },
  Mixins.colorProps
);

var f7Card = {
  name: 'f7-card',
  components: {
    f7CardHeader,
    f7CardContent,
    f7CardFooter,
  },
  props: CardProps,
  render(c) {
    const self = this;
    let headerEl;
    let contentEl;
    let footerEl;

    if (self.title || (self.$slots && self.$slots.header)) {
      headerEl = c('f7-card-header', [self.title, self.$slots.header]);
    }
    if (self.content || (self.$slots && self.$slots.content)) {
      contentEl = c('f7-card-content', { props: { padding: self.padding } }, [self.content, self.$slots.content]);
    }
    if (self.footer || (self.$slots && self.$slots.footer)) {
      footerEl = c('f7-card-footer', [self.footer, self.$slots.footer]);
    }
    return c('div', { staticClass: 'card', class: self.classes }, [headerEl, contentEl, footerEl, self.$slots.default]);
  },
  computed: {
    classes() {
      const self = this;
      return Mixins.colorClasses(self);
    },
  },
};

const CheckboxProps = Utils.extend({
  checked: Boolean,
  name: [Number, String],
  value: [Number, String, Boolean],
  disabled: Boolean,
  readonly: Boolean,
}, Mixins.colorProps);

var f7Checkbox = {
  name: 'f7-checkbox',
  props: CheckboxProps,
  render(c) {
    const self = this;

    const inputEl = c('input', {
      attrs: {
        type: 'checkbox',
        name: self.name,
      },
      domProps: {
        value: self.value,
        disabled: self.disabled,
        readonly: self.readonly,
        checked: self.checked,
      },
      on: {
        change: self.onChange,
      },
    });

    const iconEl = c('i', { staticClass: 'icon-checkbox' });

    return c('label', {
      staticClass: 'checkbox',
      class: self.classes,
    }, [inputEl, iconEl, self.$slots.default]);
  },
  computed: {
    classes() {
      const self = this;
      return Utils.extend(
        {
          disabled: self.disabled,
        },
        Mixins.colorClasses(self)
      );
    },
  },
  methods: {
    onChange(event) {
      this.$emit('change', event);
    },
  },
};

const ChipProps = Utils.extend({
  media: String,
  text: [String, Number],
  deleteable: Boolean,
  mediaBgColor: String,
  mediaTextColor: String,
}, Mixins.colorProps);

var f7Chip = {
  name: 'f7-chip',
  props: ChipProps,
  render(c) {
    const self = this;
    let mediaEl;
    let labelEl;
    let deleteEl;
    if (self.media || (self.$slots && self.$slots.media)) {
      mediaEl = c('div', { staticClass: 'chip-media', class: self.mediaClasses }, self.media || self.$slots.media);
    }
    if (self.text || (self.$slots && self.$slots.text)) {
      labelEl = c('div', { staticClass: 'chip-label' }, [self.text, self.$slots.text]);
    }
    if (self.deleteable) {
      deleteEl = c('a', {
        staticClass: 'chip-delete',
        attrs: {
          href: '#',
        },
        on: {
          click: self.onDeleteClick,
        },
      });
    }
    return c('div', {
      staticClass: 'chip',
      class: self.classes,
      on: {
        click: self.onClick,
      },
    }, [mediaEl, labelEl, deleteEl]);
  },
  computed: {
    classes() {
      const self = this;
      return Mixins.colorClasses(self);
    },
    mediaClasses() {
      const c = {};
      if (this.mediaTextColor) c[`text-color-${this.mediaTextColor}`] = true;
      if (this.mediaBgColor) c[`bg-color-${this.mediaBgColor}`] = true;
      return c;
    },
  },
  methods: {
    onClick(event) {
      this.$emit('click', event);
    },
    onDeleteClick(event) {
      this.$emit('delete', event);
    },
  },
};

const ColProps = Utils.extend(
  {
    tag: {
      type: String,
      default: 'div',
    },
    width: {
      type: [Number, String],
      default: 'auto',
    },
    tabletWidth: {
      type: [Number, String],
    },
    desktopWidth: {
      type: [Number, String],
    },
  },
  Mixins.colorProps
);

var f7Col = {
  name: 'f7-col',
  props: ColProps,
  render(c) {
    const self = this;
    return c(self.tag, {
      class: self.classes,
    }, [self.$slots.default]);
  },
  computed: {
    classes() {
      const self = this;
      return Utils.extend(
        {
          col: self.width === 'auto',
          [`col-${self.width}`]: self.width !== 'auto',
          [`tablet-${self.tabletWidth}`]: self.tabletWidth,
          [`desktop-${self.desktopWidth}`]: self.desktopWidth,
        },
        Mixins.colorClasses(self)
      );
    },
  },
};

const FabButtonProps = Utils.extend(
  {
    fabClose: Boolean,
  },
  Mixins.colorProps
);

var f7FabButton = {render: function(){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('a',{class:_vm.classes,on:{"click":_vm.onClick}},[_vm._t("default")],2)},staticRenderFns: [],
  name: 'f7-fab-button',
  props: FabButtonProps,
  computed: {
    classes() {
      const self = this;
      return Utils.extend(
        {
          'fab-close': self.fabClose,
        },
        Mixins.colorClasses(self)
      );
    },
  },
  methods: {
    onClick(event) {
      this.$emit('click', event);
    },
  },
};

const FabButtonsProps = Utils.extend(
  {
    position: {
      type: String,
      default: 'top',
    },
  },
  Mixins.colorProps
);

var f7FabButtons = {render: function(){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"fab-buttons",class:_vm.classes},[_vm._t("default")],2)},staticRenderFns: [],
  name: 'f7-fab-buttons',
  props: FabButtonsProps,
  computed: {
    classes() {
      const self = this;
      return Utils.extend(
        {
          [`fab-buttons-${self.position}`]: true,
        },
        Mixins.colorClasses(self)
      );
    },
  },
};

const FabProps = Utils.extend(
  {
    morphTo: String,
    href: [Boolean, String],
    position: {
      type: String,
      default: 'right-bottom',
    },
  },
  Mixins.colorProps
);

var f7Fab = {
  name: 'f7-fab',
  props: FabProps,
  render(c) {
    const self = this;

    let href = self.href;
    if (href === true) href = '#';
    if (href === false) href = undefined; // no href attribute

    const linkChildren = [];
    const fabChildren = [];

    if (self.$slots.default) {
      for (let i = 0; i < self.$slots.default.length; i += 1) {
        const child = self.$slots.default[i];
        if (child.tag && child.tag.indexOf('fab-buttons') >= 0) {
          fabChildren.push(child);
        } else {
          linkChildren.push(child);
        }
      }
    }

    const linkEl = c('a', {
      attrs: {
        href,
      },
      on: {
        click: self.onClick,
      },
    }, linkChildren);

    fabChildren.push(linkEl);

    return c('div', {
      staticClass: 'fab',
      class: self.classes,
      attrs: {
        'data-morph-to': self.morphTo,
      },
    }, fabChildren);
  },
  computed: {
    classes() {
      const self = this;
      return Utils.extend(
        {
          'fab-morph': self.morphTo,
          [`fab-${self.position}`]: true,
        },
        Mixins.colorClasses(self)
      );
    },
  },
  methods: {
    onClick(event) {
      const self = this;
      self.$emit('click', event);
    },
  },
};

const ToggleProps = Utils.extend({
  init: {
    type: Boolean,
    default: true,
  },
  checked: Boolean,
  disabled: Boolean,
  readonly: Boolean,
  name: String,
  value: [String, Number, Array],
}, Mixins.colorProps);

var f7Toggle = {
  name: 'f7-toggle',
  render(c) {
    const self = this;

    return c('label', {
      staticClass: 'toggle',
      class: Utils.extend(
        {
          disabled: self.disabled,
        },
        Mixins.colorClasses(self)
      ),
    }, [
      c('input', {
        attrs: {
          type: 'checkbox',
          name: self.name,
        },
        domProps: {
          disabled: self.disabled,
          readonly: self.readonly,
          checked: self.checked,
          value: self.value,
        },
        on: {
          change: self.onChange,
        },
      }),
      c('span', { staticClass: 'toggle-icon' }),
    ]);
  },
  props: ToggleProps,
  watch: {
    checked(newValue) {
      const self = this;
      if (!self.f7Toggle) return;
      self.f7Toggle.checked = newValue;
    },
  },
  beforeDestroy() {
    const self = this;
    if (self.f7Toggle && self.f7Toggle.destroy && self.f7Toggle.$el) self.f7Toggle.destroy();
  },
  methods: {
    toggle() {
      const self = this;
      if (self.f7Toggle && self.f7Toggle.setValue) self.f7Toggle.toggle();
    },
    onChange(e) {
      const self = this;
      self.$emit('change', e);
    },
    onF7Ready(f7) {
      const self = this;
      if (!self.init) return;
      self.$nextTick(() => {
        self.f7Toggle = f7.toggle.create({
          el: self.$el,
          on: {
            change(toggle) {
              self.$emit('toggle:change', toggle.checked);
            },
          },
        });
      });
    },
  },
};

const RangeProps = Utils.extend({
  init: {
    type: Boolean,
    default: true,
  },
  value: {
    type: [Number, Array, String],
    default: 0,
  },
  min: {
    type: [Number, String],
    default: 0,
  },
  max: {
    type: [Number, String],
    default: 100,
  },
  step: {
    type: [Number, String],
    default: 1,
  },
  label: {
    type: Boolean,
    default: false,
  },
  dual: {
    type: Boolean,
    default: false,
  },
  disabled: Boolean,
  draggableBar: {
    type: Boolean,
    default: true,
  },
}, Mixins.colorProps);

var f7Range = {
  name: 'f7-range',
  render(c) {
    const self = this;

    return c('div', {
      staticClass: 'range-slider',
      class: Utils.extend({
        disabled: self.disabled,
      }, Mixins.colorClasses(self)),
    });
  },
  props: RangeProps,
  watch: {
    value(newValue) {
      const self = this;
      if (!self.f7Range) return;
      self.f7Range.setValue(newValue);
    },
  },
  beforeDestroy() {
    const self = this;
    if (self.f7Range && self.f7Range.destroy) self.f7Range.destroy();
  },
  methods: {
    setValue(newValue) {
      const self = this;
      if (self.f7Range && self.f7Range.setValue) self.f7Range.setValue(newValue);
    },
    getValue() {
      const self = this;
      if (self.f7Range && self.f7Range.getValue) {
        return self.f7Range.getValue();
      }
      return undefined;
    },
    onF7Ready(f7) {
      const self = this;
      if (!self.init) return;
      self.$nextTick(() => {
        self.f7Range = f7.range.create({
          el: self.$el,
          value: self.value,
          min: self.min,
          max: self.max,
          step: self.step,
          label: self.label,
          dual: self.dual,
          draggableBar: self.draggableBar,
          on: {
            change(range, value) {
              self.$emit('range:change', value);
            },
            changed(range, value) {
              self.$emit('range:changed', value);
            },
          },
        });
      });
    },
  },
};

const InputProps = Utils.extend(
  {
    // Inputs
    type: String,
    name: String,
    value: [String, Number, Array],
    placeholder: String,
    id: String,
    size: [String, Number],
    accept: [String, Number],
    autocomplete: [String],
    autocorrect: [String],
    autocapitalize: [String],
    spellcheck: [String],
    autofocus: Boolean,
    autosave: String,
    checked: Boolean,
    disabled: Boolean,
    max: [String, Number],
    min: [String, Number],
    step: [String, Number],
    maxlength: [String, Number],
    minlength: [String, Number],
    multiple: Boolean,
    readonly: Boolean,
    required: Boolean,
    inputStyle: String,
    pattern: String,
    validate: Boolean,
    tabindex: [String, Number],
    resizable: Boolean,
    clearButton: Boolean,

    // Error, Info
    errorMessage: String,
    info: String,

    // Components
    wrap: {
      type: Boolean,
      default: true,
    },
  },
  Mixins.colorProps
);

var f7Input = {
  name: 'f7-input',
  components: {
    f7Toggle,
    f7Range,
  },
  props: InputProps,
  render(c) {
    let inputEl;
    const self = this;
    const attrs = {
      name: self.name,
      type: self.type,
      placeholder: self.placeholder,
      id: self.id,
      value: self.value,
      size: self.size,
      accept: self.accept,
      autocomplete: self.autocomplete,
      autocorrect: self.autocorrect,
      autocapitalize: self.autocapitalize,
      spellcheck: self.spellcheck,
      autofocus: self.autofocus,
      autosave: self.autosave,
      checked: self.checked,
      disabled: self.disabled,
      max: self.max,
      maxlength: self.maxlength,
      min: self.min,
      minlength: self.minlength,
      step: self.step,
      multiple: self.multiple,
      readonly: self.readonly,
      required: self.required,
      pattern: self.pattern,
      validate: self.validate,
      tabindex: self.tabindex,
      'data-error-message': self.errorMessage,
    };
    const on = {
      focus: self.onFocus,
      blur: self.onBlur,
      input: self.onInput,
      change: self.onChange,
      'textarea:resize': self.onTextareaResize,
      'input:notempty': self.onInputNotEmpty,
      'input:empty': self.onInputEmpty,
      'input:clear': self.onInputClear,
    };
    if (self.type === 'select' || self.type === 'textarea' || self.type === 'file') {
      delete attrs.value;
      if (self.type === 'select') {
        inputEl = c('select', {
          attrs, on, style: self.inputStyle, domProps: { value: self.value },
        }, self.$slots.default);
      } else if (self.type === 'file') {
        inputEl = c('input', { attrs, style: self.inputStyle, on }, self.$slots.default);
      } else {
        inputEl = c('textarea', {
          attrs,
          style: self.inputStyle,
          on,
          class: { resizable: self.resizable },
          domProps: { value: self.value },
        }, self.$slots.default);
      }
    } else if ((self.$slots.default && self.$slots.default.length > 0) || !self.type) {
      inputEl = self.$slots.default;
    } else if (self.type === 'toggle') {
      inputEl = c('f7-toggle', { props: attrs, on });
    } else if (self.type === 'range') {
      on['range:change'] = self.onChange;
      inputEl = c('f7-range', { props: attrs, on });
    } else {
      inputEl = c('input', {
        attrs,
        style: self.inputStyle,
        on,
        domProps: { value: self.value, checked: self.checked },
      });
    }

    let clearButtonEl;
    if (self.clearButton) {
      clearButtonEl = c('span', { staticClass: 'input-clear-button' });
    }

    let $parent = self.$parent;
    let foundItemContent;
    while ($parent && !foundItemContent) {
      const tag = $parent.$vnode && $parent.$vnode.tag;
      if (tag && (tag.indexOf('list-item') > 0 || tag.indexOf('list-item-content') > 0)) {
        foundItemContent = $parent;
      }
      $parent = $parent.$parent;
    }
    if (foundItemContent) foundItemContent.itemInputForced = true;
    if (foundItemContent && (self.info || (self.$slots.info && self.$slots.info.length))) foundItemContent.itemInputWithInfoForced = true;

    let infoEl;
    if (self.info || (self.$slots.info && self.$slots.info.length)) {
      infoEl = c('div', { staticClass: 'item-input-info' }, [self.info, self.$slots.info]);
    }

    const itemInput = self.wrap ? c('div', { staticClass: 'item-input-wrap', class: self.classes }, [inputEl, clearButtonEl, infoEl]) : inputEl;
    return itemInput;
  },
  computed: {
    classes() {
      const self = this;
      return Mixins.colorClasses(self);
    },
  },
  watch: {
    value() {
      const self = this;
      if (self.type === 'range' || self.type === 'toggle') return;
      const f7 = self.$f7;
      if (!f7) return;
      const inputEl = self.wrap ? self.$el.querySelector('input, select, textarea') : self.$el;
      self.$nextTick(() => {
        f7.input.checkEmptyState(inputEl);
        if (self.validate) {
          f7.input.validate(inputEl);
        }
        if (self.resizable) {
          f7.input.resizeTextarea(inputEl);
        }
      });
    },
  },
  methods: {
    onF7Ready(f7) {
      const self = this;
      const inputEl = self.wrap ? self.$el.querySelector('input, select, textarea') : self.$el;
      f7.input.checkEmptyState(inputEl);
      if (self.validate) {
        f7.input.validate(inputEl);
      }
      if (self.resizable) {
        f7.input.resizeTextarea(inputEl);
      }
    },
    onTextareaResize(event) {
      this.$emit('textarea:resize', event);
    },
    onInputNotEmpty(event) {
      this.$emit('input:notempty', event);
    },
    onInputEmpty(event) {
      this.$emit('input:empty', event);
    },
    onInputClear(event) {
      this.$emit('input:clear', event);
    },
    onInput(event) {
      this.$emit('input', event);
    },
    onFocus(event) {
      this.$emit('focus', event);
    },
    onBlur(event) {
      this.$emit('blur', event);
    },
    onChange(event) {
      const self = this;
      self.$emit('change', event);
    },
  },
};

const LabelProps = Utils.extend(
  {
    floating: Boolean,
    inline: Boolean,
  },
  Mixins.colorProps
);

var f7Label = {
  name: 'f7-label',
  props: LabelProps,
  render(c) {
    const self = this;

    if (self.inline) {
      let $parent = self.$parent;
      let foundItemContent;
      while ($parent && !foundItemContent) {
        const tag = $parent.$vnode && $parent.$vnode.tag;
        if (tag && (tag.indexOf('list-item') > 0 || tag.indexOf('list-item-content') > 0)) {
          foundItemContent = $parent;
        }
        $parent = $parent.$parent;
      }
      if (foundItemContent) foundItemContent.inlineLabelForced = true;
    }

    return c('div', {
      staticClass: 'item-title',
      class: self.classes,
    }, [self.$slots.default]);
  },
  computed: {
    classes() {
      const self = this;
      return Utils.extend(
        {
          'item-label': !self.floating,
          'item-floating-label': self.floating,
        },
        Mixins.colorClasses(self)
      );
    },
  },
};

const LinkProps = Utils.extend(
  {
    noLinkClass: Boolean,
    noFastClick: Boolean,
    noFastclick: Boolean,
    text: String,
    tabLink: [Boolean, String],
    tabLinkActive: Boolean,
    iconOnly: Boolean,
    badge: [String, Number],
    badgeColor: [String],
    iconBadge: [String, Number],
    href: {
      type: [String, Boolean],
      default: '#',
    },
  },
  Mixins.colorProps,
  Mixins.linkIconProps,
  Mixins.linkRouterProps,
  Mixins.linkActionsProps
);

var f7Link = {
  name: 'f7-link',
  components: {
    f7Badge,
    f7Icon,
  },
  props: LinkProps,
  render(c) {
    const self = this;
    const isTabbarLabel = (self.tabLink || self.tabLink === '') && self.$parent && self.$parent.tabbar && self.$parent.labels;

    let iconEl;
    let textEl;
    let badgeEl;
    let iconBadgeEl;

    if (self.text) {
      if (self.badge) badgeEl = c('f7-badge', { props: { color: self.badgeColor } }, self.badge);
      textEl = c('span', { class: { 'tabbar-label': isTabbarLabel } }, [self.text, badgeEl]);
    }
    if (self.icon || self.iconMaterial || self.iconIon || self.iconFa || self.iconF7 || (self.iconIfMd && self.$theme.md) || (self.iconIfIos && self.$theme.ios)) {
      if (self.iconBadge) iconBadgeEl = c('f7-badge', { props: { color: self.badgeColor } }, self.iconBadge);
      iconEl = c('f7-icon', {
        props: {
          material: self.iconMaterial,
          ion: self.iconIon,
          fa: self.iconFa,
          f7: self.iconF7,
          icon: self.icon,
          ifMd: self.iconIfMd,
          ifIos: self.iconIfIos,
          color: self.iconColor,
          size: self.iconSize,
        },
      }, [iconBadgeEl]);
    }
    if (
      self.iconOnly ||
      (!self.text && self.$slots.default && self.$slots.default.length === 0) ||
      (!self.text && !self.$slots.default)
    ) {
      self.classes['icon-only'] = true;
    }
    self.classes.link = !(self.noLinkClass || isTabbarLabel);
    const linkEl = c('a', {
      class: self.classes,
      attrs: self.attrs,
      on: {
        click: self.onClick,
      },
    }, [iconEl, textEl, self.$slots.default]);
    return linkEl;
  },
  computed: {
    attrs() {
      const self = this;
      const { href, target, tabLink } = self;
      let hrefComputed = href;
      if (href === true) hrefComputed = '#';
      if (href === false) hrefComputed = undefined; // no href attribute
      return Utils.extend(
        {
          href: hrefComputed,
          target,
          'data-tab': Utils.isStringProp(tabLink) && tabLink,
        },
        Mixins.linkRouterAttrs(self),
        Mixins.linkActionsAttrs(self)
      );
    },
    classes() {
      const self = this;
      const {
        noFastclick,
        noFastClick,
        tabLink,
        tabLinkActive,
      } = self;

      return Utils.extend(
        {
          'tab-link': tabLink || tabLink === '',
          'tab-link-active': tabLinkActive,
          'no-fastclick': noFastclick || noFastClick,
        },
        Mixins.colorClasses(self),
        Mixins.linkRouterClasses(self),
        Mixins.linkActionsClasses(self)
      );
    },
  },
  methods: {
    onClick(event) {
      this.$emit('click', event);
    },
  },
};

const ListButtonProps = Utils.extend(
  {
    noFastclick: Boolean,
    noFastClick: Boolean,
    title: [String, Number],
    text: [String, Number],
    tabLink: [Boolean, String],
    tabLinkActive: Boolean,
    link: [Boolean, String],
    href: [Boolean, String],
    target: String,
  },
  Mixins.colorProps,
  Mixins.linkRouterProps,
  Mixins.linkActionsProps
);

var f7ListButton = {
  name: 'f7-list-button',
  render(c) {
    const self = this;
    const linkEl = c('a', {
      staticClass: 'item-link list-button',
      attrs: self.attrs,
      class: self.classes,
      on: {
        click: self.onClick,
      },
    }, [self.title || self.text, self.$slots.default]);
    return c('li', {}, [linkEl]);
  },
  props: ListButtonProps,
  computed: {
    attrs() {
      const self = this;
      // Link Props
      const {
        link,
        href,
        target,
        tabLink,
      } = self;

      return Utils.extend(
        {
          href: ((typeof link === 'boolean' && typeof href === 'boolean') ? '#' : (link || href)),
          target,
          'data-tab': Utils.isStringProp(tabLink) && tabLink,
        },
        Mixins.linkRouterAttrs(self),
        Mixins.linkActionsAttrs(self)
      );
    },
    classes() {
      const self = this;

      const {
        noFastclick,
        noFastClick,
        tabLink,
        tabLinkActive,
      } = self;

      return Utils.extend(
        {
          'tab-link': tabLink || tabLink === '',
          'tab-link-active': tabLinkActive,
          'no-fastclick': noFastclick || noFastClick,
        },
        Mixins.colorClasses(self),
        Mixins.linkRouterClasses(self),
        Mixins.linkActionsClasses(self)
      );
    },
  },
  methods: {
    onClick(event) {
      this.$emit('click', event);
    },
  },
};

const ListGroupProps = Utils.extend(
  {
    mediaList: Boolean,
    sortable: Boolean,
  },
  Mixins.colorProps
);

var f7ListGroup = {render: function(){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"list-group",class:_vm.classes},[_c('ul',[_vm._t("default")],2)])},staticRenderFns: [],
  name: 'f7-list-group',
  props: ListGroupProps,
  computed: {
    classes() {
      const self = this;
      return Mixins.colorClasses(self);
    },
    sortableComputed() {
      return this.sortable || this.$parent.sortable;
    },
    mediaListComputed() {
      return this.mediaList || this.$parent.mediaList;
    },
  },
  data() {
    return {};
  },
};

const ListIndexProps = Utils.extend(
  {
    init: {
      type: Boolean,
      default: true,
    },
    listEl: [String, Object],
    indexes: {
      type: [String, Array],
      default: 'auto',
    },
    scrollList: {
      type: Boolean,
      default: true,
    },
    label: {
      type: Boolean,
      default: false,
    },
    iosItemHeight: {
      type: Number,
      default: 14,
    },
    mdItemHeight: {
      type: Number,
      default: 14,
    },
  },
  Mixins.colorProps
);
var f7ListIndex = {render: function(){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"list-index",class:_vm.classes},[_vm._t("default")],2)},staticRenderFns: [],
  props: ListIndexProps,
  name: 'f7-list-index',
  computed: {
    classes() {
      const self = this;
      return Mixins.colorClasses(self);
    },
  },
  beforeDestroy() {
    if (!this.init) return;
    if (this.f7ListIndex && this.f7ListIndex.destroy) {
      this.f7ListIndex.destroy();
    }
  },
  watch: {
    indexes() {
      if (!this.f7ListIndex) return;
      this.f7ListIndex.params.indexes = this.indexes;
      this.update();
    },
  },
  methods: {
    update() {
      if (!this.f7ListIndex) return;
      this.f7ListIndex.update();
    },
    scrollListToIndex(itemContent) {
      if (!this.f7ListIndex) return;
      this.f7ListIndex.scrollListToIndex(itemContent);
    },
    onF7Ready(f7) {
      const self = this;
      if (!self.init) return;
      const {
        $el, listEl, indexes, iosItemHeight, mdItemHeight, scrollList, label,
      } = self;
      self.f7ListIndex = f7.listIndex.create({
        el: $el,
        listEl,
        indexes,
        iosItemHeight,
        mdItemHeight,
        scrollList,
        label,
        on: {
          select(index, itemContent, itemIndex) {
            self.$emit('listindex:select', itemContent, itemIndex);
          },
        },
      });
    },
  },
};

var f7ListItemCell = {render: function(){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"item-cell",class:_vm.classes},[_vm._t("default")],2)},staticRenderFns: [],
  name: 'f7-list-item-cell',
  props: Mixins.colorProps,
  computed: {
    classes() {
      const self = this;
      return Mixins.colorClasses(self);
    },
  },
};

const ListItemContentProps = Utils.extend(
  {
    title: [String, Number],
    text: [String, Number],
    media: String,
    subtitle: [String, Number],
    header: [String, Number],
    footer: [String, Number],
    after: [String, Number],
    badge: [String, Number],
    badgeColor: String,
    mediaList: Boolean,
    itemInput: Boolean,
    itemInputWithInfo: Boolean,
    inlineLabel: Boolean,

    checkbox: Boolean,
    checked: Boolean,
    radio: Boolean,
    name: String,
    value: [String, Number, Array],
    readonly: Boolean,
    required: Boolean,
    disabled: Boolean,
  },
  Mixins.colorProps
);

var f7ListItemContent = {
  name: 'f7-list-item-content',
  components: {
    f7Badge,
  },
  props: ListItemContentProps,
  render(c) {
    const self = this;
    const slotsContentStart = [];
    const slotsContent = [];
    const slotsContentEnd = [];
    const slotsInnerStart = [];
    const slotsInner = [];
    const slotsInnerEnd = [];
    const slotsAfterStart = [];
    const slotsAfter = [];
    const slotsAfterEnd = [];
    const slotsMedia = [];
    const slotsBeforeTitle = [];
    const slotsTitle = [];
    const slotsAfterTitle = [];
    const slotsSubtitle = [];
    const slotsText = [];
    const slotsHeader = [];
    const slotsFooter = [];

    let [titleEl, afterWrapEl, afterEl, badgeEl, innerEl, titleRowEl, subtitleEl, textEl, mediaEl, inputEl, inputIconEl, headerEl, footerEl] = [];

    if (self.$slots.default && self.$slots.default.length > 0) {
      for (let i = 0; i < self.$slots.default.length; i += 1) {
        const slotName = self.$slots.default[i].data ? self.$slots.default[i].data.slot : undefined;
        if (!slotName || (slotName === 'inner')) slotsInner.push(self.$slots.default[i]);
        if (slotName === 'content-start') slotsContentStart.push(self.$slots.default[i]);
        if (slotName === 'content') slotsContent.push(self.$slots.default[i]);
        if (slotName === 'content-end') slotsContentEnd.push(self.$slots.default[i]);
        if (slotName === 'after-start') slotsAfterStart.push(self.$slots.default[i]);
        if (slotName === 'after') slotsAfter.push(self.$slots.default[i]);
        if (slotName === 'after-end') slotsAfterEnd.push(self.$slots.default[i]);
        if (slotName === 'media') slotsMedia.push(self.$slots.default[i]);
        if (slotName === 'inner-start') slotsInnerStart.push(self.$slots.default[i]);
        if (slotName === 'inner-end') slotsInnerEnd.push(self.$slots.default[i]);
        if (slotName === 'before-title') slotsBeforeTitle.push(self.$slots.default[i]);
        if (slotName === 'title') slotsTitle.push(self.$slots.default[i]);
        if (slotName === 'after-title') slotsAfterTitle.push(self.$slots.default[i]);
        if (slotName === 'subtitle') slotsSubtitle.push(self.$slots.default[i]);
        if (slotName === 'text') slotsText.push(self.$slots.default[i]);
        if (slotName === 'header') slotsHeader.push(self.$slots.default[i]);
        if (slotName === 'footer') slotsFooter.push(self.$slots.default[i]);
      }
    }

    // Input
    if (self.radio || self.checkbox) {
      inputEl = c('input', {
        attrs: {
          value: self.value,
          name: self.name,
          checked: self.checked,
          readonly: self.readonly,
          disabled: self.disabled,
          required: self.required,
          type: self.radio ? 'radio' : 'checkbox',
        },
        on: {
          change: self.onChange,
        },
        domProps: {
          checked: self.checked,
          disabled: self.disabled,
          required: self.required,
        },
      });
      inputIconEl = c('i', { staticClass: `icon icon-${self.radio ? 'radio' : 'checkbox'}` });
    }
    // Media
    if (self.media || slotsMedia.length) {
      let mediaImgEl;
      if (self.media) {
        mediaImgEl = c('img', { attrs: { src: self.media } });
      }
      mediaEl = c('div', { staticClass: 'item-media' }, [mediaImgEl, slotsMedia]);
    }
    // Inner Elements
    if (self.header || slotsHeader.length) {
      headerEl = c('div', { staticClass: 'item-header' }, [self.header, slotsHeader]);
    }
    if (self.footer || slotsFooter.length) {
      footerEl = c('div', { staticClass: 'item-footer' }, [self.footer, slotsFooter]);
    }
    if (self.title || slotsTitle.length) {
      titleEl = c('div', { staticClass: 'item-title' }, [!self.mediaList && headerEl, self.title, slotsTitle, !self.mediaList && footerEl]);
    }
    if (self.subtitle || slotsSubtitle.length) {
      subtitleEl = c('div', { staticClass: 'item-subtitle' }, [self.subtitle, slotsSubtitle]);
    }
    if (self.text || slotsText.length) {
      textEl = c('div', { staticClass: 'item-text' }, [self.text, slotsText]);
    }
    if (self.after || self.badge || slotsAfter.length) {
      if (self.after) {
        afterEl = c('span', [self.after]);
      }
      if (self.badge) {
        badgeEl = c('f7-badge', { props: { color: self.badgeColor } }, [self.badge]);
      }
      afterWrapEl = c('div', { staticClass: 'item-after' }, [slotsAfterStart, afterEl, badgeEl, slotsAfter, slotsAfterEnd]);
    }
    if (self.mediaList) {
      titleRowEl = c('div', { staticClass: 'item-title-row' }, [slotsBeforeTitle, titleEl, slotsAfterTitle, afterWrapEl]);
    }
    innerEl = c('div', { staticClass: 'item-inner' }, self.mediaList ? [slotsInnerStart, headerEl, titleRowEl, subtitleEl, textEl, slotsInner, footerEl, slotsInnerEnd] : [slotsInnerStart, slotsBeforeTitle, titleEl, slotsAfterTitle, afterWrapEl, slotsInner, slotsInnerEnd]);

    // Finalize
    return c((self.checkbox || self.radio) ? 'label' : 'div', {
      staticClass: 'item-content',
      class: Utils.extend(
        {
          'item-checkbox': self.checkbox,
          'item-radio': self.radio,
          'item-input': self.itemInput || self.itemInputForced,
          'inline-label': self.inlineLabel || self.inlineLabelForced,
          'item-input-with-info': self.itemInputWithInfo || self.itemInputWithInfoForced,
        },
        Mixins.colorClasses(self)
      ),
      on: {
        click: self.onClick,
      },
    }, [slotsContentStart, inputEl, inputIconEl, mediaEl, innerEl, slotsContent, slotsContentEnd]);
  },
  data() {
    return {
      itemInputForced: false,
      inlineLabelForced: false,
      itemInputWithInfoForced: false,
    };
  },
  methods: {
    onClick(event) {
      this.$emit('click', event);
    },
    onChange(event) {
      this.$emit('change', event);
    },
    onInput(event) {
      this.$emit('input', event);
    },
  },
};

var f7ListItemRow = {render: function(){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"item-row",class:_vm.classes},[_vm._t("default")],2)},staticRenderFns: [],
  name: 'f7-list-item-row',
  props: Mixins.colorProps,
  computed: {
    classes() {
      const self = this;
      return Mixins.colorClasses(self);
    },
  },
};

const ListItemProps = Utils.extend(
  {
    title: [String, Number],
    text: [String, Number],
    media: String,
    subtitle: [String, Number],
    header: [String, Number],
    footer: [String, Number],

    // Link Props
    link: [Boolean, String],
    target: String,
    noFastclick: Boolean,
    noFastClick: Boolean,

    after: [String, Number],
    badge: [String, Number],
    badgeColor: String,

    mediaItem: Boolean,
    mediaList: Boolean,
    divider: Boolean,
    groupTitle: Boolean,
    swipeout: Boolean,
    sortable: Boolean,
    accordionItem: Boolean,
    accordionItemOpened: Boolean,

    // Smart Select
    smartSelect: Boolean,
    smartSelectParams: Object,

    // Inputs
    checkbox: Boolean,
    radio: Boolean,
    checked: Boolean,
    name: String,
    value: [String, Number, Array],
    readonly: Boolean,
    required: Boolean,
    disabled: Boolean,
    itemInput: Boolean,
    itemInputWithInfo: Boolean,
    inlineLabel: Boolean,
  },
  Mixins.colorProps,
  Mixins.linkRouterProps,
  Mixins.linkActionsProps
);

var f7ListItem = {
  name: 'f7-list-item',
  components: {
    f7ListItemContent,
  },
  props: ListItemProps,
  render(c) {
    const self = this;

    let liChildren;
    let linkEl;
    let itemContentEl;

    if (!self.simpleListComputed) {
      // Item Content
      itemContentEl = c('f7-list-item-content', {
        props: {
          title: self.title,
          text: self.text,
          media: self.media,
          subtitle: self.subtitle,
          after: self.after,
          header: self.header,
          footer: self.footer,
          badge: self.badge,
          badgeColor: self.badgeColor,
          mediaList: self.mediaListComputed,
          accordionItem: self.accordionItem,

          checkbox: self.checkbox,
          checked: self.checked,
          radio: self.radio,
          name: self.name,
          value: self.value,
          readonly: self.readonly,
          required: self.required,
          disabled: self.disabled,
          itemInput: self.itemInput || self.itemInputForced,
          itemInputWithInfo: self.itemInputWithInfo || self.itemInputWithInfoForced,
          inlineLabel: self.inlineLabel || self.inlineLabelForced,
        },
        on: (self.link || self.href || self.accordionItem || self.smartSelect) ? {} : { click: self.onClick, change: self.onChange },
      }, [
        self.$slots['content-start'],
        self.$slots.content,
        self.$slots['content-end'],
        self.$slots.media,
        self.$slots['inner-start'],
        self.$slots.inner,
        self.$slots['inner-end'],
        self.$slots['after-start'],
        self.$slots.after,
        self.$slots['after-end'],
        self.$slots.header,
        self.$slots.footer,
        self.$slots['before-title'],
        self.$slots.title,
        self.$slots['after-title'],
        self.$slots.subtitle,
        self.$slots.text,
        (self.swipeout || self.accordionItem ? [] : self.$slots.default),
      ]);

      // Link
      if (self.link || self.href || self.accordionItem || self.smartSelect) {
        linkEl = c('a', {
          attrs: Utils.extend(
            {
              href: self.link === true || self.accordionItem || self.smartSelect ? '#' : self.link || self.href,
              target: self.target,
            },
            Mixins.linkRouterAttrs(self),
            Mixins.linkActionsAttrs(self)
          ),
          class: Utils.extend(
            {
              'item-link': true,
              'no-fastclick': self.noFastclick || self.noFastClick,
              'smart-select': self.smartSelect,
            },
            Mixins.linkRouterClasses(self),
            Mixins.linkActionsClasses(self)
          ),
          on: {
            click: self.onClick,
          },
        }, [itemContentEl]);
      }
    }

    if (self.divider || self.groupTitle) {
      liChildren = [c('span', self.$slots.default || self.title)];
    } else if (self.simpleListComputed) {
      liChildren = [self.title, self.$slots.default];
    } else {
      const linkItemEl = (self.link || self.href || self.smartSelect || self.accordionItem) ? linkEl : itemContentEl;
      if (self.swipeout) {
        liChildren = [c('div', { class: { 'swipeout-content': true } }, [linkItemEl])];
      } else {
        liChildren = [linkItemEl];
      }
      if (self.sortableComputed) {
        liChildren.push(c('div', { class: { 'sortable-handler': true } }));
      }
      if (self.swipeout || self.accordionItem) {
        liChildren.push(self.$slots.default);
      }
      liChildren.unshift(self.$slots['root-start']);
      liChildren.push(self.$slots.root);
      liChildren.push(self.$slots['root-end']);
    }

    return c(
      'li',
      {
        class: Utils.extend(
          {
            'item-divider': self.divider,
            'list-group-title': self.groupTitle,
            'media-item': self.mediaItem,
            swipeout: self.swipeout,
            'accordion-item': self.accordionItem,
            'accordion-item-opened': self.accordionItemOpened,
          },
          Mixins.colorClasses(self)
        ),
        on: {
          'swipeout:open': self.onSwipeoutOpen,
          'swipeout:opened': self.onSwipeoutOpened,
          'swipeout:close': self.onSwipeoutClose,
          'swipeout:closed': self.onSwipeoutClosed,
          'swipeout:delete': self.onSwipeoutDelete,
          'swipeout:deleted': self.onSwipeoutDeleted,
          swipeout: self.onSwipeout,
          'accordion:open': self.onAccOpen,
          'accordion:opened': self.onAccOpened,
          'accordion:close': self.onAccClose,
          'accordion:closed': self.onAccClosed,
        },
      },
      liChildren
    );
  },
  data() {
    return {
      itemInputForced: false,
      inlineLabelForced: false,
      itemInputWithInfoForced: false,
    };
  },
  computed: {
    sortableComputed() {
      return this.sortable || this.$parent.sortable || this.$parent.sortableComputed;
    },
    mediaListComputed() {
      return this.mediaList || this.mediaItem || this.$parent.mediaList || this.$parent.mediaListComputed;
    },
    simpleListComputed() {
      return this.simpleList || this.$parent.simpleList || (this.$parent.$parent && this.$parent.simpleList);
    },
  },
  beforeDestroy() {
    const self = this;
    if (self.smartSelect && self.f7SmartSelect) {
      self.f7SmartSelect.destroy();
    }
  },
  methods: {
    onF7Ready(f7) {
      const self = this;
      if (!self.smartSelect) return;
      const smartSelectParams = Utils.extend({ el: self.$el.querySelector('a.smart-select') }, (self.smartSelectParams || {}));
      self.f7SmartSelect = f7.smartSelect.create(smartSelectParams);
    },
    onClick(event) {
      const self = this;
      if (self.smartSelect && self.f7SmartSelect) {
        self.f7SmartSelect.open();
      }
      if (event.target.tagName.toLowerCase() !== 'input') {
        self.$emit('click', event);
      }
    },
    onSwipeoutDeleted(event) {
      this.$emit('swipeout:deleted', event);
    },
    onSwipeoutDelete(event) {
      this.$emit('swipeout:delete', event);
    },
    onSwipeoutClose(event) {
      this.$emit('swipeout:close', event);
    },
    onSwipeoutClosed(event) {
      this.$emit('swipeout:closed', event);
    },
    onSwipeoutOpen(event) {
      this.$emit('swipeout:open', event);
    },
    onSwipeoutOpened(event) {
      this.$emit('swipeout:opened', event);
    },
    onSwipeout(event) {
      this.$emit('swipeout', event);
    },
    onAccClose(event) {
      this.$emit('accordion:close', event);
    },
    onAccClosed(event) {
      this.$emit('accordion:closed', event);
    },
    onAccOpen(event) {
      this.$emit('accordion:open', event);
    },
    onAccOpened(event) {
      this.$emit('accordion:opened', event);
    },
    onChange(event) {
      this.$emit('change', event);
    },
    onInput(event) {
      this.$emit('input', event);
    },
  },
};

const ListProps = Utils.extend(
  {
    inset: Boolean,
    tabletInset: Boolean,
    mediaList: Boolean,
    sortable: Boolean,
    sortableEnabled: Boolean,
    accordionList: Boolean,
    contactsList: Boolean,
    simpleList: Boolean,
    linksList: Boolean,

    noHairlines: Boolean,
    noHairlinesBetween: Boolean,
    noHairlinesMd: Boolean,
    noHairlinesBetweenMd: Boolean,
    noHairlinesIos: Boolean,
    noHairlinesBetweenIos: Boolean,

    // Tab
    tab: Boolean,
    tabActive: Boolean,

    // Form
    form: Boolean,
    formStoreData: Boolean,
    inlineLabels: Boolean,

    // Virtual List
    virtualList: Boolean,
    virtualListParams: Object,
  },
  Mixins.colorProps
);

var f7List = {
  name: 'f7-list',
  props: ListProps,
  beforeDestroy() {
    const self = this;
    if (!(self.virtualList && self.f7VirtualList)) return;
    if (self.f7VirtualList.destroy) self.f7VirtualList.destroy();
  },
  render(c) {
    const self = this;

    const listChildren = [];
    const ulChildren = self.$slots.list || [];

    if (self.$slots.default) {
      for (let i = 0; i < self.$slots.default.length; i += 1) {
        const tag = self.$slots.default[i].tag;
        if (tag && !(tag === 'li' || tag.indexOf('list-item') >= 0 || tag.indexOf('list-button') >= 0)) {
          listChildren.push(self.$slots.default[i]);
        } else if (tag) {
          ulChildren.push(self.$slots.default[i]);
        }
      }
    }
    const blockEl = c(
      self.form ? 'form' : 'div',
      {
        staticClass: 'list',
        class: Utils.extend(
          {
            inset: self.inset,
            'tablet-inset': self.tabletInset,
            'media-list': self.mediaList,
            'simple-list': self.simpleList,
            'links-list': self.linksList,
            sortable: self.sortable,
            'accordion-list': self.accordionList,
            'contacts-list': self.contactsList,
            'virtual-list': self.virtualList,
            'sortable-enabled': self.sortableEnabled,
            tab: self.tab,
            'tab-active': self.tabActive,
            'no-hairlines': self.noHairlines,
            'no-hairlines-between': self.noHairlinesBetween,
            'no-hairlines-md': self.noHairlinesMd,
            'no-hairlines-between-md': self.noHairlinesBetweenMd,
            'no-hairlines-ios': self.noHairlinesIos,
            'no-hairlines-between-ios': self.noHairlinesBetweenIos,
            'form-store-data': self.formStoreData,
            'inline-labels': self.inlineLabels,
          },
          Mixins.colorClasses(self)
        ),
        on: {
          'sortable:enable': self.onSortableEnable,
          'sortable:disable': self.onSortableDisable,
          'sortable:sort': self.onSortableSort,
          'tab:show': self.onTabShow,
          'tab:hide': self.onTabHide,
        },
      },
      [
        ulChildren.length > 0 ?
          [
            self.$slots['before-list'],
            c('ul', {}, ulChildren),
            self.$slots['after-list'],
            listChildren,
          ] :
          [
            self.$slots['before-list'],
            listChildren,
            self.$slots['after-list'],
          ],
      ]
    );
    return blockEl;
  },
  methods: {
    onSortableEnable(event) {
      this.$emit('sortable:enable', event);
    },
    onSortableDisable(event) {
      this.$emit('sortable:disable', event);
    },
    onSortableSort(event) {
      this.$emit('sortable:sort', event, event.detail);
    },
    onTabShow(e) {
      this.$emit('tab:show', e);
    },
    onTabHide(e) {
      this.$emit('tab:hide', e);
    },
    onF7Ready(f7) {
      const self = this;
      // Init Virtual List
      if (!self.virtualList) return;
      const $$ = self.$$;
      const $el = $$(self.$el);
      const templateScript = $el.find('script');
      let template = templateScript.html();
      if (!template && templateScript.length > 0) {
        template = templateScript[0].outerHTML;
        // eslint-disable-next-line
        template = /\<script type="text\/template7"\>(.*)<\/script>/.exec(template)[1];
      }
      const vlParams = self.virtualListParams || {};
      if (!template && !vlParams.renderItem && !vlParams.itemTemplate && !vlParams.renderExternal) return;
      if (template) template = self.$t7.compile(template);

      self.f7VirtualList = f7.virtualList.create(Utils.extend(
        {
          el: self.$el,
          itemTemplate: template,
          on: {
            itemBeforeInsert(itemEl, item) {
              const vl = this;
              self.$emit('virtual:itembeforeinsert', vl, itemEl, item);
            },
            beforeClear(fragment) {
              const vl = this;
              self.$emit('virtual:beforeclear', vl, fragment);
            },
            itemsBeforeInsert(fragment) {
              const vl = this;
              self.$emit('virtual:itemsbeforeinsert', vl, fragment);
            },
            itemsAfterInsert(fragment) {
              const vl = this;
              self.$emit('virtual:itemsafterinsert', vl, fragment);
            },
          },
        },
        vlParams
      ));
    },
  },
};

var f7LoginScreenTitle = {render: function(){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"login-screen-title",class:_vm.classes},[_vm._t("default")],2)},staticRenderFns: [],
  name: 'f7-login-screen-title',
  props: Mixins.colorProps,
  computed: {
    classes() {
      const self = this;
      return Mixins.colorClasses(self);
    },
  },
};

const LoginScreenProps = Utils.extend(
  {
    opened: Boolean,
  },
  Mixins.colorProps
);

var f7LoginScreen = {
  name: 'f7-login-screen',
  render(c) {
    const self = this;
    return c('div', {
      staticClass: 'login-screen',
      class: self.classes,
      on: {
        'loginscreen:open': self.onOpen,
        'loginscreen:opened': self.onOpened,
        'loginscreen:close': self.onClose,
        'loginscreen:closed': self.onClosed,
      },
    }, self.$slots.default);
  },
  watch: {
    opened(opened) {
      const self = this;
      if (!self.f7LoginScreen) return;
      if (opened) {
        self.f7LoginScreen.open();
      } else {
        self.f7LoginScreen.close();
      }
    },
  },
  props: LoginScreenProps,
  computed: {
    classes() {
      const self = this;
      return Mixins.colorClasses(self);
    },
  },
  beforeDestroy() {
    const self = this;
    if (self.f7LoginScreen) self.f7LoginScreen.destroy();
  },
  methods: {
    onOpen(event) {
      this.$emit('loginscreen:open', event);
    },
    onOpened(event) {
      this.$emit('loginscreen:opened', event);
    },
    onClose(event) {
      this.$emit('loginscreen:close', event);
    },
    onClosed(event) {
      this.$emit('loginscreen:closed', event);
    },
    open(animate) {
      const self = this;
      if (!self.$f7) return undefined;
      return self.$f7.loginScreen.open(self.$el, animate);
    },
    close(animate) {
      const self = this;
      if (!self.$f7) return undefined;
      return self.$f7.loginScreen.close(self.$el, animate);
    },
    onF7Ready() {
      const self = this;
      self.f7LoginScreen = self.$f7.loginScreen.create({
        el: self.$el,
      });
      if (self.opened) {
        self.f7LoginScreen.open(false);
      }
    },
  },
};

const MessageProps = Utils.extend(
  {
    text: String,
    name: String,
    avatar: String,
    type: {
      type: String,
      default: 'sent',
    },
    image: String,
    header: String,
    footer: String,
    textHeader: String,
    textFooter: String,
    first: Boolean,
    last: Boolean,
    tail: Boolean,
    sameName: Boolean,
    sameHeader: Boolean,
    sameFooter: Boolean,
    sameAvatar: Boolean,
    typing: Boolean,
  },
  Mixins.colorProps
);
var f7Message = {render: function(){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"message",class:_vm.classes,on:{"click":_vm.onClick}},[_vm._t("start"),_vm._v(" "),(_vm.avatar || _vm.$slots.avatar)?_c('div',{staticClass:"message-avatar",style:({'background-image': _vm.avatar && 'url(' + _vm.avatar + ')'}),on:{"click":_vm.onAvatarClick}}):_vm._e(),_vm._v(" "),_c('div',{staticClass:"message-content"},[_vm._t("content-start"),_vm._v(" "),(_vm.name || _vm.$slots.name)?_c('div',{staticClass:"message-name",on:{"click":_vm.onNameClick}},[_vm._t("name",[_vm._v(_vm._s(_vm.name))])],2):_vm._e(),_vm._v(" "),(_vm.header || _vm.$slots.header)?_c('div',{staticClass:"message-header",on:{"click":_vm.onHeaderClick}},[_vm._t("header",[_vm._v(_vm._s(_vm.header))])],2):_vm._e(),_vm._v(" "),_c('div',{staticClass:"message-bubble",on:{"click":_vm.onBubbleClick}},[_vm._t("bubble-start"),_vm._v(" "),(_vm.image || _vm.$slots.image)?_c('div',{staticClass:"message-image"},[_vm._t("image",[_c('img',{attrs:{"src":_vm.image}})])],2):_vm._e(),_vm._v(" "),(_vm.textHeader || _vm.$slots['text-header'])?_c('div',{staticClass:"message-text-header"},[_vm._t("text-header",[_vm._v(_vm._s(_vm.textHeader))])],2):_vm._e(),_vm._v(" "),(_vm.text || _vm.$slots.text || _vm.typing)?_c('div',{staticClass:"message-text",on:{"click":_vm.onTextClick}},[_vm._t("text",[_vm._v(_vm._s(_vm.text))]),_vm._v(" "),(_vm.typing)?_c('div',{staticClass:"message-typing-indicator"},[_c('div'),_vm._v(" "),_c('div'),_vm._v(" "),_c('div')]):_vm._e()],2):_vm._e(),_vm._v(" "),(_vm.textFooter || _vm.$slots['text-footer'])?_c('div',{staticClass:"message-text-footer"},[_vm._t("text-footer",[_vm._v(_vm._s(_vm.textFooter))])],2):_vm._e(),_vm._v(" "),_vm._t("bubble-end"),_vm._v(" "),_vm._t("default")],2),_vm._v(" "),(_vm.footer || _vm.$slots.footer)?_c('div',{staticClass:"message-footer",on:{"click":_vm.onFooterClick}},[_vm._t("footer",[_vm._v(_vm._s(_vm.footer))])],2):_vm._e(),_vm._v(" "),_vm._t("content-end")],2),_vm._v(" "),_vm._t("end")],2)},staticRenderFns: [],
  name: 'f7-message',
  props: MessageProps,
  computed: {
    classes() {
      const self = this;
      return Utils.extend({
        'message-sent': self.type === 'sent',
        'message-received': self.type === 'received',
        'message-typing': self.typing,
        'message-first': self.first,
        'message-last': self.last,
        'message-tail': self.tail,
        'message-same-name': self.sameName,
        'message-same-header': self.sameHeader,
        'message-same-footer': self.sameFooter,
        'message-same-avatar': self.sameAvatar,
      }, Mixins.colorClasses(self));
    },
  },
  methods: {
    onClick(event) {
      this.$emit('click', event);
    },
    onNameClick(event) {
      this.$emit('click:name', event);
    },
    onTextClick(event) {
      this.$emit('click:text', event);
    },
    onAvatarClick(event) {
      this.$emit('click:avatar', event);
    },
    onHeaderClick(event) {
      this.$emit('click:header', event);
    },
    onFooterClick(event) {
      this.$emit('click:footer', event);
    },
    onBubbleClick(event) {
      this.$emit('click:bubble', event);
    },
  },
};

const MessagebarAttachmentProps = Utils.extend(
  {
    image: String,
    deletable: {
      type: Boolean,
      default: true,
    },
  },
  Mixins.colorProps
);

var f7MessagebarAttachment = {render: function(){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"messagebar-attachment",class:_vm.classes,on:{"click":_vm.onClick}},[(_vm.image)?_c('img',{attrs:{"src":_vm.image}}):_vm._e(),_vm._v(" "),(_vm.deletable)?_c('span',{staticClass:"messagebar-attachment-delete",on:{"click":_vm.onDeleteClick}}):_vm._e(),_vm._v(" "),_vm._t("default")],2)},staticRenderFns: [],
  props: MessagebarAttachmentProps,
  name: 'f7-messagebar-attachment',
  computed: {
    classes() {
      const self = this;
      return Mixins.colorClasses(self);
    },
  },
  methods: {
    onClick(e) {
      this.$emit('attachment:click', e);
    },
    onDeleteClick(e) {
      this.$emit('attachment:delete', e);
    },
  },
};

var f7MessagebarAttachments = {render: function(){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"messagebar-attachments",class:_vm.classes},[_vm._t("default")],2)},staticRenderFns: [],
  props: Mixins.colorProps,
  name: 'f7-messagebar-attachments',
  computed: {
    classes() {
      const self = this;
      return Mixins.colorClasses(self);
    },
  },
};

const MessagebarSheetItemProps = Utils.extend(
  {
    image: String,
    checked: Boolean,
  },
  Mixins.colorProps
);

var f7MessagebarSheetImage = {render: function(){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('label',{staticClass:"messagebar-sheet-image checkbox",class:_vm.classes,style:({ 'background-image': _vm.image && `url(${_vm.image})`})},[_c('input',{attrs:{"type":"checkbox"},domProps:{"checked":_vm.checked},on:{"change":_vm.onChange}}),_vm._v(" "),_c('i',{staticClass:"icon icon-checkbox"}),_vm._v(" "),_vm._t("default")],2)},staticRenderFns: [],
  props: MessagebarSheetItemProps,
  name: 'f7-messagebar-sheet-image',
  computed: {
    classes() {
      const self = this;
      return Mixins.colorClasses(self);
    },
  },
  methods: {
    onChange(e) {
      if (this.checked) this.$emit('checked', e);
      else this.$emit('unchecked', e);
      this.$emit('change', e);
    },
  },
};

var f7MessagebarSheetItem = {render: function(){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"messagebar-sheet-item",class:_vm.classes},[_vm._t("default")],2)},staticRenderFns: [],
  props: Mixins.colorProps,
  name: 'f7-messagebar-sheet-item',
  computed: {
    classes() {
      const self = this;
      return Mixins.colorClasses(self);
    },
  },
};

var f7MessagebarSheet = {render: function(){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"messagebar-sheet",class:_vm.classes},[_vm._t("default")],2)},staticRenderFns: [],
  props: Mixins.colorProps,
  name: 'f7-messagebar-sheet',
  computed: {
    classes() {
      const self = this;
      return Mixins.colorClasses(self);
    },
  },
};

const MessagebarProps = Utils.extend(
  {
    sheetVisible: Boolean,
    attachmentsVisible: Boolean,
    top: Boolean,
    resizable: {
      type: Boolean,
      default: true,
    },
    bottomOffset: {
      type: Number,
      default: 0,
    },
    topOffset: {
      type: Number,
      default: 0,
    },
    maxHeight: Number,
    sendLink: String,
    value: [String, Number, Array],
    disabled: Boolean,
    readonly: Boolean,
    name: String,
    placeholder: {
      type: String,
      default: 'Message',
    },
    init: {
      type: Boolean,
      default: true,
    },
  },
  Mixins.colorProps
);

var f7Messagebar = {
  name: 'f7-messagebar',
  components: {
    f7Input,
    f7Link,
  },
  render(c) {
    const self = this;
    const beforeInnerEls = [];
    const afterInnerEls = [];
    const innerStartEls = [];
    const innerEndEls = []; // add send link here
    const beforeAreaEls = []; // add attachments here
    const afterAreaEls = [];

    let linkEl;
    if ((self.sendLink && self.sendLink.length > 0) || self.$slots['send-link']) {
      linkEl = c('f7-link', {
        on: {
          click: self.onClick,
        },
      }, [self.sendLink ? self.sendLink : self.$slots['send-link']]);
      innerEndEls.push(linkEl);
    }

    if (self.$slots['before-inner']) {
      self.$slots['before-inner'].forEach((el) => {
        beforeInnerEls.push(el);
      });
    }
    if (self.$slots['after-inner']) {
      self.$slots['after-inner'].forEach((el) => {
        afterInnerEls.push(el);
      });
    }
    if (self.$slots['inner-start']) {
      self.$slots['inner-start'].forEach((el) => {
        innerStartEls.push(el);
      });
    }
    if (self.$slots['inner-end']) {
      self.$slots['inner-end'].forEach((el) => {
        innerEndEls.push(el);
      });
    }
    if (self.$slots['before-area']) {
      self.$slots['before-area'].forEach((el) => {
        beforeAreaEls.push(el);
      });
    }
    if (self.$slots['after-area']) {
      self.$slots['after-area'].forEach((el) => {
        afterAreaEls.push(el);
      });
    }
    if (self.$slots.default) {
      self.$slots.default.forEach((el) => {
        const tag = el.tag;
        if (tag && tag.indexOf('messagebar-attachments') >= 0) {
          beforeAreaEls.push(el);
        } else if (tag && tag.indexOf('messagebar-sheet') >= 0) {
          afterInnerEls.push(el);
        } else {
          innerEndEls.push(el);
        }
      });
    }

    const inputEl = c('f7-input', {
      props: {
        type: 'textarea',
        wrap: false,
        placeholder: self.placeholder,
        disabled: self.disabled,
        name: self.name,
        readonly: self.readonly,
        resizable: self.resizable,
        value: self.value,
      },
      ref: 'area',
      on: {
        input: self.onInput,
        change: self.onChange,
        focus: self.onFocus,
        blur: self.onBlur,
      },
    });

    const areaEl = c('div', {
      staticClass: 'messagebar-area',
    }, [
      beforeAreaEls,
      inputEl,
      afterAreaEls,
    ]);

    const innerEl = c('div', {
      staticClass: 'toolbar-inner',
    }, [
      innerStartEls,
      areaEl,
      innerEndEls,
    ]);

    return c('div', {
      staticClass: 'toolbar messagebar',
      class: self.classes,
      on: {
        'messagebar:attachmentdelete': self.onDeleteAttachment,
        'messagebar:attachmentclick': self.onClickAttachment,
        'messagebar:resizepage': self.onResizePage,
      },
    }, [
      beforeInnerEls,
      innerEl,
      afterInnerEls,
    ]);
  },
  props: MessagebarProps,
  computed: {
    classes() {
      const self = this;
      return Utils.extend({
        'messagebar-attachments-visible': self.attachmentsVisible,
        'messagebar-sheet-visible': self.sheetVisible,
      }, Mixins.colorClasses);
    },
  },
  watch: {
    sheetVisible() {
      const self = this;
      if (!self.resizable) return;
      self.$nextTick(() => {
        if (!self.f7Messagebar) return;
        self.f7Messagebar.sheetVisible = self.sheetVisible;
        self.f7Messagebar.resizePage();
      });
    },
    attachmentsVisible() {
      const self = this;
      if (!self.resizable) return;
      self.$nextTick(() => {
        if (!self.f7Messagebar) return;
        self.f7Messagebar.attachmentsVisible = self.attachmentsVisible;
        self.f7Messagebar.resizePage();
      });
    },
  },
  beforeDestroy() {
    if (this.f7Messagebar && this.f7Messagebar.destroy) this.f7Messagebar.destroy();
  },
  methods: {
    clear(...args) {
      if (!this.f7Messagebar) return undefined;
      return this.f7Messagebar.clear(...args);
    },
    getValue(...args) {
      if (!this.f7Messagebar) return undefined;
      return this.f7Messagebar.getValue(...args);
    },
    setValue(...args) {
      if (!this.f7Messagebar) return undefined;
      return this.f7Messagebar.setValue(...args);
    },
    setPlaceholder(...args) {
      if (!this.f7Messagebar) return undefined;
      return this.f7Messagebar.setPlaceholder(...args);
    },
    resizePage(...args) {
      if (!this.f7Messagebar) return undefined;
      return this.f7Messagebar.resizePage(...args);
    },
    focus(...args) {
      if (!this.f7Messagebar) return undefined;
      return this.f7Messagebar.focus(...args);
    },
    blur(...args) {
      if (!this.f7Messagebar) return undefined;
      return this.f7Messagebar.blur(...args);
    },
    attachmentsShow(...args) {
      if (!this.f7Messagebar) return undefined;
      return this.f7Messagebar.attachmentsShow(...args);
    },
    attachmentsHide(...args) {
      if (!this.f7Messagebar) return undefined;
      return this.f7Messagebar.attachmentsHide(...args);
    },
    attachmentsToggle(...args) {
      if (!this.f7Messagebar) return undefined;
      return this.f7Messagebar.attachmentsToggle(...args);
    },
    sheetShow(...args) {
      if (!this.f7Messagebar) return undefined;
      return this.f7Messagebar.sheetShow(...args);
    },
    sheetHide(...args) {
      if (!this.f7Messagebar) return undefined;
      return this.f7Messagebar.sheetHide(...args);
    },
    sheetToggle(...args) {
      if (!this.f7Messagebar) return undefined;
      return this.f7Messagebar.sheetToggle(...args);
    },
    onChange(event) {
      this.$emit('change', event);
    },
    onInput(event) {
      this.$emit('input', event);
    },
    onFocus(event) {
      this.$emit('focus', event);
    },
    onBlur(event) {
      this.$emit('blur', event);
    },
    onClick(event) {
      const self = this;
      const value = self.$refs.area.$el.value;
      const clear = self.f7Messagebar ? self.f7Messagebar.clear : () => {};
      this.$emit('submit', value, clear);
      this.$emit('send', value, clear);
      this.$emit('click', event);
    },
    onDeleteAttachment(e) {
      this.$emit('messagebar:attachmentdelete', e);
    },
    onClickAttachment(e) {
      this.$emit('messagebar:attachmentclick', e);
    },
    onResizePage(e) {
      this.$emit('messagebar:resizepage', e);
    },
    onF7Ready() {
      const self = this;
      if (!self.init) return;
      self.f7Messagebar = self.$f7.messagebar.create({
        el: self.$el,
        top: self.top,
        resizePage: self.resizable,
        bottomOffset: self.bottomOffset,
        topOffset: self.topOffset,
        maxHeight: self.maxHeight,
      });
    },
  },
};

var f7MessagesTitle = {render: function(){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"messages-title",class:_vm.classes},[_vm._t("default")],2)},staticRenderFns: [],
  props: Mixins.colorProps,
  name: 'f7-messages-title',
  computed: {
    classes() {
      const self = this;
      return Mixins.colorClasses(self);
    },
  },
};

const MessagesProps = Utils.extend(
  {
    autoLayout: {
      type: Boolean,
      default: false,
    },
    messages: {
      type: Array,
      default() {
        return [];
      },
    },
    newMessagesFirst: {
      type: Boolean,
      default: false,
    },
    scrollMessages: {
      type: Boolean,
      default: true,
    },
    scrollMessagesOnEdge: {
      type: Boolean,
      default: true,
    },
    firstMessageRule: Function,
    lastMessageRule: Function,
    tailMessageRule: Function,
    sameNameMessageRule: Function,
    sameHeaderMessageRule: Function,
    sameFooterMessageRule: Function,
    sameAvatarMessageRule: Function,
    customClassMessageRule: Function,
    renderMessage: Function,

    init: {
      type: Boolean,
      default: true,
    },
  },
  Mixins.colorProps
);
var f7Messages = {
  name: 'f7-messages',
  render(c) {
    const self = this;
    return c('div', {
      staticClass: 'messages',
      class: Mixins.colorClasses(self),
    }, self.$slots.default);
  },
  props: MessagesProps,
  beforeDestroy() {
    if (this.f7Messages && this.f7Messages.destroy) this.f7Messages.destroy();
  },
  beforeUpdate() {
    const self = this;
    if (!self.init) return;
    self.$children.forEach((el) => {
      self.$$(el.$el).addClass('message-appeared');
    });
  },
  updated() {
    const self = this;
    if (!self.init) return;
    self.$children.forEach((el) => {
      const $el = self.$$(el.$el);
      if (!$el.hasClass('message-appeared')) {
        $el.addClass('message-appear-from-bottom');
      }
    });
    if (self.f7Messages && self.f7Messages.layout && self.autoLayout) {
      self.f7Messages.layout();
    }
    if (self.f7Messages && self.f7Messages.scroll && self.scrollMessages) {
      self.f7Messages.scroll();
    }
  },

  methods: {
    renderMessages(messagesToRender, method) {
      if (!this.f7Messages) return undefined;
      return this.renderMessages(messagesToRender, method);
    },
    layout() {
      if (!this.f7Messages) return undefined;
      return this.layout();
    },
    scroll(duration, scrollTop) {
      if (!this.f7Messages) return undefined;
      return this.scroll(duration, scrollTop);
    },
    clear() {
      if (!this.f7Messages) return undefined;
      return this.clear();
    },
    removeMessage(messageToRemove, layout) {
      if (!this.f7Messages) return undefined;
      return this.removeMessage(messageToRemove, layout);
    },
    removeMessages(messagesToRemove, layout) {
      if (!this.f7Messages) return undefined;
      return this.removeMessages(messagesToRemove, layout);
    },
    addMessage(...args) {
      if (!this.f7Messages) return undefined;
      return this.addMessage(...args);
    },
    addMessages(...args) {
      if (!this.f7Messages) return undefined;
      return this.addMessages(...args);
    },
    showTyping(message) {
      if (!this.f7Messages) return undefined;
      return this.showTyping(message);
    },
    hideTyping() {
      if (!this.f7Messages) return undefined;
      return this.hideTyping();
    },
    destroy() {
      if (!this.f7Messages) return undefined;
      return this.destroy();
    },
    onF7Ready(f7) {
      const self = this;
      if (!self.init) return;
      self.f7Messages = f7.messages.create({
        el: self.$el,
        autoLayout: self.autoLayout,
        messages: self.messages,
        newMessagesFirst: self.newMessagesFirst,
        scrollMessages: self.scrollMessages,
        scrollMessagesOnEdge: self.scrollMessagesOnEdge,
        firstMessageRule: self.firstMessageRule,
        lastMessageRule: self.lastMessageRule,
        tailMessageRule: self.tailMessageRule,
        sameNameMessageRule: self.sameNameMessageRule,
        sameHeaderMessageRule: self.sameHeaderMessageRule,
        sameFooterMessageRule: self.sameFooterMessageRule,
        sameAvatarMessageRule: self.sameAvatarMessageRule,
        customClassMessageRule: self.customClassMessageRule,
        renderMessage: self.renderMessage,
      });
    },
  },
};

const NavLeftProps = Utils.extend({
  backLink: [Boolean, String],
  backLinkUrl: String,
  sliding: Boolean,
}, Mixins.colorProps);

var f7NavLeft = {render: function(){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"left",class:_vm.classes},[(_vm.backLink)?_c('f7-link',{class:{'icon-only': (_vm.backLink === true || _vm.backLink && _vm.$theme.md)},attrs:{"href":_vm.backLinkUrl || '#',"back":"","icon":"icon-back","text":_vm.backLink !== true && !_vm.$theme.md ? _vm.backLink : undefined},on:{"click":_vm.onBackClick}}):_vm._e(),_vm._v(" "),_vm._t("default")],2)},staticRenderFns: [],
  name: 'f7-nav-left',
  components: {
    f7Link,
  },
  props: NavLeftProps,
  computed: {
    classes() {
      return Utils.extend({
        sliding: this.slidng,
      }, Mixins.colorClasses(this));
    },
  },
  methods: {
    onBackClick(e) {
      this.$emit('back-click', e);
      this.$emit('click:back', e);
    },
  },
};

const NavRightProps = Utils.extend({
  sliding: Boolean,
}, Mixins.colorProps);

var f7NavRight = {render: function(){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"right",class:_vm.classes},[_vm._t("default")],2)},staticRenderFns: [],
  name: 'f7-nav-right',
  props: NavRightProps,
  computed: {
    classes() {
      return Utils.extend({
        sliding: this.slidng,
      }, Mixins.colorClasses(this));
    },
  },
};

const NavTitleProps = Utils.extend({
  title: String,
  subtitle: String,
  sliding: Boolean,
}, Mixins.colorProps);

var f7NavTitle = {render: function(){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"title",class:_vm.classes},[_vm._t("default",[_vm._v(_vm._s(_vm.title)),(_vm.subtitle)?_c('span',{staticClass:"subtitle"},[_vm._v(_vm._s(_vm.subtitle))]):_vm._e()])],2)},staticRenderFns: [],
  name: 'f7-nav-title',
  props: NavTitleProps,
  computed: {
    classes() {
      return Utils.extend({
        sliding: this.slidng,
      }, Mixins.colorClasses(this));
    },
  },
};

const NavbarProps = Utils.extend({
  backLink: [Boolean, String],
  backLinkUrl: String,
  sliding: {
    type: Boolean,
    default: true,
  },
  title: String,
  subtitle: String,
  hidden: Boolean,
  noShadow: Boolean,
  noHairline: Boolean,
  inner: {
    type: Boolean,
    default: true,
  },
}, Mixins.colorProps);

var f7Navbar = {
  name: 'f7-navbar',
  components: {
    f7NavLeft,
    f7NavTitle,
  },
  render(c) {
    const self = this;
    let innerEl;
    let leftEl;
    let titleEl;
    if (self.inner) {
      if (self.backLink) {
        leftEl = c('f7-nav-left', {
          props: {
            backLink: self.backLink,
            backLinkUrl: self.backLinkUrl,
          },
          on: {
            'back-click': self.onBackClick,
          },
        });
      }
      if (self.title || self.subtitle) {
        titleEl = c('f7-nav-title', {
          props: {
            title: self.title,
            subtitle: self.subtitle,
          },
        });
      }
      innerEl = c('div', { ref: 'inner', staticClass: 'navbar-inner', class: { sliding: self.sliding } }, [leftEl, titleEl, self.$slots.default]);
    }
    return c('div', {
      staticClass: 'navbar',
      class: self.classes,
    }, [self.$slots['before-inner'], innerEl, self.$slots['after-inner']]);
  },
  updated() {
    const self = this;
    if (!self.$f7) return;
    self.$nextTick(() => {
      if (self.$el && self.$el.children && self.$el.children.length) {
        self.$f7.navbar.size(self.$el);
      } else if (self.$refs.inner) {
        self.$f7.navbar.size(self.$refs.inner);
      }
    });
  },
  props: NavbarProps,
  computed: {
    classes() {
      const self = this;
      return Utils.extend({
        'navbar-hidden': self.hidden,
        'no-shadow': self.noShadow,
        'no-hairline': self.noHairline,
      }, Mixins.colorClasses(self));
    },
  },
  methods: {
    hide(animate) {
      const self = this;
      if (!self.$f7) return;
      self.$f7.navbar.hide(self.$el, animate);
    },
    show(animate) {
      const self = this;
      if (!self.$f7) return;
      self.$f7.navbar.show(self.$el, animate);
    },
    size() {
      const self = this;
      if (!self.$f7) return;
      self.$f7.navbar.size(self.$el);
    },
    onBackClick(e) {
      this.$emit('back-click', e);
      this.$emit('click:back', e);
    },
  },
};

const PageContentProps = Utils.extend({
  tab: Boolean,
  tabActive: Boolean,
  ptr: Boolean,
  ptrDistance: Number,
  ptrPreloader: {
    type: Boolean,
    default: true,
  },
  infinite: Boolean,
  infiniteTop: Boolean,
  infiniteDistance: Number,
  infinitePreloader: {
    type: Boolean,
    default: true,
  },
  hideBarsOnScroll: Boolean,
  hideNavbarOnScroll: Boolean,
  hideToolbarOnScroll: Boolean,
  messagesContent: Boolean,
  loginScreen: Boolean,
}, Mixins.colorProps);

var f7PageContent = {
  name: 'f7-page-content',
  render(c) {
    const self = this;

    let ptrEl;
    let infiniteEl;

    if (self.ptr && (self.ptrPreloader)) {
      ptrEl = c('div', { staticClass: 'ptr-preloader' }, [
        c('div', { staticClass: 'preloader' }),
        c('div', { staticClass: 'ptr-arrow' }),
      ]);
    }
    if ((self.infinite) && self.infinitePreloader) {
      infiniteEl = c('div', { staticClass: 'preloader infinite-scroll-preloader' });
    }
    return c('div', {
      staticClass: 'page-content',
      class: self.classes,
      attrs: {
        'data-ptr-distance': self.ptrDistance,
        'data-infinite-distance': self.infiniteDistance,
      },
      on: {
        'ptr:pullstart': self.onPtrPullStart,
        'ptr:pullmove': self.onPtrPullMove,
        'ptr:pullend': self.onPtrPullEnd,
        'ptr:refresh': self.onPtrRefresh,
        'ptr:done': self.onPtrRefreshDone,
        infinite: self.onInfinite,
        'tab:show': self.onTabShow,
        'tab:hide': self.onTabHide,
      },
    }, (self.infiniteTop ? [ptrEl, infiniteEl, self.$slots.default] : [ptrEl, self.$slots.default, infiniteEl]));
  },
  props: PageContentProps,
  computed: {
    classes() {
      const self = this;
      return Utils.extend({
        tab: self.tab,
        'tab-active': self.tabActive,
        'ptr-content': self.ptr,
        'infinite-scroll-content': self.infinite,
        'infinite-scroll-top': self.infiniteTop,
        'hide-bars-on-scroll': self.hideBarsOnScroll,
        'hide-navbar-on-scroll': self.hideNavbarOnScroll,
        'hide-toolbar-on-scroll': self.hideToolbarOnScroll,
        'messages-content': self.messagesContent,
        'login-screen-content': self.loginScreen,
      }, Mixins.colorClasses(self));
    },
  },
  methods: {
    onPtrPullStart(event) {
      this.$emit('ptr:pullstart', event);
    },
    onPtrPullMove(event) {
      this.$emit('ptr:pullmove', event);
    },
    onPtrPullEnd(event) {
      this.$emit('ptr:pullend', event);
    },
    onPtrRefresh(event) {
      this.$emit('ptr:refresh', event, event.detail);
    },
    onPtrRefreshDone(event) {
      this.$emit('ptr:done', event);
    },
    onInfinite(event) {
      this.$emit('infinite', event);
    },
    onTabShow(e) {
      const self = this;
      self.$emit('tab:show', e);
    },
    onTabHide(e) {
      const self = this;
      self.$emit('tab:hide', e);
    },
  },
};

const PageProps = Utils.extend({
  name: String,
  stacked: Boolean,
  withSubnavbar: Boolean,
  subnavbar: Boolean,
  noNavbar: Boolean,
  noToolbar: Boolean,
  tabs: Boolean,
  pageContent: {
    type: Boolean,
    default: true,
  },
  noSwipeback: Boolean,
  // Page Content Props
  ptr: Boolean,
  ptrDistance: Number,
  ptrPreloader: {
    type: Boolean,
    default: true,
  },
  infinite: Boolean,
  infiniteTop: Boolean,
  infiniteDistance: Number,
  infinitePreloader: {
    type: Boolean,
    default: true,
  },
  hideBarsOnScroll: Boolean,
  hideNavbarOnScroll: Boolean,
  hideToolbarOnScroll: Boolean,
  messagesContent: Boolean,
  loginScreen: Boolean,
}, Mixins.colorProps);

var f7Page = {
  name: 'f7-page',
  components: {
    f7PageContent,
  },
  render(c) {
    const fixedList = [];
    const staticList = [];
    const self = this;

    let pageContentEl;

    const fixedTags = ('navbar toolbar tabbar subnavbar searchbar messagebar fab list-index').split(' ');

    let tag;
    let child;
    let withSubnavbar;
    let withSearchbar;
    let withMessages = self.$options.propsData.withMessages;

    if (self.$slots.default) {
      for (let i = 0; i < self.$slots.default.length; i += 1) {
        child = self.$slots.default[i];
        tag = child.tag;
        if (!tag) {
          staticList.push(child);
          continue; // eslint-disable-line
        }
        let isFixed = false;
        if (tag.indexOf('subnavbar') >= 0) withSubnavbar = true;
        if (tag.indexOf('searchbar') >= 0) withSearchbar = true;
        if (typeof withMessages === 'undefined' && tag.indexOf('messages') >= 0) withMessages = true;
        for (let j = 0; j < fixedTags.length; j += 1) {
          if (tag.indexOf(fixedTags[j]) >= 0) {
            isFixed = true;
          }
        }
        if (isFixed) fixedList.push(child);
        else staticList.push(child);
      }
    }

    if (fixedList.length > 0 && withSearchbar) {
      fixedList.push(c('div', { class: { 'searchbar-overlay': true } }));
    }
    if (self.pageContent) {
      pageContentEl = c('f7-page-content', {
        props: {
          ptr: self.ptr,
          ptrDistance: self.ptrDistance,
          ptrPreloader: self.ptrPreloader,
          infinite: self.infinite,
          infiniteTop: self.infiniteTop,
          infiniteDistance: self.infiniteDistance,
          infinitePreloader: self.infinitePreloader,
          hideBarsOnScroll: self.hideBarsOnScroll,
          hideNavbarOnScroll: self.hideNavbarOnScroll,
          hideToolbarOnScroll: self.hideToolbarOnScroll,
          messagesContent: self.messagesContent || withMessages,
          loginScreen: self.loginScreen,
        },
        on: {
          'ptr:pullstart': self.onPtrPullStart,
          'ptr:pullmove': self.onPtrPullMove,
          'ptr:pullend': self.onPtrPullEnd,
          'ptr:refresh': self.onPtrRefresh,
          'ptr:done': self.onPtrRefreshDone,
          infinite: self.onInfinite,
        },
      }, [self.$slots.static, staticList]);
    } else {
      pageContentEl = [];
      if (self.$slots.default && fixedList.length > 0) {
        for (let i = 0; i < self.$slots.default.length; i += 1) {
          if (fixedList.indexOf(self.$slots.default[i]) < 0) {
            pageContentEl.push(self.$slots.default[i]);
          }
        }
      } else {
        pageContentEl = [self.$slots.default];
      }
    }
    fixedList.push(self.$slots.fixed);

    if (withSubnavbar) self.classes['page-with-subnavbar'] = true;

    const pageEl = c('div', {
      staticClass: 'page',
      class: self.classes,
      attrs: {
        'data-name': self.name,
      },
      on: {
        'page:mounted': self.onPageMounted,
        'page:init': self.onPageInit,
        'page:reinit': self.onPageReinit,
        'page:beforein': self.onPageBeforeIn,
        'page:afterin': self.onPageAfterIn,
        'page:beforeout': self.onPageBeforeOut,
        'page:afterout': self.onPageAfterOut,
        'page:beforeremove': self.onPageBeforeRemove,
      },
    }, [fixedList, pageContentEl]);

    return pageEl;
  },
  props: PageProps,
  computed: {
    classes() {
      return Utils.extend({
        stacked: this.stacked,
        tabs: this.tabs,
        'page-with-subnavbar': this.subnavbar || this.withSubnavbar,
        'no-navbar': this.noNavbar,
        'no-toolbar': this.noToolbar,
        'no-swipeback': this.noSwipeback,
      }, Mixins.colorClasses(this));
    },
  },
  methods: {
    onPtrPullStart(event) {
      this.$emit('ptr:pullstart', event);
    },
    onPtrPullMove(event) {
      this.$emit('ptr:pullmove', event);
    },
    onPtrPullEnd(event) {
      this.$emit('ptr:pullend', event);
    },
    onPtrRefresh(event) {
      this.$emit('ptr:refresh', event, event.detail);
    },
    onPtrRefreshDone(event) {
      this.$emit('ptr:done', event);
    },
    onInfinite(event) {
      this.$emit('infinite', event);
    },
    onPageMounted(event) {
      this.$emit('page:mounted', event, event.detail);
    },
    onPageInit(event) {
      this.$emit('page:init', event, event.detail);
    },
    onPageReinit(event) {
      this.$emit('page:reinit', event, event.detail);
    },
    onPageBeforeIn(event) {
      this.$emit('page:beforein', event, event.detail);
    },
    onPageBeforeOut(event) {
      this.$emit('page:beforeout', event, event.detail);
    },
    onPageAfterOut(event) {
      this.$emit('page:afterout', event, event.detail);
    },
    onPageAfterIn(event) {
      this.$emit('page:afterin', event, event.detail);
    },
    onPageBeforeRemove(event) {
      this.$emit('page:beforeremove', event, event.detail);
    },
  },
};

const PanelProps = Utils.extend(
  {
    side: String,
    effect: String,
    cover: Boolean,
    reveal: Boolean,
    left: Boolean,
    right: Boolean,
    opened: Boolean,
  },
  Mixins.colorProps
);

var f7Panel = {render: function(){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"panel",class:_vm.classes,on:{"panel:open":_vm.onOpen,"panel:opened":_vm.onOpened,"panel:close":_vm.onClose,"panel:closed":_vm.onClosed,"panel:backdrop-click":_vm.onBackdropClick,"panel:swipe":_vm.onPanelSwipe,"panel:swipeopen":_vm.onPanelSwipeOpen,"panel:breakpoint":_vm.onBreakpoint}},[_vm._t("default")],2)},staticRenderFns: [],
  props: PanelProps,
  computed: {
    classes() {
      const self = this;
      const side = self.side || (self.left ? 'left' : 'right');
      const effect = self.effect || (self.reveal ? 'reveal' : 'cover');
      return Utils.extend(
        {
          'panel-active': self.opened,
          [`panel-${side}`]: side,
          [`panel-${effect}`]: effect,
        },
        Mixins.colorClasses(self)
      );
    },
  },
  watch: {
    opened(opened) {
      const self = this;
      if (!self.$f7) return;
      const side = self.side || (self.left ? 'left' : 'right');
      if (opened) {
        self.$f7.panel.open(side);
      } else {
        self.$f7.panel.open(side);
      }
    },
  },
  beforeDestroy() {
    const self = this;
    if (self.f7Panel) self.f7Panel.destroy();
  },
  mounted() {
    const self = this;
    if (self.opened) {
      self.$el.style.display = 'block';
    }
    const $ = self.$;
    if (!$) return;
    const side = self.side || (self.left ? 'left' : 'right');
    const effect = self.effect || (self.reveal ? 'reveal' : 'cover');
    if (self.opened) {
      $('html').addClass(`with-panel-${side}-${effect}`);
    }
  },
  methods: {
    onOpen(event) {
      this.$emit('panel:open', event);
    },
    onOpened(event) {
      this.$emit('panel:opened', event);
    },
    onClose(event) {
      this.$emit('panel:close', event);
    },
    onClosed(event) {
      this.$emit('panel:closed', event);
    },
    onBackdropClick(event) {
      this.$emit('panel:backdrop-click', event);
    },
    onPanelSwipe(event) {
      this.$emit('panel:swipe', event);
    },
    onPanelSwipeOpen(event) {
      this.$emit('panel:swipeopen', event);
    },
    onBreakpoint(event) {
      this.$emit('panel:breakpoint', event);
    },
    onF7Ready() {
      const self = this;
      const $ = self.$$;
      if (!$) return;
      if ($('.panel-backdrop').length === 0) {
        $('<div class="panel-backdrop"></div>').insertBefore(self.$el);
      }
      self.f7Panel = self.$f7.panel.create({ el: self.$el });
    },
    open(animate) {
      const self = this;
      if (!self.$f7) return;
      const side = self.side || (self.left ? 'left' : 'right');
      self.$f7.panel.open(side, animate);
    },
    close(animate) {
      const self = this;
      if (!self.$f7) return;
      const side = self.side || (self.left ? 'left' : 'right');
      self.$f7.panel.close(side, animate);
    },
  },
};

var f7PhotoBrowser = {
  name: 'f7-photo-browser',
  render() {},
  beforeDestroy() {
    const self = this;
    if (self.f7PhotoBrowser && self.f7PhotoBrowser.destroy) self.f7PhotoBrowser.destroy();
  },
  watch: {
    photos(newValue) {
      const self = this;
      const pb = self.f7PhotoBrowser;
      if (!pb) return;
      self.f7PhotoBrowser.photos = newValue;
      if (pb.opened && pb.swiper) {
        pb.swiper.update();
      }
    },
  },
  props: {
    init: {
      type: Boolean,
      default: true,
    },
    params: Object,
    photos: Array,
    exposition: Boolean,
    expositionHideCaptions: Boolean,
    type: String,
    navbar: Boolean,
    toolbar: Boolean,
    theme: String,
    captionsTheme: String,
    swipeToClose: Boolean,
    backLinkText: String,
    navbarOfText: String,
    iconsColor: String,
    swiper: Object,
    url: String,
    view: [String, Object],
    routableModals: Boolean,
    renderNavbar: Function,
    renderToolbar: Function,
    renderCaption: Function,
    renderObject: Function,
    renderLazyPhoto: Function,
    renderPhoto: Function,
    renderPage: Function,
    renderPopup: Function,
    renderStandalone: Function,
  },
  methods: {
    open(index) {
      return this.f7PhotoBrowser.open(index);
    },
    close() {
      return this.f7PhotoBrowser.close();
    },
    expositionToggle() {
      return this.f7PhotoBrowser.expositionToggle();
    },
    expositionEnable() {
      return this.f7PhotoBrowser.expositionEnable();
    },
    expositionDisable() {
      return this.f7PhotoBrowser.expositionDisable();
    },
    onF7Init(f7) {
      const self = this;
      // Init Virtual List
      if (!self.init) return;
      let params;

      if (typeof self.params !== 'undefined') params = self.params;
      else params = self.$options.propsData;

      params = Utils.extend({}, params, {
        on: {
          open() {
            self.$emit('photobrowser:open');
          },
          close() {
            self.$emit('photobrowser:close');
          },
          opened() {
            self.$emit('photobrowser:opened');
          },
          closed() {
            self.$emit('photobrowser:closed');
          },
          swipeToClose() {
            self.$emit('photobrowser:swipetoclose');
          },
        },
      });

      self.f7PhotoBrowser = f7.photoBrowser.create(params);
    },
  },
};

const PopoverProps = Utils.extend(
  {
    opened: Boolean,
    target: [String, Object],
  },
  Mixins.colorProps
);

var f7Popover = {
  name: 'f7-popover',
  render(c) {
    const self = this;
    const angleEl = c('div', { staticClass: 'popover-angle' });
    const innerEl = c('div', { staticClass: 'popover-inner' }, self.$slots.default);
    return c('div', {
      class: self.classes,
      staticClass: 'popover',
      on: {
        'popover:open': self.onOpen,
        'popover:opened': self.onOpened,
        'popover:close': self.onClose,
        'popover:closed': self.onClosed,
      },
    }, [angleEl, innerEl]);
  },
  watch: {
    opened(opened) {
      const self = this;
      if (!self.f7Popover) return;
      if (opened) {
        self.f7Popover.open();
      } else {
        self.f7Popover.close();
      }
    },
  },
  props: PopoverProps,
  computed: {
    classes() {
      const self = this;
      return Mixins.colorClasses(self);
    },
  },
  beforeDestroy() {
    const self = this;
    if (self.f7Popover) self.f7Popover.destroy();
  },
  methods: {
    onOpen(event) {
      this.$emit('popover:open', event);
    },
    onOpened(event) {
      this.$emit('popover:opened', event);
    },
    onClose(event) {
      this.$emit('popover:close', event);
    },
    onClosed(event) {
      this.$emit('popover:closed', event);
    },
    open(target, animate) {
      const self = this;
      if (!self.$f7) return undefined;
      return self.$f7.popover.open(self.$el, target, animate);
    },
    close(animate) {
      const self = this;
      if (!self.$f7) return undefined;
      return self.$f7.sheet.close(self.$el, animate);
    },
    onF7Ready() {
      const self = this;
      const popoverParams = {
        el: self.$el,
      };
      if (self.target) popoverParams.targetEl = self.target;
      self.f7Popover = self.$f7.popover.create(popoverParams);
      if (self.opened && self.target) {
        self.f7Popover.open(self.target, false);
      }
    },
  },
};

const PopupProps = Utils.extend(
  {
    'tablet-fullscreen': Boolean,
    opened: Boolean,
  },
  Mixins.colorProps
);

var f7Popup = {
  name: 'f7-popup',
  render(c) {
    const self = this;
    return c('div', {
      staticClass: 'popup',
      class: self.classes,
      on: {
        'popup:open': self.onOpen,
        'popup:opened': self.onOpened,
        'popup:close': self.onClose,
        'popup:closed': self.onClosed,
      },
    }, self.$slots.default);
  },
  watch: {
    opened(opened) {
      const self = this;
      if (!self.f7Popup) return;
      if (opened) {
        self.f7Popup.open();
      } else {
        self.f7Popup.close();
      }
    },
  },
  props: PopupProps,
  computed: {
    classes() {
      const self = this;
      return Utils.extend({
        'popup-tablet-fullscreen': self.tabletFullscreen,
      }, Mixins.colorClasses(self));
    },
  },
  beforeDestroy() {
    const self = this;
    if (self.f7Popup) self.f7Popup.destroy();
  },
  methods: {
    onOpen(event) {
      this.$emit('popup:open', event);
    },
    onOpened(event) {
      this.$emit('popup:opened', event);
    },
    onClose(event) {
      this.$emit('popup:close', event);
    },
    onClosed(event) {
      this.$emit('popup:closed', event);
    },
    open(animate) {
      const self = this;
      if (!self.$f7) return undefined;
      return self.$f7.popup.open(self.$el, animate);
    },
    close(animate) {
      const self = this;
      if (!self.$f7) return undefined;
      return self.$f7.popup.close(self.$el, animate);
    },
    onF7Ready() {
      const self = this;
      self.f7Popup = self.$f7.popup.create({
        el: self.$el,
      });
      if (self.opened) {
        self.f7Popup.open(false);
      }
    },
  },
};

const PreloaderProps = Utils.extend({
  size: [Number, String],
}, Mixins.colorProps);

var f7Preloader = {render: function(){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('span',{staticClass:"preloader",class:_vm.classes,style:({'width': (_vm.sizeComputed ? `${_vm.sizeComputed}px` : ''), 'height': (_vm.sizeComputed ? `${_vm.sizeComputed}px` : '')})},[(_vm.$theme.md)?_c('span',{staticClass:"preloader-inner"},[_c('span',{staticClass:"preloader-inner-gap"}),_vm._v(" "),_vm._m(0),_vm._v(" "),_vm._m(1)]):_vm._e()])},staticRenderFns: [function(){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('span',{staticClass:"preloader-inner-left"},[_c('span',{staticClass:"preloader-inner-half-circle"})])},function(){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('span',{staticClass:"preloader-inner-right"},[_c('span',{staticClass:"preloader-inner-half-circle"})])}],
  name: 'f7-preloader',
  props: PreloaderProps,
  computed: {
    classes() {
      return Mixins.colorClasses(this);
    },
    sizeComputed() {
      let s = this.size;
      if (s && typeof s === 'string' && s.indexOf('px') >= 0) {
        s = s.replace('px', '');
      }
      return s;
    },
  },
};

const ProgressbarProps = Utils.extend({
  progress: Number,
  infinite: Boolean,
}, Mixins.colorProps);

var f7Progressbar = {
  name: 'f7-progressbar',
  render(c) {
    const self = this;
    const { progress } = self;
    return c('span', {
      staticClass: 'progressbar',
      class: self.classes,
      attrs: {
        'data-progress': progress,
      },
    }, [
      c('span', {
        style: {
          transform: progress ? `translate3d(${-100 + progress}%, 0, 0)` : '',
          '-webkit-transform': progress ? `translate3d(${-100 + progress}%, 0, 0)` : '',
        },
      }),
    ]);
  },
  props: ProgressbarProps,
  computed: {
    classes() {
      return Utils.extend({
        'progressbar-infinite': this.infinite,
      }, Mixins.colorClasses(this));
    },
  },
  methods: {
    set(progress, speed) {
      const self = this;
      if (!self.$f7) return;
      self.$f7.progressbar.set(self.$el, progress, speed);
    },
  },
};

const RadioProps = Utils.extend({
  checked: Boolean,
  name: [Number, String],
  value: [Number, String, Boolean],
  disabled: Boolean,
  readonly: Boolean,
}, Mixins.colorProps);

var f7Radio = {
  name: 'f7-radio',
  props: RadioProps,
  render(c) {
    const self = this;

    const inputEl = c('input', {
      attrs: {
        type: 'radio',
        name: self.name,
      },
      domProps: {
        value: self.value,
        disabled: self.disabled,
        readonly: self.readonly,
        checked: self.checked,
      },
      on: {
        change: self.onChange,
      },
    });

    const iconEl = c('i', { staticClass: 'icon-radio' });

    return c('label', {
      staticClass: 'radio',
      class: Utils.extend({
        disabled: self.disabled,
      }, Mixins.colorClasses(self)),
    }, [inputEl, iconEl, self.$slots.default]);
  },
  methods: {
    onChange(event) {
      this.$emit('change', event);
    },
  },
};

var f7RoutableModals = {
  name: 'f7-routable-modals',
  data() {
    return {
      modals: [],
    };
  },
  render(c) {
    const self = this;
    const modals = self.modals.map(modal => c(modal.component, {
      tag: 'component',
      props: modal.params ? modal.params || {} : {},
      key: modal.id,
    }));
    return c(
      'div',
      {
        staticClass: 'framework7-modals',
        ref: 'routableModals',
      },
      modals
    );
  },
};

const RowProps = Utils.extend(
  {
    noGap: Boolean,
    tag: {
      type: String,
      default: 'div',
    },
  },
  Mixins.colorProps
);

var f7Row = {
  name: 'f7-row',
  props: RowProps,
  render(c) {
    const self = this;
    return c(self.tag, {
      staticClass: 'row',
      class: self.classes,
    }, [self.$slots.default]);
  },
  computed: {
    classes() {
      const self = this;
      return Utils.extend(
        {
          'no-gap': self.noGap,
        },
        Mixins.colorClasses(self)
      );
    },
  },
};

const SearchbarProps = Utils.extend(
  {
    noShadow: Boolean,
    noHairline: Boolean,
    form: {
      type: Boolean,
      default: true,
    },
    placeholder: {
      type: String,
      default: 'Search',
    },
    disableButton: {
      type: Boolean,
      default: true,
    },
    disableButtonText: {
      type: String,
      default: 'Cancel',
    },
    clearButton: {
      type: Boolean,
      default: true,
    },

    // SB Params
    expandable: Boolean,
    searchContainer: [String, Object],
    searchIn: {
      type: String,
      default: '.item-title',
    },
    searchItem: {
      type: String,
      default: 'li',
    },
    foundEl: {
      type: [String, Object],
      default: '.searchbar-found',
    },
    notFoundEl: {
      type: [String, Object],
      default: '.searchbar-not-found',
    },
    backdrop: {
      type: Boolean,
      default: true,
    },
    backdropEl: [String, Object],
    hideOnEnableEl: {
      type: [String, Object],
      default: '.searchbar-hide-on-enable',
    },
    hideOnSearchEl: {
      type: [String, Object],
      default: '.searchbar-hide-on-search',
    },
    ignore: {
      type: String,
      default: '.searchbar-ignore',
    },
    customSearch: {
      type: Boolean,
      default: false,
    },
    removeDiacritics: {
      type: Boolean,
      default: false,
    },
    hideDividers: {
      type: Boolean,
      default: true,
    },
    hideGroups: {
      type: Boolean,
      default: true,
    },
    init: {
      type: Boolean,
      default: true,
    },
  },
  Mixins.colorProps
);

var f7Searchbar = {
  name: 'f7-searchbar',
  render(c) {
    const self = this;
    let clearEl;
    let disableEl;

    const inputEl = c('input', {
      attrs: {
        placeholder: self.placeholder,
        type: 'search',
      },
      on: {
        input: self.onInput,
        change: self.onChange,
        focus: self.onFocus,
        blur: self.onBlur,
      },
    });
    if (self.clearButton) {
      clearEl = c('span', {
        staticClass: 'input-clear-button',
        on: {
          click: self.onClearButtonClick,
        },
      });
    }
    if (self.disableButton) {
      disableEl = c('span', {
        staticClass: 'searchbar-disable-button',
        on: {
          click: self.onDisableButtonClick,
        },
      }, [self.disableButtonText]);
    }
    const iconEl = c('i', {
      staticClass: 'searchbar-icon',
    });

    const inputWrapEl = c('div', { staticClass: 'searchbar-input-wrap' }, [self.$slots['input-wrap-start'], inputEl, iconEl, clearEl, self.$slots['input-wrap-end']]);

    const innerEl = c('div', {
      staticClass: 'searchbar-inner',
    }, [self.$slots['inner-start'], inputWrapEl, disableEl, self.$slots['inner-end'], self.$slots.default]);

    return c(self.form ? 'form' : 'div', {
      staticClass: 'searchbar',
      class: Utils.extend({
        'no-shadow': self.noShadow,
        'no-hairline': self.noHairline,
        'searchbar-expandable': self.expandable,
      }, Mixins.colorClasses(self)),
      on: {
        submit: self.onSubmit,
      },
    }, [self.$slots['before-inner'], innerEl, self.$slots['after-inner']]);
  },
  beforeDestroy() {
    if (this.f7Searchbar && this.f7Searchbar.destroy) this.f7Searchbar.destroy();
  },
  props: SearchbarProps,
  methods: {
    search(query) {
      if (!this.f7Searchbar) return undefined;
      return this.f7Searchbar.search(query);
    },
    enable() {
      if (!this.f7Searchbar) return undefined;
      return this.f7Searchbar.enable();
    },
    disable() {
      if (!this.f7Searchbar) return undefined;
      return this.f7Searchbar.disable();
    },
    toggle() {
      if (!this.f7Searchbar) return undefined;
      return this.toggle.disable();
    },
    clear() {
      if (!this.f7Searchbar) return undefined;
      return this.f7Searchbar.clear();
    },
    onChange(event) {
      this.$emit('change', event);
    },
    onInput(event) {
      this.$emit('input', event);
    },
    onFocus(event) {
      this.$emit('focus', event);
    },
    onBlur(event) {
      this.$emit('blur', event);
    },
    onSubmit(event) {
      this.$emit('submit', event);
    },
    onClearButtonClick(event) {
      this.$emit('click:clear', event);
    },
    onDisableButtonClick(event) {
      this.$emit('click:disable', event);
    },

    onF7Ready() {
      const self = this;
      if (!self.init) return;
      const params = {
        el: self.$el,
        searchContainer: self.searchContainer,
        searchIn: self.searchIn,
        searchItem: self.searchItem,
        hideOnEnableEl: self.hideOnEnableEl,
        hideOnSearchEl: self.hideOnSearchEl,
        foundEl: self.foundEl,
        notFoundEl: self.notFoundEl,
        backdrop: self.backdrop,
        backdropEl: self.backdropEl,
        disableButton: self.disableButton,
        ignore: self.ignore,
        customSearch: self.customSearch,
        removeDiacritics: self.removeDiacritics,
        hideDividers: self.hideDividers,
        hideGroups: self.hideGroups,
        on: {
          search(searchbar, query, previousQuery) {
            self.$emit('searchbar:search', searchbar, query, previousQuery);
          },
          clear(searchbar, previousQuery) {
            self.$emit('searchbar:clear', searchbar, previousQuery);
          },
          enable(searchbar) {
            self.$emit('searchbar:enable', searchbar);
          },
          disable(searchbar) {
            self.$emit('searchbar:disable', searchbar);
          },
        },
      };
      Object.keys(params).forEach((key) => {
        if (typeof params[key] === 'undefined' || params[key] === '') {
          delete params[key];
        }
      });
      self.f7Searchbar = self.$f7.searchbar.create(params);
    },
  },
};

const SegmentedProps = Utils.extend({
  raised: Boolean,
  round: Boolean,
  tag: {
    type: String,
    default: 'div',
  },
}, Mixins.colorProps);

var f7Segmented = {
  name: 'f7-segmented',
  props: SegmentedProps,
  render(c) {
    const self = this;
    return c(self.tag, {
      staticClass: 'segmented',
      class: Utils.extend({
        'segmented-raised': self.raised,
        'segmented-round': self.round,
      }, Mixins.colorClasses(self)),
    }, [self.$slots.default]);
  },
};

const SheetProps = Utils.extend(
  {
    opened: Boolean,
    backdrop: Boolean,
  },
  Mixins.colorProps
);

var f7Sheet = {
  name: 'f7-sheet',
  render(c) {
    const self = this;
    const fixedList = [];
    const staticList = [];
    const fixedTags = ('navbar toolbar tabbar subnavbar searchbar messagebar fab').split(' ');

    let tag;
    let child;

    if (self.$slots.default) {
      for (let i = 0; i < self.$slots.default.length; i += 1) {
        child = self.$slots.default[i];
        tag = child.tag;
        if (!tag) {
          staticList.push(child);
          continue; // eslint-disable-line
        }
        let isFixed = false;
        for (let j = 0; j < fixedTags.length; j += 1) {
          if (tag.indexOf(fixedTags[j]) >= 0) {
            isFixed = true;
          }
        }
        if (isFixed) fixedList.push(child);
        else staticList.push(child);
      }
    }

    const innerEl = c('div', {
      staticClass: 'sheet-modal-inner',
    }, staticList);

    return c('div', {
      class: self.classes,
      staticClass: 'sheet-modal',
      on: {
        'sheet:open': self.onOpen,
        'sheet:opened': self.onOpened,
        'sheet:close': self.onClose,
        'sheet:closed': self.onClosed,
      },
    }, [fixedList, innerEl]);
  },
  watch: {
    opened(opened) {
      const self = this;
      if (!self.f7Sheet) return;
      if (opened) {
        self.f7Sheet.open();
      } else {
        self.f7Sheet.close();
      }
    },
  },
  props: SheetProps,
  computed: {
    classes() {
      const self = this;
      return Mixins.colorClasses(self);
    },
  },
  beforeDestroy() {
    const self = this;
    if (self.f7Sheet) self.f7Sheet.destroy();
  },
  methods: {
    onOpen(event) {
      this.$emit('sheet:open', event);
    },
    onOpened(event) {
      this.$emit('sheet:opened', event);
    },
    onClose(event) {
      this.$emit('sheet:close', event);
    },
    onClosed(event) {
      this.$emit('sheet:closed', event);
    },
    open(animate) {
      const self = this;
      if (!self.$f7) return undefined;
      return self.$f7.sheet.open(self.$el, animate);
    },
    close(animate) {
      const self = this;
      if (!self.$f7) return undefined;
      return self.$f7.sheet.close(self.$el, animate);
    },
    onF7Ready() {
      const self = this;
      let backdrop = self.backdrop;
      if (self.$options.propsData.backdrop === undefined) {
        const app = self.$f7;
        backdrop = app.params.sheet && app.params.sheet.backdrop !== undefined ? app.params.sheet.backdrop : self.$theme.md;
      }
      self.f7Sheet = self.$f7.sheet.create({
        el: self.$el,
        backdrop,
      });
      if (self.opened) {
        self.f7Sheet.open(false);
      }
    },
  },
};

var f7Statusbar = {render: function(){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"statusbar",class:_vm.classes})},staticRenderFns: [],
  name: 'f7-statusbar',
  props: Mixins.colorProps,
  computed: {
    classes() {
      const self = this;
      return Mixins.colorClasses(self);
    },
  },
};

const StepperProps = Utils.extend({
  init: {
    type: Boolean,
    default: true,
  },
  value: {
    type: Number,
    default: 0,
  },
  min: {
    type: Number,
    default: 0,
  },
  max: {
    type: Number,
    default: 100,
  },
  step: {
    type: Number,
    default: 1,
  },
  formatValue: Function,
  input: {
    type: Boolean,
    default: true,
  },
  inputType: {
    type: String,
    default: 'text',
  },
  inputReadonly: {
    type: Boolean,
    default: true,
  },
  autorepeat: {
    type: Boolean,
    default: false,
  },
  autorepeatDynamic: {
    type: Boolean,
    default: false,
  },
  wraps: {
    type: Boolean,
    default: false,
  },
  disabled: Boolean,
  buttonsOnly: Boolean,

  round: Boolean,
  roundMd: Boolean,
  roundIos: Boolean,
  fill: Boolean,
  fillMd: Boolean,
  fillIos: Boolean,
  big: Boolean,
  bigMd: Boolean,
  bigIos: Boolean,
  small: Boolean,
  smallMd: Boolean,
  smallIos: Boolean,
  raised: Boolean,
}, Mixins.colorProps);

var f7Stepper = {render: function(){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"stepper",class:_vm.classes},[_c('div',{staticClass:"stepper-button-minus",on:{"click":_vm.onMinusClick}}),_vm._v(" "),(_vm.input && !_vm.buttonsOnly)?_c('div',{staticClass:"stepper-input-wrap"},[_c('input',{attrs:{"type":_vm.inputType,"min":_vm.inputType === 'number' ? _vm.min : undefined,"max":_vm.inputType === 'number' ? _vm.max : undefined,"step":_vm.inputType === 'number' ? _vm.step : undefined,"readonly":_vm.inputReadonly},domProps:{"value":_vm.value},on:{"input":_vm.onInput}})]):_vm._e(),_vm._v(" "),(!_vm.input && !_vm.buttonsOnly)?_c('div',{staticClass:"stepper-value"},[_vm._v(_vm._s(_vm.value))]):_vm._e(),_vm._v(" "),_c('div',{staticClass:"stepper-button-plus",on:{"click":_vm.onPlusClick}})])},staticRenderFns: [],
  props: StepperProps,
  computed: {
    classes() {
      const self = this;
      const {
        round,
        roundIos,
        roundMd,
        fill,
        fillIos,
        fillMd,
        big,
        bigIos,
        bigMd,
        small,
        smallIos,
        smallMd,
        raised,
      } = self;

      return Utils.extend({
        disabled: self.disabled,
        'stepper-round': round,
        'stepper-round-ios': roundIos,
        'stepper-round-md': roundMd,
        'stepper-fill': fill,
        'stepper-fill-ios': fillIos,
        'stepper-fill-md': fillMd,
        'stepper-big': big,
        'stepper-big-ios': bigIos,
        'stepper-big-md': bigMd,
        'stepper-small': small,
        'stepper-small-ios': smallIos,
        'stepper-small-md': smallMd,
        'stepper-raised': raised,
      }, Mixins.colorClasses(self));
    },
  },
  beforeDestroy() {
    if (!this.init) return;
    if (this.f7Stepper && this.f7Stepper.destroy) {
      this.f7Stepper.destroy();
    }
  },
  methods: {
    increment() {
      if (!this.f7Stepper) return;
      this.f7Stepper.increment();
    },
    decrement() {
      if (!this.f7Stepper) return;
      this.f7Stepper.decrement();
    },
    setValue(newValue) {
      const self = this;
      if (self.f7Stepper && self.f7Stepper.setValue) self.f7Stepper.setValue(newValue);
    },
    getValue() {
      const self = this;
      if (self.f7Stepper && self.f7Stepper.getValue) {
        return self.f7Stepper.getValue();
      }
      return undefined;
    },
    onInput(e) {
      this.$emit('input', e, this.f7Stepper);
    },
    onMinusClick(e) {
      this.$emit('stepper:minusclick', e, this.f7Stepper);
    },
    onPlusClick(e) {
      this.$emit('stepper:plusclick', e, this.f7Stepper);
    },
    onF7Ready(f7) {
      const self = this;
      if (!self.init) return;
      const {
        min, max, value, step, formatValue, $el, autorepeat, autorepeatDynamic, wraps,
      } = self;
      self.f7Stepper = f7.stepper.create({
        el: $el,
        min,
        max,
        value,
        step,
        formatValue,
        autorepeat,
        autorepeatDynamic,
        wraps,
        on: {
          change(stepper, newValue) {
            self.$emit('stepper:change', newValue);
          },
        },
      });
    },
  },
}

const SubnavbarProps = Utils.extend({
  sliding: Boolean,
  title: String,
  inner: {
    type: Boolean,
    default: true,
  },
}, Mixins.colorProps);

var f7Subnavbar = {render: function(){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"subnavbar",class:_vm.classes},[(_vm.inner)?_c('div',{staticClass:"subnavbar-inner"},[(_vm.title)?_c('div',{staticClass:"title"},[_vm._v(_vm._s(_vm.title))]):_vm._e(),_vm._v(" "),_vm._t("default")],2):_vm._t("default")],2)},staticRenderFns: [],
  name: 'f7-subnavbar',
  props: SubnavbarProps,
  computed: {
    classes() {
      return Utils.extend({
        sliding: this.sliding,
      }, Mixins.colorClasses(this));
    },
  },
};

const SwipeoutActionsProps = Utils.extend({
  left: Boolean,
  right: Boolean,
  side: String,
}, Mixins.colorProps);

var f7SwipeoutActions = {render: function(){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{class:_vm.classes},[_vm._t("default")],2)},staticRenderFns: [],
  name: 'f7-swipeout-actions',
  props: SwipeoutActionsProps,
  computed: {
    classes() {
      return Utils.extend({
        [`swipeout-actions-${this.sideComputed}`]: true,
      }, Mixins.colorClasses(this));
    },
    sideComputed() {
      if (!this.side) {
        if (this.left) return 'left';
        if (this.right) return 'right';
        return 'right';
      }
      return this.side;
    },
  },
  data() {
    return {};
  },
};

const SwipeoutButtonProps = Utils.extend({
  text: String,
  confirmText: String,
  overswipe: Boolean,
  close: Boolean,
  delete: Boolean,
}, Mixins.colorProps);

var f7SwipeoutButton = {render: function(){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('a',{class:_vm.classes,attrs:{"data-confirm":_vm.confirmText || undefined},on:{"click":_vm.onClick}},[_vm._t("default",[_vm._v(_vm._s(_vm.text))])],2)},staticRenderFns: [],
  name: 'f7-swipeout-button',
  props: SwipeoutButtonProps,
  computed: {
    classes() {
      return Utils.extend({
        'swipeout-overswipe': this.overswipe,
        'swipeout-delete': this.delete,
        'swipeout-close': this.close,
      }, Mixins.colorClasses(this));
    },
  },
  methods: {
    onClick(event) {
      this.$emit('click', event);
    },
  },
};

var f7SwiperSlide = {render: function(){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"swiper-slide"},[(_vm.zoom)?_c('div',{staticClass:"swiper-zoom-container"},[_vm._t("default")],2):_vm._t("default")],2)},staticRenderFns: [],
  name: 'f7-swiper-slide',
  props: {
    zoom: Boolean,
  },
};

const SwiperProps = Utils.extend({
  params: Object,
  pagination: Boolean,
  scrollbar: Boolean,
  navigation: Boolean,
  init: {
    type: Boolean,
    default: true,
  },
}, Mixins.colorProps);

var f7Swiper = {render: function(){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"swiper-container",class:_vm.classes},[_vm._t("before-wrapper"),_vm._v(" "),_c('div',{staticClass:"swiper-wrapper"},[_vm._t("default")],2),_vm._v(" "),(_vm.paginationComputed === true)?_c('div',{staticClass:"swiper-pagination"}):_vm._e(),_vm._v(" "),(_vm.scrollbarComputed === true)?_c('div',{staticClass:"swiper-scrollbar"}):_vm._e(),_vm._v(" "),(_vm.navigationComputed === true)?_c('div',{staticClass:"swiper-button-next"}):_vm._e(),_vm._v(" "),(_vm.navigationComputed === true)?_c('div',{staticClass:"swiper-button-prev"}):_vm._e(),_vm._v(" "),_vm._t("after-wrapper")],2)},staticRenderFns: [],
  name: 'f7-swiper',
  beforeDestroy() {
    const self = this;
    if (!self.init) return;
    if (self.swiper && self.swiper.destroy) self.swiper.destroy();
  },
  data() {
    return {
      initialUpdate: false,
    };
  },
  updated() {
    const self = this;
    if (!self.initialUpdate) {
      self.initialUpdate = true;
      return;
    }
    if (self.swiper && self.swiper.update) self.swiper.update();
  },
  props: SwiperProps,
  computed: {
    classes() {
      return Mixins.colorClasses(this);
    },
    paginationComputed() {
      const self = this;
      if (self.pagination === true || (self.params && self.params.pagination && !self.params.pagination.el)) {
        return true;
      }
      return false;
    },
    scrollbarComputed() {
      const self = this;
      if (self.scrollbar === true || (self.params && self.params.scrollbar && !self.params.scrollbar.el)) {
        return true;
      }
      return false;
    },
    navigationComputed() {
      const self = this;
      if (self.navigation === true || (self.params && self.params.navigation && !self.params.navigation.nextEl && !self.params.navigation.prevEl)) {
        return true;
      }
      return false;
    },
  },
  methods: {
    onF7Ready(f7) {
      const self = this;
      if (!self.init) return;
      const params = {
        pagination: {},
        navigation: {},
        scrollbar: {},
      };
      if (self.params) Utils.extend(params, self.params);
      if (self.pagination && !params.pagination.el) params.pagination.el = '.swiper-pagination';
      if (self.navigation && !params.navigation.nextEl && !params.navigation.prevEl) {
        params.navigation.nextEl = '.swiper-button-next';
        params.navigation.prevEl = '.swiper-button-prev';
      }
      if (self.scrollbar && !params.scrollbar.el) params.scrollbar.el = '.swiper-scrollbar';

      self.swiper = f7.swiper.create(this.$el, params);
    },
  },
};

const TabProps = Utils.extend({
  tabActive: Boolean,
  id: String,
}, Mixins.colorProps);

var f7Tab = {
  name: 'f7-tab',
  props: TabProps,
  data() {
    return {
      tabContent: null,
    };
  },
  render(c) {
    const self = this;

    return c(
      'div', {
        staticClass: 'tab',
        attrs: {
          id: self.id,
        },
        class: Utils.extend({
          'tab-active': self.tabActive,
        }, Mixins.colorClasses(self)),
        on: {
          'tab:show': self.onTabShow,
          'tab:hide': self.onTabHide,
        },
      },
      [self.tabContent ? c(self.tabContent.component, { tag: 'component', props: self.tabContent.params, key: self.tabContent.id }) : self.$slots.default]
    );
  },
  methods: {
    show(animate) {
      if (!this.$f7) return;
      this.$f7.tab.show(this.$el, animate);
    },
    onTabShow(e) {
      this.$emit('tab:show', e);
    },
    onTabHide(e) {
      this.$emit('tab:hide', e);
    },
  },
};

const TabsProps = Utils.extend({
  animated: Boolean,
  swipeable: Boolean,
  routable: Boolean,
}, Mixins.colorProps);

var f7Tabs = {
  name: 'f7-tabs',
  render(c) {
    const self = this;
    const tabsEl = c('div', { staticClass: 'tabs' }, [self.$slots.default]);
    if (self.animated || self.swipeable) return c('div', { class: self.classes }, [tabsEl]);
    return tabsEl;
  },
  props: TabsProps,
  computed: {
    classes() {
      return Utils.extend({
        'tabs-animated-wrap': this.animated,
        'tabs-swipeable-wrap': this.swipeable,
        'tabs-routable': this.routable,
      }, Mixins.colorClasses(this));
    },
  },
};

const ToolbarProps = Utils.extend({
  bottomMd: Boolean,
  tabbar: Boolean,
  labels: Boolean,
  scrollable: Boolean,
  hidden: Boolean,
  noShadow: Boolean,
  noHairline: Boolean,
  inner: {
    type: Boolean,
    default: true,
  },
}, Mixins.colorProps);

var f7Toolbar = {render: function(){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"toolbar",class:_vm.classes},[_vm._t("before-inner"),_vm._v(" "),(_vm.inner)?_c('div',{staticClass:"toolbar-inner"},[_vm._t("default")],2):_vm._t("default"),_vm._v(" "),_vm._t("after-inner")],2)},staticRenderFns: [],
  name: 'f7-toolbar',
  props: ToolbarProps,
  updated() {
    const self = this;
    if (self.tabbar && self.$f7) {
      self.$nextTick(() => {
        self.$f7.toolbar.setHighlight(self.$el);
      });
    }
  },
  computed: {
    classes() {
      const self = this;
      return Utils.extend({
        'toolbar-bottom-md': self.bottomMd,
        tabbar: self.tabbar,
        'tabbar-labels': self.labels,
        'tabbar-scrollable': self.scrollable,
        'toolbar-hidden': self.hidden,
        'no-shadow': self.noShadow,
        'no-hairline': self.noHairline,
      }, Mixins.colorClasses(self));
    },
  },
  methods: {
    hide(animate) {
      const self = this;
      if (!self.$f7) return;
      self.$f7.toolbar.hide(this.$el, animate);
    },
    show(animate) {
      const self = this;
      if (!self.$f7) return;
      self.$f7.toolbar.show(this.$el, animate);
    },
    onF7Ready(f7) {
      const self = this;
      if (self.tabbar) f7.toolbar.setHighlight(self.$el);
    },
  },
};

const ViewProps = Utils.extend(
  {
    tab: Boolean,
    tabActive: Boolean,

    name: String,
    router: Boolean,
    linksView: [Object, String],
    url: String,
    main: Boolean,
    stackPages: Boolean,
    xhrCache: String,
    xhrCacheIgnore: Array,
    xhrCacheIgnoreGetParameters: Boolean,
    xhrCacheDuration: Number,
    preloadPreviousPage: Boolean,
    uniqueHistory: Boolean,
    uniqueHistoryIgnoreGetParameters: Boolean,
    allowDuplicateUrls: Boolean,
    reloadPages: Boolean,
    removeElements: Boolean,
    removeElementsWithTimeout: Boolean,
    removeElementsTimeout: Number,
    restoreScrollTopOnBack: Boolean,
    // Swipe Back
    iosSwipeBack: Boolean,
    iosSwipeBackAnimateShadow: Boolean,
    iosSwipeBackAnimateOpacity: Boolean,
    iosSwipeBackActiveArea: Number,
    iosSwipeBackThreshold: Number,
    // Push State
    pushState: Boolean,
    pushStateRoot: String,
    pushStateAnimate: Boolean,
    pushStateAnimateOnLoad: Boolean,
    pushStateSeparator: String,
    pushStateOnLoad: Boolean,
    // Animate Pages
    animate: Boolean,
    // iOS Dynamic Navbar
    iosDynamicNavbar: Boolean,
    iosSeparateDynamicNavbar: Boolean,
    // Animate iOS Navbar Back Icon
    iosAnimateNavbarBackIcon: Boolean,
    // MD Theme delay
    materialPageLoadDelay: Number,

    passRouteQueryToRequest: Boolean,
    passRouteParamsToRequest: Boolean,
    routes: Array,
    routesAdd: Array,

    init: {
      type: Boolean,
      default: true,
    },
  },
  Mixins.colorProps
);

var f7View = {
  name: 'f7-view',
  props: ViewProps,
  render(c) {
    const self = this;
    const pages = self.pages.map(page => c(page.component, {
      tag: 'component',
      props: page.params ? page.params || {} : {},
      key: page.id,
    }));
    return c(
      'div',
      {
        staticClass: 'view',
        ref: 'view',
        class: self.classes,
        on: {
          'swipeback:move': self.onSwipeBackMove,
          'swipeback:beforechange': self.onSwipeBackBeforeChange,
          'swipeback:afterchange': self.onSwipeBackAfterChange,
          'swipeback:beforereset': self.onSwipeBackBeforeReset,
          'swipeback:afterreset': self.onSwipeBackAfterReset,
          'tab:show': self.onTabShow,
          'tab:hide': self.onTabHide,
        },
      },
      [
        self.$slots.default,
        pages,
      ]
    );
  },
  beforeDestroy() {
    const self = this;
    if (self.f7View && self.f7View.destroy) self.f7View.destroy();
  },
  data() {
    return {
      pages: [],
    };
  },
  computed: {
    classes() {
      return Utils.extend(
        {
          'view-main': this.main,
          'tab-active': this.tabActive,
          tab: this.tab,
        },
        Mixins.colorClasses(this)
      );
    },
  },
  methods: {
    onF7Ready(f7) {
      const self = this;
      if (!self.init) return;

      // Init View
      self.f7View = f7.views.create(self.$el, self.$options.propsData);
    },
    onSwipeBackMove(event) {
      this.$emit('swipeback:move', event, event.detail);
    },
    onSwipeBackBeforeChange(event) {
      this.$emit('swipeback:beforechange', event, event.detail);
    },
    onSwipeBackAfterChange(event) {
      this.$emit('swipeback:afterchange', event, event.detail);
    },
    onSwipeBackBeforeReset(event) {
      this.$emit('swipeback:beforereset', event, event.detail);
    },
    onSwipeBackAfterReset(event) {
      this.$emit('swipeback:afterreset', event, event.detail);
    },
    onTabShow(e) {
      this.$emit('tab:show', e);
    },
    onTabHide(e) {
      this.$emit('tab:hide', e);
    },
  },
};

const ViewsProps = Utils.extend(
  {
    tabs: Boolean,
  },
  Mixins.colorProps
);

var f7Views = {render: function(){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"views",class:_vm.classes},[_vm._t("default")],2)},staticRenderFns: [],
  name: 'f7-views',
  props: ViewsProps,
  computed: {
    classes() {
      return Utils.extend(
        {
          tabs: this.tabs,
        },
        Mixins.colorClasses(this)
      );
    },
  },
};

/* eslint no-param-reassign: "off" */

var vuePlugin = {
  install(Vue, Framework7 = window.Framework7) {
    // Check for F7
    if (typeof Framework7 === 'undefined') {
      throw new Error('Framework7 is undefined, make sure you have passed it as an argument: Vue.use(Framework7Vue, Framework7)');
    }
    // Event Hub
    const eventHub = new Vue();

    // Flags
    let f7Ready = false;
    let f7Instance;

    // Define protos
    Object.defineProperty(Vue.prototype, '$f7', {
      get() {
        return f7Instance;
      },
    });

    const $theme = {};
    Object.defineProperty(Vue.prototype, '$theme', {
      get() {
        return {
          ios: f7Instance ? f7Instance.theme === 'ios' : $theme.ios,
          md: f7Instance ? f7Instance.theme === 'md' : $theme.md,
        };
      },
    });
    Vue.prototype.Dom7 = Framework7.$;
    Vue.prototype.$$ = Framework7.$;
    Vue.prototype.$device = Framework7.device;
    Vue.prototype.$request = Framework7.request;
    Vue.prototype.$utils = Framework7.utils;

    // Init F7
    function initFramework7(rootEl, params, routes) {
      const f7Params = Utils.extend({}, (params || {}), { root: rootEl });
      if (routes && routes.length && !f7Params.routes) f7Params.routes = routes;

      f7Instance = new Framework7(f7Params);
      f7Ready = true;
      eventHub.$emit('f7Ready', f7Instance);
    }

    // Extend F7 Router
    Framework7.Router
      .use(VueRouter)
      .use({
        on: {
          routeChange(to, from, router) {
            eventHub.$emit('f7RouteChange', to, from, router);
          },
          routeChanged(to, from, router) {
            eventHub.$emit('f7RouteChanged', to, from, router);
          },
        },
      });

    // Mixin
    Vue.mixin({
      directives: Directives,
      components: {
        // eslint-disable-next-line
        f7AccordionContent,
        f7AccordionItem,
        f7AccordionToggle,
        f7Accordion,
        f7ActionsButton,
        f7ActionsGroup,
        f7ActionsLabel,
        f7Actions,
        f7Badge,
        f7BlockFooter,
        f7BlockHeader,
        f7BlockTitle,
        f7Block,
        f7Button,
        f7CardContent,
        f7CardFooter,
        f7CardHeader,
        f7Card,
        f7Checkbox,
        f7Chip,
        f7Col,
        f7FabButton,
        f7FabButtons,
        f7Fab,
        f7Icon,
        f7Input,
        f7Label,
        f7Link,
        f7ListButton,
        f7ListGroup,
        f7ListIndex,
        f7ListItemCell,
        f7ListItemContent,
        f7ListItemRow,
        f7ListItem,
        f7List,
        f7LoginScreenTitle,
        f7LoginScreen,
        f7Message,
        f7MessagebarAttachment,
        f7MessagebarAttachments,
        f7MessagebarSheetImage,
        f7MessagebarSheetItem,
        f7MessagebarSheet,
        f7Messagebar,
        f7MessagesTitle,
        f7Messages,
        f7NavLeft,
        f7NavRight,
        f7NavTitle,
        f7Navbar,
        f7PageContent,
        f7Page,
        f7Panel,
        f7PhotoBrowser,
        f7Popover,
        f7Popup,
        f7Preloader,
        f7Progressbar,
        f7Radio,
        f7Range,
        f7RoutableModals,
        f7Row,
        f7Searchbar,
        f7Segmented,
        f7Sheet,
        f7Statusbar,
        f7Stepper,
        f7Subnavbar,
        f7SwipeoutActions,
        f7SwipeoutButton,
        f7SwiperSlide,
        f7Swiper,
        f7Tab,
        f7Tabs,
        f7Toggle,
        f7Toolbar,
        f7View,
        f7Views,
      },
      beforeCreate() {
        const self = this;
        if (self === self.$root) {
          const { theme } = (self.$options.framework7 || {});
          if (theme === 'md') $theme.md = true;
          if (theme === 'ios') $theme.ios = true;
          if (!theme || theme === 'auto') {
            $theme.ios = !!(Framework7.Device || Framework7.device).ios;
            $theme.md = !(Framework7.Device || Framework7.device).ios;
          }
        }

        let $route;
        let $router;
        let parent = self;
        while (parent && !$router && !$route) {
          if (parent.$f7route) $route = parent.$f7route;
          if (parent.$f7router) $router = parent.$f7router;
          else if (parent.f7View) {
            $router = parent.f7View.router;
          } else if (parent.$el && parent.$el.f7View) {
            $router = parent.$el.f7View.router;
          }
          parent = parent.$parent;
        }
        if ($route && $router) {
          self.$f7route = $route;
          self.$f7router = $router;
          self.$f7Route = $route;
          self.$f7Router = $router;
        }
      },
      beforeDestroy() {
        const self = this;
        if (self.$f7RouteChangeCallback) eventHub.$off('f7RouteChange', self.$f7RouteChangeCallback);
        if (self.$f7RouteChangedCallback) eventHub.$off('f7RouteChanged', self.$f7RouteChangedCallback);
      },
      created() {
        const self = this;

        const routeChangeCallback = self.onF7RouteChange || self.F7RouteChange || self.f7RouteChange || self.f7routeChange;
        const routeChangedCallback = self.onF7RouteChanged || self.F7RouteChanged || self.f7RouteChanged || self.f7routeChanged;
        if (!routeChangeCallback && !routeChangedCallback) return;

        function hasRouter(router) {
          return (self.$f7router && router === self.$f7router) ||
                 (!self.$f7router && self.$f7 && self.$f7.router);
        }

        function addRoutesCallbacks() {
          if (routeChangeCallback) {
            self.$f7RouteChangeCallback = function onRouteChange(to, from, router) {
              if (hasRouter(router)) {
                routeChangeCallback(to, from, router);
              }
            };
            eventHub.$on('f7RouteChange', self.$f7RouteChangeCallback);
          }
          if (routeChangedCallback) {
            self.$f7RouteChangedCallback = function onRouteChanged(to, from, router) {
              if (hasRouter(router)) {
                routeChangedCallback(to, from, router);
              }
            };
            eventHub.$on('f7RouteChanged', self.$f7RouteChangedCallback);
          }
        }

        if (!self.$f7) eventHub.$on('f7Ready', addRoutesCallbacks);
        else addRoutesCallbacks();
      },
      mounted() {
        const self = this;
        if (self === self.$root) {
          initFramework7(self.$root.$el, self.$options.framework7, self.$options.routes);
        }
        const callback = self.onF7Ready || self.onF7ready || self.onF7Init || self.onF7init || self.f7Ready || self.f7Init || self.f7ready || self.f7init;
        if (!callback) return;
        if (f7Ready) callback(f7Instance);
        else {
          eventHub.$on('f7Ready', (f7) => {
            callback(f7);
          });
        }
      },
    });
  },
};

/* harmony default export */ __webpack_exports__["a"] = (vuePlugin);


/***/ }),

/***/ "./node_modules/framework7/dist/framework7.esm.bundle.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export Request */
/* unused harmony export Utils */
/* unused harmony export Device */
/* unused harmony export Support */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_ssr_window__ = __webpack_require__("./node_modules/ssr-window/dist/ssr-window.esm.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_dom7__ = __webpack_require__("./node_modules/dom7/dist/dom7.module.js");
/* unused harmony reexport Dom7 */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_template7__ = __webpack_require__("./node_modules/template7/dist/template7.esm.js");
/* unused harmony reexport Template7 */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_path_to_regexp__ = __webpack_require__("./node_modules/framework7/node_modules/path-to-regexp/index.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_path_to_regexp___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_path_to_regexp__);
/**
 * Framework7 2.2.5
 * Full featured mobile HTML framework for building iOS & Android apps
 * http://framework7.io/
 *
 * Copyright 2014-2018 Vladimir Kharlampidi
 *
 * Released under the MIT License
 *
 * Released on: April 29, 2018
 */








/**
 * https://github.com/gre/bezier-easing
 * BezierEasing - use bezier curve for transition easing function
 * by Gatan Renaudeau 2014 - 2015  MIT License
 */

/* eslint-disable */

// These values are established by empiricism with tests (tradeoff: performance VS precision)
var NEWTON_ITERATIONS = 4;
var NEWTON_MIN_SLOPE = 0.001;
var SUBDIVISION_PRECISION = 0.0000001;
var SUBDIVISION_MAX_ITERATIONS = 10;

var kSplineTableSize = 11;
var kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);

var float32ArraySupported = typeof Float32Array === 'function';

function A (aA1, aA2) { return 1.0 - 3.0 * aA2 + 3.0 * aA1; }
function B (aA1, aA2) { return 3.0 * aA2 - 6.0 * aA1; }
function C (aA1)      { return 3.0 * aA1; }

// Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.
function calcBezier (aT, aA1, aA2) { return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT; }

// Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.
function getSlope (aT, aA1, aA2) { return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1); }

function binarySubdivide (aX, aA, aB, mX1, mX2) {
  var currentX, currentT, i = 0;
  do {
    currentT = aA + (aB - aA) / 2.0;
    currentX = calcBezier(currentT, mX1, mX2) - aX;
    if (currentX > 0.0) {
      aB = currentT;
    } else {
      aA = currentT;
    }
  } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);
  return currentT;
}

function newtonRaphsonIterate (aX, aGuessT, mX1, mX2) {
 for (var i = 0; i < NEWTON_ITERATIONS; ++i) {
   var currentSlope = getSlope(aGuessT, mX1, mX2);
   if (currentSlope === 0.0) {
     return aGuessT;
   }
   var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
   aGuessT -= currentX / currentSlope;
 }
 return aGuessT;
}

function bezier (mX1, mY1, mX2, mY2) {
  if (!(0 <= mX1 && mX1 <= 1 && 0 <= mX2 && mX2 <= 1)) {
    throw new Error('bezier x values must be in [0, 1] range');
  }

  // Precompute samples table
  var sampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);
  if (mX1 !== mY1 || mX2 !== mY2) {
    for (var i = 0; i < kSplineTableSize; ++i) {
      sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
    }
  }

  function getTForX (aX) {
    var intervalStart = 0.0;
    var currentSample = 1;
    var lastSample = kSplineTableSize - 1;

    for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {
      intervalStart += kSampleStepSize;
    }
    --currentSample;

    // Interpolate to provide an initial guess for t
    var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);
    var guessForT = intervalStart + dist * kSampleStepSize;

    var initialSlope = getSlope(guessForT, mX1, mX2);
    if (initialSlope >= NEWTON_MIN_SLOPE) {
      return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
    } else if (initialSlope === 0.0) {
      return guessForT;
    } else {
      return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
    }
  }

  return function BezierEasing (x) {
    if (mX1 === mY1 && mX2 === mY2) {
      return x; // linear
    }
    // Because JavaScript number are imprecise, we should guarantee the extremes are right.
    if (x === 0) {
      return 0;
    }
    if (x === 1) {
      return 1;
    }
    return calcBezier(getTForX(x), mY1, mY2);
  };
}

/* eslint no-control-regex: "off" */

// Remove Diacritics
const defaultDiacriticsRemovalap = [
  { base: 'A', letters: '\u0041\u24B6\uFF21\u00C0\u00C1\u00C2\u1EA6\u1EA4\u1EAA\u1EA8\u00C3\u0100\u0102\u1EB0\u1EAE\u1EB4\u1EB2\u0226\u01E0\u00C4\u01DE\u1EA2\u00C5\u01FA\u01CD\u0200\u0202\u1EA0\u1EAC\u1EB6\u1E00\u0104\u023A\u2C6F' },
  { base: 'AA', letters: '\uA732' },
  { base: 'AE', letters: '\u00C6\u01FC\u01E2' },
  { base: 'AO', letters: '\uA734' },
  { base: 'AU', letters: '\uA736' },
  { base: 'AV', letters: '\uA738\uA73A' },
  { base: 'AY', letters: '\uA73C' },
  { base: 'B', letters: '\u0042\u24B7\uFF22\u1E02\u1E04\u1E06\u0243\u0182\u0181' },
  { base: 'C', letters: '\u0043\u24B8\uFF23\u0106\u0108\u010A\u010C\u00C7\u1E08\u0187\u023B\uA73E' },
  { base: 'D', letters: '\u0044\u24B9\uFF24\u1E0A\u010E\u1E0C\u1E10\u1E12\u1E0E\u0110\u018B\u018A\u0189\uA779' },
  { base: 'DZ', letters: '\u01F1\u01C4' },
  { base: 'Dz', letters: '\u01F2\u01C5' },
  { base: 'E', letters: '\u0045\u24BA\uFF25\u00C8\u00C9\u00CA\u1EC0\u1EBE\u1EC4\u1EC2\u1EBC\u0112\u1E14\u1E16\u0114\u0116\u00CB\u1EBA\u011A\u0204\u0206\u1EB8\u1EC6\u0228\u1E1C\u0118\u1E18\u1E1A\u0190\u018E' },
  { base: 'F', letters: '\u0046\u24BB\uFF26\u1E1E\u0191\uA77B' },
  { base: 'G', letters: '\u0047\u24BC\uFF27\u01F4\u011C\u1E20\u011E\u0120\u01E6\u0122\u01E4\u0193\uA7A0\uA77D\uA77E' },
  { base: 'H', letters: '\u0048\u24BD\uFF28\u0124\u1E22\u1E26\u021E\u1E24\u1E28\u1E2A\u0126\u2C67\u2C75\uA78D' },
  { base: 'I', letters: '\u0049\u24BE\uFF29\u00CC\u00CD\u00CE\u0128\u012A\u012C\u0130\u00CF\u1E2E\u1EC8\u01CF\u0208\u020A\u1ECA\u012E\u1E2C\u0197' },
  { base: 'J', letters: '\u004A\u24BF\uFF2A\u0134\u0248' },
  { base: 'K', letters: '\u004B\u24C0\uFF2B\u1E30\u01E8\u1E32\u0136\u1E34\u0198\u2C69\uA740\uA742\uA744\uA7A2' },
  { base: 'L', letters: '\u004C\u24C1\uFF2C\u013F\u0139\u013D\u1E36\u1E38\u013B\u1E3C\u1E3A\u0141\u023D\u2C62\u2C60\uA748\uA746\uA780' },
  { base: 'LJ', letters: '\u01C7' },
  { base: 'Lj', letters: '\u01C8' },
  { base: 'M', letters: '\u004D\u24C2\uFF2D\u1E3E\u1E40\u1E42\u2C6E\u019C' },
  { base: 'N', letters: '\u004E\u24C3\uFF2E\u01F8\u0143\u00D1\u1E44\u0147\u1E46\u0145\u1E4A\u1E48\u0220\u019D\uA790\uA7A4' },
  { base: 'NJ', letters: '\u01CA' },
  { base: 'Nj', letters: '\u01CB' },
  { base: 'O', letters: '\u004F\u24C4\uFF2F\u00D2\u00D3\u00D4\u1ED2\u1ED0\u1ED6\u1ED4\u00D5\u1E4C\u022C\u1E4E\u014C\u1E50\u1E52\u014E\u022E\u0230\u00D6\u022A\u1ECE\u0150\u01D1\u020C\u020E\u01A0\u1EDC\u1EDA\u1EE0\u1EDE\u1EE2\u1ECC\u1ED8\u01EA\u01EC\u00D8\u01FE\u0186\u019F\uA74A\uA74C' },
  { base: 'OI', letters: '\u01A2' },
  { base: 'OO', letters: '\uA74E' },
  { base: 'OU', letters: '\u0222' },
  { base: 'OE', letters: '\u008C\u0152' },
  { base: 'oe', letters: '\u009C\u0153' },
  { base: 'P', letters: '\u0050\u24C5\uFF30\u1E54\u1E56\u01A4\u2C63\uA750\uA752\uA754' },
  { base: 'Q', letters: '\u0051\u24C6\uFF31\uA756\uA758\u024A' },
  { base: 'R', letters: '\u0052\u24C7\uFF32\u0154\u1E58\u0158\u0210\u0212\u1E5A\u1E5C\u0156\u1E5E\u024C\u2C64\uA75A\uA7A6\uA782' },
  { base: 'S', letters: '\u0053\u24C8\uFF33\u1E9E\u015A\u1E64\u015C\u1E60\u0160\u1E66\u1E62\u1E68\u0218\u015E\u2C7E\uA7A8\uA784' },
  { base: 'T', letters: '\u0054\u24C9\uFF34\u1E6A\u0164\u1E6C\u021A\u0162\u1E70\u1E6E\u0166\u01AC\u01AE\u023E\uA786' },
  { base: 'TZ', letters: '\uA728' },
  { base: 'U', letters: '\u0055\u24CA\uFF35\u00D9\u00DA\u00DB\u0168\u1E78\u016A\u1E7A\u016C\u00DC\u01DB\u01D7\u01D5\u01D9\u1EE6\u016E\u0170\u01D3\u0214\u0216\u01AF\u1EEA\u1EE8\u1EEE\u1EEC\u1EF0\u1EE4\u1E72\u0172\u1E76\u1E74\u0244' },
  { base: 'V', letters: '\u0056\u24CB\uFF36\u1E7C\u1E7E\u01B2\uA75E\u0245' },
  { base: 'VY', letters: '\uA760' },
  { base: 'W', letters: '\u0057\u24CC\uFF37\u1E80\u1E82\u0174\u1E86\u1E84\u1E88\u2C72' },
  { base: 'X', letters: '\u0058\u24CD\uFF38\u1E8A\u1E8C' },
  { base: 'Y', letters: '\u0059\u24CE\uFF39\u1EF2\u00DD\u0176\u1EF8\u0232\u1E8E\u0178\u1EF6\u1EF4\u01B3\u024E\u1EFE' },
  { base: 'Z', letters: '\u005A\u24CF\uFF3A\u0179\u1E90\u017B\u017D\u1E92\u1E94\u01B5\u0224\u2C7F\u2C6B\uA762' },
  { base: 'a', letters: '\u0061\u24D0\uFF41\u1E9A\u00E0\u00E1\u00E2\u1EA7\u1EA5\u1EAB\u1EA9\u00E3\u0101\u0103\u1EB1\u1EAF\u1EB5\u1EB3\u0227\u01E1\u00E4\u01DF\u1EA3\u00E5\u01FB\u01CE\u0201\u0203\u1EA1\u1EAD\u1EB7\u1E01\u0105\u2C65\u0250' },
  { base: 'aa', letters: '\uA733' },
  { base: 'ae', letters: '\u00E6\u01FD\u01E3' },
  { base: 'ao', letters: '\uA735' },
  { base: 'au', letters: '\uA737' },
  { base: 'av', letters: '\uA739\uA73B' },
  { base: 'ay', letters: '\uA73D' },
  { base: 'b', letters: '\u0062\u24D1\uFF42\u1E03\u1E05\u1E07\u0180\u0183\u0253' },
  { base: 'c', letters: '\u0063\u24D2\uFF43\u0107\u0109\u010B\u010D\u00E7\u1E09\u0188\u023C\uA73F\u2184' },
  { base: 'd', letters: '\u0064\u24D3\uFF44\u1E0B\u010F\u1E0D\u1E11\u1E13\u1E0F\u0111\u018C\u0256\u0257\uA77A' },
  { base: 'dz', letters: '\u01F3\u01C6' },
  { base: 'e', letters: '\u0065\u24D4\uFF45\u00E8\u00E9\u00EA\u1EC1\u1EBF\u1EC5\u1EC3\u1EBD\u0113\u1E15\u1E17\u0115\u0117\u00EB\u1EBB\u011B\u0205\u0207\u1EB9\u1EC7\u0229\u1E1D\u0119\u1E19\u1E1B\u0247\u025B\u01DD' },
  { base: 'f', letters: '\u0066\u24D5\uFF46\u1E1F\u0192\uA77C' },
  { base: 'g', letters: '\u0067\u24D6\uFF47\u01F5\u011D\u1E21\u011F\u0121\u01E7\u0123\u01E5\u0260\uA7A1\u1D79\uA77F' },
  { base: 'h', letters: '\u0068\u24D7\uFF48\u0125\u1E23\u1E27\u021F\u1E25\u1E29\u1E2B\u1E96\u0127\u2C68\u2C76\u0265' },
  { base: 'hv', letters: '\u0195' },
  { base: 'i', letters: '\u0069\u24D8\uFF49\u00EC\u00ED\u00EE\u0129\u012B\u012D\u00EF\u1E2F\u1EC9\u01D0\u0209\u020B\u1ECB\u012F\u1E2D\u0268\u0131' },
  { base: 'j', letters: '\u006A\u24D9\uFF4A\u0135\u01F0\u0249' },
  { base: 'k', letters: '\u006B\u24DA\uFF4B\u1E31\u01E9\u1E33\u0137\u1E35\u0199\u2C6A\uA741\uA743\uA745\uA7A3' },
  { base: 'l', letters: '\u006C\u24DB\uFF4C\u0140\u013A\u013E\u1E37\u1E39\u013C\u1E3D\u1E3B\u017F\u0142\u019A\u026B\u2C61\uA749\uA781\uA747' },
  { base: 'lj', letters: '\u01C9' },
  { base: 'm', letters: '\u006D\u24DC\uFF4D\u1E3F\u1E41\u1E43\u0271\u026F' },
  { base: 'n', letters: '\u006E\u24DD\uFF4E\u01F9\u0144\u00F1\u1E45\u0148\u1E47\u0146\u1E4B\u1E49\u019E\u0272\u0149\uA791\uA7A5' },
  { base: 'nj', letters: '\u01CC' },
  { base: 'o', letters: '\u006F\u24DE\uFF4F\u00F2\u00F3\u00F4\u1ED3\u1ED1\u1ED7\u1ED5\u00F5\u1E4D\u022D\u1E4F\u014D\u1E51\u1E53\u014F\u022F\u0231\u00F6\u022B\u1ECF\u0151\u01D2\u020D\u020F\u01A1\u1EDD\u1EDB\u1EE1\u1EDF\u1EE3\u1ECD\u1ED9\u01EB\u01ED\u00F8\u01FF\u0254\uA74B\uA74D\u0275' },
  { base: 'oi', letters: '\u01A3' },
  { base: 'ou', letters: '\u0223' },
  { base: 'oo', letters: '\uA74F' },
  { base: 'p', letters: '\u0070\u24DF\uFF50\u1E55\u1E57\u01A5\u1D7D\uA751\uA753\uA755' },
  { base: 'q', letters: '\u0071\u24E0\uFF51\u024B\uA757\uA759' },
  { base: 'r', letters: '\u0072\u24E1\uFF52\u0155\u1E59\u0159\u0211\u0213\u1E5B\u1E5D\u0157\u1E5F\u024D\u027D\uA75B\uA7A7\uA783' },
  { base: 's', letters: '\u0073\u24E2\uFF53\u00DF\u015B\u1E65\u015D\u1E61\u0161\u1E67\u1E63\u1E69\u0219\u015F\u023F\uA7A9\uA785\u1E9B' },
  { base: 't', letters: '\u0074\u24E3\uFF54\u1E6B\u1E97\u0165\u1E6D\u021B\u0163\u1E71\u1E6F\u0167\u01AD\u0288\u2C66\uA787' },
  { base: 'tz', letters: '\uA729' },
  { base: 'u', letters: '\u0075\u24E4\uFF55\u00F9\u00FA\u00FB\u0169\u1E79\u016B\u1E7B\u016D\u00FC\u01DC\u01D8\u01D6\u01DA\u1EE7\u016F\u0171\u01D4\u0215\u0217\u01B0\u1EEB\u1EE9\u1EEF\u1EED\u1EF1\u1EE5\u1E73\u0173\u1E77\u1E75\u0289' },
  { base: 'v', letters: '\u0076\u24E5\uFF56\u1E7D\u1E7F\u028B\uA75F\u028C' },
  { base: 'vy', letters: '\uA761' },
  { base: 'w', letters: '\u0077\u24E6\uFF57\u1E81\u1E83\u0175\u1E87\u1E85\u1E98\u1E89\u2C73' },
  { base: 'x', letters: '\u0078\u24E7\uFF58\u1E8B\u1E8D' },
  { base: 'y', letters: '\u0079\u24E8\uFF59\u1EF3\u00FD\u0177\u1EF9\u0233\u1E8F\u00FF\u1EF7\u1E99\u1EF5\u01B4\u024F\u1EFF' },
  { base: 'z', letters: '\u007A\u24E9\uFF5A\u017A\u1E91\u017C\u017E\u1E93\u1E95\u01B6\u0225\u0240\u2C6C\uA763' },
];

const diacriticsMap = {};
for (let i = 0; i < defaultDiacriticsRemovalap.length; i += 1) {
  const letters = defaultDiacriticsRemovalap[i].letters;
  for (let j = 0; j < letters.length; j += 1) {
    diacriticsMap[letters[j]] = defaultDiacriticsRemovalap[i].base;
  }
}

const createPromise = function createPromise(handler) {
  let resolved = false;
  let rejected = false;
  let resolveArgs;
  let rejectArgs;
  const promiseHandlers = {
    then: undefined,
    catch: undefined,
  };
  const promise = {
    then(thenHandler) {
      if (resolved) {
        thenHandler(...resolveArgs);
      } else {
        promiseHandlers.then = thenHandler;
      }
      return promise;
    },
    catch(catchHandler) {
      if (rejected) {
        catchHandler(...rejectArgs);
      } else {
        promiseHandlers.catch = catchHandler;
      }
      return promise;
    },
  };

  function resolve(...args) {
    resolved = true;
    if (promiseHandlers.then) promiseHandlers.then(...args);
    else resolveArgs = args;
  }
  function reject(...args) {
    rejected = true;
    if (promiseHandlers.catch) promiseHandlers.catch(...args);
    else rejectArgs = args;
  }
  handler(resolve, reject);

  return promise;
};

const Utils = {
  mdPreloaderContent: `
    <span class="preloader-inner">
      <span class="preloader-inner-gap"></span>
      <span class="preloader-inner-left">
          <span class="preloader-inner-half-circle"></span>
      </span>
      <span class="preloader-inner-right">
          <span class="preloader-inner-half-circle"></span>
      </span>
    </span>
  `.trim(),
  eventNameToColonCase(eventName) {
    let hasColon;
    return eventName.split('').map((char, index) => {
      if (char.match(/[A-Z]/) && index !== 0 && !hasColon) {
        hasColon = true;
        return `:${char.toLowerCase()}`;
      }
      return char.toLowerCase();
    }).join('');
  },
  deleteProps(obj) {
    const object = obj;
    Object.keys(object).forEach((key) => {
      try {
        object[key] = null;
      } catch (e) {
        // no getter for object
      }
      try {
        delete object[key];
      } catch (e) {
        // something got wrong
      }
    });
  },
  bezier(...args) {
    return bezier(...args);
  },
  nextTick(callback, delay = 0) {
    return setTimeout(callback, delay);
  },
  nextFrame(callback) {
    return Utils.requestAnimationFrame(callback);
  },
  now() {
    return Date.now();
  },
  promise(handler) {
    return __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].Promise ? new Promise(handler) : createPromise(handler);
  },
  requestAnimationFrame(callback) {
    if (__WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].requestAnimationFrame) return __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].requestAnimationFrame(callback);
    else if (__WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].webkitRequestAnimationFrame) return __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].webkitRequestAnimationFrame(callback);
    return __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].setTimeout(callback, 1000 / 60);
  },
  cancelAnimationFrame(id) {
    if (__WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].cancelAnimationFrame) return __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].cancelAnimationFrame(id);
    else if (__WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].webkitCancelAnimationFrame) return __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].webkitCancelAnimationFrame(id);
    return __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].clearTimeout(id);
  },
  removeDiacritics(str) {
    return str.replace(/[^\u0000-\u007E]/g, a => diacriticsMap[a] || a);
  },
  parseUrlQuery(url) {
    const query = {};
    let urlToParse = url || __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].location.href;
    let i;
    let params;
    let param;
    let length;
    if (typeof urlToParse === 'string' && urlToParse.length) {
      urlToParse = urlToParse.indexOf('?') > -1 ? urlToParse.replace(/\S*\?/, '') : '';
      params = urlToParse.split('&').filter(paramsPart => paramsPart !== '');
      length = params.length;

      for (i = 0; i < length; i += 1) {
        param = params[i].replace(/#\S+/g, '').split('=');
        query[decodeURIComponent(param[0])] = typeof param[1] === 'undefined' ? undefined : decodeURIComponent(param[1]) || '';
      }
    }
    return query;
  },
  getTranslate(el, axis = 'x') {
    let matrix;
    let curTransform;
    let transformMatrix;

    const curStyle = __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].getComputedStyle(el, null);

    if (__WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].WebKitCSSMatrix) {
      curTransform = curStyle.transform || curStyle.webkitTransform;
      if (curTransform.split(',').length > 6) {
        curTransform = curTransform.split(', ').map(a => a.replace(',', '.')).join(', ');
      }
      // Some old versions of Webkit choke when 'none' is passed; pass
      // empty string instead in this case
      transformMatrix = new __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].WebKitCSSMatrix(curTransform === 'none' ? '' : curTransform);
    } else {
      transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue('transform').replace('translate(', 'matrix(1, 0, 0, 1,');
      matrix = transformMatrix.toString().split(',');
    }

    if (axis === 'x') {
      // Latest Chrome and webkits Fix
      if (__WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].WebKitCSSMatrix) curTransform = transformMatrix.m41;
      // Crazy IE10 Matrix
      else if (matrix.length === 16) curTransform = parseFloat(matrix[12]);
      // Normal Browsers
      else curTransform = parseFloat(matrix[4]);
    }
    if (axis === 'y') {
      // Latest Chrome and webkits Fix
      if (__WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].WebKitCSSMatrix) curTransform = transformMatrix.m42;
      // Crazy IE10 Matrix
      else if (matrix.length === 16) curTransform = parseFloat(matrix[13]);
      // Normal Browsers
      else curTransform = parseFloat(matrix[5]);
    }
    return curTransform || 0;
  },
  serializeObject(obj, parents = []) {
    if (typeof obj === 'string') return obj;
    const resultArray = [];
    const separator = '&';
    let newParents;
    function varName(name) {
      if (parents.length > 0) {
        let parentParts = '';
        for (let j = 0; j < parents.length; j += 1) {
          if (j === 0) parentParts += parents[j];
          else parentParts += `[${encodeURIComponent(parents[j])}]`;
        }
        return `${parentParts}[${encodeURIComponent(name)}]`;
      }
      return encodeURIComponent(name);
    }
    function varValue(value) {
      return encodeURIComponent(value);
    }
    Object.keys(obj).forEach((prop) => {
      let toPush;
      if (Array.isArray(obj[prop])) {
        toPush = [];
        for (let i = 0; i < obj[prop].length; i += 1) {
          if (!Array.isArray(obj[prop][i]) && typeof obj[prop][i] === 'object') {
            newParents = parents.slice();
            newParents.push(prop);
            newParents.push(String(i));
            toPush.push(Utils.serializeObject(obj[prop][i], newParents));
          } else {
            toPush.push(`${varName(prop)}[]=${varValue(obj[prop][i])}`);
          }
        }
        if (toPush.length > 0) resultArray.push(toPush.join(separator));
      } else if (obj[prop] === null || obj[prop] === '') {
        resultArray.push(`${varName(prop)}=`);
      } else if (typeof obj[prop] === 'object') {
        // Object, convert to named array
        newParents = parents.slice();
        newParents.push(prop);
        toPush = Utils.serializeObject(obj[prop], newParents);
        if (toPush !== '') resultArray.push(toPush);
      } else if (typeof obj[prop] !== 'undefined' && obj[prop] !== '') {
        // Should be string or plain value
        resultArray.push(`${varName(prop)}=${varValue(obj[prop])}`);
      } else if (obj[prop] === '') resultArray.push(varName(prop));
    });
    return resultArray.join(separator);
  },
  isObject(o) {
    return typeof o === 'object' && o !== null && o.constructor && o.constructor === Object;
  },
  merge(...args) {
    const to = args[0];
    args.splice(0, 1);
    const from = args;

    for (let i = 0; i < from.length; i += 1) {
      const nextSource = args[i];
      if (nextSource !== undefined && nextSource !== null) {
        const keysArray = Object.keys(Object(nextSource));
        for (let nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {
          const nextKey = keysArray[nextIndex];
          const desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
          if (desc !== undefined && desc.enumerable) {
            to[nextKey] = nextSource[nextKey];
          }
        }
      }
    }
    return to;
  },
  extend(...args) {
    let deep = true;
    let to;
    let from;
    if (typeof args[0] === 'boolean') {
      deep = args[0];
      to = args[1];
      args.splice(0, 2);
      from = args;
    } else {
      to = args[0];
      args.splice(0, 1);
      from = args;
    }
    for (let i = 0; i < from.length; i += 1) {
      const nextSource = args[i];
      if (nextSource !== undefined && nextSource !== null) {
        const keysArray = Object.keys(Object(nextSource));
        for (let nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {
          const nextKey = keysArray[nextIndex];
          const desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
          if (desc !== undefined && desc.enumerable) {
            if (!deep) {
              to[nextKey] = nextSource[nextKey];
            } else if (Utils.isObject(to[nextKey]) && Utils.isObject(nextSource[nextKey])) {
              Utils.extend(to[nextKey], nextSource[nextKey]);
            } else if (!Utils.isObject(to[nextKey]) && Utils.isObject(nextSource[nextKey])) {
              to[nextKey] = {};
              Utils.extend(to[nextKey], nextSource[nextKey]);
            } else {
              to[nextKey] = nextSource[nextKey];
            }
          }
        }
      }
    }
    return to;
  },
};

const Device = (function Device() {
  const ua = __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].navigator.userAgent;

  const device = {
    ios: false,
    android: false,
    androidChrome: false,
    desktop: false,
    windows: false,
    iphone: false,
    iphoneX: false,
    ipod: false,
    ipad: false,
    cordova: __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].cordova || __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].phonegap,
    phonegap: __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].cordova || __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].phonegap,
  };

  const windows = ua.match(/(Windows Phone);?[\s\/]+([\d.]+)?/); // eslint-disable-line
  const android = ua.match(/(Android);?[\s\/]+([\d.]+)?/); // eslint-disable-line
  const ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
  const ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
  const iphone = !ipad && ua.match(/(iPhone\sOS|iOS)\s([\d_]+)/);
  const iphoneX = iphone && __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].screen.width === 375 && __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].screen.height === 812;


  // Windows
  if (windows) {
    device.os = 'windows';
    device.osVersion = windows[2];
    device.windows = true;
  }
  // Android
  if (android && !windows) {
    device.os = 'android';
    device.osVersion = android[2];
    device.android = true;
    device.androidChrome = ua.toLowerCase().indexOf('chrome') >= 0;
  }
  if (ipad || iphone || ipod) {
    device.os = 'ios';
    device.ios = true;
  }
  // iOS
  if (iphone && !ipod) {
    device.osVersion = iphone[2].replace(/_/g, '.');
    device.iphone = true;
    device.iphoneX = iphoneX;
  }
  if (ipad) {
    device.osVersion = ipad[2].replace(/_/g, '.');
    device.ipad = true;
  }
  if (ipod) {
    device.osVersion = ipod[3] ? ipod[3].replace(/_/g, '.') : null;
    device.iphone = true;
  }
  // iOS 8+ changed UA
  if (device.ios && device.osVersion && ua.indexOf('Version/') >= 0) {
    if (device.osVersion.split('.')[0] === '10') {
      device.osVersion = ua.toLowerCase().split('version/')[1].split(' ')[0];
    }
  }

  // Webview
  device.webView = (iphone || ipad || ipod) && (ua.match(/.*AppleWebKit(?!.*Safari)/i) || __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].navigator.standalone);
  device.webview = device.webView;


  // Desktop
  device.desktop = !(device.os || device.android || device.webView);

  // Minimal UI
  if (device.os && device.os === 'ios') {
    const osVersionArr = device.osVersion.split('.');
    const metaViewport = __WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */].querySelector('meta[name="viewport"]');
    device.minimalUi =
      !device.webView &&
      (ipod || iphone) &&
      (osVersionArr[0] * 1 === 7 ? osVersionArr[1] * 1 >= 1 : osVersionArr[0] * 1 > 7) &&
      metaViewport && metaViewport.getAttribute('content').indexOf('minimal-ui') >= 0;
  }

  // Check for status bar and fullscreen app mode
  device.needsStatusbarOverlay = function needsStatusbarOverlay() {
    if (device.webView && (__WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].innerWidth * __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].innerHeight === __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].screen.width * __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].screen.height)) {
      if (device.iphoneX && (__WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].orientation === 90 || __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].orientation === -90)) {
        return false;
      }
      return true;
    }
    return false;
  };
  device.statusbar = device.needsStatusbarOverlay();

  // Pixel Ratio
  device.pixelRatio = __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].devicePixelRatio || 1;

  // Export object
  return device;
}());

class Framework7Class {
  constructor(params = {}, parents = []) {
    const self = this;
    self.params = params;

    // Events
    self.eventsParents = parents;
    self.eventsListeners = {};

    if (self.params && self.params.on) {
      Object.keys(self.params.on).forEach((eventName) => {
        self.on(eventName, self.params.on[eventName]);
      });
    }
  }
  on(events, handler, priority) {
    const self = this;
    if (typeof handler !== 'function') return self;
    const method = priority ? 'unshift' : 'push';
    events.split(' ').forEach((event) => {
      if (!self.eventsListeners[event]) self.eventsListeners[event] = [];
      self.eventsListeners[event][method](handler);
    });
    return self;
  }
  once(events, handler, priority) {
    const self = this;
    if (typeof handler !== 'function') return self;
    function onceHandler(...args) {
      handler.apply(self, args);
      self.off(events, onceHandler);
    }
    return self.on(events, onceHandler, priority);
  }
  off(events, handler) {
    const self = this;
    if (!self.eventsListeners) return self;
    events.split(' ').forEach((event) => {
      if (typeof handler === 'undefined') {
        self.eventsListeners[event] = [];
      } else {
        self.eventsListeners[event].forEach((eventHandler, index) => {
          if (eventHandler === handler) {
            self.eventsListeners[event].splice(index, 1);
          }
        });
      }
    });
    return self;
  }
  emit(...args) {
    const self = this;
    if (!self.eventsListeners) return self;
    let events;
    let data;
    let context;
    let eventsParents;
    if (typeof args[0] === 'string' || Array.isArray(args[0])) {
      events = args[0];
      data = args.slice(1, args.length);
      context = self;
      eventsParents = self.eventsParents;
    } else {
      events = args[0].events;
      data = args[0].data;
      context = args[0].context || self;
      eventsParents = args[0].local ? [] : args[0].parents || self.eventsParents;
    }
    const eventsArray = Array.isArray(events) ? events : events.split(' ');
    const localEvents = eventsArray.map(eventName => eventName.replace('local::', ''));
    const parentEvents = eventsArray.filter(eventName => eventName.indexOf('local::') < 0);

    localEvents.forEach((event) => {
      if (self.eventsListeners && self.eventsListeners[event]) {
        const handlers = [];
        self.eventsListeners[event].forEach((eventHandler) => {
          handlers.push(eventHandler);
        });
        handlers.forEach((eventHandler) => {
          eventHandler.apply(context, data);
        });
      }
    });
    if (eventsParents && eventsParents.length > 0) {
      eventsParents.forEach((eventsParent) => {
        eventsParent.emit(parentEvents, ...data);
      });
    }
    return self;
  }
  useModulesParams(instanceParams) {
    const instance = this;
    if (!instance.modules) return;
    Object.keys(instance.modules).forEach((moduleName) => {
      const module = instance.modules[moduleName];
      // Extend params
      if (module.params) {
        Utils.extend(instanceParams, module.params);
      }
    });
  }
  useModules(modulesParams = {}) {
    const instance = this;
    if (!instance.modules) return;
    Object.keys(instance.modules).forEach((moduleName) => {
      const module = instance.modules[moduleName];
      const moduleParams = modulesParams[moduleName] || {};
      // Extend instance methods and props
      if (module.instance) {
        Object.keys(module.instance).forEach((modulePropName) => {
          const moduleProp = module.instance[modulePropName];
          if (typeof moduleProp === 'function') {
            instance[modulePropName] = moduleProp.bind(instance);
          } else {
            instance[modulePropName] = moduleProp;
          }
        });
      }
      // Add event listeners
      if (module.on && instance.on) {
        Object.keys(module.on).forEach((moduleEventName) => {
          instance.on(moduleEventName, module.on[moduleEventName]);
        });
      }

      // Module create callback
      if (module.create) {
        module.create.bind(instance)(moduleParams);
      }
    });
  }
  static set components(components) {
    const Class = this;
    if (!Class.use) return;
    Class.use(components);
  }
  static installModule(module, ...params) {
    const Class = this;
    if (!Class.prototype.modules) Class.prototype.modules = {};
    const name = module.name || (`${Object.keys(Class.prototype.modules).length}_${Utils.now()}`);
    Class.prototype.modules[name] = module;
    // Prototype
    if (module.proto) {
      Object.keys(module.proto).forEach((key) => {
        Class.prototype[key] = module.proto[key];
      });
    }
    // Class
    if (module.static) {
      Object.keys(module.static).forEach((key) => {
        Class[key] = module.static[key];
      });
    }
    // Callback
    if (module.install) {
      module.install.apply(Class, params);
    }
    return Class;
  }
  static use(module, ...params) {
    const Class = this;
    if (Array.isArray(module)) {
      module.forEach(m => Class.installModule(m));
      return Class;
    }
    return Class.installModule(module, ...params);
  }
}

class Framework7 extends Framework7Class {
  constructor(params) {
    super(params);

    const passedParams = Utils.extend({}, params);

    // App Instance
    const app = this;

    // Default
    const defaults = {
      version: '1.0.0',
      id: 'io.framework7.testapp',
      root: 'body',
      theme: 'auto',
      language: __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].navigator.language,
      routes: [],
      name: 'Framework7',
      initOnDeviceReady: true,
      init: true,
    };

    // Extend defaults with modules params
    app.useModulesParams(defaults);


    // Extend defaults with passed params
    app.params = Utils.extend(defaults, params);

    const $rootEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(app.params.root);

    Utils.extend(app, {
      // App Id
      id: app.params.id,
      // App Name
      name: app.params.name,
      // App version
      version: app.params.version,
      // Routes
      routes: app.params.routes,
      // Lang
      language: app.params.language,
      // Root
      root: $rootEl,
      // RTL
      rtl: $rootEl.css('direction') === 'rtl',
      // Theme
      theme: (function getTheme() {
        if (app.params.theme === 'auto') {
          return Device.ios ? 'ios' : 'md';
        }
        return app.params.theme;
      }()),
      // Initially passed parameters
      passedParams,
    });

    // Save Root
    if (app.root && app.root[0]) {
      app.root[0].f7 = app;
    }

    // Install Modules
    app.useModules();

    // Init
    if (app.params.init) {
      if (Device.cordova && app.params.initOnDeviceReady) {
        Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(__WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */]).on('deviceready', () => {
          app.init();
        });
      } else {
        app.init();
      }
    }

    // Return app instance
    return app;
  }
  init() {
    const app = this;
    if (app.initialized) return;

    app.root.addClass('framework7-initializing');

    // RTL attr
    if (app.rtl) {
      Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])('html').attr('dir', 'rtl');
    }

    // Root class
    app.root.addClass('framework7-root');

    // Theme class
    Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])('html').removeClass('ios md').addClass(app.theme);

    // Data
    app.data = {};
    if (app.params.data && typeof app.params.data === 'function') {
      Utils.extend(app.data, app.params.data.bind(app)());
    } else if (app.params.data) {
      Utils.extend(app.data, app.params.data);
    }
    // Methods
    app.methods = {};
    if (app.params.methods) {
      Utils.extend(app.methods, app.params.methods);
    }
    // Init class
    Utils.nextFrame(() => {
      app.root.removeClass('framework7-initializing');
    });
    // Emit, init other modules
    app.initialized = true;
    app.emit('init');
  }
  // eslint-disable-next-line
  get $() {
    return __WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */];
  }
  // eslint-disable-next-line
  get t7() {
    return __WEBPACK_IMPORTED_MODULE_2_template7__["a" /* default */];
  }
  static get Dom7() {
    return __WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */];
  }
  static get $() {
    return __WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */];
  }
  static get Template7() {
    return __WEBPACK_IMPORTED_MODULE_2_template7__["a" /* default */];
  }
  static get Class() {
    return Framework7Class;
  }
}

const globals = {};
let jsonpRequests = 0;

function Request(requestOptions) {
  const globalsNoCallbacks = Utils.extend({}, globals);
  ('beforeCreate beforeOpen beforeSend error complete success statusCode').split(' ').forEach((callbackName) => {
    delete globalsNoCallbacks[callbackName];
  });
  const defaults = Utils.extend({
    url: __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].location.toString(),
    method: 'GET',
    data: false,
    async: true,
    cache: true,
    user: '',
    password: '',
    headers: {},
    xhrFields: {},
    statusCode: {},
    processData: true,
    dataType: 'text',
    contentType: 'application/x-www-form-urlencoded',
    timeout: 0,
  }, globalsNoCallbacks);

  const options = Utils.extend({}, defaults, requestOptions);
  let proceedRequest;

  // Function to run XHR callbacks and events
  function fireCallback(callbackName, ...data) {
    /*
      Callbacks:
      beforeCreate (options),
      beforeOpen (xhr, options),
      beforeSend (xhr, options),
      error (xhr, status),
      complete (xhr, stautus),
      success (response, status, xhr),
      statusCode ()
    */
    let globalCallbackValue;
    let optionCallbackValue;
    if (globals[callbackName]) {
      globalCallbackValue = globals[callbackName](...data);
    }
    if (options[callbackName]) {
      optionCallbackValue = options[callbackName](...data);
    }
    if (typeof globalCallbackValue !== 'boolean') globalCallbackValue = true;
    if (typeof optionCallbackValue !== 'boolean') optionCallbackValue = true;
    return (globalCallbackValue && optionCallbackValue);
  }

  // Before create callback
  proceedRequest = fireCallback('beforeCreate', options);
  if (proceedRequest === false) return undefined;

  // For jQuery guys
  if (options.type) options.method = options.type;

  // Parameters Prefix
  let paramsPrefix = options.url.indexOf('?') >= 0 ? '&' : '?';

  // UC method
  const method = options.method.toUpperCase();

  // Data to modify GET URL
  if ((method === 'GET' || method === 'HEAD' || method === 'OPTIONS' || method === 'DELETE') && options.data) {
    let stringData;
    if (typeof options.data === 'string') {
      // Should be key=value string
      if (options.data.indexOf('?') >= 0) stringData = options.data.split('?')[1];
      else stringData = options.data;
    } else {
      // Should be key=value object
      stringData = Utils.serializeObject(options.data);
    }
    if (stringData.length) {
      options.url += paramsPrefix + stringData;
      if (paramsPrefix === '?') paramsPrefix = '&';
    }
  }

  // JSONP
  if (options.dataType === 'json' && options.url.indexOf('callback=') >= 0) {
    const callbackName = `f7jsonp_${Date.now() + ((jsonpRequests += 1))}`;
    let abortTimeout;
    const callbackSplit = options.url.split('callback=');
    let requestUrl = `${callbackSplit[0]}callback=${callbackName}`;
    if (callbackSplit[1].indexOf('&') >= 0) {
      const addVars = callbackSplit[1].split('&').filter(el => el.indexOf('=') > 0).join('&');
      if (addVars.length > 0) requestUrl += `&${addVars}`;
    }

    // Create script
    let script = __WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */].createElement('script');
    script.type = 'text/javascript';
    script.onerror = function onerror() {
      clearTimeout(abortTimeout);
      fireCallback('error', null, 'scripterror');
      fireCallback('complete', null, 'scripterror');
    };
    script.src = requestUrl;

    // Handler
    __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */][callbackName] = function jsonpCallback(data) {
      clearTimeout(abortTimeout);
      fireCallback('success', data);
      script.parentNode.removeChild(script);
      script = null;
      delete __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */][callbackName];
    };
    __WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */].querySelector('head').appendChild(script);

    if (options.timeout > 0) {
      abortTimeout = setTimeout(() => {
        script.parentNode.removeChild(script);
        script = null;
        fireCallback('error', null, 'timeout');
      }, options.timeout);
    }

    return undefined;
  }

  // Cache for GET/HEAD requests
  if (method === 'GET' || method === 'HEAD' || method === 'OPTIONS' || method === 'DELETE') {
    if (options.cache === false) {
      options.url += `${paramsPrefix}_nocache${Date.now()}`;
    }
  }

  // Create XHR
  const xhr = new XMLHttpRequest();

  // Save Request URL
  xhr.requestUrl = options.url;
  xhr.requestParameters = options;

  // Before open callback
  proceedRequest = fireCallback('beforeOpen', xhr, options);
  if (proceedRequest === false) return xhr;

  // Open XHR
  xhr.open(method, options.url, options.async, options.user, options.password);

  // Create POST Data
  let postData = null;

  if ((method === 'POST' || method === 'PUT' || method === 'PATCH') && options.data) {
    if (options.processData) {
      const postDataInstances = [ArrayBuffer, Blob, Document, FormData];
      // Post Data
      if (postDataInstances.indexOf(options.data.constructor) >= 0) {
        postData = options.data;
      } else {
        // POST Headers
        const boundary = `---------------------------${Date.now().toString(16)}`;

        if (options.contentType === 'multipart/form-data') {
          xhr.setRequestHeader('Content-Type', `multipart/form-data; boundary=${boundary}`);
        } else {
          xhr.setRequestHeader('Content-Type', options.contentType);
        }
        postData = '';
        let data = Utils.serializeObject(options.data);
        if (options.contentType === 'multipart/form-data') {
          data = data.split('&');
          const newData = [];
          for (let i = 0; i < data.length; i += 1) {
            newData.push(`Content-Disposition: form-data; name="${data[i].split('=')[0]}"\r\n\r\n${data[i].split('=')[1]}\r\n`);
          }
          postData = `--${boundary}\r\n${newData.join(`--${boundary}\r\n`)}--${boundary}--\r\n`;
        } else {
          postData = data;
        }
      }
    } else {
      postData = options.data;
      xhr.setRequestHeader('Content-Type', options.contentType);
    }
  }

  // Additional headers
  if (options.headers) {
    Object.keys(options.headers).forEach((headerName) => {
      xhr.setRequestHeader(headerName, options.headers[headerName]);
    });
  }

  // Check for crossDomain
  if (typeof options.crossDomain === 'undefined') {
    // eslint-disable-next-line
    options.crossDomain = /^([\w-]+:)?\/\/([^\/]+)/.test(options.url) && RegExp.$2 !== __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].location.host;
  }

  if (!options.crossDomain) {
    xhr.setRequestHeader('X-Requested-With', 'XMLHttpRequest');
  }

  if (options.xhrFields) {
    Utils.extend(xhr, options.xhrFields);
  }

  let xhrTimeout;

  // Handle XHR
  xhr.onload = function onload() {
    if (xhrTimeout) clearTimeout(xhrTimeout);
    if ((xhr.status >= 200 && xhr.status < 300) || xhr.status === 0) {
      let responseData;
      if (options.dataType === 'json') {
        let parseError;
        try {
          responseData = JSON.parse(xhr.responseText);
        } catch (err) {
          parseError = true;
        }
        if (!parseError) {
          fireCallback('success', responseData, xhr.status, xhr);
        } else {
          fireCallback('error', xhr, 'parseerror');
        }
      } else {
        responseData = xhr.responseType === 'text' || xhr.responseType === '' ? xhr.responseText : xhr.response;
        fireCallback('success', responseData, xhr.status, xhr);
      }
    } else {
      fireCallback('error', xhr, xhr.status);
    }
    if (options.statusCode) {
      if (globals.statusCode && globals.statusCode[xhr.status]) globals.statusCode[xhr.status](xhr);
      if (options.statusCode[xhr.status]) options.statusCode[xhr.status](xhr);
    }
    fireCallback('complete', xhr, xhr.status);
  };

  xhr.onerror = function onerror() {
    if (xhrTimeout) clearTimeout(xhrTimeout);
    fireCallback('error', xhr, xhr.status);
    fireCallback('complete', xhr, 'error');
  };

  // Timeout
  if (options.timeout > 0) {
    xhr.onabort = function onabort() {
      if (xhrTimeout) clearTimeout(xhrTimeout);
    };
    xhrTimeout = setTimeout(() => {
      xhr.abort();
      fireCallback('error', xhr, 'timeout');
      fireCallback('complete', xhr, 'timeout');
    }, options.timeout);
  }

  // Ajax start callback
  proceedRequest = fireCallback('beforeSend', xhr, options);
  if (proceedRequest === false) return xhr;

  // Send XHR
  xhr.send(postData);

  // Return XHR object
  return xhr;
}
function RequestShortcut(method, ...args) {
  let [url, data, success, error, dataType] = [];
  if (typeof args[1] === 'function') {
    [url, success, error, dataType] = args;
  } else {
    [url, data, success, error, dataType] = args;
  }
  [success, error].forEach((callback) => {
    if (typeof callback === 'string') {
      dataType = callback;
      if (callback === success) success = undefined;
      else error = undefined;
    }
  });
  dataType = dataType || (method === 'json' || method === 'postJSON' ? 'json' : undefined);
  const requestOptions = {
    url,
    method: method === 'post' || method === 'postJSON' ? 'POST' : 'GET',
    data,
    success,
    error,
    dataType,
  };
  if (method === 'postJSON') {
    Utils.extend(requestOptions, {
      contentType: 'application/json',
      processData: false,
      crossDomain: true,
      data: typeof data === 'string' ? data : JSON.stringify(data),
    });
  }
  return Request(requestOptions);
}
Request.get = function get(...args) {
  return RequestShortcut('get', ...args);
};
Request.post = function post(...args) {
  return RequestShortcut('post', ...args);
};
Request.json = function json(...args) {
  return RequestShortcut('json', ...args);
};
Request.getJSON = Request.json;
Request.postJSON = function postJSON(...args) {
  return RequestShortcut('postJSON', ...args);
};
Request.setup = function setup(options) {
  if (options.type && !options.method) {
    Utils.extend(options, { method: options.type });
  }
  Utils.extend(globals, options);
};

const Support = (function Support() {
  const positionSticky = (function supportPositionSticky() {
    let support = false;
    const div = __WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */].createElement('div');
    ('sticky -webkit-sticky -moz-sticky').split(' ').forEach((prop) => {
      if (support) return;
      div.style.position = prop;
      if (div.style.position === prop) {
        support = true;
      }
    });
    return support;
  }());

  const testDiv = __WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */].createElement('div');

  return {
    positionSticky,
    touch: (function checkTouch() {
      return !!(('ontouchstart' in __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */]) || (__WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].DocumentTouch && __WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */] instanceof __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].DocumentTouch));
    }()),

    pointerEvents: !!(__WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].navigator.pointerEnabled || __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].PointerEvent),
    prefixedPointerEvents: !!__WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].navigator.msPointerEnabled,

    transition: (function checkTransition() {
      const style = testDiv.style;
      return ('transition' in style || 'webkitTransition' in style || 'MozTransition' in style);
    }()),
    transforms3d: (__WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].Modernizr && __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].Modernizr.csstransforms3d === true) || (function checkTransforms3d() {
      const style = testDiv.style;
      return ('webkitPerspective' in style || 'MozPerspective' in style || 'OPerspective' in style || 'MsPerspective' in style || 'perspective' in style);
    }()),

    flexbox: (function checkFlexbox() {
      const div = __WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */].createElement('div').style;
      const styles = ('alignItems webkitAlignItems webkitBoxAlign msFlexAlign mozBoxAlign webkitFlexDirection msFlexDirection mozBoxDirection mozBoxOrient webkitBoxDirection webkitBoxOrient').split(' ');
      for (let i = 0; i < styles.length; i += 1) {
        if (styles[i] in div) return true;
      }
      return false;
    }()),

    observer: (function checkObserver() {
      return ('MutationObserver' in __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */] || 'WebkitMutationObserver' in __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */]);
    }()),

    passiveListener: (function checkPassiveListener() {
      let supportsPassive = false;
      try {
        const opts = Object.defineProperty({}, 'passive', {
          // eslint-disable-next-line
          get() {
            supportsPassive = true;
          },
        });
        __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].addEventListener('testPassiveListener', null, opts);
      } catch (e) {
        // No support
      }
      return supportsPassive;
    }()),

    gestures: (function checkGestures() {
      return 'ongesturestart' in __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */];
    }()),
  };
}());

var DeviceModule = {
  name: 'device',
  proto: {
    device: Device,
  },
  static: {
    device: Device,
  },
  on: {
    init() {
      const classNames = [];
      const html = __WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */].querySelector('html');
      if (!html) return;
      // Pixel Ratio
      classNames.push(`device-pixel-ratio-${Math.floor(Device.pixelRatio)}`);
      if (Device.pixelRatio >= 2) {
        classNames.push('device-retina');
      }
      // OS classes
      if (Device.os) {
        classNames.push(
          `device-${Device.os}`,
          `device-${Device.os}-${Device.osVersion.split('.')[0]}`,
          `device-${Device.os}-${Device.osVersion.replace(/\./g, '-')}`
        );
        if (Device.os === 'ios') {
          const major = parseInt(Device.osVersion.split('.')[0], 10);
          for (let i = major - 1; i >= 6; i -= 1) {
            classNames.push(`device-ios-gt-${i}`);
          }
          if (Device.iphoneX) {
            classNames.push('device-iphone-x');
          }
        }
      } else if (Device.desktop) {
        classNames.push('device-desktop');
      }
      // Status bar classes
      if (Device.statusbar) {
        classNames.push('with-statusbar');
      } else {
        html.classList.remove('with-statusbar');
      }

      // Add html classes
      classNames.forEach((className) => {
        html.classList.add(className);
      });
    },
  },
};

var SupportModule = {
  name: 'support',
  proto: {
    support: Support,
  },
  static: {
    support: Support,
  },
  on: {
    init() {
      const html = __WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */].querySelector('html');
      if (!html) return;
      const classNames = [];
      if (Support.positionSticky) {
        classNames.push('support-position-sticky');
      }
      // Add html classes
      classNames.forEach((className) => {
        html.classList.add(className);
      });
    },
  },
};

var UtilsModule = {
  name: 'utils',
  proto: {
    utils: Utils,
  },
  static: {
    utils: Utils,
  },
};

var ResizeModule = {
  name: 'resize',
  instance: {
    getSize() {
      const app = this;
      if (!app.root[0]) return { width: 0, height: 0, left: 0, top: 0 };
      const offset = app.root.offset();
      const [width, height, left, top] = [app.root[0].offsetWidth, app.root[0].offsetHeight, offset.left, offset.top];
      app.width = width;
      app.height = height;
      app.left = left;
      app.top = top;
      return { width, height, left, top };
    },
  },
  on: {
    init() {
      const app = this;

      // Get Size
      app.getSize();

      // Emit resize
      __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].addEventListener('resize', () => {
        app.emit('resize');
      }, false);

      // Emit orientationchange
      __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].addEventListener('orientationchange', () => {
        app.emit('orientationchange');
      });
    },
    orientationchange() {
      const app = this;
      if (app.device && app.device.minimalUi) {
        if (__WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].orientation === 90 || __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].orientation === -90) {
          __WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */].body.scrollTop = 0;
        }
      }
      // Fix iPad weird body scroll
      if (app.device.ipad) {
        __WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */].body.scrollLeft = 0;
        setTimeout(() => {
          __WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */].body.scrollLeft = 0;
        }, 0);
      }
    },
    resize() {
      const app = this;
      app.getSize();
    },
  },
};

/* eslint no-param-reassign: "off" */

var RequestModule = {
  name: 'request',
  proto: {
    request: Request,
  },
  static: {
    request: Request,
  },
};

function initTouch() {
  const app = this;
  const params = app.params.touch;
  const useRipple = app.theme === 'md' && params.materialRipple;

  if (Device.ios && Device.webView) {
    // Strange hack required for iOS 8 webview to work on inputs
    __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].addEventListener('touchstart', () => {});
  }

  let touchStartX;
  let touchStartY;
  let touchStartTime;
  let targetElement;
  let trackClick;
  let activeSelection;
  let scrollParent;
  let lastClickTime;
  let isMoved;
  let tapHoldFired;
  let tapHoldTimeout;

  let activableElement;
  let activeTimeout;

  let needsFastClick;
  let needsFastClickTimeOut;

  let rippleWave;
  let rippleTarget;
  let rippleTimeout;

  function findActivableElement(el) {
    const target = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(el);
    const parents = target.parents(params.activeStateElements);
    let activable;
    if (target.is(params.activeStateElements)) {
      activable = target;
    }
    if (parents.length > 0) {
      activable = activable ? activable.add(parents) : parents;
    }
    return activable || target;
  }

  function isInsideScrollableView(el) {
    const pageContent = el.parents('.page-content, .panel');

    if (pageContent.length === 0) {
      return false;
    }

    // This event handler covers the "tap to stop scrolling".
    if (pageContent.prop('scrollHandlerSet') !== 'yes') {
      pageContent.on('scroll', () => {
        clearTimeout(activeTimeout);
        clearTimeout(rippleTimeout);
      });
      pageContent.prop('scrollHandlerSet', 'yes');
    }

    return true;
  }
  function addActive() {
    if (!activableElement) return;
    activableElement.addClass('active-state');
  }
  function removeActive() {
    if (!activableElement) return;
    activableElement.removeClass('active-state');
    activableElement = null;
  }
  function isFormElement(el) {
    const nodes = ('input select textarea label').split(' ');
    if (el.nodeName && nodes.indexOf(el.nodeName.toLowerCase()) >= 0) return true;
    return false;
  }
  function androidNeedsBlur(el) {
    const noBlur = ('button input textarea select').split(' ');
    if (__WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */].activeElement && el !== __WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */].activeElement && __WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */].activeElement !== __WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */].body) {
      if (noBlur.indexOf(el.nodeName.toLowerCase()) >= 0) {
        return false;
      }
      return true;
    }
    return false;
  }
  function targetNeedsFastClick(el) {
    /*
    if (
      Device.ios
      &&
      (
        Device.osVersion.split('.')[0] > 9
        ||
        (Device.osVersion.split('.')[0] * 1 === 9 && Device.osVersion.split('.')[1] >= 1)
      )
    ) {
      return false;
    }
    */
    const $el = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(el);
    if (el.nodeName.toLowerCase() === 'input' && (el.type === 'file' || el.type === 'range')) return false;
    if (el.nodeName.toLowerCase() === 'select' && Device.android) return false;
    if ($el.hasClass('no-fastclick') || $el.parents('.no-fastclick').length > 0) return false;
    if (params.fastClicksExclude && $el.is(params.fastClicksExclude)) return false;
    return true;
  }
  function targetNeedsFocus(el) {
    if (__WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */].activeElement === el) {
      return false;
    }
    const tag = el.nodeName.toLowerCase();
    const skipInputs = ('button checkbox file image radio submit').split(' ');
    if (el.disabled || el.readOnly) return false;
    if (tag === 'textarea') return true;
    if (tag === 'select') {
      if (Device.android) return false;
      return true;
    }
    if (tag === 'input' && skipInputs.indexOf(el.type) < 0) return true;
    return false;
  }
  function targetNeedsPrevent(el) {
    const $el = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(el);
    let prevent = true;
    if ($el.is('label') || $el.parents('label').length > 0) {
      if (Device.android) {
        prevent = false;
      } else if (Device.ios && $el.is('input')) {
        prevent = true;
      } else prevent = false;
    }
    return prevent;
  }

  // Ripple handlers
  function findRippleElement(el) {
    const rippleElements = params.materialRippleElements;
    const $el = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(el);
    if ($el.is(rippleElements)) {
      if ($el.hasClass('no-ripple')) {
        return false;
      }
      return $el;
    } else if ($el.parents(rippleElements).length > 0) {
      const rippleParent = $el.parents(rippleElements).eq(0);
      if (rippleParent.hasClass('no-ripple')) {
        return false;
      }
      return rippleParent;
    }
    return false;
  }
  function createRipple($el, x, y) {
    if (!$el) return;
    rippleWave = app.touchRipple.create($el, x, y);
  }

  function removeRipple() {
    if (!rippleWave) return;
    rippleWave.remove();
    rippleWave = undefined;
    rippleTarget = undefined;
  }
  function rippleTouchStart(el) {
    rippleTarget = findRippleElement(el);
    if (!rippleTarget || rippleTarget.length === 0) {
      rippleTarget = undefined;
      return;
    }
    if (!isInsideScrollableView(rippleTarget)) {
      createRipple(rippleTarget, touchStartX, touchStartY);
    } else {
      rippleTimeout = setTimeout(() => {
        createRipple(rippleTarget, touchStartX, touchStartY);
      }, 80);
    }
  }
  function rippleTouchMove() {
    clearTimeout(rippleTimeout);
    removeRipple();
  }
  function rippleTouchEnd() {
    if (rippleWave) {
      removeRipple();
    } else if (rippleTarget && !isMoved) {
      clearTimeout(rippleTimeout);
      createRipple(rippleTarget, touchStartX, touchStartY);
      setTimeout(removeRipple, 0);
    } else {
      removeRipple();
    }
  }

  // Mouse Handlers
  function handleMouseDown(e) {
    findActivableElement(e.target).addClass('active-state');
    if ('which' in e && e.which === 3) {
      setTimeout(() => {
        Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])('.active-state').removeClass('active-state');
      }, 0);
    }
    if (useRipple) {
      touchStartX = e.pageX;
      touchStartY = e.pageY;
      rippleTouchStart(e.target, e.pageX, e.pageY);
    }
  }
  function handleMouseMove() {
    Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])('.active-state').removeClass('active-state');
    if (useRipple) {
      rippleTouchMove();
    }
  }
  function handleMouseUp() {
    Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])('.active-state').removeClass('active-state');
    if (useRipple) {
      rippleTouchEnd();
    }
  }

  // Send Click
  function sendClick(e) {
    const touch = e.changedTouches[0];
    const evt = __WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */].createEvent('MouseEvents');
    let eventType = 'click';
    if (Device.android && targetElement.nodeName.toLowerCase() === 'select') {
      eventType = 'mousedown';
    }
    evt.initMouseEvent(eventType, true, true, __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */], 1, touch.screenX, touch.screenY, touch.clientX, touch.clientY, false, false, false, false, 0, null);
    evt.forwardedTouchEvent = true;

    if (app.device.ios && __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].navigator.standalone) {
      // Fix the issue happens in iOS home screen apps where the wrong element is selected during a momentum scroll.
      // Upon tapping, we give the scrolling time to stop, then we grab the element based where the user tapped.
      setTimeout(() => {
        targetElement = __WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */].elementFromPoint(e.changedTouches[0].clientX, e.changedTouches[0].clientY);
        targetElement.dispatchEvent(evt);
      }, 10);
    } else {
      targetElement.dispatchEvent(evt);
    }
  }

  // Touch Handlers
  function handleTouchStart(e) {
    isMoved = false;
    tapHoldFired = false;
    if (e.targetTouches.length > 1) {
      if (activableElement) removeActive();
      return true;
    }
    if (e.touches.length > 1 && activableElement) {
      removeActive();
    }
    if (params.tapHold) {
      if (tapHoldTimeout) clearTimeout(tapHoldTimeout);
      tapHoldTimeout = setTimeout(() => {
        if (e && e.touches && e.touches.length > 1) return;
        tapHoldFired = true;
        e.preventDefault();
        Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(e.target).trigger('taphold');
      }, params.tapHoldDelay);
    }
    if (needsFastClickTimeOut) clearTimeout(needsFastClickTimeOut);
    needsFastClick = targetNeedsFastClick(e.target);

    if (!needsFastClick) {
      trackClick = false;
      return true;
    }
    if (Device.ios || (Device.android && 'getSelection' in __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */])) {
      const selection = __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].getSelection();
      if (
        selection.rangeCount &&
        selection.focusNode !== __WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */].body &&
        (!selection.isCollapsed || __WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */].activeElement === selection.focusNode)
      ) {
        activeSelection = true;
        return true;
      }

      activeSelection = false;
    }
    if (Device.android) {
      if (androidNeedsBlur(e.target)) {
        __WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */].activeElement.blur();
      }
    }

    trackClick = true;
    targetElement = e.target;
    touchStartTime = (new Date()).getTime();
    touchStartX = e.targetTouches[0].pageX;
    touchStartY = e.targetTouches[0].pageY;

    // Detect scroll parent
    if (Device.ios) {
      scrollParent = undefined;
      Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(targetElement).parents().each(() => {
        const parent = this;
        if (parent.scrollHeight > parent.offsetHeight && !scrollParent) {
          scrollParent = parent;
          scrollParent.f7ScrollTop = scrollParent.scrollTop;
        }
      });
    }
    if ((touchStartTime - lastClickTime) < params.fastClicksDelayBetweenClicks) {
      e.preventDefault();
    }

    if (params.activeState) {
      activableElement = findActivableElement(targetElement);
      // If it's inside a scrollable view, we don't trigger active-state yet,
      // because it can be a scroll instead. Based on the link:
      // http://labnote.beedesk.com/click-scroll-and-pseudo-active-on-mobile-webk
      if (!isInsideScrollableView(activableElement)) {
        addActive();
      } else {
        activeTimeout = setTimeout(addActive, 80);
      }
    }
    if (useRipple) {
      rippleTouchStart(targetElement, touchStartX, touchStartY);
    }
    return true;
  }
  function handleTouchMove(e) {
    if (!trackClick) return;
    const distance = params.fastClicksDistanceThreshold;
    if (distance) {
      const pageX = e.targetTouches[0].pageX;
      const pageY = e.targetTouches[0].pageY;
      if (Math.abs(pageX - touchStartX) > distance || Math.abs(pageY - touchStartY) > distance) {
        isMoved = true;
      }
    } else {
      isMoved = true;
    }
    if (isMoved) {
      trackClick = false;
      targetElement = null;
      isMoved = true;
      if (params.tapHold) {
        clearTimeout(tapHoldTimeout);
      }
      if (params.activeState) {
        clearTimeout(activeTimeout);
        removeActive();
      }
      if (useRipple) {
        rippleTouchMove();
      }
    }
  }
  function handleTouchEnd(e) {
    clearTimeout(activeTimeout);
    clearTimeout(tapHoldTimeout);

    const touchEndTime = (new Date()).getTime();

    if (!trackClick) {
      if (!activeSelection && needsFastClick) {
        if (!(Device.android && !e.cancelable) && e.cancelable) {
          e.preventDefault();
        }
      }
      return true;
    }

    if (__WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */].activeElement === e.target) {
      if (params.activeState) removeActive();
      if (useRipple) {
        rippleTouchEnd();
      }
      return true;
    }

    if (!activeSelection) {
      e.preventDefault();
    }

    if ((touchEndTime - lastClickTime) < params.fastClicksDelayBetweenClicks) {
      setTimeout(removeActive, 0);
      return true;
    }

    lastClickTime = touchEndTime;

    trackClick = false;

    if (Device.ios && scrollParent) {
      if (scrollParent.scrollTop !== scrollParent.f7ScrollTop) {
        return false;
      }
    }

    // Add active-state here because, in a very fast tap, the timeout didn't
    // have the chance to execute. Removing active-state in a timeout gives
    // the chance to the animation execute.
    if (params.activeState) {
      addActive();
      setTimeout(removeActive, 0);
    }
    // Remove Ripple
    if (useRipple) {
      rippleTouchEnd();
    }

    // Trigger focus when required
    if (targetNeedsFocus(targetElement)) {
      if (Device.ios && Device.webView) {
        targetElement.focus();
        return false;
      }

      targetElement.focus();
    }

    // Blur active elements
    if (__WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */].activeElement && targetElement !== __WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */].activeElement && __WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */].activeElement !== __WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */].body && targetElement.nodeName.toLowerCase() !== 'label') {
      __WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */].activeElement.blur();
    }

    // Send click
    e.preventDefault();
    if (params.tapHoldPreventClicks && tapHoldFired) {
      return false;
    }
    sendClick(e);
    return false;
  }
  function handleTouchCancel() {
    trackClick = false;
    targetElement = null;

    // Remove Active State
    clearTimeout(activeTimeout);
    clearTimeout(tapHoldTimeout);
    if (params.activeState) {
      removeActive();
    }

    // Remove Ripple
    if (useRipple) {
      rippleTouchEnd();
    }
  }

  function handleClick(e) {
    let allowClick = false;
    if (trackClick) {
      targetElement = null;
      trackClick = false;
      return true;
    }
    if ((e.target.type === 'submit' && e.detail === 0) || e.target.type === 'file') {
      return true;
    }
    if (!targetElement) {
      if (!isFormElement(e.target)) {
        allowClick = true;
      }
    }
    if (!needsFastClick) {
      allowClick = true;
    }
    if (__WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */].activeElement === targetElement) {
      allowClick = true;
    }
    if (e.forwardedTouchEvent) {
      allowClick = true;
    }
    if (!e.cancelable) {
      allowClick = true;
    }
    if (params.tapHold && params.tapHoldPreventClicks && tapHoldFired) {
      allowClick = false;
    }
    if (!allowClick) {
      e.stopImmediatePropagation();
      e.stopPropagation();
      if (targetElement) {
        if (targetNeedsPrevent(targetElement) || isMoved) {
          e.preventDefault();
        }
      } else {
        e.preventDefault();
      }
      targetElement = null;
    }
    needsFastClickTimeOut = setTimeout(() => {
      needsFastClick = false;
    }, (Device.ios || Device.androidChrome ? 100 : 400));

    if (params.tapHold) {
      tapHoldTimeout = setTimeout(() => {
        tapHoldFired = false;
      }, (Device.ios || Device.androidChrome ? 100 : 400));
    }

    return allowClick;
  }

  function emitAppTouchEvent(name, e) {
    app.emit({
      events: name,
      data: [e],
    });
  }
  function appClick(e) {
    emitAppTouchEvent('click', e);
  }
  function appTouchStartActive(e) {
    emitAppTouchEvent('touchstart touchstart:active', e);
  }
  function appTouchMoveActive(e) {
    emitAppTouchEvent('touchmove touchmove:active', e);
  }
  function appTouchEndActive(e) {
    emitAppTouchEvent('touchend touchend:active', e);
  }
  function appTouchStartPassive(e) {
    emitAppTouchEvent('touchstart:passive', e);
  }
  function appTouchMovePassive(e) {
    emitAppTouchEvent('touchmove:passive', e);
  }
  function appTouchEndPassive(e) {
    emitAppTouchEvent('touchend:passive', e);
  }

  const passiveListener = Support.passiveListener ? { passive: true } : false;
  const activeListener = Support.passiveListener ? { passive: false } : false;

  __WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */].addEventListener('click', appClick, true);

  if (Support.passiveListener) {
    __WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */].addEventListener(app.touchEvents.start, appTouchStartActive, activeListener);
    __WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */].addEventListener(app.touchEvents.move, appTouchMoveActive, activeListener);
    __WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */].addEventListener(app.touchEvents.end, appTouchEndActive, activeListener);

    __WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */].addEventListener(app.touchEvents.start, appTouchStartPassive, passiveListener);
    __WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */].addEventListener(app.touchEvents.move, appTouchMovePassive, passiveListener);
    __WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */].addEventListener(app.touchEvents.end, appTouchEndPassive, passiveListener);
  } else {
    __WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */].addEventListener(app.touchEvents.start, (e) => {
      appTouchStartActive(e);
      appTouchStartPassive(e);
    }, false);
    __WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */].addEventListener(app.touchEvents.move, (e) => {
      appTouchMoveActive(e);
      appTouchMovePassive(e);
    }, false);
    __WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */].addEventListener(app.touchEvents.end, (e) => {
      appTouchEndActive(e);
      appTouchEndPassive(e);
    }, false);
  }

  if (Support.touch) {
    app.on('click', handleClick);
    app.on('touchstart', handleTouchStart);
    app.on('touchmove', handleTouchMove);
    app.on('touchend', handleTouchEnd);
    __WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */].addEventListener('touchcancel', handleTouchCancel, { passive: true });
  } else if (params.activeState) {
    app.on('touchstart', handleMouseDown);
    app.on('touchmove', handleMouseMove);
    app.on('touchend', handleMouseUp);
  }
  __WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */].addEventListener('contextmenu', (e) => {
    if (params.disableContextMenu && (Device.ios || Device.android || Device.cordova)) {
      e.preventDefault();
    }
    if (useRipple) {
      if (activableElement) removeActive();
      rippleTouchEnd();
    }
  });
}

var TouchModule = {
  name: 'touch',
  params: {
    touch: {
      // Fast clicks
      fastClicks: true,
      fastClicksDistanceThreshold: 10,
      fastClicksDelayBetweenClicks: 50,
      fastClicksExclude: '', // CSS selector
      // ContextMenu
      disableContextMenu: true,
      // Tap Hold
      tapHold: false,
      tapHoldDelay: 750,
      tapHoldPreventClicks: true,
      // Active State
      activeState: true,
      activeStateElements: 'a, button, label, span, .actions-button, .stepper-button, .stepper-button-plus, .stepper-button-minus',
      materialRipple: true,
      materialRippleElements: '.ripple, .link, .item-link, .links-list a, .button, button, .input-clear-button, .dialog-button, .tab-link, .item-radio, .item-checkbox, .actions-button, .searchbar-disable-button, .fab a, .checkbox, .radio, .data-table .sortable-cell:not(.input-cell), .notification-close-button, .stepper-button, .stepper-button-minus, .stepper-button-plus',
    },
  },
  instance: {
    touchEvents: {
      start: Support.touch ? 'touchstart' : 'mousedown',
      move: Support.touch ? 'touchmove' : 'mousemove',
      end: Support.touch ? 'touchend' : 'mouseup',
    },
  },
  on: {
    init: initTouch,
  },
};

const tempDom = __WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */].createElement('div');

class Framework7Component {
  constructor(opts, extendContext = {}) {
    const options = Utils.extend({}, opts);
    let component = Utils.merge(this, extendContext, { $options: options });

    // Apply context
    ('beforeCreate created beforeMount mounted beforeDestroy destroyed').split(' ').forEach((cycleKey) => {
      if (options[cycleKey]) options[cycleKey] = options[cycleKey].bind(component);
    });

    if (options.data) {
      options.data = options.data.bind(component);
      // Data
      Utils.extend(component, options.data());
    }
    if (options.render) options.render = options.render.bind(component);
    if (options.methods) {
      Object.keys(options.methods).forEach((methodName) => {
        component[methodName] = options.methods[methodName].bind(component);
      });
    }

    // Bind Events
    if (options.on) {
      Object.keys(options.on).forEach((eventName) => {
        options.on[eventName] = options.on[eventName].bind(component);
      });
    }
    if (options.once) {
      Object.keys(options.once).forEach((eventName) => {
        options.once[eventName] = options.once[eventName].bind(component);
      });
    }

    if (options.beforeCreate) options.beforeCreate();

    // Watchers
    if (options.watch) {
      Object.keys(options.watch).forEach((watchKey) => {
        let dataKeyValue = component[watchKey];
        Object.defineProperty(component, watchKey, {
          enumerable: true,
          configurable: true,
          set(newValue) {
            const previousValue = dataKeyValue;
            dataKeyValue = newValue;
            if (previousValue === newValue) return;
            options.watch[watchKey].call(component, newValue, previousValue);
          },
          get() {
            return dataKeyValue;
          },
        });
      });
    }

    // Render template

    function render() {
      let html = '';
      if (options.render) {
        html = options.render();
      } else if (options.template) {
        if (typeof options.template === 'string') {
          try {
            html = __WEBPACK_IMPORTED_MODULE_2_template7__["a" /* default */].compile(options.template)(component);
          } catch (err) {
            throw err;
          }
        } else {
          // Supposed to be function
          html = options.template(component);
        }
      }
      return html;
    }

    let html = render();

    // Make Dom
    if (html && typeof html === 'string') {
      html = html.trim();
      tempDom.innerHTML = html;
    } else if (html) {
      tempDom.innerHTML = '';
      tempDom.appendChild(html);
    }

    // Extend component with $el
    const el = tempDom.children[0];
    const $el = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(el);
    component.$el = $el;
    component.el = el;
    component.el = el;

    // Find Events
    const events = [];
    Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(tempDom).find('*').each((index, element) => {
      const attrs = [];
      for (let i = 0; i < element.attributes.length; i += 1) {
        const attr = element.attributes[i];
        if (attr.name.indexOf('@') === 0) {
          attrs.push({
            name: attr.name,
            value: attr.value,
          });
        }
      }
      attrs.forEach((attr) => {
        element.removeAttribute(attr.name);
        const event = attr.name.replace('@', '');
        let name = event;
        let stop = false;
        let prevent = false;
        let once = false;
        if (event.indexOf('.') >= 0) {
          event.split('.').forEach((eventNamePart, eventNameIndex) => {
            if (eventNameIndex === 0) name = eventNamePart;
            else {
              if (eventNamePart === 'stop') stop = true;
              if (eventNamePart === 'prevent') prevent = true;
              if (eventNamePart === 'once') once = true;
            }
          });
        }
        const value = attr.value.toString();
        events.push({
          el: element,
          name,
          once,
          handler(...args) {
            const e = args[0];
            if (stop) e.stopPropagation();
            if (prevent) e.preventDefault();
            let methodName;
            let method;
            let customArgs = [];
            if (value.indexOf('(') < 0) {
              customArgs = args;
              methodName = value;
            } else {
              methodName = value.split('(')[0];
              value.split('(')[1].split(')')[0].split(',').forEach((argument) => {
                let arg = argument.trim();
                // eslint-disable-next-line
                if (!isNaN(arg)) arg = parseFloat(arg);
                else if (arg === 'true') arg = true;
                else if (arg === 'false') arg = false;
                else if (arg === 'null') arg = null;
                else if (arg === 'undefined') arg = undefined;
                else if (arg[0] === '"') arg = arg.replace(/"/g, '');
                else if (arg[0] === '\'') arg = arg.replace(/'/g, '');
                else if (arg.indexOf('.') > 0) {
                  let deepArg;
                  arg.split('.').forEach((path) => {
                    if (!deepArg) deepArg = component;
                    deepArg = deepArg[path];
                  });
                  arg = deepArg;
                } else {
                  arg = component[arg];
                }
                customArgs.push(arg);
              });
            }
            if (methodName.indexOf('.') >= 0) {
              methodName.split('.').forEach((path, pathIndex) => {
                if (!method) method = component;
                if (method[path]) method = method[path];
                else {
                  throw new Error(`Component doesn't have method "${methodName.split('.').slice(0, pathIndex + 1).join('.')}"`);
                }
              });
            } else {
              if (!component[methodName]) {
                throw new Error(`Component doesn't have method "${methodName}"`);
              }
              method = component[methodName];
            }
            method(...customArgs);
          },
        });
      });
    });

    // Set styles scope ID
    let styleEl;
    if (options.style) {
      styleEl = __WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */].createElement('style');
      styleEl.innerHTML = options.style;
    }
    if (options.styleScopeId) {
      el.setAttribute('data-scope', options.styleScopeId);
    }

    // Attach events
    function attachEvents() {
      if (options.on) {
        Object.keys(options.on).forEach((eventName) => {
          $el.on(Utils.eventNameToColonCase(eventName), options.on[eventName]);
        });
      }
      if (options.once) {
        Object.keys(options.once).forEach((eventName) => {
          $el.once(Utils.eventNameToColonCase(eventName), options.once[eventName]);
        });
      }
      events.forEach((event) => {
        Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(event.el)[event.once ? 'once' : 'on'](event.name, event.handler);
      });
    }

    function detachEvents() {
      if (options.on) {
        Object.keys(options.on).forEach((eventName) => {
          $el.off(Utils.eventNameToColonCase(eventName), options.on[eventName]);
        });
      }
      if (options.once) {
        Object.keys(options.once).forEach((eventName) => {
          $el.off(Utils.eventNameToColonCase(eventName), options.once[eventName]);
        });
      }
      events.forEach((event) => {
        Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(event.el).off(event.name, event.handler);
      });
    }

    attachEvents();

    // Created callback
    if (options.created) options.created();

    // Mount
    component.$mount = function mount(mountMethod) {
      if (options.beforeMount) options.beforeMount();
      if (styleEl) Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])('head').append(styleEl);
      if (mountMethod) mountMethod(el);
      if (options.mounted) options.mounted();
    };

    // Destroy
    component.$destroy = function destroy() {
      if (options.beforeDestroy) options.beforeDestroy();
      if (styleEl) Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(styleEl).remove();
      detachEvents();
      if (options.destroyed) options.destroyed();
      // Delete component instance
      if (el && el.f7Component) {
        el.f7Component = null;
        delete el.f7Component;
      }
      Utils.deleteProps(component);
      component = null;
    };

    // Store component instance
    for (let i = 0; i < tempDom.children.length; i += 1) {
      tempDom.children[i].f7Component = component;
    }

    return component;
  }
}


const Component = {
  parse(componentString) {
    const callbackName = `f7_component_callback_${new Date().getTime()}`;

    // Template
    let template;
    if (componentString.indexOf('<template>') >= 0) {
      template = componentString
        .split('<template>')
        .filter((item, index) => index > 0)
        .join('<template>')
        .split('</template>')
        .filter((item, index, arr) => index < arr.length - 1)
        .join('</template>')
        .replace(/{{#raw}}([ \n]*)<template/g, '{{#raw}}<template')
        .replace(/\/template>([ \n]*){{\/raw}}/g, '/template>{{/raw}}')
        .replace(/([ \n])<template/g, '$1{{#raw}}<template')
        .replace(/\/template>([ \n])/g, '/template>{{/raw}}$1');
    }

    // Styles
    let style;
    const styleScopeId = Utils.now();
    if (componentString.indexOf('<style>') >= 0) {
      style = componentString.split('<style>')[1].split('</style>')[0];
    } else if (componentString.indexOf('<style scoped>') >= 0) {
      style = componentString.split('<style scoped>')[1].split('</style>')[0];
      style = style.split('\n').map((line) => {
        if (line.indexOf('{') >= 0) {
          if (line.indexOf('{{this}}') >= 0) {
            return line.replace('{{this}}', `[data-scope="${styleScopeId}"]`);
          }
          return `[data-scope="${styleScopeId}"] ${line.trim()}`;
        }
        return line;
      }).join('\n');
    }

    let scriptContent;
    if (componentString.indexOf('<script>') >= 0) {
      const scripts = componentString.split('<script>');
      scriptContent = scripts[scripts.length - 1].split('</script>')[0].trim();
    } else {
      scriptContent = 'return {}';
    }
    scriptContent = `window.${callbackName} = function () {${scriptContent}}`;

    // Insert Script El
    const scriptEl = __WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */].createElement('script');
    scriptEl.innerHTML = scriptContent;
    Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])('head').append(scriptEl);

    const component = __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */][callbackName]();

    // Remove Script El
    Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(scriptEl).remove();

    if (!component.template && !component.render) {
      component.template = template;
    }
    if (style) {
      component.style = style;
      component.styleScopeId = styleScopeId;
    }
    return component;
  },
  create(c, extendContext = {}) {
    return new Framework7Component(c, extendContext);
  },
};

const History = {
  queue: [],
  clearQueue() {
    if (History.queue.length === 0) return;
    const currentQueue = History.queue.shift();
    currentQueue();
  },
  routerQueue: [],
  clearRouterQueue() {
    if (History.routerQueue.length === 0) return;
    const currentQueue = History.routerQueue.pop();
    const { router, stateUrl, action } = currentQueue;

    let animate = router.params.animate;
    if (router.params.pushStateAnimate === false) animate = false;

    if (action === 'back') {
      router.back({ animate, pushState: false });
    }
    if (action === 'load') {
      router.navigate(stateUrl, { animate, pushState: false });
    }
  },
  handle(e) {
    if (History.blockPopstate) return;
    const app = this;
    // const mainView = app.views.main;
    let state = e.state;
    History.previousState = History.state;
    History.state = state;

    History.allowChange = true;
    History.clearQueue();

    state = History.state;
    if (!state) state = {};

    app.views.forEach((view) => {
      const router = view.router;
      let viewState = state[view.id];
      if (!viewState && view.params.pushState) {
        viewState = {
          url: view.router.history[0],
        };
      }
      if (!viewState) return;
      const stateUrl = viewState.url || undefined;

      let animate = router.params.animate;
      if (router.params.pushStateAnimate === false) animate = false;

      if (stateUrl !== router.url) {
        if (router.history.indexOf(stateUrl) >= 0) {
          // Go Back
          if (router.allowPageChange) {
            router.back({ animate, pushState: false });
          } else {
            History.routerQueue.push({
              action: 'back',
              router,
            });
          }
        } else if (router.allowPageChange) {
          // Load page
          router.navigate(stateUrl, { animate, pushState: false });
        } else {
          History.routerQueue.unshift({
            action: 'load',
            stateUrl,
            router,
          });
        }
      }
    });
  },
  initViewState(viewId, viewState) {
    const newState = Utils.extend({}, (History.state || {}), {
      [viewId]: viewState,
    });
    History.state = newState;
    __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].history.replaceState(newState, '');
  },
  push(viewId, viewState, url) {
    if (!History.allowChange) {
      History.queue.push(() => {
        History.push(viewId, viewState, url);
      });
      return;
    }
    History.previousState = History.state;
    const newState = Utils.extend({}, (History.previousState || {}), {
      [viewId]: viewState,
    });
    History.state = newState;
    __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].history.pushState(newState, '', url);
  },
  replace(viewId, viewState, url) {
    if (!History.allowChange) {
      History.queue.push(() => {
        History.replace(viewId, viewState, url);
      });
      return;
    }
    History.previousState = History.state;
    const newState = Utils.extend({}, (History.previousState || {}), {
      [viewId]: viewState,
    });
    History.state = newState;
    __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].history.replaceState(newState, '', url);
  },
  go(index) {
    History.allowChange = false;
    __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].history.go(index);
  },
  back() {
    History.allowChange = false;
    __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].history.back();
  },
  allowChange: true,
  previousState: {},
  state: __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].history.state,
  blockPopstate: true,
  init(app) {
    Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(__WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */]).on('load', () => {
      setTimeout(() => {
        History.blockPopstate = false;
      }, 0);
    });

    if (__WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */].readyState && __WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */].readyState === 'complete') {
      History.blockPopstate = false;
    }

    Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(__WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */]).on('popstate', History.handle.bind(app));
  },
};

function SwipeBack(r) {
  const router = r;
  const { $el, $navbarEl, app, params } = router;
  let isTouched = false;
  let isMoved = false;
  const touchesStart = {};
  let isScrolling;
  let currentPage = [];
  let previousPage = [];
  let viewContainerWidth;
  let touchesDiff;
  let allowViewTouchMove = true;
  let touchStartTime;
  let currentNavbar = [];
  let previousNavbar = [];
  let currentNavElements;
  let previousNavElements;
  let activeNavBackIcon;
  let activeNavBackIconText;
  let previousNavBackIcon;
  // let previousNavBackIconText;
  let dynamicNavbar;
  let separateNavbar;
  let pageShadow;
  let pageOpacity;
  let navbarWidth;

  const paramsSwipeBackAnimateShadow = params[`${app.theme}SwipeBackAnimateShadow`];
  const paramsSwipeBackAnimateOpacity = params[`${app.theme}SwipeBackAnimateOpacity`];
  const paramsSwipeBackActiveArea = params[`${app.theme}SwipeBackActiveArea`];
  const paramsSwipeBackThreshold = params[`${app.theme}SwipeBackThreshold`];

  function handleTouchStart(e) {
    const swipeBackEnabled = params[`${app.theme}SwipeBack`];
    if (!allowViewTouchMove || !swipeBackEnabled || isTouched || (app.swipeout && app.swipeout.el) || !router.allowPageChange) return;
    if (Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(e.target).closest('.range-slider, .calendar-months').length > 0) return;
    isMoved = false;
    isTouched = true;
    isScrolling = undefined;
    touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
    touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
    touchStartTime = Utils.now();
    dynamicNavbar = router.dynamicNavbar;
    separateNavbar = router.separateNavbar;
  }
  function handleTouchMove(e) {
    if (!isTouched) return;
    const pageX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
    const pageY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
    if (typeof isScrolling === 'undefined') {
      isScrolling = !!(isScrolling || Math.abs(pageY - touchesStart.y) > Math.abs(pageX - touchesStart.x)) || pageX < touchesStart.x;
    }
    if (isScrolling || e.f7PreventSwipeBack || app.preventSwipeBack) {
      isTouched = false;
      return;
    }
    if (!isMoved) {
      // Calc values during first move fired
      let cancel = false;
      const target = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(e.target);

      const swipeout = target.closest('.swipeout');
      if (swipeout.length > 0) {
        if (!app.rtl && swipeout.find('.swipeout-actions-left').length > 0) cancel = true;
        if (app.rtl && swipeout.find('.swipeout-actions-right').length > 0) cancel = true;
      }

      currentPage = target.closest('.page');
      if (currentPage.hasClass('no-swipeback') || target.closest('.no-swipeback').length > 0) cancel = true;
      previousPage = $el.find('.page-previous:not(.stacked)');

      let notFromBorder = touchesStart.x - $el.offset().left > paramsSwipeBackActiveArea;
      viewContainerWidth = $el.width();
      if (app.rtl) {
        notFromBorder = touchesStart.x < ($el.offset().left - $el[0].scrollLeft) + (viewContainerWidth - paramsSwipeBackActiveArea);
      } else {
        notFromBorder = touchesStart.x - $el.offset().left > paramsSwipeBackActiveArea;
      }
      if (notFromBorder) cancel = true;
      if (previousPage.length === 0 || currentPage.length === 0) cancel = true;
      if (cancel) {
        isTouched = false;
        return;
      }

      if (paramsSwipeBackAnimateShadow) {
        pageShadow = currentPage.find('.page-shadow-effect');
        if (pageShadow.length === 0) {
          pageShadow = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])('<div class="page-shadow-effect"></div>');
          currentPage.append(pageShadow);
        }
      }
      if (paramsSwipeBackAnimateOpacity) {
        pageOpacity = previousPage.find('.page-opacity-effect');
        if (pageOpacity.length === 0) {
          pageOpacity = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])('<div class="page-opacity-effect"></div>');
          previousPage.append(pageOpacity);
        }
      }

      if (dynamicNavbar) {
        if (separateNavbar) {
          currentNavbar = $navbarEl.find('.navbar-current:not(.stacked)');
          previousNavbar = $navbarEl.find('.navbar-previous:not(.stacked)');
        } else {
          currentNavbar = currentPage.children('.navbar').children('.navbar-inner');
          previousNavbar = previousPage.children('.navbar').children('.navbar-inner');
        }
        navbarWidth = $navbarEl[0].offsetWidth;
        currentNavElements = currentNavbar.children('.left, .title, .right, .subnavbar, .fading');
        previousNavElements = previousNavbar.children('.left, .title, .right, .subnavbar, .fading');
        if (params.iosAnimateNavbarBackIcon) {
          if (currentNavbar.hasClass('sliding')) {
            activeNavBackIcon = currentNavbar.children('.left').find('.back .icon');
            activeNavBackIconText = currentNavbar.children('.left').find('.back span').eq(0);
          } else {
            activeNavBackIcon = currentNavbar.children('.left.sliding').find('.back .icon');
            activeNavBackIconText = currentNavbar.children('.left.sliding').find('.back span').eq(0);
          }
          if (previousNavbar.hasClass('sliding')) {
            previousNavBackIcon = previousNavbar.children('.left').find('.back .icon');
            // previousNavBackIconText = previousNavbar.children('left').find('.back span').eq(0);
          } else {
            previousNavBackIcon = previousNavbar.children('.left.sliding').find('.back .icon');
            // previousNavBackIconText = previousNavbar.children('.left.sliding').find('.back span').eq(0);
          }
        }
      }

      // Close/Hide Any Picker
      if (Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])('.sheet.modal-in').length > 0 && app.sheet) {
        app.sheet.close(Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])('.sheet.modal-in'));
      }
    }
    e.f7PreventPanelSwipe = true;
    isMoved = true;
    app.preventSwipePanelBySwipeBack = true;
    e.preventDefault();

    // RTL inverter
    const inverter = app.rtl ? -1 : 1;

    // Touches diff
    touchesDiff = (pageX - touchesStart.x - paramsSwipeBackThreshold) * inverter;
    if (touchesDiff < 0) touchesDiff = 0;
    const percentage = touchesDiff / viewContainerWidth;

    // Swipe Back Callback
    const callbackData = {
      percentage,
      currentPageEl: currentPage[0],
      previousPageEl: previousPage[0],
      currentNavbarEl: currentNavbar[0],
      previousNavbarEl: previousNavbar[0],
    };
    $el.trigger('swipeback:move', callbackData);
    router.emit('swipebackMove', callbackData);

    // Transform pages
    let currentPageTranslate = touchesDiff * inverter;
    let previousPageTranslate = ((touchesDiff / 5) - (viewContainerWidth / 5)) * inverter;
    if (Device.pixelRatio === 1) {
      currentPageTranslate = Math.round(currentPageTranslate);
      previousPageTranslate = Math.round(previousPageTranslate);
    }

    currentPage.transform(`translate3d(${currentPageTranslate}px,0,0)`);
    if (paramsSwipeBackAnimateShadow) pageShadow[0].style.opacity = 1 - (1 * percentage);

    if (app.theme !== 'md') {
      previousPage.transform(`translate3d(${previousPageTranslate}px,0,0)`);
    }
    if (paramsSwipeBackAnimateOpacity) pageOpacity[0].style.opacity = 1 - (1 * percentage);

    // Dynamic Navbars Animation
    if (dynamicNavbar) {
      currentNavElements.each((index, navEl) => {
        const $navEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(navEl);
        if (!$navEl.is('.subnavbar')) $navEl[0].style.opacity = (1 - (percentage ** 0.33));
        if ($navEl[0].className.indexOf('sliding') >= 0 || currentNavbar.hasClass('sliding')) {
          let activeNavTranslate = percentage * $navEl[0].f7NavbarRightOffset;
          if (Device.pixelRatio === 1) activeNavTranslate = Math.round(activeNavTranslate);
          $navEl.transform(`translate3d(${activeNavTranslate}px,0,0)`);
          if (params.iosAnimateNavbarBackIcon) {
            if ($navEl[0].className.indexOf('left') >= 0 && activeNavBackIcon.length > 0) {
              let iconTranslate = -activeNavTranslate;
              if (!separateNavbar) {
                iconTranslate -= navbarWidth * percentage;
              }
              activeNavBackIcon.transform(`translate3d(${iconTranslate}px,0,0)`);
            }
          }
        }
      });
      previousNavElements.each((index, navEl) => {
        const $navEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(navEl);
        if (!$navEl.is('.subnavbar')) $navEl[0].style.opacity = (percentage ** 3);
        if ($navEl[0].className.indexOf('sliding') >= 0 || previousNavbar.hasClass('sliding')) {
          let previousNavTranslate = $navEl[0].f7NavbarLeftOffset * (1 - percentage);
          if ($navEl[0].className.indexOf('title') >= 0 && activeNavBackIcon && activeNavBackIcon.length && activeNavBackIconText.length) {
            previousNavTranslate = ($navEl[0].f7NavbarLeftOffset + activeNavBackIconText[0].offsetLeft) * (1 - percentage);
          } else {
            previousNavTranslate = $navEl[0].f7NavbarLeftOffset * (1 - percentage);
          }
          if (Device.pixelRatio === 1) previousNavTranslate = Math.round(previousNavTranslate);
          $navEl.transform(`translate3d(${previousNavTranslate}px,0,0)`);
          if (params.iosAnimateNavbarBackIcon) {
            if ($navEl[0].className.indexOf('left') >= 0 && previousNavBackIcon.length > 0) {
              let iconTranslate = -previousNavTranslate;
              if (!separateNavbar) {
                iconTranslate += (navbarWidth / 5) * (1 - percentage);
              }
              previousNavBackIcon.transform(`translate3d(${iconTranslate}px,0,0)`);
            }
          }
        }
      });
    }
  }
  function handleTouchEnd() {
    app.preventSwipePanelBySwipeBack = false;
    if (!isTouched || !isMoved) {
      isTouched = false;
      isMoved = false;
      return;
    }
    isTouched = false;
    isMoved = false;
    if (touchesDiff === 0) {
      Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])([currentPage[0], previousPage[0]]).transform('');
      if (pageShadow && pageShadow.length > 0) pageShadow.remove();
      if (pageOpacity && pageOpacity.length > 0) pageOpacity.remove();
      if (dynamicNavbar) {
        currentNavElements.transform('').css({ opacity: '' });
        previousNavElements.transform('').css({ opacity: '' });
        if (activeNavBackIcon && activeNavBackIcon.length > 0) activeNavBackIcon.transform('');
        if (previousNavBackIcon && activeNavBackIcon.length > 0) previousNavBackIcon.transform('');
      }
      return;
    }
    const timeDiff = Utils.now() - touchStartTime;
    let pageChanged = false;
    // Swipe back to previous page
    if (
      (timeDiff < 300 && touchesDiff > 10) ||
      (timeDiff >= 300 && touchesDiff > viewContainerWidth / 2)
    ) {
      currentPage.removeClass('page-current').addClass(`page-next${app.theme === 'md' ? ' page-next-on-right' : ''}`);
      previousPage.removeClass('page-previous').addClass('page-current').removeAttr('aria-hidden');
      if (pageShadow) pageShadow[0].style.opacity = '';
      if (pageOpacity) pageOpacity[0].style.opacity = '';
      if (dynamicNavbar) {
        currentNavbar.removeClass('navbar-current').addClass('navbar-next');
        previousNavbar.removeClass('navbar-previous').addClass('navbar-current').removeAttr('aria-hidden');
      }
      pageChanged = true;
    }
    // Reset custom styles
    // Add transitioning class for transition-duration
    Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])([currentPage[0], previousPage[0]]).addClass('page-transitioning page-transitioning-swipeback').transform('');

    if (dynamicNavbar) {
      currentNavElements.css({ opacity: '' })
        .each((navElIndex, navEl) => {
          const translate = pageChanged ? navEl.f7NavbarRightOffset : 0;
          const sliding = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(navEl);
          let iconTranslate = pageChanged ? -translate : 0;
          if (!separateNavbar && pageChanged) iconTranslate -= navbarWidth;
          sliding.transform(`translate3d(${translate}px,0,0)`);
          if (params.iosAnimateNavbarBackIcon) {
            if (sliding.hasClass('left') && activeNavBackIcon.length > 0) {
              activeNavBackIcon.addClass('navbar-transitioning').transform(`translate3d(${iconTranslate}px,0,0)`);
            }
          }
        }).addClass('navbar-transitioning');

      previousNavElements.transform('').css({ opacity: '' }).each((navElIndex, navEl) => {
        const translate = pageChanged ? 0 : navEl.f7NavbarLeftOffset;
        const sliding = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(navEl);
        let iconTranslate = pageChanged ? 0 : -translate;
        if (!separateNavbar && !pageChanged) iconTranslate += navbarWidth / 5;
        sliding.transform(`translate3d(${translate}px,0,0)`);
        if (params.iosAnimateNavbarBackIcon) {
          if (sliding.hasClass('left') && previousNavBackIcon.length > 0) {
            previousNavBackIcon.addClass('navbar-transitioning').transform(`translate3d(${iconTranslate}px,0,0)`);
          }
        }
      }).addClass('navbar-transitioning');
    }
    allowViewTouchMove = false;
    router.allowPageChange = false;

    // Swipe Back Callback
    const callbackData = {
      currentPage: currentPage[0],
      previousPage: previousPage[0],
      currentNavbar: currentNavbar[0],
      previousNavbar: previousNavbar[0],
    };

    if (pageChanged) {
      // Update Route
      router.currentRoute = previousPage[0].f7Page.route;
      router.currentPage = previousPage[0];

      // Page before animation callback
      router.pageCallback('beforeOut', currentPage, currentNavbar, 'current', 'next', { route: currentPage[0].f7Page.route, swipeBack: true });
      router.pageCallback('beforeIn', previousPage, previousNavbar, 'previous', 'current', { route: previousPage[0].f7Page.route, swipeBack: true });

      $el.trigger('swipeback:beforechange', callbackData);
      router.emit('swipebackBeforeChange', callbackData);
    } else {
      $el.trigger('swipeback:beforereset', callbackData);
      router.emit('swipebackBeforeReset', callbackData);
    }

    currentPage.transitionEnd(() => {
      Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])([currentPage[0], previousPage[0]]).removeClass('page-transitioning page-transitioning-swipeback');

      if (dynamicNavbar) {
        currentNavElements.removeClass('navbar-transitioning').css({ opacity: '' }).transform('');
        previousNavElements.removeClass('navbar-transitioning').css({ opacity: '' }).transform('');
        if (activeNavBackIcon && activeNavBackIcon.length > 0) activeNavBackIcon.removeClass('navbar-transitioning');
        if (previousNavBackIcon && previousNavBackIcon.length > 0) previousNavBackIcon.removeClass('navbar-transitioning');
      }
      allowViewTouchMove = true;
      router.allowPageChange = true;
      if (pageChanged) {
        // Update History
        if (router.history.length === 1) {
          router.history.unshift(router.url);
        }
        router.history.pop();
        router.saveHistory();

        // Update push state
        if (params.pushState) {
          History.back();
        }

        // Page after animation callback
        router.pageCallback('afterOut', currentPage, currentNavbar, 'current', 'next', { route: currentPage[0].f7Page.route, swipeBack: true });
        router.pageCallback('afterIn', previousPage, previousNavbar, 'previous', 'current', { route: previousPage[0].f7Page.route, swipeBack: true });

        // Remove Old Page
        if (params.stackPages && router.initialPages.indexOf(currentPage[0]) >= 0) {
          currentPage.addClass('stacked');
          if (separateNavbar) {
            currentNavbar.addClass('stacked');
          }
        } else {
          router.pageCallback('beforeRemove', currentPage, currentNavbar, 'next', { swipeBack: true });
          router.removePage(currentPage);
          if (separateNavbar) {
            router.removeNavbar(currentNavbar);
          }
        }

        $el.trigger('swipeback:afterchange', callbackData);
        router.emit('swipebackAfterChange', callbackData);

        router.emit('routeChanged', router.currentRoute, router.previousRoute, router);

        if (params.preloadPreviousPage) {
          router.back(router.history[router.history.length - 2], { preload: true });
        }
      } else {
        $el.trigger('swipeback:afterreset', callbackData);
        router.emit('swipebackAfterReset', callbackData);
      }
      if (pageShadow && pageShadow.length > 0) pageShadow.remove();
      if (pageOpacity && pageOpacity.length > 0) pageOpacity.remove();
    });
  }

  function attachEvents() {
    const passiveListener = (app.touchEvents.start === 'touchstart' && Support.passiveListener) ? { passive: true, capture: false } : false;
    $el.on(app.touchEvents.start, handleTouchStart, passiveListener);
    app.on('touchmove:active', handleTouchMove);
    app.on('touchend:passive', handleTouchEnd);
  }
  function detachEvents() {
    const passiveListener = (app.touchEvents.start === 'touchstart' && Support.passiveListener) ? { passive: true, capture: false } : false;
    $el.off(app.touchEvents.start, handleTouchStart, passiveListener);
    app.off('touchmove:active', handleTouchMove);
    app.off('touchend:passive', handleTouchEnd);
  }

  attachEvents();

  router.on('routerDestroy', detachEvents);
}

function redirect (direction, route, options) {
  const router = this;
  const redirect = route.route.redirect;
  if (options.initial && router.params.pushState) {
    options.replaceState = true; // eslint-disable-line
    options.history = true; // eslint-disable-line
  }
  function redirectResolve(redirectUrl, redirectOptions = {}) {
    router.allowPageChange = true;
    router[direction](redirectUrl, Utils.extend({}, options, redirectOptions));
  }
  function redirectReject() {
    router.allowPageChange = true;
  }
  if (typeof redirect === 'function') {
    router.allowPageChange = false;
    const redirectUrl = redirect.call(router, route, redirectResolve, redirectReject);
    if (redirectUrl && typeof redirectUrl === 'string') {
      router.allowPageChange = true;
      return router[direction](redirectUrl, options);
    }
    return router;
  }
  return router[direction](redirect, options);
}

function refreshPage() {
  const router = this;
  return router.navigate(router.currentRoute.url, {
    ignoreCache: true,
    reloadCurrent: true,
  });
}

function forward(el, forwardOptions = {}) {
  const router = this;
  const app = router.app;
  const view = router.view;

  const options = Utils.extend({
    animate: router.params.animate,
    pushState: true,
    replaceState: false,
    history: true,
    reloadCurrent: router.params.reloadPages,
    reloadPrevious: false,
    reloadAll: false,
    clearPreviousHistory: false,
    on: {},
  }, forwardOptions);

  const dynamicNavbar = router.dynamicNavbar;
  const separateNavbar = router.separateNavbar;

  const $viewEl = router.$el;
  const $newPage = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(el);
  const reload = options.reloadPrevious || options.reloadCurrent || options.reloadAll;
  let $oldPage;

  let $navbarEl;
  let $newNavbarInner;
  let $oldNavbarInner;

  if ($newPage.length) {
    // Remove theme elements
    router.removeThemeElements($newPage);
  }

  if (dynamicNavbar) {
    $newNavbarInner = $newPage.children('.navbar').children('.navbar-inner');
    if (separateNavbar) {
      $navbarEl = router.$navbarEl;
      if ($newNavbarInner.length > 0) {
        $newPage.children('.navbar').remove();
      }
      if ($newNavbarInner.length === 0 && $newPage[0].f7Page) {
        // Try from pageData
        $newNavbarInner = $newPage[0].f7Page.$navbarEl;
      }
    }
  }

  router.allowPageChange = false;
  if ($newPage.length === 0) {
    router.allowPageChange = true;
    return router;
  }

  // Pages In View
  const $pagesInView = $viewEl
    .children('.page:not(.stacked)')
    .filter((index, pageInView) => pageInView !== $newPage[0]);

  // Navbars In View
  let $navbarsInView;
  if (separateNavbar) {
    $navbarsInView = $navbarEl
      .children('.navbar-inner:not(.stacked)')
      .filter((index, navbarInView) => navbarInView !== $newNavbarInner[0]);
  }

  // Exit when reload previous and only 1 page in view so nothing ro reload
  if (options.reloadPrevious && $pagesInView.length < 2) {
    router.allowPageChange = true;
    return router;
  }

  // New Page
  let newPagePosition = 'next';
  if (options.reloadCurrent || options.reloadAll) {
    newPagePosition = 'current';
  } else if (options.reloadPrevious) {
    newPagePosition = 'previous';
  }
  $newPage
    .addClass(`page-${newPagePosition}`)
    .removeClass('stacked');

  if (dynamicNavbar && $newNavbarInner.length) {
    $newNavbarInner
      .addClass(`navbar-${newPagePosition}`)
      .removeClass('stacked');
  }

  // Find Old Page
  if (options.reloadCurrent) {
    $oldPage = $pagesInView.eq($pagesInView.length - 1);
    if (separateNavbar) {
      // $oldNavbarInner = $navbarsInView.eq($pagesInView.length - 1);
      $oldNavbarInner = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(app.navbar.getElByPage($oldPage));
    }
  } else if (options.reloadPrevious) {
    $oldPage = $pagesInView.eq($pagesInView.length - 2);
    if (separateNavbar) {
      // $oldNavbarInner = $navbarsInView.eq($pagesInView.length - 2);
      $oldNavbarInner = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(app.navbar.getElByPage($oldPage));
    }
  } else if (options.reloadAll) {
    $oldPage = $pagesInView.filter((index, pageEl) => pageEl !== $newPage[0]);
    if (separateNavbar) {
      $oldNavbarInner = $navbarsInView.filter((index, navbarEl) => navbarEl !== $newNavbarInner[0]);
    }
  } else {
    if ($pagesInView.length > 1) {
      let i = 0;
      for (i = 0; i < $pagesInView.length - 1; i += 1) {
        const oldNavbarInnerEl = app.navbar.getElByPage($pagesInView.eq(i));
        if (router.params.stackPages) {
          $pagesInView.eq(i).addClass('stacked');
          if (separateNavbar) {
            // $navbarsInView.eq(i).addClass('stacked');
            Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(oldNavbarInnerEl).addClass('stacked');
          }
        } else {
          // Page remove event
          router.pageCallback('beforeRemove', $pagesInView[i], $navbarsInView && $navbarsInView[i], 'previous', undefined, options);
          router.removePage($pagesInView[i]);
          if (separateNavbar && oldNavbarInnerEl) {
            router.removeNavbar(oldNavbarInnerEl);
          }
        }
      }
    }
    $oldPage = $viewEl
      .children('.page:not(.stacked)')
      .filter((index, page) => page !== $newPage[0]);
    if (separateNavbar) {
      $oldNavbarInner = $navbarEl
        .children('.navbar-inner:not(.stacked)')
        .filter((index, navbarInner) => navbarInner !== $newNavbarInner[0]);
    }
  }
  if (dynamicNavbar && !separateNavbar) {
    $oldNavbarInner = $oldPage.children('.navbar').children('.navbar-inner');
  }

  // Push State
  if (router.params.pushState && (options.pushState || options.replaceState) && !options.reloadPrevious) {
    const pushStateRoot = router.params.pushStateRoot || '';
    History[options.reloadCurrent || options.reloadAll || options.replaceState ? 'replace' : 'push'](
      view.id,
      {
        url: options.route.url,
      },
      pushStateRoot + router.params.pushStateSeparator + options.route.url
    );
  }

  if (!options.reloadPrevious) {
    // Current Page & Navbar
    router.currentPageEl = $newPage[0];
    if (dynamicNavbar && $newNavbarInner.length) {
      router.currentNavbarEl = $newNavbarInner[0];
    } else {
      delete router.currentNavbarEl;
    }

    // Current Route
    router.currentRoute = options.route;
  }

  // Update router history
  const url = options.route.url;

  if (options.history) {
    if ((options.reloadCurrent && router.history.length) > 0 || options.replaceState) {
      router.history[router.history.length - (options.reloadPrevious ? 2 : 1)] = url;
    } else if (options.reloadPrevious) {
      router.history[router.history.length - 2] = url;
    } else if (options.reloadAll) {
      router.history = [url];
    } else {
      router.history.push(url);
    }
  }
  router.saveHistory();

  // Insert new page and navbar
  const newPageInDom = $newPage.parents(__WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */]).length > 0;
  const f7Component = $newPage[0].f7Component;
  if (options.reloadPrevious) {
    if (f7Component && !newPageInDom) {
      f7Component.$mount((componentEl) => {
        Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(componentEl).insertBefore($oldPage);
      });
    } else {
      $newPage.insertBefore($oldPage);
    }
    if (separateNavbar && $newNavbarInner.length) {
      if ($oldNavbarInner.length) {
        $newNavbarInner.insertBefore($oldNavbarInner);
      } else {
        if (!router.$navbarEl.parents(__WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */]).length) {
          router.$el.prepend(router.$navbarEl);
        }
        $navbarEl.append($newNavbarInner);
      }
    }
  } else {
    if ($oldPage.next('.page')[0] !== $newPage[0]) {
      if (f7Component && !newPageInDom) {
        f7Component.$mount((componentEl) => {
          $viewEl.append(componentEl);
        });
      } else {
        $viewEl.append($newPage[0]);
      }
    }
    if (separateNavbar && $newNavbarInner.length) {
      if (!router.$navbarEl.parents(__WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */]).length) {
        router.$el.prepend(router.$navbarEl);
      }
      $navbarEl.append($newNavbarInner[0]);
    }
  }
  if (!newPageInDom) {
    router.pageCallback('mounted', $newPage, $newNavbarInner, newPagePosition, reload ? newPagePosition : 'current', options, $oldPage);
  }

  // Remove old page
  if (options.reloadCurrent && $oldPage.length > 0) {
    if (router.params.stackPages && router.initialPages.indexOf($oldPage[0]) >= 0) {
      $oldPage.addClass('stacked');
      if (separateNavbar) {
        $oldNavbarInner.addClass('stacked');
      }
    } else {
      // Page remove event
      router.pageCallback('beforeRemove', $oldPage, $oldNavbarInner, 'previous', undefined, options);
      router.removePage($oldPage);
      if (separateNavbar && $oldNavbarInner && $oldNavbarInner.length) {
        router.removeNavbar($oldNavbarInner);
      }
    }
  } else if (options.reloadAll) {
    $oldPage.each((index, pageEl) => {
      const $oldPageEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(pageEl);
      const $oldNavbarInnerEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(app.navbar.getElByPage($oldPageEl));
      if (router.params.stackPages && router.initialPages.indexOf($oldPageEl[0]) >= 0) {
        $oldPageEl.addClass('stacked');
        if (separateNavbar) {
          $oldNavbarInnerEl.addClass('stacked');
        }
      } else {
        // Page remove event
        router.pageCallback('beforeRemove', $oldPageEl, $oldNavbarInner && $oldNavbarInner.eq(index), 'previous', undefined, options);
        router.removePage($oldPageEl);
        if (separateNavbar && $oldNavbarInnerEl.length) {
          router.removeNavbar($oldNavbarInnerEl);
        }
      }
    });
  } else if (options.reloadPrevious) {
    if (router.params.stackPages && router.initialPages.indexOf($oldPage[0]) >= 0) {
      $oldPage.addClass('stacked');
      if (separateNavbar) {
        $oldNavbarInner.addClass('stacked');
      }
    } else {
      // Page remove event
      router.pageCallback('beforeRemove', $oldPage, $oldNavbarInner, 'previous', undefined, options);
      router.removePage($oldPage);
      if (separateNavbar && $oldNavbarInner && $oldNavbarInner.length) {
        router.removeNavbar($oldNavbarInner);
      }
    }
  }

  // Load Tab
  if (options.route.route.tab) {
    router.tabLoad(options.route.route.tab, Utils.extend({}, options, {
      history: false,
      pushState: false,
    }));
  }

  // Page init and before init events
  router.pageCallback('init', $newPage, $newNavbarInner, newPagePosition, reload ? newPagePosition : 'current', options, $oldPage);

  if (options.reloadCurrent || options.reloadAll) {
    router.allowPageChange = true;
    router.pageCallback('beforeIn', $newPage, $newNavbarInner, newPagePosition, 'current', options);
    router.pageCallback('afterIn', $newPage, $newNavbarInner, newPagePosition, 'current', options);
    if (options.reloadCurrent && options.clearPreviousHistory) router.clearPreviousHistory();
    return router;
  }
  if (options.reloadPrevious) {
    router.allowPageChange = true;
    return router;
  }

  // Before animation event
  router.pageCallback('beforeIn', $newPage, $newNavbarInner, 'next', 'current', options);
  router.pageCallback('beforeOut', $oldPage, $oldNavbarInner, 'current', 'previous', options);

  // Animation
  function afterAnimation() {
    const pageClasses = 'page-previous page-current page-next';
    const navbarClasses = 'navbar-previous navbar-current navbar-next';
    $newPage.removeClass(pageClasses).addClass('page-current').removeAttr('aria-hidden');
    $oldPage.removeClass(pageClasses).addClass('page-previous').attr('aria-hidden', 'true');
    if (dynamicNavbar) {
      $newNavbarInner.removeClass(navbarClasses).addClass('navbar-current').removeAttr('aria-hidden');
      $oldNavbarInner.removeClass(navbarClasses).addClass('navbar-previous').attr('aria-hidden', 'true');
    }
    // After animation event
    router.allowPageChange = true;
    router.pageCallback('afterIn', $newPage, $newNavbarInner, 'next', 'current', options);
    router.pageCallback('afterOut', $oldPage, $oldNavbarInner, 'current', 'previous', options);

    let keepOldPage = app.theme === 'ios' ? (router.params.preloadPreviousPage || router.params.iosSwipeBack) : router.params.preloadPreviousPage;
    if (!keepOldPage) {
      if ($newPage.hasClass('smart-select-page') || $newPage.hasClass('photo-browser-page') || $newPage.hasClass('autocomplete-page')) {
        keepOldPage = true;
      }
    }
    if (!keepOldPage) {
      if (router.params.stackPages) {
        $oldPage.addClass('stacked');
        if (separateNavbar) {
          $oldNavbarInner.addClass('stacked');
        }
      } else if (!($newPage.attr('data-name') && $newPage.attr('data-name') === 'smart-select-page')) {
        // Remove event
        router.pageCallback('beforeRemove', $oldPage, $oldNavbarInner, 'previous', undefined, options);
        router.removePage($oldPage);
        if (separateNavbar && $oldNavbarInner.length) {
          router.removeNavbar($oldNavbarInner);
        }
      }
    }
    if (options.clearPreviousHistory) router.clearPreviousHistory();
    router.emit('routeChanged', router.currentRoute, router.previousRoute, router);

    if (router.params.pushState) {
      History.clearRouterQueue();
    }
  }
  function setPositionClasses() {
    const pageClasses = 'page-previous page-current page-next';
    const navbarClasses = 'navbar-previous navbar-current navbar-next';
    $oldPage.removeClass(pageClasses).addClass('page-current').removeAttr('aria-hidden');
    $newPage.removeClass(pageClasses).addClass('page-next').removeAttr('aria-hidden');
    if (dynamicNavbar) {
      $oldNavbarInner.removeClass(navbarClasses).addClass('navbar-current').removeAttr('aria-hidden');
      $newNavbarInner.removeClass(navbarClasses).addClass('navbar-next').removeAttr('aria-hidden');
    }
  }
  if (options.animate) {
    const delay = router.app.theme === 'md' ? router.params.materialPageLoadDelay : router.params.iosPageLoadDelay;
    if (delay) {
      setTimeout(() => {
        setPositionClasses();
        router.animate($oldPage, $newPage, $oldNavbarInner, $newNavbarInner, 'forward', () => {
          afterAnimation();
        });
      }, delay);
    } else {
      setPositionClasses();
      router.animate($oldPage, $newPage, $oldNavbarInner, $newNavbarInner, 'forward', () => {
        afterAnimation();
      });
    }
  } else {
    afterAnimation();
  }
  return router;
}
function load(loadParams = {}, loadOptions = {}, ignorePageChange) {
  const router = this;
  if (!router.allowPageChange && !ignorePageChange) return router;
  const params = loadParams;
  const options = loadOptions;
  const { url, content, el, pageName, template, templateUrl, component, componentUrl } = params;

  if (!options.reloadCurrent &&
    options.route &&
    options.route.route &&
    options.route.route.parentPath &&
    router.currentRoute.route &&
    router.currentRoute.route.parentPath === options.route.route.parentPath) {
    // Do something nested
    if (options.route.url === router.url) {
      return false;
    }
    // Check for same params
    let sameParams = Object.keys(options.route.params).length === Object.keys(router.currentRoute.params).length;
    if (sameParams) {
      // Check for equal params name
      Object.keys(options.route.params).forEach((paramName) => {
        if (
          !(paramName in router.currentRoute.params) ||
          (router.currentRoute.params[paramName] !== options.route.params[paramName])
        ) {
          sameParams = false;
        }
      });
    }
    if (sameParams) {
      if (options.route.route.tab) {
        return router.tabLoad(options.route.route.tab, options);
      }
      return false;
    }
  }

  if (
    options.route &&
    options.route.url &&
    router.url === options.route.url &&
    !(options.reloadCurrent || options.reloadPrevious) &&
    !router.params.allowDuplicateUrls
  ) {
    router.allowPageChange = true;
    return false;
  }

  if (!options.route && url) {
    options.route = router.parseRouteUrl(url);
    Utils.extend(options.route, { route: { url, path: url } });
  }

  // Component Callbacks
  function resolve(pageEl, newOptions) {
    return router.forward(pageEl, Utils.extend(options, newOptions));
  }
  function reject() {
    router.allowPageChange = true;
    return router;
  }

  if (url || templateUrl || componentUrl) {
    router.allowPageChange = false;
  }

  // Proceed
  if (content) {
    router.forward(router.getPageEl(content), options);
  } else if (template || templateUrl) {
    // Parse template and send page element
    try {
      router.pageTemplateLoader(template, templateUrl, options, resolve, reject);
    } catch (err) {
      router.allowPageChange = true;
      throw err;
    }
  } else if (el) {
    // Load page from specified HTMLElement or by page name in pages container
    router.forward(router.getPageEl(el), options);
  } else if (pageName) {
    // Load page by page name in pages container
    router.forward(router.$el.children(`.page[data-name="${pageName}"]`).eq(0), options);
  } else if (component || componentUrl) {
    // Load from component (F7/Vue/React/...)
    try {
      router.pageComponentLoader(router.el, component, componentUrl, options, resolve, reject);
    } catch (err) {
      router.allowPageChange = true;
      throw err;
    }
  } else if (url) {
    // Load using XHR
    if (router.xhr) {
      router.xhr.abort();
      router.xhr = false;
    }
    router.xhrRequest(url, options)
      .then((pageContent) => {
        router.forward(router.getPageEl(pageContent), options);
      })
      .catch(() => {
        router.allowPageChange = true;
      });
  }
  return router;
}
function navigate(navigateParams, navigateOptions = {}) {
  const router = this;
  let url;
  let createRoute;
  if (typeof navigateParams === 'string') {
    url = navigateParams;
  } else {
    url = navigateParams.url;
    createRoute = navigateParams.route;
  }
  const app = router.app;
  if (!router.view) {
    if (app.views.main) {
      app.views.main.router.navigate(url, navigateOptions);
    }
    return router;
  }
  if (url === '#' || url === '') {
    return router;
  }

  let navigateUrl = url.replace('./', '');
  if (navigateUrl[0] !== '/' && navigateUrl.indexOf('#') !== 0) {
    const currentPath = router.currentRoute.parentPath || router.currentRoute.path;
    navigateUrl = ((currentPath ? `${currentPath}/` : '/') + navigateUrl)
      .replace('///', '/')
      .replace('//', '/');
  }
  let route;
  if (createRoute) {
    route = Utils.extend(router.parseRouteUrl(navigateUrl), {
      route: Utils.extend({}, createRoute),
    });
  } else {
    route = router.findMatchingRoute(navigateUrl);
  }

  if (!route) {
    return router;
  }

  if (route.route.redirect) {
    return redirect.call(router, 'navigate', route, navigateOptions);
  }

  const options = {};
  if (route.route.options) {
    Utils.extend(options, route.route.options, navigateOptions, { route });
  } else {
    Utils.extend(options, navigateOptions, { route });
  }
  if (options && options.context) {
    route.context = options.context;
    options.route.context = options.context;
  }
  ('popup popover sheet loginScreen actions customModal').split(' ').forEach((modalLoadProp) => {
    if (route.route[modalLoadProp]) {
      router.modalLoad(modalLoadProp, route, options);
    }
  });
  ('url content component pageName el componentUrl template templateUrl').split(' ').forEach((pageLoadProp) => {
    if (route.route[pageLoadProp]) {
      router.load({ [pageLoadProp]: route.route[pageLoadProp] }, options);
    }
  });
  // Async
  function asyncResolve(resolveParams, resolveOptions) {
    router.allowPageChange = false;
    let resolvedAsModal = false;
    if (resolveOptions && resolveOptions.context) {
      if (!route.context) route.context = resolveOptions.context;
      else route.context = Utils.extend({}, route.context, resolveOptions.context);
      options.route.context = route.context;
    }
    ('popup popover sheet loginScreen actions customModal').split(' ').forEach((modalLoadProp) => {
      if (resolveParams[modalLoadProp]) {
        resolvedAsModal = true;
        const modalRoute = Utils.extend({}, route, { route: resolveParams });
        router.allowPageChange = true;
        router.modalLoad(modalLoadProp, modalRoute, Utils.extend(options, resolveOptions));
      }
    });
    if (resolvedAsModal) return;
    router.load(resolveParams, Utils.extend(options, resolveOptions), true);
  }
  function asyncReject() {
    router.allowPageChange = true;
  }
  if (route.route.async) {
    router.allowPageChange = false;

    route.route.async.call(router, route, router.currentRoute, asyncResolve, asyncReject);
  }
  // Return Router
  return router;
}

function tabLoad(tabRoute, loadOptions = {}) {
  const router = this;
  const options = Utils.extend({
    animate: router.params.animate,
    pushState: true,
    history: true,
    parentPageEl: null,
    preload: false,
    on: {},
  }, loadOptions);

  let currentRoute;
  let previousRoute;
  if (options.route) {
    // Set Route
    if (!options.preload && options.route !== router.currentRoute) {
      previousRoute = router.previousRoute;
      router.currentRoute = options.route;
    }
    if (options.preload) {
      currentRoute = options.route;
      previousRoute = router.currentRoute;
    } else {
      currentRoute = router.currentRoute;
      if (!previousRoute) previousRoute = router.previousRoute;
    }

    // Update Browser History
    if (router.params.pushState && options.pushState && !options.reloadPrevious) {
      History.replace(
        router.view.id,
        {
          url: options.route.url,
        },
        (router.params.pushStateRoot || '') + router.params.pushStateSeparator + options.route.url
      );
    }

    // Update Router History
    if (options.history) {
      router.history[Math.max(router.history.length - 1, 0)] = options.route.url;
      router.saveHistory();
    }
  }

  // Show Tab
  const $parentPageEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(options.parentPageEl || router.currentPageEl);
  let tabEl;
  if ($parentPageEl.length && $parentPageEl.find(`#${tabRoute.id}`).length) {
    tabEl = $parentPageEl.find(`#${tabRoute.id}`).eq(0);
  } else if (router.view.selector) {
    tabEl = `${router.view.selector} #${tabRoute.id}`;
  } else {
    tabEl = `#${tabRoute.id}`;
  }
  const tabShowResult = router.app.tab.show({
    tabEl,
    animate: options.animate,
    tabRoute: options.route,
  });

  const { $newTabEl, $oldTabEl, animated, onTabsChanged } = tabShowResult;

  if ($newTabEl && $newTabEl.parents('.page').length > 0 && options.route) {
    const tabParentPageData = $newTabEl.parents('.page')[0].f7Page;
    if (tabParentPageData && options.route) {
      tabParentPageData.route = options.route;
    }
  }

  // Tab Content Loaded
  function onTabLoaded(contentEl) {
    // Remove theme elements
    router.removeThemeElements($newTabEl);

    let tabEventTarget = $newTabEl;
    if (typeof contentEl !== 'string') tabEventTarget = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(contentEl);

    tabEventTarget.trigger('tab:init tab:mounted', tabRoute);
    router.emit('tabInit tabMounted', $newTabEl[0], tabRoute);

    if ($oldTabEl && router.params.unloadTabContent) {
      if (animated) {
        onTabsChanged(() => {
          router.tabRemove($oldTabEl, $newTabEl, tabRoute);
        });
      } else {
        router.tabRemove($oldTabEl, $newTabEl, tabRoute);
      }
    }
  }
  if (!router.params.unloadTabContent) {
    if ($newTabEl[0].f7RouterTabLoaded) return router;
  }

  // Load Tab Content
  function loadTab(loadTabParams, loadTabOptions) {
    // Load Tab Props
    const { url, content, el, template, templateUrl, component, componentUrl } = loadTabParams;
    // Component/Template Callbacks
    function resolve(contentEl) {
      router.allowPageChange = true;
      if (!contentEl) return;
      if (typeof contentEl === 'string') {
        $newTabEl.html(contentEl);
      } else {
        $newTabEl.html('');
        if (contentEl.f7Component) {
          contentEl.f7Component.$mount((componentEl) => {
            $newTabEl.append(componentEl);
          });
        } else {
          $newTabEl.append(contentEl);
        }
      }
      if (!router.params.unloadTabContent) {
        $newTabEl[0].f7RouterTabLoaded = true;
      }
      onTabLoaded(contentEl);
    }
    function reject() {
      router.allowPageChange = true;
      return router;
    }

    if (content) {
      resolve(content);
    } else if (template || templateUrl) {
      try {
        router.tabTemplateLoader(template, templateUrl, loadTabOptions, resolve, reject);
      } catch (err) {
        router.allowPageChange = true;
        throw err;
      }
    } else if (el) {
      resolve(el);
    } else if (component || componentUrl) {
      // Load from component (F7/Vue/React/...)
      try {
        router.tabComponentLoader($newTabEl[0], component, componentUrl, loadTabOptions, resolve, reject);
      } catch (err) {
        router.allowPageChange = true;
        throw err;
      }
    } else if (url) {
      // Load using XHR
      if (router.xhr) {
        router.xhr.abort();
        router.xhr = false;
      }
      router.xhrRequest(url, loadTabOptions)
        .then((tabContent) => {
          resolve(tabContent);
        })
        .catch(() => {
          router.allowPageChange = true;
        });
    }
  }

  ('url content component el componentUrl template templateUrl').split(' ').forEach((tabLoadProp) => {
    if (tabRoute[tabLoadProp]) {
      loadTab({ [tabLoadProp]: tabRoute[tabLoadProp] }, options);
    }
  });

  // Async
  function asyncResolve(resolveParams, resolveOptions) {
    loadTab(resolveParams, Utils.extend(options, resolveOptions));
  }
  function asyncReject() {
    router.allowPageChange = true;
  }
  if (tabRoute.async) {
    tabRoute.async.call(router, currentRoute, previousRoute, asyncResolve, asyncReject);
  }
  return router;
}
function tabRemove($oldTabEl, $newTabEl, tabRoute) {
  const router = this;
  let hasTabComponentChild;
  $oldTabEl.children().each((index, tabChild) => {
    if (tabChild.f7Component) {
      hasTabComponentChild = true;
      Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(tabChild).trigger('tab:beforeremove', tabRoute);
      tabChild.f7Component.$destroy();
    }
  });
  if (!hasTabComponentChild) {
    $oldTabEl.trigger('tab:beforeremove', tabRoute);
  }
  router.emit('tabBeforeRemove', $oldTabEl[0], $newTabEl[0], tabRoute);
  router.removeTabContent($oldTabEl[0], tabRoute);
}

function modalLoad(modalType, route, loadOptions = {}) {
  const router = this;
  const app = router.app;

  const options = Utils.extend({
    animate: router.params.animate,
    pushState: true,
    history: true,
    on: {},
  }, loadOptions);

  const modalParams = Utils.extend({}, route.route[modalType]);
  const modalRoute = route.route;

  function onModalLoaded() {
    // Create Modal
    const modal = app[modalType].create(modalParams);
    modalRoute.modalInstance = modal;

    function closeOnSwipeBack() {
      modal.close();
    }
    modal.on('modalOpen', () => {
      router.once('swipeBackMove', closeOnSwipeBack);
    });
    modal.on('modalClose', () => {
      router.off('swipeBackMove', closeOnSwipeBack);
      if (!modal.closeByRouter) {
        router.back();
      }
    });

    modal.on('modalClosed', () => {
      modal.$el.trigger(`${modalType.toLowerCase()}:beforeremove`, route, modal);
      modal.emit(`modalBeforeRemove ${modalType}BeforeRemove`, modal.el, route, modal);
      const modalComponent = modal.el.f7Component;
      if (modalComponent) {
        modalComponent.$destroy();
      }
      Utils.nextTick(() => {
        if (modalComponent) {
          router.removeModal(modal.el);
        }
        modal.destroy();
        delete modalRoute.modalInstance;
      });
    });

    if (options.route) {
      // Update Browser History
      if (router.params.pushState && options.pushState) {
        History.push(
          router.view.id,
          {
            url: options.route.url,
            modal: modalType,
          },
          (router.params.pushStateRoot || '') + router.params.pushStateSeparator + options.route.url
        );
      }

      // Set Route
      if (options.route !== router.currentRoute) {
        router.currentRoute = Utils.extend(options.route, { modal });
      }

      // Update Router History
      if (options.history) {
        router.history.push(options.route.url);
        router.saveHistory();
      }
    }

    // Remove theme elements
    router.removeThemeElements(modal.el);

    // Emit events
    modal.$el.trigger(`${modalType.toLowerCase()}:init ${modalType.toLowerCase()}:mounted`, route, modal);
    router.emit(`modalInit ${modalType}Init ${modalType}Mounted`, modal.el, route, modal);
    // Open
    modal.open();
  }

  // Load Modal Content
  function loadModal(loadModalParams, loadModalOptions) {
    // Load Modal Props
    const { url, content, template, templateUrl, component, componentUrl } = loadModalParams;

    // Component/Template Callbacks
    function resolve(contentEl) {
      if (contentEl) {
        if (typeof contentEl === 'string') {
          modalParams.content = contentEl;
        } else if (contentEl.f7Component) {
          contentEl.f7Component.$mount((componentEl) => {
            modalParams.el = componentEl;
            app.root.append(componentEl);
          });
        } else {
          modalParams.el = contentEl;
        }
        onModalLoaded();
      }
    }
    function reject() {
      router.allowPageChange = true;
      return router;
    }

    if (content) {
      resolve(content);
    } else if (template || templateUrl) {
      try {
        router.modalTemplateLoader(template, templateUrl, loadModalOptions, resolve, reject);
      } catch (err) {
        router.allowPageChange = true;
        throw err;
      }
    } else if (component || componentUrl) {
      // Load from component (F7/Vue/React/...)
      try {
        router.modalComponentLoader(app.root[0], component, componentUrl, loadModalOptions, resolve, reject);
      } catch (err) {
        router.allowPageChange = true;
        throw err;
      }
    } else if (url) {
      // Load using XHR
      if (router.xhr) {
        router.xhr.abort();
        router.xhr = false;
      }
      router.xhrRequest(url, loadModalOptions)
        .then((modalContent) => {
          modalParams.content = modalContent;
          onModalLoaded();
        })
        .catch(() => {
          router.allowPageChange = true;
        });
    } else {
      onModalLoaded();
    }
  }

  ('url content component el componentUrl template templateUrl').split(' ').forEach((modalLoadProp) => {
    if (modalParams[modalLoadProp]) {
      loadModal({ [modalLoadProp]: modalParams[modalLoadProp] }, options);
    }
  });

  // Async
  function asyncResolve(resolveParams, resolveOptions) {
    loadModal(resolveParams, Utils.extend(options, resolveOptions));
  }
  function asyncReject() {
    router.allowPageChange = true;
  }
  if (modalParams.async) {
    modalParams.async.call(router, options.route, router.currentRoute, asyncResolve, asyncReject);
  }
  return router;
}
function modalRemove(modal) {
  Utils.extend(modal, { closeByRouter: true });
  modal.close();
}

function backward(el, backwardOptions) {
  const router = this;
  const app = router.app;
  const view = router.view;

  const options = Utils.extend({
    animate: router.params.animate,
    pushState: true,
  }, backwardOptions);

  const dynamicNavbar = router.dynamicNavbar;
  const separateNavbar = router.separateNavbar;

  const $newPage = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(el);
  const $oldPage = router.$el.children('.page-current');

  if ($newPage.length) {
    // Remove theme elements
    router.removeThemeElements($newPage);
  }

  let $navbarEl;
  let $newNavbarInner;
  let $oldNavbarInner;

  if (dynamicNavbar) {
    $newNavbarInner = $newPage.children('.navbar').children('.navbar-inner');
    if (separateNavbar) {
      $navbarEl = router.$navbarEl;
      if ($newNavbarInner.length > 0) {
        $newPage.children('.navbar').remove();
      }
      if ($newNavbarInner.length === 0 && $newPage[0].f7Page) {
        // Try from pageData
        $newNavbarInner = $newPage[0].f7Page.$navbarEl;
      }
      $oldNavbarInner = $navbarEl.find('.navbar-current');
    } else {
      $oldNavbarInner = $oldPage.children('.navbar').children('.navbar-inner');
    }
  }

  router.allowPageChange = false;
  if ($newPage.length === 0 || $oldPage.length === 0) {
    router.allowPageChange = true;
    return router;
  }

  // Remove theme elements
  router.removeThemeElements($newPage);

  // New Page
  $newPage
    .addClass('page-previous')
    .removeClass('stacked')
    .removeAttr('aria-hidden');

  if (dynamicNavbar && $newNavbarInner.length > 0) {
    $newNavbarInner
      .addClass('navbar-previous')
      .removeClass('stacked')
      .removeAttr('aria-hidden');
  }


  // Remove previous page in case of "forced"
  let backIndex;
  if (options.force) {
    if ($oldPage.prev('.page-previous:not(.stacked)').length > 0 || $oldPage.prev('.page-previous').length === 0) {
      if (router.history.indexOf(options.route.url) >= 0) {
        backIndex = router.history.length - router.history.indexOf(options.route.url) - 1;
        router.history = router.history.slice(0, router.history.indexOf(options.route.url) + 2);
        view.history = router.history;
      } else if (router.history[[router.history.length - 2]]) {
        router.history[router.history.length - 2] = options.route.url;
      } else {
        router.history.unshift(router.url);
      }

      if (backIndex && router.params.stackPages) {
        $oldPage.prevAll('.page-previous').each((index, pageToRemove) => {
          const $pageToRemove = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(pageToRemove);
          let $navbarToRemove;
          if (separateNavbar) {
            // $navbarToRemove = $oldNavbarInner.prevAll('.navbar-previous').eq(index);
            $navbarToRemove = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(app.navbar.getElByPage($pageToRemove));
          }
          if ($pageToRemove[0] !== $newPage[0] && $pageToRemove.index() > $newPage.index()) {
            if (router.initialPages.indexOf($pageToRemove[0]) >= 0) {
              $pageToRemove.addClass('stacked');
              if (separateNavbar) {
                $navbarToRemove.addClass('stacked');
              }
            } else {
              router.pageCallback('beforeRemove', $pageToRemove, $navbarToRemove, 'previous', undefined, options);
              router.removePage($pageToRemove);
              if (separateNavbar && $navbarToRemove.length > 0) {
                router.removeNavbar($navbarToRemove);
              }
            }
          }
        });
      } else {
        const $pageToRemove = $oldPage.prev('.page-previous:not(.stacked)');
        let $navbarToRemove;
        if (separateNavbar) {
          // $navbarToRemove = $oldNavbarInner.prev('.navbar-inner:not(.stacked)');
          $navbarToRemove = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(app.navbar.getElByPage($pageToRemove));
        }
        if (router.params.stackPages && router.initialPages.indexOf($pageToRemove[0]) >= 0) {
          $pageToRemove.addClass('stacked');
          $navbarToRemove.addClass('stacked');
        } else if ($pageToRemove.length > 0) {
          router.pageCallback('beforeRemove', $pageToRemove, $navbarToRemove, 'previous', undefined, options);
          router.removePage($pageToRemove);
          if (separateNavbar && $navbarToRemove.length) {
            router.removeNavbar($navbarToRemove);
          }
        }
      }
    }
  }

  // Insert new page
  const newPageInDom = $newPage.parents(__WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */]).length > 0;
  const f7Component = $newPage[0].f7Component;

  function insertPage() {
    if ($newPage.next($oldPage).length === 0) {
      if (!newPageInDom && f7Component) {
        f7Component.$mount((componentEl) => {
          Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(componentEl).insertBefore($oldPage);
        });
      } else {
        $newPage.insertBefore($oldPage);
      }
    }
    if (separateNavbar && $newNavbarInner.length) {
      $newNavbarInner.insertBefore($oldNavbarInner);
      if ($oldNavbarInner.length > 0) {
        $newNavbarInner.insertBefore($oldNavbarInner);
      } else {
        if (!router.$navbarEl.parents(__WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */]).length) {
          router.$el.prepend(router.$navbarEl);
        }
        $navbarEl.append($newNavbarInner);
      }
    }
    if (!newPageInDom) {
      router.pageCallback('mounted', $newPage, $newNavbarInner, 'previous', 'current', options, $oldPage);
    }
  }

  if (options.preload) {
    // Insert Page
    insertPage();
    // Tab route
    if (options.route.route.tab) {
      router.tabLoad(options.route.route.tab, Utils.extend({}, options, {
        history: false,
        pushState: false,
        preload: true,
      }));
    }
    // Page init and before init events
    router.pageCallback('init', $newPage, $newNavbarInner, 'previous', 'current', options, $oldPage);
    if ($newPage.prevAll('.page-previous:not(.stacked)').length > 0) {
      $newPage.prevAll('.page-previous:not(.stacked)').each((index, pageToRemove) => {
        const $pageToRemove = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(pageToRemove);
        let $navbarToRemove;
        if (separateNavbar) {
          // $navbarToRemove = $newNavbarInner.prevAll('.navbar-previous:not(.stacked)').eq(index);
          $navbarToRemove = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(app.navbar.getElByPage($pageToRemove));
        }
        if (router.params.stackPages && router.initialPages.indexOf(pageToRemove) >= 0) {
          $pageToRemove.addClass('stacked');
          if (separateNavbar) {
            $navbarToRemove.addClass('stacked');
          }
        } else {
          router.pageCallback('beforeRemove', $pageToRemove, $navbarToRemove, 'previous', undefined);
          router.removePage($pageToRemove);
          if (separateNavbar && $navbarToRemove.length) {
            router.removeNavbar($navbarToRemove);
          }
        }
      });
    }
    router.allowPageChange = true;
    return router;
  }

  // History State
  if (router.params.pushState && options.pushState) {
    if (backIndex) History.go(-backIndex);
    else History.back();
  }

  // Update History
  if (router.history.length === 1) {
    router.history.unshift(router.url);
  }
  router.history.pop();
  router.saveHistory();

  // Current Page & Navbar
  router.currentPageEl = $newPage[0];
  if (dynamicNavbar && $newNavbarInner.length) {
    router.currentNavbarEl = $newNavbarInner[0];
  } else {
    delete router.currentNavbarEl;
  }

  // Current Route
  router.currentRoute = options.route;

  // Insert Page
  insertPage();

  // Load Tab
  if (options.route.route.tab) {
    router.tabLoad(options.route.route.tab, Utils.extend({}, options, {
      history: false,
      pushState: false,
    }));
  }

  // Page init and before init events
  router.pageCallback('init', $newPage, $newNavbarInner, 'previous', 'current', options, $oldPage);

  // Before animation callback
  router.pageCallback('beforeIn', $newPage, $newNavbarInner, 'previous', 'current', options);
  router.pageCallback('beforeOut', $oldPage, $oldNavbarInner, 'current', 'next', options);

  // Animation
  function afterAnimation() {
    // Set classes
    const pageClasses = 'page-previous page-current page-next';
    const navbarClasses = 'navbar-previous navbar-current navbar-next';
    $newPage.removeClass(pageClasses).addClass('page-current').removeAttr('aria-hidden');
    $oldPage.removeClass(pageClasses).addClass('page-next').attr('aria-hidden', 'true');
    if (dynamicNavbar) {
      $newNavbarInner.removeClass(navbarClasses).addClass('navbar-current').removeAttr('aria-hidden');
      $oldNavbarInner.removeClass(navbarClasses).addClass('navbar-next').attr('aria-hidden', 'true');
    }

    // After animation event
    router.pageCallback('afterIn', $newPage, $newNavbarInner, 'previous', 'current', options);
    router.pageCallback('afterOut', $oldPage, $oldNavbarInner, 'current', 'next', options);

    // Remove Old Page
    if (router.params.stackPages && router.initialPages.indexOf($oldPage[0]) >= 0) {
      $oldPage.addClass('stacked');
      if (separateNavbar) {
        $oldNavbarInner.addClass('stacked');
      }
    } else {
      router.pageCallback('beforeRemove', $oldPage, $oldNavbarInner, 'next', undefined, options);
      router.removePage($oldPage);
      if (separateNavbar && $oldNavbarInner.length) {
        router.removeNavbar($oldNavbarInner);
      }
    }

    router.allowPageChange = true;
    router.emit('routeChanged', router.currentRoute, router.previousRoute, router);

    // Preload previous page
    const preloadPreviousPage = app.theme === 'ios' ? (router.params.preloadPreviousPage || router.params.iosSwipeBack) : router.params.preloadPreviousPage;
    if (preloadPreviousPage) {
      router.back(router.history[router.history.length - 2], { preload: true });
    }
    if (router.params.pushState) {
      History.clearRouterQueue();
    }
  }

  function setPositionClasses() {
    const pageClasses = 'page-previous page-current page-next';
    const navbarClasses = 'navbar-previous navbar-current navbar-next';
    $oldPage.removeClass(pageClasses).addClass('page-current');
    $newPage.removeClass(pageClasses).addClass('page-previous').removeAttr('aria-hidden');
    if (dynamicNavbar) {
      $oldNavbarInner.removeClass(navbarClasses).addClass('navbar-current');
      $newNavbarInner.removeClass(navbarClasses).addClass('navbar-previous').removeAttr('aria-hidden');
    }
  }

  if (options.animate) {
    setPositionClasses();
    router.animate($oldPage, $newPage, $oldNavbarInner, $newNavbarInner, 'backward', () => {
      afterAnimation();
    });
  } else {
    afterAnimation();
  }

  return router;
}
function loadBack(backParams, backOptions, ignorePageChange) {
  const router = this;

  if (!router.allowPageChange && !ignorePageChange) return router;
  const params = backParams;
  const options = backOptions;
  const { url, content, el, pageName, template, templateUrl, component, componentUrl } = params;

  if (
    options.route.url &&
    router.url === options.route.url &&
    !(options.reloadCurrent || options.reloadPrevious) &&
    !router.params.allowDuplicateUrls
  ) {
    return false;
  }

  if (!options.route && url) {
    options.route = router.parseRouteUrl(url);
  }

  // Component Callbacks
  function resolve(pageEl, newOptions) {
    return router.backward(pageEl, Utils.extend(options, newOptions));
  }
  function reject() {
    router.allowPageChange = true;
    return router;
  }

  if (url || templateUrl || componentUrl) {
    router.allowPageChange = false;
  }

  // Proceed
  if (content) {
    router.backward(router.getPageEl(content), options);
  } else if (template || templateUrl) {
    // Parse template and send page element
    try {
      router.pageTemplateLoader(template, templateUrl, options, resolve, reject);
    } catch (err) {
      router.allowPageChange = true;
      throw err;
    }
  } else if (el) {
    // Load page from specified HTMLElement or by page name in pages container
    router.backward(router.getPageEl(el), options);
  } else if (pageName) {
    // Load page by page name in pages container
    router.backward(router.$el.children(`.page[data-name="${pageName}"]`).eq(0), options);
  } else if (component || componentUrl) {
    // Load from component (F7/Vue/React/...)
    try {
      router.pageComponentLoader(router.el, component, componentUrl, options, resolve, reject);
    } catch (err) {
      router.allowPageChange = true;
      throw err;
    }
  } else if (url) {
    // Load using XHR
    if (router.xhr) {
      router.xhr.abort();
      router.xhr = false;
    }
    router.xhrRequest(url, options)
      .then((pageContent) => {
        router.backward(router.getPageEl(pageContent), options);
      })
      .catch(() => {
        router.allowPageChange = true;
      });
  }
  return router;
}
function back(...args) {
  let navigateUrl;
  let navigateOptions;
  if (typeof args[0] === 'object') {
    navigateOptions = args[0] || {};
  } else {
    navigateUrl = args[0];
    navigateOptions = args[1] || {};
  }

  const router = this;
  const app = router.app;
  if (!router.view) {
    app.views.main.router.back(navigateUrl, navigateOptions);
    return router;
  }

  let currentRouteIsModal = router.currentRoute.modal;
  let modalType;
  if (!currentRouteIsModal) {
    ('popup popover sheet loginScreen actions customModal').split(' ').forEach((modalLoadProp) => {
      if (router.currentRoute.route[modalLoadProp]) {
        currentRouteIsModal = true;
        modalType = modalLoadProp;
      }
    });
  }
  if (currentRouteIsModal) {
    const modalToClose = router.currentRoute.modal ||
                         router.currentRoute.route.modalInstance ||
                         app[modalType].get();
    const previousUrl = router.history[router.history.length - 2];
    let previousRoute = router.findMatchingRoute(previousUrl);
    if (!previousRoute && previousUrl) {
      previousRoute = {
        url: previousUrl,
        path: previousUrl.split('?')[0],
        query: Utils.parseUrlQuery(previousUrl),
        route: {
          path: previousUrl.split('?')[0],
          url: previousUrl,
        },
      };
    }
    if (!previousRoute || !modalToClose) {
      return router;
    }
    if (router.params.pushState && navigateOptions.pushState !== false) {
      History.back();
    }
    router.currentRoute = previousRoute;
    router.history.pop();
    router.saveHistory();
    router.modalRemove(modalToClose);
    return router;
  }
  const $previousPage = router.$el.children('.page-current').prevAll('.page-previous').eq(0);
  if (!navigateOptions.force && $previousPage.length > 0) {
    if (router.params.pushState && $previousPage[0].f7Page && router.history[router.history.length - 2] !== $previousPage[0].f7Page.route.url) {
      router.back(router.history[router.history.length - 2], Utils.extend(navigateOptions, { force: true }));
      return router;
    }
    router.loadBack({ el: $previousPage }, Utils.extend(navigateOptions, {
      route: $previousPage[0].f7Page.route,
    }));
    return router;
  }

  // Navigate URL
  if (navigateUrl === '#') {
    navigateUrl = undefined;
  }
  if (navigateUrl && navigateUrl[0] !== '/' && navigateUrl.indexOf('#') !== 0) {
    navigateUrl = ((router.path || '/') + navigateUrl).replace('//', '/');
  }
  if (!navigateUrl && router.history.length > 1) {
    navigateUrl = router.history[router.history.length - 2];
  }

  // Find route to load
  let route = router.findMatchingRoute(navigateUrl);
  if (!route) {
    if (navigateUrl) {
      route = {
        url: navigateUrl,
        path: navigateUrl.split('?')[0],
        query: Utils.parseUrlQuery(navigateUrl),
        route: {
          path: navigateUrl.split('?')[0],
          url: navigateUrl,
        },
      };
    }
  }
  if (!route) {
    return router;
  }

  if (route.route.redirect) {
    return redirect.call(router, 'back', route, navigateOptions);
  }

  const options = {};
  if (route.route.options) {
    Utils.extend(options, route.route.options, navigateOptions, { route });
  } else {
    Utils.extend(options, navigateOptions, { route });
  }

  if (options && options.context) {
    route.context = options.context;
    options.route.context = options.context;
  }

  if (options.force && router.params.stackPages) {
    router.$el.children('.page-previous.stacked').each((index, pageEl) => {
      if (pageEl.f7Page && pageEl.f7Page.route && pageEl.f7Page.route.url === route.url) {
        router.loadBack({ el: pageEl }, options);
      }
    });
  }

  ('url content component pageName el componentUrl template templateUrl').split(' ').forEach((pageLoadProp) => {
    if (route.route[pageLoadProp]) {
      router.loadBack({ [pageLoadProp]: route.route[pageLoadProp] }, options);
    }
  });
  // Async
  function asyncResolve(resolveParams, resolveOptions) {
    router.allowPageChange = false;
    if (resolveOptions && resolveOptions.context) {
      if (!route.context) route.context = resolveOptions.context;
      else route.context = Utils.extend({}, route.context, resolveOptions.context);
      options.route.context = route.context;
    }
    router.loadBack(resolveParams, Utils.extend(options, resolveOptions), true);
  }
  function asyncReject() {
    router.allowPageChange = true;
  }
  if (route.route.async) {
    router.allowPageChange = false;

    route.route.async.call(router, route, router.currentRoute, asyncResolve, asyncReject);
  }
  // Return Router
  return router;
}

function clearPreviousHistory() {
  const router = this;
  const app = router.app;
  const separateNavbar = router.separateNavbar;
  const url = router.history[router.history.length - 1];

  const $currentPageEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(router.currentPageEl);

  const $pagesToRemove = router.$el
    .children('.page:not(.stacked)')
    .filter((index, pageInView) => pageInView !== $currentPageEl[0]);

  $pagesToRemove.each((index, pageEl) => {
    const $oldPageEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(pageEl);
    const $oldNavbarInnerEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(app.navbar.getElByPage($oldPageEl));
    if (router.params.stackPages && router.initialPages.indexOf($oldPageEl[0]) >= 0) {
      $oldPageEl.addClass('stacked');
      if (separateNavbar) {
        $oldNavbarInnerEl.addClass('stacked');
      }
    } else {
      // Page remove event
      router.pageCallback('beforeRemove', $oldPageEl, $oldNavbarInnerEl, 'previous', undefined, {});
      router.removePage($oldPageEl);
      if (separateNavbar && $oldNavbarInnerEl.length) {
        router.removeNavbar($oldNavbarInnerEl);
      }
    }
  });

  router.history = [url];
  router.view.history = [url];
  router.saveHistory();
}

class Router extends Framework7Class {
  constructor(app, view) {
    super({}, [typeof view === 'undefined' ? app : view]);
    const router = this;

    // Is App Router
    router.isAppRouter = typeof view === 'undefined';

    if (router.isAppRouter) {
      // App Router
      Utils.extend(false, router, {
        app,
        params: app.params.view,
        routes: app.routes || [],
        cache: app.cache,
      });
    } else {
      // View Router
      Utils.extend(false, router, {
        app,
        view,
        viewId: view.id,
        params: view.params,
        routes: view.routes,
        $el: view.$el,
        el: view.el,
        $navbarEl: view.$navbarEl,
        navbarEl: view.navbarEl,
        history: view.history,
        scrollHistory: view.scrollHistory,
        cache: app.cache,
        dynamicNavbar: app.theme === 'ios' && view.params.iosDynamicNavbar,
        separateNavbar: app.theme === 'ios' && view.params.iosDynamicNavbar && view.params.iosSeparateDynamicNavbar,
        initialPages: [],
        initialNavbars: [],
      });
    }

    // Install Modules
    router.useModules();

    // Temporary Dom
    router.tempDom = __WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */].createElement('div');

    // AllowPageChage
    router.allowPageChange = true;

    // Current Route
    let currentRoute = {};
    let previousRoute = {};
    Object.defineProperty(router, 'currentRoute', {
      enumerable: true,
      configurable: true,
      set(newRoute = {}) {
        previousRoute = Utils.extend({}, currentRoute);
        currentRoute = newRoute;
        if (!currentRoute) return;
        router.url = currentRoute.url;
        router.emit('routeChange', newRoute, previousRoute, router);
      },
      get() {
        return currentRoute;
      },
    });
    Object.defineProperty(router, 'previousRoute', {
      enumerable: true,
      configurable: true,
      get() {
        return previousRoute;
      },
      set(newRoute) {
        previousRoute = newRoute;
      },
    });

    Utils.extend(router, {
      // Load
      forward,
      load,
      navigate,
      refreshPage,
      // Tab
      tabLoad,
      tabRemove,
      // Modal
      modalLoad,
      modalRemove,
      // Back
      backward,
      loadBack,
      back,
      // Clear history
      clearPreviousHistory,
    });

    return router;
  }
  animatableNavElements(newNavbarInner, oldNavbarInner) {
    const router = this;
    const dynamicNavbar = router.dynamicNavbar;
    const animateIcon = router.params.iosAnimateNavbarBackIcon;

    let newNavEls;
    let oldNavEls;
    function animatableNavEl(el, navbarInner) {
      const $el = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(el);
      const isSliding = $el.hasClass('sliding') || navbarInner.hasClass('sliding');
      const isSubnavbar = $el.hasClass('subnavbar');
      const needsOpacityTransition = isSliding ? !isSubnavbar : true;
      const hasIcon = isSliding && animateIcon && $el.hasClass('left') && $el.find('.back .icon').length > 0;
      let $iconEl;
      if (hasIcon) $iconEl = $el.find('.back .icon');
      return {
        $el,
        $iconEl,
        hasIcon,
        leftOffset: $el[0].f7NavbarLeftOffset,
        rightOffset: $el[0].f7NavbarRightOffset,
        isSliding,
        isSubnavbar,
        needsOpacityTransition,
      };
    }
    if (dynamicNavbar) {
      newNavEls = [];
      oldNavEls = [];
      newNavbarInner.children('.left, .right, .title, .subnavbar').each((index, navEl) => {
        newNavEls.push(animatableNavEl(navEl, newNavbarInner));
      });
      oldNavbarInner.children('.left, .right, .title, .subnavbar').each((index, navEl) => {
        oldNavEls.push(animatableNavEl(navEl, oldNavbarInner));
      });
      [oldNavEls, newNavEls].forEach((navEls) => {
        navEls.forEach((navEl) => {
          const n = navEl;
          const { isSliding, $el } = navEl;
          const otherEls = navEls === oldNavEls ? newNavEls : oldNavEls;
          if (!(isSliding && $el.hasClass('title') && otherEls)) return;
          otherEls.forEach((otherNavEl) => {
            if (otherNavEl.$el.hasClass('left') && otherNavEl.hasIcon) {
              const iconTextEl = otherNavEl.$el.find('.back span')[0];
              n.leftOffset += iconTextEl ? iconTextEl.offsetLeft : 0;
            }
          });
        });
      });
    }

    return { newNavEls, oldNavEls };
  }
  animateWithCSS(oldPage, newPage, oldNavbarInner, newNavbarInner, direction, callback) {
    const router = this;
    const dynamicNavbar = router.dynamicNavbar;
    const separateNavbar = router.separateNavbar;
    const ios = router.app.theme === 'ios';
    // Router Animation class
    const routerTransitionClass = `router-transition-${direction} router-transition-css-${direction}`;

    let newNavEls;
    let oldNavEls;
    let navbarWidth = 0;

    if (ios && dynamicNavbar) {
      if (!separateNavbar) {
        navbarWidth = newNavbarInner[0].offsetWidth;
      }
      const navEls = router.animatableNavElements(newNavbarInner, oldNavbarInner);
      newNavEls = navEls.newNavEls;
      oldNavEls = navEls.oldNavEls;
    }

    function animateNavbars(progress) {
      if (ios && dynamicNavbar) {
        newNavEls.forEach((navEl) => {
          const $el = navEl.$el;
          const offset = direction === 'forward' ? navEl.rightOffset : navEl.leftOffset;
          if (navEl.isSliding) {
            $el.transform(`translate3d(${offset * (1 - progress)}px,0,0)`);
          }
          if (navEl.hasIcon) {
            if (direction === 'forward') {
              navEl.$iconEl.transform(`translate3d(${(-offset - navbarWidth) * (1 - progress)}px,0,0)`);
            } else {
              navEl.$iconEl.transform(`translate3d(${(-offset + (navbarWidth / 5)) * (1 - progress)}px,0,0)`);
            }
          }
        });
        oldNavEls.forEach((navEl) => {
          const $el = navEl.$el;
          const offset = direction === 'forward' ? navEl.leftOffset : navEl.rightOffset;
          if (navEl.isSliding) {
            $el.transform(`translate3d(${offset * (progress)}px,0,0)`);
          }
          if (navEl.hasIcon) {
            if (direction === 'forward') {
              navEl.$iconEl.transform(`translate3d(${(-offset + (navbarWidth / 5)) * (progress)}px,0,0)`);
            } else {
              navEl.$iconEl.transform(`translate3d(${(-offset - navbarWidth) * (progress)}px,0,0)`);
            }
          }
        });
      }
    }

    // AnimationEnd Callback
    function onDone() {
      if (router.dynamicNavbar) {
        if (newNavbarInner.hasClass('sliding')) {
          newNavbarInner.find('.title, .left, .right, .left .icon, .subnavbar').transform('');
        } else {
          newNavbarInner.find('.sliding').transform('');
        }
        if (oldNavbarInner.hasClass('sliding')) {
          oldNavbarInner.find('.title, .left, .right, .left .icon, .subnavbar').transform('');
        } else {
          oldNavbarInner.find('.sliding').transform('');
        }
      }
      router.$el.removeClass(routerTransitionClass);
      if (callback) callback();
    }

    (direction === 'forward' ? newPage : oldPage).animationEnd(() => {
      onDone();
    });

    // Animate
    if (dynamicNavbar) {
      // Prepare Navbars
      animateNavbars(0);
      Utils.nextTick(() => {
        // Add class, start animation
        animateNavbars(1);
        router.$el.addClass(routerTransitionClass);
      });
    } else {
      // Add class, start animation
      router.$el.addClass(routerTransitionClass);
    }
  }
  animateWithJS(oldPage, newPage, oldNavbarInner, newNavbarInner, direction, callback) {
    const router = this;
    const dynamicNavbar = router.dynamicNavbar;
    const separateNavbar = router.separateNavbar;
    const ios = router.app.theme === 'ios';
    const duration = ios ? 400 : 250;
    const routerTransitionClass = `router-transition-${direction} router-transition-js-${direction}`;

    let startTime = null;
    let done = false;

    let newNavEls;
    let oldNavEls;
    let navbarWidth = 0;

    if (ios && dynamicNavbar) {
      if (!separateNavbar) {
        navbarWidth = newNavbarInner[0].offsetWidth;
      }
      const navEls = router.animatableNavElements(newNavbarInner, oldNavbarInner);
      newNavEls = navEls.newNavEls;
      oldNavEls = navEls.oldNavEls;
    }

    let $shadowEl;
    let $opacityEl;

    if (ios) {
      $shadowEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])('<div class="page-shadow-effect"></div>');
      $opacityEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])('<div class="page-opacity-effect"></div>');

      if (direction === 'forward') {
        newPage.append($shadowEl);
        oldPage.append($opacityEl);
      } else {
        newPage.append($opacityEl);
        oldPage.append($shadowEl);
      }
    }
    const easing = Utils.bezier(0.25, 0.1, 0.25, 1);

    function onDone() {
      newPage.transform('').css('opacity', '');
      oldPage.transform('').css('opacity', '');
      if (ios) {
        $shadowEl.remove();
        $opacityEl.remove();
        if (dynamicNavbar) {
          newNavEls.forEach((navEl) => {
            navEl.$el.transform('');
            navEl.$el.css('opacity', '');
          });
          oldNavEls.forEach((navEl) => {
            navEl.$el.transform('');
            navEl.$el.css('opacity', '');
          });
          newNavEls = [];
          oldNavEls = [];
        }
      }

      router.$el.removeClass(routerTransitionClass);

      if (callback) callback();
    }

    function render() {
      const time = Utils.now();
      if (!startTime) startTime = time;
      const progress = Math.max(Math.min((time - startTime) / duration, 1), 0);
      const easeProgress = easing(progress);

      if (progress >= 1) {
        done = true;
      }
      const inverter = router.app.rtl ? -1 : 1;
      if (ios) {
        if (direction === 'forward') {
          newPage.transform(`translate3d(${(1 - easeProgress) * 100 * inverter}%,0,0)`);
          oldPage.transform(`translate3d(${-easeProgress * 20 * inverter}%,0,0)`);
          $shadowEl[0].style.opacity = easeProgress;
          $opacityEl[0].style.opacity = easeProgress;
        } else {
          newPage.transform(`translate3d(${-(1 - easeProgress) * 20 * inverter}%,0,0)`);
          oldPage.transform(`translate3d(${easeProgress * 100 * inverter}%,0,0)`);
          $shadowEl[0].style.opacity = 1 - easeProgress;
          $opacityEl[0].style.opacity = 1 - easeProgress;
        }
        if (dynamicNavbar) {
          newNavEls.forEach((navEl) => {
            const $el = navEl.$el;
            const offset = direction === 'forward' ? navEl.rightOffset : navEl.leftOffset;
            if (navEl.needsOpacityTransition) {
              $el[0].style.opacity = easeProgress;
            }
            if (navEl.isSliding) {
              $el.transform(`translate3d(${offset * (1 - easeProgress)}px,0,0)`);
            }
            if (navEl.hasIcon) {
              if (direction === 'forward') {
                navEl.$iconEl.transform(`translate3d(${(-offset - navbarWidth) * (1 - easeProgress)}px,0,0)`);
              } else {
                navEl.$iconEl.transform(`translate3d(${(-offset + (navbarWidth / 5)) * (1 - easeProgress)}px,0,0)`);
              }
            }
          });
          oldNavEls.forEach((navEl) => {
            const $el = navEl.$el;
            const offset = direction === 'forward' ? navEl.leftOffset : navEl.rightOffset;
            if (navEl.needsOpacityTransition) {
              $el[0].style.opacity = (1 - easeProgress);
            }
            if (navEl.isSliding) {
              $el.transform(`translate3d(${offset * (easeProgress)}px,0,0)`);
            }
            if (navEl.hasIcon) {
              if (direction === 'forward') {
                navEl.$iconEl.transform(`translate3d(${(-offset + (navbarWidth / 5)) * (easeProgress)}px,0,0)`);
              } else {
                navEl.$iconEl.transform(`translate3d(${(-offset - navbarWidth) * (easeProgress)}px,0,0)`);
              }
            }
          });
        }
      } else if (direction === 'forward') {
        newPage.transform(`translate3d(0, ${(1 - easeProgress) * 56}px,0)`);
        newPage.css('opacity', easeProgress);
      } else {
        oldPage.transform(`translate3d(0, ${easeProgress * 56}px,0)`);
        oldPage.css('opacity', 1 - easeProgress);
      }

      if (done) {
        onDone();
        return;
      }
      Utils.nextFrame(render);
    }

    router.$el.addClass(routerTransitionClass);

    Utils.nextFrame(render);
  }
  animate(...args) {
    // Args: oldPage, newPage, oldNavbarInner, newNavbarInner, direction, callback
    const router = this;
    if (router.params.animateCustom) {
      router.params.animateCustom.apply(router, args);
    } else if (router.params.animateWithJS) {
      router.animateWithJS(...args);
    } else {
      router.animateWithCSS(...args);
    }
  }
  removeModal(modalEl) {
    const router = this;
    router.removeEl(modalEl);
  }
  // eslint-disable-next-line
  removeTabContent(tabEl) {
    const $tabEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(tabEl);
    $tabEl.html('');
  }
  removeNavbar(el) {
    const router = this;
    router.removeEl(el);
  }
  removePage(el) {
    const router = this;
    router.removeEl(el);
  }
  removeEl(el) {
    if (!el) return;
    const router = this;
    const $el = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(el);
    if ($el.length === 0) return;
    if ($el[0].f7Component && $el[0].f7Component.$destroy) {
      $el[0].f7Component.$destroy();
    }
    $el.find('.tab').each((tabIndex, tabEl) => {
      Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(tabEl).children().each((index, tabChild) => {
        if (tabChild.f7Component) {
          Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(tabChild).trigger('tab:beforeremove');
          tabChild.f7Component.$destroy();
        }
      });
    });
    if (!router.params.removeElements) {
      return;
    }
    if (router.params.removeElementsWithTimeout) {
      setTimeout(() => {
        $el.remove();
      }, router.params.removeElementsTimeout);
    } else {
      $el.remove();
    }
  }
  getPageEl(content) {
    const router = this;
    if (typeof content === 'string') {
      router.tempDom.innerHTML = content;
    } else {
      if (Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(content).hasClass('page')) {
        return content;
      }
      router.tempDom.innerHTML = '';
      Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(router.tempDom).append(content);
    }

    return router.findElement('.page', router.tempDom);
  }
  findElement(stringSelector, container, notStacked) {
    const router = this;
    const view = router.view;
    const app = router.app;

    // Modals Selector
    const modalsSelector = '.popup, .dialog, .popover, .actions-modal, .sheet-modal, .login-screen, .page';

    const $container = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(container);
    let selector = stringSelector;
    if (notStacked) selector += ':not(.stacked)';

    let found = $container
      .find(selector)
      .filter((index, el) => Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(el).parents(modalsSelector).length === 0);

    if (found.length > 1) {
      if (typeof view.selector === 'string') {
        // Search in related view
        found = $container.find(`${view.selector} ${selector}`);
      }
      if (found.length > 1) {
        // Search in main view
        found = $container.find(`.${app.params.viewMainClass} ${selector}`);
      }
    }
    if (found.length === 1) return found;

    // Try to find not stacked
    if (!notStacked) found = router.findElement(selector, $container, true);
    if (found && found.length === 1) return found;
    if (found && found.length > 1) return Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(found[0]);
    return undefined;
  }
  flattenRoutes(routes = this.routes) {
    let flattenedRoutes = [];
    routes.forEach((route) => {
      if ('routes' in route) {
        const mergedPathsRoutes = route.routes.map((childRoute) => {
          const cRoute = Utils.extend({}, childRoute);
          cRoute.path = (`${route.path}/${cRoute.path}`).replace('///', '/').replace('//', '/');
          return cRoute;
        });
        flattenedRoutes = flattenedRoutes.concat(route, this.flattenRoutes(mergedPathsRoutes));
      } else if ('tabs' in route && route.tabs) {
        const mergedPathsRoutes = route.tabs.map((tabRoute) => {
          const tRoute = Utils.extend({}, route, {
            path: (`${route.path}/${tabRoute.path}`).replace('///', '/').replace('//', '/'),
            parentPath: route.path,
            tab: tabRoute,
          });
          delete tRoute.tabs;
          return tRoute;
        });
        flattenedRoutes = flattenedRoutes.concat(this.flattenRoutes(mergedPathsRoutes));
      } else {
        flattenedRoutes.push(route);
      }
    });
    return flattenedRoutes;
  }
  // eslint-disable-next-line
  parseRouteUrl(url) {
    if (!url) return {};
    const query = Utils.parseUrlQuery(url);
    const hash = url.split('#')[1];
    const params = {};
    const path = url.split('#')[0].split('?')[0];
    return {
      query,
      hash,
      params,
      url,
      path,
    };
  }
  findTabRoute(tabEl) {
    const router = this;
    const $tabEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(tabEl);
    const parentPath = router.currentRoute.route.parentPath;
    const tabId = $tabEl.attr('id');
    const flattenedRoutes = router.flattenRoutes(router.routes);
    let foundTabRoute;
    flattenedRoutes.forEach((route) => {
      if (
        route.parentPath === parentPath &&
        route.tab &&
        route.tab.id === tabId
      ) {
        foundTabRoute = route;
      }
    });
    return foundTabRoute;
  }
  findRouteByKey(key, value) {
    const router = this;
    const routes = router.routes;
    const flattenedRoutes = router.flattenRoutes(routes);
    let matchingRoute;

    flattenedRoutes.forEach((route) => {
      if (matchingRoute) return;
      if (route[key] === value) {
        matchingRoute = route;
      }
    });
    return matchingRoute;
  }
  findMatchingRoute(url) {
    if (!url) return undefined;
    const router = this;
    const routes = router.routes;
    const flattenedRoutes = router.flattenRoutes(routes);
    const { path, query, hash, params } = router.parseRouteUrl(url);
    let matchingRoute;
    flattenedRoutes.forEach((route) => {
      if (matchingRoute) return;
      const keys = [];

      const pathsToMatch = [route.path];
      if (route.alias) {
        if (typeof route.alias === 'string') pathsToMatch.push(route.alias);
        else if (Array.isArray(route.alias)) {
          route.alias.forEach((aliasPath) => {
            pathsToMatch.push(aliasPath);
          });
        }
      }

      let matched;
      pathsToMatch.forEach((pathToMatch) => {
        if (matched) return;
        matched = __WEBPACK_IMPORTED_MODULE_3_path_to_regexp___default()(pathToMatch, keys).exec(path);
      });

      if (matched) {
        keys.forEach((keyObj, index) => {
          const paramValue = matched[index + 1];
          params[keyObj.name] = paramValue;
        });

        let parentPath;
        if (route.parentPath) {
          parentPath = path.split('/').slice(0, route.parentPath.split('/').length - 1).join('/');
        }

        matchingRoute = {
          query,
          hash,
          params,
          url,
          path,
          parentPath,
          route,
          name: route.name,
        };
      }
    });
    return matchingRoute;
  }
  removeFromXhrCache(url) {
    const router = this;
    const xhrCache = router.cache.xhr;
    let index = false;
    for (let i = 0; i < xhrCache.length; i += 1) {
      if (xhrCache[i].url === url) index = i;
    }
    if (index !== false) xhrCache.splice(index, 1);
  }
  xhrRequest(requestUrl, options) {
    const router = this;
    const params = router.params;
    const { ignoreCache } = options;
    let url = requestUrl;

    let hasQuery = url.indexOf('?') >= 0;
    if (params.passRouteQueryToRequest &&
      options &&
      options.route &&
      options.route.query &&
      Object.keys(options.route.query).length
    ) {
      url += `${hasQuery ? '&' : '?'}${Utils.serializeObject(options.route.query)}`;
      hasQuery = true;
    }

    if (params.passRouteParamsToRequest &&
      options &&
      options.route &&
      options.route.params &&
      Object.keys(options.route.params).length
    ) {
      url += `${hasQuery ? '&' : '?'}${Utils.serializeObject(options.route.params)}`;
      hasQuery = true;
    }

    if (url.indexOf('{{') >= 0 &&
      options &&
      options.route &&
      options.route.params &&
      Object.keys(options.route.params).length
    ) {
      Object.keys(options.route.params).forEach((paramName) => {
        const regExp = new RegExp(`{{${paramName}}}`, 'g');
        url = url.replace(regExp, options.route.params[paramName] || '');
      });
    }
    // should we ignore get params or not
    if (params.xhrCacheIgnoreGetParameters && url.indexOf('?') >= 0) {
      url = url.split('?')[0];
    }
    return Utils.promise((resolve, reject) => {
      if (params.xhrCache && !ignoreCache && url.indexOf('nocache') < 0 && params.xhrCacheIgnore.indexOf(url) < 0) {
        for (let i = 0; i < router.cache.xhr.length; i += 1) {
          const cachedUrl = router.cache.xhr[i];
          if (cachedUrl.url === url) {
            // Check expiration
            if (Utils.now() - cachedUrl.time < params.xhrCacheDuration) {
              // Load from cache
              resolve(cachedUrl.content);
              return;
            }
          }
        }
      }
      router.xhr = router.app.request({
        url,
        method: 'GET',
        beforeSend(xhr) {
          router.emit('routerAjaxStart', xhr, options);
        },
        complete(xhr, status) {
          router.emit('routerAjaxComplete', xhr);
          if ((status !== 'error' && status !== 'timeout' && (xhr.status >= 200 && xhr.status < 300)) || xhr.status === 0) {
            if (params.xhrCache && xhr.responseText !== '') {
              router.removeFromXhrCache(url);
              router.cache.xhr.push({
                url,
                time: Utils.now(),
                content: xhr.responseText,
              });
            }
            router.emit('routerAjaxSuccess', xhr, options);
            resolve(xhr.responseText);
          } else {
            router.emit('routerAjaxError', xhr, options);
            reject(xhr);
          }
        },
        error(xhr) {
          router.emit('routerAjaxError', xhr, options);
          reject(xhr);
        },
      });
    });
  }
  // Remove theme elements
  removeThemeElements(el) {
    const router = this;
    const theme = router.app.theme;
    Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(el).find(`.${theme === 'md' ? 'ios' : 'md'}-only, .if-${theme === 'md' ? 'ios' : 'md'}`).remove();
  }
  templateLoader(template, templateUrl, options, resolve, reject) {
    const router = this;
    function compile(t) {
      let compiledHtml;
      let context;
      try {
        context = options.context || {};
        if (typeof context === 'function') context = context.call(router);
        else if (typeof context === 'string') {
          try {
            context = JSON.parse(context);
          } catch (err) {
            reject();
            throw (err);
          }
        }
        if (typeof t === 'function') {
          compiledHtml = t(context);
        } else {
          compiledHtml = __WEBPACK_IMPORTED_MODULE_2_template7__["a" /* default */].compile(t)(Utils.extend({}, context || {}, {
            $app: router.app,
            $root: Utils.extend({}, router.app.data, router.app.methods),
            $route: options.route,
            $router: router,
            $theme: {
              ios: router.app.theme === 'ios',
              md: router.app.theme === 'md',
            },
          }));
        }
      } catch (err) {
        reject();
        throw (err);
      }
      resolve(compiledHtml, { context });
    }
    if (templateUrl) {
      // Load via XHR
      if (router.xhr) {
        router.xhr.abort();
        router.xhr = false;
      }
      router
        .xhrRequest(templateUrl, options)
        .then((templateContent) => {
          compile(templateContent);
        })
        .catch(() => {
          reject();
        });
    } else {
      compile(template);
    }
  }
  modalTemplateLoader(template, templateUrl, options, resolve, reject) {
    const router = this;
    return router.templateLoader(template, templateUrl, options, (html) => {
      resolve(html);
    }, reject);
  }
  tabTemplateLoader(template, templateUrl, options, resolve, reject) {
    const router = this;
    return router.templateLoader(template, templateUrl, options, (html) => {
      resolve(html);
    }, reject);
  }
  pageTemplateLoader(template, templateUrl, options, resolve, reject) {
    const router = this;
    return router.templateLoader(template, templateUrl, options, (html, newOptions = {}) => {
      resolve(router.getPageEl(html), newOptions);
    }, reject);
  }
  componentLoader(component, componentUrl, options = {}, resolve, reject) {
    const router = this;
    const url = typeof component === 'string' ? component : componentUrl;
    function compile(c) {
      let context = options.context || {};
      if (typeof context === 'function') context = context.call(router);
      else if (typeof context === 'string') {
        try {
          context = JSON.parse(context);
        } catch (err) {
          reject();
          throw (err);
        }
      }
      const extendContext = Utils.merge(
        {},
        context,
        {
          $: __WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */],
          $$: __WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */],
          $app: router.app,
          $root: Utils.merge({}, router.app.data, router.app.methods),
          $route: options.route,
          $router: router,
          $dom7: __WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */],
          $theme: {
            ios: router.app.theme === 'ios',
            md: router.app.theme === 'md',
          },
        }
      );
      const createdComponent = Component.create(c, extendContext);
      resolve(createdComponent.el);
    }
    if (url) {
      // Load via XHR
      if (router.xhr) {
        router.xhr.abort();
        router.xhr = false;
      }
      router
        .xhrRequest(url, options)
        .then((loadedComponent) => {
          compile(Component.parse(loadedComponent));
        })
        .catch((err) => {
          reject();
          throw (err);
        });
    } else {
      compile(component);
    }
  }
  modalComponentLoader(rootEl, component, componentUrl, options, resolve, reject) {
    const router = this;
    router.componentLoader(component, componentUrl, options, (el) => {
      resolve(el);
    }, reject);
  }
  tabComponentLoader(tabEl, component, componentUrl, options, resolve, reject) {
    const router = this;
    router.componentLoader(component, componentUrl, options, (el) => {
      resolve(el);
    }, reject);
  }
  pageComponentLoader(routerEl, component, componentUrl, options, resolve, reject) {
    const router = this;
    router.componentLoader(component, componentUrl, options, (el, newOptions = {}) => {
      resolve(el, newOptions);
    }, reject);
  }
  getPageData(pageEl, navbarEl, from, to, route = {}, pageFromEl) {
    const router = this;
    const $pageEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(pageEl);
    const $navbarEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(navbarEl);
    const currentPage = $pageEl[0].f7Page || {};
    let direction;
    let pageFrom;
    if ((from === 'next' && to === 'current') || (from === 'current' && to === 'previous')) direction = 'forward';
    if ((from === 'current' && to === 'next') || (from === 'previous' && to === 'current')) direction = 'backward';
    if (currentPage && !currentPage.fromPage) {
      const $pageFromEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(pageFromEl);
      if ($pageFromEl.length) {
        pageFrom = $pageFromEl[0].f7Page;
      }
    }
    const page = {
      app: router.app,
      view: router.view,
      router,
      $el: $pageEl,
      el: $pageEl[0],
      $pageEl,
      pageEl: $pageEl[0],
      $navbarEl,
      navbarEl: $navbarEl[0],
      name: $pageEl.attr('data-name'),
      position: from,
      from,
      to,
      direction,
      route: currentPage.route ? currentPage.route : route,
      pageFrom: currentPage.pageFrom || pageFrom,
    };

    if ($navbarEl && $navbarEl[0]) {
      $navbarEl[0].f7Page = page;
    }
    $pageEl[0].f7Page = page;
    return page;
  }
  // Callbacks
  pageCallback(callback, pageEl, navbarEl, from, to, options = {}, pageFromEl) {
    if (!pageEl) return;
    const router = this;
    const $pageEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(pageEl);
    if (!$pageEl.length) return;
    const { route } = options;
    const restoreScrollTopOnBack = router.params.restoreScrollTopOnBack;

    const camelName = `page${callback[0].toUpperCase() + callback.slice(1, callback.length)}`;
    const colonName = `page:${callback.toLowerCase()}`;

    let page = {};
    if (callback === 'beforeRemove' && $pageEl[0].f7Page) {
      page = Utils.extend($pageEl[0].f7Page, { from, to, position: from });
    } else {
      page = router.getPageData(pageEl, navbarEl, from, to, route, pageFromEl);
    }
    page.swipeBack = !!options.swipeBack;

    const { on = {}, once = {} } = options.route ? options.route.route : {};
    if (options.on) {
      Utils.extend(on, options.on);
    }
    if (options.once) {
      Utils.extend(once, options.once);
    }

    function attachEvents() {
      if ($pageEl[0].f7RouteEventsAttached) return;
      $pageEl[0].f7RouteEventsAttached = true;
      if (on && Object.keys(on).length > 0) {
        $pageEl[0].f7RouteEventsOn = on;
        Object.keys(on).forEach((eventName) => {
          on[eventName] = on[eventName].bind(router);
          $pageEl.on(Utils.eventNameToColonCase(eventName), on[eventName]);
        });
      }
      if (once && Object.keys(once).length > 0) {
        $pageEl[0].f7RouteEventsOnce = once;
        Object.keys(once).forEach((eventName) => {
          once[eventName] = once[eventName].bind(router);
          $pageEl.once(Utils.eventNameToColonCase(eventName), once[eventName]);
        });
      }
    }

    function detachEvents() {
      if (!$pageEl[0].f7RouteEventsAttached) return;
      if ($pageEl[0].f7RouteEventsOn) {
        Object.keys($pageEl[0].f7RouteEventsOn).forEach((eventName) => {
          $pageEl.off(Utils.eventNameToColonCase(eventName), $pageEl[0].f7RouteEventsOn[eventName]);
        });
      }
      if ($pageEl[0].f7RouteEventsOnce) {
        Object.keys($pageEl[0].f7RouteEventsOnce).forEach((eventName) => {
          $pageEl.off(Utils.eventNameToColonCase(eventName), $pageEl[0].f7RouteEventsOnce[eventName]);
        });
      }
      $pageEl[0].f7RouteEventsAttached = null;
      $pageEl[0].f7RouteEventsOn = null;
      $pageEl[0].f7RouteEventsOnce = null;
      delete $pageEl[0].f7RouteEventsAttached;
      delete $pageEl[0].f7RouteEventsOn;
      delete $pageEl[0].f7RouteEventsOnce;
    }

    if (callback === 'mounted') {
      attachEvents();
    }
    if (callback === 'init') {
      if (restoreScrollTopOnBack && (from === 'previous' || !from) && to === 'current' && router.scrollHistory[page.route.url] && !$pageEl.hasClass('no-restore-scroll')) {
        let $pageContent = $pageEl.find('.page-content');
        if ($pageContent.length > 0) {
          // eslint-disable-next-line
          $pageContent = $pageContent.filter((pageContentIndex, pageContentEl) => {
            return (
              Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(pageContentEl).parents('.tab:not(.tab-active)').length === 0 &&
              !Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(pageContentEl).is('.tab:not(.tab-active)')
            );
          });
        }
        $pageContent.scrollTop(router.scrollHistory[page.route.url]);
      }
      attachEvents();
      if ($pageEl[0].f7PageInitialized) {
        $pageEl.trigger('page:reinit', page);
        router.emit('pageReinit', page);
        return;
      }
      $pageEl[0].f7PageInitialized = true;
    }
    if (restoreScrollTopOnBack && callback === 'beforeOut' && from === 'current' && to === 'previous') {
      // Save scroll position
      let $pageContent = $pageEl.find('.page-content');
      if ($pageContent.length > 0) {
        // eslint-disable-next-line
        $pageContent = $pageContent.filter((pageContentIndex, pageContentEl) => {
          return (
            Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(pageContentEl).parents('.tab:not(.tab-active)').length === 0 &&
            !Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(pageContentEl).is('.tab:not(.tab-active)')
          );
        });
      }
      router.scrollHistory[page.route.url] = $pageContent.scrollTop();
    }
    if (restoreScrollTopOnBack && callback === 'beforeOut' && from === 'current' && to === 'next') {
      // Delete scroll position
      delete router.scrollHistory[page.route.url];
    }

    $pageEl.trigger(colonName, page);
    router.emit(camelName, page);

    if (callback === 'beforeRemove') {
      detachEvents();
      $pageEl[0].f7Page = null;
    }
  }
  saveHistory() {
    const router = this;
    router.view.history = router.history;
    if (router.params.pushState) {
      __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].localStorage[`f7router-${router.view.id}-history`] = JSON.stringify(router.history);
    }
  }
  restoreHistory() {
    const router = this;
    if (router.params.pushState && __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].localStorage[`f7router-${router.view.id}-history`]) {
      router.history = JSON.parse(__WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].localStorage[`f7router-${router.view.id}-history`]);
      router.view.history = router.history;
    }
  }
  clearHistory() {
    const router = this;
    router.history = [];
    if (router.view) router.view.history = [];
    router.saveHistory();
  }
  init() {
    const router = this;
    const { app, view } = router;

    // Init Swipeback
    {
      if (
        (view && router.params.iosSwipeBack && app.theme === 'ios') ||
        (view && router.params.mdSwipeBack && app.theme === 'md')
      ) {
        SwipeBack(router);
      }
    }

    // Dynamic not separated navbbar
    if (router.dynamicNavbar && !router.separateNavbar) {
      router.$el.addClass('router-dynamic-navbar-inside');
    }

    let initUrl = router.params.url;
    let documentUrl = __WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */].location.href.split(__WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */].location.origin)[1];
    let historyRestored;
    if (!router.params.pushState) {
      if (!initUrl) {
        initUrl = documentUrl;
      }
      if (__WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */].location.search && initUrl.indexOf('?') < 0) {
        initUrl += __WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */].location.search;
      }
      if (__WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */].location.hash && initUrl.indexOf('#') < 0) {
        initUrl += __WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */].location.hash;
      }
    } else {
      if (router.params.pushStateRoot && documentUrl.indexOf(router.params.pushStateRoot) >= 0) {
        documentUrl = documentUrl.split(router.params.pushStateRoot)[1];
        if (documentUrl === '') documentUrl = '/';
      }
      if (router.params.pushStateSeparator.length > 0 && documentUrl.indexOf(router.params.pushStateSeparator) >= 0) {
        initUrl = documentUrl.split(router.params.pushStateSeparator)[1];
      } else {
        initUrl = documentUrl;
      }
      router.restoreHistory();
      if (router.history.indexOf(initUrl) >= 0) {
        router.history = router.history.slice(0, router.history.indexOf(initUrl) + 1);
      } else if (router.params.url === initUrl) {
        router.history = [initUrl];
      } else if (History.state && History.state[view.id] && History.state[view.id].url === router.history[router.history.length - 1]) {
        initUrl = router.history[router.history.length - 1];
      } else {
        router.history = [documentUrl.split(router.params.pushStateSeparator)[0] || '/', initUrl];
      }
      if (router.history.length > 1) {
        historyRestored = true;
      } else {
        router.history = [];
      }
      router.saveHistory();
    }
    let currentRoute;
    if (router.history.length > 1) {
      // Will load page
      currentRoute = router.findMatchingRoute(router.history[0]);
      if (!currentRoute) {
        currentRoute = Utils.extend(router.parseRouteUrl(router.history[0]), {
          route: {
            url: router.history[0],
            path: router.history[0].split('?')[0],
          },
        });
      }
    } else {
      // Don't load page
      currentRoute = router.findMatchingRoute(initUrl);
      if (!currentRoute) {
        currentRoute = Utils.extend(router.parseRouteUrl(initUrl), {
          route: {
            url: initUrl,
            path: initUrl.split('?')[0],
          },
        });
      }
    }

    if (router.params.stackPages) {
      router.$el.children('.page').each((index, pageEl) => {
        const $pageEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(pageEl);
        router.initialPages.push($pageEl[0]);
        if (router.separateNavbar && $pageEl.children('.navbar').length > 0) {
          router.initialNavbars.push($pageEl.children('.navbar').find('.navbar-inner')[0]);
        }
      });
    }

    if (router.$el.children('.page:not(.stacked)').length === 0 && initUrl) {
      // No pages presented in DOM, reload new page
      router.navigate(initUrl, {
        initial: true,
        reloadCurrent: true,
        pushState: false,
      });
    } else {
      // Init current DOM page
      let hasTabRoute;
      router.currentRoute = currentRoute;
      router.$el.children('.page:not(.stacked)').each((index, pageEl) => {
        const $pageEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(pageEl);
        let $navbarInnerEl;
        $pageEl.addClass('page-current');
        if (router.separateNavbar) {
          $navbarInnerEl = $pageEl.children('.navbar').children('.navbar-inner');
          if ($navbarInnerEl.length > 0) {
            if (!router.$navbarEl.parents(__WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */]).length) {
              router.$el.prepend(router.$navbarEl);
            }
            router.$navbarEl.append($navbarInnerEl);
            $pageEl.children('.navbar').remove();
          } else {
            router.$navbarEl.addClass('navbar-hidden');
          }
        }
        const initOptions = {
          route: router.currentRoute,
        };
        if (router.currentRoute && router.currentRoute.route && router.currentRoute.route.options) {
          Utils.extend(initOptions, router.currentRoute.route.options);
        }
        router.currentPageEl = $pageEl[0];
        if (router.dynamicNavbar && $navbarInnerEl.length) {
          router.currentNavbarEl = $navbarInnerEl[0];
        }
        router.removeThemeElements($pageEl);
        if (router.dynamicNavbar && $navbarInnerEl.length) {
          router.removeThemeElements($navbarInnerEl);
        }
        if (initOptions.route.route.tab) {
          hasTabRoute = true;
          router.tabLoad(initOptions.route.route.tab, Utils.extend({}, initOptions));
        }
        router.pageCallback('init', $pageEl, $navbarInnerEl, 'current', undefined, initOptions);
      });
      if (historyRestored) {
        router.navigate(initUrl, {
          initial: true,
          pushState: false,
          history: false,
          animate: router.params.pushStateAnimateOnLoad,
          once: {
            pageAfterIn() {
              if (router.history.length > 2) {
                router.back({ preload: true });
              }
            },
          },
        });
      }
      if (!historyRestored && !hasTabRoute) {
        router.history.push(initUrl);
        router.saveHistory();
      }
    }
    if (initUrl && router.params.pushState && (!History.state || !History.state[view.id])) {
      History.initViewState(view.id, {
        url: initUrl,
      });
    }
    router.emit('local::init routerInit', router);
  }
  destroy() {
    let router = this;

    router.emit('local::destroy routerDestroy', router);

    // Delete props & methods
    Object.keys(router).forEach((routerProp) => {
      router[routerProp] = null;
      delete router[routerProp];
    });

    router = null;
  }
}

var Router$1 = {
  name: 'router',
  static: {
    Router,
  },
  instance: {
    cache: {
      xhr: [],
      templates: [],
      components: [],
    },
  },
  create() {
    const instance = this;
    if (instance.app) {
      // View Router
      if (instance.params.router) {
        instance.router = new Router(instance.app, instance);
      }
    } else {
      // App Router
      instance.router = new Router(instance);
    }
  },
};

class View extends Framework7Class {
  constructor(appInstance, el, viewParams = {}) {
    super(viewParams, [appInstance]);

    const app = appInstance;
    const $el = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(el);
    const view = this;

    const defaults = {
      routes: [],
      routesAdd: [],
    };

    // Default View params
    view.params = Utils.extend(defaults, app.params.view, viewParams);

    // Routes
    if (view.params.routes.length > 0) {
      view.routes = view.params.routes;
    } else {
      view.routes = [].concat(app.routes, view.params.routesAdd);
    }

    // Selector
    let selector;
    if (typeof el === 'string') selector = el;
    else {
      // Supposed to be HTMLElement or Dom7
      selector = ($el.attr('id') ? `#${$el.attr('id')}` : '') + ($el.attr('class') ? `.${$el.attr('class').replace(/ /g, '.').replace('.active', '')}` : '');
    }

    // DynamicNavbar
    let $navbarEl;
    if (app.theme === 'ios' && view.params.iosDynamicNavbar && view.params.iosSeparateDynamicNavbar) {
      $navbarEl = $el.children('.navbar').eq(0);
      if ($navbarEl.length === 0) {
        $navbarEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])('<div class="navbar"></div>');
      }
    }

    // View Props
    Utils.extend(false, view, {
      app,
      $el,
      el: $el[0],
      name: view.params.name,
      main: view.params.main || $el.hasClass('view-main'),
      $navbarEl,
      navbarEl: $navbarEl ? $navbarEl[0] : undefined,
      selector,
      history: [],
      scrollHistory: {},
    });

    // Save in DOM
    $el[0].f7View = view;

    // Install Modules
    view.useModules();

    // Add to app
    app.views.push(view);
    if (view.main) {
      app.views.main = view;
    }
    if (view.name) {
      app.views[view.name] = view;
    }

    // Index
    view.index = app.views.indexOf(view);

    // View ID
    let viewId;
    if (view.name) {
      viewId = `view_${view.name}`;
    } else if (view.main) {
      viewId = 'view_main';
    } else {
      viewId = `view_${view.index}`;
    }
    view.id = viewId;

    // Init View
    if (app.initialized) {
      view.init();
    } else {
      app.on('init', () => {
        view.init();
      });
    }

    return view;
  }
  destroy() {
    let view = this;
    const app = view.app;

    view.$el.trigger('view:beforedestroy', view);
    view.emit('local::beforeDestroy viewBeforeDestroy', view);

    if (view.main) {
      app.views.main = null;
      delete app.views.main;
    } else if (view.name) {
      app.views[view.name] = null;
      delete app.views[view.name];
    }
    view.$el[0].f7View = null;
    delete view.$el[0].f7View;

    app.views.splice(app.views.indexOf(view), 1);

    // Destroy Router
    if (view.params.router && view.router) {
      view.router.destroy();
    }

    view.emit('local::destroy viewDestroy', view);

    // Delete props & methods
    Object.keys(view).forEach((viewProp) => {
      view[viewProp] = null;
      delete view[viewProp];
    });

    view = null;
  }
  init() {
    const view = this;
    if (view.params.router) {
      view.router.init();
    }
  }
}

// Use Router
View.use(Router$1);

function initClicks(app) {
  function handleClicks(e) {
    const clicked = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(e.target);
    const clickedLink = clicked.closest('a');
    const isLink = clickedLink.length > 0;
    const url = isLink && clickedLink.attr('href');
    const isTabLink = isLink && clickedLink.hasClass('tab-link') && (clickedLink.attr('data-tab') || (url && url.indexOf('#') === 0));

    // Check if link is external
    if (isLink) {
      // eslint-disable-next-line
      if (clickedLink.is(app.params.clicks.externalLinks) || (url && url.indexOf('javascript:') >= 0)) {
        const target = clickedLink.attr('target');
        if (url && (target === '_system' || target === '_blank' || target === '_browser')) {
          e.preventDefault();
          if (target !== '_browser' && __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].cordova && __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].cordova.InAppBrowser) {
            __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].cordova.InAppBrowser.open(url, target);
          } else {
            __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].open(url, target);
          }
        }
        return;
      }
    }

    // Modules Clicks
    Object.keys(app.modules).forEach((moduleName) => {
      const moduleClicks = app.modules[moduleName].clicks;
      if (!moduleClicks) return;
      Object.keys(moduleClicks).forEach((clickSelector) => {
        const matchingClickedElement = clicked.closest(clickSelector).eq(0);
        if (matchingClickedElement.length > 0) {
          moduleClicks[clickSelector].call(app, matchingClickedElement, matchingClickedElement.dataset());
        }
      });
    });

    // Load Page
    let clickedLinkData = {};
    if (isLink) {
      e.preventDefault();
      clickedLinkData = clickedLink.dataset();
    }
    const validUrl = url && url.length > 0 && url !== '#' && !isTabLink;
    const template = clickedLinkData.template;
    if (validUrl || clickedLink.hasClass('back') || template) {
      let view;
      if (clickedLinkData.view) {
        view = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(clickedLinkData.view)[0].f7View;
      } else {
        view = clicked.parents('.view')[0] && clicked.parents('.view')[0].f7View;
        if (!clickedLink.hasClass('back') && view && view.params.linksView) {
          if (typeof view.params.linksView === 'string') view = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(view.params.linksView)[0].f7View;
          else if (view.params.linksView instanceof View) view = view.params.linksView;
        }
      }
      if (!view) {
        if (app.views.main) view = app.views.main;
      }
      if (!view || !view.router) return;
      if (clickedLinkData.context && typeof clickedLinkData.context === 'string') {
        try {
          clickedLinkData.context = JSON.parse(clickedLinkData.context);
        } catch (err) {
          // something wrong there
        }
      }
      if (clickedLink.hasClass('back')) view.router.back(url, clickedLinkData);
      else view.router.navigate(url, clickedLinkData);
    }
  }

  app.on('click', handleClicks);

  // Prevent scrolling on overlays
  function preventScrolling(e) {
    e.preventDefault();
  }
  if (Support.touch && !Device.android) {
    const activeListener = Support.passiveListener ? { passive: false, capture: false } : false;
    Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(__WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */]).on((app.params.fastClicks ? 'touchstart' : 'touchmove'), '.panel-backdrop, .dialog-backdrop, .preloader-backdrop, .popup-backdrop, .searchbar-backdrop', preventScrolling, activeListener);
  }
}
var ClicksModule = {
  name: 'clicks',
  params: {
    clicks: {
      // External Links
      externalLinks: '.external',
    },
  },
  on: {
    init() {
      const app = this;
      initClicks(app);
    },
  },
};

var HistoryModule = {
  name: 'history',
  static: {
    history: History,
  },
  on: {
    init() {
      History.init(this);
    },
  },
};

const keyPrefix = 'f7storage-';
const Storage = {
  get(key) {
    return Utils.promise((resolve, reject) => {
      try {
        const value = JSON.parse(__WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].localStorage.getItem(`${keyPrefix}${key}`));
        resolve(value);
      } catch (e) {
        reject(e);
      }
    });
  },
  set(key, value) {
    return Utils.promise((resolve, reject) => {
      try {
        __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].localStorage.setItem(`${keyPrefix}${key}`, JSON.stringify(value));
        resolve();
      } catch (e) {
        reject(e);
      }
    });
  },
  remove(key) {
    return Utils.promise((resolve, reject) => {
      try {
        __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].localStorage.removeItem(`${keyPrefix}${key}`);
        resolve();
      } catch (e) {
        reject(e);
      }
    });
  },
  clear() {

  },
  length() {

  },
  keys() {
    return Utils.promise((resolve, reject) => {
      try {
        const keys = Object.keys(__WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].localStorage)
          .filter(keyName => keyName.indexOf(keyPrefix) === 0)
          .map(keyName => keyName.replace(keyPrefix, ''));
        resolve(keys);
      } catch (e) {
        reject(e);
      }
    });
  },
  forEach(callback) {
    return Utils.promise((resolve, reject) => {
      try {
        Object.keys(__WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].localStorage)
          .filter(keyName => keyName.indexOf(keyPrefix) === 0)
          .forEach((keyName, index) => {
            const key = keyName.replace(keyPrefix, '');
            Storage.get(key).then((value) => {
              callback(key, value, index);
            });
          });
        resolve();
      } catch (e) {
        reject(e);
      }
    });
  },
};

var StorageModule = {
  name: 'storage',
  static: {
    Storage,
    storage: Storage,
  },
};

const Statusbar = {
  hide() {
    Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])('html').removeClass('with-statusbar');
    if (Device.cordova && __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].StatusBar) {
      __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].StatusBar.hide();
    }
  },
  show() {
    if (Device.cordova && __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].StatusBar) {
      __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].StatusBar.show();
      Utils.nextTick(() => {
        if (Device.needsStatusbarOverlay()) {
          Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])('html').addClass('with-statusbar');
        }
      });
      return;
    }
    Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])('html').addClass('with-statusbar');
  },
  onClick() {
    const app = this;
    let pageContent;
    if (Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])('.popup.modal-in').length > 0) {
      // Check for opened popup
      pageContent = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])('.popup.modal-in').find('.page:not(.page-previous):not(.page-next):not(.cached)').find('.page-content');
    } else if (Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])('.panel.panel-active').length > 0) {
      // Check for opened panel
      pageContent = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])('.panel.panel-active').find('.page:not(.page-previous):not(.page-next):not(.cached)').find('.page-content');
    } else if (Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])('.views > .view.tab-active').length > 0) {
      // View in tab bar app layout
      pageContent = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])('.views > .view.tab-active').find('.page:not(.page-previous):not(.page-next):not(.cached)').find('.page-content');
    } else if (Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])('.views').length > 0) {
      pageContent = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])('.views').find('.page:not(.page-previous):not(.page-next):not(.cached)').find('.page-content');
    } else {
      pageContent = app.root.children('.view').find('.page:not(.page-previous):not(.page-next):not(.cached)').find('.page-content');
    }

    if (pageContent && pageContent.length > 0) {
      // Check for tab
      if (pageContent.hasClass('tab')) {
        pageContent = pageContent.parent('.tabs').children('.page-content.tab-active');
      }
      if (pageContent.length > 0) pageContent.scrollTop(0, 300);
    }
  },
  setIosTextColor(color) {
    if (Device.cordova && __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].StatusBar) {
      if (color === 'white') {
        __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].StatusBar.styleLightContent();
      } else {
        __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].StatusBar.styleDefault();
      }
    }
  },
  setBackgroundColor(color) {
    Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])('.statusbar').css('background-color', color);
    if (Device.cordova && __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].StatusBar) {
      __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].StatusBar.backgroundColorByHexString(color);
    }
  },
  isVisible() {
    if (Device.cordova && __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].StatusBar) {
      return __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].StatusBar.isVisible;
    }
    return false;
  },
  iosOverlaysWebView(overlays = true) {
    if (!Device.ios) return;
    if (Device.cordova && __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].StatusBar) {
      __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].StatusBar.overlaysWebView(overlays);
      if (overlays) {
        Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])('html').addClass('with-statusbar');
      } else {
        Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])('html').removeClass('with-statusbar');
      }
    }
  },
  checkOverlay() {
    if (Device.needsStatusbarOverlay()) {
      Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])('html').addClass('with-statusbar');
    } else {
      Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])('html').removeClass('with-statusbar');
    }
  },
  init() {
    const app = this;
    const params = app.params.statusbar;
    if (!params.enabled) return;

    if (params.overlay === 'auto') {
      if (Device.needsStatusbarOverlay()) {
        Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])('html').addClass('with-statusbar');
      }

      if (Device.ios && (Device.cordova || Device.webView)) {
        if (__WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].orientation === 0) {
          app.once('resize', () => {
            Statusbar.checkOverlay();
          });
        }

        Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(__WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */]).on('resume', () => {
          Statusbar.checkOverlay();
        }, false);

        app.on('orientationchange resize', () => {
          Statusbar.checkOverlay();
        });
      }
    } else if (params.overlay === true) {
      Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])('html').addClass('with-statusbar');
    } else if (params.overlay === false) {
      Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])('html').removeClass('with-statusbar');
    }

    if (Device.cordova && __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].StatusBar) {
      if (params.scrollTopOnClick) {
        Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(__WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */]).on('statusTap', Statusbar.onClick.bind(app));
      }
      if (params.iosOverlaysWebView) {
        __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].StatusBar.overlaysWebView(true);
      } else {
        __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].StatusBar.overlaysWebView(false);
      }

      if (params.iosTextColor === 'white') {
        __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].StatusBar.styleLightContent();
      } else {
        __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].StatusBar.styleDefault();
      }
    }
    if (params.iosBackgroundColor && app.theme === 'ios') {
      Statusbar.setBackgroundColor(params.iosBackgroundColor);
    }
    if (params.materialBackgroundColor && app.theme === 'md') {
      Statusbar.setBackgroundColor(params.materialBackgroundColor);
    }
  },
};

var Statusbar$1 = {
  name: 'statusbar',
  params: {
    statusbar: {
      enabled: true,
      overlay: 'auto',
      scrollTopOnClick: true,
      iosOverlaysWebView: true,
      iosTextColor: 'black',
      iosBackgroundColor: null,
      materialBackgroundColor: null,
    },
  },
  create() {
    const app = this;
    Utils.extend(app, {
      statusbar: {
        checkOverlay: Statusbar.checkOverlay,
        hide: Statusbar.hide,
        show: Statusbar.show,
        iosOverlaysWebView: Statusbar.iosOverlaysWebView,
        setIosTextColor: Statusbar.setIosTextColor,
        setBackgroundColor: Statusbar.setBackgroundColor,
        isVisible: Statusbar.isVisible,
        init: Statusbar.init.bind(app),
      },
    });
  },
  on: {
    init() {
      const app = this;
      Statusbar.init.call(app);
    },
  },
  clicks: {
    '.statusbar': function onStatusbarClick() {
      const app = this;
      if (!app.params.statusbar.enabled) return;
      if (!app.params.statusbar.scrollTopOnClick) return;
      Statusbar.onClick.call(app);
    },
  },
};

function getCurrentView(app) {
  const popoverView = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])('.popover.modal-in .view');
  const popupView = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])('.popup.modal-in .view');
  const panelView = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])('.panel.panel-active .view');
  let appViews = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])('.views');
  if (appViews.length === 0) appViews = app.root;
  // Find active view as tab
  let appView = appViews.children('.view');
  // Propably in tabs or split view
  if (appView.length > 1) {
    if (appView.hasClass('tab')) {
      // Tabs
      appView = appViews.children('.view.tab-active');
    }
  }
  if (popoverView.length > 0 && popoverView[0].f7View) return popoverView[0].f7View;
  if (popupView.length > 0 && popupView[0].f7View) return popupView[0].f7View;
  if (panelView.length > 0 && panelView[0].f7View) return panelView[0].f7View;
  if (appView.length > 0) {
    if (appView.length === 1 && appView[0].f7View) return appView[0].f7View;
    if (appView.length > 1) {
      return app.views.main;
    }
  }
  return undefined;
}

var View$1 = {
  name: 'view',
  params: {
    view: {
      name: undefined,
      main: false,
      router: true,
      linksView: null,
      stackPages: false,
      xhrCache: true,
      xhrCacheIgnore: [],
      xhrCacheIgnoreGetParameters: false,
      xhrCacheDuration: 1000 * 60 * 10, // Ten minutes
      preloadPreviousPage: true,
      uniqueHistory: false,
      uniqueHistoryIgnoreGetParameters: false,
      allowDuplicateUrls: false,
      reloadPages: false,
      removeElements: true,
      removeElementsWithTimeout: false,
      removeElementsTimeout: 0,
      restoreScrollTopOnBack: true,
      unloadTabContent: true,
      passRouteQueryToRequest: true,
      passRouteParamsToRequest: false,
      // Swipe Back
      iosSwipeBack: true,
      iosSwipeBackAnimateShadow: true,
      iosSwipeBackAnimateOpacity: true,
      iosSwipeBackActiveArea: 30,
      iosSwipeBackThreshold: 0,
      mdSwipeBack: false,
      mdSwipeBackAnimateShadow: true,
      mdSwipeBackAnimateOpacity: false,
      mdSwipeBackActiveArea: 30,
      mdSwipeBackThreshold: 0,
      // Push State
      pushState: false,
      pushStateRoot: undefined,
      pushStateAnimate: true,
      pushStateAnimateOnLoad: false,
      pushStateSeparator: '#!',
      pushStateOnLoad: true,
      // Animate Pages
      animate: true,
      animateWithJS: false,
      // iOS Dynamic Navbar
      iosDynamicNavbar: true,
      iosSeparateDynamicNavbar: true,
      // Animate iOS Navbar Back Icon
      iosAnimateNavbarBackIcon: true,
      // Delays
      iosPageLoadDelay: 0,
      materialPageLoadDelay: 0,
    },
  },
  static: {
    View,
  },
  create() {
    const app = this;
    Utils.extend(app, {
      views: Utils.extend([], {
        create(el, params) {
          return new View(app, el, params);
        },
        get(viewEl) {
          const $viewEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(viewEl);
          if ($viewEl.length && $viewEl[0].f7View) return $viewEl[0].f7View;
          return undefined;
        },
      }),
    });
    Object.defineProperty(app.views, 'current', {
      enumerable: true,
      configurable: true,
      get() {
        return getCurrentView(app);
      },
    });
    // Alias
    app.view = app.views;
  },
  on: {
    init() {
      const app = this;
      Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])('.view-init').each((index, viewEl) => {
        if (viewEl.f7View) return;
        const viewParams = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(viewEl).dataset();
        app.views.create(viewEl, viewParams);
      });
    },
    modalOpen(modal) {
      const app = this;
      modal.$el.find('.view-init').each((index, viewEl) => {
        if (viewEl.f7View) return;
        const viewParams = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(viewEl).dataset();
        app.views.create(viewEl, viewParams);
      });
    },
    modalBeforeDestroy(modal) {
      if (!modal || !modal.$el) return;
      modal.$el.find('.view-init').each((index, viewEl) => {
        const view = viewEl.f7View;
        if (!view) return;
        view.destroy();
      });
    },
  },
};

const Navbar = {
  size(el) {
    const app = this;
    if (app.theme !== 'ios') return;
    let $el = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(el);
    if ($el.hasClass('navbar')) {
      $el = $el.children('.navbar-inner').each((index, navbarEl) => {
        app.navbar.size(navbarEl);
      });
      return;
    }
    if (
      $el.hasClass('stacked') ||
      $el.parents('.stacked').length > 0 ||
      $el.parents('.tab:not(.tab-active)').length > 0 ||
      $el.parents('.popup:not(.modal-in)').length > 0
    ) {
      return;
    }
    const $viewEl = $el.parents('.view').eq(0);
    const left = app.rtl ? $el.children('.right') : $el.children('.left');
    const right = app.rtl ? $el.children('.left') : $el.children('.right');
    const title = $el.children('.title');
    const subnavbar = $el.children('.subnavbar');
    const noLeft = left.length === 0;
    const noRight = right.length === 0;
    const leftWidth = noLeft ? 0 : left.outerWidth(true);
    const rightWidth = noRight ? 0 : right.outerWidth(true);
    const titleWidth = title.outerWidth(true);
    const navbarStyles = $el.styles();
    const navbarWidth = $el[0].offsetWidth;
    const navbarInnerWidth = navbarWidth - parseInt(navbarStyles.paddingLeft, 10) - parseInt(navbarStyles.paddingRight, 10);
    const isPrevious = $el.hasClass('navbar-previous');
    const sliding = $el.hasClass('sliding');

    let router;
    let dynamicNavbar;
    let separateNavbar;
    let separateNavbarRightOffset = 0;
    let separateNavbarLeftOffset = 0;

    if ($viewEl.length > 0 && $viewEl[0].f7View) {
      router = $viewEl[0].f7View.router;
      dynamicNavbar = router && router.dynamicNavbar;
      separateNavbar = router && router.separateNavbar;
      if (!separateNavbar) {
        separateNavbarRightOffset = navbarWidth;
        separateNavbarLeftOffset = navbarWidth / 5;
      }
    }

    let currLeft;
    let diff;
    if (noRight) {
      currLeft = navbarInnerWidth - titleWidth;
    }
    if (noLeft) {
      currLeft = 0;
    }
    if (!noLeft && !noRight) {
      currLeft = ((navbarInnerWidth - rightWidth - titleWidth) + leftWidth) / 2;
    }
    let requiredLeft = (navbarInnerWidth - titleWidth) / 2;
    if (navbarInnerWidth - leftWidth - rightWidth > titleWidth) {
      if (requiredLeft < leftWidth) {
        requiredLeft = leftWidth;
      }
      if (requiredLeft + titleWidth > navbarInnerWidth - rightWidth) {
        requiredLeft = navbarInnerWidth - rightWidth - titleWidth;
      }
      diff = requiredLeft - currLeft;
    } else {
      diff = 0;
    }

    // RTL inverter
    const inverter = app.rtl ? -1 : 1;

    if (dynamicNavbar) {
      if (title.hasClass('sliding') || (title.length > 0 && sliding)) {
        let titleLeftOffset = (-(currLeft + diff) * inverter) + separateNavbarLeftOffset;
        const titleRightOffset = ((navbarInnerWidth - currLeft - diff - titleWidth) * inverter) - separateNavbarRightOffset;

        if (isPrevious) {
          if (router && router.params.iosAnimateNavbarBackIcon) {
            const activeNavbarBackLink = $el.parent().find('.navbar-current').children('.left.sliding').find('.back .icon ~ span');
            if (activeNavbarBackLink.length > 0) {
              titleLeftOffset += activeNavbarBackLink[0].offsetLeft;
            }
          }
        }
        title[0].f7NavbarLeftOffset = titleLeftOffset;
        title[0].f7NavbarRightOffset = titleRightOffset;
      }
      if (!noLeft && (left.hasClass('sliding') || sliding)) {
        if (app.rtl) {
          left[0].f7NavbarLeftOffset = (-(navbarInnerWidth - left[0].offsetWidth) / 2) * inverter;
          left[0].f7NavbarRightOffset = leftWidth * inverter;
        } else {
          left[0].f7NavbarLeftOffset = -leftWidth + separateNavbarLeftOffset;
          left[0].f7NavbarRightOffset = ((navbarInnerWidth - left[0].offsetWidth) / 2) - separateNavbarRightOffset;
          if (router && router.params.iosAnimateNavbarBackIcon && left.find('.back .icon').length > 0) {
            left[0].f7NavbarRightOffset -= left.find('.back .icon')[0].offsetWidth;
          }
        }
      }
      if (!noRight && (right.hasClass('sliding') || sliding)) {
        if (app.rtl) {
          right[0].f7NavbarLeftOffset = -rightWidth * inverter;
          right[0].f7NavbarRightOffset = ((navbarInnerWidth - right[0].offsetWidth) / 2) * inverter;
        } else {
          right[0].f7NavbarLeftOffset = (-(navbarInnerWidth - right[0].offsetWidth) / 2) + separateNavbarLeftOffset;
          right[0].f7NavbarRightOffset = rightWidth - separateNavbarRightOffset;
        }
      }
      if (subnavbar.length && (subnavbar.hasClass('sliding') || sliding)) {
        subnavbar[0].f7NavbarLeftOffset = app.rtl ? subnavbar[0].offsetWidth : (-subnavbar[0].offsetWidth + separateNavbarLeftOffset);
        subnavbar[0].f7NavbarRightOffset = (-subnavbar[0].f7NavbarLeftOffset - separateNavbarRightOffset) + separateNavbarLeftOffset;
      }
    }

    // Title left
    if (app.params.navbar.iosCenterTitle) {
      let titleLeft = diff;
      if (app.rtl && noLeft && noRight && title.length > 0) titleLeft = -titleLeft;
      title.css({ left: `${titleLeft}px` });
    }
  },
  hide(el, animate = true) {
    let $el = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(el);
    if ($el.hasClass('navbar-inner')) $el = $el.parents('.navbar');
    if (!$el.length) return;
    if ($el.hasClass('navbar-hidden')) return;
    const className = `navbar-hidden${animate ? ' navbar-transitioning' : ''}`;
    $el.transitionEnd(() => {
      $el.removeClass('navbar-transitioning');
    });
    $el.addClass(className);
  },
  show(el = '.navbar-hidden', animate = true) {
    let $el = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(el);
    if ($el.hasClass('navbar-inner')) $el = $el.parents('.navbar');
    if (!$el.length) return;
    if (!$el.hasClass('navbar-hidden')) return;
    if (animate) {
      $el.addClass('navbar-transitioning');
      $el.transitionEnd(() => {
        $el.removeClass('navbar-transitioning');
      });
    }
    $el.removeClass('navbar-hidden');
  },
  getElByPage(page) {
    let $pageEl;
    let $navbarEl;
    let pageData;
    if (page.$navbarEl || page.$el) {
      pageData = page;
      $pageEl = page.$el;
    } else {
      $pageEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(page);
      if ($pageEl.length > 0) pageData = $pageEl[0].f7Page;
    }
    if (pageData && pageData.$navbarEl && pageData.$navbarEl.length > 0) {
      $navbarEl = pageData.$navbarEl;
    } else if ($pageEl) {
      $navbarEl = $pageEl.children('.navbar').children('.navbar-inner');
    }
    if (!$navbarEl || ($navbarEl && $navbarEl.length === 0)) return undefined;
    return $navbarEl[0];
  },
  getPageByEl(navbarInnerEl) {
    let $navbarInnerEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(navbarInnerEl);
    if ($navbarInnerEl.hasClass('navbar')) {
      $navbarInnerEl = $navbarInnerEl.find('.navbar-inner');
      if ($navbarInnerEl.length > 1) return undefined;
    }
    return $navbarInnerEl[0].f7Page;
  },
  initHideNavbarOnScroll(pageEl, navbarInnerEl) {
    const app = this;
    const $pageEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(pageEl);
    const $navbarEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(navbarInnerEl || app.navbar.getElByPage(pageEl)).closest('.navbar');

    let previousScrollTop;
    let currentScrollTop;

    let scrollHeight;
    let offsetHeight;
    let reachEnd;
    let action;
    let navbarHidden;
    function handleScroll() {
      const scrollContent = this;
      if ($pageEl.hasClass('page-previous')) return;
      currentScrollTop = scrollContent.scrollTop;
      scrollHeight = scrollContent.scrollHeight;
      offsetHeight = scrollContent.offsetHeight;
      reachEnd = currentScrollTop + offsetHeight >= scrollHeight;
      navbarHidden = $navbarEl.hasClass('navbar-hidden');

      if (reachEnd) {
        if (app.params.navbar.showOnPageScrollEnd) {
          action = 'show';
        }
      } else if (previousScrollTop > currentScrollTop) {
        if (app.params.navbar.showOnPageScrollTop || currentScrollTop <= 44) {
          action = 'show';
        } else {
          action = 'hide';
        }
      } else if (currentScrollTop > 44) {
        action = 'hide';
      } else {
        action = 'show';
      }

      if (action === 'show' && navbarHidden) {
        app.navbar.show($navbarEl);
        navbarHidden = false;
      } else if (action === 'hide' && !navbarHidden) {
        app.navbar.hide($navbarEl);
        navbarHidden = true;
      }

      previousScrollTop = currentScrollTop;
    }
    $pageEl.on('scroll', '.page-content', handleScroll, true);
    $pageEl[0].f7ScrollNavbarHandler = handleScroll;
  },
};
var Navbar$1 = {
  name: 'navbar',
  create() {
    const app = this;
    Utils.extend(app, {
      navbar: {
        size: Navbar.size.bind(app),
        hide: Navbar.hide.bind(app),
        show: Navbar.show.bind(app),
        getElByPage: Navbar.getElByPage.bind(app),
        initHideNavbarOnScroll: Navbar.initHideNavbarOnScroll.bind(app),
      },
    });
  },
  params: {
    navbar: {
      scrollTopOnTitleClick: true,
      iosCenterTitle: true,
      hideOnPageScroll: false,
      showOnPageScrollEnd: true,
      showOnPageScrollTop: true,
    },
  },
  on: {
    'panelBreakpoint resize': function onResize() {
      const app = this;
      if (app.theme !== 'ios') return;
      Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])('.navbar').each((index, navbarEl) => {
        app.navbar.size(navbarEl);
      });
    },
    pageBeforeRemove(page) {
      if (page.$el[0].f7ScrollNavbarHandler) {
        page.$el.off('scroll', '.page-content', page.$el[0].f7ScrollNavbarHandler, true);
      }
    },
    pageBeforeIn(page) {
      const app = this;
      if (app.theme !== 'ios') return;
      let $navbarEl;
      const view = page.$el.parents('.view')[0].f7View;
      const navbarInnerEl = app.navbar.getElByPage(page);
      if (!navbarInnerEl) {
        $navbarEl = page.$el.parents('.view').children('.navbar');
      } else {
        $navbarEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(navbarInnerEl).parents('.navbar');
      }
      if (page.$el.hasClass('no-navbar') || (view.router.dynamicNavbar && !navbarInnerEl)) {
        const animate = !!(page.pageFrom && page.router.history.length > 0);
        app.navbar.hide($navbarEl, animate);
      } else {
        app.navbar.show($navbarEl);
      }
    },
    pageReinit(page) {
      const app = this;
      if (app.theme !== 'ios') return;
      const $navbarEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(app.navbar.getElByPage(page));
      if (!$navbarEl || $navbarEl.length === 0) return;
      app.navbar.size($navbarEl);
    },
    pageInit(page) {
      const app = this;
      const $navbarEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(app.navbar.getElByPage(page));
      if (!$navbarEl || $navbarEl.length === 0) return;
      if (app.theme === 'ios') {
        app.navbar.size($navbarEl);
      }
      if (
        app.params.navbar.hideOnPageScroll ||
        page.$el.find('.hide-navbar-on-scroll').length ||
        page.$el.hasClass('hide-navbar-on-scroll') ||
        page.$el.find('.hide-bars-on-scroll').length ||
        page.$el.hasClass('hide-bars-on-scroll')
      ) {
        if (
          page.$el.find('.keep-navbar-on-scroll').length ||
          page.$el.hasClass('keep-navbar-on-scroll') ||
          page.$el.find('.keep-bars-on-scroll').length ||
          page.$el.hasClass('keep-bars-on-scroll')
        ) {
          return;
        }
        app.navbar.initHideNavbarOnScroll(page.el, $navbarEl[0]);
      }
    },
    modalOpen(modal) {
      const app = this;
      if (app.theme !== 'ios') return;
      modal.$el.find('.navbar:not(.navbar-previous):not(.stacked)').each((index, navbarEl) => {
        app.navbar.size(navbarEl);
      });
    },
    panelOpen(panel) {
      const app = this;
      if (app.theme !== 'ios') return;
      panel.$el.find('.navbar:not(.navbar-previous):not(.stacked)').each((index, navbarEl) => {
        app.navbar.size(navbarEl);
      });
    },
    panelSwipeOpen(panel) {
      const app = this;
      if (app.theme !== 'ios') return;
      panel.$el.find('.navbar:not(.navbar-previous):not(.stacked)').each((index, navbarEl) => {
        app.navbar.size(navbarEl);
      });
    },
    tabShow(tabEl) {
      const app = this;
      Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(tabEl).find('.navbar:not(.navbar-previous):not(.stacked)').each((index, navbarEl) => {
        app.navbar.size(navbarEl);
      });
    },
  },
  clicks: {
    '.navbar .title': function onTitleClick($clickedEl) {
      const app = this;
      if (!app.params.navbar.scrollTopOnTitleClick) return;
      if ($clickedEl.closest('a').length > 0) {
        return;
      }
      let pageContent;
      // Find active page
      const navbar = $clickedEl.parents('.navbar');

      // Static Layout
      pageContent = navbar.parents('.page-content');

      if (pageContent.length === 0) {
        // Fixed Layout
        if (navbar.parents('.page').length > 0) {
          pageContent = navbar.parents('.page').find('.page-content');
        }
        // Through Layout
        if (pageContent.length === 0) {
          if (navbar.nextAll('.page-current:not(.stacked)').length > 0) {
            pageContent = navbar.nextAll('.page-current:not(.stacked)').find('.page-content');
          }
        }
      }
      if (pageContent && pageContent.length > 0) {
        // Check for tab
        if (pageContent.hasClass('tab')) {
          pageContent = pageContent.parent('.tabs').children('.page-content.tab-active');
        }
        if (pageContent.length > 0) pageContent.scrollTop(0, 300);
      }
    },
  },
};

const Toolbar = {
  setHighlight(tabbarEl) {
    const app = this;
    if (app.theme !== 'md') return;

    const $tabbarEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(tabbarEl);

    if ($tabbarEl.length === 0 || !($tabbarEl.hasClass('tabbar') || $tabbarEl.hasClass('tabbar-labels'))) return;

    if ($tabbarEl.find('.tab-link-highlight').length === 0) {
      $tabbarEl.children('.toolbar-inner').append('<span class="tab-link-highlight"></span>');
    }

    const $highlightEl = $tabbarEl.find('.tab-link-highlight');
    const $activeLink = $tabbarEl.find('.tab-link-active');
    let highlightWidth;
    let highlightTranslate;

    if ($tabbarEl.hasClass('tabbar-scrollable') && $activeLink && $activeLink[0]) {
      highlightWidth = `${$activeLink[0].offsetWidth}px`;
      highlightTranslate = `${$activeLink[0].offsetLeft}px`;
    } else {
      const activeIndex = $activeLink.index();
      const tabLinksCount = $tabbarEl.find('.tab-link').length;
      highlightWidth = `${100 / tabLinksCount}%`;
      highlightTranslate = `${(app.rtl ? -activeIndex : activeIndex) * 100}%`;
    }

    $highlightEl
      .css('width', highlightWidth)
      .transform(`translate3d(${highlightTranslate},0,0)`);
  },
  init(tabbarEl) {
    const app = this;
    app.toolbar.setHighlight(tabbarEl);
  },
  hide(el, animate = true) {
    const $el = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(el);
    if ($el.hasClass('toolbar-hidden')) return;
    const className = `toolbar-hidden${animate ? ' toolbar-transitioning' : ''}`;
    $el.transitionEnd(() => {
      $el.removeClass('toolbar-transitioning');
    });
    $el.addClass(className);
  },
  show(el, animate = true) {
    const $el = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(el);
    if (!$el.hasClass('toolbar-hidden')) return;
    if (animate) {
      $el.addClass('toolbar-transitioning');
      $el.transitionEnd(() => {
        $el.removeClass('toolbar-transitioning');
      });
    }
    $el.removeClass('toolbar-hidden');
  },
  initHideToolbarOnScroll(pageEl) {
    const app = this;
    const $pageEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(pageEl);
    let $toolbarEl = $pageEl.parents('.view').children('.toolbar');
    if ($toolbarEl.length === 0) {
      $toolbarEl = $pageEl.find('.toolbar');
    }
    if ($toolbarEl.length === 0) {
      $toolbarEl = $pageEl.parents('.views').children('.tabbar, .tabbar-labels');
    }
    if ($toolbarEl.length === 0) {
      return;
    }

    let previousScrollTop;
    let currentScrollTop;

    let scrollHeight;
    let offsetHeight;
    let reachEnd;
    let action;
    let toolbarHidden;
    function handleScroll() {
      const scrollContent = this;
      if ($pageEl.hasClass('page-previous')) return;
      currentScrollTop = scrollContent.scrollTop;
      scrollHeight = scrollContent.scrollHeight;
      offsetHeight = scrollContent.offsetHeight;
      reachEnd = currentScrollTop + offsetHeight >= scrollHeight;
      toolbarHidden = $toolbarEl.hasClass('toolbar-hidden');

      if (reachEnd) {
        if (app.params.toolbar.showOnPageScrollEnd) {
          action = 'show';
        }
      } else if (previousScrollTop > currentScrollTop) {
        if (app.params.toolbar.showOnPageScrollTop || currentScrollTop <= 44) {
          action = 'show';
        } else {
          action = 'hide';
        }
      } else if (currentScrollTop > 44) {
        action = 'hide';
      } else {
        action = 'show';
      }

      if (action === 'show' && toolbarHidden) {
        app.toolbar.show($toolbarEl);
        toolbarHidden = false;
      } else if (action === 'hide' && !toolbarHidden) {
        app.toolbar.hide($toolbarEl);
        toolbarHidden = true;
      }

      previousScrollTop = currentScrollTop;
    }
    $pageEl.on('scroll', '.page-content', handleScroll, true);
    $pageEl[0].f7ScrollToolbarHandler = handleScroll;
  },
};
var Toolbar$1 = {
  name: 'toolbar',
  create() {
    const app = this;
    Utils.extend(app, {
      toolbar: {
        hide: Toolbar.hide.bind(app),
        show: Toolbar.show.bind(app),
        setHighlight: Toolbar.setHighlight.bind(app),
        initHideToolbarOnScroll: Toolbar.initHideToolbarOnScroll.bind(app),
        init: Toolbar.init.bind(app),
      },
    });
  },
  params: {
    toolbar: {
      hideOnPageScroll: false,
      showOnPageScrollEnd: true,
      showOnPageScrollTop: true,
    },
  },
  on: {
    pageBeforeRemove(page) {
      if (page.$el[0].f7ScrollToolbarHandler) {
        page.$el.off('scroll', '.page-content', page.$el[0].f7ScrollToolbarHandler, true);
      }
    },
    pageBeforeIn(page) {
      const app = this;
      let $toolbarEl = page.$el.parents('.view').children('.toolbar');
      if ($toolbarEl.length === 0) {
        $toolbarEl = page.$el.find('.toolbar');
      }
      if ($toolbarEl.length === 0) {
        $toolbarEl = page.$el.parents('.views').children('.tabbar, .tabbar-labels');
      }
      if ($toolbarEl.length === 0) {
        return;
      }
      if (page.$el.hasClass('no-toolbar')) {
        app.toolbar.hide($toolbarEl);
      } else {
        app.toolbar.show($toolbarEl);
      }
    },
    pageInit(page) {
      const app = this;
      page.$el.find('.tabbar, .tabbar-labels').each((index, tabbarEl) => {
        app.toolbar.init(tabbarEl);
      });
      if (
        app.params.toolbar.hideOnPageScroll ||
        page.$el.find('.hide-toolbar-on-scroll').length ||
        page.$el.hasClass('hide-toolbar-on-scroll') ||
        page.$el.find('.hide-bars-on-scroll').length ||
        page.$el.hasClass('hide-bars-on-scroll')
      ) {
        if (
          page.$el.find('.keep-toolbar-on-scroll').length ||
          page.$el.hasClass('keep-toolbar-on-scroll') ||
          page.$el.find('.keep-bars-on-scroll').length ||
          page.$el.hasClass('keep-bars-on-scroll')
        ) {
          return;
        }
        app.toolbar.initHideToolbarOnScroll(page.el);
      }
    },
    init() {
      const app = this;
      app.root.find('.tabbar, .tabbar-labels').each((index, tabbarEl) => {
        app.toolbar.init(tabbarEl);
      });
    },
  },
};

var Subnavbar = {
  name: 'subnavbar',
  on: {
    pageInit(page) {
      if (page.$navbarEl && page.$navbarEl.length && page.$navbarEl.find('.subnavbar').length) {
        page.$el.addClass('page-with-subnavbar');
      }
      if (page.$el.find('.subnavbar').length) {
        page.$el.addClass('page-with-subnavbar');
      }
    },
  },
};

class TouchRipple {
  constructor($el, x, y) {
    const ripple = this;
    if (!$el) return undefined;
    const box = $el[0].getBoundingClientRect();
    const center = {
      x: x - box.left,
      y: y - box.top,
    };
    const width = box.width;
    const height = box.height;
    const diameter = Math.max((((height ** 2) + (width ** 2)) ** 0.5), 48);

    ripple.$rippleWaveEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(`<div class="ripple-wave" style="width: ${diameter}px; height: ${diameter}px; margin-top:-${diameter / 2}px; margin-left:-${diameter / 2}px; left:${center.x}px; top:${center.y}px;"></div>`);

    $el.prepend(ripple.$rippleWaveEl);

    /* eslint no-underscore-dangle: ["error", { "allow": ["_clientLeft"] }] */
    ripple._clientLeft = ripple.$rippleWaveEl[0].clientLeft;

    ripple.rippleTransform = `translate3d(${-center.x + (width / 2)}px, ${-center.y + (height / 2)}px, 0) scale(1)`;

    ripple.$rippleWaveEl.transform(ripple.rippleTransform);

    return ripple;
  }
  onRemove() {
    let ripple = this;
    ripple.$rippleWaveEl.remove();
    Object.keys(ripple).forEach((key) => {
      ripple[key] = null;
      delete ripple[key];
    });
    ripple = null;
  }
  remove() {
    const ripple = this;
    if (ripple.removing) return;
    const $rippleWaveEl = this.$rippleWaveEl;
    const rippleTransform = this.rippleTransform;
    let removeTimeout = Utils.nextTick(() => {
      ripple.onRemove();
    }, 400);
    ripple.removing = true;
    $rippleWaveEl
      .addClass('ripple-wave-fill')
      .transform(rippleTransform.replace('scale(1)', 'scale(1.01)'))
      .transitionEnd(() => {
        clearTimeout(removeTimeout);
        Utils.nextFrame(() => {
          $rippleWaveEl
            .addClass('ripple-wave-out')
            .transform(rippleTransform.replace('scale(1)', 'scale(1.01)'));

          removeTimeout = Utils.nextTick(() => {
            ripple.onRemove();
          }, 700);

          $rippleWaveEl.transitionEnd(() => {
            clearTimeout(removeTimeout);
            ripple.onRemove();
          });
        });
      });
  }
}

var TouchRipple$1 = {
  name: 'touch-ripple',
  static: {
    TouchRipple,
  },
  create() {
    const app = this;
    app.touchRipple = {
      create(...args) {
        return new TouchRipple(...args);
      },
    };
  },
};

const openedModals = [];
const dialogsQueue = [];
function clearDialogsQueue() {
  if (dialogsQueue.length === 0) return;
  const dialog = dialogsQueue.shift();
  dialog.open();
}
class Modal extends Framework7Class {
  constructor(app, params) {
    super(params, [app]);

    const modal = this;

    const defaults = {};

    // Extend defaults with modules params
    modal.useModulesParams(defaults);

    modal.params = Utils.extend(defaults, params);

    // Install Modules
    modal.useModules();

    return this;
  }
  onOpen() {
    const modal = this;
    openedModals.push(modal);
    Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])('html').addClass(`with-modal-${modal.type.toLowerCase()}`);
    modal.$el.trigger(`modal:open ${modal.type.toLowerCase()}:open`, modal);
    modal.emit(`local::open modalOpen ${modal.type}Open`, modal);
  }
  onOpened() {
    const modal = this;
    modal.$el.trigger(`modal:opened ${modal.type.toLowerCase()}:opened`, modal);
    modal.emit(`local::opened modalOpened ${modal.type}Opened`, modal);
  }
  onClose() {
    const modal = this;
    if (!modal.type || !modal.$el) return;
    openedModals.splice(openedModals.indexOf(modal), 1);
    Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])('html').removeClass(`with-modal-${modal.type.toLowerCase()}`);
    modal.$el.trigger(`modal:close ${modal.type.toLowerCase()}:close`, modal);
    modal.emit(`local::close modalClose ${modal.type}Close`, modal);
  }
  onClosed() {
    const modal = this;
    if (!modal.type || !modal.$el) return;
    modal.$el.removeClass('modal-out');
    modal.$el.hide();
    modal.$el.trigger(`modal:closed ${modal.type.toLowerCase()}:closed`, modal);
    modal.emit(`local::closed modalClosed ${modal.type}Closed`, modal);
  }
  open(animateModal) {
    const modal = this;
    const app = modal.app;
    const $el = modal.$el;
    const $backdropEl = modal.$backdropEl;
    const type = modal.type;
    let animate = true;
    if (typeof animateModal !== 'undefined') animate = animateModal;
    else if (typeof modal.params.animate !== 'undefined') {
      animate = modal.params.animate;
    }

    if (!$el || $el.hasClass('modal-in')) {
      return modal;
    }

    if (type === 'dialog' && app.params.modal.queueDialogs) {
      let pushToQueue;
      if (Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])('.dialog.modal-in').length > 0) {
        pushToQueue = true;
      } else if (openedModals.length > 0) {
        openedModals.forEach((openedModal) => {
          if (openedModal.type === 'dialog') pushToQueue = true;
        });
      }
      if (pushToQueue) {
        dialogsQueue.push(modal);
        return modal;
      }
    }

    const $modalParentEl = $el.parent();
    const wasInDom = $el.parents(__WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */]).length > 0;
    if (app.params.modal.moveToRoot && !$modalParentEl.is(app.root)) {
      app.root.append($el);
      modal.once(`${type}Closed`, () => {
        if (wasInDom) {
          $modalParentEl.append($el);
        } else {
          $el.remove();
        }
      });
    }
    // Show Modal
    $el.show();

    // Set Dialog offset
    if (type === 'dialog') {
      $el.css({
        marginTop: `${-Math.round($el.outerHeight() / 2)}px`,
      });
    }

    // Emit open
    /* eslint no-underscore-dangle: ["error", { "allow": ["_clientLeft"] }] */
    modal._clientLeft = $el[0].clientLeft;

    // Backdrop
    if ($backdropEl) {
      $backdropEl[animate ? 'removeClass' : 'addClass']('not-animated');
      $backdropEl.addClass('backdrop-in');
    }
    // Modal
    function transitionEnd() {
      if ($el.hasClass('modal-out')) {
        modal.onClosed();
      } else if ($el.hasClass('modal-in')) {
        modal.onOpened();
      }
    }
    if (animate) {
      $el
        .animationEnd(() => {
          transitionEnd();
        });
      $el
        .transitionEnd(() => {
          transitionEnd();
        });
      $el
        .removeClass('modal-out not-animated')
        .addClass('modal-in');
      modal.onOpen();
    } else {
      $el.removeClass('modal-out').addClass('modal-in not-animated');
      modal.onOpen();
      modal.onOpened();
    }

    return modal;
  }
  close(animateModal) {
    const modal = this;
    const $el = modal.$el;
    const $backdropEl = modal.$backdropEl;

    let animate = true;
    if (typeof animateModal !== 'undefined') animate = animateModal;
    else if (typeof modal.params.animate !== 'undefined') {
      animate = modal.params.animate;
    }

    if (!$el || !$el.hasClass('modal-in')) {
      return modal;
    }

    // backdrop
    if ($backdropEl) {
      $backdropEl[animate ? 'removeClass' : 'addClass']('not-animated');
      $backdropEl.removeClass('backdrop-in');
    }

    // Modal
    $el[animate ? 'removeClass' : 'addClass']('not-animated');
    function transitionEnd() {
      if ($el.hasClass('modal-out')) {
        modal.onClosed();
      } else if ($el.hasClass('modal-in')) {
        modal.onOpened();
      }
    }
    if (animate) {
      $el
        .animationEnd(() => {
          transitionEnd();
        });
      $el
        .transitionEnd(() => {
          transitionEnd();
        });
      $el
        .removeClass('modal-in')
        .addClass('modal-out');
      // Emit close
      modal.onClose();
    } else {
      $el
        .addClass('not-animated')
        .removeClass('modal-in')
        .addClass('modal-out');
      // Emit close
      modal.onClose();
      modal.onClosed();
    }

    if (modal.type === 'dialog') {
      clearDialogsQueue();
    }

    return modal;
  }
  destroy() {
    const modal = this;
    if (modal.destroyed) return;
    modal.emit(`local::beforeDestroy modalBeforeDestroy ${modal.type}BeforeDestroy`, modal);
    if (modal.$el) {
      modal.$el.trigger(`modal:beforedestroy ${modal.type.toLowerCase()}:beforedestroy`, modal);
      if (modal.$el.length && modal.$el[0].f7Modal) {
        delete modal.$el[0].f7Modal;
      }
    }
    Utils.deleteProps(modal);
    modal.destroyed = true;
  }
}

class CustomModal extends Modal {
  constructor(app, params) {
    const extendedParams = Utils.extend({
      backdrop: true,
      closeByBackdropClick: true,
      on: {},
    }, params);

    // Extends with open/close Modal methods;
    super(app, extendedParams);

    const customModal = this;

    customModal.params = extendedParams;

    // Find Element
    let $el;
    if (!customModal.params.el) {
      $el = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(customModal.params.content);
    } else {
      $el = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(customModal.params.el);
    }

    if ($el && $el.length > 0 && $el[0].f7Modal) {
      return $el[0].f7Modal;
    }

    if ($el.length === 0) {
      return customModal.destroy();
    }
    let $backdropEl;
    if (customModal.params.backdrop) {
      $backdropEl = app.root.children('.custom-modal-backdrop');
      if ($backdropEl.length === 0) {
        $backdropEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])('<div class="custom-modal-backdrop"></div>');
        app.root.append($backdropEl);
      }
    }

    function handleClick(e) {
      if (!customModal || customModal.destroyed) return;
      if ($backdropEl && e.target === $backdropEl[0]) {
        customModal.close();
      }
    }

    customModal.on('customModalOpened', () => {
      if (customModal.params.closeByBackdropClick && customModal.params.backdrop) {
        app.on('click', handleClick);
      }
    });
    customModal.on('customModalClose', () => {
      if (customModal.params.closeByBackdropClick && customModal.params.backdrop) {
        app.off('click', handleClick);
      }
    });

    Utils.extend(customModal, {
      app,
      $el,
      el: $el[0],
      $backdropEl,
      backdropEl: $backdropEl && $backdropEl[0],
      type: 'customModal',
    });

    $el[0].f7Modal = customModal;

    return customModal;
  }
}

var Modal$1 = {
  name: 'modal',
  static: {
    Modal,
    CustomModal,
  },
  create() {
    const app = this;
    app.customModal = {
      create(params) {
        return new CustomModal(app, params);
      },
    };
  },
  params: {
    modal: {
      moveToRoot: true,
      queueDialogs: true,
    },
  },
};

class Dialog extends Modal {
  constructor(app, params) {
    const extendedParams = Utils.extend({
      title: app.params.dialog.title,
      text: undefined,
      content: '',
      buttons: [],
      verticalButtons: false,
      onClick: undefined,
      cssClass: undefined,
      destroyOnClose: false,
      on: {},
    }, params);
    if (typeof extendedParams.closeByBackdropClick === 'undefined') {
      extendedParams.closeByBackdropClick = app.params.dialog.closeByBackdropClick;
    }

    // Extends with open/close Modal methods;
    super(app, extendedParams);

    const dialog = this;

    const { title, text, content, buttons, verticalButtons, cssClass } = extendedParams;

    dialog.params = extendedParams;

    // Find Element
    let $el;
    if (!dialog.params.el) {
      const dialogClasses = ['dialog'];
      if (buttons.length === 0) dialogClasses.push('dialog-no-buttons');
      if (buttons.length > 0) dialogClasses.push(`dialog-buttons-${buttons.length}`);
      if (verticalButtons) dialogClasses.push('dialog-buttons-vertical');
      if (cssClass) dialogClasses.push(cssClass);

      let buttonsHTML = '';
      if (buttons.length > 0) {
        buttonsHTML = `
          <div class="dialog-buttons">
            ${buttons.map(button => `
              <span class="dialog-button${button.bold ? ' dialog-button-bold' : ''}${button.color ? ` color-${button.color}` : ''}${button.cssClass ? ` ${button.cssClass}` : ''}">${button.text}</span>
            `).join('')}
          </div>
        `;
      }

      const dialogHtml = `
        <div class="${dialogClasses.join(' ')}">
          <div class="dialog-inner">
            ${title ? `<div class="dialog-title">${title}</div>` : ''}
            ${text ? `<div class="dialog-text">${text}</div>` : ''}
            ${content}
          </div>
          ${buttonsHTML}
        </div>
      `;
      $el = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(dialogHtml);
    } else {
      $el = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(dialog.params.el);
    }

    if ($el && $el.length > 0 && $el[0].f7Modal) {
      return $el[0].f7Modal;
    }

    if ($el.length === 0) {
      return dialog.destroy();
    }

    let $backdropEl = app.root.children('.dialog-backdrop');
    if ($backdropEl.length === 0) {
      $backdropEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])('<div class="dialog-backdrop"></div>');
      app.root.append($backdropEl);
    }

    // Assign events
    function buttonOnClick(e) {
      const buttonEl = this;
      const index = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(buttonEl).index();
      const button = buttons[index];
      if (button.onClick) button.onClick(dialog, e);
      if (dialog.params.onClick) dialog.params.onClick(dialog, index);
      if (button.close !== false) dialog.close();
    }
    let addKeyboardHander;
    function onKeyPress(e) {
      const keyCode = e.keyCode;
      buttons.forEach((button, index) => {
        if (button.keyCodes && button.keyCodes.indexOf(keyCode) >= 0) {
          if (__WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */].activeElement) __WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */].activeElement.blur();
          if (button.onClick) button.onClick(dialog, e);
          if (dialog.params.onClick) dialog.params.onClick(dialog, index);
          if (button.close !== false) dialog.close();
        }
      });
    }
    if (buttons && buttons.length > 0) {
      dialog.on('open', () => {
        $el.find('.dialog-button').each((index, buttonEl) => {
          const button = buttons[index];
          if (button.keyCodes) addKeyboardHander = true;
          Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(buttonEl).on('click', buttonOnClick);
        });
        if (
          addKeyboardHander &&
          !app.device.ios &&
          !app.device.android &&
          !app.device.cordova
        ) {
          Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(__WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */]).on('keydown', onKeyPress);
        }
      });
      dialog.on('close', () => {
        $el.find('.dialog-button').each((index, buttonEl) => {
          Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(buttonEl).off('click', buttonOnClick);
        });
        if (
          addKeyboardHander &&
          !app.device.ios &&
          !app.device.android &&
          !app.device.cordova
        ) {
          Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(__WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */]).off('keydown', onKeyPress);
        }
        addKeyboardHander = false;
      });
    }
    Utils.extend(dialog, {
      app,
      $el,
      el: $el[0],
      $backdropEl,
      backdropEl: $backdropEl[0],
      type: 'dialog',
      setProgress(progress, duration) {
        app.progressbar.set($el.find('.progressbar'), progress, duration);
        return dialog;
      },
      setText(newText) {
        let $textEl = $el.find('.dialog-text');
        if ($textEl.length === 0) {
          $textEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])('<div class="dialog-text"></div>');
          if (typeof title !== 'undefined') {
            $textEl.insertAfter($el.find('.dialog-title'));
          } else {
            $el.find('.dialog-inner').prepend($textEl);
          }
        }
        $textEl.html(newText);
        dialog.params.text = newText;
        return dialog;
      },
      setTitle(newTitle) {
        let $titleEl = $el.find('.dialog-title');
        if ($titleEl.length === 0) {
          $titleEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])('<div class="dialog-title"></div>');
          $el.find('.dialog-inner').prepend($titleEl);
        }
        $titleEl.html(newTitle);
        dialog.params.title = newTitle;
        return dialog;
      },
    });

    function handleClick(e) {
      const target = e.target;
      const $target = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(target);
      if ($target.closest(dialog.el).length === 0) {
        if (
          dialog.params.closeByBackdropClick &&
          dialog.backdropEl &&
          dialog.backdropEl === target
        ) {
          dialog.close();
        }
      }
    }

    dialog.on('opened', () => {
      if (dialog.params.closeByBackdropClick) {
        app.on('click', handleClick);
      }
    });
    dialog.on('close', () => {
      if (dialog.params.closeByBackdropClick) {
        app.off('click', handleClick);
      }
    });

    $el[0].f7Modal = dialog;

    if (dialog.params.destroyOnClose) {
      dialog.once('closed', () => {
        setTimeout(() => {
          dialog.destroy();
        }, 0);
      });
    }

    return dialog;
  }
}

function ConstructorMethods (parameters = {}) {
  const {
    defaultSelector,
    constructor,
    domProp,
    app,
    addMethods,
  } = parameters;
  const methods = {
    create(...args) {
      if (app) return new constructor(app, ...args);
      return new constructor(...args);
    },
    get(el = defaultSelector) {
      if (el instanceof constructor) return el;
      const $el = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(el);
      if ($el.length === 0) return undefined;
      return $el[0][domProp];
    },
    destroy(el) {
      const instance = methods.get(el);
      if (instance && instance.destroy) return instance.destroy();
      return undefined;
    },
  };
  if (addMethods && Array.isArray(addMethods)) {
    addMethods.forEach((methodName) => {
      methods[methodName] = (el = defaultSelector, ...args) => {
        const instance = methods.get(el);
        if (instance && instance[methodName]) return instance[methodName](...args);
        return undefined;
      };
    });
  }
  return methods;
}

function ModalMethods (parameters = {}) {
  const { defaultSelector, constructor, app } = parameters;
  const methods = Utils.extend(
    ConstructorMethods({
      defaultSelector,
      constructor,
      app,
      domProp: 'f7Modal',
    }),
    {
      open(el, animate) {
        const $el = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(el);
        let instance = $el[0].f7Modal;
        if (!instance) instance = new constructor(app, { el: $el });
        return instance.open(animate);
      },
      close(el = defaultSelector, animate) {
        const $el = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(el);
        if ($el.length === 0) return undefined;
        let instance = $el[0].f7Modal;
        if (!instance) instance = new constructor(app, { el: $el });
        return instance.close(animate);
      },
    }
  );
  return methods;
}

var Dialog$1 = {
  name: 'dialog',
  params: {
    dialog: {
      title: undefined,
      buttonOk: 'OK',
      buttonCancel: 'Cancel',
      usernamePlaceholder: 'Username',
      passwordPlaceholder: 'Password',
      preloaderTitle: 'Loading... ',
      progressTitle: 'Loading... ',
      closeByBackdropClick: false,
      destroyPredefinedDialogs: true,
      keyboardActions: true,
    },
  },
  static: {
    Dialog,
  },
  create() {
    const app = this;
    const defaultDialogTitle = app.params.dialog.title || app.name;
    const destroyOnClose = app.params.dialog.destroyPredefinedDialogs;
    const keyboardActions = app.params.dialog.keyboardActions;
    app.dialog = Utils.extend(
      ModalMethods({
        app,
        constructor: Dialog,
        defaultSelector: '.dialog.modal-in',
      }),
      {
        // Shortcuts
        alert(...args) {
          let [text, title, callbackOk] = args;
          if (args.length === 2 && typeof args[1] === 'function') {
            [text, callbackOk, title] = args;
          }
          return new Dialog(app, {
            title: typeof title === 'undefined' ? defaultDialogTitle : title,
            text,
            buttons: [{
              text: app.params.dialog.buttonOk,
              bold: true,
              onClick: callbackOk,
              keyCodes: keyboardActions ? [13, 27] : null,
            }],
            destroyOnClose,
          }).open();
        },
        prompt(...args) {
          let [text, title, callbackOk, callbackCancel] = args;
          if (typeof args[1] === 'function') {
            [text, callbackOk, callbackCancel, title] = args;
          }
          return new Dialog(app, {
            title: typeof title === 'undefined' ? defaultDialogTitle : title,
            text,
            content: '<div class="dialog-input-field item-input"><div class="item-input-wrap"><input type="text" class="dialog-input"></div></div>',
            buttons: [
              {
                text: app.params.dialog.buttonCancel,
                keyCodes: keyboardActions ? [27] : null,
              },
              {
                text: app.params.dialog.buttonOk,
                bold: true,
                keyCodes: keyboardActions ? [13] : null,
              },
            ],
            onClick(dialog, index) {
              const inputValue = dialog.$el.find('.dialog-input').val();
              if (index === 0 && callbackCancel) callbackCancel(inputValue);
              if (index === 1 && callbackOk) callbackOk(inputValue);
            },
            destroyOnClose,
          }).open();
        },
        confirm(...args) {
          let [text, title, callbackOk, callbackCancel] = args;
          if (typeof args[1] === 'function') {
            [text, callbackOk, callbackCancel, title] = args;
          }
          return new Dialog(app, {
            title: typeof title === 'undefined' ? defaultDialogTitle : title,
            text,
            buttons: [
              {
                text: app.params.dialog.buttonCancel,
                onClick: callbackCancel,
                keyCodes: keyboardActions ? [27] : null,
              },
              {
                text: app.params.dialog.buttonOk,
                bold: true,
                onClick: callbackOk,
                keyCodes: keyboardActions ? [13] : null,
              },
            ],
            destroyOnClose,
          }).open();
        },
        login(...args) {
          let [text, title, callbackOk, callbackCancel] = args;
          if (typeof args[1] === 'function') {
            [text, callbackOk, callbackCancel, title] = args;
          }
          return new Dialog(app, {
            title: typeof title === 'undefined' ? defaultDialogTitle : title,
            text,
            content: `
              <div class="dialog-input-field dialog-input-double item-input">
                <div class="item-input-wrap">
                  <input type="text" name="dialog-username" placeholder="${app.params.dialog.usernamePlaceholder}" class="dialog-input">
                </div>
              </div>
              <div class="dialog-input-field dialog-input-double item-input">
                <div class="item-input-wrap">
                  <input type="password" name="dialog-password" placeholder="${app.params.dialog.passwordPlaceholder}" class="dialog-input">
                </div>
              </div>`,
            buttons: [
              {
                text: app.params.dialog.buttonCancel,
                keyCodes: keyboardActions ? [27] : null,
              },
              {
                text: app.params.dialog.buttonOk,
                bold: true,
                keyCodes: keyboardActions ? [13] : null,
              },
            ],
            onClick(dialog, index) {
              const username = dialog.$el.find('[name="dialog-username"]').val();
              const password = dialog.$el.find('[name="dialog-password"]').val();
              if (index === 0 && callbackCancel) callbackCancel(username, password);
              if (index === 1 && callbackOk) callbackOk(username, password);
            },
            destroyOnClose,
          }).open();
        },
        password(...args) {
          let [text, title, callbackOk, callbackCancel] = args;
          if (typeof args[1] === 'function') {
            [text, callbackOk, callbackCancel, title] = args;
          }
          return new Dialog(app, {
            title: typeof title === 'undefined' ? defaultDialogTitle : title,
            text,
            content: `
              <div class="dialog-input-field item-input">
                <div class="item-input-wrap">
                  <input type="password" name="dialog-password" placeholder="${app.params.dialog.passwordPlaceholder}" class="dialog-input">
                </div>
              </div>`,
            buttons: [
              {
                text: app.params.dialog.buttonCancel,
                keyCodes: keyboardActions ? [27] : null,
              },
              {
                text: app.params.dialog.buttonOk,
                bold: true,
                keyCodes: keyboardActions ? [13] : null,
              },
            ],
            onClick(dialog, index) {
              const password = dialog.$el.find('[name="dialog-password"]').val();
              if (index === 0 && callbackCancel) callbackCancel(password);
              if (index === 1 && callbackOk) callbackOk(password);
            },
            destroyOnClose,
          }).open();
        },
        preloader(title) {
          const preloaderInner = app.theme !== 'md' ? '' : Utils.mdPreloaderContent;
          return new Dialog(app, {
            title: typeof title === 'undefined' ? app.params.dialog.preloaderTitle : title,
            content: `<div class="preloader">${preloaderInner}</div>`,
            cssClass: 'dialog-preloader',
            destroyOnClose,
          }).open();
        },
        progress(...args) {
          let [title, progress, color] = args;
          if (args.length === 2) {
            if (typeof args[0] === 'number') {
              [progress, color, title] = args;
            } else if (typeof args[0] === 'string' && typeof args[1] === 'string') {
              [title, color, progress] = args;
            }
          } else if (args.length === 1) {
            if (typeof args[0] === 'number') {
              [progress, title, color] = args;
            }
          }
          const infinite = typeof progress === 'undefined';
          const dialog = new Dialog(app, {
            title: typeof title === 'undefined' ? app.params.dialog.progressTitle : title,
            cssClass: 'dialog-progress',
            content: `
              <div class="progressbar${infinite ? '-infinite' : ''}${color ? ` color-${color}` : ''}">
                ${!infinite ? '<span></span>' : ''}
              </div>
            `,
            destroyOnClose,
          });
          if (!infinite) dialog.setProgress(progress);
          return dialog.open();
        },
      }
    );
  },
};

class Popup extends Modal {
  constructor(app, params) {
    const extendedParams = Utils.extend(
      { on: {} },
      app.params.popup,
      params
    );

    // Extends with open/close Modal methods;
    super(app, extendedParams);

    const popup = this;

    popup.params = extendedParams;

    // Find Element
    let $el;
    if (!popup.params.el) {
      $el = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(popup.params.content);
    } else {
      $el = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(popup.params.el);
    }

    if ($el && $el.length > 0 && $el[0].f7Modal) {
      return $el[0].f7Modal;
    }

    if ($el.length === 0) {
      return popup.destroy();
    }

    let $backdropEl;
    if (popup.params.backdrop) {
      $backdropEl = app.root.children('.popup-backdrop');
      if ($backdropEl.length === 0) {
        $backdropEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])('<div class="popup-backdrop"></div>');
        app.root.append($backdropEl);
      }
    }

    Utils.extend(popup, {
      app,
      $el,
      el: $el[0],
      $backdropEl,
      backdropEl: $backdropEl && $backdropEl[0],
      type: 'popup',
    });

    function handleClick(e) {
      const target = e.target;
      const $target = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(target);
      if ($target.closest(popup.el).length === 0) {
        if (
          popup.params &&
          popup.params.closeByBackdropClick &&
          popup.params.backdrop &&
          popup.backdropEl &&
          popup.backdropEl === target
        ) {
          popup.close();
        }
      }
    }

    popup.on('popupOpened', () => {
      if (popup.params.closeByBackdropClick) {
        app.on('click', handleClick);
      }
    });
    popup.on('popupClose', () => {
      if (popup.params.closeByBackdropClick) {
        app.off('click', handleClick);
      }
    });

    $el[0].f7Modal = popup;

    return popup;
  }
}

var Popup$1 = {
  name: 'popup',
  params: {
    popup: {
      backdrop: true,
      closeByBackdropClick: true,
    },
  },
  static: {
    Popup,
  },
  create() {
    const app = this;
    app.popup = ModalMethods({
      app,
      constructor: Popup,
      defaultSelector: '.popup.modal-in',
    });
  },
  clicks: {
    '.popup-open': function openPopup($clickedEl, data = {}) {
      const app = this;
      app.popup.open(data.popup, data.animate);
    },
    '.popup-close': function closePopup($clickedEl, data = {}) {
      const app = this;
      app.popup.close(data.popup, data.animate);
    },
  },
};

class LoginScreen extends Modal {
  constructor(app, params) {
    const extendedParams = Utils.extend({
      on: {},
    }, params);

    // Extends with open/close Modal methods;
    super(app, extendedParams);

    const loginScreen = this;

    loginScreen.params = extendedParams;

    // Find Element
    let $el;
    if (!loginScreen.params.el) {
      $el = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(loginScreen.params.content);
    } else {
      $el = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(loginScreen.params.el);
    }

    if ($el && $el.length > 0 && $el[0].f7Modal) {
      return $el[0].f7Modal;
    }

    if ($el.length === 0) {
      return loginScreen.destroy();
    }

    Utils.extend(loginScreen, {
      app,
      $el,
      el: $el[0],
      type: 'loginScreen',
    });

    $el[0].f7Modal = loginScreen;

    return loginScreen;
  }
}

var LoginScreen$1 = {
  name: 'loginScreen',
  static: {
    LoginScreen,
  },
  create() {
    const app = this;
    app.loginScreen = ModalMethods({
      app,
      constructor: LoginScreen,
      defaultSelector: '.login-screen.modal-in',
    });
  },
  clicks: {
    '.login-screen-open': function openLoginScreen($clickedEl, data = {}) {
      const app = this;
      app.loginScreen.open(data.loginScreen, data.animate);
    },
    '.login-screen-close': function closeLoginScreen($clickedEl, data = {}) {
      const app = this;
      app.loginScreen.close(data.loginScreen, data.animate);
    },
  },
};

class Popover extends Modal {
  constructor(app, params) {
    const extendedParams = Utils.extend(
      { on: {} },
      app.params.popover,
      params
    );

    // Extends with open/close Modal methods;
    super(app, extendedParams);

    const popover = this;

    popover.params = extendedParams;

    // Find Element
    let $el;
    if (!popover.params.el) {
      $el = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(popover.params.content);
    } else {
      $el = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(popover.params.el);
    }

    if ($el && $el.length > 0 && $el[0].f7Modal) {
      return $el[0].f7Modal;
    }

    // Find Target
    const $targetEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(popover.params.targetEl).eq(0);

    if ($el.length === 0) {
      return popover.destroy();
    }

    // Backdrop
    let $backdropEl;
    if (popover.params.backdrop) {
      $backdropEl = app.root.children('.popover-backdrop');
      if ($backdropEl.length === 0) {
        $backdropEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])('<div class="popover-backdrop"></div>');
        app.root.append($backdropEl);
      }
    }

    // Find Angle
    let $angleEl;
    if ($el.find('.popover-angle').length === 0) {
      $angleEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])('<div class="popover-angle"></div>');
      $el.prepend($angleEl);
    } else {
      $angleEl = $el.find('.popover-angle');
    }

    // Open
    const originalOpen = popover.open;

    Utils.extend(popover, {
      app,
      $el,
      el: $el[0],
      $targetEl,
      targetEl: $targetEl[0],
      $angleEl,
      angleEl: $angleEl[0],
      $backdropEl,
      backdropEl: $backdropEl && $backdropEl[0],
      type: 'popover',
      open(...args) {
        let [targetEl, animate] = args;
        if (typeof args[0] === 'boolean') [animate, targetEl] = args;
        if (targetEl) {
          popover.$targetEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(targetEl);
          popover.targetEl = popover.$targetEl[0];
        }
        originalOpen.call(popover, animate);
      },
    });

    function handleResize() {
      popover.resize();
    }
    popover.on('popoverOpen', () => {
      popover.resize();
      app.on('resize', handleResize);
      popover.on('popoverClose popoverBeforeDestroy', () => {
        app.off('resize', handleResize);
      });
    });

    function handleClick(e) {
      const target = e.target;
      const $target = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(target);
      if ($target.closest(popover.el).length === 0) {
        if (
          popover.params.closeByBackdropClick &&
          popover.params.backdrop &&
          popover.backdropEl &&
          popover.backdropEl === target
        ) {
          popover.close();
        } else if (popover.params.closeByOutsideClick) {
          popover.close();
        }
      }
    }

    popover.on('popoverOpened', () => {
      if (popover.params.closeByOutsideClick || popover.params.closeByBackdropClick) {
        app.on('click', handleClick);
      }
    });
    popover.on('popoverClose', () => {
      if (popover.params.closeByOutsideClick || popover.params.closeByBackdropClick) {
        app.off('click', handleClick);
      }
    });

    $el[0].f7Modal = popover;

    return popover;
  }
  resize() {
    const popover = this;
    const { app, $el, $targetEl, $angleEl } = popover;
    const { targetX, targetY } = popover.params;
    $el.css({ left: '', top: '' });
    const [width, height] = [$el.width(), $el.height()];
    let angleSize = 0;
    let angleLeft;
    let angleTop;
    if (app.theme === 'ios') {
      $angleEl.removeClass('on-left on-right on-top on-bottom').css({ left: '', top: '' });
      angleSize = $angleEl.width() / 2;
    } else {
      $el.removeClass('popover-on-left popover-on-right popover-on-top popover-on-bottom').css({ left: '', top: '' });
    }

    let targetWidth;
    let targetHeight;
    let targetOffsetLeft;
    let targetOffsetTop;
    if ($targetEl && $targetEl.length > 0) {
      targetWidth = $targetEl.outerWidth();
      targetHeight = $targetEl.outerHeight();

      const targetOffset = $targetEl.offset();
      targetOffsetLeft = targetOffset.left - app.left;
      targetOffsetTop = targetOffset.top - app.top;

      const targetParentPage = $targetEl.parents('.page');
      if (targetParentPage.length > 0) {
        targetOffsetTop -= targetParentPage[0].scrollTop;
      }
    } else if (typeof targetX !== 'undefined' && targetY !== 'undefined') {
      targetOffsetLeft = targetX;
      targetOffsetTop = targetY;
      targetWidth = popover.params.targetWidth || 0;
      targetHeight = popover.params.targetHeight || 0;
    }

    let [left, top, diff] = [0, 0, 0];
    // Top Position
    let position = app.theme === 'md' ? 'bottom' : 'top';
    if (app.theme === 'md') {
      if (height < app.height - targetOffsetTop - targetHeight) {
        // On bottom
        position = 'bottom';
        top = targetOffsetTop;
      } else if (height < targetOffsetTop) {
        // On top
        top = (targetOffsetTop - height) + targetHeight;
        position = 'top';
      } else {
        // On middle
        position = 'bottom';
        top = targetOffsetTop;
      }

      if (top <= 0) {
        top = 8;
      } else if (top + height >= app.height) {
        top = app.height - height - 8;
      }

      // Horizontal Position
      left = (targetOffsetLeft + targetWidth) - width - 8;
      if (left + width >= app.width - 8) {
        left = (targetOffsetLeft + targetWidth) - width - 8;
      }
      if (left < 8) {
        left = 8;
      }
      if (position === 'top') {
        $el.addClass('popover-on-top');
      }
      if (position === 'bottom') {
        $el.addClass('popover-on-bottom');
      }
    } else {
      if ((height + angleSize) < targetOffsetTop) {
        // On top
        top = targetOffsetTop - height - angleSize;
      } else if ((height + angleSize) < app.height - targetOffsetTop - targetHeight) {
        // On bottom
        position = 'bottom';
        top = targetOffsetTop + targetHeight + angleSize;
      } else {
        // On middle
        position = 'middle';
        top = ((targetHeight / 2) + targetOffsetTop) - (height / 2);
        diff = top;
        if (top <= 0) {
          top = 5;
        } else if (top + height >= app.height) {
          top = app.height - height - 5;
        }
        diff -= top;
      }

      // Horizontal Position
      if (position === 'top' || position === 'bottom') {
        left = ((targetWidth / 2) + targetOffsetLeft) - (width / 2);
        diff = left;
        if (left < 5) left = 5;
        if (left + width > app.width) left = app.width - width - 5;
        if (left < 0) left = 0;
        if (position === 'top') {
          $angleEl.addClass('on-bottom');
        }
        if (position === 'bottom') {
          $angleEl.addClass('on-top');
        }
        diff -= left;
        angleLeft = ((width / 2) - angleSize) + diff;
        angleLeft = Math.max(Math.min(angleLeft, width - (angleSize * 2) - 13), 13);
        $angleEl.css({ left: `${angleLeft}px` });
      } else if (position === 'middle') {
        left = targetOffsetLeft - width - angleSize;
        $angleEl.addClass('on-right');
        if (left < 5 || (left + width > app.width)) {
          if (left < 5) left = targetOffsetLeft + targetWidth + angleSize;
          if (left + width > app.width) left = app.width - width - 5;
          $angleEl.removeClass('on-right').addClass('on-left');
        }
        angleTop = ((height / 2) - angleSize) + diff;
        angleTop = Math.max(Math.min(angleTop, height - (angleSize * 2) - 13), 13);
        $angleEl.css({ top: `${angleTop}px` });
      }
    }

    // Apply Styles
    $el.css({ top: `${top}px`, left: `${left}px` });
  }
}

var Popover$1 = {
  name: 'popover',
  params: {
    popover: {
      closeByBackdropClick: true,
      closeByOutsideClick: false,
      backdrop: true,
    },
  },
  static: {
    Popover,
  },
  create() {
    const app = this;
    app.popover = Utils.extend(
      ModalMethods({
        app,
        constructor: Popover,
        defaultSelector: '.popover.modal-in',
      }),
      {
        open(popoverEl, targetEl, animate) {
          const $popoverEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(popoverEl);
          let popover = $popoverEl[0].f7Modal;
          if (!popover) popover = new Popover(app, { el: $popoverEl, targetEl });
          return popover.open(targetEl, animate);
        },
      }
    );
  },
  clicks: {
    '.popover-open': function openPopover($clickedEl, data = {}) {
      const app = this;
      app.popover.open(data.popover, $clickedEl, data.animate);
    },
    '.popover-close': function closePopover($clickedEl, data = {}) {
      const app = this;
      app.popover.close(data.popover, data.animate);
    },
  },
};

/* eslint indent: ["off"] */

class Actions extends Modal {
  constructor(app, params) {
    const extendedParams = Utils.extend(
      { on: {} },
      app.params.actions,
      params
    );

    // Extends with open/close Modal methods;
    super(app, extendedParams);

    const actions = this;

    actions.params = extendedParams;

    // Buttons
    let groups;
    if (actions.params.buttons) {
      groups = actions.params.buttons;
      if (!Array.isArray(groups[0])) groups = [groups];
    }
    actions.groups = groups;

    // Find Element
    let $el;
    if (actions.params.el) {
      $el = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(actions.params.el);
    } else if (actions.params.content) {
      $el = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(actions.params.content);
    } else if (actions.params.buttons) {
      if (actions.params.convertToPopover) {
        actions.popoverHtml = actions.renderPopover();
      }
      actions.actionsHtml = actions.render();
    }

    if ($el && $el.length > 0 && $el[0].f7Modal) {
      return $el[0].f7Modal;
    }

    if ($el && $el.length === 0 && !(actions.actionsHtml || actions.popoverHtml)) {
      return actions.destroy();
    }

    // Backdrop
    let $backdropEl;
    if (actions.params.backdrop) {
      $backdropEl = app.root.children('.actions-backdrop');
      if ($backdropEl.length === 0) {
        $backdropEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])('<div class="actions-backdrop"></div>');
        app.root.append($backdropEl);
      }
    }

    const originalOpen = actions.open;
    const originalClose = actions.close;

    let popover;
    function buttonOnClick(e) {
      const buttonEl = this;
      let buttonIndex;
      let groupIndex;
      if (Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(buttonEl).hasClass('item-link')) {
        buttonIndex = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(buttonEl).parents('li').index();
        groupIndex = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(buttonEl).parents('.list').index();
      } else {
        buttonIndex = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(buttonEl).index();
        groupIndex = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(buttonEl).parents('.actions-group').index();
      }
      if (typeof groups !== 'undefined') {
        const button = groups[groupIndex][buttonIndex];
        if (button.onClick) button.onClick(actions, e);
        if (actions.params.onClick) actions.params.onClick(actions, e);
        if (button.close !== false) actions.close();
      }
    }
    actions.open = function open(animate) {
      let convertToPopover = false;
      const { targetEl, targetX, targetY, targetWidth, targetHeight } = actions.params;
      if (actions.params.convertToPopover && (targetEl || (targetX !== undefined && targetY !== undefined))) {
        // Popover
        if (
          actions.params.forceToPopover ||
          (app.device.ios && app.device.ipad) ||
          app.width >= 768
        ) {
          convertToPopover = true;
        }
      }
      if (convertToPopover && actions.popoverHtml) {
        popover = app.popover.create({
          content: actions.popoverHtml,
          backdrop: actions.params.backdrop,
          targetEl,
          targetX,
          targetY,
          targetWidth,
          targetHeight,
        });
        popover.open(animate);
        popover.once('popoverOpened', () => {
          popover.$el.find('.item-link').each((groupIndex, buttonEl) => {
            Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(buttonEl).on('click', buttonOnClick);
          });
        });
        popover.once('popoverClosed', () => {
          popover.$el.find('.item-link').each((groupIndex, buttonEl) => {
            Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(buttonEl).off('click', buttonOnClick);
          });
          Utils.nextTick(() => {
            popover.destroy();
            popover = undefined;
          });
        });
      } else {
        actions.$el = actions.actionsHtml ? Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(actions.actionsHtml) : actions.$el;
        actions.$el[0].f7Modal = actions;
        if (actions.groups) {
          actions.$el.find('.actions-button').each((groupIndex, buttonEl) => {
            Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(buttonEl).on('click', buttonOnClick);
          });
          actions.once('actionsClosed', () => {
            actions.$el.find('.actions-button').each((groupIndex, buttonEl) => {
              Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(buttonEl).off('click', buttonOnClick);
            });
          });
        }
        originalOpen.call(actions, animate);
      }
      return actions;
    };

    actions.close = function close(animate) {
      if (popover) {
        popover.close(animate);
      } else {
        originalClose.call(actions, animate);
      }
      return actions;
    };

    Utils.extend(actions, {
      app,
      $el,
      el: $el ? $el[0] : undefined,
      $backdropEl,
      backdropEl: $backdropEl && $backdropEl[0],
      type: 'actions',
    });

    function handleClick(e) {
      const target = e.target;
      const $target = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(target);
      if ($target.closest(actions.el).length === 0) {
        if (
          actions.params.closeByBackdropClick &&
          actions.params.backdrop &&
          actions.backdropEl &&
          actions.backdropEl === target
        ) {
          actions.close();
        } else if (actions.params.closeByOutsideClick) {
          actions.close();
        }
      }
    }

    actions.on('opened', () => {
      if (actions.params.closeByBackdropClick || actions.params.closeByOutsideClick) {
        app.on('click', handleClick);
      }
    });
    actions.on('close', () => {
      if (actions.params.closeByBackdropClick || actions.params.closeByOutsideClick) {
        app.off('click', handleClick);
      }
    });

    if ($el) {
      $el[0].f7Modal = actions;
    }

    return actions;
  }
  render() {
    const actions = this;
    if (actions.params.render) return actions.params.render.call(actions, actions);
    const { groups } = actions;
    return `
      <div class="actions-modal${actions.params.grid ? ' actions-grid' : ''}">
        ${groups.map(group =>
          `<div class="actions-group">
            ${group.map((button) => {
              const buttonClasses = [`actions-${button.label ? 'label' : 'button'}`];
              const { color, bg, bold, disabled, label, text, icon } = button;
              if (color) buttonClasses.push(`color-${color}`);
              if (bg) buttonClasses.push(`bg-color-${bg}`);
              if (bold) buttonClasses.push('actions-button-bold');
              if (disabled) buttonClasses.push('disabled');
              if (label) {
                return `<div class="${buttonClasses.join(' ')}">${text}</div>`;
              }
              return `
                <div class="${buttonClasses.join(' ')}">
                  ${icon ? `<div class="actions-button-media">${icon}</div>` : ''}
                  <div class="actions-button-text">${text}</div>
                </div>`.trim();
            }).join('')}
          </div>`).join('')}
      </div>
    `.trim();
  }
  renderPopover() {
    const actions = this;
    if (actions.params.renderPopover) return actions.params.renderPopover.call(actions, actions);
    const { groups } = actions;
    return `
      <div class="popover popover-from-actions">
        <div class="popover-inner">
          ${groups.map(group => `
            <div class="list">
              <ul>
                ${group.map((button) => {
                  const itemClasses = [];
                  const { color, bg, bold, disabled, label, text, icon } = button;
                  if (color) itemClasses.push(`color-${color}`);
                  if (bg) itemClasses.push(`bg-color-${bg}`);
                  if (bold) itemClasses.push('popover-from-actions-bold');
                  if (disabled) itemClasses.push('disabled');
                  if (label) {
                    itemClasses.push('popover-from-actions-label');
                    return `<li class="${itemClasses.join(' ')}">${text}</li>`;
                  }
                  itemClasses.push('item-link');
                  if (icon) {
                    itemClasses.push('item-content');
                    return `
                      <li>
                        <a class="${itemClasses.join(' ')}">
                          <div class="item-media">
                            ${icon}
                          </div>
                          <div class="item-inner">
                            <div class="item-title">
                              ${text}
                            </div>
                          </div>
                        </a>
                      </li>
                    `;
                  }
                  itemClasses.push('list-button');
                  return `
                    <li>
                      <a href="#" class="list-button ${itemClasses.join(' ')}">${text}</a>
                    </li>
                  `;
                }).join('')}
              </ul>
            </div>
          `).join('')}
        </div>
      </div>
    `.trim();
  }
}

var Actions$1 = {
  name: 'actions',
  params: {
    actions: {
      convertToPopover: true,
      forceToPopover: false,
      closeByBackdropClick: true,
      render: null,
      renderPopover: null,
      backdrop: true,
    },
  },
  static: {
    Actions,
  },
  create() {
    const app = this;
    app.actions = ModalMethods({
      app,
      constructor: Actions,
      defaultSelector: '.actions-modal.modal-in',
    });
  },
  clicks: {
    '.actions-open': function openActions($clickedEl, data = {}) {
      const app = this;
      app.actions.open(data.actions, data.animate);
    },
    '.actions-close': function closeActions($clickedEl, data = {}) {
      const app = this;
      app.actions.close(data.actions, data.animate);
    },
  },
};

class Sheet extends Modal {
  constructor(app, params) {
    const extendedParams = Utils.extend(
      { on: {} },
      app.params.sheet,
      params
    );

    // Extends with open/close Modal methods;
    super(app, extendedParams);

    const sheet = this;

    sheet.params = extendedParams;

    // Find Element
    let $el;
    if (!sheet.params.el) {
      $el = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(sheet.params.content);
    } else {
      $el = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(sheet.params.el);
    }

    if ($el && $el.length > 0 && $el[0].f7Modal) {
      return $el[0].f7Modal;
    }

    if ($el.length === 0) {
      return sheet.destroy();
    }
    let $backdropEl;
    if (sheet.params.backdrop) {
      $backdropEl = app.root.children('.sheet-backdrop');
      if ($backdropEl.length === 0) {
        $backdropEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])('<div class="sheet-backdrop"></div>');
        app.root.append($backdropEl);
      }
    }

    let $pageContentEl;
    function scrollToOpen() {
      const $scrollEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(sheet.params.scrollToEl).eq(0);
      if ($scrollEl.length === 0) return;
      $pageContentEl = $scrollEl.parents('.page-content');
      if ($pageContentEl.length === 0) return;

      const paddingTop = parseInt($pageContentEl.css('padding-top'), 10);
      const paddingBottom = parseInt($pageContentEl.css('padding-bottom'), 10);
      const pageHeight = $pageContentEl[0].offsetHeight - paddingTop - $el.height();
      const pageScrollHeight = $pageContentEl[0].scrollHeight - paddingTop - $el.height();
      const pageScroll = $pageContentEl.scrollTop();

      let newPaddingBottom;

      const scrollElTop = ($scrollEl.offset().top - paddingTop) + $scrollEl[0].offsetHeight;
      if (scrollElTop > pageHeight) {
        const scrollTop = (pageScroll + scrollElTop) - pageHeight;
        if (scrollTop + pageHeight > pageScrollHeight) {
          newPaddingBottom = ((scrollTop + pageHeight) - pageScrollHeight) + paddingBottom;
          if (pageHeight === pageScrollHeight) {
            newPaddingBottom = $el.height();
          }
          $pageContentEl.css({
            'padding-bottom': `${newPaddingBottom}px`,
          });
        }
        $pageContentEl.scrollTop(scrollTop, 300);
      }
    }

    function scrollToClose() {
      if ($pageContentEl && $pageContentEl.length > 0) {
        $pageContentEl.css({
          'padding-bottom': '',
        });
      }
    }
    function handleClick(e) {
      const target = e.target;
      const $target = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(target);
      if ($target.closest(sheet.el).length === 0) {
        if (
          sheet.params.closeByBackdropClick &&
          sheet.params.backdrop &&
          sheet.backdropEl &&
          sheet.backdropEl === target
        ) {
          sheet.close();
        } else if (sheet.params.closeByOutsideClick) {
          sheet.close();
        }
      }
    }

    sheet.on('sheetOpen', () => {
      if (sheet.params.scrollToEl) {
        scrollToOpen();
      }
    });
    sheet.on('sheetOpened', () => {
      if (sheet.params.closeByOutsideClick || sheet.params.closeByBackdropClick) {
        app.on('click', handleClick);
      }
    });
    sheet.on('sheetClose', () => {
      if (sheet.params.scrollToEl) {
        scrollToClose();
      }
      if (sheet.params.closeByOutsideClick || sheet.params.closeByBackdropClick) {
        app.off('click', handleClick);
      }
    });

    Utils.extend(sheet, {
      app,
      $el,
      el: $el[0],
      $backdropEl,
      backdropEl: $backdropEl && $backdropEl[0],
      type: 'sheet',
    });

    $el[0].f7Modal = sheet;

    return sheet;
  }
}

var Sheet$1 = {
  name: 'sheet',
  params: {
    sheet: {
      closeByBackdropClick: true,
      closeByOutsideClick: false,
    },
  },
  static: {
    Sheet,
  },
  create() {
    const app = this;
    if (!app.passedParams.sheet || app.passedParams.sheet.backdrop === undefined) {
      app.params.sheet.backdrop = app.theme === 'md';
    }
    app.sheet = Utils.extend(
      {},
      ModalMethods({
        app,
        constructor: Sheet,
        defaultSelector: '.sheet-modal.modal-in',
      })
    );
  },
  clicks: {
    '.sheet-open': function openSheet($clickedEl, data = {}) {
      const app = this;
      if (Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])('.sheet-modal.modal-in').length > 0 && data.sheet && Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(data.sheet)[0] !== Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])('.sheet-modal.modal-in')[0]) {
        app.sheet.close('.sheet-modal.modal-in');
      }
      app.sheet.open(data.sheet, data.animate);
    },
    '.sheet-close': function closeSheet($clickedEl, data = {}) {
      const app = this;
      app.sheet.close(data.sheet, data.animate);
    },
  },
};

class Toast extends Modal {
  constructor(app, params) {
    const extendedParams = Utils.extend({
      on: {},
    }, app.params.toast, params);

    // Extends with open/close Modal methods;
    super(app, extendedParams);

    const toast = this;

    toast.app = app;

    toast.params = extendedParams;

    const { closeButton, closeTimeout } = toast.params;

    let $el;
    if (!toast.params.el) {
      // Find Element
      const toastHtml = toast.render();

      $el = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(toastHtml);
    } else {
      $el = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(toast.params.el);
    }

    if ($el && $el.length > 0 && $el[0].f7Modal) {
      return $el[0].f7Modal;
    }

    if ($el.length === 0) {
      return toast.destroy();
    }

    Utils.extend(toast, {
      $el,
      el: $el[0],
      type: 'toast',
    });

    $el[0].f7Modal = toast;

    if (closeButton) {
      $el.find('.toast-button').on('click', () => {
        toast.emit('local::closeButtonClick toastCloseButtonClick', toast);
        toast.close();
      });

      toast.on('beforeDestroy', () => {
        $el.find('.toast-button').off('click');
      });
    }

    let timeoutId;
    toast.on('open', () => {
      Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])('.toast.modal-in').each((index, openedEl) => {
        const toastInstance = app.toast.get(openedEl);
        if (openedEl !== toast.el && toastInstance) {
          toastInstance.close();
        }
      });
      if (closeTimeout) {
        timeoutId = Utils.nextTick(() => {
          toast.close();
        }, closeTimeout);
      }
    });
    toast.on('close', () => {
      __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].clearTimeout(timeoutId);
    });

    if (toast.params.destroyOnClose) {
      toast.once('closed', () => {
        setTimeout(() => {
          toast.destroy();
        }, 0);
      });
    }

    return toast;
  }
  render() {
    const toast = this;
    const app = toast.app;
    if (toast.params.render) return toast.params.render.call(toast, toast);
    const { position, cssClass, icon, text, closeButton, closeButtonColor, closeButtonText } = toast.params;
    return `
      <div class="toast toast-${position} ${cssClass || ''} ${icon ? 'toast-with-icon' : ''}">
        <div class="toast-content">
          ${icon ? `<div class="toast-icon">${icon}</div>` : ''}
          <div class="toast-text">${text}</div>
          ${closeButton && !icon ? `
          <a class="toast-button ${app.theme === 'md' ? 'button' : 'link'} ${closeButtonColor ? `color-${closeButtonColor}` : ''}">${closeButtonText}</a>
          `.trim() : ''}
        </div>
      </div>
    `.trim();
  }
}

var Toast$1 = {
  name: 'toast',
  static: {
    Toast,
  },
  create() {
    const app = this;
    app.toast = Utils.extend(
      {},
      ModalMethods({
        app,
        constructor: Toast,
        defaultSelector: '.toast.modal-in',
      }),
      {
        // Shortcuts
        show(params) {
          Utils.extend(params, {
            destroyOnClose: true,
          });
          return new Toast(app, params).open();
        },
      }
    );
  },
  params: {
    toast: {
      icon: null,
      text: null,
      position: 'bottom',
      closeButton: false,
      closeButtonColor: null,
      closeButtonText: 'Ok',
      closeTimeout: null,
      cssClass: null,
      render: null,
    },
  },
};

const Preloader = {
  init(el) {
    const app = this;
    if (app.theme !== 'md') return;
    const $el = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(el);
    if ($el.length === 0 || $el.children('.preloader-inner').length > 0) return;
    $el.append(Utils.mdPreloaderContent);
  },
  // Modal
  visible: false,
  show(color = 'white') {
    const app = this;
    if (Preloader.visible) return;
    const preloaderInner = app.theme !== 'md' ? '' : Utils.mdPreloaderContent;
    Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])('html').addClass('with-modal-preloader');
    app.root.append(`
      <div class="preloader-backdrop"></div>
      <div class="preloader-modal">
        <div class="preloader color-${color}">${preloaderInner}</div>
      </div>
    `);
    Preloader.visible = true;
  },
  hide() {
    const app = this;
    if (!Preloader.visible) return;
    Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])('html').removeClass('with-modal-preloader');
    app.root.find('.preloader-backdrop, .preloader-modal').remove();
    Preloader.visible = false;
  },
};
var Preloader$1 = {
  name: 'preloader',
  create() {
    const app = this;
    Utils.extend(app, {
      preloader: {
        init: Preloader.init.bind(app),
        show: Preloader.show.bind(app),
        hide: Preloader.hide.bind(app),
      },
    });
  },
  on: {
    photoBrowserOpen(pb) {
      const app = this;
      if (app.theme !== 'md') return;
      pb.$el.find('.preloader').each((index, preloaderEl) => {
        app.preloader.init(preloaderEl);
      });
    },
    pageInit(page) {
      const app = this;
      if (app.theme !== 'md') return;
      page.$el.find('.preloader').each((index, preloaderEl) => {
        app.preloader.init(preloaderEl);
      });
    },
  },
};

const Progressbar = {
  set(...args) {
    const app = this;
    let [el, progress, duration] = args;
    if (typeof args[0] === 'number') {
      [progress, duration] = args;
      el = app.root;
    }
    if (typeof progress === 'undefined' || progress === null) return el;
    if (!progress) progress = 0;

    const $el = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(el || app.root);
    if ($el.length === 0) {
      return el;
    }
    const progressNormalized = Math.min(Math.max(progress, 0), 100);
    let $progressbarEl;
    if ($el.hasClass('progressbar')) $progressbarEl = $el.eq(0);
    else {
      $progressbarEl = $el.children('.progressbar');
    }
    if ($progressbarEl.length === 0 || $progressbarEl.hasClass('progressbar-infinite')) {
      return $progressbarEl;
    }
    let $progressbarLine = $progressbarEl.children('span');
    if ($progressbarLine.length === 0) {
      $progressbarLine = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])('<span></span>');
      $progressbarEl.append($progressbarLine);
    }
    $progressbarLine
      .transition(typeof duration !== 'undefined' ? duration : '')
      .transform(`translate3d(${(-100 + progressNormalized)}%,0,0)`);

    return $progressbarEl[0];
  },
  show(...args) {
    const app = this;

    // '.page', 50, 'multi'
    let [el, progress, color] = args;
    let type = 'determined';

    if (args.length === 2) {
      if ((typeof args[0] === 'string' || typeof args[0] === 'object') && typeof args[1] === 'string') {
        // '.page', 'multi'
        [el, color, progress] = args;
        type = 'infinite';
      } else if (typeof args[0] === 'number' && typeof args[1] === 'string') {
        // 50, 'multi'
        [progress, color] = args;
        el = app.root;
      }
    } else if (args.length === 1) {
      if (typeof args[0] === 'number') {
        el = app.root;
        progress = args[0];
      } else if (typeof args[0] === 'string') {
        type = 'infinite';
        el = app.root;
        color = args[0];
      }
    } else if (args.length === 0) {
      type = 'infinite';
      el = app.root;
    }

    const $el = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(el);
    if ($el.length === 0) return undefined;

    let $progressbarEl;
    if ($el.hasClass('progressbar') || $el.hasClass('progressbar-infinite')) {
      $progressbarEl = $el;
    } else {
      $progressbarEl = $el.children('.progressbar:not(.progressbar-out), .progressbar-infinite:not(.progressbar-out)');
      if ($progressbarEl.length === 0) {
        $progressbarEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(`
          <span class="progressbar${type === 'infinite' ? '-infinite' : ''}${color ? ` color-${color}` : ''} progressbar-in">
            ${type === 'infinite' ? '' : '<span></span>'}
          </span>`);
        $el.append($progressbarEl);
      }
    }

    if (typeof progress !== 'undefined') {
      app.progressbar.set($progressbarEl, progress);
    }

    return $progressbarEl[0];
  },
  hide(el, removeAfterHide = true) {
    const app = this;
    const $el = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(el || app.root);
    if ($el.length === 0) return undefined;
    let $progressbarEl;
    if ($el.hasClass('progressbar') || $el.hasClass('progressbar-infinite')) {
      $progressbarEl = $el;
    } else {
      $progressbarEl = $el.children('.progressbar, .progressbar-infinite');
    }
    if ($progressbarEl.length === 0 || !$progressbarEl.hasClass('progressbar-in') || $progressbarEl.hasClass('progressbar-out')) {
      return $progressbarEl;
    }
    $progressbarEl
      .removeClass('progressbar-in')
      .addClass('progressbar-out')
      .animationEnd(() => {
        if (removeAfterHide) {
          $progressbarEl.remove();
        }
      });
    return $progressbarEl;
  },
};

var Progressbar$1 = {
  name: 'progressbar',
  create() {
    const app = this;
    Utils.extend(app, {
      progressbar: {
        set: Progressbar.set.bind(app),
        show: Progressbar.show.bind(app),
        hide: Progressbar.hide.bind(app),
      },
    });
  },
  on: {
    pageInit(page) {
      const app = this;
      page.$el.find('.progressbar').each((index, progressbarEl) => {
        const $progressbarEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(progressbarEl);
        app.progressbar.set($progressbarEl, $progressbarEl.attr('data-progress'));
      });
    },
  },
};

const Sortable = {
  init() {
    const app = this;
    let isTouched;
    let isMoved;
    let touchStartY;
    let touchesDiff;
    let $sortingEl;
    let $sortingItems;
    let $sortableContainer;
    let sortingElHeight;
    let minTop;
    let maxTop;
    let $insertAfterEl;
    let $insertBeforeEl;
    let indexFrom;
    let $pageEl;
    let $pageContentEl;
    let pageHeight;
    let pageOffset;
    let sortingElOffsetLocal;
    let sortingElOffsetTop;
    let initialScrollTop;

    function handleTouchStart(e) {
      isMoved = false;
      isTouched = true;
      touchStartY = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
      $sortingEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(this).parent('li');
      indexFrom = $sortingEl.index();
      $sortableContainer = $sortingEl.parents('.sortable');
      const $listGroup = $sortingEl.parents('.list-group');
      if ($listGroup.length && $listGroup.parents($sortableContainer).length) {
        $sortableContainer = $listGroup;
      }
      $sortingItems = $sortableContainer.children('ul').children('li');
      if (app.panel) app.panel.allowOpen = false;
      if (app.swipeout) app.swipeout.allow = false;
    }
    function handleTouchMove(e) {
      if (!isTouched || !$sortingEl) return;
      const pageY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
      if (!isMoved) {
        $pageEl = $sortingEl.parents('.page');
        $pageContentEl = $sortingEl.parents('.page-content');
        const paddingTop = parseInt($pageContentEl.css('padding-top'), 10);
        const paddingBottom = parseInt($pageContentEl.css('padding-bottom'), 10);
        initialScrollTop = $pageContentEl[0].scrollTop;
        pageOffset = $pageEl.offset().top + paddingTop;
        pageHeight = $pageEl.height() - paddingTop - paddingBottom;
        $sortingEl.addClass('sorting');
        $sortableContainer.addClass('sortable-sorting');
        sortingElOffsetLocal = $sortingEl[0].offsetTop;
        minTop = $sortingEl[0].offsetTop;
        maxTop = $sortingEl.parent().height() - sortingElOffsetLocal - $sortingEl.height();
        sortingElHeight = $sortingEl[0].offsetHeight;
        sortingElOffsetTop = $sortingEl.offset().top;
      }
      isMoved = true;

      e.preventDefault();
      e.f7PreventSwipePanel = true;

      touchesDiff = pageY - touchStartY;

      const translateScrollOffset = $pageContentEl[0].scrollTop - initialScrollTop;
      const translate = Math.min(Math.max(touchesDiff + translateScrollOffset, -minTop), maxTop);
      $sortingEl.transform(`translate3d(0,${translate}px,0)`);

      const scrollAddition = 44;
      let allowScroll = true;
      if ((touchesDiff + translateScrollOffset) + scrollAddition < -minTop) {
        allowScroll = false;
      }
      if ((touchesDiff + translateScrollOffset) - scrollAddition > maxTop) {
        allowScroll = false;
      }

      $insertBeforeEl = undefined;
      $insertAfterEl = undefined;

      let scrollDiff;
      if (allowScroll) {
        if (sortingElOffsetTop + touchesDiff + sortingElHeight + scrollAddition > pageOffset + pageHeight) {
          // To Bottom
          scrollDiff = (sortingElOffsetTop + touchesDiff + sortingElHeight + scrollAddition) - (pageOffset + pageHeight);
        }
        if (sortingElOffsetTop + touchesDiff < pageOffset + scrollAddition) {
          // To Top
          scrollDiff = (sortingElOffsetTop + touchesDiff) - pageOffset - scrollAddition;
        }
        if (scrollDiff) {
          $pageContentEl[0].scrollTop += scrollDiff;
        }
      }

      $sortingItems.each((index, el) => {
        const $currentEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(el);
        if ($currentEl[0] === $sortingEl[0]) return;
        const currentElOffset = $currentEl[0].offsetTop;
        const currentElHeight = $currentEl.height();
        const sortingElOffset = sortingElOffsetLocal + translate;

        if ((sortingElOffset >= currentElOffset - (currentElHeight / 2)) && $sortingEl.index() < $currentEl.index()) {
          $currentEl.transform(`translate3d(0, ${-sortingElHeight}px,0)`);
          $insertAfterEl = $currentEl;
          $insertBeforeEl = undefined;
        } else if ((sortingElOffset <= currentElOffset + (currentElHeight / 2)) && $sortingEl.index() > $currentEl.index()) {
          $currentEl.transform(`translate3d(0, ${sortingElHeight}px,0)`);
          $insertAfterEl = undefined;
          if (!$insertBeforeEl) $insertBeforeEl = $currentEl;
        } else {
          $currentEl.transform('translate3d(0, 0%,0)');
        }
      });
    }
    function handleTouchEnd() {
      if (!isTouched || !isMoved) {
        isTouched = false;
        isMoved = false;
        if (isTouched && !isMoved) {
          if (app.panel) app.panel.allowOpen = true;
          if (app.swipeout) app.swipeout.allow = true;
        }
        return;
      }
      if (app.panel) app.panel.allowOpen = true;
      if (app.swipeout) app.swipeout.allow = true;

      $sortingItems.transform('');
      $sortingEl.removeClass('sorting');
      $sortableContainer.removeClass('sortable-sorting');

      let virtualList;
      let oldIndex;
      let newIndex;
      if ($insertAfterEl) {
        $sortingEl.insertAfter($insertAfterEl);
      }
      if ($insertBeforeEl) {
        $sortingEl.insertBefore($insertBeforeEl);
      }

      $sortingEl.trigger('sortable:sort', { from: indexFrom, to: $sortingEl.index() });
      app.emit('sortableSort', $sortingEl[0], { from: indexFrom, to: $sortingEl.index() });

      if (($insertAfterEl || $insertBeforeEl) && $sortableContainer.hasClass('virtual-list')) {
        virtualList = $sortableContainer[0].f7VirtualList;
        oldIndex = $sortingEl[0].f7VirtualListIndex;
        newIndex = $insertBeforeEl ? $insertBeforeEl[0].f7VirtualListIndex : $insertAfterEl[0].f7VirtualListIndex;
        if (virtualList) virtualList.moveItem(oldIndex, newIndex);
      }
      $insertBeforeEl = undefined;
      $insertAfterEl = undefined;
      isTouched = false;
      isMoved = false;
    }

    const activeListener = app.support.passiveListener ? { passive: false, capture: false } : false;

    Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(__WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */]).on(app.touchEvents.start, '.list.sortable .sortable-handler', handleTouchStart, activeListener);
    app.on('touchmove:active', handleTouchMove);
    app.on('touchend:passive', handleTouchEnd);
  },
  enable(el = '.list.sortable') {
    const app = this;
    const $el = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(el);
    if ($el.length === 0) return;
    $el.addClass('sortable-enabled');
    $el.trigger('sortable:enable');
    app.emit('sortableEnable', $el[0]);
  },
  disable(el = '.list.sortable') {
    const app = this;
    const $el = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(el);
    if ($el.length === 0) return;
    $el.removeClass('sortable-enabled');
    $el.trigger('sortable:disable');
    app.emit('sortableDisable', $el[0]);
  },
  toggle(el = '.list.sortable') {
    const app = this;
    const $el = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(el);
    if ($el.length === 0) return;
    if ($el.hasClass('sortable-enabled')) {
      app.sortable.disable($el);
    } else {
      app.sortable.enable($el);
    }
  },
};
var Sortable$1 = {
  name: 'sortable',
  params: {
    sortable: true,
  },
  create() {
    const app = this;
    Utils.extend(app, {
      sortable: {
        init: Sortable.init.bind(app),
        enable: Sortable.enable.bind(app),
        disable: Sortable.disable.bind(app),
        toggle: Sortable.toggle.bind(app),
      },
    });
  },
  on: {
    init() {
      const app = this;
      if (app.params.sortable) app.sortable.init();
    },
  },
  clicks: {
    '.sortable-enable': function enable($clickedEl, data = {}) {
      const app = this;
      app.sortable.enable(data.sortable);
    },
    '.sortable-disable': function disable($clickedEl, data = {}) {
      const app = this;
      app.sortable.disable(data.sortable);
    },
    '.sortable-toggle': function toggle($clickedEl, data = {}) {
      const app = this;
      app.sortable.toggle(data.sortable);
    },
  },
};

const Swipeout = {
  init() {
    const app = this;
    const touchesStart = {};
    let isTouched;
    let isMoved;
    let isScrolling;
    let touchStartTime;
    let touchesDiff;
    let $swipeoutEl;
    let $swipeoutContent;
    let $actionsRight;
    let $actionsLeft;
    let actionsLeftWidth;
    let actionsRightWidth;
    let translate;
    let opened;
    let openedActionsSide;
    let $leftButtons;
    let $rightButtons;
    let direction;
    let $overswipeLeftButton;
    let $overswipeRightButton;
    let overswipeLeft;
    let overswipeRight;

    function handleTouchStart(e) {
      if (!Swipeout.allow) return;
      isMoved = false;
      isTouched = true;
      isScrolling = undefined;
      touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
      touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
      touchStartTime = (new Date()).getTime();
      $swipeoutEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(this);
    }
    function handleTouchMove(e) {
      if (!isTouched) return;
      const pageX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
      const pageY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
      if (typeof isScrolling === 'undefined') {
        isScrolling = !!(isScrolling || Math.abs(pageY - touchesStart.y) > Math.abs(pageX - touchesStart.x));
      }
      if (isScrolling) {
        isTouched = false;
        return;
      }

      if (!isMoved) {
        if (Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])('.list.sortable-opened').length > 0) return;
        $swipeoutContent = $swipeoutEl.find('.swipeout-content');
        $actionsRight = $swipeoutEl.find('.swipeout-actions-right');
        $actionsLeft = $swipeoutEl.find('.swipeout-actions-left');
        actionsLeftWidth = null;
        actionsRightWidth = null;
        $leftButtons = null;
        $rightButtons = null;
        $overswipeRightButton = null;
        $overswipeLeftButton = null;
        if ($actionsLeft.length > 0) {
          actionsLeftWidth = $actionsLeft.outerWidth();
          $leftButtons = $actionsLeft.children('a');
          $overswipeLeftButton = $actionsLeft.find('.swipeout-overswipe');
        }
        if ($actionsRight.length > 0) {
          actionsRightWidth = $actionsRight.outerWidth();
          $rightButtons = $actionsRight.children('a');
          $overswipeRightButton = $actionsRight.find('.swipeout-overswipe');
        }
        opened = $swipeoutEl.hasClass('swipeout-opened');
        if (opened) {
          openedActionsSide = $swipeoutEl.find('.swipeout-actions-left.swipeout-actions-opened').length > 0 ? 'left' : 'right';
        }
        $swipeoutEl.removeClass('swipeout-transitioning');
        if (!app.params.swipeout.noFollow) {
          $swipeoutEl.find('.swipeout-actions-opened').removeClass('swipeout-actions-opened');
          $swipeoutEl.removeClass('swipeout-opened');
        }
      }
      isMoved = true;
      e.preventDefault();

      touchesDiff = pageX - touchesStart.x;
      translate = touchesDiff;

      if (opened) {
        if (openedActionsSide === 'right') translate -= actionsRightWidth;
        else translate += actionsLeftWidth;
      }

      if (
        (translate > 0 && $actionsLeft.length === 0)
        ||
        (translate < 0 && $actionsRight.length === 0)
      ) {
        if (!opened) {
          isTouched = false;
          isMoved = false;
          $swipeoutContent.transform('');
          if ($rightButtons && $rightButtons.length > 0) {
            $rightButtons.transform('');
          }
          if ($leftButtons && $leftButtons.length > 0) {
            $leftButtons.transform('');
          }
          return;
        }
        translate = 0;
      }

      if (translate < 0) direction = 'to-left';
      else if (translate > 0) direction = 'to-right';
      else if (!direction) direction = 'to-left';

      let buttonOffset;
      let progress;

      e.f7PreventSwipePanel = true;
      if (app.params.swipeout.noFollow) {
        if (opened) {
          if (openedActionsSide === 'right' && touchesDiff > 0) {
            app.swipeout.close($swipeoutEl);
          }
          if (openedActionsSide === 'left' && touchesDiff < 0) {
            app.swipeout.close($swipeoutEl);
          }
        } else {
          if (touchesDiff < 0 && $actionsRight.length > 0) {
            app.swipeout.open($swipeoutEl, 'right');
          }
          if (touchesDiff > 0 && $actionsLeft.length > 0) {
            app.swipeout.open($swipeoutEl, 'left');
          }
        }
        isTouched = false;
        isMoved = false;
        return;
      }
      overswipeLeft = false;
      overswipeRight = false;
      if ($actionsRight.length > 0) {
        // Show right actions
        let buttonTranslate = translate;
        progress = buttonTranslate / actionsRightWidth;
        if (buttonTranslate < -actionsRightWidth) {
          buttonTranslate = -actionsRightWidth - ((-buttonTranslate - actionsRightWidth) ** 0.8);
          translate = buttonTranslate;
          if ($overswipeRightButton.length > 0) {
            overswipeRight = true;
          }
        }
        if (direction !== 'to-left') {
          progress = 0;
          buttonTranslate = 0;
        }
        $rightButtons.each((index, buttonEl) => {
          const $buttonEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(buttonEl);
          if (typeof buttonEl.f7SwipeoutButtonOffset === 'undefined') {
            $buttonEl[0].f7SwipeoutButtonOffset = buttonEl.offsetLeft;
          }
          buttonOffset = buttonEl.f7SwipeoutButtonOffset;
          if ($overswipeRightButton.length > 0 && $buttonEl.hasClass('swipeout-overswipe') && direction === 'to-left') {
            $buttonEl.css({ left: `${overswipeRight ? -buttonOffset : 0}px` });
            if (overswipeRight) {
              $buttonEl.addClass('swipeout-overswipe-active');
            } else {
              $buttonEl.removeClass('swipeout-overswipe-active');
            }
          }
          $buttonEl.transform(`translate3d(${buttonTranslate - (buttonOffset * (1 + Math.max(progress, -1)))}px,0,0)`);
        });
      }
      if ($actionsLeft.length > 0) {
        // Show left actions
        let buttonTranslate = translate;
        progress = buttonTranslate / actionsLeftWidth;
        if (buttonTranslate > actionsLeftWidth) {
          buttonTranslate = actionsLeftWidth + ((buttonTranslate - actionsLeftWidth) ** 0.8);
          translate = buttonTranslate;
          if ($overswipeLeftButton.length > 0) {
            overswipeLeft = true;
          }
        }
        if (direction !== 'to-right') {
          buttonTranslate = 0;
          progress = 0;
        }
        $leftButtons.each((index, buttonEl) => {
          const $buttonEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(buttonEl);
          if (typeof buttonEl.f7SwipeoutButtonOffset === 'undefined') {
            $buttonEl[0].f7SwipeoutButtonOffset = actionsLeftWidth - buttonEl.offsetLeft - buttonEl.offsetWidth;
          }
          buttonOffset = buttonEl.f7SwipeoutButtonOffset;
          if ($overswipeLeftButton.length > 0 && $buttonEl.hasClass('swipeout-overswipe') && direction === 'to-right') {
            $buttonEl.css({ left: `${overswipeLeft ? buttonOffset : 0}px` });
            if (overswipeLeft) {
              $buttonEl.addClass('swipeout-overswipe-active');
            } else {
              $buttonEl.removeClass('swipeout-overswipe-active');
            }
          }
          if ($leftButtons.length > 1) {
            $buttonEl.css('z-index', $leftButtons.length - index);
          }
          $buttonEl.transform(`translate3d(${buttonTranslate + (buttonOffset * (1 - Math.min(progress, 1)))}px,0,0)`);
        });
      }
      $swipeoutEl.trigger('swipeout', progress);
      app.emit('swipeout', $swipeoutEl[0], progress);
      $swipeoutContent.transform(`translate3d(${translate}px,0,0)`);
    }
    function handleTouchEnd() {
      if (!isTouched || !isMoved) {
        isTouched = false;
        isMoved = false;
        return;
      }

      isTouched = false;
      isMoved = false;
      const timeDiff = (new Date()).getTime() - touchStartTime;
      const $actions = direction === 'to-left' ? $actionsRight : $actionsLeft;
      const actionsWidth = direction === 'to-left' ? actionsRightWidth : actionsLeftWidth;
      let action;
      let $buttons;
      let i;

      if (
        (
          timeDiff < 300
          &&
          (
            (touchesDiff < -10 && direction === 'to-left')
            ||
            (touchesDiff > 10 && direction === 'to-right')
          )
        )
        ||
        (
          timeDiff >= 300
          &&
          (Math.abs(translate) > actionsWidth / 2)
        )
      ) {
        action = 'open';
      } else {
        action = 'close';
      }
      if (timeDiff < 300) {
        if (Math.abs(translate) === 0) action = 'close';
        if (Math.abs(translate) === actionsWidth) action = 'open';
      }

      if (action === 'open') {
        Swipeout.el = $swipeoutEl[0];
        $swipeoutEl.trigger('swipeout:open');
        app.emit('swipeoutOpen', $swipeoutEl[0]);
        $swipeoutEl.addClass('swipeout-opened swipeout-transitioning');
        const newTranslate = direction === 'to-left' ? -actionsWidth : actionsWidth;
        $swipeoutContent.transform(`translate3d(${newTranslate}px,0,0)`);
        $actions.addClass('swipeout-actions-opened');
        $buttons = direction === 'to-left' ? $rightButtons : $leftButtons;
        if ($buttons) {
          for (i = 0; i < $buttons.length; i += 1) {
            Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])($buttons[i]).transform(`translate3d(${newTranslate}px,0,0)`);
          }
        }
        if (overswipeRight) {
          $actionsRight.find('.swipeout-overswipe')[0].click();
        }
        if (overswipeLeft) {
          $actionsLeft.find('.swipeout-overswipe')[0].click();
        }
      } else {
        $swipeoutEl.trigger('swipeout:close');
        app.emit('swipeoutClose', $swipeoutEl[0]);
        Swipeout.el = undefined;
        $swipeoutEl.addClass('swipeout-transitioning').removeClass('swipeout-opened');
        $swipeoutContent.transform('');
        $actions.removeClass('swipeout-actions-opened');
      }

      let buttonOffset;
      if ($leftButtons && $leftButtons.length > 0 && $leftButtons !== $buttons) {
        $leftButtons.each((index, buttonEl) => {
          const $buttonEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(buttonEl);
          buttonOffset = buttonEl.f7SwipeoutButtonOffset;
          if (typeof buttonOffset === 'undefined') {
            $buttonEl[0].f7SwipeoutButtonOffset = actionsLeftWidth - buttonEl.offsetLeft - buttonEl.offsetWidth;
          }
          $buttonEl.transform(`translate3d(${buttonOffset}px,0,0)`);
        });
      }
      if ($rightButtons && $rightButtons.length > 0 && $rightButtons !== $buttons) {
        $rightButtons.each((index, buttonEl) => {
          const $buttonEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(buttonEl);
          buttonOffset = buttonEl.f7SwipeoutButtonOffset;
          if (typeof buttonOffset === 'undefined') {
            $buttonEl[0].f7SwipeoutButtonOffset = buttonEl.offsetLeft;
          }
          $buttonEl.transform(`translate3d(${-buttonOffset}px,0,0)`);
        });
      }
      $swipeoutContent.transitionEnd(() => {
        if ((opened && action === 'open') || (!opened && action === 'close')) return;
        $swipeoutEl.trigger(action === 'open' ? 'swipeout:opened' : 'swipeout:closed');
        app.emit(action === 'open' ? 'swipeoutOpened' : 'swipeoutClosed', $swipeoutEl[0]);
        $swipeoutEl.removeClass('swipeout-transitioning');
        if (opened && action === 'close') {
          if ($actionsRight.length > 0) {
            $rightButtons.transform('');
          }
          if ($actionsLeft.length > 0) {
            $leftButtons.transform('');
          }
        }
      });
    }

    const passiveListener = app.support.passiveListener ? { passive: true } : false;

    app.on('touchstart', (e) => {
      if (Swipeout.el) {
        const $targetEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(e.target);
        if (!(
          Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(Swipeout.el).is($targetEl[0]) ||
          $targetEl.parents('.swipeout').is(Swipeout.el) ||
          $targetEl.hasClass('modal-in') ||
          ($targetEl.attr('class') || '').indexOf('-backdrop') > 0 ||
          $targetEl.hasClass('actions-modal') ||
          $targetEl.parents('.actions-modal.modal-in, .dialog.modal-in').length > 0
        )) {
          app.swipeout.close(Swipeout.el);
        }
      }
    });
    Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(__WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */]).on(app.touchEvents.start, 'li.swipeout', handleTouchStart, passiveListener);
    app.on('touchmove:active', handleTouchMove);
    app.on('touchend:passive', handleTouchEnd);
  },
  allow: true,
  el: undefined,
  open(...args) {
    const app = this;
    let [el, side, callback] = args;
    if (typeof args[1] === 'function') {
      [el, callback, side] = args;
    }
    const $el = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(el).eq(0);

    if ($el.length === 0) return;
    if (!$el.hasClass('swipeout') || $el.hasClass('swipeout-opened')) return;
    if (!side) {
      if ($el.find('.swipeout-actions-right').length > 0) side = 'right';
      else side = 'left';
    }
    const $swipeoutActions = $el.find(`.swipeout-actions-${side}`);
    const $swipeoutContent = $el.find('.swipeout-content');
    if ($swipeoutActions.length === 0) return;
    $el.trigger('swipeout:open').addClass('swipeout-opened').removeClass('swipeout-transitioning');
    app.emit('swipeoutOpen', $el[0]);
    $swipeoutActions.addClass('swipeout-actions-opened');
    const $buttons = $swipeoutActions.children('a');
    const swipeoutActionsWidth = $swipeoutActions.outerWidth();
    const translate = side === 'right' ? -swipeoutActionsWidth : swipeoutActionsWidth;
    if ($buttons.length > 1) {
      $buttons.each((buttonIndex, buttonEl) => {
        const $buttonEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(buttonEl);
        if (side === 'right') {
          $buttonEl.transform(`translate3d(${-buttonEl.offsetLeft}px,0,0)`);
        } else {
          $buttonEl.css('z-index', $buttons.length - buttonIndex).transform(`translate3d(${swipeoutActionsWidth - buttonEl.offsetWidth - buttonEl.offsetLeft}px,0,0)`);
        }
      });
    }
    $el.addClass('swipeout-transitioning');
    $swipeoutContent.transitionEnd(() => {
      $el.trigger('swipeout:opened');
      app.emit('swipeoutOpened', $el[0]);
      if (callback) callback.call($el[0]);
    });
    Utils.nextFrame(() => {
      $buttons.transform(`translate3d(${translate}px,0,0)`);
      $swipeoutContent.transform(`translate3d(${translate}px,0,0)`);
    });
    Swipeout.el = $el[0];
  },
  close(el, callback) {
    const app = this;
    const $el = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(el).eq(0);
    if ($el.length === 0) return;
    if (!$el.hasClass('swipeout-opened')) return;
    const side = $el.find('.swipeout-actions-opened').hasClass('swipeout-actions-right') ? 'right' : 'left';
    const $swipeoutActions = $el.find('.swipeout-actions-opened').removeClass('swipeout-actions-opened');
    const $buttons = $swipeoutActions.children('a');
    const swipeoutActionsWidth = $swipeoutActions.outerWidth();
    Swipeout.allow = false;
    $el.trigger('swipeout:close');
    app.emit('swipeoutClose', $el[0]);
    $el.removeClass('swipeout-opened').addClass('swipeout-transitioning');

    let closeTimeout;
    function onSwipeoutClose() {
      Swipeout.allow = true;
      if ($el.hasClass('swipeout-opened')) return;
      $el.removeClass('swipeout-transitioning');
      $buttons.transform('');
      $el.trigger('swipeout:closed');
      app.emit('swipeoutClosed', $el[0]);
      if (callback) callback.call($el[0]);
      if (closeTimeout) clearTimeout(closeTimeout);
    }
    $el.find('.swipeout-content').transform('').transitionEnd(onSwipeoutClose);
    closeTimeout = setTimeout(onSwipeoutClose, 500);

    $buttons.each((index, buttonEl) => {
      const $buttonEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(buttonEl);
      if (side === 'right') {
        $buttonEl.transform(`translate3d(${-buttonEl.offsetLeft}px,0,0)`);
      } else {
        $buttonEl.transform(`translate3d(${swipeoutActionsWidth - buttonEl.offsetWidth - buttonEl.offsetLeft}px,0,0)`);
      }
      $buttonEl.css({ left: '0px' }).removeClass('swipeout-overswipe-active');
    });
    if (Swipeout.el && Swipeout.el === $el[0]) Swipeout.el = undefined;
  },
  delete(el, callback) {
    const app = this;
    const $el = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(el).eq(0);
    if ($el.length === 0) return;
    Swipeout.el = undefined;
    $el.trigger('swipeout:delete');
    app.emit('swipeoutDelete', $el[0]);
    $el.css({ height: `${$el.outerHeight()}px` });
    $el.transitionEnd(() => {
      $el.trigger('swipeout:deleted');
      app.emit('swipeoutDeleted', $el[0]);
      if (callback) callback.call($el[0]);
      if ($el.parents('.virtual-list').length > 0) {
        const virtualList = $el.parents('.virtual-list')[0].f7VirtualList;
        const virtualIndex = $el[0].f7VirtualListIndex;
        if (virtualList && typeof virtualIndex !== 'undefined') virtualList.deleteItem(virtualIndex);
      } else if (app.params.swipeout.removeElements) {
        if (app.params.swipeout.removeElementsWithTimeout) {
          setTimeout(() => {
            $el.remove();
          }, app.params.swipeout.removeElementsTimeout);
        } else {
          $el.remove();
        }
      } else {
        $el.removeClass('swipeout-deleting swipeout-transitioning');
      }
    });
    // eslint-disable-next-line
    $el[0]._clientLeft = $el[0].clientLeft;
    $el
      .addClass('swipeout-deleting swipeout-transitioning')
      .css({ height: '0px' })
      .find('.swipeout-content')
      .transform('translate3d(-100%,0,0)');
  },
};
var Swipeout$1 = {
  name: 'swipeout',
  params: {
    swipeout: {
      actionsNoFold: false,
      noFollow: false,
      removeElements: true,
      removeElementsWithTimeout: false,
      removeElementsTimeout: 0,
    },
  },
  create() {
    const app = this;
    Utils.extend(app, {
      swipeout: {
        init: Swipeout.init.bind(app),
        open: Swipeout.open.bind(app),
        close: Swipeout.close.bind(app),
        delete: Swipeout.delete.bind(app),
      },
    });
    Object.defineProperty(app.swipeout, 'el', {
      enumerable: true,
      configurable: true,
      get: () => Swipeout.el,
      set(el) {
        Swipeout.el = el;
      },
    });
    Object.defineProperty(app.swipeout, 'allow', {
      enumerable: true,
      configurable: true,
      get: () => Swipeout.allow,
      set(allow) {
        Swipeout.allow = allow;
      },
    });
  },
  clicks: {
    '.swipeout-open': function openSwipeout($clickedEl, data = {}) {
      const app = this;
      app.swipeout.open(data.swipeout, data.side);
    },
    '.swipeout-close': function closeSwipeout($clickedEl) {
      const app = this;
      const $swipeoutEl = $clickedEl.closest('.swipeout');
      if ($swipeoutEl.length === 0) return;
      app.swipeout.close($swipeoutEl);
    },
    '.swipeout-delete': function deleteSwipeout($clickedEl, data = {}) {
      const app = this;
      const $swipeoutEl = $clickedEl.closest('.swipeout');
      if ($swipeoutEl.length === 0) return;
      const { confirm, confirmTitle } = data;
      if (data.confirm) {
        app.dialog.confirm(confirm, confirmTitle, () => {
          app.swipeout.delete($swipeoutEl);
        });
      } else {
        app.swipeout.delete($swipeoutEl);
      }
    },
  },
  on: {
    init() {
      const app = this;
      if (!app.params.swipeout) return;
      app.swipeout.init();
    },
  },
};

/* eslint no-underscore-dangle: ["error", { "allow": ["_clientLeft"] }] */

const Accordion = {
  toggleClicked($clickedEl) {
    const app = this;
    let $accordionItemEl = $clickedEl.closest('.accordion-item').eq(0);
    if (!$accordionItemEl.length) $accordionItemEl = $clickedEl.parents('li').eq(0);
    if ($clickedEl.parents('li').length > 1 && $clickedEl.parents('li')[0] !== $accordionItemEl[0]) return;
    app.accordion.toggle($accordionItemEl);
  },
  open(el) {
    const app = this;
    const $el = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(el);
    const $list = $el.parents('.accordion-list').eq(0);
    let $contentEl = $el.children('.accordion-item-content');
    if ($contentEl.length === 0) $contentEl = $el.find('.accordion-item-content');
    if ($contentEl.length === 0) return;
    const $openedItem = $list.length > 0 && $el.parent().children('.accordion-item-opened');
    if ($openedItem.length > 0) {
      app.accordion.close($openedItem);
    }
    $contentEl.transitionEnd(() => {
      if ($el.hasClass('accordion-item-opened')) {
        $contentEl.transition(0);
        $contentEl.css('height', 'auto');
        $contentEl._clientLeft = $contentEl[0].clientLeft;
        $contentEl.transition('');
        $el.trigger('accordion:opened');
        app.emit('accordionOpened', $el[0]);
      } else {
        $contentEl.css('height', '');
        $el.trigger('accordion:closed');
        app.emit('accordionClosed', $el[0]);
      }
    });
    $contentEl.css('height', `${$contentEl[0].scrollHeight}px`);
    $el.trigger('accordion:open');
    $el.addClass('accordion-item-opened');
    app.emit('accordionOpen', $el[0]);
  },
  close(el) {
    const app = this;
    const $el = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(el);
    let $contentEl = $el.children('.accordion-item-content');
    if ($contentEl.length === 0) $contentEl = $el.find('.accordion-item-content');
    $el.removeClass('accordion-item-opened');
    $contentEl.transition(0);
    $contentEl.css('height', `${$contentEl[0].scrollHeight}px`);
    $contentEl._clientLeft = $contentEl[0].clientLeft;
    $contentEl.transition('');
    // Close
    $contentEl.transitionEnd(() => {
      if ($el.hasClass('accordion-item-opened')) {
        $contentEl.transition(0);
        $contentEl.css('height', 'auto');
        $contentEl._clientLeft = $contentEl[0].clientLeft;
        $contentEl.transition('');
        $el.trigger('accordion:opened');
        app.emit('accordionOpened', $el[0]);
      } else {
        $contentEl.css('height', '');
        $el.trigger('accordion:closed');
        app.emit('accordionClosed', $el[0]);
      }
    });
    Utils.nextFrame(() => {
      $contentEl.transition('');
      $contentEl.css('height', '');
      $el.trigger('accordion:close');
      app.emit('accordionClose');
    });
  },
  toggle(el) {
    const app = this;
    const $el = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(el);
    if ($el.length === 0) return;
    if ($el.hasClass('accordion-item-opened')) app.accordion.close(el);
    else app.accordion.open(el);
  },
};

var Accordion$1 = {
  name: 'accordion',
  create() {
    const app = this;
    Utils.extend(app, {
      accordion: {
        open: Accordion.open.bind(app),
        close: Accordion.close.bind(app),
        toggle: Accordion.toggle.bind(app),
      },
    });
  },
  clicks: {
    '.accordion-item .item-link, .accordion-item-toggle, .links-list.accordion-list > ul > li > a': function open($clickedEl) {
      const app = this;
      Accordion.toggleClicked.call(app, $clickedEl);
    },
  },
};

class VirtualList extends Framework7Class {
  constructor(app, params = {}) {
    super(params, [app]);
    const vl = this;

    const defaults = {
      cols: 1,
      height: app.theme === 'md' ? 48 : 44,
      cache: true,
      dynamicHeightBufferSize: 1,
      showFilteredItemsOnly: false,
      renderExternal: undefined,
      setListHeight: true,
      searchByItem: undefined,
      searchAll: undefined,
      itemTemplate: undefined,
      ul: null,
      createUl: true,
      renderItem(item) {
        return `
          <li>
            <div class="item-content">
              <div class="item-inner">
                <div class="item-title">${item}</div>
              </div>
            </div>
          </li>
        `.trim();
      },
      on: {},
    };

    // Extend defaults with modules params
    vl.useModulesParams(defaults);

    vl.params = Utils.extend(defaults, params);
    if (vl.params.height === undefined || !vl.params.height) {
      vl.params.height = app.theme === 'md' ? 48 : 44;
    }

    vl.$el = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(params.el);
    vl.el = vl.$el[0];

    if (vl.$el.length === 0) return undefined;
    vl.$el[0].f7VirtualList = vl;

    vl.items = vl.params.items;
    if (vl.params.showFilteredItemsOnly) {
      vl.filteredItems = [];
    }
    if (vl.params.itemTemplate) {
      if (typeof vl.params.itemTemplate === 'string') vl.renderItem = __WEBPACK_IMPORTED_MODULE_2_template7__["a" /* default */].compile(vl.params.itemTemplate);
      else if (typeof vl.params.itemTemplate === 'function') vl.renderItem = vl.params.itemTemplate;
    } else if (vl.params.renderItem) {
      vl.renderItem = vl.params.renderItem;
    }
    vl.$pageContentEl = vl.$el.parents('.page-content');
    vl.pageContentEl = vl.$pageContentEl[0];

    // Bad scroll
    if (typeof vl.params.updatableScroll !== 'undefined') {
      vl.updatableScroll = vl.params.updatableScroll;
    } else {
      vl.updatableScroll = true;
      if (Device.ios && Device.osVersion.split('.')[0] < 8) {
        vl.updatableScroll = false;
      }
    }

    // Append <ul>
    const ul = vl.params.ul;
    vl.$ul = ul ? Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(vl.params.ul) : vl.$el.children('ul');
    if (vl.$ul.length === 0 && vl.params.createUl) {
      vl.$el.append('<ul></ul>');
      vl.$ul = vl.$el.children('ul');
    }
    vl.ul = vl.$ul[0];

    let $itemsWrapEl;
    if (!vl.ul && !vl.params.createUl) $itemsWrapEl = vl.$el;
    else $itemsWrapEl = vl.$ul;

    Utils.extend(vl, {
      $itemsWrapEl,
      itemsWrapEl: $itemsWrapEl[0],
      // DOM cached items
      domCache: {},
      displayDomCache: {},
      // Temporary DOM Element
      tempDomElement: __WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */].createElement('ul'),
      // Last repain position
      lastRepaintY: null,
      // Fragment
      fragment: __WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */].createDocumentFragment(),
      // Props
      pageHeight: undefined,
      rowsPerScreen: undefined,
      rowsBefore: undefined,
      rowsAfter: undefined,
      rowsToRender: undefined,
      maxBufferHeight: 0,
      listHeight: undefined,
      dynamicHeight: typeof vl.params.height === 'function',
    });

    // Install Modules
    vl.useModules();

    // Attach events
    const handleScrollBound = vl.handleScroll.bind(vl);
    const handleResizeBound = vl.handleResize.bind(vl);
    let $pageEl;
    let $tabEl;
    let $panelEl;
    let $popupEl;
    vl.attachEvents = function attachEvents() {
      $pageEl = vl.$el.parents('.page').eq(0);
      $tabEl = vl.$el.parents('.tab').eq(0);
      $panelEl = vl.$el.parents('.panel').eq(0);
      $popupEl = vl.$el.parents('.popup').eq(0);

      vl.$pageContentEl.on('scroll', handleScrollBound);
      if ($pageEl) $pageEl.on('page:reinit', handleResizeBound);
      if ($tabEl) $tabEl.on('tab:show', handleResizeBound);
      if ($panelEl) $panelEl.on('panel:open', handleResizeBound);
      if ($popupEl) $popupEl.on('popup:open', handleResizeBound);
      app.on('resize', handleResizeBound);
    };
    vl.detachEvents = function attachEvents() {
      vl.$pageContentEl.off('scroll', handleScrollBound);
      if ($pageEl) $pageEl.off('page:reinit', handleResizeBound);
      if ($tabEl) $tabEl.off('tab:show', handleResizeBound);
      if ($panelEl) $panelEl.off('panel:open', handleResizeBound);
      if ($popupEl) $popupEl.off('popup:open', handleResizeBound);
      app.off('resize', handleResizeBound);
    };
    // Init
    vl.init();

    return vl;
  }
  setListSize() {
    const vl = this;
    const items = vl.filteredItems || vl.items;
    vl.pageHeight = vl.$pageContentEl[0].offsetHeight;
    if (vl.dynamicHeight) {
      vl.listHeight = 0;
      vl.heights = [];
      for (let i = 0; i < items.length; i += 1) {
        const itemHeight = vl.params.height(items[i]);
        vl.listHeight += itemHeight;
        vl.heights.push(itemHeight);
      }
    } else {
      vl.listHeight = Math.ceil(items.length / vl.params.cols) * vl.params.height;
      vl.rowsPerScreen = Math.ceil(vl.pageHeight / vl.params.height);
      vl.rowsBefore = vl.params.rowsBefore || vl.rowsPerScreen * 2;
      vl.rowsAfter = vl.params.rowsAfter || vl.rowsPerScreen;
      vl.rowsToRender = (vl.rowsPerScreen + vl.rowsBefore + vl.rowsAfter);
      vl.maxBufferHeight = (vl.rowsBefore / 2) * vl.params.height;
    }

    if (vl.updatableScroll || vl.params.setListHeight) {
      vl.$itemsWrapEl.css({ height: `${vl.listHeight}px` });
    }
  }
  render(force, forceScrollTop) {
    const vl = this;
    if (force) vl.lastRepaintY = null;

    let scrollTop = -(vl.$el[0].getBoundingClientRect().top - vl.$pageContentEl[0].getBoundingClientRect().top);

    if (typeof forceScrollTop !== 'undefined') scrollTop = forceScrollTop;
    if (vl.lastRepaintY === null || Math.abs(scrollTop - vl.lastRepaintY) > vl.maxBufferHeight || (!vl.updatableScroll && (vl.$pageContentEl[0].scrollTop + vl.pageHeight >= vl.$pageContentEl[0].scrollHeight))) {
      vl.lastRepaintY = scrollTop;
    } else {
      return;
    }

    const items = vl.filteredItems || vl.items;
    let fromIndex;
    let toIndex;
    let heightBeforeFirstItem = 0;
    let heightBeforeLastItem = 0;
    if (vl.dynamicHeight) {
      let itemTop = 0;
      let itemHeight;
      vl.maxBufferHeight = vl.pageHeight;

      for (let j = 0; j < vl.heights.length; j += 1) {
        itemHeight = vl.heights[j];
        if (typeof fromIndex === 'undefined') {
          if (itemTop + itemHeight >= scrollTop - (vl.pageHeight * 2 * vl.params.dynamicHeightBufferSize)) fromIndex = j;
          else heightBeforeFirstItem += itemHeight;
        }

        if (typeof toIndex === 'undefined') {
          if (itemTop + itemHeight >= scrollTop + (vl.pageHeight * 2 * vl.params.dynamicHeightBufferSize) || j === vl.heights.length - 1) toIndex = j + 1;
          heightBeforeLastItem += itemHeight;
        }
        itemTop += itemHeight;
      }
      toIndex = Math.min(toIndex, items.length);
    } else {
      fromIndex = (parseInt(scrollTop / vl.params.height, 10) - vl.rowsBefore) * vl.params.cols;
      if (fromIndex < 0) {
        fromIndex = 0;
      }
      toIndex = Math.min(fromIndex + (vl.rowsToRender * vl.params.cols), items.length);
    }

    let topPosition;
    const renderExternalItems = [];
    vl.reachEnd = false;
    let i;
    for (i = fromIndex; i < toIndex; i += 1) {
      let itemEl;
      // Define real item index
      const index = vl.items.indexOf(items[i]);

      if (i === fromIndex) vl.currentFromIndex = index;
      if (i === toIndex - 1) vl.currentToIndex = index;
      if (vl.filteredItems) {
        if (vl.items[index] === vl.filteredItems[vl.filteredItems.length - 1]) vl.reachEnd = true;
      } else if (index === vl.items.length - 1) vl.reachEnd = true;

      // Find items
      if (vl.params.renderExternal) {
        renderExternalItems.push(items[i]);
      } else if (vl.domCache[index]) {
        itemEl = vl.domCache[index];
        itemEl.f7VirtualListIndex = index;
      } else {
        if (vl.renderItem) {
          vl.tempDomElement.innerHTML = vl.renderItem(items[i], index).trim();
        } else {
          vl.tempDomElement.innerHTML = items[i].toString().trim();
        }
        itemEl = vl.tempDomElement.childNodes[0];
        if (vl.params.cache) vl.domCache[index] = itemEl;
        itemEl.f7VirtualListIndex = index;
      }

      // Set item top position
      if (i === fromIndex) {
        if (vl.dynamicHeight) {
          topPosition = heightBeforeFirstItem;
        } else {
          topPosition = ((i * vl.params.height) / vl.params.cols);
        }
      }
      if (!vl.params.renderExternal) {
        itemEl.style.top = `${topPosition}px`;

        // Before item insert
        vl.emit('local::itemBeforeInsert vlItemBeforeInsert', vl, itemEl, items[i]);

        // Append item to fragment
        vl.fragment.appendChild(itemEl);
      }
    }

    // Update list height with not updatable scroll
    if (!vl.updatableScroll) {
      if (vl.dynamicHeight) {
        vl.itemsWrapEl.style.height = `${heightBeforeLastItem}px`;
      } else {
        vl.itemsWrapEl.style.height = `${(i * vl.params.height) / vl.params.cols}px`;
      }
    }

    // Update list html
    if (vl.params.renderExternal) {
      if (items && items.length === 0) {
        vl.reachEnd = true;
      }
    } else {
      vl.emit('local::beforeClear vlBeforeClear', vl, vl.fragment);
      vl.itemsWrapEl.innerHTML = '';

      vl.emit('local::itemsBeforeInsert vlItemsBeforeInsert', vl, vl.fragment);

      if (items && items.length === 0) {
        vl.reachEnd = true;
        if (vl.params.emptyTemplate) vl.itemsWrapEl.innerHTML = vl.params.emptyTemplate;
      } else {
        vl.itemsWrapEl.appendChild(vl.fragment);
      }

      vl.emit('local::itemsAfterInsert vlItemsAfterInsert', vl, vl.fragment);
    }

    if (typeof forceScrollTop !== 'undefined' && force) {
      vl.$pageContentEl.scrollTop(forceScrollTop, 0);
    }
    if (vl.params.renderExternal) {
      vl.params.renderExternal(vl, {
        fromIndex,
        toIndex,
        listHeight: vl.listHeight,
        topPosition,
        items: renderExternalItems,
      });
    }
  }
  // Filter
  filterItems(indexes, resetScrollTop = true) {
    const vl = this;
    vl.filteredItems = [];
    for (let i = 0; i < indexes.length; i += 1) {
      vl.filteredItems.push(vl.items[indexes[i]]);
    }
    if (resetScrollTop) {
      vl.$pageContentEl[0].scrollTop = 0;
    }
    vl.update();
  }
  resetFilter() {
    const vl = this;
    if (vl.params.showFilteredItemsOnly) {
      vl.filteredItems = [];
    } else {
      vl.filteredItems = null;
      delete vl.filteredItems;
    }
    vl.update();
  }
  scrollToItem(index) {
    const vl = this;
    if (index > vl.items.length) return false;
    let itemTop = 0;
    if (vl.dynamicHeight) {
      for (let i = 0; i < index; i += 1) {
        itemTop += vl.heights[i];
      }
    } else {
      itemTop = index * vl.params.height;
    }
    const listTop = vl.$el[0].offsetTop;
    vl.render(true, (listTop + itemTop) - parseInt(vl.$pageContentEl.css('padding-top'), 10));
    return true;
  }
  handleScroll() {
    const vl = this;
    vl.render();
  }
  // Handle resize event
  isVisible() {
    const vl = this;
    return !!(vl.el.offsetWidth || vl.el.offsetHeight || vl.el.getClientRects().length);
  }
  handleResize() {
    const vl = this;
    if (vl.isVisible()) {
      vl.setListSize();
      vl.render(true);
    }
  }
  // Append
  appendItems(items) {
    const vl = this;
    for (let i = 0; i < items.length; i += 1) {
      vl.items.push(items[i]);
    }
    vl.update();
  }
  appendItem(item) {
    const vl = this;
    vl.appendItems([item]);
  }
  // Replace
  replaceAllItems(items) {
    const vl = this;
    vl.items = items;
    delete vl.filteredItems;
    vl.domCache = {};
    vl.update();
  }
  replaceItem(index, item) {
    const vl = this;
    vl.items[index] = item;
    if (vl.params.cache) delete vl.domCache[index];
    vl.update();
  }
  // Prepend
  prependItems(items) {
    const vl = this;
    for (let i = items.length - 1; i >= 0; i -= 1) {
      vl.items.unshift(items[i]);
    }
    if (vl.params.cache) {
      const newCache = {};
      Object.keys(vl.domCache).forEach((cached) => {
        newCache[parseInt(cached, 10) + items.length] = vl.domCache[cached];
      });
      vl.domCache = newCache;
    }
    vl.update();
  }
  prependItem(item) {
    const vl = this;
    vl.prependItems([item]);
  }

  // Move
  moveItem(from, to) {
    const vl = this;
    const fromIndex = from;
    let toIndex = to;
    if (fromIndex === toIndex) return;
    // remove item from array
    const item = vl.items.splice(fromIndex, 1)[0];
    if (toIndex >= vl.items.length) {
      // Add item to the end
      vl.items.push(item);
      toIndex = vl.items.length - 1;
    } else {
    // Add item to new index
      vl.items.splice(toIndex, 0, item);
    }
    // Update cache
    if (vl.params.cache) {
      const newCache = {};
      Object.keys(vl.domCache).forEach((cached) => {
        const cachedIndex = parseInt(cached, 10);
        const leftIndex = fromIndex < toIndex ? fromIndex : toIndex;
        const rightIndex = fromIndex < toIndex ? toIndex : fromIndex;
        const indexShift = fromIndex < toIndex ? -1 : 1;
        if (cachedIndex < leftIndex || cachedIndex > rightIndex) newCache[cachedIndex] = vl.domCache[cachedIndex];
        if (cachedIndex === leftIndex) newCache[rightIndex] = vl.domCache[cachedIndex];
        if (cachedIndex > leftIndex && cachedIndex <= rightIndex) newCache[cachedIndex + indexShift] = vl.domCache[cachedIndex];
      });
      vl.domCache = newCache;
    }
    vl.update();
  }
  // Insert before
  insertItemBefore(index, item) {
    const vl = this;
    if (index === 0) {
      vl.prependItem(item);
      return;
    }
    if (index >= vl.items.length) {
      vl.appendItem(item);
      return;
    }
    vl.items.splice(index, 0, item);
    // Update cache
    if (vl.params.cache) {
      const newCache = {};
      Object.keys(vl.domCache).forEach((cached) => {
        const cachedIndex = parseInt(cached, 10);
        if (cachedIndex >= index) {
          newCache[cachedIndex + 1] = vl.domCache[cachedIndex];
        }
      });
      vl.domCache = newCache;
    }
    vl.update();
  }
  // Delete
  deleteItems(indexes) {
    const vl = this;
    let prevIndex;
    let indexShift = 0;
    for (let i = 0; i < indexes.length; i += 1) {
      let index = indexes[i];
      if (typeof prevIndex !== 'undefined') {
        if (index > prevIndex) {
          indexShift = -i;
        }
      }
      index += indexShift;
      prevIndex = indexes[i];
      // Delete item
      const deletedItem = vl.items.splice(index, 1)[0];

      // Delete from filtered
      if (vl.filteredItems && vl.filteredItems.indexOf(deletedItem) >= 0) {
        vl.filteredItems.splice(vl.filteredItems.indexOf(deletedItem), 1);
      }
      // Update cache
      if (vl.params.cache) {
        const newCache = {};
        Object.keys(vl.domCache).forEach((cached) => {
          const cachedIndex = parseInt(cached, 10);
          if (cachedIndex === index) {
            delete vl.domCache[index];
          } else if (parseInt(cached, 10) > index) {
            newCache[cachedIndex - 1] = vl.domCache[cached];
          } else {
            newCache[cachedIndex] = vl.domCache[cached];
          }
        });
        vl.domCache = newCache;
      }
    }
    vl.update();
  }
  deleteAllItems() {
    const vl = this;
    vl.items = [];
    delete vl.filteredItems;
    if (vl.params.cache) vl.domCache = {};
    vl.update();
  }
  deleteItem(index) {
    const vl = this;
    vl.deleteItems([index]);
  }
  // Clear cache
  clearCachefunction() {
    const vl = this;
    vl.domCache = {};
  }
  // Update Virtual List
  update(deleteCache) {
    const vl = this;
    if (deleteCache && vl.params.cache) {
      vl.domCache = {};
    }
    vl.setListSize();
    vl.render(true);
  }
  init() {
    const vl = this;
    vl.attachEvents();
    vl.setListSize();
    vl.render();
  }
  destroy() {
    let vl = this;
    vl.detachEvents();
    vl.$el[0].f7VirtualList = null;
    delete vl.$el[0].f7VirtualList;
    Utils.deleteProps(vl);
    vl = null;
  }
}

var VirtualList$1 = {
  name: 'virtualList',
  static: {
    VirtualList,
  },
  create() {
    const app = this;
    app.virtualList = ConstructorMethods({
      defaultSelector: '.virtual-list',
      constructor: VirtualList,
      app,
      domProp: 'f7VirtualList',
    });
  },
};

class ListIndex extends Framework7Class {
  constructor(app, params = {}) {
    super(params, [app]);
    const index = this;

    const defaults = {
      el: null, // where to render indexes
      listEl: null, // list el to generate indexes
      indexes: 'auto', // or array of indexes
      iosItemHeight: 14,
      mdItemHeight: 14,
      scrollList: true,
      label: false,
      // eslint-disable-next-line
      renderItem(itemContent, itemIndex) {
        return `
          <li>${itemContent}</li>
        `.trim();
      },
      renderSkipPlaceholder() {
        return '<li class="list-index-skip-placeholder"></li>';
      },
      on: {},
    };

    // Extend defaults with modules params
    index.useModulesParams(defaults);

    index.params = Utils.extend(defaults, params);

    let $el;
    let $listEl;
    let $pageContentEl;
    let $ul;

    if (index.params.el) {
      $el = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(index.params.el);
    } else {
      return index;
    }

    $ul = $el.find('ul');
    if ($ul.length === 0) {
      $ul = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])('<ul></ul>');
      $el.append($ul);
    }

    if (index.params.listEl) {
      $listEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(index.params.listEl);
    }

    if (index.params.indexes === 'auto' && !$listEl) {
      return index;
    }

    if ($listEl) {
      $pageContentEl = $listEl.parents('.page-content').eq(0);
    } else {
      $pageContentEl = $el.siblings('.page-content').eq(0);
      if ($pageContentEl.length === 0) {
        $pageContentEl = $el.parents('.page').eq(0).find('.page-content').eq(0);
      }
    }

    $el[0].f7ListIndex = index;

    Utils.extend(index, {
      app,
      $el,
      el: $el && $el[0],
      $ul,
      ul: $ul && $ul[0],
      $listEl,
      listEl: $listEl && $listEl[0],
      $pageContentEl,
      pageContentEl: $pageContentEl && $pageContentEl[0],
      indexes: params.indexes,
      height: 0,
      skipRate: 0,
    });

    // Install Modules
    index.useModules();

    // Attach events
    function handleResize() {
      const height = { index };
      index.calcSize();
      if (height !== index.height) {
        index.render();
      }
    }

    function handleClick(e) {
      const $clickedLi = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(e.target).closest('li');
      if (!$clickedLi.length) return;

      let itemIndex = $clickedLi.index();
      if (index.skipRate > 0) {
        const percentage = itemIndex / ($clickedLi.siblings('li').length - 1);
        itemIndex = Math.round((index.indexes.length - 1) * percentage);
      }
      const itemContent = index.indexes[itemIndex];

      index.$el.trigger('listindex:click', itemContent, itemIndex);
      index.emit('local::click listIndexClick', index, itemContent, itemIndex);
      index.$el.trigger('listindex:select', itemContent, itemIndex);
      index.emit('local::select listIndexSelect', index, itemContent, itemIndex);

      if (index.$listEl && index.params.scrollList) {
        index.scrollListToIndex(itemContent, itemIndex);
      }
    }

    const touchesStart = {};
    let isTouched;
    let isMoved;
    let topPoint;
    let bottomPoint;
    let $labelEl;
    let previousIndex = null;
    function handleTouchStart(e) {
      const $children = $ul.children();
      if (!$children.length) return;
      topPoint = $children[0].getBoundingClientRect().top;
      bottomPoint = $children[$children.length - 1].getBoundingClientRect().top + $children[0].offsetHeight;

      touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
      touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
      isTouched = true;
      isMoved = false;
      previousIndex = null;
    }
    function handleTouchMove(e) {
      if (!isTouched) return;
      if (!isMoved && index.params.label) {
        $labelEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])('<span class="list-index-label"></span>');
        $el.append($labelEl);
      }
      isMoved = true;
      const pageY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
      e.preventDefault();

      let percentage = (pageY - topPoint) / (bottomPoint - topPoint);
      percentage = Math.min(Math.max(percentage, 0), 1);

      const itemIndex = Math.round((index.indexes.length - 1) * percentage);
      const itemContent = index.indexes[itemIndex];


      const ulHeight = bottomPoint - topPoint;
      const bubbleBottom = ((index.height - ulHeight) / 2) + ((1 - percentage) * ulHeight);

      if (itemIndex !== previousIndex) {
        if (index.params.label) {
          $labelEl.html(itemContent).transform(`translateY(-${bubbleBottom}px)`);
        }

        if (index.$listEl && index.params.scrollList) {
          index.scrollListToIndex(itemContent, itemIndex);
        }
      }

      previousIndex = itemIndex;

      index.$el.trigger('listindex:select', index);
      index.emit('local::select listIndexSelect', index, itemContent, itemIndex);
    }
    function handleTouchEnd() {
      if (!isTouched) return;
      isTouched = false;
      isMoved = false;
      if (index.params.label) {
        if ($labelEl) $labelEl.remove();
        $labelEl = undefined;
      }
    }
    const passiveListener = app.support.passiveListener ? { passive: true } : false;
    index.attachEvents = function attachEvents() {
      $el.parents('.tab').on('tab:show', handleResize);
      $el.parents('.page').on('page:reinit', handleResize);
      $el.parents('.panel').on('panel:open', handleResize);
      $el
        .parents('.sheet-modal, .actions-modal, .popup, .popover, .login-screen, .dialog, .toast')
        .on('modal:open', handleResize);
      app.on('resize', handleResize);

      $el.on('click', handleClick);
      $el.on(app.touchEvents.start, handleTouchStart, passiveListener);
      app.on('touchmove:active', handleTouchMove);
      app.on('touchend:passive', handleTouchEnd);
    };
    index.detachEvents = function attachEvents() {
      $el.parents('.tab').off('tab:show', handleResize);
      $el.parents('.page').off('page:reinit', handleResize);
      $el.parents('.panel').off('panel:open', handleResize);
      $el
        .parents('.sheet-modal, .actions-modal, .popup, .popover, .login-screen, .dialog, .toast')
        .off('modal:open', handleResize);
      app.off('resize', handleResize);

      $el.off('click', handleClick);
      $el.off(app.touchEvents.start, handleTouchStart, passiveListener);
      app.off('touchmove:active', handleTouchMove);
      app.off('touchend:passive', handleTouchEnd);
    };
    // Init
    index.init();

    return index;
  }
  // eslint-disable-next-line
  scrollListToIndex(itemContent, itemIndex) {
    const index = this;
    const { $listEl, $pageContentEl } = index;
    if (!$listEl || !$pageContentEl || $pageContentEl.length === 0) return index;

    let $scrollToEl;
    $listEl.find('.list-group-title, .item-divider').each((elIndex, el) => {
      if ($scrollToEl) return;
      const $el = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(el);
      if ($el.text() === itemContent) {
        $scrollToEl = $el;
      }
    });
    if (!$scrollToEl || $scrollToEl.length === 0) return index;

    const parentTop = $scrollToEl.parent().offset().top;
    const paddingTop = parseInt($pageContentEl.css('padding-top'), 10);
    const scrollTop = $pageContentEl[0].scrollTop;
    const scrollToElTop = $scrollToEl.offset().top;

    if (parentTop <= paddingTop) {
      $pageContentEl.scrollTop((parentTop + scrollTop) - paddingTop);
    } else {
      $pageContentEl.scrollTop((scrollToElTop + scrollTop) - paddingTop);
    }
    return index;
  }
  renderSkipPlaceholder() {
    const index = this;
    return index.params.renderSkipPlaceholder.call(index);
  }
  renderItem(itemContent, itemIndex) {
    const index = this;
    return index.params.renderItem.call(index, itemContent, itemIndex);
  }
  render() {
    const index = this;
    const { $ul, indexes, skipRate } = index;
    let wasSkipped;

    const html = indexes.map((itemContent, itemIndex) => {
      if (itemIndex % skipRate !== 0 && skipRate > 0) {
        wasSkipped = true;
        return '';
      }
      let itemHtml = index.renderItem(itemContent, itemIndex);
      if (wasSkipped) {
        itemHtml = index.renderSkipPlaceholder() + itemHtml;
      }
      wasSkipped = false;
      return itemHtml;
    }).join('');

    $ul.html(html);

    return index;
  }
  calcSize() {
    const index = this;
    const { app, params, el, indexes } = index;
    const height = el.offsetHeight;
    const itemHeight = app.theme === 'ios' ? params.iosItemHeight : params.mdItemHeight;
    const maxItems = Math.floor(height / itemHeight);
    const items = indexes.length;
    let skipRate = 0;
    if (items > maxItems) {
      skipRate = Math.ceil(((items * 2) - 1) / maxItems);
    }

    index.height = height;
    index.skipRate = skipRate;

    return index;
  }
  calcIndexes() {
    const index = this;
    if (index.params.indexes === 'auto') {
      index.indexes = [];

      index.$listEl.find('.list-group-title, .item-divider').each((elIndex, el) => {
        const elContent = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(el).text();
        if (index.indexes.indexOf(elContent) < 0) {
          index.indexes.push(elContent);
        }
      });
    } else {
      index.indexes = index.params.indexes;
    }
    return index;
  }
  update() {
    const index = this;
    index.calcIndexes();
    index.calcSize();
    index.render();

    return index;
  }
  init() {
    const index = this;
    index.calcIndexes();
    index.calcSize();
    index.render();
    index.attachEvents();
  }
  destroy() {
    let index = this;
    index.$el.trigger('listindex:beforedestroy', index);
    index.emit('local::beforeDestroy listIndexBeforeDestroy', index);
    index.detachEvents();
    index.$el[0].f7ListIndex = null;
    delete index.$el[0].f7ListIndex;
    Utils.deleteProps(index);
    index = null;
  }
}

var ListIndex$1 = {
  name: 'listIndex',
  static: {
    ListIndex,
  },
  create() {
    const app = this;
    app.listIndex = ConstructorMethods({
      defaultSelector: '.list-index',
      constructor: ListIndex,
      app,
      domProp: 'f7ListIndex',
    });
  },
  on: {
    tabMounted(tabEl) {
      const app = this;
      Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(tabEl).find('.list-index-init').each((index, listIndexEl) => {
        const params = Utils.extend(Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(listIndexEl).dataset(), { el: listIndexEl });
        app.listIndex.create(params);
      });
    },
    tabBeforeRemove(tabEl) {
      Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(tabEl).find('.list-index-init').each((index, listIndexEl) => {
        if (listIndexEl.f7ListIndex) listIndexEl.f7ListIndex.destroy();
      });
    },
    pageInit(page) {
      const app = this;
      page.$el.find('.list-index-init').each((index, listIndexEl) => {
        const params = Utils.extend(Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(listIndexEl).dataset(), { el: listIndexEl });
        app.listIndex.create(params);
      });
    },
    pageBeforeRemove(page) {
      page.$el.find('.list-index-init').each((index, listIndexEl) => {
        if (listIndexEl.f7ListIndex) listIndexEl.f7ListIndex.destroy();
      });
    },
  },
};

var Timeline = {
  name: 'timeline',
};

const Tab = {
  show(...args) {
    const app = this;
    let tabEl;
    let tabLinkEl;
    let animate;
    let tabRoute;
    if (args.length === 1 && args[0].constructor === Object) {
      tabEl = args[0].tabEl;
      tabLinkEl = args[0].tabLinkEl;
      animate = args[0].animate;
      tabRoute = args[0].tabRoute;
    } else {
      [tabEl, tabLinkEl, animate, tabRoute] = args;
      if (typeof args[1] === 'boolean') {
        [tabEl, animate, tabLinkEl, tabRoute] = args;
        if (args.length > 2 && tabLinkEl.constructor === Object) {
          [tabEl, animate, tabRoute, tabLinkEl] = args;
        }
      }
    }
    if (typeof animate === 'undefined') animate = true;

    const $newTabEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(tabEl);
    if (tabRoute && $newTabEl[0]) {
      $newTabEl[0].f7TabRoute = tabRoute;
    }

    if ($newTabEl.length === 0 || $newTabEl.hasClass('tab-active')) {
      return {
        $newTabEl,
        newTabEl: $newTabEl[0],
      };
    }

    let $tabLinkEl;
    if (tabLinkEl) $tabLinkEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(tabLinkEl);

    const $tabsEl = $newTabEl.parent('.tabs');
    if ($tabsEl.length === 0) {
      return {
        $newTabEl,
        newTabEl: $newTabEl[0],
      };
    }

    // Release swipeouts in hidden tabs
    if (app.swipeout) app.swipeout.allowOpen = true;

    // Animated tabs
    const tabsChangedCallbacks = [];

    function onTabsChanged(callback) {
      tabsChangedCallbacks.push(callback);
    }
    function tabsChanged() {
      tabsChangedCallbacks.forEach((callback) => {
        callback();
      });
    }

    let animated = false;

    if ($tabsEl.parent().hasClass('tabs-animated-wrap')) {
      $tabsEl.parent()[animate ? 'removeClass' : 'addClass']('not-animated');

      const transitionDuration = parseFloat($tabsEl.css('transition-duration').replace(',', '.'));
      if (animate && transitionDuration) {
        $tabsEl.transitionEnd(tabsChanged);
        animated = true;
      }

      const tabsTranslate = (app.rtl ? $newTabEl.index() : -$newTabEl.index()) * 100;
      $tabsEl.transform(`translate3d(${tabsTranslate}%,0,0)`);
    }

    // Swipeable tabs
    if ($tabsEl.parent().hasClass('tabs-swipeable-wrap') && app.swiper) {
      const swiper = $tabsEl.parent()[0].swiper;
      if (swiper && swiper.activeIndex !== $newTabEl.index()) {
        animated = true;
        swiper
          .once('slideChangeTransitionEnd', () => {
            tabsChanged();
          })
          .slideTo($newTabEl.index(), animate ? undefined : 0);
      }
    }

    // Remove active class from old tabs
    const $oldTabEl = $tabsEl.children('.tab-active');
    $oldTabEl
      .removeClass('tab-active')
      .trigger('tab:hide');
    app.emit('tabHide', $oldTabEl[0]);

    // Trigger 'show' event on new tab
    $newTabEl
      .addClass('tab-active')
      .trigger('tab:show');
    app.emit('tabShow', $newTabEl[0]);

    // Find related link for new tab
    if (!$tabLinkEl) {
      // Search by id
      if (typeof tabEl === 'string') $tabLinkEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(`.tab-link[href="${tabEl}"]`);
      else $tabLinkEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(`.tab-link[href="#${$newTabEl.attr('id')}"]`);
      // Search by data-tab
      if (!$tabLinkEl || ($tabLinkEl && $tabLinkEl.length === 0)) {
        Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])('[data-tab]').each((index, el) => {
          if ($newTabEl.is(Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(el).attr('data-tab'))) $tabLinkEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(el);
        });
      }
      if (tabRoute && (!$tabLinkEl || ($tabLinkEl && $tabLinkEl.length === 0))) {
        $tabLinkEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(`[data-route-tab-id="${tabRoute.route.tab.id}"]`);
        if ($tabLinkEl.length === 0) {
          $tabLinkEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(`.tab-link[href="${tabRoute.url}"]`);
        }
      }
      if ($tabLinkEl.length > 1 && $newTabEl.parents('.page').length) {
        // eslint-disable-next-line
        $tabLinkEl = $tabLinkEl.filter((index, tabLinkElement) => {
          return Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(tabLinkElement).parents('.page')[0] === $newTabEl.parents('.page')[0];
        });
        if (app.theme === 'ios' && $tabLinkEl.length === 0 && tabRoute) {
          const $pageEl = $newTabEl.parents('.page');
          const $navbarEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(app.navbar.getElByPage($pageEl));
          $tabLinkEl = $navbarEl.find(`[data-route-tab-id="${tabRoute.route.tab.id}"]`);
          if ($tabLinkEl.length === 0) {
            $tabLinkEl = $navbarEl.find(`.tab-link[href="${tabRoute.url}"]`);
          }
        }
      }
    }
    if ($tabLinkEl.length > 0) {
      // Find related link for old tab
      let $oldTabLinkEl;
      if ($oldTabEl && $oldTabEl.length > 0) {
        // Search by id
        const oldTabId = $oldTabEl.attr('id');
        if (oldTabId) {
          $oldTabLinkEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(`.tab-link[href="#${oldTabId}"]`);
          // Search by data-route-tab-id
          if (!$oldTabLinkEl || ($oldTabLinkEl && $oldTabLinkEl.length === 0)) {
            $oldTabLinkEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(`.tab-link[data-route-tab-id="${oldTabId}"]`);
          }
        }
        // Search by data-tab
        if (!$oldTabLinkEl || ($oldTabLinkEl && $oldTabLinkEl.length === 0)) {
          Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])('[data-tab]').each((index, tabLinkElement) => {
            if ($oldTabEl.is(Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(tabLinkElement).attr('data-tab'))) $oldTabLinkEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(tabLinkElement);
          });
        }
        if (!$oldTabLinkEl || ($oldTabLinkEl && $oldTabLinkEl.length === 0)) {
          $oldTabLinkEl = $tabLinkEl.siblings('.tab-link-active');
        }
      } else if (tabRoute) {
        $oldTabLinkEl = $tabLinkEl.siblings('.tab-link-active');
      }

      if ($oldTabLinkEl && $oldTabLinkEl.length > 1 && $oldTabEl && $oldTabEl.parents('.page').length) {
        // eslint-disable-next-line
        $oldTabLinkEl = $oldTabLinkEl.filter((index, tabLinkElement) => {
          return Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(tabLinkElement).parents('.page')[0] === $oldTabEl.parents('.page')[0];
        });
      }

      if ($oldTabLinkEl && $oldTabLinkEl.length > 0) $oldTabLinkEl.removeClass('tab-link-active');

      // Update links' classes
      if ($tabLinkEl && $tabLinkEl.length > 0) {
        $tabLinkEl.addClass('tab-link-active');
        // Material Highlight
        if (app.theme === 'md' && app.toolbar) {
          const $tabbarEl = $tabLinkEl.parents('.tabbar, .tabbar-labels');
          if ($tabbarEl.length > 0) {
            app.toolbar.setHighlight($tabbarEl);
          }
        }
      }
    }
    return {
      $newTabEl,
      newTabEl: $newTabEl[0],
      $oldTabEl,
      oldTabEl: $oldTabEl[0],
      onTabsChanged,
      animated,
    };
  },
};
var Tabs = {
  name: 'tabs',
  create() {
    const app = this;
    Utils.extend(app, {
      tab: {
        show: Tab.show.bind(app),
      },
    });
  },
  clicks: {
    '.tab-link': function tabLinkClick($clickedEl, data = {}) {
      const app = this;
      if (($clickedEl.attr('href') && $clickedEl.attr('href').indexOf('#') === 0) || $clickedEl.attr('data-tab')) {
        app.tab.show({
          tabEl: data.tab || $clickedEl.attr('href'),
          tabLinkEl: $clickedEl,
          animate: data.animate,
        });
      }
    },
  },
};

function swipePanel(panel) {
  const app = panel.app;
  Utils.extend(panel, {
    swipeable: true,
    swipeInitialized: true,
  });
  const params = app.params.panel;
  const { $el, $backdropEl, side, effect } = panel;
  let otherPanel;

  let isTouched;
  let isMoved;
  let isScrolling;
  const touchesStart = {};
  let touchStartTime;
  let touchesDiff;
  let translate;
  let backdropOpacity;
  let panelWidth;
  let direction;

  let $viewEl;

  let touchMoves = 0;
  function handleTouchStart(e) {
    if (!panel.swipeable) return;
    if (!app.panel.allowOpen || (!params.swipe && !params.swipeOnlyClose) || isTouched) return;
    if (Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])('.modal-in, .photo-browser-in').length > 0) return;
    otherPanel = app.panel[side === 'left' ? 'right' : 'left'] || {};
    if (!panel.opened && otherPanel.opened) return;
    if (!(params.swipeCloseOpposite || params.swipeOnlyClose)) {
      if (otherPanel.opened) return;
    }
    if (e.target && e.target.nodeName.toLowerCase() === 'input' && e.target.type === 'range') return;
    if (Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(e.target).closest('.range-slider, .tabs-swipeable-wrap, .calendar-months, .no-swipe-panel').length > 0) return;
    touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
    touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
    if (params.swipeOnlyClose && !panel.opened) {
      return;
    }
    if (params.swipe !== 'both' && params.swipeCloseOpposite && params.swipe !== side && !panel.opened) {
      return;
    }
    if (params.swipeActiveArea && !panel.opened) {
      if (side === 'left') {
        if (touchesStart.x > params.swipeActiveArea) return;
      }
      if (side === 'right') {
        if (touchesStart.x < app.width - params.swipeActiveArea) return;
      }
    }
    if (params.swipeCloseActiveAreaSide && panel.opened) {
      if (side === 'left') {
        if (touchesStart.x < ($el[0].offsetWidth - params.swipeCloseActiveAreaSide)) return;
      }
      if (side === 'right') {
        if (touchesStart.x > ((app.width - $el[0].offsetWidth) + params.swipeCloseActiveAreaSide)) return;
      }
    }
    touchMoves = 0;
    $viewEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(panel.getViewEl());
    isMoved = false;
    isTouched = true;
    isScrolling = undefined;

    touchStartTime = Utils.now();
    direction = undefined;
  }
  function handleTouchMove(e) {
    if (!isTouched) return;
    touchMoves += 1;
    if (touchMoves < 2) return;
    if (e.f7PreventSwipePanel || app.preventSwipePanelBySwipeBack || app.preventSwipePanel) {
      isTouched = false;
      return;
    }
    const pageX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
    const pageY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
    if (typeof isScrolling === 'undefined') {
      isScrolling = !!(isScrolling || Math.abs(pageY - touchesStart.y) > Math.abs(pageX - touchesStart.x));
    }
    if (isScrolling) {
      isTouched = false;
      return;
    }
    if (!direction) {
      if (pageX > touchesStart.x) {
        direction = 'to-right';
      } else {
        direction = 'to-left';
      }

      if (params.swipe === 'both') {
        if (params.swipeActiveArea > 0 && !panel.opened) {
          if (side === 'left' && touchesStart.x > params.swipeActiveArea) {
            isTouched = false;
            return;
          }
          if (side === 'right' && touchesStart.x < app.width - params.swipeActiveArea) {
            isTouched = false;
            return;
          }
        }
      }
      if ($el.hasClass('panel-visible-by-breakpoint')) {
        isTouched = false;
        return;
      }

      if (
        (side === 'left' &&
          (
            direction === 'to-left' && !$el.hasClass('panel-active')
          )
        )
        ||
        (side === 'right' &&
          (
            direction === 'to-right' && !$el.hasClass('panel-active')
          )
        )
      ) {
        isTouched = false;
        return;
      }
    }

    if (params.swipeNoFollow) {
      const timeDiff = (new Date()).getTime() - touchStartTime;
      if (timeDiff < 300) {
        if (direction === 'to-left') {
          if (side === 'right') app.panel.open(side);
          if (side === 'left' && $el.hasClass('panel-active')) app.panel.close();
        }
        if (direction === 'to-right') {
          if (side === 'left') app.panel.open(side);
          if (side === 'right' && $el.hasClass('panel-active')) app.panel.close();
        }
      }
      isTouched = false;
      isMoved = false;
      return;
    }

    if (!isMoved) {
      if (!panel.opened) {
        $el.show();
        $backdropEl.show();
        $el.trigger('panel:swipeopen', panel);
        panel.emit('local::swipeOpen panelSwipeOpen', panel);
      }
      panelWidth = $el[0].offsetWidth;
      $el.transition(0);
    }

    isMoved = true;

    e.preventDefault();
    let threshold = panel.opened ? 0 : -params.swipeThreshold;
    if (side === 'right') threshold = -threshold;

    touchesDiff = (pageX - touchesStart.x) + threshold;

    if (side === 'right') {
      if (effect === 'cover') {
        translate = touchesDiff + (panel.opened ? 0 : panelWidth);
        if (translate < 0) translate = 0;
        if (translate > panelWidth) {
          translate = panelWidth;
        }
      } else {
        translate = touchesDiff - (panel.opened ? panelWidth : 0);
        if (translate > 0) translate = 0;
        if (translate < -panelWidth) {
          translate = -panelWidth;
        }
      }
    } else {
      translate = touchesDiff + (panel.opened ? panelWidth : 0);
      if (translate < 0) translate = 0;
      if (translate > panelWidth) {
        translate = panelWidth;
      }
    }
    if (effect === 'reveal') {
      $viewEl.transform(`translate3d(${translate}px,0,0)`).transition(0);
      $backdropEl.transform(`translate3d(${translate}px,0,0)`).transition(0);

      $el.trigger('panel:swipe', panel, Math.abs(translate / panelWidth));
      panel.emit('local::swipe panelSwipe', panel, Math.abs(translate / panelWidth));
    } else {
      if (side === 'left') translate -= panelWidth;
      $el.transform(`translate3d(${translate}px,0,0)`).transition(0);

      $backdropEl.transition(0);
      backdropOpacity = 1 - Math.abs(translate / panelWidth);
      $backdropEl.css({ opacity: backdropOpacity });

      $el.trigger('panel:swipe', panel, Math.abs(translate / panelWidth));
      panel.emit('local::swipe panelSwipe', panel, Math.abs(translate / panelWidth));
    }
  }
  function handleTouchEnd() {
    if (!isTouched || !isMoved) {
      isTouched = false;
      isMoved = false;
      return;
    }
    isTouched = false;
    isMoved = false;
    const timeDiff = (new Date()).getTime() - touchStartTime;
    let action;
    const edge = (translate === 0 || Math.abs(translate) === panelWidth);

    const threshold = params.swipeThreshold || 0;

    if (!panel.opened) {
      if (Math.abs(touchesDiff) < threshold) {
        action = 'reset';
      } else if (effect === 'cover') {
        if (translate === 0) {
          action = 'swap'; // open
        } else if (timeDiff < 300 && Math.abs(translate) > 0) {
          action = 'swap'; // open
        } else if (timeDiff >= 300 && Math.abs(translate) < panelWidth / 2) {
          action = 'swap'; // open
        } else {
          action = 'reset'; // close
        }
      } else if (translate === 0) {
        action = 'reset';
      } else if (
        (timeDiff < 300 && Math.abs(translate) > 0)
        ||
        (timeDiff >= 300 && (Math.abs(translate) >= panelWidth / 2))
      ) {
        action = 'swap';
      } else {
        action = 'reset';
      }
    } else if (effect === 'cover') {
      if (translate === 0) {
        action = 'reset'; // open
      } else if (timeDiff < 300 && Math.abs(translate) > 0) {
        action = 'swap'; // open
      } else if (timeDiff >= 300 && Math.abs(translate) < panelWidth / 2) {
        action = 'reset'; // open
      } else {
        action = 'swap'; // close
      }
    } else if (translate === -panelWidth) {
      action = 'reset';
    } else if (
      (timeDiff < 300 && Math.abs(translate) >= 0)
      ||
      (timeDiff >= 300 && (Math.abs(translate) <= panelWidth / 2))
    ) {
      if (side === 'left' && translate === panelWidth) action = 'reset';
      else action = 'swap';
    } else {
      action = 'reset';
    }
    if (action === 'swap') {
      if (panel.opened) {
        panel.close(!edge);
      } else {
        panel.open(!edge);
      }
    }
    if (action === 'reset') {
      if (!panel.opened) {
        if (edge) {
          $el.css({ display: '' });
        } else {
          const target = effect === 'reveal' ? $viewEl : $el;
          Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])('html').addClass('with-panel-transitioning');
          target.transitionEnd(() => {
            if ($el.hasClass('panel-active')) return;
            $el.css({ display: '' });
            Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])('html').removeClass('with-panel-transitioning');
          });
        }
      }
    }
    if (effect === 'reveal') {
      Utils.nextFrame(() => {
        $viewEl.transition('');
        $viewEl.transform('');
      });
    }
    $el.transition('').transform('');
    $backdropEl.css({ display: '' }).transform('').transition('').css('opacity', '');
  }

  // Add Events
  app.on('touchstart:passive', handleTouchStart);
  app.on('touchmove:active', handleTouchMove);
  app.on('touchend:passive', handleTouchEnd);
  panel.on('panelDestroy', () => {
    app.off('touchstart:passive', handleTouchStart);
    app.off('touchmove:active', handleTouchMove);
    app.off('touchend:passive', handleTouchEnd);
  });
}

class Panel extends Framework7Class {
  constructor(app, params = {}) {
    super(params, [app]);
    const panel = this;

    const el = params.el;
    const $el = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(el);
    if ($el.length === 0) return panel;
    if ($el[0].f7Panel) return $el[0].f7Panel;

    $el[0].f7Panel = panel;

    let { opened, side, effect } = params;
    if (typeof opened === 'undefined') opened = $el.hasClass('panel-active');
    if (typeof side === 'undefined') side = $el.hasClass('panel-left') ? 'left' : 'right';
    if (typeof effect === 'undefined') effect = $el.hasClass('panel-cover') ? 'cover' : 'reveal';

    if (!app.panel[side]) {
      Utils.extend(app.panel, {
        [side]: panel,
      });
    }

    let $backdropEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])('.panel-backdrop');
    if ($backdropEl.length === 0) {
      $backdropEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])('<div class="panel-backdrop"></div>');
      $backdropEl.insertBefore($el);
    }

    Utils.extend(panel, {
      app,
      side,
      effect,
      $el,
      el: $el[0],
      opened,
      $backdropEl,
      backdropEl: $backdropEl[0],
    });

    // Install Modules
    panel.useModules();

    // Init
    panel.init();

    return panel;
  }
  init() {
    const panel = this;
    const app = panel.app;
    if (app.params.panel[`${panel.side}Breakpoint`]) {
      panel.initBreakpoints();
    }
    {
      if (
        (app.params.panel.swipe === panel.side)
        ||
        (app.params.panel.swipe === 'both')
        ||
        (app.params.panel.swipe && app.params.panel.swipe !== panel.side && app.params.panel.swipeCloseOpposite)
      ) {
        panel.initSwipePanel();
      }
    }
  }
  getViewEl() {
    const panel = this;
    const app = panel.app;
    let viewEl;
    if (app.root.children('.views').length > 0) {
      viewEl = app.root.children('.views')[0];
    } else {
      viewEl = app.root.children('.view')[0];
    }
    return viewEl;
  }
  setBreakpoint() {
    const panel = this;
    const app = panel.app;
    const { side, $el } = panel;
    const $viewEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(panel.getViewEl());
    const breakpoint = app.params.panel[`${side}Breakpoint`];
    const wasVisible = $el.hasClass('panel-visible-by-breakpoint');

    if (app.width >= breakpoint) {
      if (!wasVisible) {
        Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])('html').removeClass(`with-panel-${side}-reveal with-panel-${side}-cover with-panel`);
        $el.css('display', '').addClass('panel-visible-by-breakpoint').removeClass('panel-active');
        panel.onOpen();
        panel.onOpened();
        $viewEl.css({
          [`margin-${side}`]: `${$el.width()}px`,
        });
        app.allowPanelOpen = true;
        app.emit('local::breakpoint panelBreakpoint');
        panel.$el.trigger('panel:breakpoint', panel);
      }
    } else if (wasVisible) {
      $el.css('display', '').removeClass('panel-visible-by-breakpoint panel-active');
      panel.onClose();
      panel.onClosed();
      $viewEl.css({
        [`margin-${side}`]: '',
      });
      app.emit('local::breakpoint panelBreakpoint');
      panel.$el.trigger('panel:breakpoint', panel);
    }
  }
  initBreakpoints() {
    const panel = this;
    const app = panel.app;
    panel.resizeHandler = function resizeHandler() {
      panel.setBreakpoint();
    };
    if (app.params.panel[`${panel.side}Breakpoint`]) {
      app.on('resize', panel.resizeHandler);
    }
    panel.setBreakpoint();
    return panel;
  }
  initSwipePanel() {
    {
      swipePanel(this);
    }
  }
  destroy() {
    let panel = this;
    const app = panel.app;

    panel.emit('local::beforeDestroy panelBeforeDestroy', panel);
    panel.$el.trigger('panel:beforedestroy', panel);

    if (panel.resizeHandler) {
      app.off('resize', panel.resizeHandler);
    }
    panel.$el.trigger('panel:destroy', panel);
    panel.emit('local::destroy panelDestroy');
    delete app.panel[panel.side];
    delete panel.el.f7Panel;
    Utils.deleteProps(panel);
    panel = null;
  }
  open(animate = true) {
    const panel = this;
    const app = panel.app;
    if (!app.panel.allowOpen) return false;

    const { side, effect, $el, $backdropEl, opened } = panel;

    // Ignore if opened
    if (opened || $el.hasClass('panel-visible-by-breakpoint') || $el.hasClass('panel-active')) return false;

    // Close if some panel is opened
    app.panel.close(side === 'left' ? 'right' : 'left', animate);

    app.panel.allowOpen = false;

    $el[animate ? 'removeClass' : 'addClass']('not-animated');
    $el
      .css({ display: 'block' })
      .addClass('panel-active');

    $backdropEl[animate ? 'removeClass' : 'addClass']('not-animated');
    $backdropEl.show();

    /* eslint no-underscore-dangle: ["error", { "allow": ["_clientLeft"] }] */
    panel._clientLeft = $el[0].clientLeft;

    Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])('html').addClass(`with-panel with-panel-${side}-${effect}`);
    panel.onOpen();

    // Transition End;
    const transitionEndTarget = effect === 'reveal' ? $el.nextAll('.view, .views').eq(0) : $el;

    function panelTransitionEnd() {
      transitionEndTarget.transitionEnd((e) => {
        if (Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(e.target).is(transitionEndTarget)) {
          if ($el.hasClass('panel-active')) {
            panel.onOpened();
            $backdropEl.css({ display: '' });
          } else {
            panel.onClosed();
            $backdropEl.css({ display: '' });
          }
        } else panelTransitionEnd();
      });
    }
    if (animate) {
      panelTransitionEnd();
    } else {
      panel.onOpened();
      $backdropEl.css({ display: '' });
    }

    return true;
  }
  close(animate = true) {
    const panel = this;
    const app = panel.app;

    const { side, effect, $el, $backdropEl, opened } = panel;

    if (!opened || $el.hasClass('panel-visible-by-breakpoint') || !$el.hasClass('panel-active')) return false;

    $el[animate ? 'removeClass' : 'addClass']('not-animated');
    $el.removeClass('panel-active');

    $backdropEl[animate ? 'removeClass' : 'addClass']('not-animated');

    const transitionEndTarget = effect === 'reveal' ? $el.nextAll('.view, .views').eq(0) : $el;

    panel.onClose();
    app.panel.allowOpen = false;

    if (animate) {
      transitionEndTarget.transitionEnd(() => {
        if ($el.hasClass('panel-active')) return;
        $el.css({ display: '' });
        Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])('html').removeClass('with-panel-transitioning');
        panel.onClosed();
      });
      Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])('html')
        .removeClass(`with-panel with-panel-${side}-${effect}`)
        .addClass('with-panel-transitioning');
    } else {
      $el.css({ display: '' });
      $el.removeClass('not-animated');
      Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])('html').removeClass(`with-panel with-panel-transitioning with-panel-${side}-${effect}`);
      panel.onClosed();
    }
    return true;
  }
  onOpen() {
    const panel = this;
    panel.opened = true;
    panel.$el.trigger('panel:open', panel);
    panel.emit('local::open panelOpen', panel);
  }
  onOpened() {
    const panel = this;
    const app = panel.app;
    app.panel.allowOpen = true;

    panel.$el.trigger('panel:opened', panel);
    panel.emit('local::opened panelOpened', panel);
  }
  onClose() {
    const panel = this;
    panel.opened = false;
    panel.$el.addClass('panel-closing');
    panel.$el.trigger('panel:close', panel);
    panel.emit('local::close panelClose', panel);
  }
  onClosed() {
    const panel = this;
    const app = panel.app;
    app.panel.allowOpen = true;
    panel.$el.removeClass('panel-closing');
    panel.$el.trigger('panel:closed', panel);
    panel.emit('local::closed panelClosed', panel);
  }
}

var Panel$1 = {
  name: 'panel',
  params: {
    panel: {
      leftBreakpoint: 0,
      rightBreakpoint: 0,
      swipe: undefined, // or 'left' or 'right' or 'both'
      swipeActiveArea: 0,
      swipeCloseActiveAreaSide: 0,
      swipeCloseOpposite: true,
      swipeOnlyClose: false,
      swipeNoFollow: false,
      swipeThreshold: 0,
      closeByBackdropClick: true,
    },
  },
  static: {
    Panel,
  },
  instance: {
    panel: {
      allowOpen: true,
    },
  },
  create() {
    const app = this;
    Utils.extend(app.panel, {
      disableSwipe(panel = 'both') {
        let side;
        let panels = [];
        if (typeof panel === 'string') {
          if (panel === 'both') {
            side = 'both';
            panels = [app.panel.left, app.panel.right];
          } else {
            side = panel;
            panels = app.panel[side];
          }
        } else {
          panels = [panel];
        }
        panels.forEach((panelInstance) => {
          if (panelInstance) Utils.extend(panelInstance, { swipeable: false });
        });
      },
      enableSwipe(panel = 'both') {
        let panels = [];
        let side;
        if (typeof panel === 'string') {
          side = panel;
          if (
            (app.params.panel.swipe === 'left' && side === 'right') ||
            (app.params.panel.swipe === 'right' && side === 'left') ||
            side === 'both'
          ) {
            side = 'both';
            app.params.panel.swipe = side;
            panels = [app.panel.left, app.panel.right];
          } else {
            app.params.panel.swipe = side;
            panels.push(app.panel[side]);
          }
        } else if (panel) {
          panels.push(panel);
        }
        if (panels.length) {
          panels.forEach((panelInstance) => {
            if (!panelInstance) return;
            if (!panelInstance.swipeInitialized) {
              panelInstance.initSwipePanel();
            } else {
              Utils.extend(panelInstance, { swipeable: true });
            }
          });
        }
      },
      create(params) {
        return new Panel(app, params);
      },
      open(side, animate) {
        let panelSide = side;
        if (!panelSide) {
          if (Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])('.panel').length > 1) {
            return false;
          }
          panelSide = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])('.panel').hasClass('panel-left') ? 'left' : 'right';
        }
        if (!panelSide) return false;
        if (app.panel[panelSide]) {
          return app.panel[panelSide].open(animate);
        }
        const $panelEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(`.panel-${panelSide}`);
        if ($panelEl.length > 0) {
          return app.panel.create({ el: $panelEl }).open(animate);
        }
        return false;
      },
      close(side, animate) {
        let $panelEl;
        let panelSide;
        if (panelSide) {
          panelSide = side;
          $panelEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(`.panel-${panelSide}`);
        } else {
          $panelEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])('.panel.panel-active');
          panelSide = $panelEl.hasClass('panel-left') ? 'left' : 'right';
        }
        if (!panelSide) return false;
        if (app.panel[panelSide]) {
          return app.panel[panelSide].close(animate);
        }
        if ($panelEl.length > 0) {
          return app.panel.create({ el: $panelEl }).close(animate);
        }
        return false;
      },
      get(side) {
        let panelSide = side;
        if (!panelSide) {
          if (Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])('.panel').length > 1) {
            return undefined;
          }
          panelSide = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])('.panel').hasClass('panel-left') ? 'left' : 'right';
        }
        if (!panelSide) return undefined;
        if (app.panel[panelSide]) {
          return app.panel[panelSide];
        }
        const $panelEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(`.panel-${panelSide}`);
        if ($panelEl.length > 0) {
          return app.panel.create({ el: $panelEl });
        }
        return undefined;
      },
    });
  },
  on: {
    init() {
      const app = this;

      // Create Panels
      Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])('.panel').each((index, panelEl) => {
        const side = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(panelEl).hasClass('panel-left') ? 'left' : 'right';
        app.panel[side] = app.panel.create({ el: panelEl, side });
      });
    },
  },
  clicks: {
    '.panel-open': function open(clickedEl, data = {}) {
      const app = this;
      let side = 'left';
      if (data.panel === 'right' || (Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])('.panel').length === 1 && Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])('.panel').hasClass('panel-right'))) {
        side = 'right';
      }
      app.panel.open(side, data.animate);
    },
    '.panel-close': function close(clickedEl, data = {}) {
      const app = this;
      const side = data.panel;
      app.panel.close(side, data.animate);
    },
    '.panel-backdrop': function close() {
      const app = this;
      const $panelEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])('.panel-active');
      const instance = $panelEl[0] && $panelEl[0].f7Panel;
      $panelEl.trigger('panel:backdrop-click');
      if (instance) {
        instance.emit('backdropClick', instance);
      }
      app.emit('panelBackdropClick', instance || $panelEl[0]);
      if (app.params.panel.closeByBackdropClick) app.panel.close();
    },
  },
};

var Card = {
  name: 'card',
};

var Chip = {
  name: 'chip',
};

// Form Data
const FormData$1 = {
  store(form, data) {
    const app = this;
    let formId = form;

    const $formEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(form);
    if ($formEl.length && $formEl.is('form') && $formEl.attr('id')) {
      formId = $formEl.attr('id');
    }
    // Store form data in app.formsData
    app.form.data[`form-${formId}`] = data;

    // Store form data in local storage also
    try {
      __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].localStorage[`f7form-${formId}`] = JSON.stringify(data);
    } catch (e) {
      throw e;
    }
  },
  get(form) {
    const app = this;
    let formId = form;

    const $formEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(form);
    if ($formEl.length && $formEl.is('form') && $formEl.attr('id')) {
      formId = $formEl.attr('id');
    }

    try {
      if (__WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].localStorage[`f7form-${formId}`]) {
        return JSON.parse(__WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].localStorage[`f7form-${formId}`]);
      }
    } catch (e) {
      throw e;
    }
    if (app.form.data[`form-${formId}`]) {
      return app.form.data[`form-${formId}`];
    }
    return undefined;
  },
  remove(form) {
    const app = this;
    let formId = form;

    const $formEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(form);
    if ($formEl.length && $formEl.is('form') && $formEl.attr('id')) {
      formId = $formEl.attr('id');
    }

    // Delete form data from app.formsData
    if (app.form.data[`form-${formId}`]) {
      app.form.data[`form-${formId}`] = '';
      delete app.form.data[`form-${formId}`];
    }

    // Delete form data from local storage also
    try {
      if (__WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].localStorage[`f7form-${formId}`]) {
        __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].localStorage[`f7form-${formId}`] = '';
        __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].localStorage.removeItem(`f7form-${formId}`);
      }
    } catch (e) {
      throw e;
    }
  },
};

// Form Storage
const FormStorage = {
  init(formEl) {
    const app = this;
    const $formEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(formEl);
    const formId = $formEl.attr('id');
    if (!formId) return;
    const initialData = app.form.getFormData(formId);
    if (initialData) {
      app.form.fillFromData($formEl, initialData);
    }
    function store() {
      const data = app.form.convertToData($formEl);
      if (!data) return;
      app.form.storeFormData(formId, data);
      $formEl.trigger('form:storedata', data);
      app.emit('formStoreData', $formEl[0], data);
    }
    $formEl.on('change submit', store);
  },
  destroy(formEl) {
    const $formEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(formEl);
    $formEl.off('change submit');
  },
};

// Form To/From Data
function formToData(formEl) {
  const app = this;
  const $formEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(formEl).eq(0);
  if ($formEl.length === 0) return undefined;

  // Form data
  const data = {};

  // Skip input types
  const skipTypes = ['submit', 'image', 'button', 'file'];
  const skipNames = [];
  $formEl.find('input, select, textarea').each((inputIndex, inputEl) => {
    const $inputEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(inputEl);
    if ($inputEl.hasClass('ignore-store-data') || $inputEl.hasClass('no-store-data')) {
      return;
    }
    const name = $inputEl.attr('name');
    const type = $inputEl.attr('type');
    const tag = inputEl.nodeName.toLowerCase();
    if (skipTypes.indexOf(type) >= 0) return;
    if (skipNames.indexOf(name) >= 0 || !name) return;
    if (tag === 'select' && $inputEl.prop('multiple')) {
      skipNames.push(name);
      data[name] = [];
      $formEl.find(`select[name="${name}"] option`).each((index, el) => {
        if (el.selected) data[name].push(el.value);
      });
    } else {
      switch (type) {
        case 'checkbox':
          skipNames.push(name);
          data[name] = [];
          $formEl.find(`input[name="${name}"]`).each((index, el) => {
            if (el.checked) data[name].push(el.value);
          });
          break;
        case 'radio':
          skipNames.push(name);
          $formEl.find(`input[name="${name}"]`).each((index, el) => {
            if (el.checked) data[name] = el.value;
          });
          break;
        default:
          data[name] = $inputEl.val();
          break;
      }
    }
  });
  $formEl.trigger('form:todata', data);
  app.emit('formToData', $formEl[0], data);

  return data;
}
function formFromData(formEl, formData) {
  const app = this;
  const $formEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(formEl).eq(0);
  if (!$formEl.length) return;

  let data = formData;
  const formId = $formEl.attr('id');

  if (!data && formId) {
    data = app.form.getFormData(formId);
  }

  if (!data) return;

  // Skip input types
  const skipTypes = ['submit', 'image', 'button', 'file'];
  const skipNames = [];

  $formEl.find('input, select, textarea').each((inputIndex, inputEl) => {
    const $inputEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(inputEl);
    if ($inputEl.hasClass('ignore-store-data') || $inputEl.hasClass('no-store-data')) {
      return;
    }
    const name = $inputEl.attr('name');
    const type = $inputEl.attr('type');
    const tag = inputEl.nodeName.toLowerCase();
    if (typeof data[name] === 'undefined' || data[name] === null) return;
    if (skipTypes.indexOf(type) >= 0) return;
    if (skipNames.indexOf(name) >= 0 || !name) return;
    if (tag === 'select' && $inputEl.prop('multiple')) {
      skipNames.push(name);
      $formEl.find(`select[name="${name}"] option`).each((index, el) => {
        const selectEl = el;
        if (data[name].indexOf(el.value) >= 0) selectEl.selected = true;
        else selectEl.selected = false;
      });
    } else {
      switch (type) {
        case 'checkbox':
          skipNames.push(name);
          $formEl.find(`input[name="${name}"]`).each((index, el) => {
            const checkboxEl = el;
            if (data[name].indexOf(el.value) >= 0) checkboxEl.checked = true;
            else checkboxEl.checked = false;
          });
          break;
        case 'radio':
          skipNames.push(name);
          $formEl.find(`input[name="${name}"]`).each((index, el) => {
            const radioEl = el;
            if (data[name] === el.value) radioEl.checked = true;
            else radioEl.checked = false;
          });
          break;
        default:
          $inputEl.val(data[name]);
          break;
      }
    }
    if (tag === 'select' || tag === 'input' || tag === 'textarea') {
      $inputEl.trigger('change', 'fromdata');
    }
  });
  $formEl.trigger('form:fromdata', data);
  app.emit('formFromData', $formEl[0], data);
}

function initAjaxForm() {
  const app = this;

  function onSubmitChange(e, fromData) {
    const $formEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(this);
    if (e.type === 'change' && !$formEl.hasClass('form-ajax-submit-onchange')) return;
    if (e.type === 'submit') e.preventDefault();

    if (e.type === 'change' && fromData === 'fromdata') return;

    const method = ($formEl.attr('method') || 'GET').toUpperCase();
    const contentType = $formEl.prop('enctype') || $formEl.attr('enctype');

    const url = $formEl.attr('action');
    if (!url) return;

    let data;
    if (method === 'POST') {
      if (contentType === 'application/x-www-form-urlencoded') {
        data = app.form.convertToData($formEl[0]);
      } else {
        data = new __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].FormData($formEl[0]);
      }
    } else {
      data = Utils.serializeObject(app.form.convertToData($formEl[0]));
    }

    const xhr = app.request({
      method,
      url,
      contentType,
      data,
      beforeSend() {
        $formEl.trigger('formajax:beforesend', data, xhr);
        app.emit('formAjaxBeforeSend', $formEl[0], data, xhr);
      },
      error() {
        $formEl.trigger('formajax:error', data, xhr);
        app.emit('formAjaxError', $formEl[0], data, xhr);
      },
      complete() {
        $formEl.trigger('formajax:complete', data, xhr);
        app.emit('formAjaxComplete', $formEl[0], data, xhr);
      },
      success() {
        $formEl.trigger('formajax:success', data, xhr);
        app.emit('formAjaxSuccess', $formEl[0], data, xhr);
      },
    });
  }
  Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(__WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */]).on('submit change', 'form.form-ajax-submit, form.form-ajax-submit-onchange', onSubmitChange);
}

var Form = {
  name: 'form',
  create() {
    const app = this;
    Utils.extend(app, {
      form: {
        data: {},
        storeFormData: FormData$1.store.bind(app),
        getFormData: FormData$1.get.bind(app),
        removeFormData: FormData$1.remove.bind(app),
        convertToData: formToData.bind(app),
        fillFromData: formFromData.bind(app),
        storage: {
          init: FormStorage.init.bind(app),
          destroy: FormStorage.destroy.bind(app),
        },
      },
    });
  },
  on: {
    init() {
      const app = this;
      initAjaxForm.call(app);
    },
    tabBeforeRemove(tabEl) {
      const app = this;
      Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(tabEl).find('.form-store-data').each((index, formEl) => {
        app.form.storage.destroy(formEl);
      });
    },
    tabMounted(tabEl) {
      const app = this;
      Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(tabEl).find('.form-store-data').each((index, formEl) => {
        app.form.storage.init(formEl);
      });
    },
    pageBeforeRemove(page) {
      const app = this;
      page.$el.find('.form-store-data').each((index, formEl) => {
        app.form.storage.destroy(formEl);
      });
    },
    pageInit(page) {
      const app = this;
      page.$el.find('.form-store-data').each((index, formEl) => {
        app.form.storage.init(formEl);
      });
    },
  },
};

const Input = {
  ignoreTypes: ['checkbox', 'button', 'submit', 'range', 'radio', 'image'],
  createTextareaResizableShadow() {
    const $shadowEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(__WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */].createElement('textarea'));
    $shadowEl.addClass('textarea-resizable-shadow');
    $shadowEl.prop({
      disabled: true,
      readonly: true,
    });
    Input.textareaResizableShadow = $shadowEl;
  },
  textareaResizableShadow: undefined,
  resizeTextarea(textareaEl) {
    const app = this;
    const $textareaEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(textareaEl);
    if (!Input.textareaResizableShadow) {
      Input.createTextareaResizableShadow();
    }
    const $shadowEl = Input.textareaResizableShadow;
    if (!$textareaEl.length) return;
    if (!$textareaEl.hasClass('resizable')) return;
    if (Input.textareaResizableShadow.parents().length === 0) {
      app.root.append($shadowEl);
    }

    const styles = __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].getComputedStyle($textareaEl[0]);
    ('padding margin width font-size font-family font-style font-weight line-height font-variant text-transform letter-spacing border box-sizing display').split(' ').forEach((style) => {
      let styleValue = styles[style];
      if (('font-size line-height letter-spacing width').split(' ').indexOf(style) >= 0) {
        styleValue = styleValue.replace(',', '.');
      }
      $shadowEl.css(style, styleValue);
    });
    const currentHeight = $textareaEl[0].clientHeight;

    $shadowEl.val('');
    const initialHeight = $shadowEl[0].scrollHeight;

    $shadowEl.val($textareaEl.val());
    $shadowEl.css('height', 0);
    const scrollHeight = $shadowEl[0].scrollHeight;

    if (currentHeight !== scrollHeight) {
      if (scrollHeight > initialHeight) {
        $textareaEl.css('height', `${scrollHeight}px`);
        $textareaEl.trigger('textarea:resize', { initialHeight, currentHeight, scrollHeight });
      } else if (scrollHeight < currentHeight) {
        $textareaEl.css('height', '');
        $textareaEl.trigger('textarea:resize', { initialHeight, currentHeight, scrollHeight });
      }
    }
  },
  validate(inputEl) {
    const $inputEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(inputEl);
    if (!$inputEl.length) return;
    const $itemInputEl = $inputEl.parents('.item-input');
    const $inputWrapEl = $inputEl.parents('.input');
    const validity = $inputEl[0].validity;
    const validationMessage = $inputEl.dataset().errorMessage || $inputEl[0].validationMessage || '';
    if (!validity) return;
    if (!validity.valid) {
      let $errorEl = $inputEl.nextAll('.item-input-error-message, .input-error-message');
      if (validationMessage) {
        if ($errorEl.length === 0) {
          $errorEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(`<div class="${$inputWrapEl.length ? 'input-error-message' : 'item-input-error-message'}"></div>`);
          $errorEl.insertAfter($inputEl);
        }
        $errorEl.text(validationMessage);
      }
      if ($errorEl.length > 0) {
        $itemInputEl.addClass('item-input-with-error-message');
        $inputWrapEl.addClass('input-with-eror-message');
      }
      $itemInputEl.addClass('item-input-invalid');
      $inputWrapEl.addClass('input-invalid');
      $inputEl.addClass('input-invalid');
    } else {
      $itemInputEl.removeClass('item-input-invalid item-input-with-error-message');
      $inputWrapEl.removeClass('input-invalid input-with-error-message');
      $inputEl.removeClass('input-invalid');
    }
  },
  validateInputs(el) {
    const app = this;
    Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(el).find('input, textarea, select').each((index, inputEl) => {
      app.input.validate(inputEl);
    });
  },
  focus(inputEl) {
    const $inputEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(inputEl);
    const type = $inputEl.attr('type');
    if (Input.ignoreTypes.indexOf(type) >= 0) return;
    $inputEl.parents('.item-input').addClass('item-input-focused');
    $inputEl.parents('.input').addClass('input-focused');
    $inputEl.addClass('input-focused');
  },
  blur(inputEl) {
    const $inputEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(inputEl);
    $inputEl.parents('.item-input').removeClass('item-input-focused');
    $inputEl.parents('.input').removeClass('input-focused');
    $inputEl.removeClass('input-focused');
  },
  checkEmptyState(inputEl) {
    const $inputEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(inputEl);
    const value = $inputEl.val();
    const $itemInputEl = $inputEl.parents('.item-input');
    const $inputWrapEl = $inputEl.parents('.input');
    if ((value && (typeof value === 'string' && value.trim() !== '')) || (Array.isArray(value) && value.length > 0)) {
      $itemInputEl.addClass('item-input-with-value');
      $inputWrapEl.addClass('input-with-value');
      $inputEl.addClass('input-with-value');
      $inputEl.trigger('input:notempty');
    } else {
      $itemInputEl.removeClass('item-input-with-value');
      $inputWrapEl.removeClass('input-with-value');
      $inputEl.removeClass('input-with-value');
      $inputEl.trigger('input:empty');
    }
  },
  scrollIntoView(inputEl, duration = 0, centered) {
    const $inputEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(inputEl);
    const $scrollableEl = $inputEl.parents('.page-content, .panel').eq(0);
    if (!$scrollableEl.length) {
      return false;
    }
    const contentHeight = $scrollableEl[0].offsetHeight;
    const contentScrollTop = $scrollableEl[0].scrollTop;
    const contentPaddingTop = parseInt($scrollableEl.css('padding-top'), 10);
    const contentPaddingBottom = parseInt($scrollableEl.css('padding-bottom'), 10);
    const contentOffsetTop = $scrollableEl.offset().top - contentScrollTop;

    const inputOffsetTop = $inputEl.offset().top - contentOffsetTop;
    const inputHeight = $inputEl[0].offsetHeight;

    const min = (inputOffsetTop + contentScrollTop) - contentPaddingTop;
    const max = ((inputOffsetTop + contentScrollTop) - contentHeight) + contentPaddingBottom + inputHeight;
    const centeredPosition = min + ((max - min) / 2);

    if (contentScrollTop > min) {
      $scrollableEl.scrollTop(centered ? centeredPosition : min, duration);
      return true;
    } else if (contentScrollTop < max) {
      $scrollableEl.scrollTop(centered ? centeredPosition : max, duration);
      return true;
    }
    return false;
  },
  init() {
    const app = this;
    Input.createTextareaResizableShadow();
    function onFocus() {
      const inputEl = this;
      if (app.params.input.scrollIntoViewOnFocus) {
        if (Device.android) {
          Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(__WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */]).once('resize', () => {
            if (__WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */] && __WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */].activeElement === inputEl) {
              app.input.scrollIntoView(inputEl, 0, app.params.input.scrollIntoViewCentered);
            }
          });
        } else {
          app.input.scrollIntoView(inputEl, 0, app.params.input.scrollIntoViewCentered);
        }
      }
      app.input.focus(inputEl);
    }
    function onBlur() {
      const $inputEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(this);
      const tag = $inputEl[0].nodeName.toLowerCase();
      app.input.blur($inputEl);
      if ($inputEl.dataset().validate || $inputEl.attr('validate') !== null) {
        app.input.validate($inputEl);
      }
      // Resize textarea
      if (tag === 'textarea' && $inputEl.hasClass('resizable')) {
        if (Input.textareaResizableShadow) Input.textareaResizableShadow.remove();
      }
    }
    function onChange() {
      const $inputEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(this);
      const type = $inputEl.attr('type');
      const tag = $inputEl[0].nodeName.toLowerCase();
      if (Input.ignoreTypes.indexOf(type) >= 0) return;

      // Check Empty State
      app.input.checkEmptyState($inputEl);

      // Check validation
      if ($inputEl.dataset().validate || $inputEl.attr('validate') !== null) {
        app.input.validate($inputEl);
      }

      // Resize textarea
      if (tag === 'textarea' && $inputEl.hasClass('resizable')) {
        app.input.resizeTextarea($inputEl);
      }
    }
    function onInvalid(e) {
      const $inputEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(this);
      if ($inputEl.dataset().validate || $inputEl.attr('validate') !== null) {
        e.preventDefault();
        app.input.validate($inputEl);
      }
    }
    function clearInput() {
      const $clicked = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(this);
      const $inputEl = $clicked.siblings('input, textarea').eq(0);
      const previousValue = $inputEl.val();
      $inputEl
        .val('')
        .trigger('change')
        .focus()
        .trigger('input:clear', previousValue);
    }
    Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(__WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */]).on('click', '.input-clear-button', clearInput);
    Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(__WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */]).on('change input', 'input, textarea, select', onChange, true);
    Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(__WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */]).on('focus', 'input, textarea, select', onFocus, true);
    Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(__WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */]).on('blur', 'input, textarea, select', onBlur, true);
    Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(__WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */]).on('invalid', 'input, textarea, select', onInvalid, true);
  },
};

var Input$1 = {
  name: 'input',
  params: {
    input: {
      scrollIntoViewOnFocus: Device.android,
      scrollIntoViewCentered: false,
    },
  },
  create() {
    const app = this;
    Utils.extend(app, {
      input: {
        scrollIntoView: Input.scrollIntoView.bind(app),
        focus: Input.focus.bind(app),
        blur: Input.blur.bind(app),
        validate: Input.validate.bind(app),
        validateInputs: Input.validateInputs.bind(app),
        checkEmptyState: Input.checkEmptyState.bind(app),
        resizeTextarea: Input.resizeTextarea.bind(app),
        init: Input.init.bind(app),
      },
    });
  },
  on: {
    init() {
      const app = this;
      app.input.init();
    },
    tabMounted(tabEl) {
      const app = this;
      const $tabEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(tabEl);
      $tabEl.find('.item-input, .input').each((itemInputIndex, itemInputEl) => {
        const $itemInputEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(itemInputEl);
        $itemInputEl.find('input, select, textarea').each((inputIndex, inputEl) => {
          const $inputEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(inputEl);
          if (Input.ignoreTypes.indexOf($inputEl.attr('type')) >= 0) return;
          app.input.checkEmptyState($inputEl);
        });
      });
      $tabEl.find('textarea.resizable').each((textareaIndex, textareaEl) => {
        app.input.resizeTextarea(textareaEl);
      });
    },
    pageInit(page) {
      const app = this;
      const $pageEl = page.$el;
      $pageEl.find('.item-input, .input').each((itemInputIndex, itemInputEl) => {
        const $itemInputEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(itemInputEl);
        $itemInputEl.find('input, select, textarea').each((inputIndex, inputEl) => {
          const $inputEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(inputEl);
          if (Input.ignoreTypes.indexOf($inputEl.attr('type')) >= 0) return;
          app.input.checkEmptyState($inputEl);
        });
      });
      $pageEl.find('textarea.resizable').each((textareaIndex, textareaEl) => {
        app.input.resizeTextarea(textareaEl);
      });
    },
  },
};

var Checkbox = {
  name: 'checkbox',
};

var Radio = {
  name: 'radio',
};

class Toggle extends Framework7Class {
  constructor(app, params = {}) {
    super(params, [app]);
    const toggle = this;

    const defaults = {};

    // Extend defaults with modules params
    toggle.useModulesParams(defaults);

    toggle.params = Utils.extend(defaults, params);

    const el = toggle.params.el;
    if (!el) return toggle;

    const $el = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(el);
    if ($el.length === 0) return toggle;


    const $inputEl = $el.children('input[type="checkbox"]');

    Utils.extend(toggle, {
      app,
      $el,
      el: $el[0],
      $inputEl,
      inputEl: $inputEl[0],
      disabled: $el.hasClass('disabled') || $inputEl.hasClass('disabled') || $inputEl.attr('disabled') || $inputEl[0].disabled,
    });

    Object.defineProperty(toggle, 'checked', {
      enumerable: true,
      configurable: true,
      set(checked) {
        if (!toggle || typeof toggle.$inputEl === 'undefined') return;
        if (toggle.checked === checked) return;
        $inputEl[0].checked = checked;
        toggle.$inputEl.trigger('change');
      },
      get() {
        return $inputEl[0].checked;
      },
    });

    $el[0].f7Toggle = toggle;

    let isTouched;
    const touchesStart = {};
    let isScrolling;
    let touchesDiff;
    let toggleWidth;
    let touchStartTime;
    let touchStartChecked;
    function handleTouchStart(e) {
      if (isTouched || toggle.disabled) return;
      touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
      touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
      touchesDiff = 0;

      isTouched = true;
      isScrolling = undefined;
      touchStartTime = Utils.now();
      touchStartChecked = toggle.checked;

      toggleWidth = $el[0].offsetWidth;
      Utils.nextTick(() => {
        if (isTouched) {
          $el.addClass('toggle-active-state');
        }
      });
    }
    function handleTouchMove(e) {
      if (!isTouched || toggle.disabled) return;
      const pageX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
      const pageY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
      const inverter = app.rtl ? -1 : 1;

      if (typeof isScrolling === 'undefined') {
        isScrolling = !!(isScrolling || Math.abs(pageY - touchesStart.y) > Math.abs(pageX - touchesStart.x));
      }
      if (isScrolling) {
        isTouched = false;
        return;
      }
      e.preventDefault();

      touchesDiff = pageX - touchesStart.x;


      let changed;
      if (touchesDiff * inverter < 0 && Math.abs(touchesDiff) > toggleWidth / 3 && touchStartChecked) {
        changed = true;
      }
      if (touchesDiff * inverter > 0 && Math.abs(touchesDiff) > toggleWidth / 3 && !touchStartChecked) {
        changed = true;
      }
      if (changed) {
        touchesStart.x = pageX;
        toggle.checked = !touchStartChecked;
        touchStartChecked = !touchStartChecked;
      }
    }
    function handleTouchEnd() {
      if (!isTouched || toggle.disabled) {
        if (isScrolling) $el.removeClass('toggle-active-state');
        isTouched = false;
        return;
      }
      const inverter = app.rtl ? -1 : 1;
      isTouched = false;

      $el.removeClass('toggle-active-state');

      let changed;
      if ((Utils.now() - touchStartTime) < 300) {
        if (touchesDiff * inverter < 0 && touchStartChecked) {
          changed = true;
        }
        if (touchesDiff * inverter > 0 && !touchStartChecked) {
          changed = true;
        }
        if (changed) {
          toggle.checked = !touchStartChecked;
        }
      }
    }
    function handleInputChange() {
      toggle.$el.trigger('toggle:change', toggle);
      toggle.emit('local::change toggleChange', toggle);
    }
    toggle.attachEvents = function attachEvents() {
      {
        if (!Support.touch) return;
        const passive = Support.passiveListener ? { passive: true } : false;
        $el.on(app.touchEvents.start, handleTouchStart, passive);
        app.on('touchmove', handleTouchMove);
        app.on('touchend:passive', handleTouchEnd);
      }
      toggle.$inputEl.on('change', handleInputChange);
    };
    toggle.detachEvents = function detachEvents() {
      {
        if (!Support.touch) return;
        const passive = Support.passiveListener ? { passive: true } : false;
        $el.off(app.touchEvents.start, handleTouchStart, passive);
        app.off('touchmove', handleTouchMove);
        app.off('touchend:passive', handleTouchEnd);
      }
      toggle.$inputEl.off('change', handleInputChange);
    };


    // Install Modules
    toggle.useModules();

    // Init
    toggle.init();
  }
  toggle() {
    const toggle = this;
    toggle.checked = !toggle.checked;
  }
  init() {
    const toggle = this;
    toggle.attachEvents();
  }
  destroy() {
    let toggle = this;
    toggle.$el.trigger('toggle:beforedestroy', toggle);
    toggle.emit('local::beforeDestroy toggleBeforeDestroy', toggle);
    delete toggle.$el[0].f7Toggle;
    toggle.detachEvents();
    Utils.deleteProps(toggle);
    toggle = null;
  }
}

var Toggle$1 = {
  name: 'toggle',
  create() {
    const app = this;
    app.toggle = ConstructorMethods({
      defaultSelector: '.toggle',
      constructor: Toggle,
      app,
      domProp: 'f7Toggle',
    });
  },
  static: {
    Toggle,
  },
  on: {
    tabMounted(tabEl) {
      const app = this;
      Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(tabEl).find('.toggle-init').each((index, toggleEl) => app.toggle.create({ el: toggleEl }));
    },
    tabBeforeRemove(tabEl) {
      Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(tabEl).find('.toggle-init').each((index, toggleEl) => {
        if (toggleEl.f7Toggle) toggleEl.f7Toggle.destroy();
      });
    },
    pageInit(page) {
      const app = this;
      page.$el.find('.toggle-init').each((index, toggleEl) => app.toggle.create({ el: toggleEl }));
    },
    pageBeforeRemove(page) {
      page.$el.find('.toggle-init').each((index, toggleEl) => {
        if (toggleEl.f7Toggle) toggleEl.f7Toggle.destroy();
      });
    },
  },
};

class Range extends Framework7Class {
  constructor(app, params) {
    super(params, [app]);
    const range = this;
    const defaults = {
      el: null,
      inputEl: null,
      dual: false,
      step: 1,
      label: false,
      min: 0,
      max: 100,
      value: 0,
      draggableBar: true,
    };

    // Extend defaults with modules params
    range.useModulesParams(defaults);

    range.params = Utils.extend(defaults, params);

    const el = range.params.el;
    if (!el) return range;

    const $el = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(el);
    if ($el.length === 0) return range;

    const dataset = $el.dataset();

    ('step min max value').split(' ').forEach((paramName) => {
      if (typeof params[paramName] === 'undefined' && typeof dataset[paramName] !== 'undefined') {
        range.params[paramName] = parseFloat(dataset[paramName]);
      }
    });
    ('dual label').split(' ').forEach((paramName) => {
      if (typeof params[paramName] === 'undefined' && typeof dataset[paramName] !== 'undefined') {
        range.params[paramName] = dataset[paramName];
      }
    });


    if (!range.params.value) {
      if (typeof dataset.value !== 'undefined') range.params.value = dataset.value;
      if (typeof dataset.valueLeft !== 'undefined' && typeof dataset.valueRight !== 'undefined') {
        range.params.value = [parseFloat(dataset.valueLeft), parseFloat(dataset.valueRight)];
      }
    }

    let $inputEl;
    if (!range.params.dual) {
      if (range.params.inputEl) {
        $inputEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(range.params.inputEl);
      } else if ($el.find('input[type="range"]').length) {
        $inputEl = $el.find('input[type="range"]').eq(0);
      }
    }

    const { dual, step, label, min, max, value } = range.params;
    Utils.extend(range, {
      $el,
      el: $el[0],
      $inputEl,
      inputEl: $inputEl ? $inputEl[0] : undefined,
      dual,
      step,
      label,
      min,
      max,
      value,
      previousValue: value,
    });

    if ($inputEl) {
      ('step min max').split(' ').forEach((paramName) => {
        if (!params[paramName] && $inputEl.attr(paramName)) {
          range.params[paramName] = parseFloat($inputEl.attr(paramName));
          range[paramName] = parseFloat($inputEl.attr(paramName));
        }
      });
      if (typeof $inputEl.val() !== 'undefined') {
        range.params.value = parseFloat($inputEl.val());
        range.value = parseFloat($inputEl.val());
      }
    }

    // Dual
    if (range.dual) {
      $el.addClass('range-slider-dual');
    }
    if (range.label) {
      $el.addClass('range-slider-label');
    }

    // Check for layout
    const $barEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])('<div class="range-bar"></div>');
    const $barActiveEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])('<div class="range-bar-active"></div>');
    $barEl.append($barActiveEl);

    // Create Knobs
    const knobHTML = `
      <div class="range-knob-wrap">
        <div class="range-knob"></div>
        ${range.label ? '<div class="range-knob-label"></div>' : ''}
      </div>
    `;
    const knobs = [Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(knobHTML)];
    const labels = [];

    if (range.dual) {
      knobs.push(Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(knobHTML));
    }

    $el.append($barEl);
    knobs.forEach(($knobEl) => {
      $el.append($knobEl);
    });

    // Labels
    if (range.label) {
      labels.push(knobs[0].find('.range-knob-label'));
      if (range.dual) {
        labels.push(knobs[1].find('.range-knob-label'));
      }
    }

    Utils.extend(range, {
      app,
      knobs,
      labels,
      $barEl,
      $barActiveEl,
    });

    $el[0].f7Range = range;

    // Touch Events
    let isTouched;
    const touchesStart = {};
    let isScrolling;
    let rangeOffsetLeft;
    let $touchedKnobEl;
    let dualValueIndex;
    let valueChangedByTouch;
    function onTouchChange() {
      valueChangedByTouch = true;
    }
    function handleTouchStart(e) {
      if (isTouched) return;
      if (!range.params.draggableBar) {
        if (Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(e.target).closest('.range-knob').length === 0) {
          return;
        }
      }
      valueChangedByTouch = false;
      touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
      touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;

      isTouched = true;
      isScrolling = undefined;
      rangeOffsetLeft = $el.offset().left;

      let progress;
      if (range.app.rtl) {
        progress = ((rangeOffsetLeft + range.rangeWidth) - touchesStart.x) / range.rangeWidth;
      } else {
        progress = (touchesStart.x - rangeOffsetLeft) / range.rangeWidth;
      }

      let newValue = (progress * (range.max - range.min)) + range.min;
      if (range.dual) {
        if (Math.abs(range.value[0] - newValue) < Math.abs(range.value[1] - newValue)) {
          dualValueIndex = 0;
          $touchedKnobEl = range.knobs[0];
          newValue = [newValue, range.value[1]];
        } else {
          dualValueIndex = 1;
          $touchedKnobEl = range.knobs[1];
          newValue = [range.value[0], newValue];
        }
      } else {
        $touchedKnobEl = range.knobs[0];
        newValue = (progress * (range.max - range.min)) + range.min;
      }
      Utils.nextTick(() => {
        if (isTouched) $touchedKnobEl.addClass('range-knob-active-state');
      }, 70);
      range.on('change', onTouchChange);
      range.setValue(newValue, true);
    }
    function handleTouchMove(e) {
      if (!isTouched) return;
      const pageX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
      const pageY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;

      if (typeof isScrolling === 'undefined') {
        isScrolling = !!(isScrolling || Math.abs(pageY - touchesStart.y) > Math.abs(pageX - touchesStart.x));
      }
      if (isScrolling) {
        isTouched = false;
        return;
      }
      e.preventDefault();

      let progress;
      if (range.app.rtl) {
        progress = ((rangeOffsetLeft + range.rangeWidth) - pageX) / range.rangeWidth;
      } else {
        progress = (pageX - rangeOffsetLeft) / range.rangeWidth;
      }

      let newValue = (progress * (range.max - range.min)) + range.min;
      if (range.dual) {
        let leftValue;
        let rightValue;
        if (dualValueIndex === 0) {
          leftValue = newValue;
          rightValue = range.value[1];
          if (leftValue > rightValue) {
            rightValue = leftValue;
          }
        } else {
          leftValue = range.value[0];
          rightValue = newValue;
          if (rightValue < leftValue) {
            leftValue = rightValue;
          }
        }
        newValue = [leftValue, rightValue];
      }
      range.setValue(newValue, true);
    }
    function handleTouchEnd() {
      if (!isTouched) {
        if (isScrolling) $touchedKnobEl.removeClass('range-knob-active-state');
        isTouched = false;
        return;
      }
      range.off('change', onTouchChange);
      isTouched = false;
      $touchedKnobEl.removeClass('range-knob-active-state');
      if (valueChangedByTouch && range.$inputEl && !range.dual) {
        range.$inputEl.trigger('change');
      }
      valueChangedByTouch = false;
      if (typeof range.previousValue !== 'undefined') {
        if (
          (
            range.dual &&
            (
              range.previousValue[0] !== range.value[0] ||
              range.previousValue[1] !== range.value[1]
            )
          ) ||
          (
            !range.dual &&
            range.previousValue !== range.value
          )
        ) {
          range.$el.trigger('range:changed', range, range.value);
          range.emit('local::changed rangeChanged', range, range.value);
        }
      }
    }

    function handleResize() {
      range.calcSize();
      range.layout();
    }
    range.attachEvents = function attachEvents() {
      const passive = Support.passiveListener ? { passive: true } : false;
      range.$el.on(app.touchEvents.start, handleTouchStart, passive);
      app.on('touchmove', handleTouchMove);
      app.on('touchend:passive', handleTouchEnd);
      app.on('tabShow', handleResize);
      app.on('resize', handleResize);
      range.$el
        .parents('.sheet-modal, .actions-modal, .popup, .popover, .login-screen, .dialog, .toast')
        .on('modal:open', handleResize);
      range.$el
        .parents('.panel')
        .on('panel:open', handleResize);
    };
    range.detachEvents = function detachEvents() {
      const passive = Support.passiveListener ? { passive: true } : false;
      range.$el.off(app.touchEvents.start, handleTouchStart, passive);
      app.off('touchmove', handleTouchMove);
      app.off('touchend:passive', handleTouchEnd);
      app.off('tabShow', handleResize);
      app.off('resize', handleResize);
      range.$el
        .parents('.sheet-modal, .actions-modal, .popup, .popover, .login-screen, .dialog, .toast')
        .off('modal:open', handleResize);
      range.$el
        .parents('.panel')
        .off('panel:open', handleResize);
    };

    // Install Modules
    range.useModules();

    // Init
    range.init();

    return range;
  }
  calcSize() {
    const range = this;
    const width = range.$el.outerWidth();
    if (width === 0) return;
    range.rangeWidth = width;
    range.knobWidth = range.knobs[0].outerWidth();
  }
  layout() {
    const range = this;
    const {
      app,
      knobWidth,
      rangeWidth,
      min,
      max,
      knobs,
      $barActiveEl,
      value,
      label,
      labels,
    } = range;
    const positionProperty = app.rtl ? 'right' : 'left';
    if (range.dual) {
      const progress = [((value[0] - min) / (max - min)), ((value[1] - min) / (max - min))];
      $barActiveEl.css({
        [positionProperty]: `${progress[0] * 100}%`,
        width: `${(progress[1] - progress[0]) * 100}%`,
      });
      knobs.forEach(($knobEl, knobIndex) => {
        let leftPos = rangeWidth * progress[knobIndex];
        const realLeft = (rangeWidth * progress[knobIndex]) - (knobWidth / 2);
        if (realLeft < 0) leftPos = knobWidth / 2;
        if ((realLeft + knobWidth) > rangeWidth) leftPos = rangeWidth - (knobWidth / 2);
        $knobEl.css(positionProperty, `${leftPos}px`);
        if (label) labels[knobIndex].text(value[knobIndex]);
      });
    } else {
      const progress = ((value - min) / (max - min));
      $barActiveEl.css('width', `${progress * 100}%`);

      let leftPos = rangeWidth * progress;
      const realLeft = (rangeWidth * progress) - (knobWidth / 2);
      if (realLeft < 0) leftPos = knobWidth / 2;
      if ((realLeft + knobWidth) > rangeWidth) leftPos = rangeWidth - (knobWidth / 2);
      knobs[0].css(positionProperty, `${leftPos}px`);
      if (label) labels[0].text(value);
    }
    if ((range.dual && value.indexOf(min) >= 0) || (!range.dual && value === min)) {
      range.$el.addClass('range-slider-min');
    } else {
      range.$el.removeClass('range-slider-min');
    }
    if ((range.dual && value.indexOf(max) >= 0) || (!range.dual && value === max)) {
      range.$el.addClass('range-slider-max');
    } else {
      range.$el.removeClass('range-slider-max');
    }
  }
  setValue(newValue, byTouchMove) {
    const range = this;
    const { step, min, max } = range;
    let valueChanged;
    let oldValue;
    if (range.dual) {
      oldValue = [range.value[0], range.value[1]];
      let newValues = newValue;
      if (!Array.isArray(newValues)) newValues = [newValue, newValue];
      if (newValue[0] > newValue[1]) {
        newValues = [newValues[0], newValues[0]];
      }
      newValues = newValues.map(value => Math.max(Math.min(Math.round(value / step) * step, max), min));
      if (newValues[0] === range.value[0] && newValues[1] === range.value[1]) {
        return range;
      }
      newValues.forEach((value, valueIndex) => {
        range.value[valueIndex] = value;
      });
      valueChanged = oldValue[0] !== newValues[0] || oldValue[1] !== newValues[1];
      range.layout();
    } else {
      oldValue = range.value;
      const value = Math.max(Math.min(Math.round(newValue / step) * step, max), min);
      range.value = value;
      range.layout();
      valueChanged = oldValue !== value;
    }

    if (valueChanged) {
      range.previousValue = oldValue;
    }
    // Events
    if (!valueChanged) return range;
    range.$el.trigger('range:change', range, range.value);
    if (range.$inputEl && !range.dual) {
      range.$inputEl.val(range.value);
      if (!byTouchMove) {
        range.$inputEl.trigger('input change');
      } else {
        range.$inputEl.trigger('input');
      }
    }
    if (!byTouchMove) {
      range.$el.trigger('range:changed', range, range.value);
      range.emit('local::changed rangeChanged', range, range.value);
    }
    range.emit('local::change rangeChange', range, range.value);
    return range;
  }
  getValue() {
    return this.value;
  }
  init() {
    const range = this;
    range.calcSize();
    range.layout();
    range.attachEvents();
    return range;
  }
  destroy() {
    let range = this;
    range.$el.trigger('range:beforedestroy', range);
    range.emit('local::beforeDestroy rangeBeforeDestroy', range);
    delete range.$el[0].f7Range;
    range.detachEvents();
    Utils.deleteProps(range);
    range = null;
  }
}

var Range$1 = {
  name: 'range',
  create() {
    const app = this;
    app.range = Utils.extend(
      ConstructorMethods({
        defaultSelector: '.range-slider',
        constructor: Range,
        app,
        domProp: 'f7Range',
      }),
      {
        getValue(el = '.range-slider') {
          const range = app.range.get(el);
          if (range) return range.getValue();
          return undefined;
        },
        setValue(el = '.range-slider', value) {
          const range = app.range.get(el);
          if (range) return range.setValue(value);
          return undefined;
        },
      }
    );
  },
  static: {
    Range,
  },
  on: {
    tabMounted(tabEl) {
      const app = this;
      Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(tabEl).find('.range-slider-init').each((index, rangeEl) => new Range(app, {
        el: rangeEl,
      }));
    },
    tabBeforeRemove(tabEl) {
      Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(tabEl).find('.range-slider-init').each((index, rangeEl) => {
        if (rangeEl.f7Range) rangeEl.f7Range.destroy();
      });
    },
    pageInit(page) {
      const app = this;
      page.$el.find('.range-slider-init').each((index, rangeEl) => new Range(app, {
        el: rangeEl,
      }));
    },
    pageBeforeRemove(page) {
      page.$el.find('.range-slider-init').each((index, rangeEl) => {
        if (rangeEl.f7Range) rangeEl.f7Range.destroy();
      });
    },
  },
};

class Stepper extends Framework7Class {
  constructor(app, params) {
    super(params, [app]);
    const stepper = this;

    const defaults = {
      el: null,
      inputEl: null,
      valueEl: null,
      value: 0,
      formatValue: null,
      step: 1,
      min: 0,
      max: 100,
      watchInput: true,
      autorepeat: false,
      autorepeatDynamic: false,
      wraps: false,
    };

    // Extend defaults with modules params
    stepper.useModulesParams(defaults);

    stepper.params = Utils.extend(defaults, params);
    if (stepper.params.value < stepper.params.min) {
      stepper.params.value = stepper.params.min;
    }
    if (stepper.params.value > stepper.params.max) {
      stepper.params.value = stepper.params.max;
    }

    const el = stepper.params.el;
    if (!el) return stepper;

    const $el = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(el);
    if ($el.length === 0) return stepper;

    let $inputEl;
    if (stepper.params.inputEl) {
      $inputEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(stepper.params.inputEl);
    } else if ($el.find('.stepper-input-wrap').find('input, textarea').length) {
      $inputEl = $el.find('.stepper-input-wrap').find('input, textarea').eq(0);
    }

    if ($inputEl && $inputEl.length) {
      ('step min max').split(' ').forEach((paramName) => {
        if (!params[paramName] && $inputEl.attr(paramName)) {
          stepper.params[paramName] = parseFloat($inputEl.attr(paramName));
        }
      });

      const inputValue = parseFloat($inputEl.val());
      if (typeof params.value === 'undefined' && !Number.isNaN(inputValue) && (inputValue || inputValue === 0)) {
        stepper.params.value = inputValue;
      }
    }

    let $valueEl;
    if (stepper.params.valueEl) {
      $valueEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(stepper.params.valueEl);
    } else if ($el.find('.stepper-value').length) {
      $valueEl = $el.find('.stepper-value').eq(0);
    }

    const $buttonPlusEl = $el.find('.stepper-button-plus');
    const $buttonMinusEl = $el.find('.stepper-button-minus');

    const { step, min, max, value } = stepper.params;

    Utils.extend(stepper, {
      app,
      $el,
      el: $el[0],
      $buttonPlusEl,
      buttonPlusEl: $buttonPlusEl[0],
      $buttonMinusEl,
      buttonMinusEl: $buttonMinusEl[0],
      $inputEl,
      inputEl: $inputEl ? $inputEl[0] : undefined,
      $valueEl,
      valueEl: $valueEl ? $valueEl[0] : undefined,
      step,
      min,
      max,
      value,
    });

    $el[0].f7Stepper = stepper;

    // Handle Events
    const touchesStart = {};
    let isTouched;
    let isScrolling;
    let preventButtonClick;
    let intervalId;
    let timeoutId;
    let autorepeatAction = null;
    let autorepeatInAction = false;

    function dynamicRepeat(current, progressions, startsIn, progressionStep, repeatEvery, action) {
      clearTimeout(timeoutId);
      timeoutId = setTimeout(() => {
        if (current === 1) {
          preventButtonClick = true;
          autorepeatInAction = true;
        }
        clearInterval(intervalId);
        action();
        intervalId = setInterval(() => {
          action();
        }, repeatEvery);
        if (current < progressions) {
          dynamicRepeat(current + 1, progressions, startsIn, progressionStep, repeatEvery / 2, action);
        }
      }, current === 1 ? startsIn : progressionStep);
    }

    function onTouchStart(e) {
      if (isTouched) return;
      if (Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(e.target).closest($buttonPlusEl).length) {
        autorepeatAction = 'increment';
      } else if (Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(e.target).closest($buttonMinusEl).length) {
        autorepeatAction = 'decrement';
      }
      if (!autorepeatAction) return;

      touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
      touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
      isTouched = true;
      isScrolling = undefined;

      const progressions = stepper.params.autorepeatDynamic ? 4 : 1;
      dynamicRepeat(1, progressions, 500, 1000, 300, () => {
        stepper[autorepeatAction]();
      });
    }
    function onTouchMove(e) {
      if (!isTouched) return;
      const pageX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
      const pageY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;

      if (typeof isScrolling === 'undefined' && !autorepeatInAction) {
        isScrolling = !!(isScrolling || Math.abs(pageY - touchesStart.y) > Math.abs(pageX - touchesStart.x));
      }
      const distance = (((pageX - touchesStart.x) ** 2) + ((pageY - touchesStart.y) ** 2)) ** 0.5;

      if (isScrolling || distance > 20) {
        isTouched = false;
        clearTimeout(timeoutId);
        clearInterval(intervalId);
      }
    }
    function onTouchEnd() {
      clearTimeout(timeoutId);
      clearInterval(intervalId);
      autorepeatAction = null;
      autorepeatInAction = false;
      isTouched = false;
    }

    function onMinusClick() {
      if (preventButtonClick) {
        preventButtonClick = false;
        return;
      }
      stepper.decrement();
    }
    function onPlusClick() {
      if (preventButtonClick) {
        preventButtonClick = false;
        return;
      }
      stepper.increment();
    }
    function onInput(e) {
      if (e.detail && e.detail.sentByF7Stepper) return;
      stepper.setValue(e.target.value, true);
    }
    stepper.attachEvents = function attachEvents() {
      $buttonMinusEl.on('click', onMinusClick);
      $buttonPlusEl.on('click', onPlusClick);
      if (stepper.params.watchInput && $inputEl && $inputEl.length) {
        $inputEl.on('input', onInput);
      }
      if (stepper.params.autorepeat) {
        app.on('touchstart:passive', onTouchStart);
        app.on('touchmove:active', onTouchMove);
        app.on('touchend:passive', onTouchEnd);
      }
    };
    stepper.detachEvents = function detachEvents() {
      $buttonMinusEl.off('click', onMinusClick);
      $buttonPlusEl.off('click', onPlusClick);
      if (stepper.params.watchInput && $inputEl && $inputEl.length) {
        $inputEl.off('input', onInput);
      }
    };

    // Install Modules
    stepper.useModules();

    // Init
    stepper.init();

    return stepper;
  }
  minus() {
    return this.decrement();
  }
  plus() {
    return this.increment();
  }
  decrement() {
    const stepper = this;
    return stepper.setValue(stepper.value - stepper.step);
  }
  increment() {
    const stepper = this;
    return stepper.setValue(stepper.value + stepper.step);
  }
  setValue(newValue, forceUpdate) {
    const stepper = this;
    const { step, min, max } = stepper;

    const oldValue = stepper.value;

    let value = Math.round(newValue / step) * step;
    if (!stepper.params.wraps) {
      value = Math.max(Math.min(value, max), min);
    } else {
      if (value > max) value = min;
      if (value < min) value = max;
    }
    if (Number.isNaN(value)) {
      value = oldValue;
    }
    stepper.value = value;

    const valueChanged = oldValue !== value;

    // Events
    if (!valueChanged && !forceUpdate) return stepper;
    stepper.$el.trigger('stepper:change', stepper, stepper.value);
    const formattedValue = stepper.formatValue(stepper.value);
    if (stepper.$inputEl && stepper.$inputEl.length) {
      stepper.$inputEl.val(formattedValue);
      stepper.$inputEl.trigger('input change', { sentByF7Stepper: true });
    }
    if (stepper.$valueEl && stepper.$valueEl.length) {
      stepper.$valueEl.html(formattedValue);
    }
    stepper.emit('local::change stepperChange', stepper, stepper.value);
    return stepper;
  }
  getValue() {
    return this.value;
  }
  formatValue(value) {
    const stepper = this;
    if (!stepper.params.formatValue) return value;
    return stepper.params.formatValue.call(stepper, value);
  }
  init() {
    const stepper = this;
    stepper.attachEvents();
    if (stepper.$valueEl && stepper.$valueEl.length) {
      const formattedValue = stepper.formatValue(stepper.value);
      stepper.$valueEl.html(formattedValue);
    }
    return stepper;
  }
  destroy() {
    let stepper = this;
    stepper.$el.trigger('stepper:beforedestroy', stepper);
    stepper.emit('local::beforeDestroy stepperBeforeDestroy', stepper);
    delete stepper.$el[0].f7Stepper;
    stepper.detachEvents();
    Utils.deleteProps(stepper);
    stepper = null;
  }
}

var Stepper$1 = {
  name: 'stepper',
  create() {
    const app = this;
    app.stepper = Utils.extend(
      ConstructorMethods({
        defaultSelector: '.stepper',
        constructor: Stepper,
        app,
        domProp: 'f7Stepper',
      }),
      {
        getValue(el = '.stepper') {
          const stepper = app.stepper.get(el);
          if (stepper) return stepper.getValue();
          return undefined;
        },
        setValue(el = '.stepper', value) {
          const stepper = app.stepper.get(el);
          if (stepper) return stepper.setValue(value);
          return undefined;
        },
      }
    );
  },
  static: {
    Stepper,
  },
  on: {
    tabMounted(tabEl) {
      const app = this;
      Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(tabEl).find('.stepper-init').each((index, stepperEl) => {
        const dataset = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(stepperEl).dataset();
        // eslint-disable-next-line
        new Stepper(app, Utils.extend({ el: stepperEl }, dataset || {}));
      });
    },
    tabBeforeRemove(tabEl) {
      Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(tabEl).find('.stepper-init').each((index, stepperEl) => {
        if (stepperEl.f7Stepper) stepperEl.f7Stepper.destroy();
      });
    },
    pageInit(page) {
      const app = this;
      page.$el.find('.stepper-init').each((index, stepperEl) => {
        const dataset = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(stepperEl).dataset();
        // eslint-disable-next-line
        new Stepper(app, Utils.extend({ el: stepperEl }, dataset || {}));
      });
    },
    pageBeforeRemove(page) {
      page.$el.find('.stepper-init').each((index, stepperEl) => {
        if (stepperEl.f7Stepper) stepperEl.f7Stepper.destroy();
      });
    },
  },
};

class SmartSelect extends Framework7Class {
  constructor(app, params = {}) {
    super(params, [app]);
    const ss = this;
    ss.app = app;
    const defaults = Utils.extend({
      on: {},
    }, app.params.smartSelect);

    const $el = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(params.el).eq(0);
    if ($el.length === 0) return ss;

    const $selectEl = $el.find('select').eq(0);
    if ($selectEl.length === 0) return ss;

    let $valueEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(params.valueEl);
    if ($valueEl.length === 0) {
      $valueEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])('<div class="item-after"></div>');
      $valueEl.insertAfter($el.find('.item-title'));
    }

    // Extend defaults with modules params
    ss.useModulesParams(defaults);

    // View
    let view = params.view;
    if (!view) {
      view = $el.parents('.view').length && $el.parents('.view')[0].f7View;
    }
    if (!view) {
      throw Error('Smart Select requires initialized View');
    }

    // Url
    let url = params.url;
    if (!url) {
      if ($el.attr('href') && $el.attr('href') !== '#') url = $el.attr('href');
      else url = `${$selectEl.attr('name').toLowerCase()}-select/`;
    }
    if (!url) url = ss.params.url;

    const multiple = $selectEl[0].multiple;
    const inputType = multiple ? 'checkbox' : 'radio';
    const id = Utils.now();
    Utils.extend(ss, {
      params: Utils.extend(defaults, params),
      $el,
      el: $el[0],
      $selectEl,
      selectEl: $selectEl[0],
      $valueEl,
      valueEl: $valueEl[0],
      url,
      multiple,
      inputType,
      id,
      view,
      inputName: `${inputType}-${id}`,
      selectName: $selectEl.attr('name'),
      maxLength: $selectEl.attr('maxlength') || params.maxLength,
    });
    $el[0].f7SmartSelect = ss;

    // Events
    function onClick() {
      ss.open();
    }
    function onChange() {
      ss.setValue();
    }
    ss.attachEvents = function attachEvents() {
      $el.on('click', onClick);
      $el.on('change', 'select', onChange);
    };
    ss.detachEvents = function detachEvents() {
      $el.off('click', onClick);
      $el.off('change', 'select', onChange);
    };

    function handleInputChange() {
      let optionEl;
      let text;
      const inputEl = this;
      const value = inputEl.value;
      let optionText = [];
      let displayAs;
      if (inputEl.type === 'checkbox') {
        for (let i = 0; i < ss.selectEl.options.length; i += 1) {
          optionEl = ss.selectEl.options[i];
          if (optionEl.value === value) {
            optionEl.selected = inputEl.checked;
          }
          if (optionEl.selected) {
            displayAs = optionEl.dataset ? optionEl.dataset.displayAs : Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(optionEl).data('display-value-as');
            text = displayAs && typeof displayAs !== 'undefined' ? displayAs : optionEl.textContent;
            optionText.push(text.trim());
          }
        }
        if (ss.maxLength) {
          ss.checkMaxLength();
        }
      } else {
        optionEl = ss.$selectEl.find(`option[value="${value}"]`)[0];
        displayAs = optionEl.dataset ? optionEl.dataset.displayAs : Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(optionEl).data('display-as');
        text = displayAs && typeof displayAs !== 'undefined' ? displayAs : optionEl.textContent;
        optionText = [text];
        ss.selectEl.value = value;
      }

      ss.$selectEl.trigger('change');
      ss.$valueEl.text(optionText.join(', '));
      if (ss.params.closeOnSelect && ss.inputType === 'radio') {
        ss.close();
      }
    }

    ss.attachInputsEvents = function attachInputsEvents() {
      ss.$containerEl.on('change', 'input[type="checkbox"], input[type="radio"]', handleInputChange);
    };
    ss.detachInputsEvents = function detachInputsEvents() {
      ss.$containerEl.off('change', 'input[type="checkbox"], input[type="radio"]', handleInputChange);
    };

    // Install Modules
    ss.useModules();

    // Init
    ss.init();

    return ss;
  }
  checkMaxLength() {
    const ss = this;
    const $containerEl = ss.$containerEl;
    if (ss.selectEl.selectedOptions.length >= ss.maxLength) {
      $containerEl.find('input[type="checkbox"]').each((index, inputEl) => {
        if (!inputEl.checked) {
          Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(inputEl).parents('li').addClass('disabled');
        } else {
          Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(inputEl).parents('li').removeClass('disabled');
        }
      });
    } else {
      $containerEl.find('.disabled').removeClass('disabled');
    }
  }
  setValue(value) {
    const ss = this;
    let valueArray = [];
    if (typeof value !== 'undefined') {
      if (Array.isArray(value)) {
        valueArray = value;
      } else {
        valueArray = [value];
      }
    } else {
      ss.$selectEl.find('option').each((optionIndex, optionEl) => {
        const $optionEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(optionEl);
        if (optionEl.selected) {
          const displayAs = optionEl.dataset ? optionEl.dataset.displayAs : $optionEl.data('display-value-as');
          if (displayAs && typeof displayAs !== 'undefined') {
            valueArray.push(displayAs);
          } else {
            valueArray.push(optionEl.textContent.trim());
          }
        }
      });
    }
    ss.$valueEl.text(valueArray.join(', '));
  }
  getItemsData() {
    const ss = this;
    const items = [];
    let previousGroupEl;
    ss.$selectEl.find('option').each((index, optionEl) => {
      const $optionEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(optionEl);
      const optionData = $optionEl.dataset();
      const optionImage = optionData.optionImage || ss.params.optionImage;
      const optionIcon = optionData.optionIcon || ss.params.optionIcon;
      const optionHasMedia = optionImage || optionIcon;
      // if (material) optionHasMedia = optionImage || optionIcon;
      const optionColor = optionData.optionColor;

      let optionClassName = optionData.optionClass || '';
      if ($optionEl[0].disabled) optionClassName += ' disabled';

      const optionGroupEl = $optionEl.parent('optgroup')[0];
      const optionGroupLabel = optionGroupEl && optionGroupEl.label;
      let optionIsLabel = false;
      if (optionGroupEl && optionGroupEl !== previousGroupEl) {
        optionIsLabel = true;
        previousGroupEl = optionGroupEl;
        items.push({
          groupLabel: optionGroupLabel,
          isLabel: optionIsLabel,
        });
      }
      items.push({
        value: $optionEl[0].value,
        text: $optionEl[0].textContent.trim(),
        selected: $optionEl[0].selected,
        groupEl: optionGroupEl,
        groupLabel: optionGroupLabel,
        image: optionImage,
        icon: optionIcon,
        color: optionColor,
        className: optionClassName,
        disabled: $optionEl[0].disabled,
        id: ss.id,
        hasMedia: optionHasMedia,
        checkbox: ss.inputType === 'checkbox',
        radio: ss.inputType === 'radio',
        inputName: ss.inputName,
        inputType: ss.inputType,
      });
    });
    ss.items = items;
    return items;
  }
  renderSearchbar() {
    const ss = this;
    if (ss.params.renderSearchbar) return ss.params.renderSearchbar.call(ss);
    const searchbarHTML = `
      <form class="searchbar">
        <div class="searchbar-inner">
          <div class="searchbar-input-wrap">
            <input type="search" placeholder="${ss.params.searchbarPlaceholder}"/>
            <i class="searchbar-icon"></i>
            <span class="input-clear-button"></span>
          </div>
          <span class="searchbar-disable-button">${ss.params.searchbarDisableText}</span>
        </div>
      </form>
    `;
    return searchbarHTML;
  }
  renderItem(item, index) {
    const ss = this;
    if (ss.params.renderItem) return ss.params.renderItem.call(ss, item, index);
    let itemHtml;
    if (item.isLabel) {
      itemHtml = `<li class="item-divider">${item.groupLabel}</li>`;
    } else {
      itemHtml = `
        <li class="${item.className || ''}">
          <label class="item-${item.inputType} item-content">
            <input type="${item.inputType}" name="${item.inputName}" value="${item.value}" ${item.selected ? 'checked' : ''}/>
            <i class="icon icon-${item.inputType}"></i>
            ${item.hasMedia ? `
              <div class="item-media">
                ${item.icon ? `<i class="icon ${item.icon}"></i>` : ''}
                ${item.image ? `<img src="${item.image}">` : ''}
              </div>
            ` : ''}
            <div class="item-inner">
              <div class="item-title${item.color ? ` color-${item.color}` : ''}">${item.text}</div>
            </div>
          </label>
        </li>
      `;
    }
    return itemHtml;
  }
  renderItems() {
    const ss = this;
    if (ss.params.renderItems) return ss.params.renderItems.call(ss, ss.items);
    const itemsHtml = `
      ${ss.items.map((item, index) => `${ss.renderItem(item, index)}`).join('')}
    `;
    return itemsHtml;
  }
  renderPage() {
    const ss = this;
    if (ss.params.renderPage) return ss.params.renderPage.call(ss, ss.items);
    let pageTitle = ss.params.pageTitle;
    if (typeof pageTitle === 'undefined') {
      pageTitle = ss.$el.find('.item-title').text().trim();
    }
    const pageHtml = `
      <div class="page smart-select-page" data-name="smart-select-page" data-select-name="${ss.selectName}">
        <div class="navbar ${ss.params.navbarColorTheme ? `color-theme-${ss.params.navbarColorTheme}` : ''}">
          <div class="navbar-inner sliding ${ss.params.navbarColorTheme ? `color-theme-${ss.params.navbarColorTheme}` : ''}">
            <div class="left">
              <a href="#" class="link back">
                <i class="icon icon-back"></i>
                <span class="ios-only">${ss.params.pageBackLinkText}</span>
              </a>
            </div>
            ${pageTitle ? `<div class="title">${pageTitle}</div>` : ''}
            ${ss.params.searchbar ? `<div class="subnavbar">${ss.renderSearchbar()}</div>` : ''}
          </div>
        </div>
        ${ss.params.searchbar ? '<div class="searchbar-backdrop"></div>' : ''}
        <div class="page-content">
          <div class="list smart-select-list-${ss.id} ${ss.params.virtualList ? ' virtual-list' : ''} ${ss.params.formColorTheme ? `color-theme-${ss.params.formColorTheme}` : ''}">
            <ul>${!ss.params.virtualList && ss.renderItems(ss.items)}</ul>
          </div>
        </div>
      </div>
    `;
    return pageHtml;
  }
  renderPopup() {
    const ss = this;
    if (ss.params.renderPopup) return ss.params.renderPopup.call(ss, ss.items);
    let pageTitle = ss.params.pageTitle;
    if (typeof pageTitle === 'undefined') {
      pageTitle = ss.$el.find('.item-title').text().trim();
    }
    const popupHtml = `
      <div class="popup smart-select-popup" data-select-name="${ss.selectName}">
        <div class="view">
          <div class="page smart-select-page ${ss.params.searchbar ? 'page-with-subnavbar' : ''}" data-name="smart-select-page">
            <div class="navbar${ss.params.navbarColorTheme ? `theme-${ss.params.navbarColorTheme}` : ''}">
              <div class="navbar-inner sliding">
                <div class="left">
                  <a href="#" class="link popup-close">
                    <i class="icon icon-back"></i>
                    <span class="ios-only">${ss.params.popupCloseLinkText}</span>
                  </a>
                </div>
                ${pageTitle ? `<div class="title">${pageTitle}</div>` : ''}
                ${ss.params.searchbar ? `<div class="subnavbar">${ss.renderSearchbar()}</div>` : ''}
              </div>
            </div>
            ${ss.params.searchbar ? '<div class="searchbar-backdrop"></div>' : ''}
            <div class="page-content">
              <div class="list smart-select-list-${ss.id} ${ss.params.virtualList ? ' virtual-list' : ''}${ss.params.formColorTheme ? `theme-${ss.params.formColorTheme}` : ''}">
                <ul>${!ss.params.virtualList && ss.renderItems(ss.items)}</ul>
              </div>
            </div>
          </div>
        </div>
      </div>
    `;
    return popupHtml;
  }
  renderSheet() {
    const ss = this;
    if (ss.params.renderSheet) return ss.params.renderSheet.call(ss, ss.items);
    const sheetHtml = `
      <div class="sheet-modal smart-select-sheet" data-select-name="${ss.selectName}">
        <div class="toolbar ${ss.params.toolbarColorTheme ? `theme-${ss.params.toolbarColorTheme}` : ''}">
          <div class="toolbar-inner">
            <div class="left"></div>
            <div class="right">
              <a class="link sheet-close">${ss.params.sheetCloseLinkText}</a>
            </div>
          </div>
        </div>
        <div class="sheet-modal-inner">
          <div class="page-content">
            <div class="list smart-select-list-${ss.id} ${ss.params.virtualList ? ' virtual-list' : ''}${ss.params.formColorTheme ? `theme-${ss.params.formColorTheme}` : ''}">
              <ul>${!ss.params.virtualList && ss.renderItems(ss.items)}</ul>
            </div>
          </div>
        </div>
      </div>
    `;
    return sheetHtml;
  }
  renderPopover() {
    const ss = this;
    if (ss.params.renderPopover) return ss.params.renderPopover.call(ss, ss.items);
    const popoverHtml = `
      <div class="popover smart-select-popover" data-select-name="${ss.selectName}">
        <div class="popover-inner">
          <div class="list smart-select-list-${ss.id} ${ss.params.virtualList ? ' virtual-list' : ''}${ss.params.formColorTheme ? `theme-${ss.params.formColorTheme}` : ''}">
            <ul>${!ss.params.virtualList && ss.renderItems(ss.items)}</ul>
          </div>
        </div>
      </div>
    `;
    return popoverHtml;
  }
  onOpen(type, containerEl) {
    const ss = this;
    const app = ss.app;
    const $containerEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(containerEl);
    ss.$containerEl = $containerEl;
    ss.openedIn = type;
    ss.opened = true;

    // Init VL
    if (ss.params.virtualList) {
      ss.vl = app.virtualList.create({
        el: $containerEl.find('.virtual-list'),
        items: ss.items,
        renderItem: ss.renderItem.bind(ss),
        height: ss.params.virtualListHeight,
        searchByItem(query, item) {
          if (item.text && item.text.toLowerCase().indexOf(query.trim().toLowerCase()) >= 0) return true;
          return false;
        },
      });
    }

    // Init SB
    if (ss.params.searchbar) {
      let $searchbarEl = $containerEl.find('.searchbar');
      if (type === 'page' && app.theme === 'ios') {
        $searchbarEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(app.navbar.getElByPage($containerEl)).find('.searchbar');
      }
      ss.searchbar = app.searchbar.create({
        el: $searchbarEl,
        backdropEl: $containerEl.find('.searchbar-backdrop'),
        searchContainer: `.smart-select-list-${ss.id}`,
        searchIn: '.item-title',
      });
    }

    // Check for max length
    if (ss.maxLength) {
      ss.checkMaxLength();
    }

    // Close on select
    if (ss.params.closeOnSelect) {
      ss.$containerEl.find(`input[type="radio"][name="${ss.inputName}"]:checked`).parents('label').once('click', () => {
        ss.close();
      });
    }

    // Attach input events
    ss.attachInputsEvents();

    ss.$el.trigger('smartselect:open', ss);
    ss.emit('local::open smartSelectOpen', ss);
  }
  onOpened() {
    const ss = this;

    ss.$el.trigger('smartselect:opened', ss);
    ss.emit('local::opened smartSelectOpened', ss);
  }
  onClose() {
    const ss = this;
    if (ss.destroyed) return;

    // Destroy VL
    if (ss.vl && ss.vl.destroy) {
      ss.vl.destroy();
      ss.vl = null;
      delete ss.vl;
    }

    // Destroy SB
    if (ss.searchbar && ss.searchbar.destroy) {
      ss.searchbar.destroy();
      ss.searchbar = null;
      delete ss.searchbar;
    }
    // Detach events
    ss.detachInputsEvents();

    ss.$el.trigger('smartselect:close', ss);
    ss.emit('local::close smartSelectClose', ss);
  }
  onClosed() {
    const ss = this;
    if (ss.destroyed) return;
    ss.opened = false;
    ss.$containerEl = null;
    delete ss.$containerEl;

    ss.$el.trigger('smartselect:closed', ss);
    ss.emit('local::closed smartSelectClosed', ss);
  }
  openPage() {
    const ss = this;
    if (ss.opened) return ss;
    ss.getItemsData();
    const pageHtml = ss.renderPage(ss.items);

    ss.view.router.navigate({
      url: ss.url,
      route: {
        content: pageHtml,
        path: ss.url,
        on: {
          pageBeforeIn(e, page) {
            ss.onOpen('page', page.el);
          },
          pageAfterIn(e, page) {
            ss.onOpened('page', page.el);
          },
          pageBeforeOut(e, page) {
            ss.onClose('page', page.el);
          },
          pageAfterOut(e, page) {
            ss.onClosed('page', page.el);
          },
        },
      },
    });
    return ss;
  }
  openPopup() {
    const ss = this;
    if (ss.opened) return ss;
    ss.getItemsData();
    const popupHtml = ss.renderPopup(ss.items);

    const popupParams = {
      content: popupHtml,
      on: {
        popupOpen(popup) {
          ss.onOpen('popup', popup.el);
        },
        popupOpened(popup) {
          ss.onOpened('popup', popup.el);
        },
        popupClose(popup) {
          ss.onClose('popup', popup.el);
        },
        popupClosed(popup) {
          ss.onClosed('popup', popup.el);
        },
      },
    };

    if (ss.params.routableModals) {
      ss.view.router.navigate({
        url: ss.url,
        route: {
          path: ss.url,
          popup: popupParams,
        },
      });
    } else {
      ss.modal = ss.app.popup.create(popupParams).open();
    }
    return ss;
  }
  openSheet() {
    const ss = this;
    if (ss.opened) return ss;
    ss.getItemsData();
    const sheetHtml = ss.renderSheet(ss.items);

    const sheetParams = {
      content: sheetHtml,
      backdrop: false,
      scrollToEl: ss.$el,
      closeByOutsideClick: true,
      on: {
        sheetOpen(sheet) {
          ss.onOpen('sheet', sheet.el);
        },
        sheetOpened(sheet) {
          ss.onOpened('sheet', sheet.el);
        },
        sheetClose(sheet) {
          ss.onClose('sheet', sheet.el);
        },
        sheetClosed(sheet) {
          ss.onClosed('sheet', sheet.el);
        },
      },
    };

    if (ss.params.routableModals) {
      ss.view.router.navigate({
        url: ss.url,
        route: {
          path: ss.url,
          sheet: sheetParams,
        },
      });
    } else {
      ss.modal = ss.app.sheet.create(sheetParams).open();
    }
    return ss;
  }
  openPopover() {
    const ss = this;
    if (ss.opened) return ss;
    ss.getItemsData();
    const popoverHtml = ss.renderPopover(ss.items);
    const popoverParams = {
      content: popoverHtml,
      targetEl: ss.$el,
      on: {
        popoverOpen(popover) {
          ss.onOpen('popover', popover.el);
        },
        popoverOpened(popover) {
          ss.onOpened('popover', popover.el);
        },
        popoverClose(popover) {
          ss.onClose('popover', popover.el);
        },
        popoverClosed(popover) {
          ss.onClosed('popover', popover.el);
        },
      },
    };
    if (ss.params.routableModals) {
      ss.view.router.navigate({
        url: ss.url,
        route: {
          path: ss.url,
          popover: popoverParams,
        },
      });
    } else {
      ss.modal = ss.app.popover.create(popoverParams).open();
    }
    return ss;
  }
  open(type) {
    const ss = this;
    if (ss.opened) return ss;
    const openIn = type || ss.params.openIn;
    ss[`open${openIn.split('').map((el, index) => {
      if (index === 0) return el.toUpperCase();
      return el;
    }).join('')}`]();
    return ss;
  }
  close() {
    const ss = this;
    if (!ss.opened) return ss;
    if (ss.params.routableModals || ss.openedIn === 'page') {
      ss.view.router.back();
    } else {
      ss.modal.once('modalClosed', () => {
        Utils.nextTick(() => {
          ss.modal.destroy();
          delete ss.modal;
        });
      });
      ss.modal.close();
    }
    return ss;
  }
  init() {
    const ss = this;
    ss.attachEvents();
    ss.setValue();
  }
  destroy() {
    const ss = this;
    ss.emit('local::beforeDestroy smartSelectBeforeDestroy', ss);
    ss.$el.trigger('smartselect:beforedestroy', ss);
    ss.detachEvents();
    delete ss.$el[0].f7SmartSelect;
    Utils.deleteProps(ss);
    ss.destroyed = true;
  }
}

var SmartSelect$1 = {
  name: 'smartSelect',
  params: {
    smartSelect: {
      el: undefined,
      valueEl: undefined,
      openIn: 'page', // or 'popup' or 'sheet' or 'popover'
      pageTitle: undefined,
      pageBackLinkText: 'Back',
      popupCloseLinkText: 'Close',
      sheetCloseLinkText: 'Done',
      searchbar: false,
      searchbarPlaceholder: 'Search',
      searchbarDisableText: 'Cancel',
      closeOnSelect: false,
      virtualList: false,
      virtualListHeight: undefined,
      formColorTheme: undefined,
      navbarColorTheme: undefined,
      routableModals: true,
      url: 'select/',
      /*
        Custom render functions
      */
      renderPage: undefined,
      renderPopup: undefined,
      renderSheet: undefined,
      renderPopover: undefined,
      renderItems: undefined,
      renderItem: undefined,
      renderSearchbar: undefined,
    },
  },
  static: {
    SmartSelect,
  },
  create() {
    const app = this;
    app.smartSelect = Utils.extend(
      ConstructorMethods({
        defaultSelector: '.smart-select',
        constructor: SmartSelect,
        app,
        domProp: 'f7SmartSelect',
      }),
      {
        open(smartSelectEl) {
          const ss = app.smartSelect.get(smartSelectEl);
          if (ss && ss.open) return ss.open();
          return undefined;
        },
        close(smartSelectEl) {
          const ss = app.smartSelect.get(smartSelectEl);
          if (ss && ss.close) return ss.close();
          return undefined;
        },
      }
    );
  },

  on: {
    tabMounted(tabEl) {
      const app = this;
      Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(tabEl).find('.smart-select-init').each((index, smartSelectEl) => {
        app.smartSelect.create(Utils.extend({ el: smartSelectEl }, Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(smartSelectEl).dataset()));
      });
    },
    tabBeforeRemove(tabEl) {
      Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(tabEl).find('.smart-select-init').each((index, smartSelectEl) => {
        if (smartSelectEl.f7SmartSelect && smartSelectEl.f7SmartSelect.destroy) {
          smartSelectEl.f7SmartSelect.destroy();
        }
      });
    },
    pageInit(page) {
      const app = this;
      page.$el.find('.smart-select-init').each((index, smartSelectEl) => {
        app.smartSelect.create(Utils.extend({ el: smartSelectEl }, Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(smartSelectEl).dataset()));
      });
    },
    pageBeforeRemove(page) {
      page.$el.find('.smart-select-init').each((index, smartSelectEl) => {
        if (smartSelectEl.f7SmartSelect && smartSelectEl.f7SmartSelect.destroy) {
          smartSelectEl.f7SmartSelect.destroy();
        }
      });
    },
  },
  clicks: {
    '.smart-select': function open($clickedEl, data) {
      const app = this;
      if (!$clickedEl[0].f7SmartSelect) {
        const ss = app.smartSelect.create(Utils.extend({ el: $clickedEl }, data));
        ss.open();
      }
    },
  },
};

var Grid = {
  name: 'grid',
};

class Calendar extends Framework7Class {
  constructor(app, params = {}) {
    super(params, [app]);
    const calendar = this;
    calendar.params = Utils.extend({}, app.params.calendar, params);

    let $containerEl;
    if (calendar.params.containerEl) {
      $containerEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(calendar.params.containerEl);
      if ($containerEl.length === 0) return calendar;
    }

    let $inputEl;
    if (calendar.params.inputEl) {
      $inputEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(calendar.params.inputEl);
    }

    let view;
    if ($inputEl) {
      view = $inputEl.parents('.view').length && $inputEl.parents('.view')[0].f7View;
    }
    if (!view) view = app.views.main;

    const isHorizontal = calendar.params.direction === 'horizontal';

    let inverter = 1;
    if (isHorizontal) {
      inverter = app.rtl ? -1 : 1;
    }

    Utils.extend(calendar, {
      app,
      $containerEl,
      containerEl: $containerEl && $containerEl[0],
      inline: $containerEl && $containerEl.length > 0,
      $inputEl,
      inputEl: $inputEl && $inputEl[0],
      initialized: false,
      opened: false,
      url: calendar.params.url,
      isHorizontal,
      inverter,
      view,
      animating: false,
    });

    function onInputClick() {
      calendar.open();
    }
    function onInputFocus(e) {
      e.preventDefault();
    }
    function onHtmlClick(e) {
      const $targetEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(e.target);
      if (calendar.isPopover()) return;
      if (!calendar.opened) return;
      if ($targetEl.closest('[class*="backdrop"]').length) return;
      if ($inputEl && $inputEl.length > 0) {
        if ($targetEl[0] !== $inputEl[0] && $targetEl.closest('.sheet-modal, .calendar-modal').length === 0) {
          calendar.close();
        }
      } else if (Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(e.target).closest('.sheet-modal, .calendar-modal').length === 0) {
        calendar.close();
      }
    }

    // Events
    Utils.extend(calendar, {
      attachInputEvents() {
        calendar.$inputEl.on('click', onInputClick);
        if (calendar.params.inputReadOnly) {
          calendar.$inputEl.on('focus mousedown', onInputFocus);
        }
      },
      detachInputEvents() {
        calendar.$inputEl.off('click', onInputClick);
        if (calendar.params.inputReadOnly) {
          calendar.$inputEl.off('focus mousedown', onInputFocus);
        }
      },
      attachHtmlEvents() {
        app.on('click', onHtmlClick);
      },
      detachHtmlEvents() {
        app.off('click', onHtmlClick);
      },
    });
    calendar.attachCalendarEvents = function attachCalendarEvents() {
      let allowItemClick = true;
      let isTouched;
      let isMoved;
      let touchStartX;
      let touchStartY;
      let touchCurrentX;
      let touchCurrentY;
      let touchStartTime;
      let touchEndTime;
      let currentTranslate;
      let wrapperWidth;
      let wrapperHeight;
      let percentage;
      let touchesDiff;
      let isScrolling;

      const { $el, $wrapperEl } = calendar;

      function handleTouchStart(e) {
        if (isMoved || isTouched) return;
        isTouched = true;
        touchStartX = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
        touchCurrentX = touchStartX;
        touchStartY = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
        touchCurrentY = touchStartY;
        touchStartTime = (new Date()).getTime();
        percentage = 0;
        allowItemClick = true;
        isScrolling = undefined;
        currentTranslate = calendar.monthsTranslate;
      }
      function handleTouchMove(e) {
        if (!isTouched) return;
        const { isHorizontal: isH } = calendar;

        touchCurrentX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
        touchCurrentY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
        if (typeof isScrolling === 'undefined') {
          isScrolling = !!(isScrolling || Math.abs(touchCurrentY - touchStartY) > Math.abs(touchCurrentX - touchStartX));
        }
        if (isH && isScrolling) {
          isTouched = false;
          return;
        }
        e.preventDefault();
        if (calendar.animating) {
          isTouched = false;
          return;
        }
        allowItemClick = false;
        if (!isMoved) {
          // First move
          isMoved = true;
          wrapperWidth = $wrapperEl[0].offsetWidth;
          wrapperHeight = $wrapperEl[0].offsetHeight;
          $wrapperEl.transition(0);
        }

        touchesDiff = isH ? touchCurrentX - touchStartX : touchCurrentY - touchStartY;
        percentage = touchesDiff / (isH ? wrapperWidth : wrapperHeight);
        currentTranslate = ((calendar.monthsTranslate * calendar.inverter) + percentage) * 100;

        // Transform wrapper
        $wrapperEl.transform(`translate3d(${isH ? currentTranslate : 0}%, ${isH ? 0 : currentTranslate}%, 0)`);
      }
      function handleTouchEnd() {
        if (!isTouched || !isMoved) {
          isTouched = false;
          isMoved = false;
          return;
        }
        isTouched = false;
        isMoved = false;

        touchEndTime = new Date().getTime();
        if (touchEndTime - touchStartTime < 300) {
          if (Math.abs(touchesDiff) < 10) {
            calendar.resetMonth();
          } else if (touchesDiff >= 10) {
            if (app.rtl) calendar.nextMonth();
            else calendar.prevMonth();
          } else if (app.rtl) calendar.prevMonth();
          else calendar.nextMonth();
        } else if (percentage <= -0.5) {
          if (app.rtl) calendar.prevMonth();
          else calendar.nextMonth();
        } else if (percentage >= 0.5) {
          if (app.rtl) calendar.nextMonth();
          else calendar.prevMonth();
        } else {
          calendar.resetMonth();
        }

        // Allow click
        setTimeout(() => {
          allowItemClick = true;
        }, 100);
      }

      function handleDayClick(e) {
        if (!allowItemClick) return;
        let $dayEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(e.target).parents('.calendar-day');
        if ($dayEl.length === 0 && Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(e.target).hasClass('calendar-day')) {
          $dayEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(e.target);
        }
        if ($dayEl.length === 0) return;
        if ($dayEl.hasClass('calendar-day-disabled')) return;
        if (!calendar.params.rangePicker) {
          if ($dayEl.hasClass('calendar-day-next')) calendar.nextMonth();
          if ($dayEl.hasClass('calendar-day-prev')) calendar.prevMonth();
        }
        const dateYear = $dayEl.attr('data-year');
        const dateMonth = $dayEl.attr('data-month');
        const dateDay = $dayEl.attr('data-day');
        calendar.emit(
          'local::dayClick calendarDayClick',
          calendar,
          $dayEl[0],
          dateYear,
          dateMonth,
          dateDay
        );
        if (!$dayEl.hasClass('calendar-day-selected') || calendar.params.multiple || calendar.params.rangePicker) {
          calendar.addValue(new Date(dateYear, dateMonth, dateDay, 0, 0, 0));
        }
        if (calendar.params.closeOnSelect) {
          if (
            (calendar.params.rangePicker && calendar.value.length === 2) ||
            !calendar.params.rangePicker
          ) {
            calendar.close();
          }
        }
      }
      function onNextMonthClick() {
        calendar.nextMonth();
      }
      function onPrevMonthClick() {
        calendar.prevMonth();
      }
      function onNextYearClick() {
        calendar.nextYear();
      }
      function onPrevYearClick() {
        calendar.prevYear();
      }

      const passiveListener = app.touchEvents.start === 'touchstart' && app.support.passiveListener ? { passive: true, capture: false } : false;
      // Selectors clicks
      $el.find('.calendar-prev-month-button').on('click', onPrevMonthClick);
      $el.find('.calendar-next-month-button').on('click', onNextMonthClick);
      $el.find('.calendar-prev-year-button').on('click', onPrevYearClick);
      $el.find('.calendar-next-year-button').on('click', onNextYearClick);
      // Day clicks
      $wrapperEl.on('click', handleDayClick);
      // Touch events
      {
        if (calendar.params.touchMove) {
          $wrapperEl.on(app.touchEvents.start, handleTouchStart, passiveListener);
          app.on('touchmove:active', handleTouchMove);
          app.on('touchend:passive', handleTouchEnd);
        }
      }

      calendar.detachCalendarEvents = function detachCalendarEvents() {
        $el.find('.calendar-prev-month-button').off('click', onPrevMonthClick);
        $el.find('.calendar-next-month-button').off('click', onNextMonthClick);
        $el.find('.calendar-prev-year-button').off('click', onPrevYearClick);
        $el.find('.calendar-next-year-button').off('click', onNextYearClick);
        $wrapperEl.off('click', handleDayClick);
        {
          if (calendar.params.touchMove) {
            $wrapperEl.off(app.touchEvents.start, handleTouchStart, passiveListener);
            app.off('touchmove:active', handleTouchMove);
            app.off('touchend:passive', handleTouchEnd);
          }
        }
      };
    };

    calendar.init();

    return calendar;
  }
  // eslint-disable-next-line
  normalizeDate(date) {
    const d = new Date(date);
    return new Date(d.getFullYear(), d.getMonth(), d.getDate());
  }
  normalizeValues(values) {
    const calendar = this;
    let newValues = [];
    if (values && Array.isArray(values)) {
      newValues = values.map(val => calendar.normalizeDate(val));
    }
    return newValues;
  }
  initInput() {
    const calendar = this;
    if (!calendar.$inputEl) return;
    if (calendar.params.inputReadOnly) calendar.$inputEl.prop('readOnly', true);
  }
  isPopover() {
    const calendar = this;
    const { app, modal, params } = calendar;
    if (params.openIn === 'sheet') return false;
    if (modal && modal.type !== 'popover') return false;

    if (!calendar.inline && calendar.inputEl) {
      if (params.openIn === 'popover') return true;
      else if (app.device.ios) {
        return !!app.device.ipad;
      } else if (app.width >= 768) {
        return true;
      }
    }
    return false;
  }
  formatDate(d) {
    const calendar = this;
    const date = new Date(d);
    const year = date.getFullYear();
    const month = date.getMonth();
    const month1 = month + 1;
    const day = date.getDate();
    const weekDay = date.getDay();
    const { dateFormat, monthNames, monthNamesShort, dayNames, dayNamesShort } = calendar.params;

    return dateFormat
      .replace(/yyyy/g, year)
      .replace(/yy/g, String(year).substring(2))
      .replace(/mm/g, month1 < 10 ? `0${month1}` : month1)
      .replace(/m(\W+)/g, `${month1}$1`)
      .replace(/MM/g, monthNames[month])
      .replace(/M(\W+)/g, `${monthNamesShort[month]}$1`)
      .replace(/dd/g, day < 10 ? `0${day}` : day)
      .replace(/d(\W+)/g, `${day}$1`)
      .replace(/DD/g, dayNames[weekDay])
      .replace(/D(\W+)/g, `${dayNamesShort[weekDay]}$1`);
  }
  formatValue() {
    const calendar = this;
    const { value } = calendar;
    if (calendar.params.formatValue) {
      return calendar.params.formatValue.call(calendar, value);
    }
    return value
      .map(v => calendar.formatDate(v))
      .join(calendar.params.rangePicker ? ' - ' : ', ');
  }
  addValue(newValue) {
    const calendar = this;
    const { multiple, rangePicker } = calendar.params;
    if (multiple) {
      if (!calendar.value) calendar.value = [];
      let inValuesIndex;
      for (let i = 0; i < calendar.value.length; i += 1) {
        if (new Date(newValue).getTime() === new Date(calendar.value[i]).getTime()) {
          inValuesIndex = i;
        }
      }
      if (typeof inValuesIndex === 'undefined') {
        calendar.value.push(newValue);
      } else {
        calendar.value.splice(inValuesIndex, 1);
      }
      calendar.updateValue();
    } else if (rangePicker) {
      if (!calendar.value) calendar.value = [];
      if (calendar.value.length === 2 || calendar.value.length === 0) {
        calendar.value = [];
      }
      if (calendar.value[0] !== newValue) calendar.value.push(newValue);
      else calendar.value = [];
      calendar.value.sort((a, b) => a - b);
      calendar.updateValue();
    } else {
      calendar.value = [newValue];
      calendar.updateValue();
    }
  }
  setValue(values) {
    const calendar = this;
    calendar.value = values;
    calendar.updateValue();
  }
  getValue() {
    const calendar = this;
    return calendar.value;
  }
  updateValue(onlyHeader) {
    const calendar = this;
    const {
      $el,
      $wrapperEl,
      $inputEl,
      value,
      params,
    } = calendar;
    let i;
    if ($el && $el.length > 0) {
      $wrapperEl.find('.calendar-day-selected').removeClass('calendar-day-selected');
      let valueDate;
      if (params.rangePicker && value.length === 2) {
        for (i = new Date(value[0]).getTime(); i <= new Date(value[1]).getTime(); i += 24 * 60 * 60 * 1000) {
          valueDate = new Date(i);
          $wrapperEl.find(`.calendar-day[data-date="${valueDate.getFullYear()}-${valueDate.getMonth()}-${valueDate.getDate()}"]`).addClass('calendar-day-selected');
        }
      } else {
        for (i = 0; i < calendar.value.length; i += 1) {
          valueDate = new Date(value[i]);
          $wrapperEl.find(`.calendar-day[data-date="${valueDate.getFullYear()}-${valueDate.getMonth()}-${valueDate.getDate()}"]`).addClass('calendar-day-selected');
        }
      }
    }
    if (!onlyHeader) {
      calendar.emit('local::change calendarChange', calendar, value);
    }


    if (($inputEl && $inputEl.length) || params.header) {
      const inputValue = calendar.formatValue(value);
      if (params.header && $el && $el.length) {
        $el.find('.calendar-selected-date').text(inputValue);
      }
      if ($inputEl && $inputEl.length && !onlyHeader) {
        $inputEl.val(inputValue);
        $inputEl.trigger('change');
      }
    }
  }
  updateCurrentMonthYear(dir) {
    const calendar = this;
    const { $months, $el, params } = calendar;
    if (typeof dir === 'undefined') {
      calendar.currentMonth = parseInt($months.eq(1).attr('data-month'), 10);
      calendar.currentYear = parseInt($months.eq(1).attr('data-year'), 10);
    } else {
      calendar.currentMonth = parseInt($months.eq(dir === 'next' ? ($months.length - 1) : 0).attr('data-month'), 10);
      calendar.currentYear = parseInt($months.eq(dir === 'next' ? ($months.length - 1) : 0).attr('data-year'), 10);
    }
    $el.find('.current-month-value').text(params.monthNames[calendar.currentMonth]);
    $el.find('.current-year-value').text(calendar.currentYear);
  }
  update() {
    const calendar = this;
    const { currentYear, currentMonth, $wrapperEl } = calendar;
    const currentDate = new Date(currentYear, currentMonth);
    const prevMonthHtml = calendar.renderMonth(currentDate, 'prev');
    const currentMonthHtml = calendar.renderMonth(currentDate);
    const nextMonthHtml = calendar.renderMonth(currentDate, 'next');

    $wrapperEl
      .transition(0)
      .html(`${prevMonthHtml}${currentMonthHtml}${nextMonthHtml}`)
      .transform('translate3d(0,0,0)');
    calendar.$months = $wrapperEl.find('.calendar-month');
    calendar.monthsTranslate = 0;
    calendar.setMonthsTranslate();
    calendar.$months.each((index, monthEl) => {
      calendar.emit(
        'local::monthAdd calendarMonthAdd',
        monthEl
      );
    });
  }
  onMonthChangeStart(dir) {
    const calendar = this;
    const { $months, currentYear, currentMonth } = calendar;
    calendar.updateCurrentMonthYear(dir);
    $months.removeClass('calendar-month-current calendar-month-prev calendar-month-next');
    const currentIndex = dir === 'next' ? $months.length - 1 : 0;

    $months.eq(currentIndex).addClass('calendar-month-current');
    $months.eq(dir === 'next' ? currentIndex - 1 : currentIndex + 1).addClass(dir === 'next' ? 'calendar-month-prev' : 'calendar-month-next');

    calendar.emit(
      'local::monthYearChangeStart calendarMonthYearChangeStart',
      calendar,
      currentYear,
      currentMonth
    );
  }
  onMonthChangeEnd(dir, rebuildBoth) {
    const calendar = this;
    const { currentYear, currentMonth, $wrapperEl, monthsTranslate } = calendar;
    calendar.animating = false;
    let nextMonthHtml;
    let prevMonthHtml;
    let currentMonthHtml;
    $wrapperEl
      .find('.calendar-month:not(.calendar-month-prev):not(.calendar-month-current):not(.calendar-month-next)')
      .remove();

    if (typeof dir === 'undefined') {
      dir = 'next'; // eslint-disable-line
      rebuildBoth = true; // eslint-disable-line
    }
    if (!rebuildBoth) {
      currentMonthHtml = calendar.renderMonth(new Date(currentYear, currentMonth), dir);
    } else {
      $wrapperEl.find('.calendar-month-next, .calendar-month-prev').remove();
      prevMonthHtml = calendar.renderMonth(new Date(currentYear, currentMonth), 'prev');
      nextMonthHtml = calendar.renderMonth(new Date(currentYear, currentMonth), 'next');
    }
    if (dir === 'next' || rebuildBoth) {
      $wrapperEl.append(currentMonthHtml || nextMonthHtml);
    }
    if (dir === 'prev' || rebuildBoth) {
      $wrapperEl.prepend(currentMonthHtml || prevMonthHtml);
    }
    const $months = $wrapperEl.find('.calendar-month');
    calendar.$months = $months;
    calendar.setMonthsTranslate(monthsTranslate);
    calendar.emit(
      'local::monthAdd calendarMonthAdd',
      calendar,
      dir === 'next' ? $months.eq($months.length - 1)[0] : $months.eq(0)[0]
    );
    calendar.emit(
      'local::monthYearChangeEnd calendarMonthYearChangeEnd',
      calendar,
      currentYear,
      currentMonth
    );
  }
  setMonthsTranslate(translate) {
    const calendar = this;
    const { $months, isHorizontal: isH, inverter } = calendar;
    // eslint-disable-next-line
    translate = translate || calendar.monthsTranslate || 0;
    if (typeof calendar.monthsTranslate === 'undefined') {
      calendar.monthsTranslate = translate;
    }
    $months.removeClass('calendar-month-current calendar-month-prev calendar-month-next');
    const prevMonthTranslate = -(translate + 1) * 100 * inverter;
    const currentMonthTranslate = -translate * 100 * inverter;
    const nextMonthTranslate = -(translate - 1) * 100 * inverter;
    $months.eq(0)
      .transform(`translate3d(${isH ? prevMonthTranslate : 0}%, ${isH ? 0 : prevMonthTranslate}%, 0)`)
      .addClass('calendar-month-prev');
    $months.eq(1)
      .transform(`translate3d(${isH ? currentMonthTranslate : 0}%, ${isH ? 0 : currentMonthTranslate}%, 0)`)
      .addClass('calendar-month-current');
    $months.eq(2)
      .transform(`translate3d(${isH ? nextMonthTranslate : 0}%, ${isH ? 0 : nextMonthTranslate}%, 0)`)
      .addClass('calendar-month-next');
  }
  nextMonth(transition) {
    const calendar = this;
    const { params, $wrapperEl, inverter, isHorizontal: isH } = calendar;
    if (typeof transition === 'undefined' || typeof transition === 'object') {
      transition = ''; // eslint-disable-line
      if (!params.animate) transition = 0; // eslint-disable-line
    }
    const nextMonth = parseInt(calendar.$months.eq(calendar.$months.length - 1).attr('data-month'), 10);
    const nextYear = parseInt(calendar.$months.eq(calendar.$months.length - 1).attr('data-year'), 10);
    const nextDate = new Date(nextYear, nextMonth);
    const nextDateTime = nextDate.getTime();
    const transitionEndCallback = !calendar.animating;
    if (params.maxDate) {
      if (nextDateTime > new Date(params.maxDate).getTime()) {
        calendar.resetMonth();
        return;
      }
    }
    calendar.monthsTranslate -= 1;
    if (nextMonth === calendar.currentMonth) {
      const nextMonthTranslate = -(calendar.monthsTranslate) * 100 * inverter;
      const nextMonthHtml = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(calendar.renderMonth(nextDateTime, 'next'))
        .transform(`translate3d(${isH ? nextMonthTranslate : 0}%, ${isH ? 0 : nextMonthTranslate}%, 0)`)
        .addClass('calendar-month-next');
      $wrapperEl.append(nextMonthHtml[0]);
      calendar.$months = $wrapperEl.find('.calendar-month');
      calendar.emit(
        'local::monthAdd calendarMonthAdd',
        calendar.$months.eq(calendar.$months.length - 1)[0]
      );
    }
    calendar.animating = true;
    calendar.onMonthChangeStart('next');
    const translate = (calendar.monthsTranslate * 100) * inverter;

    $wrapperEl.transition(transition).transform(`translate3d(${isH ? translate : 0}%, ${isH ? 0 : translate}%, 0)`);
    if (transitionEndCallback) {
      $wrapperEl.transitionEnd(() => {
        calendar.onMonthChangeEnd('next');
      });
    }
    if (!params.animate) {
      calendar.onMonthChangeEnd('next');
    }
  }
  prevMonth(transition) {
    const calendar = this;
    const { params, $wrapperEl, inverter, isHorizontal: isH } = calendar;
    if (typeof transition === 'undefined' || typeof transition === 'object') {
      transition = ''; // eslint-disable-line
      if (!params.animate) transition = 0; // eslint-disable-line
    }
    const prevMonth = parseInt(calendar.$months.eq(0).attr('data-month'), 10);
    const prevYear = parseInt(calendar.$months.eq(0).attr('data-year'), 10);
    const prevDate = new Date(prevYear, prevMonth + 1, -1);
    const prevDateTime = prevDate.getTime();
    const transitionEndCallback = !calendar.animating;
    if (params.minDate) {
      if (prevDateTime < new Date(params.minDate).getTime()) {
        calendar.resetMonth();
        return;
      }
    }
    calendar.monthsTranslate += 1;
    if (prevMonth === calendar.currentMonth) {
      const prevMonthTranslate = -(calendar.monthsTranslate) * 100 * inverter;
      const prevMonthHtml = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(calendar.renderMonth(prevDateTime, 'prev'))
        .transform(`translate3d(${isH ? prevMonthTranslate : 0}%, ${isH ? 0 : prevMonthTranslate}%, 0)`)
        .addClass('calendar-month-prev');
      $wrapperEl.prepend(prevMonthHtml[0]);
      calendar.$months = $wrapperEl.find('.calendar-month');
      calendar.emit(
        'local::monthAdd calendarMonthAdd',
        calendar.$months.eq(0)[0]
      );
    }
    calendar.animating = true;
    calendar.onMonthChangeStart('prev');
    const translate = (calendar.monthsTranslate * 100) * inverter;
    $wrapperEl
      .transition(transition)
      .transform(`translate3d(${isH ? translate : 0}%, ${isH ? 0 : translate}%, 0)`);
    if (transitionEndCallback) {
      $wrapperEl.transitionEnd(() => {
        calendar.onMonthChangeEnd('prev');
      });
    }
    if (!params.animate) {
      calendar.onMonthChangeEnd('prev');
    }
  }
  resetMonth(transition = '') {
    const calendar = this;
    const { $wrapperEl, inverter, isHorizontal: isH, monthsTranslate } = calendar;
    const translate = (monthsTranslate * 100) * inverter;
    $wrapperEl
      .transition(transition)
      .transform(`translate3d(${isH ? translate : 0}%, ${isH ? 0 : translate}%, 0)`);
  }
  // eslint-disable-next-line
  setYearMonth(year, month, transition) {
    const calendar = this;
    const { params, isHorizontal: isH, $wrapperEl, inverter } = calendar;
    // eslint-disable-next-line
    if (typeof year === 'undefined') year = calendar.currentYear;
    // eslint-disable-next-line
    if (typeof month === 'undefined') month = calendar.currentMonth;
    if (typeof transition === 'undefined' || typeof transition === 'object') {
      // eslint-disable-next-line
      transition = '';
      // eslint-disable-next-line
      if (!params.animate) transition = 0;
    }
    let targetDate;
    if (year < calendar.currentYear) {
      targetDate = new Date(year, month + 1, -1).getTime();
    } else {
      targetDate = new Date(year, month).getTime();
    }
    if (params.maxDate && targetDate > new Date(params.maxDate).getTime()) {
      return false;
    }
    if (params.minDate && targetDate < new Date(params.minDate).getTime()) {
      return false;
    }
    const currentDate = new Date(calendar.currentYear, calendar.currentMonth).getTime();
    const dir = targetDate > currentDate ? 'next' : 'prev';
    const newMonthHTML = calendar.renderMonth(new Date(year, month));
    calendar.monthsTranslate = calendar.monthsTranslate || 0;
    const prevTranslate = calendar.monthsTranslate;
    let monthTranslate;
    const transitionEndCallback = !calendar.animating;
    if (targetDate > currentDate) {
      // To next
      calendar.monthsTranslate -= 1;
      if (!calendar.animating) calendar.$months.eq(calendar.$months.length - 1).remove();
      $wrapperEl.append(newMonthHTML);
      calendar.$months = $wrapperEl.find('.calendar-month');
      monthTranslate = -(prevTranslate - 1) * 100 * inverter;
      calendar.$months
        .eq(calendar.$months.length - 1)
        .transform(`translate3d(${isH ? monthTranslate : 0}%, ${isH ? 0 : monthTranslate}%, 0)`)
        .addClass('calendar-month-next');
    } else {
      // To prev
      calendar.monthsTranslate += 1;
      if (!calendar.animating) calendar.$months.eq(0).remove();
      $wrapperEl.prepend(newMonthHTML);
      calendar.$months = $wrapperEl.find('.calendar-month');
      monthTranslate = -(prevTranslate + 1) * 100 * inverter;
      calendar.$months
        .eq(0)
        .transform(`translate3d(${isH ? monthTranslate : 0}%, ${isH ? 0 : monthTranslate}%, 0)`)
        .addClass('calendar-month-prev');
    }
    calendar.emit(
      'local::monthAdd calendarMonthAdd',
      dir === 'next'
        ? calendar.$months.eq(calendar.$months.length - 1)[0]
        : calendar.$months.eq(0)[0]
    );

    calendar.animating = true;
    calendar.onMonthChangeStart(dir);
    const wrapperTranslate = (calendar.monthsTranslate * 100) * inverter;
    $wrapperEl
      .transition(transition)
      .transform(`translate3d(${isH ? wrapperTranslate : 0}%, ${isH ? 0 : wrapperTranslate}%, 0)`);
    if (transitionEndCallback) {
      $wrapperEl.transitionEnd(() => {
        calendar.onMonthChangeEnd(dir, true);
      });
    }
    if (!params.animate) {
      calendar.onMonthChangeEnd(dir);
    }
  }
  nextYear() {
    const calendar = this;
    calendar.setYearMonth(calendar.currentYear + 1);
  }
  prevYear() {
    const calendar = this;
    calendar.setYearMonth(calendar.currentYear - 1);
  }
  // eslint-disable-next-line
  dateInRange(dayDate, range) {
    let match = false;
    let i;
    if (!range) return false;
    if (Array.isArray(range)) {
      for (i = 0; i < range.length; i += 1) {
        if (range[i].from || range[i].to) {
          if (range[i].from && range[i].to) {
            if ((dayDate <= new Date(range[i].to).getTime()) && (dayDate >= new Date(range[i].from).getTime())) {
              match = true;
            }
          } else if (range[i].from) {
            if (dayDate >= new Date(range[i].from).getTime()) {
              match = true;
            }
          } else if (range[i].to) {
            if (dayDate <= new Date(range[i].to).getTime()) {
              match = true;
            }
          }
        } else if (dayDate === new Date(range[i]).getTime()) {
          match = true;
        }
      }
    } else if (range.from || range.to) {
      if (range.from && range.to) {
        if ((dayDate <= new Date(range.to).getTime()) && (dayDate >= new Date(range.from).getTime())) {
          match = true;
        }
      } else if (range.from) {
        if (dayDate >= new Date(range.from).getTime()) {
          match = true;
        }
      } else if (range.to) {
        if (dayDate <= new Date(range.to).getTime()) {
          match = true;
        }
      }
    } else if (typeof range === 'function') {
      match = range(new Date(dayDate));
    }
    return match;
  }
  // eslint-disable-next-line
  daysInMonth(date) {
    const d = new Date(date);
    return new Date(d.getFullYear(), d.getMonth() + 1, 0).getDate();
  }
  renderMonths(date) {
    const calendar = this;
    if (calendar.params.renderMonths) {
      return calendar.params.renderMonths.call(calendar, date);
    }
    return `
      <div class="calendar-months-wrapper">
        ${calendar.renderMonth(date, 'prev')}
        ${calendar.renderMonth(date)}
        ${calendar.renderMonth(date, 'next')}
      </div>
    `.trim();
  }
  renderMonth(d, offset) {
    const calendar = this;
    const { params, value } = calendar;
    if (params.renderMonth) {
      return params.renderMonth.call(calendar, d, offset);
    }
    let date = new Date(d);
    let year = date.getFullYear();
    let month = date.getMonth();

    if (offset === 'next') {
      if (month === 11) date = new Date(year + 1, 0);
      else date = new Date(year, month + 1, 1);
    }
    if (offset === 'prev') {
      if (month === 0) date = new Date(year - 1, 11);
      else date = new Date(year, month - 1, 1);
    }
    if (offset === 'next' || offset === 'prev') {
      month = date.getMonth();
      year = date.getFullYear();
    }

    const currentValues = [];
    const today = new Date().setHours(0, 0, 0, 0);
    const minDate = params.minDate ? new Date(params.minDate).getTime() : null;
    const maxDate = params.maxDate ? new Date(params.maxDate).getTime() : null;
    const rows = 6;
    const cols = 7;
    const daysInPrevMonth = calendar.daysInMonth(new Date(date.getFullYear(), date.getMonth()).getTime() - (10 * 24 * 60 * 60 * 1000));
    const daysInMonth = calendar.daysInMonth(date);
    const minDayNumber = params.firstDay === 6 ? 0 : 1;

    let monthHtml = '';
    let dayIndex = 0 + (params.firstDay - 1);
    let disabled;
    let hasEvent;
    let firstDayOfMonthIndex = new Date(date.getFullYear(), date.getMonth()).getDay();
    if (firstDayOfMonthIndex === 0) firstDayOfMonthIndex = 7;

    if (value && value.length) {
      for (let i = 0; i < value.length; i += 1) {
        currentValues.push(new Date(value[i]).setHours(0, 0, 0, 0));
      }
    }

    for (let row = 1; row <= rows; row += 1) {
      let rowHtml = '';
      for (let col = 1; col <= cols; col += 1) {
        dayIndex += 1;
        let dayDate;
        let dayNumber = dayIndex - firstDayOfMonthIndex;
        let addClass = '';
        if (row === 1 && col === 1 && dayNumber > minDayNumber && params.firstDay !== 1) {
          dayIndex -= 7;
          dayNumber = dayIndex - firstDayOfMonthIndex;
        }

        const weekDayIndex = ((col - 1) + params.firstDay > 6)
          ? ((col - 1 - 7) + params.firstDay)
          : ((col - 1) + params.firstDay);

        if (dayNumber < 0) {
          dayNumber = daysInPrevMonth + dayNumber + 1;
          addClass += ' calendar-day-prev';
          dayDate = new Date(month - 1 < 0 ? year - 1 : year, month - 1 < 0 ? 11 : month - 1, dayNumber).getTime();
        } else {
          dayNumber += 1;
          if (dayNumber > daysInMonth) {
            dayNumber -= daysInMonth;
            addClass += ' calendar-day-next';
            dayDate = new Date(month + 1 > 11 ? year + 1 : year, month + 1 > 11 ? 0 : month + 1, dayNumber).getTime();
          } else {
            dayDate = new Date(year, month, dayNumber).getTime();
          }
        }
        // Today
        if (dayDate === today) addClass += ' calendar-day-today';

        // Selected
        if (params.rangePicker && currentValues.length === 2) {
          if (dayDate >= currentValues[0] && dayDate <= currentValues[1]) addClass += ' calendar-day-selected';
        } else if (currentValues.indexOf(dayDate) >= 0) addClass += ' calendar-day-selected';
        // Weekend
        if (params.weekendDays.indexOf(weekDayIndex) >= 0) {
          addClass += ' calendar-day-weekend';
        }
        // Has Events
        hasEvent = false;
        if (params.events) {
          if (calendar.dateInRange(dayDate, params.events)) {
            hasEvent = true;
          }
        }
        if (hasEvent) {
          addClass += ' calendar-day-has-events';
        }
        // Custom Ranges
        if (params.rangesClasses) {
          for (let k = 0; k < params.rangesClasses.length; k += 1) {
            if (calendar.dateInRange(dayDate, params.rangesClasses[k].range)) {
              addClass += ` ${params.rangesClasses[k].cssClass}`;
            }
          }
        }
        // Disabled
        disabled = false;
        if ((minDate && dayDate < minDate) || (maxDate && dayDate > maxDate)) {
          disabled = true;
        }
        if (params.disabled) {
          if (calendar.dateInRange(dayDate, params.disabled)) {
            disabled = true;
          }
        }
        if (disabled) {
          addClass += ' calendar-day-disabled';
        }

        dayDate = new Date(dayDate);
        const dayYear = dayDate.getFullYear();
        const dayMonth = dayDate.getMonth();
        rowHtml += `
          <div data-year="${dayYear}" data-month="${dayMonth}" data-day="${dayNumber}" class="calendar-day${addClass}" data-date="${dayYear}-${dayMonth}-${dayNumber}">
            <span>${dayNumber}</span>
          </div>`.trim();
      }
      monthHtml += `<div class="calendar-row">${rowHtml}</div>`;
    }
    monthHtml = `<div class="calendar-month" data-year="${year}" data-month="${month}">${monthHtml}</div>`;
    return monthHtml;
  }
  renderWeekHeader() {
    const calendar = this;
    if (calendar.params.renderWeekHeader) {
      return calendar.params.renderWeekHeader.call(calendar);
    }
    const { params } = calendar;
    let weekDaysHtml = '';
    for (let i = 0; i < 7; i += 1) {
      const dayIndex = (i + params.firstDay > 6)
        ? ((i - 7) + params.firstDay)
        : (i + params.firstDay);
      const dayName = params.dayNamesShort[dayIndex];
      weekDaysHtml += `<div class="calendar-week-day">${dayName}</div>`;
    }
    return `
      <div class="calendar-week-header">
        ${weekDaysHtml}
      </div>
    `.trim();
  }
  renderMonthSelector() {
    const calendar = this;
    const app = calendar.app;
    if (calendar.params.renderMonthSelector) {
      return calendar.params.renderMonthSelector.call(calendar);
    }

    let needsBlackIcon;
    if (calendar.inline && calendar.$containerEl.closest('.theme-dark').length === 0) {
      needsBlackIcon = true;
    } else if (app.root.closest('.theme-dark').length === 0) {
      needsBlackIcon = true;
    }

    const iconColor = app.theme === 'md' && needsBlackIcon ? 'color-black' : '';
    return `
      <div class="calendar-month-selector">
        <a href="#" class="link icon-only calendar-prev-month-button">
          <i class="icon icon-prev ${iconColor}"></i>
        </a>
        <span class="current-month-value"></span>
        <a href="#" class="link icon-only calendar-next-month-button">
          <i class="icon icon-next ${iconColor}"></i>
        </a>
      </div>
    `.trim();
  }
  renderYearSelector() {
    const calendar = this;
    const app = calendar.app;
    if (calendar.params.renderYearSelector) {
      return calendar.params.renderYearSelector.call(calendar);
    }

    let needsBlackIcon;
    if (calendar.inline && calendar.$containerEl.closest('.theme-dark').length === 0) {
      needsBlackIcon = true;
    } else if (app.root.closest('.theme-dark').length === 0) {
      needsBlackIcon = true;
    }

    const iconColor = app.theme === 'md' && needsBlackIcon ? 'color-black' : '';
    return `
      <div class="calendar-year-selector">
        <a href="#" class="link icon-only calendar-prev-year-button">
          <i class="icon icon-prev ${iconColor}"></i>
        </a>
        <span class="current-year-value"></span>
        <a href="#" class="link icon-only calendar-next-year-button">
          <i class="icon icon-next ${iconColor}"></i>
        </a>
      </div>
    `.trim();
  }
  renderHeader() {
    const calendar = this;
    if (calendar.params.renderHeader) {
      return calendar.params.renderHeader.call(calendar);
    }
    return `
      <div class="calendar-header">
        <div class="calendar-selected-date">${calendar.params.headerPlaceholder}</div>
      </div>
    `.trim();
  }
  renderFooter() {
    const calendar = this;
    const app = calendar.app;
    if (calendar.params.renderFooter) {
      return calendar.params.renderFooter.call(calendar);
    }
    return `
      <div class="calendar-footer">
        <a href="#" class="${app.theme === 'md' ? 'button' : 'link'} calendar-close sheet-close popover-close">${calendar.params.toolbarCloseText}</a>
      </div>
    `.trim();
  }
  renderToolbar() {
    const calendar = this;
    if (calendar.params.renderToolbar) {
      return calendar.params.renderToolbar.call(calendar, calendar);
    }
    return `
      <div class="toolbar no-shadow">
        <div class="toolbar-inner">
          ${calendar.renderMonthSelector()}
          ${calendar.renderYearSelector()}
        </div>
      </div>
    `.trim();
  }
  // eslint-disable-next-line
  renderInline() {
    const calendar = this;
    const { cssClass, toolbar, header, footer, rangePicker, weekHeader } = calendar.params;
    const { value } = calendar;
    const date = value && value.length ? value[0] : new Date().setHours(0, 0, 0);
    const inlineHtml = `
      <div class="calendar calendar-inline ${rangePicker ? 'calendar-range' : ''} ${cssClass || ''}">
        ${header ? calendar.renderHeader() : ''}
        ${toolbar ? calendar.renderToolbar() : ''}
        ${weekHeader ? calendar.renderWeekHeader() : ''}
        <div class="calendar-months">
          ${calendar.renderMonths(date)}
        </div>
        ${footer ? calendar.renderFooter() : ''}
      </div>
    `.trim();

    return inlineHtml;
  }
  renderCustomModal() {
    const calendar = this;
    const { cssClass, toolbar, header, footer, rangePicker, weekHeader } = calendar.params;
    const { value } = calendar;
    const date = value && value.length ? value[0] : new Date().setHours(0, 0, 0);
    const sheetHtml = `
      <div class="calendar calendar-modal ${rangePicker ? 'calendar-range' : ''} ${cssClass || ''}">
        ${header ? calendar.renderHeader() : ''}
        ${toolbar ? calendar.renderToolbar() : ''}
        ${weekHeader ? calendar.renderWeekHeader() : ''}
        <div class="calendar-months">
          ${calendar.renderMonths(date)}
        </div>
        ${footer ? calendar.renderFooter() : ''}
      </div>
    `.trim();

    return sheetHtml;
  }
  renderSheet() {
    const calendar = this;
    const { cssClass, toolbar, header, footer, rangePicker, weekHeader } = calendar.params;
    const { value } = calendar;
    const date = value && value.length ? value[0] : new Date().setHours(0, 0, 0);
    const sheetHtml = `
      <div class="sheet-modal calendar calendar-sheet ${rangePicker ? 'calendar-range' : ''} ${cssClass || ''}">
        ${header ? calendar.renderHeader() : ''}
        ${toolbar ? calendar.renderToolbar() : ''}
        ${weekHeader ? calendar.renderWeekHeader() : ''}
        <div class="sheet-modal-inner calendar-months">
          ${calendar.renderMonths(date)}
        </div>
        ${footer ? calendar.renderFooter() : ''}
      </div>
    `.trim();

    return sheetHtml;
  }
  renderPopover() {
    const calendar = this;
    const { cssClass, toolbar, header, footer, rangePicker, weekHeader } = calendar.params;
    const { value } = calendar;
    const date = value && value.length ? value[0] : new Date().setHours(0, 0, 0);
    const popoverHtml = `
      <div class="popover calendar-popover">
        <div class="popover-inner">
          <div class="calendar ${rangePicker ? 'calendar-range' : ''} ${cssClass || ''}">
            ${header ? calendar.renderHeader() : ''}
            ${toolbar ? calendar.renderToolbar() : ''}
            ${weekHeader ? calendar.renderWeekHeader() : ''}
            <div class="calendar-months">
              ${calendar.renderMonths(date)}
            </div>
            ${footer ? calendar.renderFooter() : ''}
          </div>
        </div>
      </div>
    `.trim();

    return popoverHtml;
  }
  render() {
    const calendar = this;
    const { params } = calendar;
    if (params.render) return params.render.call(calendar);
    if (!calendar.inline) {
      let modalType = params.openIn;
      if (modalType === 'auto') modalType = calendar.isPopover() ? 'popover' : 'sheet';

      if (modalType === 'popover') return calendar.renderPopover();
      else if (modalType === 'sheet') return calendar.renderSheet();
      return calendar.renderCustomModal();
    }
    return calendar.renderInline();
  }
  onOpen() {
    const calendar = this;
    const { initialized, $el, app, $inputEl, inline, value, params } = calendar;
    calendar.opened = true;

    // Init main events
    calendar.attachCalendarEvents();

    const updateValue = !value && params.value;

    // Set value
    if (!initialized) {
      if (value) calendar.setValue(value, 0);
      else if (params.value) {
        calendar.setValue(calendar.normalizeValues(params.value), 0);
      }
    } else if (value) {
      calendar.setValue(value, 0);
    }

    // Update current month and year
    calendar.updateCurrentMonthYear();

    // Set initial translate
    calendar.monthsTranslate = 0;
    calendar.setMonthsTranslate();

    // Update input value
    if (updateValue) calendar.updateValue();
    else if (params.header && value) {
      calendar.updateValue(true);
    }

    // Extra focus
    if (!inline && $inputEl.length && app.theme === 'md') {
      $inputEl.trigger('focus');
    }

    calendar.initialized = true;

    calendar.$months.each((index, monthEl) => {
      calendar.emit('local::monthAdd calendarMonthAdd', monthEl);
    });

    // Trigger events
    if ($el) {
      $el.trigger('calendar:open', calendar);
    }
    if ($inputEl) {
      $inputEl.trigger('calendar:open', calendar);
    }
    calendar.emit('local::open calendarOpen', calendar);
  }
  onOpened() {
    const calendar = this;
    if (calendar.$el) {
      calendar.$el.trigger('calendar:opened', calendar);
    }
    if (calendar.$inputEl) {
      calendar.$inputEl.trigger('calendar:opened', calendar);
    }
    calendar.emit('local::opened calendarOpened', calendar);
  }
  onClose() {
    const calendar = this;
    const app = calendar.app;

    if (calendar.$inputEl && app.theme === 'md') {
      calendar.$inputEl.trigger('blur');
    }
    if (calendar.detachCalendarEvents) {
      calendar.detachCalendarEvents();
    }

    if (calendar.$el) {
      calendar.$el.trigger('calendar:close', calendar);
    }
    if (calendar.$inputEl) {
      calendar.$inputEl.trigger('calendar:close', calendar);
    }
    calendar.emit('local::close calendarClose', calendar);
  }
  onClosed() {
    const calendar = this;
    calendar.opened = false;

    if (!calendar.inline) {
      Utils.nextTick(() => {
        if (calendar.modal && calendar.modal.el && calendar.modal.destroy) {
          if (!calendar.params.routableModals) {
            calendar.modal.destroy();
          }
        }
        delete calendar.modal;
      });
    }
    if (calendar.$el) {
      calendar.$el.trigger('calendar:closed', calendar);
    }
    if (calendar.$inputEl) {
      calendar.$inputEl.trigger('calendar:closed', calendar);
    }
    calendar.emit('local::closed calendarClosed', calendar);
  }
  open() {
    const calendar = this;
    const { app, opened, inline, $inputEl, params } = calendar;
    if (opened) return;

    if (inline) {
      calendar.$el = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(calendar.render());
      calendar.$el[0].f7Calendar = calendar;
      calendar.$wrapperEl = calendar.$el.find('.calendar-months-wrapper');
      calendar.$months = calendar.$wrapperEl.find('.calendar-month');
      calendar.$containerEl.append(calendar.$el);
      calendar.onOpen();
      calendar.onOpened();
      return;
    }
    let modalType = params.openIn;
    if (modalType === 'auto') {
      modalType = calendar.isPopover() ? 'popover' : 'sheet';
    }
    const modalContent = calendar.render();

    const modalParams = {
      targetEl: $inputEl,
      scrollToEl: calendar.params.scrollToInput ? $inputEl : undefined,
      content: modalContent,
      backdrop: modalType === 'popover' && app.params.popover.backdrop !== false,
      on: {
        open() {
          const modal = this;
          calendar.modal = modal;
          calendar.$el = modalType === 'popover' ? modal.$el.find('.calendar') : modal.$el;
          calendar.$wrapperEl = calendar.$el.find('.calendar-months-wrapper');
          calendar.$months = calendar.$wrapperEl.find('.calendar-month');
          calendar.$el[0].f7Calendar = calendar;
          if (modalType === 'customModal') {
            Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(calendar.$el).find('.calendar-close').once('click', () => {
              calendar.close();
            });
          }
          calendar.onOpen();
        },
        opened() { calendar.onOpened(); },
        close() { calendar.onClose(); },
        closed() { calendar.onClosed(); },
      },
    };
    if (calendar.params.routableModals) {
      calendar.view.router.navigate({
        url: calendar.url,
        route: {
          path: calendar.url,
          [modalType]: modalParams,
        },
      });
    } else {
      calendar.modal = app[modalType].create(modalParams);
      calendar.modal.open();
    }
  }
  close() {
    const calendar = this;
    const { opened, inline } = calendar;
    if (!opened) return;
    if (inline) {
      calendar.onClose();
      calendar.onClosed();
      return;
    }
    if (calendar.params.routableModals) {
      calendar.view.router.back();
    } else {
      calendar.modal.close();
    }
  }
  init() {
    const calendar = this;

    calendar.initInput();

    if (calendar.inline) {
      calendar.open();
      calendar.emit('local::init calendarInit', calendar);
      return;
    }

    if (!calendar.initialized && calendar.params.value) {
      calendar.setValue(calendar.normalizeValues(calendar.params.value));
    }

    // Attach input Events
    if (calendar.$inputEl) {
      calendar.attachInputEvents();
    }
    if (calendar.params.closeByOutsideClick) {
      calendar.attachHtmlEvents();
    }
    calendar.emit('local::init calendarInit', calendar);
  }
  destroy() {
    const calendar = this;
    if (calendar.destroyed) return;
    const { $el } = calendar;
    calendar.emit('local::beforeDestroy calendarBeforeDestroy', calendar);
    if ($el) $el.trigger('calendar:beforedestroy', calendar);

    calendar.close();

    // Detach Events
    if (calendar.$inputEl) {
      calendar.detachInputEvents();
    }
    if (calendar.params.closeByOutsideClick) {
      calendar.detachHtmlEvents();
    }

    if ($el && $el.length) delete calendar.$el[0].f7Calendar;
    Utils.deleteProps(calendar);
    calendar.destroyed = true;
  }
}

var Calendar$1 = {
  name: 'calendar',
  static: {
    Calendar,
  },
  create() {
    const app = this;
    app.calendar = ConstructorMethods({
      defaultSelector: '.calendar',
      constructor: Calendar,
      app,
      domProp: 'f7Calendar',
    });
    app.calendar.close = function close(el = '.calendar') {
      const $el = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(el);
      if ($el.length === 0) return;
      const calendar = $el[0].f7Calendar;
      if (!calendar || (calendar && !calendar.opened)) return;
      calendar.close();
    };
  },
  params: {
    calendar: {
      // Calendar settings
      monthNames: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],
      monthNamesShort: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
      dayNames: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
      dayNamesShort: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
      firstDay: 1, // First day of the week, Monday
      weekendDays: [0, 6], // Sunday and Saturday
      multiple: false,
      rangePicker: false,
      dateFormat: 'yyyy-mm-dd',
      direction: 'horizontal', // or 'vertical'
      minDate: null,
      maxDate: null,
      disabled: null, // dates range of disabled days
      events: null, // dates range of days with events
      rangesClasses: null, // array with custom classes date ranges
      touchMove: true,
      animate: true,
      closeOnSelect: false,
      monthSelector: true,
      yearSelector: true,
      weekHeader: true,
      value: null,
      // Common opener settings
      containerEl: null,
      openIn: 'auto', // or 'popover' or 'sheet' or 'customModal'
      formatValue: null,
      inputEl: null,
      inputReadOnly: true,
      closeByOutsideClick: true,
      scrollToInput: true,
      header: false,
      headerPlaceholder: 'Select date',
      footer: false,
      toolbar: true,
      toolbarCloseText: 'Done',
      cssClass: null,
      routableModals: true,
      view: null,
      url: 'date/',
      // Render functions
      renderWeekHeader: null,
      renderMonths: null,
      renderMonth: null,
      renderMonthSelector: null,
      renderYearSelector: null,
      renderHeader: null,
      renderFooter: null,
      renderToolbar: null,
      renderInline: null,
      renderPopover: null,
      renderSheet: null,
      render: null,
    },
  },
};

function pickerColumn (colEl, updateItems) {
  const picker = this;
  const app = picker.app;
  const $colEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(colEl);
  const colIndex = $colEl.index();
  const col = picker.cols[colIndex];
  if (col.divider) return;

  col.$el = $colEl;
  col.el = $colEl[0];
  col.$itemsEl = col.$el.find('.picker-items');
  col.items = col.$itemsEl.find('.picker-item');

  let itemHeight;
  let itemsHeight;
  let minTranslate;
  let maxTranslate;
  let animationFrameId;

  function updateDuringScroll() {
    animationFrameId = Utils.requestAnimationFrame(() => {
      col.updateItems(undefined, undefined, 0);
      updateDuringScroll();
    });
  }

  col.replaceValues = function replaceColValues(values, displayValues) {
    col.detachEvents();
    col.values = values;
    col.displayValues = displayValues;
    col.$itemsEl.html(picker.renderColumn(col, true));
    col.items = col.$itemsEl.find('.picker-item');
    col.calcSize();
    col.setValue(col.values[0], 0, true);
    col.attachEvents();
  };
  col.calcSize = function calcColSize() {
    if (picker.params.rotateEffect) {
      col.$el.removeClass('picker-column-absolute');
      if (!col.width) col.$el.css({ width: '' });
    }
    let colWidth = 0;
    const colHeight = col.$el[0].offsetHeight;
    itemHeight = col.items[0].offsetHeight;
    itemsHeight = itemHeight * col.items.length;
    minTranslate = ((colHeight / 2) - itemsHeight) + (itemHeight / 2);
    maxTranslate = (colHeight / 2) - (itemHeight / 2);
    if (col.width) {
      colWidth = col.width;
      if (parseInt(colWidth, 10) === colWidth) colWidth += 'px';
      col.$el.css({ width: colWidth });
    }
    if (picker.params.rotateEffect) {
      if (!col.width) {
        col.items.each((index, itemEl) => {
          const item = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(itemEl).children('span');
          colWidth = Math.max(colWidth, item[0].offsetWidth);
        });
        col.$el.css({ width: `${colWidth + 2}px` });
      }
      col.$el.addClass('picker-column-absolute');
    }
  };

  col.setValue = function setColValue(newValue, transition = '', valueCallbacks) {
    const newActiveIndex = col.$itemsEl.find(`.picker-item[data-picker-value="${newValue}"]`).index();
    if (typeof newActiveIndex === 'undefined' || newActiveIndex === -1) {
      return;
    }
    const newTranslate = (-newActiveIndex * itemHeight) + maxTranslate;
    // Update wrapper
    col.$itemsEl.transition(transition);
    col.$itemsEl.transform(`translate3d(0,${newTranslate}px,0)`);

    // Watch items
    if (picker.params.updateValuesOnMomentum && col.activeIndex && col.activeIndex !== newActiveIndex) {
      Utils.cancelAnimationFrame(animationFrameId);
      col.$itemsEl.transitionEnd(() => {
        Utils.cancelAnimationFrame(animationFrameId);
      });
      updateDuringScroll();
    }

    // Update items
    col.updateItems(newActiveIndex, newTranslate, transition, valueCallbacks);
  };

  col.updateItems = function updateColItems(activeIndex, translate, transition, valueCallbacks) {
    if (typeof translate === 'undefined') {
      // eslint-disable-next-line
      translate = Utils.getTranslate(col.$itemsEl[0], 'y');
    }
    // eslint-disable-next-line
    if (typeof activeIndex === 'undefined') activeIndex = -Math.round((translate - maxTranslate) / itemHeight);
    // eslint-disable-next-line
    if (activeIndex < 0) activeIndex = 0;
    // eslint-disable-next-line
    if (activeIndex >= col.items.length) activeIndex = col.items.length - 1;
    const previousActiveIndex = col.activeIndex;
    col.activeIndex = activeIndex;
    col.$itemsEl.find('.picker-item-selected').removeClass('picker-item-selected');

    col.items.transition(transition);

    const selectedItem = col.items.eq(activeIndex).addClass('picker-item-selected').transform('');

    // Set 3D rotate effect
    if (picker.params.rotateEffect) {
      col.items.each((index, itemEl) => {
        const $itemEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(itemEl);
        const itemOffsetTop = $itemEl.index() * itemHeight;
        const translateOffset = maxTranslate - translate;
        const itemOffset = itemOffsetTop - translateOffset;
        const percentage = itemOffset / itemHeight;
        const itemsFit = Math.ceil(col.height / itemHeight / 2) + 1;

        let angle = (-18 * percentage);
        if (angle > 180) angle = 180;
        if (angle < -180) angle = -180;
        if (Math.abs(percentage) > itemsFit) {
          $itemEl.addClass('picker-item-far');
        } else {
          $itemEl.removeClass('picker-item-far');
        }
        $itemEl.transform(`translate3d(0, ${-translate + maxTranslate}px, ${picker.needsOriginFix ? -110 : 0}px) rotateX(${angle}deg)`);
      });
    }

    if (valueCallbacks || typeof valueCallbacks === 'undefined') {
      // Update values
      col.value = selectedItem.attr('data-picker-value');
      col.displayValue = col.displayValues ? col.displayValues[activeIndex] : col.value;
      // On change callback
      if (previousActiveIndex !== activeIndex) {
        if (col.onChange) {
          col.onChange(picker, col.value, col.displayValue);
        }
        picker.updateValue();
      }
    }
  };

  let allowItemClick = true;
  let isTouched;
  let isMoved;
  let touchStartY;
  let touchCurrentY;
  let touchStartTime;
  let touchEndTime;
  let startTranslate;
  let returnTo;
  let currentTranslate;
  let prevTranslate;
  let velocityTranslate;
  function handleTouchStart(e) {
    if (isMoved || isTouched) return;
    e.preventDefault();
    isTouched = true;
    touchStartY = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
    touchCurrentY = touchStartY;
    touchStartTime = (new Date()).getTime();

    allowItemClick = true;
    startTranslate = Utils.getTranslate(col.$itemsEl[0], 'y');
    currentTranslate = startTranslate;
  }
  function handleTouchMove(e) {
    if (!isTouched) return;
    e.preventDefault();
    allowItemClick = false;
    touchCurrentY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
    if (!isMoved) {
      // First move
      Utils.cancelAnimationFrame(animationFrameId);
      isMoved = true;
      startTranslate = Utils.getTranslate(col.$itemsEl[0], 'y');
      currentTranslate = startTranslate;
      col.$itemsEl.transition(0);
    }

    const diff = touchCurrentY - touchStartY;
    currentTranslate = startTranslate + diff;
    returnTo = undefined;

    // Normalize translate
    if (currentTranslate < minTranslate) {
      currentTranslate = minTranslate - ((minTranslate - currentTranslate) ** 0.8);
      returnTo = 'min';
    }
    if (currentTranslate > maxTranslate) {
      currentTranslate = maxTranslate + ((currentTranslate - maxTranslate) ** 0.8);
      returnTo = 'max';
    }
    // Transform wrapper
    col.$itemsEl.transform(`translate3d(0,${currentTranslate}px,0)`);

    // Update items
    col.updateItems(undefined, currentTranslate, 0, picker.params.updateValuesOnTouchmove);

    // Calc velocity
    velocityTranslate = currentTranslate - prevTranslate || currentTranslate;
    prevTranslate = currentTranslate;
  }
  function handleTouchEnd() {
    if (!isTouched || !isMoved) {
      isTouched = false;
      isMoved = false;
      return;
    }
    isTouched = false;
    isMoved = false;
    col.$itemsEl.transition('');
    if (returnTo) {
      if (returnTo === 'min') {
        col.$itemsEl.transform(`translate3d(0,${minTranslate}px,0)`);
      } else col.$itemsEl.transform(`translate3d(0,${maxTranslate}px,0)`);
    }
    touchEndTime = new Date().getTime();
    let newTranslate;
    if (touchEndTime - touchStartTime > 300) {
      newTranslate = currentTranslate;
    } else {
      newTranslate = currentTranslate + (velocityTranslate * picker.params.momentumRatio);
    }

    newTranslate = Math.max(Math.min(newTranslate, maxTranslate), minTranslate);

    // Active Index
    const activeIndex = -Math.floor((newTranslate - maxTranslate) / itemHeight);

    // Normalize translate
    if (!picker.params.freeMode) newTranslate = (-activeIndex * itemHeight) + maxTranslate;

    // Transform wrapper
    col.$itemsEl.transform(`translate3d(0,${parseInt(newTranslate, 10)}px,0)`);

    // Update items
    col.updateItems(activeIndex, newTranslate, '', true);

    // Watch items
    if (picker.params.updateValuesOnMomentum) {
      updateDuringScroll();
      col.$itemsEl.transitionEnd(() => {
        Utils.cancelAnimationFrame(animationFrameId);
      });
    }

    // Allow click
    setTimeout(() => {
      allowItemClick = true;
    }, 100);
  }

  function handleClick() {
    if (!allowItemClick) return;
    Utils.cancelAnimationFrame(animationFrameId);
    const value = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(this).attr('data-picker-value');
    col.setValue(value);
  }

  const activeListener = app.support.passiveListener ? { passive: false, capture: false } : false;
  col.attachEvents = function attachColEvents() {
    col.$el.on(app.touchEvents.start, handleTouchStart, activeListener);
    app.on('touchmove:active', handleTouchMove);
    app.on('touchend:passive', handleTouchEnd);
    col.items.on('click', handleClick);
  };
  col.detachEvents = function detachColEvents() {
    col.$el.off(app.touchEvents.start, handleTouchStart, activeListener);
    app.off('touchmove:active', handleTouchMove);
    app.off('touchend:passive', handleTouchEnd);
    col.items.off('click', handleClick);
  };

  col.init = function initCol() {
    col.calcSize();
    col.$itemsEl.transform(`translate3d(0,${maxTranslate}px,0)`).transition(0);
    if (colIndex === 0) col.$el.addClass('picker-column-first');
    if (colIndex === picker.cols.length - 1) col.$el.addClass('picker-column-last');
    // Update items on init
    if (updateItems) col.updateItems(0, maxTranslate, 0);

    col.attachEvents();
  };

  col.destroy = function destroyCol() {
    col.detachEvents();
  };

  col.init();
}

class Picker extends Framework7Class {
  constructor(app, params = {}) {
    super(params, [app]);
    const picker = this;
    picker.params = Utils.extend({}, app.params.picker, params);

    let $containerEl;
    if (picker.params.containerEl) {
      $containerEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(picker.params.containerEl);
      if ($containerEl.length === 0) return picker;
    }

    let $inputEl;
    if (picker.params.inputEl) {
      $inputEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(picker.params.inputEl);
    }

    let view;
    if ($inputEl) {
      view = $inputEl.parents('.view').length && $inputEl.parents('.view')[0].f7View;
    }
    if (!view) view = app.views.main;

    Utils.extend(picker, {
      app,
      $containerEl,
      containerEl: $containerEl && $containerEl[0],
      inline: $containerEl && $containerEl.length > 0,
      needsOriginFix: app.device.ios || ((__WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].navigator.userAgent.toLowerCase().indexOf('safari') >= 0 && __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].navigator.userAgent.toLowerCase().indexOf('chrome') < 0) && !app.device.android),
      cols: [],
      $inputEl,
      inputEl: $inputEl && $inputEl[0],
      initialized: false,
      opened: false,
      url: picker.params.url,
      view,
    });

    function onResize() {
      picker.resizeCols();
    }
    function onInputClick() {
      picker.open();
    }
    function onInputFocus(e) {
      e.preventDefault();
    }
    function onHtmlClick(e) {
      const $targetEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(e.target);
      if (picker.isPopover()) return;
      if (!picker.opened) return;
      if ($targetEl.closest('[class*="backdrop"]').length) return;
      if ($inputEl && $inputEl.length > 0) {
        if ($targetEl[0] !== $inputEl[0] && $targetEl.closest('.sheet-modal').length === 0) {
          picker.close();
        }
      } else if (Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(e.target).closest('.sheet-modal').length === 0) {
        picker.close();
      }
    }

    // Events
    Utils.extend(picker, {
      attachResizeEvent() {
        app.on('resize', onResize);
      },
      detachResizeEvent() {
        app.off('resize', onResize);
      },
      attachInputEvents() {
        picker.$inputEl.on('click', onInputClick);
        if (picker.params.inputReadOnly) {
          picker.$inputEl.on('focus mousedown', onInputFocus);
        }
      },
      detachInputEvents() {
        picker.$inputEl.off('click', onInputClick);
        if (picker.params.inputReadOnly) {
          picker.$inputEl.off('focus mousedown', onInputFocus);
        }
      },
      attachHtmlEvents() {
        app.on('click', onHtmlClick);
      },
      detachHtmlEvents() {
        app.off('click', onHtmlClick);
      },
    });

    picker.init();

    return picker;
  }
  initInput() {
    const picker = this;
    if (!picker.$inputEl) return;
    if (picker.params.inputReadOnly) picker.$inputEl.prop('readOnly', true);
  }
  resizeCols() {
    const picker = this;
    if (!picker.opened) return;
    for (let i = 0; i < picker.cols.length; i += 1) {
      if (!picker.cols[i].divider) {
        picker.cols[i].calcSize();
        picker.cols[i].setValue(picker.cols[i].value, 0, false);
      }
    }
  }
  isPopover() {
    const picker = this;
    const { app, modal, params } = picker;
    if (params.openIn === 'sheet') return false;
    if (modal && modal.type !== 'popover') return false;

    if (!picker.inline && picker.inputEl) {
      if (params.openIn === 'popover') return true;
      else if (app.device.ios) {
        return !!app.device.ipad;
      } else if (app.width >= 768) {
        return true;
      }
    }
    return false;
  }
  formatValue() {
    const picker = this;
    const { value, displayValue } = picker;
    if (picker.params.formatValue) {
      return picker.params.formatValue.call(picker, value, displayValue);
    }
    return value.join(' ');
  }
  setValue(values, transition) {
    const picker = this;
    let valueIndex = 0;
    if (picker.cols.length === 0) {
      picker.value = values;
      picker.updateValue(values);
      return;
    }
    for (let i = 0; i < picker.cols.length; i += 1) {
      if (picker.cols[i] && !picker.cols[i].divider) {
        picker.cols[i].setValue(values[valueIndex], transition);
        valueIndex += 1;
      }
    }
  }
  getValue() {
    const picker = this;
    return picker.value;
  }
  updateValue(forceValues) {
    const picker = this;
    const newValue = forceValues || [];
    const newDisplayValue = [];
    let column;
    if (picker.cols.length === 0) {
      const noDividerColumns = picker.params.cols.filter(c => !c.divider);
      for (let i = 0; i < noDividerColumns.length; i += 1) {
        column = noDividerColumns[i];
        if (column.displayValues !== undefined && column.values !== undefined && column.values.indexOf(newValue[i]) !== -1) {
          newDisplayValue.push(column.displayValues[column.values.indexOf(newValue[i])]);
        } else {
          newDisplayValue.push(newValue[i]);
        }
      }
    } else {
      for (let i = 0; i < picker.cols.length; i += 1) {
        if (!picker.cols[i].divider) {
          newValue.push(picker.cols[i].value);
          newDisplayValue.push(picker.cols[i].displayValue);
        }
      }
    }

    if (newValue.indexOf(undefined) >= 0) {
      return;
    }
    picker.value = newValue;
    picker.displayValue = newDisplayValue;
    picker.emit('local::change pickerChange', picker, picker.value, picker.displayValue);
    if (picker.inputEl) {
      picker.$inputEl.val(picker.formatValue());
      picker.$inputEl.trigger('change');
    }
  }
  initColumn(colEl, updateItems) {
    const picker = this;
    pickerColumn.call(picker, colEl, updateItems);
  }
  // eslint-disable-next-line
  destroyColumn(colEl) {
    const picker = this;
    const $colEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(colEl);
    const index = $colEl.index();
    if (picker.cols[index] && picker.cols[index].destroy) {
      picker.cols[index].destroy();
    }
  }
  renderToolbar() {
    const picker = this;
    if (picker.params.renderToolbar) return picker.params.renderToolbar.call(picker, picker);
    return `
      <div class="toolbar no-shadow">
        <div class="toolbar-inner">
          <div class="left"></div>
          <div class="right">
            <a href="#" class="link sheet-close popover-close">${picker.params.toolbarCloseText}</a>
          </div>
        </div>
      </div>
    `.trim();
  }
  // eslint-disable-next-line
  renderColumn(col, onlyItems) {
    const colClasses = `picker-column ${col.textAlign ? `picker-column-${col.textAlign}` : ''} ${col.cssClass || ''}`;
    let columnHtml;
    let columnItemsHtml;

    if (col.divider) {
      columnHtml = `
        <div class="${colClasses} picker-column-divider">${col.content}</div>
      `;
    } else {
      columnItemsHtml = col.values.map((value, index) => `
        <div class="picker-item" data-picker-value="${value}">
          <span>${col.displayValues ? col.displayValues[index] : value}</span>
        </div>
      `).join('');
      columnHtml = `
        <div class="${colClasses}">
          <div class="picker-items">${columnItemsHtml}</div>
        </div>
      `;
    }

    return onlyItems ? columnItemsHtml.trim() : columnHtml.trim();
  }
  renderInline() {
    const picker = this;
    const { rotateEffect, cssClass, toolbar } = picker.params;
    const inlineHtml = `
      <div class="picker picker-inline ${rotateEffect ? 'picker-3d' : ''} ${cssClass || ''}">
        ${toolbar ? picker.renderToolbar() : ''}
        <div class="picker-columns">
          ${picker.cols.map(col => picker.renderColumn(col)).join('')}
          <div class="picker-center-highlight"></div>
        </div>
      </div>
    `.trim();

    return inlineHtml;
  }
  renderSheet() {
    const picker = this;
    const { rotateEffect, cssClass, toolbar } = picker.params;
    const sheetHtml = `
      <div class="sheet-modal picker picker-sheet ${rotateEffect ? 'picker-3d' : ''} ${cssClass || ''}">
        ${toolbar ? picker.renderToolbar() : ''}
        <div class="sheet-modal-inner picker-columns">
          ${picker.cols.map(col => picker.renderColumn(col)).join('')}
          <div class="picker-center-highlight"></div>
        </div>
      </div>
    `.trim();

    return sheetHtml;
  }
  renderPopover() {
    const picker = this;
    const { rotateEffect, cssClass, toolbar } = picker.params;
    const popoverHtml = `
      <div class="popover picker-popover">
        <div class="popover-inner">
          <div class="picker ${rotateEffect ? 'picker-3d' : ''} ${cssClass || ''}">
            ${toolbar ? picker.renderToolbar() : ''}
            <div class="picker-columns">
              ${picker.cols.map(col => picker.renderColumn(col)).join('')}
              <div class="picker-center-highlight"></div>
            </div>
          </div>
        </div>
      </div>
    `.trim();

    return popoverHtml;
  }
  render() {
    const picker = this;
    if (picker.params.render) return picker.params.render.call(picker);
    if (!picker.inline) {
      if (picker.isPopover()) return picker.renderPopover();
      return picker.renderSheet();
    }
    return picker.renderInline();
  }
  onOpen() {
    const picker = this;
    const { initialized, $el, app, $inputEl, inline, value, params } = picker;
    picker.opened = true;

    // Init main events
    picker.attachResizeEvent();

    // Init cols
    $el.find('.picker-column').each((index, colEl) => {
      let updateItems = true;
      if (
        (!initialized && params.value) ||
        (initialized && value)
      ) {
        updateItems = false;
      }
      picker.initColumn(colEl, updateItems);
    });

    // Set value
    if (!initialized) {
      if (value) picker.setValue(value, 0);
      else if (params.value) {
        picker.setValue(params.value, 0);
      }
    } else if (value) {
      picker.setValue(value, 0);
    }

    // Extra focus
    if (!inline && $inputEl.length && app.theme === 'md') {
      $inputEl.trigger('focus');
    }

    picker.initialized = true;

    // Trigger events
    if ($el) {
      $el.trigger('picker:open', picker);
    }
    if ($inputEl) {
      $inputEl.trigger('picker:open', picker);
    }
    picker.emit('local::open pickerOpen', picker);
  }
  onOpened() {
    const picker = this;

    if (picker.$el) {
      picker.$el.trigger('picker:opened', picker);
    }
    if (picker.$inputEl) {
      picker.$inputEl.trigger('picker:opened', picker);
    }
    picker.emit('local::opened pickerOpened', picker);
  }
  onClose() {
    const picker = this;
    const app = picker.app;

    // Detach events
    picker.detachResizeEvent();

    picker.cols.forEach((col) => {
      if (col.destroy) col.destroy();
    });
    if (picker.$inputEl && app.theme === 'md') {
      picker.$inputEl.trigger('blur');
    }

    if (picker.$el) {
      picker.$el.trigger('picker:close', picker);
    }
    if (picker.$inputEl) {
      picker.$inputEl.trigger('picker:close', picker);
    }
    picker.emit('local::close pickerClose', picker);
  }
  onClosed() {
    const picker = this;
    picker.opened = false;

    if (!picker.inline) {
      Utils.nextTick(() => {
        if (picker.modal && picker.modal.el && picker.modal.destroy) {
          if (!picker.params.routableModals) {
            picker.modal.destroy();
          }
        }
        delete picker.modal;
      });
    }

    if (picker.$el) {
      picker.$el.trigger('picker:closed', picker);
    }
    if (picker.$inputEl) {
      picker.$inputEl.trigger('picker:closed', picker);
    }
    picker.emit('local::closed pickerClosed', picker);
  }
  open() {
    const picker = this;
    const { app, opened, inline, $inputEl } = picker;
    if (opened) return;
    if (picker.cols.length === 0 && picker.params.cols.length) {
      picker.params.cols.forEach((col) => {
        picker.cols.push(col);
      });
    }
    if (inline) {
      picker.$el = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(picker.render());
      picker.$el[0].f7Picker = picker;
      picker.$containerEl.append(picker.$el);
      picker.onOpen();
      picker.onOpened();
      return;
    }
    const isPopover = picker.isPopover();
    const modalType = isPopover ? 'popover' : 'sheet';
    const modalParams = {
      targetEl: $inputEl,
      scrollToEl: picker.params.scrollToInput ? $inputEl : undefined,
      content: picker.render(),
      backdrop: isPopover,
      on: {
        open() {
          const modal = this;
          picker.modal = modal;
          picker.$el = isPopover ? modal.$el.find('.picker') : modal.$el;
          picker.$el[0].f7Picker = picker;
          picker.onOpen();
        },
        opened() { picker.onOpened(); },
        close() { picker.onClose(); },
        closed() { picker.onClosed(); },
      },
    };
    if (picker.params.routableModals) {
      picker.view.router.navigate({
        url: picker.url,
        route: {
          path: picker.url,
          [modalType]: modalParams,
        },
      });
    } else {
      picker.modal = app[modalType].create(modalParams);
      picker.modal.open();
    }
  }
  close() {
    const picker = this;
    const { opened, inline } = picker;
    if (!opened) return;
    if (inline) {
      picker.onClose();
      picker.onClosed();
      return;
    }
    if (picker.params.routableModals) {
      picker.view.router.back();
    } else {
      picker.modal.close();
    }
  }
  init() {
    const picker = this;

    picker.initInput();

    if (picker.inline) {
      picker.open();
      picker.emit('local::init pickerInit', picker);
      return;
    }

    if (!picker.initialized && picker.params.value) {
      picker.setValue(picker.params.value);
    }

    // Attach input Events
    if (picker.$inputEl) {
      picker.attachInputEvents();
    }
    if (picker.params.closeByOutsideClick) {
      picker.attachHtmlEvents();
    }
    picker.emit('local::init pickerInit', picker);
  }
  destroy() {
    const picker = this;
    if (picker.destroyed) return;
    const { $el } = picker;
    picker.emit('local::beforeDestroy pickerBeforeDestroy', picker);
    if ($el) $el.trigger('picker:beforedestroy', picker);

    picker.close();

    // Detach Events
    if (picker.$inputEl) {
      picker.detachInputEvents();
    }
    if (picker.params.closeByOutsideClick) {
      picker.detachHtmlEvents();
    }

    if ($el && $el.length) delete picker.$el[0].f7Picker;
    Utils.deleteProps(picker);
    picker.destroyed = true;
  }
}

var Picker$1 = {
  name: 'picker',
  static: {
    Picker,
  },
  create() {
    const app = this;
    app.picker = ConstructorMethods({
      defaultSelector: '.picker',
      constructor: Picker,
      app,
      domProp: 'f7Picker',
    });
    app.picker.close = function close(el = '.picker') {
      const $el = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(el);
      if ($el.length === 0) return;
      const picker = $el[0].f7Picker;
      if (!picker || (picker && !picker.opened)) return;
      picker.close();
    };
  },
  params: {
    picker: {
      // Picker settings
      updateValuesOnMomentum: false,
      updateValuesOnTouchmove: true,
      rotateEffect: false,
      momentumRatio: 7,
      freeMode: false,
      cols: [],
      // Common opener settings
      containerEl: null,
      openIn: 'auto', // or 'popover' or 'sheet'
      formatValue: null,
      inputEl: null,
      inputReadOnly: true,
      closeByOutsideClick: true,
      scrollToInput: true,
      toolbar: true,
      toolbarCloseText: 'Done',
      cssClass: null,
      routableModals: true,
      view: null,
      url: 'select/',
      // Render functions
      renderToolbar: null,
      render: null,
    },
  },
};

const InfiniteScroll = {
  handleScroll(el, e) {
    const app = this;
    const $el = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(el);
    const scrollTop = $el[0].scrollTop;
    const scrollHeight = $el[0].scrollHeight;
    const height = $el[0].offsetHeight;
    let distance = $el[0].getAttribute('data-infinite-distance');

    const virtualListContainer = $el.find('.virtual-list');
    let virtualList;

    const onTop = $el.hasClass('infinite-scroll-top');
    if (!distance) distance = 50;
    if (typeof distance === 'string' && distance.indexOf('%') >= 0) {
      distance = (parseInt(distance, 10) / 100) * height;
    }
    if (distance > height) distance = height;
    if (onTop) {
      if (scrollTop < distance) {
        $el.trigger('infinite', e);
        app.emit('infinite', $el[0], e);
      }
    } else if (scrollTop + height >= scrollHeight - distance) {
      if (virtualListContainer.length > 0) {
        virtualList = virtualListContainer.eq(-1)[0].f7VirtualList;
        if (virtualList && !virtualList.reachEnd && !virtualList.params.updatableScroll) {
          return;
        }
      }
      $el.trigger('infinite', e);
      app.emit('infinite', $el[0], e);
    }
  },
  create(el) {
    const $el = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(el);
    const app = this;
    $el.on('scroll', function handle(e) {
      app.infiniteScroll.handle(this, e);
    });
  },
  destroy(el) {
    const $el = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(el);
    $el.off('scroll');
  },
};
var InfiniteScroll$1 = {
  name: 'infiniteScroll',
  create() {
    const app = this;
    Utils.extend(app, {
      infiniteScroll: {
        handle: InfiniteScroll.handleScroll.bind(app),
        create: InfiniteScroll.create.bind(app),
        destroy: InfiniteScroll.destroy.bind(app),
      },
    });
  },
  on: {
    tabMounted(tabEl) {
      const app = this;
      const $tabEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(tabEl);
      $tabEl.find('.infinite-scroll-content').each((index, el) => {
        app.infiniteScroll.create(el);
      });
    },
    tabBeforeRemove(tabEl) {
      const $tabEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(tabEl);
      const app = this;
      $tabEl.find('.infinite-scroll-content').each((index, el) => {
        app.infiniteScroll.destroy(el);
      });
    },
    pageInit(page) {
      const app = this;
      page.$el.find('.infinite-scroll-content').each((index, el) => {
        app.infiniteScroll.create(el);
      });
    },
    pageBeforeRemove(page) {
      const app = this;
      page.$el.find('.infinite-scroll-content').each((index, el) => {
        app.infiniteScroll.destroy(el);
      });
    },
  },
};

class PullToRefresh extends Framework7Class {
  constructor(app, el) {
    super({}, [app]);
    const ptr = this;
    const $el = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(el);
    const $preloaderEl = $el.find('.ptr-preloader');

    ptr.$el = $el;
    ptr.el = $el[0];
    ptr.app = app;

    // Extend defaults with modules params
    ptr.useModulesParams({});

    const isMaterial = app.theme === 'md';

    // Done
    ptr.done = function done() {
      const $transitionTarget = isMaterial ? $preloaderEl : $el;
      $transitionTarget.transitionEnd(() => {
        $el.removeClass('ptr-transitioning ptr-pull-up ptr-pull-down');
        $el.trigger('ptr:done');
        ptr.emit('local::done ptrDone', $el[0]);
      });
      $el.removeClass('ptr-refreshing').addClass('ptr-transitioning');
      return ptr;
    };

    ptr.refresh = function refresh() {
      if ($el.hasClass('ptr-refreshing')) return ptr;
      $el.addClass('ptr-transitioning ptr-refreshing');
      $el.trigger('ptr:refresh', ptr.done);
      ptr.emit('local::refresh ptrRefresh', $el[0], ptr.done);
      return ptr;
    };

    // Events handling
    let touchId;
    let isTouched;
    let isMoved;
    const touchesStart = {};
    let isScrolling;
    let touchesDiff;
    let refresh = false;
    let useTranslate = false;
    let startTranslate = 0;
    let translate;
    let scrollTop;
    let wasScrolled;
    let triggerDistance;
    let dynamicTriggerDistance;
    let pullStarted;
    let hasNavbar = false;
    const $pageEl = $el.parents('.page');

    if ($pageEl.find('.navbar').length > 0 || $pageEl.parents('.view').children('.navbar').length > 0) hasNavbar = true;
    if ($pageEl.hasClass('no-navbar')) hasNavbar = false;
    if (!hasNavbar) $el.addClass('ptr-no-navbar');

    // Define trigger distance
    if ($el.attr('data-ptr-distance')) {
      dynamicTriggerDistance = true;
    } else {
      triggerDistance = isMaterial ? 66 : 44;
    }

    function handleTouchStart(e) {
      if (isTouched) {
        if (Device.os === 'android') {
          if ('targetTouches' in e && e.targetTouches.length > 1) return;
        } else return;
      }

      if ($el.hasClass('ptr-refreshing')) {
        return;
      }
      if (Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(e.target).closest('.sortable-handler').length) return;

      isMoved = false;
      pullStarted = false;
      isTouched = true;
      isScrolling = undefined;
      wasScrolled = undefined;
      if (e.type === 'touchstart') touchId = e.targetTouches[0].identifier;
      touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
      touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
    }

    function handleTouchMove(e) {
      if (!isTouched) return;
      let pageX;
      let pageY;
      let touch;
      if (e.type === 'touchmove') {
        if (touchId && e.touches) {
          for (let i = 0; i < e.touches.length; i += 1) {
            if (e.touches[i].identifier === touchId) {
              touch = e.touches[i];
            }
          }
        }
        if (!touch) touch = e.targetTouches[0];
        pageX = touch.pageX;
        pageY = touch.pageY;
      } else {
        pageX = e.pageX;
        pageY = e.pageY;
      }
      if (!pageX || !pageY) return;


      if (typeof isScrolling === 'undefined') {
        isScrolling = !!(isScrolling || Math.abs(pageY - touchesStart.y) > Math.abs(pageX - touchesStart.x));
      }
      if (!isScrolling) {
        isTouched = false;
        return;
      }

      scrollTop = $el[0].scrollTop;
      if (typeof wasScrolled === 'undefined' && scrollTop !== 0) wasScrolled = true;

      if (!isMoved) {
        $el.removeClass('ptr-transitioning');
        if (scrollTop > $el[0].offsetHeight) {
          isTouched = false;
          return;
        }
        if (dynamicTriggerDistance) {
          triggerDistance = $el.attr('data-ptr-distance');
          if (triggerDistance.indexOf('%') >= 0) triggerDistance = ($el[0].offsetHeight * parseInt(triggerDistance, 10)) / 100;
        }
        startTranslate = $el.hasClass('ptr-refreshing') ? triggerDistance : 0;
        if ($el[0].scrollHeight === $el[0].offsetHeight || Device.os !== 'ios' || isMaterial) {
          useTranslate = true;
        } else {
          useTranslate = false;
        }
      }
      isMoved = true;
      touchesDiff = pageY - touchesStart.y;

      if ((touchesDiff > 0 && scrollTop <= 0) || scrollTop < 0) {
        // iOS 8 fix
        if (Device.os === 'ios' && parseInt(Device.osVersion.split('.')[0], 10) > 7 && scrollTop === 0 && !wasScrolled) useTranslate = true;

        if (useTranslate) {
          e.preventDefault();
          translate = (touchesDiff ** 0.85) + startTranslate;
          if (isMaterial) {
            $preloaderEl.transform(`translate3d(0,${translate}px,0)`)
              .find('.ptr-arrow').transform(`rotate(${(180 * (touchesDiff / 66)) + 100}deg)`);
          } else {
            $el.transform(`translate3d(0,${translate}px,0)`);
          }
        }
        if ((useTranslate && (touchesDiff ** 0.85) > triggerDistance) || (!useTranslate && touchesDiff >= triggerDistance * 2)) {
          refresh = true;
          $el.addClass('ptr-pull-up').removeClass('ptr-pull-down');
        } else {
          refresh = false;
          $el.removeClass('ptr-pull-up').addClass('ptr-pull-down');
        }
        if (!pullStarted) {
          $el.trigger('ptr:pullstart');
          ptr.emit('local::pullStart ptrPullStart', $el[0]);
          pullStarted = true;
        }
        $el.trigger('ptr:pullmove', {
          event: e,
          scrollTop,
          translate,
          touchesDiff,
        });
        ptr.emit('local::pullMove ptrPullMove', $el[0], {
          event: e,
          scrollTop,
          translate,
          touchesDiff,
        });
      } else {
        pullStarted = false;
        $el.removeClass('ptr-pull-up ptr-pull-down');
        refresh = false;
      }
    }
    function handleTouchEnd(e) {
      if (e.type === 'touchend' && e.changedTouches && e.changedTouches.length > 0 && touchId) {
        if (e.changedTouches[0].identifier !== touchId) {
          isTouched = false;
          isScrolling = false;
          isMoved = false;
          touchId = null;
          return;
        }
      }
      if (!isTouched || !isMoved) {
        isTouched = false;
        isMoved = false;
        return;
      }
      if (translate) {
        $el.addClass('ptr-transitioning');
        translate = 0;
      }
      if (isMaterial) {
        $preloaderEl.transform('')
          .find('.ptr-arrow').transform('');
      } else {
        $el.transform('');
      }

      if (refresh) {
        $el.addClass('ptr-refreshing');
        $el.trigger('ptr:refresh', ptr.done);
        ptr.emit('local::refresh ptrRefresh', $el[0], ptr.done);
      } else {
        $el.removeClass('ptr-pull-down');
      }
      isTouched = false;
      isMoved = false;
      if (pullStarted) {
        $el.trigger('ptr:pullend');
        ptr.emit('local::pullEnd ptrPullEnd', $el[0]);
      }
    }

    if (!$pageEl.length || !$el.length) return ptr;

    $el[0].f7PullToRefresh = ptr;

    // Events
    ptr.attachEvents = function attachEvents() {
      const passive = Support.passiveListener ? { passive: true } : false;
      $el.on(app.touchEvents.start, handleTouchStart, passive);
      app.on('touchmove', handleTouchMove);
      app.on('touchend:passive', handleTouchEnd);
    };
    ptr.detachEvents = function detachEvents() {
      const passive = Support.passiveListener ? { passive: true } : false;
      $el.off(app.touchEvents.start, handleTouchStart, passive);
      app.off('touchmove', handleTouchMove);
      app.off('touchend:passive', handleTouchEnd);
    };

    // Install Modules
    ptr.useModules();

    // Init
    ptr.init();

    return ptr;
  }
  init() {
    const ptr = this;
    ptr.attachEvents();
  }
  destroy() {
    let ptr = this;
    ptr.emit('local::beforeDestroy ptrBeforeDestroy', ptr);
    ptr.$el.trigger('ptr:beforedestroy', ptr);
    delete ptr.el.f7PullToRefresh;
    ptr.detachEvents();
    Utils.deleteProps(ptr);
    ptr = null;
  }
}

var PullToRefresh$1 = {
  name: 'pullToRefresh',
  create() {
    const app = this;
    app.ptr = Utils.extend(
      ConstructorMethods({
        defaultSelector: '.ptr-content',
        constructor: PullToRefresh,
        app,
        domProp: 'f7PullToRefresh',
      }),
      {
        done(el) {
          const ptr = app.ptr.get(el);
          if (ptr) return ptr.done();
          return undefined;
        },
        refresh(el) {
          const ptr = app.ptr.get(el);
          if (ptr) return ptr.refresh();
          return undefined;
        },
      }
    );
  },
  static: {
    PullToRefresh,
  },
  on: {
    tabMounted(tabEl) {
      const app = this;
      const $tabEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(tabEl);
      $tabEl.find('.ptr-content').each((index, el) => {
        app.ptr.create(el);
      });
    },
    tabBeforeRemove(tabEl) {
      const $tabEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(tabEl);
      const app = this;
      $tabEl.find('.ptr-content').each((index, el) => {
        app.ptr.destroy(el);
      });
    },
    pageInit(page) {
      const app = this;
      page.$el.find('.ptr-content').each((index, el) => {
        app.ptr.create(el);
      });
    },
    pageBeforeRemove(page) {
      const app = this;
      page.$el.find('.ptr-content').each((index, el) => {
        app.ptr.destroy(el);
      });
    },
  },
};

const Lazy = {
  destroy(pageEl) {
    const $pageEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(pageEl).closest('.page');
    if (!$pageEl.length) return;
    if ($pageEl[0].f7LazyDestroy) {
      $pageEl[0].f7LazyDestroy();
    }
  },
  create(pageEl) {
    const app = this;
    const $pageEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(pageEl).closest('.page').eq(0);

    // Lazy images
    const lazyLoadImages = $pageEl.find('.lazy');
    if (lazyLoadImages.length === 0 && !$pageEl.hasClass('lazy')) return;

    // Placeholder
    const placeholderSrc = app.params.lazy.placeholder;

    if (placeholderSrc !== false) {
      lazyLoadImages.each((index, lazyEl) => {
        if (Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(lazyEl).attr('data-src') && !Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(lazyEl).attr('src')) Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(lazyEl).attr('src', placeholderSrc);
      });
    }

    // load image
    const imagesSequence = [];
    let imageIsLoading = false;

    function onImageComplete(lazyEl) {
      if (imagesSequence.indexOf(lazyEl) >= 0) {
        imagesSequence.splice(imagesSequence.indexOf(lazyEl), 1);
      }
      imageIsLoading = false;
      if (app.params.lazy.sequential && imagesSequence.length > 0) {
        imageIsLoading = true;
        app.lazy.loadImage(imagesSequence[0], onImageComplete);
      }
    }

    function lazyHandler() {
      app.lazy.load($pageEl, (lazyEl) => {
        if (app.params.lazy.sequential && imageIsLoading) {
          if (imagesSequence.indexOf(lazyEl) < 0) imagesSequence.push(lazyEl);
          return;
        }
        imageIsLoading = true;
        app.lazy.loadImage(lazyEl, onImageComplete);
      });
    }

    function attachEvents() {
      $pageEl[0].f7LazyAttached = true;
      $pageEl.on('lazy', lazyHandler);
      $pageEl.on('scroll', lazyHandler, true);
      $pageEl.find('.tab').on('tab:mounted tab:show', lazyHandler);
      app.on('resize', lazyHandler);
    }
    function detachEvents() {
      $pageEl[0].f7LazyAttached = false;
      delete $pageEl[0].f7LazyAttached;
      $pageEl.off('lazy', lazyHandler);
      $pageEl.off('scroll', lazyHandler, true);
      $pageEl.find('.tab').off('tab:mounted tab:show', lazyHandler);
      app.off('resize', lazyHandler);
    }

    // Store detach function
    if (!$pageEl[0].f7LazyDestroy) {
      $pageEl[0].f7LazyDestroy = detachEvents;
    }

    // Attach events
    if (!$pageEl[0].f7LazyAttached) {
      attachEvents();
    }

    // Run loader on page load/init
    lazyHandler();
  },
  isInViewport(lazyEl) {
    const app = this;
    const rect = lazyEl.getBoundingClientRect();
    const threshold = app.params.lazy.threshold || 0;

    return (
      rect.top >= (0 - threshold) &&
      rect.left >= (0 - threshold) &&
      rect.top <= (app.height + threshold) &&
      rect.left <= (app.width + threshold)
    );
  },
  loadImage(imageEl, callback) {
    const app = this;
    const $imageEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(imageEl);

    const bg = $imageEl.attr('data-background');
    const src = bg || $imageEl.attr('data-src');
    if (!src) return;
    function onLoad() {
      $imageEl.removeClass('lazy').addClass('lazy-loaded');
      if (bg) {
        $imageEl.css('background-image', `url(${src})`);
      } else {
        $imageEl.attr('src', src);
      }
      if (callback) callback(imageEl);
      $imageEl.trigger('lazy:loaded');
      app.emit('lazyLoaded', $imageEl[0]);
    }

    function onError() {
      $imageEl.removeClass('lazy').addClass('lazy-loaded');
      if (bg) {
        $imageEl.css('background-image', `url(${app.params.lazy.placeholder || ''})`);
      } else {
        $imageEl.attr('src', app.params.lazy.placeholder || '');
      }
      if (callback) callback(imageEl);
      $imageEl.trigger('lazy:error');
      app.emit('lazyError', $imageEl[0]);
    }
    const image = new __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].Image();
    image.onload = onLoad;
    image.onerror = onError;
    image.src = src;

    $imageEl.removeAttr('data-src').removeAttr('data-background');

    // Add loaded callback and events
    $imageEl.trigger('lazy:load');
    app.emit('lazyLoad', $imageEl[0]);
  },
  load(pageEl, callback) {
    const app = this;
    let $pageEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(pageEl);
    if (!$pageEl.hasClass('page')) $pageEl = $pageEl.parents('.page').eq(0);
    if ($pageEl.length === 0) {
      return;
    }
    $pageEl.find('.lazy').each((index, lazyEl) => {
      const $lazyEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(lazyEl);
      if ($lazyEl.parents('.tab:not(.tab-active)').length > 0) {
        return;
      }
      if (app.lazy.isInViewport(lazyEl)) {
        if (callback) callback(lazyEl);
        else app.lazy.loadImage(lazyEl);
      }
    });
  },

};
var Lazy$1 = {
  name: 'lazy',
  params: {
    lazy: {
      placeholder: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAAA1BMVEXCwsK592mkAAAACklEQVQI12NgAAAAAgAB4iG8MwAAAABJRU5ErkJggg==',
      threshold: 0,
      sequential: true,
    },
  },
  create() {
    const app = this;
    Utils.extend(app, {
      lazy: {
        create: Lazy.create.bind(app),
        destroy: Lazy.destroy.bind(app),
        loadImage: Lazy.loadImage.bind(app),
        load: Lazy.load.bind(app),
        isInViewport: Lazy.isInViewport.bind(app),
      },
    });
  },
  on: {
    pageInit(page) {
      const app = this;
      if (page.$el.find('.lazy').length > 0 || page.$el.hasClass('lazy')) {
        app.lazy.create(page.$el);
      }
    },
    pageAfterIn(page) {
      const app = this;
      if (page.$el.find('.lazy').length > 0 || page.$el.hasClass('lazy')) {
        app.lazy.create(page.$el);
      }
    },
    pageBeforeRemove(page) {
      const app = this;
      if (page.$el.find('.lazy').length > 0 || page.$el.hasClass('lazy')) {
        app.lazy.destroy(page.$el);
      }
    },
    tabMounted(tabEl) {
      const app = this;
      const $tabEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(tabEl);
      if ($tabEl.find('.lazy').length > 0 || $tabEl.hasClass('lazy')) {
        app.lazy.create($tabEl);
      }
    },
    tabBeforeRemove(tabEl) {
      const app = this;
      const $tabEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(tabEl);
      if ($tabEl.find('.lazy').length > 0 || $tabEl.hasClass('lazy')) {
        app.lazy.destroy($tabEl);
      }
    },
  },
};

class DataTable extends Framework7Class {
  constructor(app, params = {}) {
    super(params, [app]);

    const table = this;

    const defaults = {

    };

    // Extend defaults with modules params
    table.useModulesParams(defaults);

    table.params = Utils.extend(defaults, params);

    // El
    const $el = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(table.params.el);
    if ($el.length === 0) return undefined;

    table.$el = $el;
    table.el = $el[0];

    if (table.$el[0].f7DataTable) {
      const instance = table.$el[0].f7DataTable;
      table.destroy();
      return instance;
    }

    table.$el[0].f7DataTable = table;

    Utils.extend(table, {
      collapsible: $el.hasClass('data-table-collapsible'),
      // Headers
      $headerEl: $el.find('.data-table-header'),
      $headerSelectedEl: $el.find('.data-table-header-selected'),
    });

    // Events
    function handleChange(e) {
      if (e.detail && e.detail.sentByF7DataTable) {
        // Scripted event, don't do anything
        return;
      }
      const $inputEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(this);
      const checked = $inputEl[0].checked;
      const columnIndex = $inputEl.parents('td,th').index();

      if ($inputEl.parents('thead').length > 0) {
        if (columnIndex === 0) {
          $el
            .find('tbody tr')[checked ? 'addClass' : 'removeClass']('data-table-row-selected');
        }
        $el
          .find(`tbody tr td:nth-child(${columnIndex + 1}) input`)
          .prop('checked', checked)
          .trigger('change', { sentByF7DataTable: true });
      } else {
        if (columnIndex === 0) {
          $inputEl.parents('tr')[checked ? 'addClass' : 'removeClass']('data-table-row-selected');
        }

        if (!checked) {
          $el.find(`thead .checkbox-cell:nth-child(${columnIndex + 1}) input[type="checkbox"]`).prop('checked', false);
        } else if ($el.find(`tbody .checkbox-cell:nth-child(${columnIndex + 1}) input[type="checkbox"]:checked`).length === $el.find('tbody tr').length) {
          $el.find(`thead .checkbox-cell:nth-child(${columnIndex + 1}) input[type="checkbox"]`).prop('checked', true).trigger('change', { sentByF7DataTable: true });
        }
      }
      table.checkSelectedHeader();
    }
    function handleSortableClick() {
      const $cellEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(this);
      const isActive = $cellEl.hasClass('sortable-cell-active');
      const currentSort = $cellEl.hasClass('sortable-desc') ? 'desc' : 'asc';
      let newSort;
      if (isActive) {
        newSort = currentSort === 'desc' ? 'asc' : 'desc';
        $cellEl.removeClass('sortable-desc sortable-asc').addClass(`sortable-${newSort}`);
      } else {
        $el.find('thead .sortable-cell-active').removeClass('sortable-cell-active');
        $cellEl.addClass('sortable-cell-active');
        newSort = currentSort;
      }
      $cellEl.trigger('datatable:sort', newSort);
      table.emit('local::sort dataTableSort', table, newSort);
    }
    table.attachEvents = function attachEvents() {
      table.$el.on('change', '.checkbox-cell input[type="checkbox"]', handleChange);
      table.$el.find('thead .sortable-cell').on('click', handleSortableClick);
    };
    table.detachEvents = function detachEvents() {
      table.$el.off('change', '.checkbox-cell input[type="checkbox"]', handleChange);
      table.$el.find('thead .sortable-cell').off('click', handleSortableClick);
    };

    // Install Modules
    table.useModules();

    // Init
    table.init();

    return table;
  }
  setCollapsibleLabels() {
    const table = this;
    if (!table.collapsible) return;
    table.$el.find('tbody td:not(.checkbox-cell)').each((index, el) => {
      const $el = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(el);
      const elIndex = $el.index();
      const collpsibleTitle = $el.attr('data-collapsible-title');
      if (!collpsibleTitle && collpsibleTitle !== '') {
        $el.attr('data-collapsible-title', table.$el.find('thead th').eq(elIndex).text());
      }
    });
  }
  checkSelectedHeader() {
    const table = this;
    if (table.$headerEl.length > 0 && table.$headerSelectedEl.length > 0) {
      const checkedItems = table.$el.find('tbody .checkbox-cell input:checked').length;
      table.$el[checkedItems > 0 ? 'addClass' : 'removeClass']('data-table-has-checked');
      table.$headerSelectedEl.find('.data-table-selected-count').text(checkedItems);
    }
  }
  init() {
    const table = this;
    table.attachEvents();
    table.setCollapsibleLabels();
    table.checkSelectedHeader();
  }
  destroy() {
    let table = this;

    table.$el.trigger('datatable:beforedestroy', table);
    table.emit('local::beforeDestroy datatableBeforeDestroy', table);

    table.attachEvents();
    table.$el[0].f7DataTable = null;
    delete table.$el[0].f7DataTable;
    Utils.deleteProps(table);
    table = null;
  }
}

var DataTable$1 = {
  name: 'dataTable',
  static: {
    DataTable,
  },
  create() {
    const app = this;
    app.dataTable = ConstructorMethods({
      defaultSelector: '.data-table',
      constructor: DataTable,
      app,
      domProp: 'f7DataTable',
    });
  },
  on: {
    tabBeforeRemove(tabEl) {
      const app = this;
      Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(tabEl).find('.data-table-init').each((index, tableEl) => {
        app.dataTable.destroy(tableEl);
      });
    },
    tabMounted(tabEl) {
      const app = this;
      Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(tabEl).find('.data-table-init').each((index, tableEl) => {
        app.dataTable.create({ el: tableEl });
      });
    },
    pageBeforeRemove(page) {
      const app = this;
      page.$el.find('.data-table-init').each((index, tableEl) => {
        app.dataTable.destroy(tableEl);
      });
    },
    pageInit(page) {
      const app = this;
      page.$el.find('.data-table-init').each((index, tableEl) => {
        app.dataTable.create({ el: tableEl });
      });
    },
  },
  clicks: {

  },
};

const Fab = {
  morphOpen(fabEl, targetEl) {
    const app = this;
    const $fabEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(fabEl);
    const $targetEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(targetEl);
    if ($targetEl.length === 0) return;

    $targetEl.transition(0).addClass('fab-morph-target-visible');
    const target = {
      width: $targetEl[0].offsetWidth,
      height: $targetEl[0].offsetHeight,
      offset: $targetEl.offset(),
      borderRadius: $targetEl.css('border-radius'),
      zIndex: $targetEl.css('z-index'),
    };
    const fab = {
      width: $fabEl[0].offsetWidth,
      height: $fabEl[0].offsetHeight,
      offset: $fabEl.offset(),
      translateX: Utils.getTranslate($fabEl[0], 'x'),
      translateY: Utils.getTranslate($fabEl[0], 'y'),
    };

    $fabEl[0].f7FabMorphData = {
      $targetEl,
      target,
      fab,
    };

    const diffX = (fab.offset.left + (fab.width / 2)) -
                  (target.offset.left + (target.width / 2)) -
                  fab.translateX;
    const diffY = (fab.offset.top + (fab.height / 2)) -
                  (target.offset.top + (target.height / 2)) -
                  fab.translateY;
    const scaleX = target.width / fab.width;
    const scaleY = target.height / fab.height;

    let borderRadius = Math.ceil(parseInt(target.borderRadius, 10) / Math.max(scaleX, scaleY));
    if (borderRadius > 0) borderRadius += 2;

    $fabEl[0].f7FabMorphResizeHandler = function resizeHandler() {
      $fabEl.transition(0).transform('');
      $targetEl.transition(0);
      target.width = $targetEl[0].offsetWidth;
      target.height = $targetEl[0].offsetHeight;
      target.offset = $targetEl.offset();
      fab.offset = $fabEl.offset();

      const diffXNew = (fab.offset.left + (fab.width / 2)) -
                      (target.offset.left + (target.width / 2)) -
                      fab.translateX;
      const diffYNew = (fab.offset.top + (fab.height / 2)) -
                      (target.offset.top + (target.height / 2)) -
                      fab.translateY;
      const scaleXNew = target.width / fab.width;
      const scaleYNew = target.height / fab.height;

      $fabEl.transform(`translate3d(${-diffXNew}px, ${-diffYNew}px, 0) scale(${scaleXNew}, ${scaleYNew})`);
    };

    $targetEl
      .css('opacity', 0)
      .transform(`scale(${1 / scaleX}, ${1 / scaleY})`);
    $fabEl
      .addClass('fab-opened')
      .css('z-index', target.zIndex - 1)
      .transform(`translate3d(${-diffX}px, ${-diffY}px, 0)`);
    $fabEl.transitionEnd(() => {
      $targetEl.transition('');
      Utils.nextTick(() => {
        $targetEl.css('opacity', 1).transform('scale(1,1)');
      });
      $fabEl.transform(`translate3d(${-diffX}px, ${-diffY}px, 0) scale(${scaleX}, ${scaleY})`)
        .css('border-radius', `${borderRadius}px`)
        .css('box-shadow', 'none');
      app.on('resize', $fabEl[0].f7FabMorphResizeHandler);
      if ($targetEl.parents('.page-content').length > 0) {
        $targetEl.parents('.page-content').on('scroll', $fabEl[0].f7FabMorphResizeHandler);
      }
    });
  },
  morphClose(fabEl) {
    const app = this;
    const $fabEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(fabEl);
    const morphData = $fabEl[0].f7FabMorphData;
    if (!morphData) return;
    const { $targetEl, target, fab } = morphData;
    if ($targetEl.length === 0) return;

    const diffX = (fab.offset.left + (fab.width / 2)) -
                  (target.offset.left + (target.width / 2)) -
                  fab.translateX;
    const diffY = (fab.offset.top + (fab.height / 2)) -
                  (target.offset.top + (target.height / 2)) -
                  fab.translateY;
    const scaleX = target.width / fab.width;
    const scaleY = target.height / fab.height;

    app.off('resize', $fabEl[0].f7FabMorphResizeHandler);
    if ($targetEl.parents('.page-content').length > 0) {
      $targetEl.parents('.page-content').off('scroll', $fabEl[0].f7FabMorphResizeHandler);
    }

    $targetEl
      .css('opacity', 0)
      .transform(`scale(${1 / scaleX}, ${1 / scaleY})`);
    $fabEl
      .transition('')
      .css('box-shadow', '')
      .css('border-radius', '')
      .transform(`translate3d(${-diffX}px, ${-diffY}px, 0)`);
    $fabEl.transitionEnd(() => {
      $fabEl
        .css('z-index', '')
        .removeClass('fab-opened')
        .transform('');
      Utils.nextTick(() => {
        $fabEl.transitionEnd(() => {
          $targetEl
            .removeClass('fab-morph-target-visible')
            .css('opacity', '')
            .transform('')
            .transition('');
        });
      });
    });
  },
  open(fabEl, targetEl) {
    const app = this;
    const $fabEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(fabEl).eq(0);
    const $buttonsEl = $fabEl.find('.fab-buttons');
    if (!$fabEl.length) return;
    if ($fabEl.hasClass('fab-opened')) return;
    if (!$buttonsEl.length && !$fabEl.hasClass('fab-morph')) return;

    if (app.fab.openedEl) {
      if (app.fab.openedEl === $fabEl[0]) return;
      app.fab.close(app.fab.openedEl);
    }
    app.fab.openedEl = $fabEl[0];
    if ($fabEl.hasClass('fab-morph')) {
      app.fab.morphOpen($fabEl, targetEl || $fabEl.attr('data-morph-to'));
    } else {
      $fabEl.addClass('fab-opened');
    }
    $fabEl.trigger('fab:open');
  },
  close(fabEl = '.fab-opened') {
    const app = this;
    const $fabEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(fabEl).eq(0);
    const $buttonsEl = $fabEl.find('.fab-buttons');
    if (!$fabEl.length) return;
    if (!$fabEl.hasClass('fab-opened')) return;
    if (!$buttonsEl.length && !$fabEl.hasClass('fab-morph')) return;
    app.fab.openedEl = null;
    if ($fabEl.hasClass('fab-morph')) {
      app.fab.morphClose($fabEl);
    } else {
      $fabEl.removeClass('fab-opened');
    }
    $fabEl.trigger('fab:close');
  },
  toggle(fabEl) {
    const app = this;
    const $fabEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(fabEl);
    if (!$fabEl.hasClass('fab-opened')) app.fab.open(fabEl);
    else app.fab.close(fabEl);
  },
};

var Fab$1 = {
  name: 'fab',
  create() {
    const app = this;
    Utils.extend(app, {
      fab: {
        openedEl: null,
        morphOpen: Fab.morphOpen.bind(app),
        morphClose: Fab.morphClose.bind(app),
        open: Fab.open.bind(app),
        close: Fab.close.bind(app),
        toggle: Fab.toggle.bind(app),
      },
    });
  },
  clicks: {
    '.fab > a': function open($clickedEl) {
      const app = this;
      app.fab.toggle($clickedEl.parents('.fab'));
    },
    '.fab-open': function open($clickedEl, data = {}) {
      const app = this;
      app.fab.open(data.fab);
    },
    '.fab-close': function close($clickedEl, data = {}) {
      const app = this;
      app.fab.close(data.fab);
    },
  },
};

class Searchbar extends Framework7Class {
  constructor(app, params = {}) {
    super(params, [app]);

    const sb = this;

    const defaults = {
      el: undefined,
      inputEl: undefined,
      disableButton: true,
      disableButtonEl: undefined,
      backdropEl: undefined,
      searchContainer: undefined, // container to search, HTMLElement or CSS selector
      searchItem: 'li', // single item selector, CSS selector
      searchIn: undefined, // where to search in item, CSS selector
      ignore: '.searchbar-ignore',
      foundEl: '.searchbar-found',
      notFoundEl: '.searchbar-not-found',
      hideOnEnableEl: '.searchbar-hide-on-enable',
      hideOnSearchEl: '.searchbar-hide-on-search',
      backdrop: true,
      removeDiacritics: true,
      customSearch: false,
      hideDividers: true,
      hideGroups: true,
      disableOnBackdropClick: true,
      expandable: false,
    };

    // Extend defaults with modules params
    sb.useModulesParams(defaults);

    sb.params = Utils.extend(defaults, params);

    const $el = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(sb.params.el);
    if ($el.length === 0) return sb;

    $el[0].f7Searchbar = sb;

    let $pageEl;
    let $navbarEl;
    if ($el.parents('.page').length > 0) {
      $pageEl = $el.parents('.page');
    } else {
      $navbarEl = $el.parents('.navbar-inner');
      if ($navbarEl.length > 0) {
        if ($navbarEl[0].f7Page) {
          $pageEl = $navbarEl[0].f7Page.$el;
        } else {
          const $currentPageEl = $el.parents('.view').find('.page-current');
          if ($currentPageEl[0] && $currentPageEl[0].f7Page && $currentPageEl[0].f7Page.navbarEl === $navbarEl[0]) {
            $pageEl = $currentPageEl;
          }
        }
      }
    }

    let $foundEl;
    if (params.foundEl) {
      $foundEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(params.foundEl);
    } else if (typeof sb.params.foundEl === 'string' && $pageEl) {
      $foundEl = $pageEl.find(sb.params.foundEl);
    }

    let $notFoundEl;
    if (params.notFoundEl) {
      $notFoundEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(params.notFoundEl);
    } else if (typeof sb.params.notFoundEl === 'string' && $pageEl) {
      $notFoundEl = $pageEl.find(sb.params.notFoundEl);
    }

    let $hideOnEnableEl;
    if (params.hideOnEnableEl) {
      $hideOnEnableEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(params.hideOnEnableEl);
    } else if (typeof sb.params.hideOnEnableEl === 'string' && $pageEl) {
      $hideOnEnableEl = $pageEl.find(sb.params.hideOnEnableEl);
    }

    let $hideOnSearchEl;
    if (params.hideOnSearchEl) {
      $hideOnSearchEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(params.hideOnSearchEl);
    } else if (typeof sb.params.hideOnSearchEl === 'string' && $pageEl) {
      $hideOnSearchEl = $pageEl.find(sb.params.hideOnSearchEl);
    }

    let $backdropEl;
    if (sb.params.backdrop) {
      if (sb.params.backdropEl) {
        $backdropEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(sb.params.backdropEl);
      } else if ($pageEl && $pageEl.length > 0) {
        $backdropEl = $pageEl.find('.searchbar-backdrop');
      } else {
        $backdropEl = $el.siblings('.searchbar-backdrop');
      }
      if ($backdropEl.length === 0) {
        $backdropEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])('<div class="searchbar-backdrop"></div>');
        if ($pageEl && $pageEl.length) {
          if ($el.parents($pageEl).length > 0 && $navbarEl && $el.parents($navbarEl).length === 0) {
            $backdropEl.insertBefore($el);
          } else {
            $backdropEl.insertBefore($pageEl.find('.page-content').eq(0));
          }
        } else {
          $backdropEl.insertBefore($el);
        }
      }
    }

    let $searchContainer;
    if (sb.params.searchContainer) {
      $searchContainer = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(sb.params.searchContainer);
    }

    let $inputEl;
    if (sb.params.inputEl) {
      $inputEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(sb.params.inputEl);
    } else {
      $inputEl = $el.find('input[type="search"]').eq(0);
    }

    let $disableButtonEl;
    if (sb.params.disableButton) {
      if (sb.params.disableButtonEl) {
        $disableButtonEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(sb.params.disableButtonEl);
      } else {
        $disableButtonEl = $el.find('.searchbar-disable-button');
      }
    }

    Utils.extend(sb, {
      app,
      view: app.views.get($el.parents('.view')),
      $el,
      el: $el[0],
      $backdropEl,
      backdropEl: $backdropEl && $backdropEl[0],
      $searchContainer,
      searchContainer: $searchContainer && $searchContainer[0],
      $inputEl,
      inputEl: $inputEl[0],
      $disableButtonEl,
      disableButtonEl: $disableButtonEl && $disableButtonEl[0],
      disableButtonHasMargin: false,
      $pageEl,
      pageEl: $pageEl && $pageEl[0],
      $navbarEl,
      navbarEl: $navbarEl && $navbarEl[0],
      $foundEl,
      foundEl: $foundEl && $foundEl[0],
      $notFoundEl,
      notFoundEl: $notFoundEl && $notFoundEl[0],
      $hideOnEnableEl,
      hideOnEnableEl: $hideOnEnableEl && $hideOnEnableEl[0],
      $hideOnSearchEl,
      hideOnSearchEl: $hideOnSearchEl && $hideOnSearchEl[0],
      previousQuery: '',
      query: '',
      isVirtualList: $searchContainer && $searchContainer.hasClass('virtual-list'),
      virtualList: undefined,
      enabled: false,
      expandable: sb.params.expandable || $el.hasClass('searchbar-expandable'),
    });

    // Events
    function preventSubmit(e) {
      e.preventDefault();
    }
    function onInputFocus(e) {
      sb.enable(e);
      sb.$el.addClass('searchbar-focused');
    }
    function onInputBlur() {
      sb.$el.removeClass('searchbar-focused');
    }
    function onInputChange() {
      const value = sb.$inputEl.val().trim();
      if (
        (
          (sb.$searchContainer && sb.$searchContainer.length > 0) &&
          (sb.params.searchIn || sb.isVirtualList || sb.params.searchIn === sb.params.searchItem)
        ) ||
        sb.params.customSearch
      ) {
        sb.search(value, true);
      }
    }
    function onInputClear(e, previousValue) {
      sb.$el.trigger('searchbar:clear', previousValue);
      sb.emit('local::clear searchbarClear', sb, previousValue);
    }
    function disableOnClick(e) {
      sb.disable(e);
    }
    function onPageBeforeOut() {
      if (!sb || (sb && !sb.$el)) return;
      if (sb.enabled) {
        sb.$el.removeClass('searchbar-enabled');
      }
    }
    function onPageBeforeIn() {
      if (!sb || (sb && !sb.$el)) return;
      if (sb.enabled) {
        sb.$el.addClass('searchbar-enabled');
      }
    }
    sb.attachEvents = function attachEvents() {
      $el.on('submit', preventSubmit);
      if (sb.params.disableButton) {
        sb.$disableButtonEl.on('click', disableOnClick);
      }
      if (sb.params.disableOnBackdropClick && sb.$backdropEl) {
        sb.$backdropEl.on('click', disableOnClick);
      }
      if (sb.expandable && app.theme === 'ios' && sb.view && $navbarEl && sb.$pageEl) {
        sb.$pageEl.on('page:beforeout', onPageBeforeOut);
        sb.$pageEl.on('page:beforein', onPageBeforeIn);
      }
      sb.$inputEl.on('focus', onInputFocus);
      sb.$inputEl.on('blur', onInputBlur);
      sb.$inputEl.on('change input compositionend', onInputChange);
      sb.$inputEl.on('input:clear', onInputClear);
    };
    sb.detachEvents = function detachEvents() {
      $el.off('submit', preventSubmit);
      if (sb.params.disableButton) {
        sb.$disableButtonEl.off('click', disableOnClick);
      }
      if (sb.params.disableOnBackdropClick && sb.$backdropEl) {
        sb.$backdropEl.off('click', disableOnClick);
      }
      if (sb.expandable && app.theme === 'ios' && sb.view && $navbarEl && sb.$pageEl) {
        sb.$pageEl.on('page:beforeout', onPageBeforeOut);
        sb.$pageEl.on('page:beforein', onPageBeforeIn);
      }
      sb.$inputEl.off('focus', onInputFocus);
      sb.$inputEl.off('blur', onInputBlur);
      sb.$inputEl.off('change input compositionend', onInputChange);
      sb.$inputEl.off('input:clear', onInputClear);
    };

    // Install Modules
    sb.useModules();

    // Init
    sb.init();

    return sb;
  }
  clear(e) {
    const sb = this;
    if (!sb.query && e && Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(e.target).hasClass('searchbar-clear')) {
      sb.disable();
      return sb;
    }
    const previousQuery = sb.value;
    sb.$inputEl.val('').trigger('change').focus();
    sb.$el.trigger('searchbar:clear', previousQuery);
    sb.emit('local::clear searchbarClear', sb, previousQuery);
    return sb;
  }
  setDisableButtonMargin() {
    const sb = this;
    if (sb.expandable) return;
    const app = sb.app;
    sb.$disableButtonEl.transition(0).show();
    sb.$disableButtonEl.css(`margin-${app.rtl ? 'left' : 'right'}`, `${-sb.disableButtonEl.offsetWidth}px`);
    /* eslint no-underscore-dangle: ["error", { "allow": ["_clientLeft"] }] */
    sb._clientLeft = sb.$disableButtonEl[0].clientLeft;
    sb.$disableButtonEl.transition('');
    sb.disableButtonHasMargin = true;
  }
  enable(setFocus) {
    const sb = this;
    if (sb.enabled) return sb;
    const app = sb.app;
    sb.enabled = true;
    function enable() {
      if (sb.$backdropEl && ((sb.$searchContainer && sb.$searchContainer.length) || sb.params.customSearch) && !sb.$el.hasClass('searchbar-enabled') && !sb.query) {
        sb.backdropShow();
      }
      sb.$el.addClass('searchbar-enabled');
      if (!sb.expandable && sb.$disableButtonEl && sb.$disableButtonEl.length > 0 && app.theme === 'ios') {
        if (!sb.disableButtonHasMargin) {
          sb.setDisableButtonMargin();
        }
        sb.$disableButtonEl.css(`margin-${app.rtl ? 'left' : 'right'}`, '0px');
      }
      if (sb.$hideOnEnableEl) sb.$hideOnEnableEl.addClass('hidden-by-searchbar');
      sb.$el.trigger('searchbar:enable');
      sb.emit('local::enable searchbarEnable', sb);
    }
    let needsFocus = false;
    if (setFocus === true) {
      if (__WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */].activeElement !== sb.inputEl) {
        needsFocus = true;
      }
    }
    const isIos = app.device.ios && app.theme === 'ios';
    if (isIos) {
      if (sb.expandable) {
        if (needsFocus) sb.$inputEl.focus();
        enable();
      } else {
        if (needsFocus) sb.$inputEl.focus();
        if (setFocus && (setFocus.type === 'focus' || setFocus === true)) {
          Utils.nextTick(() => {
            enable();
          }, 400);
        } else {
          enable();
        }
      }
    } else {
      if (needsFocus) sb.$inputEl.focus();
      if (app.theme === 'md' && sb.expandable) {
        sb.$el.parents('.navbar-inner').scrollLeft(0);
      }
      enable();
    }
    return sb;
  }
  disable() {
    const sb = this;
    if (!sb.enabled) return sb;
    const app = sb.app;
    sb.$inputEl.val('').trigger('change');
    sb.$el.removeClass('searchbar-enabled');
    sb.$el.removeClass('searchbar-focused');
    if (!sb.expandable && sb.$disableButtonEl && sb.$disableButtonEl.length > 0 && app.theme === 'ios') {
      sb.$disableButtonEl.css(`margin-${app.rtl ? 'left' : 'right'}`, `${-sb.disableButtonEl.offsetWidth}px`);
    }

    if (sb.$backdropEl && ((sb.$searchContainer && sb.$searchContainer.length) || sb.params.customSearch)) {
      sb.backdropHide();
    }

    sb.enabled = false;

    sb.$inputEl.blur();

    if (sb.$hideOnEnableEl) sb.$hideOnEnableEl.removeClass('hidden-by-searchbar');

    sb.$el.trigger('searchbar:disable');
    sb.emit('local::disable searchbarDisable', sb);
    return sb;
  }
  toggle() {
    const sb = this;
    if (sb.enabled) sb.disable();
    else sb.enable(true);
    return sb;
  }
  backdropShow() {
    const sb = this;
    if (sb.$backdropEl) {
      sb.$backdropEl.addClass('searchbar-backdrop-in');
    }
    return sb;
  }
  backdropHide() {
    const sb = this;
    if (sb.$backdropEl) {
      sb.$backdropEl.removeClass('searchbar-backdrop-in');
    }
    return sb;
  }
  search(query, internal) {
    const sb = this;
    if (sb.previousQuery && query.trim() === sb.previousQuery) return sb;
    if (typeof (sb.previousQuery) !== 'undefined' && sb.previousQuery.trim() === '' && query.trim() === '') return sb;
    sb.previousQuery = query.trim();

    if (!internal) {
      if (!sb.enabled) {
        sb.enable();
      }
      sb.$inputEl.val(query);
    }
    sb.query = query;
    sb.value = query;

    const { $searchContainer, $el, $backdropEl, $foundEl, $notFoundEl, $hideOnSearchEl, isVirtualList } = sb;

    // Hide on search element
    if (query.length > 0 && $hideOnSearchEl) {
      $hideOnSearchEl.addClass('hidden-by-searchbar');
    } else if ($hideOnSearchEl) {
      $hideOnSearchEl.removeClass('hidden-by-searchbar');
    }
    // Add active/inactive classes on overlay
    if (query.length === 0) {
      if ($searchContainer && $searchContainer.length && $el.hasClass('searchbar-enabled') && $backdropEl) sb.backdropShow();
    } else if ($searchContainer && $searchContainer.length && $el.hasClass('searchbar-enabled')) {
      sb.backdropHide();
    }

    if (sb.params.customSearch) {
      $el.trigger('searchbar:search', query, sb.previousQuery);
      sb.emit('local::search searchbarSearch', sb, query, sb.previousQuery);
      return sb;
    }

    let foundItems = [];
    let vlQuery;
    if (isVirtualList) {
      sb.virtualList = $searchContainer[0].f7VirtualList;
      if (query.trim() === '') {
        sb.virtualList.resetFilter();
        if ($notFoundEl) $notFoundEl.hide();
        if ($foundEl) $foundEl.show();
        return sb;
      }
      vlQuery = sb.params.removeDiacritics ? Utils.removeDiacritics(query) : query;
      if (sb.virtualList.params.searchAll) {
        foundItems = sb.virtualList.params.searchAll(vlQuery, sb.virtualList.items) || [];
      } else if (sb.virtualList.params.searchByItem) {
        for (let i = 0; i < sb.virtualList.items.length; i += 1) {
          if (sb.virtualList.params.searchByItem(vlQuery, sb.virtualList.params.items[i], i)) {
            foundItems.push(i);
          }
        }
      }
    } else {
      let values;
      if (sb.params.removeDiacritics) values = Utils.removeDiacritics(query.trim().toLowerCase()).split(' ');
      else {
        values = query.trim().toLowerCase().split(' ');
      }
      $searchContainer.find(sb.params.searchItem).removeClass('hidden-by-searchbar').each((itemIndex, itemEl) => {
        const $itemEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(itemEl);
        let compareWithText = [];
        let $searchIn = sb.params.searchIn ? $itemEl.find(sb.params.searchIn) : $itemEl;
        if (sb.params.searchIn === sb.params.searchItem) {
          $searchIn = $itemEl;
        }
        $searchIn.each((searchInIndex, searchInEl) => {
          let itemText = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(searchInEl).text().trim().toLowerCase();
          if (sb.params.removeDiacritics) itemText = Utils.removeDiacritics(itemText);
          compareWithText.push(itemText);
        });
        compareWithText = compareWithText.join(' ');
        let wordsMatch = 0;
        for (let i = 0; i < values.length; i += 1) {
          if (compareWithText.indexOf(values[i]) >= 0) wordsMatch += 1;
        }
        if (wordsMatch !== values.length && !(sb.params.ignore && $itemEl.is(sb.params.ignore))) {
          $itemEl.addClass('hidden-by-searchbar');
        } else {
          foundItems.push($itemEl[0]);
        }
      });

      if (sb.params.hideDividers) {
        $searchContainer.find('.item-divider, .list-group-title').each((titleIndex, titleEl) => {
          const $titleEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(titleEl);
          const $nextElements = $titleEl.nextAll('li');
          let hide = true;
          for (let i = 0; i < $nextElements.length; i += 1) {
            const $nextEl = $nextElements.eq(i);
            if ($nextEl.hasClass('list-group-title') || $nextEl.hasClass('item-divider')) break;
            if (!$nextEl.hasClass('hidden-by-searchbar')) {
              hide = false;
            }
          }
          const ignore = sb.params.ignore && $titleEl.is(sb.params.ignore);
          if (hide && !ignore) $titleEl.addClass('hidden-by-searchbar');
          else $titleEl.removeClass('hidden-by-searchbar');
        });
      }
      if (sb.params.hideGroups) {
        $searchContainer.find('.list-group').each((groupIndex, groupEl) => {
          const $groupEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(groupEl);
          const ignore = sb.params.ignore && $groupEl.is(sb.params.ignore);
          const notHidden = $groupEl.find('li:not(.hidden-by-searchbar)');
          if (notHidden.length === 0 && !ignore) {
            $groupEl.addClass('hidden-by-searchbar');
          } else {
            $groupEl.removeClass('hidden-by-searchbar');
          }
        });
      }
    }

    if (foundItems.length === 0) {
      if ($notFoundEl) $notFoundEl.show();
      if ($foundEl) $foundEl.hide();
    } else {
      if ($notFoundEl) $notFoundEl.hide();
      if ($foundEl) $foundEl.show();
    }
    if (isVirtualList && sb.virtualList) {
      sb.virtualList.filterItems(foundItems);
    }

    $el.trigger('searchbar:search', query, sb.previousQuery, foundItems);
    sb.emit('local::search searchbarSearch', sb, query, sb.previousQuery, foundItems);

    return sb;
  }
  init() {
    const sb = this;
    sb.attachEvents();
  }
  destroy() {
    const sb = this;
    sb.emit('local::beforeDestroy searchbarBeforeDestroy', sb);
    sb.$el.trigger('searchbar:beforedestroy', sb);
    sb.detachEvents();
    delete sb.$el.f7Searchbar;
    Utils.deleteProps(sb);
  }
}

var Searchbar$1 = {
  name: 'searchbar',
  static: {
    Searchbar,
  },
  create() {
    const app = this;
    app.searchbar = ConstructorMethods({
      defaultSelector: '.searchbar',
      constructor: Searchbar,
      app,
      domProp: 'f7Searchbar',
      addMethods: 'clear enable disable toggle search'.split(' '),
    });
  },
  on: {
    tabMounted(tabEl) {
      const app = this;
      Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(tabEl).find('.searchbar-init').each((index, searchbarEl) => {
        const $searchbarEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(searchbarEl);
        app.searchbar.create(Utils.extend($searchbarEl.dataset(), { el: searchbarEl }));
      });
    },
    tabBeforeRemove(tabEl) {
      Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(tabEl).find('.searchbar-init').each((index, searchbarEl) => {
        if (searchbarEl.f7Searchbar && searchbarEl.f7Searchbar.destroy) {
          searchbarEl.f7Searchbar.destroy();
        }
      });
    },
    pageInit(page) {
      const app = this;
      page.$el.find('.searchbar-init').each((index, searchbarEl) => {
        const $searchbarEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(searchbarEl);
        app.searchbar.create(Utils.extend($searchbarEl.dataset(), { el: searchbarEl }));
      });
      if (app.theme === 'ios' && page.view && page.view.router.separateNavbar && page.$navbarEl && page.$navbarEl.length > 0) {
        page.$navbarEl.find('.searchbar-init').each((index, searchbarEl) => {
          const $searchbarEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(searchbarEl);
          app.searchbar.create(Utils.extend($searchbarEl.dataset(), { el: searchbarEl }));
        });
      }
    },
    pageBeforeRemove(page) {
      const app = this;
      page.$el.find('.searchbar-init').each((index, searchbarEl) => {
        if (searchbarEl.f7Searchbar && searchbarEl.f7Searchbar.destroy) {
          searchbarEl.f7Searchbar.destroy();
        }
      });
      if (app.theme === 'ios' && page.view && page.view.router.separateNavbar && page.$navbarEl && page.$navbarEl.length > 0) {
        page.$navbarEl.find('.searchbar-init').each((index, searchbarEl) => {
          if (searchbarEl.f7Searchbar && searchbarEl.f7Searchbar.destroy) {
            searchbarEl.f7Searchbar.destroy();
          }
        });
      }
    },
  },
  clicks: {
    '.searchbar-clear': function clear($clickedEl, data = {}) {
      const app = this;
      const sb = app.searchbar.get(data.searchbar);
      if (sb) sb.clear();
    },
    '.searchbar-enable': function enable($clickedEl, data = {}) {
      const app = this;
      const sb = app.searchbar.get(data.searchbar);
      if (sb) sb.enable(true);
    },
    '.searchbar-disable': function disable($clickedEl, data = {}) {
      const app = this;
      const sb = app.searchbar.get(data.searchbar);
      if (sb) sb.disable();
    },
    '.searchbar-toggle': function toggle($clickedEl, data = {}) {
      const app = this;
      const sb = app.searchbar.get(data.searchbar);
      if (sb) sb.toggle();
    },
  },
};

class Messages extends Framework7Class {
  constructor(app, params = {}) {
    super(params, [app]);

    const m = this;

    const defaults = {
      autoLayout: true,
      messages: [],
      newMessagesFirst: false,
      scrollMessages: true,
      scrollMessagesOnEdge: true,
      firstMessageRule: undefined,
      lastMessageRule: undefined,
      tailMessageRule: undefined,
      sameNameMessageRule: undefined,
      sameHeaderMessageRule: undefined,
      sameFooterMessageRule: undefined,
      sameAvatarMessageRule: undefined,
      customClassMessageRule: undefined,
      renderMessage: undefined,
    };

    // Extend defaults with modules params
    m.useModulesParams(defaults);

    m.params = Utils.extend(defaults, params);

    const $el = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(params.el).eq(0);
    if ($el.length === 0) return m;

    $el[0].f7Messages = m;

    const $pageContentEl = $el.closest('.page-content').eq(0);

    Utils.extend(m, {
      messages: m.params.messages,
      $el,
      el: $el[0],
      $pageContentEl,
      pageContentEl: $pageContentEl[0],

    });
    // Install Modules
    m.useModules();

    // Init
    m.init();

    return m;
  }
  // eslint-disable-next-line
  getMessageData(messageEl) {
    const $messageEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(messageEl);
    const data = {
      name: $messageEl.find('.message-name').html(),
      header: $messageEl.find('.message-header').html(),
      textHeader: $messageEl.find('.message-text-header').html(),
      textFooter: $messageEl.find('.message-text-footer').html(),
      footer: $messageEl.find('.message-footer').html(),
      isTitle: $messageEl.hasClass('messages-title'),
      type: $messageEl.hasClass('message-sent') ? 'sent' : 'received',
      text: $messageEl.find('.message-text').html(),
      image: $messageEl.find('.message-image').html(),
      imageSrc: $messageEl.find('.message-image img').attr('src'),
      typing: $messageEl.hasClass('message-typing'),
    };
    if (data.isTitle) {
      data.text = $messageEl.html();
    }
    if (data.text && data.textHeader) {
      data.text = data.text.replace(`<div class="message-text-header">${data.textHeader}</div>`, '');
    }
    if (data.text && data.textFooter) {
      data.text = data.text.replace(`<div class="message-text-footer">${data.textFooter}</div>`, '');
    }
    let avatar = $messageEl.find('.message-avatar').css('background-image');
    if (avatar === 'none' || avatar === '') avatar = undefined;
    if (avatar && typeof avatar === 'string') {
      avatar = avatar.replace('url(', '').replace(')', '').replace(/"/g, '').replace(/'/g, '');
    } else {
      avatar = undefined;
    }
    data.avatar = avatar;

    return data;
  }
  getMessagesData() {
    const m = this;
    const data = [];
    m.$el.find('.message, .messages-title').each((index, messageEl) => {
      data.push(m.getMessageData(messageEl));
    });
    return data;
  }
  renderMessage(messageToRender) {
    const m = this;
    const message = Utils.extend({
      type: 'sent',
    }, messageToRender);
    if (m.params.renderMessage) {
      return m.params.renderMessage.call(m, message);
    }
    if (message.isTitle) {
      return `<div class="messages-title">${message.text}</div>`;
    }
    return `
      <div class="message message-${message.type} ${message.isTyping ? 'message-typing' : ''}">
        ${message.avatar ? `
        <div class="message-avatar" style="background-image:url(${message.avatar})"></div>
        ` : ''}
        <div class="message-content">
          ${message.name ? `<div class="message-name">${message.name}</div>` : ''}
          ${message.header ? `<div class="message-header">${message.header}</div>` : ''}
          <div class="message-bubble">
            ${message.textHeader ? `<div class="message-text-header">${message.textHeader}</div>` : ''}
            ${message.image ? `<div class="message-image">${message.image}</div>` : ''}
            ${message.imageSrc && !message.image ? `<div class="message-image"><img src="${message.imageSrc}"></div>` : ''}
            ${message.text || message.isTyping ? `<div class="message-text">${message.text || ''}${message.isTyping ? '<div class="message-typing-indicator"><div></div><div></div><div></div></div>' : ''}</div>` : ''}
            ${message.textFooter ? `<div class="message-text-footer">${message.textFooter}</div>` : ''}
          </div>
          ${message.footer ? `<div class="message-footer">${message.footer}</div>` : ''}
        </div>
      </div>
    `;
  }
  renderMessages(messagesToRender = this.messages, method = this.params.newMessagesFirst ? 'prepend' : 'append') {
    const m = this;
    const html = messagesToRender.map(message => m.renderMessage(message)).join('');
    m.$el[method](html);
  }
  isFirstMessage(...args) {
    const m = this;
    if (m.params.firstMessageRule) return m.params.firstMessageRule(...args);
    return false;
  }
  isLastMessage(...args) {
    const m = this;
    if (m.params.lastMessageRule) return m.params.lastMessageRule(...args);
    return false;
  }
  isTailMessage(...args) {
    const m = this;
    if (m.params.tailMessageRule) return m.params.tailMessageRule(...args);
    return false;
  }
  isSameNameMessage(...args) {
    const m = this;
    if (m.params.sameNameMessageRule) return m.params.sameNameMessageRule(...args);
    return false;
  }
  isSameHeaderMessage(...args) {
    const m = this;
    if (m.params.sameHeaderMessageRule) return m.params.sameHeaderMessageRule(...args);
    return false;
  }
  isSameFooterMessage(...args) {
    const m = this;
    if (m.params.sameFooterMessageRule) return m.params.sameFooterMessageRule(...args);
    return false;
  }
  isSameAvatarMessage(...args) {
    const m = this;
    if (m.params.sameAvatarMessageRule) return m.params.sameAvatarMessageRule(...args);
    return false;
  }
  isCustomClassMessage(...args) {
    const m = this;
    if (m.params.customClassMessageRule) return m.params.customClassMessageRule(...args);
    return undefined;
  }
  layout() {
    const m = this;
    m.$el.find('.message, .messages-title').each((index, messageEl) => {
      const $messageEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(messageEl);
      if (!m.messages) {
        m.messages = m.getMessagesData();
      }
      const classes = [];
      const message = m.messages[index];
      const previousMessage = m.messages[index - 1];
      const nextMessage = m.messages[index + 1];
      if (m.isFirstMessage(message, previousMessage, nextMessage)) {
        classes.push('message-first');
      }
      if (m.isLastMessage(message, previousMessage, nextMessage)) {
        classes.push('message-last');
      }
      if (m.isTailMessage(message, previousMessage, nextMessage)) {
        classes.push('message-tail');
      }
      if (m.isSameNameMessage(message, previousMessage, nextMessage)) {
        classes.push('message-same-name');
      }
      if (m.isSameHeaderMessage(message, previousMessage, nextMessage)) {
        classes.push('message-same-header');
      }
      if (m.isSameFooterMessage(message, previousMessage, nextMessage)) {
        classes.push('message-same-footer');
      }
      if (m.isSameAvatarMessage(message, previousMessage, nextMessage)) {
        classes.push('message-same-avatar');
      }
      let customMessageClasses = m.isCustomClassMessage(message, previousMessage, nextMessage);
      if (customMessageClasses && customMessageClasses.length) {
        if (typeof customMessageClasses === 'string') {
          customMessageClasses = customMessageClasses.split(' ');
        }
        customMessageClasses.forEach((customClass) => {
          classes.push(customClass);
        });
      }
      $messageEl.removeClass('message-first message-last message-tail message-same-name message-same-header message-same-footer message-same-avatar');
      classes.forEach((className) => {
        $messageEl.addClass(className);
      });
    });
  }
  clear() {
    const m = this;
    m.messages = [];
    m.$el.html('');
  }
  removeMessage(messageToRemove, layout = true) {
    const m = this;
    // Index or El
    let index;
    let $el;
    if (typeof messageToRemove === 'number') {
      index = messageToRemove;
      $el = m.$el.find('.message, .messages-title').eq(index);
    } else if (m.messages && m.messages.indexOf(messageToRemove) >= 0) {
      index = m.messages.indexOf(messageToRemove);
      $el = m.$el.children().eq(index);
    } else {
      $el = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(messageToRemove);
      index = $el.index();
    }
    if ($el.length === 0) {
      return m;
    }
    $el.remove();
    m.messages.splice(index, 1);
    if (m.params.autoLayout && layout) m.layout();
    return m;
  }
  removeMessages(messagesToRemove, layout = true) {
    const m = this;
    if (Array.isArray(messagesToRemove)) {
      const messagesToRemoveEls = [];
      messagesToRemove.forEach((messageToRemoveIndex) => {
        messagesToRemoveEls.push(m.$el.find('.message, .messages-title').eq(messageToRemoveIndex));
      });
      messagesToRemoveEls.forEach((messageToRemove) => {
        m.removeMessage(messageToRemove, false);
      });
    } else {
      Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(messagesToRemove).each((index, messageToRemove) => {
        m.removeMessage(messageToRemove, false);
      });
    }
    if (m.params.autoLayout && layout) m.layout();
    return m;
  }

  addMessage(...args) {
    const m = this;
    let messageToAdd;
    let animate;
    let method;
    if (typeof args[1] === 'boolean') {
      [messageToAdd, animate, method] = args;
    } else {
      [messageToAdd, method, animate] = args;
    }
    if (typeof animate === 'undefined') {
      animate = true;
    }
    if (typeof method === 'undefined') {
      method = m.params.newMessagesFirst ? 'prepend' : 'append';
    }

    return m.addMessages([messageToAdd], animate, method);
  }
  addMessages(...args) {
    const m = this;
    let messagesToAdd;
    let animate;
    let method;
    if (typeof args[1] === 'boolean') {
      [messagesToAdd, animate, method] = args;
    } else {
      [messagesToAdd, method, animate] = args;
    }
    if (typeof animate === 'undefined') {
      animate = true;
    }
    if (typeof method === 'undefined') {
      method = m.params.newMessagesFirst ? 'prepend' : 'append';
    }

    // Define scroll positions before new messages added
    const scrollHeightBefore = m.pageContentEl.scrollHeight;
    const heightBefore = m.pageContentEl.offsetHeight;
    const scrollBefore = m.pageContentEl.scrollTop;

    // Add message to DOM and data
    let messagesHTML = '';
    const typingMessage = m.messages.filter(el => el.isTyping)[0];
    messagesToAdd.forEach((messageToAdd) => {
      if (typingMessage) {
        if (method === 'append') {
          m.messages.splice(m.messages.indexOf(typingMessage), 0, messageToAdd);
        } else {
          m.messages.splice(m.messages.indexOf(typingMessage) + 1, 0, messageToAdd);
        }
      } else {
        m.messages[method === 'append' ? 'push' : 'unshift'](messageToAdd);
      }
      messagesHTML += m.renderMessage(messageToAdd);
    });
    const $messagesEls = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(messagesHTML);
    if (animate) {
      if (method === 'append' && !m.params.newMessagesFirst) {
        $messagesEls.addClass('message-appear-from-bottom');
      }
      if (method === 'prepend' && m.params.newMessagesFirst) {
        $messagesEls.addClass('message-appear-from-top');
      }
    }
    if (typingMessage) {
      if (method === 'append') {
        $messagesEls.insertBefore(m.$el.find('.message-typing'));
      } else {
        $messagesEls.insertAfter(m.$el.find('.message-typing'));
      }
    } else {
      m.$el[method]($messagesEls);
    }

    // Layout
    if (m.params.autoLayout) m.layout();

    if (method === 'prepend' && !typingMessage) {
      m.pageContentEl.scrollTop = scrollBefore + (m.pageContentEl.scrollHeight - scrollHeightBefore);
    }

    if (m.params.scrollMessages && ((method === 'append' && !m.params.newMessagesFirst) || (method === 'prepend' && m.params.newMessagesFirst && !typingMessage))) {
      if (m.params.scrollMessagesOnEdge) {
        let onEdge = false;
        if (m.params.newMessagesFirst && scrollBefore === 0) {
          onEdge = true;
        }
        if (!m.params.newMessagesFirst && (scrollBefore - (scrollHeightBefore - heightBefore) >= -10)) {
          onEdge = true;
        }
        if (onEdge) m.scroll(animate ? undefined : 0);
      } else {
        m.scroll(animate ? undefined : 0);
      }
    }

    return m;
  }
  showTyping(message = {}) {
    const m = this;
    const typingMessage = m.messages.filter(el => el.isTyping)[0];
    if (typingMessage) {
      m.removeMessage(m.messages.indexOf(typingMessage));
    }
    m.addMessage(Utils.extend({
      type: 'received',
      isTyping: true,
    }, message));
    return m;
  }
  hideTyping() {
    const m = this;
    let typingMessageIndex;
    let typingFound;
    m.messages.forEach((message, index) => {
      if (message.isTyping) typingMessageIndex = index;
    });
    if (typeof typingMessageIndex !== 'undefined') {
      if (m.$el.find('.message').eq(typingMessageIndex).hasClass('message-typing')) {
        typingFound = true;
        m.removeMessage(typingMessageIndex);
      }
    }
    if (!typingFound) {
      const $typingMessageEl = m.$el.find('.message-typing');
      if ($typingMessageEl.length) {
        m.removeMessage($typingMessageEl);
      }
    }
    return m;
  }
  scroll(duration = 300, scrollTop) {
    const m = this;
    const currentScroll = m.pageContentEl.scrollTop;
    let newScrollTop;
    if (typeof scrollTop !== 'undefined') newScrollTop = scrollTop;
    else {
      newScrollTop = m.params.newMessagesFirst ? 0 : m.pageContentEl.scrollHeight - m.pageContentEl.offsetHeight;
      if (newScrollTop === currentScroll) return m;
    }
    m.$pageContentEl.scrollTop(newScrollTop, duration);
    return m;
  }
  init() {
    const m = this;
    if (!m.messages || m.messages.length === 0) {
      m.messages = m.getMessagesData();
    }
    if (m.params.messages && m.params.messages.length) {
      m.renderMessages();
    }
    if (m.params.autoLayout) m.layout();
    if (m.params.scrollMessages) m.scroll(0);
  }
  destroy() {
    const m = this;
    m.emit('local::beforeDestroy messagesBeforeDestroy', m);
    m.$el.trigger('messages:beforedestroy', m);
    m.$el[0].f7Messages = null;
    delete m.$el[0].f7Messages;
    Utils.deleteProps(m);
  }
}

var Messages$1 = {
  name: 'messages',
  static: {
    Messages,
  },
  create() {
    const app = this;
    app.messages = ConstructorMethods({
      defaultSelector: '.messages',
      constructor: Messages,
      app,
      domProp: 'f7Messages',
      addMethods: 'renderMessages layout scroll clear removeMessage removeMessages addMessage addMessages'.split(' '),
    });
  },
  on: {
    tabBeforeRemove(tabEl) {
      const app = this;
      Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(tabEl).find('.messages-init').each((index, messagesEl) => {
        app.messages.destroy(messagesEl);
      });
    },
    tabMounted(tabEl) {
      const app = this;
      Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(tabEl).find('.messages-init').each((index, messagesEl) => {
        app.messages.create({ el: messagesEl });
      });
    },
    pageBeforeRemove(page) {
      const app = this;
      page.$el.find('.messages-init').each((index, messagesEl) => {
        app.messages.destroy(messagesEl);
      });
    },
    pageInit(page) {
      const app = this;
      page.$el.find('.messages-init').each((index, messagesEl) => {
        app.messages.create({ el: messagesEl });
      });
    },
  },
  clicks: {

  },
};

class Messagebar extends Framework7Class {
  constructor(app, params = {}) {
    super(params, [app]);

    const messagebar = this;

    const defaults = {
      top: false,
      topOffset: 0,
      bottomOffset: 0,
      attachments: [],
      renderAttachments: undefined,
      renderAttachment: undefined,
      maxHeight: null,
      resizePage: true,
    };

    // Extend defaults with modules params
    messagebar.useModulesParams(defaults);

    messagebar.params = Utils.extend(defaults, params);

    // El
    const $el = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(messagebar.params.el);
    if ($el.length === 0) return messagebar;

    $el[0].f7Messagebar = messagebar;

    // Page and PageContent
    const $pageEl = $el.parents('.page').eq(0);
    const $pageContentEl = $pageEl.find('.page-content').eq(0);

    // Area
    const $areaEl = $el.find('.messagebar-area');

    // Textarea
    let $textareaEl;
    if (messagebar.params.textareaEl) {
      $textareaEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(messagebar.params.textareaEl);
    } else {
      $textareaEl = $el.find('textarea');
    }

    // Attachments & Library
    const $attachmentsEl = $el.find('.messagebar-attachments');
    const $sheetEl = $el.find('.messagebar-sheet');

    if (messagebar.params.top) {
      $el.addClass('messagebar-top');
    }

    Utils.extend(messagebar, {
      $el,
      el: $el[0],
      $areaEl,
      areaEl: $areaEl[0],
      $textareaEl,
      textareaEl: $textareaEl[0],
      $attachmentsEl,
      attachmentsEl: $attachmentsEl[0],
      attachmentsVisible: $attachmentsEl.hasClass('messagebar-attachments-visible'),
      $sheetEl,
      sheetEl: $sheetEl[0],
      sheetVisible: $sheetEl.hasClass('messagebar-sheet-visible'),
      $pageEl,
      pageEl: $pageEl[0],
      $pageContentEl,
      pageContentEl: $pageContentEl,
      top: $el.hasClass('messagebar-top') || messagebar.params.top,
      attachments: [],
    });

    // Events
    function onAppResize() {
      if (messagebar.params.resizePage) {
        messagebar.resizePage();
      }
    }
    function onSubmit(e) {
      e.preventDefault();
    }
    function onAttachmentClick(e) {
      const index = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(this).index();
      if (Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(e.target).closest('.messagebar-attachment-delete').length) {
        Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(this).trigger('messagebar:attachmentdelete', index);
        messagebar.emit('local::attachmentDelete messagebarAttachmentDelete', messagebar, this, index);
      } else {
        Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(this).trigger('messagebar:attachmentclick', index);
        messagebar.emit('local::attachmentClick messagebarAttachmentClick', messagebar, this, index);
      }
    }
    function onTextareaChange() {
      messagebar.checkEmptyState();
      messagebar.$el.trigger('messagebar:change');
      messagebar.emit('local::change messagebarChange', messagebar);
    }
    function onTextareaFocus() {
      messagebar.sheetHide();
      messagebar.$el.addClass('messagebar-focused');
      messagebar.$el.trigger('messagebar:focus');
      messagebar.emit('local::focus messagebarFocus', messagebar);
    }
    function onTextareaBlur() {
      messagebar.$el.removeClass('messagebar-focused');
      messagebar.$el.trigger('messagebar:blur');
      messagebar.emit('local::blur messagebarBlur', messagebar);
    }

    messagebar.attachEvents = function attachEvents() {
      $el.on('textarea:resize', onAppResize);
      $el.on('submit', onSubmit);
      $el.on('click', '.messagebar-attachment', onAttachmentClick);
      $textareaEl.on('change input', onTextareaChange);
      $textareaEl.on('focus', onTextareaFocus);
      $textareaEl.on('blur', onTextareaBlur);
      app.on('resize', onAppResize);
    };
    messagebar.detachEvents = function detachEvents() {
      $el.off('textarea:resize', onAppResize);
      $el.off('submit', onSubmit);
      $el.off('click', '.messagebar-attachment', onAttachmentClick);
      $textareaEl.off('change input', onTextareaChange);
      $textareaEl.off('focus', onTextareaFocus);
      $textareaEl.off('blur', onTextareaBlur);
      app.off('resize', onAppResize);
    };


    // Install Modules
    messagebar.useModules();

    // Init
    messagebar.init();

    return messagebar;
  }
  focus() {
    const messagebar = this;
    messagebar.$textareaEl.focus();
    return messagebar;
  }
  blur() {
    const messagebar = this;
    messagebar.$textareaEl.blur();
    return messagebar;
  }
  clear() {
    const messagebar = this;
    messagebar.$textareaEl.val('').trigger('change');
    return messagebar;
  }
  getValue() {
    const messagebar = this;
    return messagebar.$textareaEl.val().trim();
  }
  setValue(value) {
    const messagebar = this;
    messagebar.$textareaEl.val(value).trigger('change');
    return messagebar;
  }
  setPlaceholder(placeholder) {
    const messagebar = this;
    messagebar.$textareaEl.attr('placeholder', placeholder);
    return messagebar;
  }
  resizePage() {
    const messagebar = this;
    const {
      params,
      $el,
      top,
      $pageEl,
      $pageContentEl,
      $areaEl,
      $textareaEl,
      $sheetEl,
      $attachmentsEl,
    } = messagebar;
    const elHeight = $el[0].offsetHeight;
    let maxHeight = params.maxHeight;
    if (top) ; else {
      const currentPaddingBottom = parseInt($pageContentEl.css('padding-bottom'), 10);
      const requiredPaddingBottom = elHeight + params.bottomOffset;
      if (requiredPaddingBottom !== currentPaddingBottom && $pageContentEl.length) {
        const currentPaddingTop = parseInt($pageContentEl.css('padding-top'), 10);
        const pageScrollHeight = $pageContentEl[0].scrollHeight;
        const pageOffsetHeight = $pageContentEl[0].offsetHeight;
        const pageScrollTop = $pageContentEl[0].scrollTop;
        const scrollOnBottom = (pageScrollTop === pageScrollHeight - pageOffsetHeight);
        if (!maxHeight) {
          maxHeight = $pageEl[0].offsetHeight - currentPaddingTop - $sheetEl.outerHeight() - $attachmentsEl.outerHeight() - parseInt($areaEl.css('margin-top'), 10) - parseInt($areaEl.css('margin-bottom'), 10);
        }
        $textareaEl.css('max-height', `${maxHeight}px`);
        $pageContentEl.css('padding-bottom', `${requiredPaddingBottom}px`);
        if (scrollOnBottom) {
          $pageContentEl.scrollTop($pageContentEl[0].scrollHeight - pageOffsetHeight);
        }
        $el.trigger('messagebar:resizepage');
        messagebar.emit('local::resizePage messagebarResizePage', messagebar);
      }
    }
  }
  checkEmptyState() {
    const messagebar = this;
    const { $el, $textareaEl } = messagebar;
    const value = $textareaEl.val().trim();
    if (value && value.length) {
      $el.addClass('messagebar-with-value');
    } else {
      $el.removeClass('messagebar-with-value');
    }
  }
  attachmentsCreate(innerHTML = '') {
    const messagebar = this;
    const $attachmentsEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(`<div class="messagebar-attachments">${innerHTML}</div>`);
    $attachmentsEl.insertBefore(messagebar.$textareaEl);
    Utils.extend(messagebar, {
      $attachmentsEl,
      attachmentsEl: $attachmentsEl[0],
    });
    return messagebar;
  }
  attachmentsShow(innerHTML = '') {
    const messagebar = this;
    messagebar.$attachmentsEl = messagebar.$el.find('.messagebar-attachments');
    if (messagebar.$attachmentsEl.length === 0) {
      messagebar.attachmentsCreate(innerHTML);
    }
    messagebar.$el.addClass('messagebar-attachments-visible');
    messagebar.attachmentsVisible = true;
    if (messagebar.params.resizePage) {
      messagebar.resizePage();
    }
    return messagebar;
  }
  attachmentsHide() {
    const messagebar = this;
    messagebar.$el.removeClass('messagebar-attachments-visible');
    messagebar.attachmentsVisible = false;
    if (messagebar.params.resizePage) {
      messagebar.resizePage();
    }
    return messagebar;
  }
  attachmentsToggle() {
    const messagebar = this;
    if (messagebar.attachmentsVisible) {
      messagebar.attachmentsHide();
    } else {
      messagebar.attachmentsShow();
    }
    return messagebar;
  }
  renderAttachment(attachment) {
    const messagebar = this;
    if (messagebar.params.renderAttachment) {
      return messagebar.params.renderAttachment.call(messagebar, attachment);
    }
    return `
      <div class="messagebar-attachment">
        <img src="${attachment}">
        <span class="messagebar-attachment-delete"></span>
      </div>
    `;
  }
  renderAttachments() {
    const messagebar = this;
    let html;
    if (messagebar.params.renderAttachments) {
      html = messagebar.params.renderAttachments.call(messagebar, messagebar.attachments);
    } else {
      html = `${messagebar.attachments.map(attachment => messagebar.renderAttachment(attachment)).join('')}`;
    }
    if (messagebar.$attachmentsEl.length === 0) {
      messagebar.attachmentsCreate(html);
    } else {
      messagebar.$attachmentsEl.html(html);
    }
  }
  sheetCreate(innerHTML = '') {
    const messagebar = this;
    const $sheetEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(`<div class="messagebar-sheet">${innerHTML}</div>`);
    messagebar.$el.append($sheetEl);
    Utils.extend(messagebar, {
      $sheetEl,
      sheetEl: $sheetEl[0],
    });
    return messagebar;
  }
  sheetShow(innerHTML = '') {
    const messagebar = this;
    messagebar.$sheetEl = messagebar.$el.find('.messagebar-sheet');
    if (messagebar.$sheetEl.length === 0) {
      messagebar.sheetCreate(innerHTML);
    }
    messagebar.$el.addClass('messagebar-sheet-visible');
    messagebar.sheetVisible = true;
    if (messagebar.params.resizePage) {
      messagebar.resizePage();
    }
    return messagebar;
  }
  sheetHide() {
    const messagebar = this;
    messagebar.$el.removeClass('messagebar-sheet-visible');
    messagebar.sheetVisible = false;
    if (messagebar.params.resizePage) {
      messagebar.resizePage();
    }
    return messagebar;
  }
  sheetToggle() {
    const messagebar = this;
    if (messagebar.sheetVisible) {
      messagebar.sheetHide();
    } else {
      messagebar.sheetShow();
    }
    return messagebar;
  }
  init() {
    const messagebar = this;
    messagebar.attachEvents();
    messagebar.checkEmptyState();
    return messagebar;
  }
  destroy() {
    const messagebar = this;
    messagebar.emit('local::beforeDestroy messagebarBeforeDestroy', messagebar);
    messagebar.$el.trigger('messagebar:beforedestroy', messagebar);
    messagebar.detachEvents();
    messagebar.$el[0].f7Messagebar = null;
    delete messagebar.$el[0].f7Messagebar;
    Utils.deleteProps(messagebar);
  }
}

var Messagebar$1 = {
  name: 'messagebar',
  static: {
    Messagebar,
  },
  create() {
    const app = this;
    app.messagebar = ConstructorMethods({
      defaultSelector: '.messagebar',
      constructor: Messagebar,
      app,
      domProp: 'f7Messagebar',
      addMethods: 'clear getValue setValue setPlaceholder resizePage focus blur attachmentsCreate attachmentsShow attachmentsHide attachmentsToggle renderAttachments sheetCreate sheetShow sheetHide sheetToggle'.split(' '),
    });
  },
  on: {
    tabBeforeRemove(tabEl) {
      const app = this;
      Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(tabEl).find('.messagebar-init').each((index, messagebarEl) => {
        app.messagebar.destroy(messagebarEl);
      });
    },
    tabMounted(tabEl) {
      const app = this;
      Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(tabEl).find('.messagebar-init').each((index, messagebarEl) => {
        app.messagebar.create(Utils.extend({ el: messagebarEl }, Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(messagebarEl).dataset()));
      });
    },
    pageBeforeRemove(page) {
      const app = this;
      page.$el.find('.messagebar-init').each((index, messagebarEl) => {
        app.messagebar.destroy(messagebarEl);
      });
    },
    pageInit(page) {
      const app = this;
      page.$el.find('.messagebar-init').each((index, messagebarEl) => {
        app.messagebar.create(Utils.extend({ el: messagebarEl }, Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(messagebarEl).dataset()));
      });
    },
  },
};

function updateSize () {
  const swiper = this;
  let width;
  let height;
  const $el = swiper.$el;
  if (typeof swiper.params.width !== 'undefined') {
    width = swiper.params.width;
  } else {
    width = $el[0].clientWidth;
  }
  if (typeof swiper.params.height !== 'undefined') {
    height = swiper.params.height;
  } else {
    height = $el[0].clientHeight;
  }
  if ((width === 0 && swiper.isHorizontal()) || (height === 0 && swiper.isVertical())) {
    return;
  }

  // Subtract paddings
  width = width - parseInt($el.css('padding-left'), 10) - parseInt($el.css('padding-right'), 10);
  height = height - parseInt($el.css('padding-top'), 10) - parseInt($el.css('padding-bottom'), 10);

  Utils.extend(swiper, {
    width,
    height,
    size: swiper.isHorizontal() ? width : height,
  });
}

function updateSlides () {
  const swiper = this;
  const params = swiper.params;

  const {
    $wrapperEl, size: swiperSize, rtlTranslate: rtl, wrongRTL,
  } = swiper;
  const slides = $wrapperEl.children(`.${swiper.params.slideClass}`);
  const isVirtual = swiper.virtual && params.virtual.enabled;
  const slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;
  let snapGrid = [];
  const slidesGrid = [];
  const slidesSizesGrid = [];

  let offsetBefore = params.slidesOffsetBefore;
  if (typeof offsetBefore === 'function') {
    offsetBefore = params.slidesOffsetBefore.call(swiper);
  }

  let offsetAfter = params.slidesOffsetAfter;
  if (typeof offsetAfter === 'function') {
    offsetAfter = params.slidesOffsetAfter.call(swiper);
  }

  const previousSlidesLength = slidesLength;
  const previousSnapGridLength = swiper.snapGrid.length;
  const previousSlidesGridLength = swiper.snapGrid.length;

  let spaceBetween = params.spaceBetween;
  let slidePosition = -offsetBefore;
  let prevSlideSize = 0;
  let index = 0;
  if (typeof swiperSize === 'undefined') {
    return;
  }
  if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {
    spaceBetween = (parseFloat(spaceBetween.replace('%', '')) / 100) * swiperSize;
  }

  swiper.virtualSize = -spaceBetween;

  // reset margins
  if (rtl) slides.css({ marginLeft: '', marginTop: '' });
  else slides.css({ marginRight: '', marginBottom: '' });

  let slidesNumberEvenToRows;
  if (params.slidesPerColumn > 1) {
    if (Math.floor(slidesLength / params.slidesPerColumn) === slidesLength / swiper.params.slidesPerColumn) {
      slidesNumberEvenToRows = slidesLength;
    } else {
      slidesNumberEvenToRows = Math.ceil(slidesLength / params.slidesPerColumn) * params.slidesPerColumn;
    }
    if (params.slidesPerView !== 'auto' && params.slidesPerColumnFill === 'row') {
      slidesNumberEvenToRows = Math.max(slidesNumberEvenToRows, params.slidesPerView * params.slidesPerColumn);
    }
  }

  // Calc slides
  let slideSize;
  const slidesPerColumn = params.slidesPerColumn;
  const slidesPerRow = slidesNumberEvenToRows / slidesPerColumn;
  const numFullColumns = slidesPerRow - ((params.slidesPerColumn * slidesPerRow) - slidesLength);
  for (let i = 0; i < slidesLength; i += 1) {
    slideSize = 0;
    const slide = slides.eq(i);
    if (params.slidesPerColumn > 1) {
      // Set slides order
      let newSlideOrderIndex;
      let column;
      let row;
      if (params.slidesPerColumnFill === 'column') {
        column = Math.floor(i / slidesPerColumn);
        row = i - (column * slidesPerColumn);
        if (column > numFullColumns || (column === numFullColumns && row === slidesPerColumn - 1)) {
          row += 1;
          if (row >= slidesPerColumn) {
            row = 0;
            column += 1;
          }
        }
        newSlideOrderIndex = column + ((row * slidesNumberEvenToRows) / slidesPerColumn);
        slide
          .css({
            '-webkit-box-ordinal-group': newSlideOrderIndex,
            '-moz-box-ordinal-group': newSlideOrderIndex,
            '-ms-flex-order': newSlideOrderIndex,
            '-webkit-order': newSlideOrderIndex,
            order: newSlideOrderIndex,
          });
      } else {
        row = Math.floor(i / slidesPerRow);
        column = i - (row * slidesPerRow);
      }
      slide
        .css(
          `margin-${swiper.isHorizontal() ? 'top' : 'left'}`,
          (row !== 0 && params.spaceBetween) && (`${params.spaceBetween}px`)
        )
        .attr('data-swiper-column', column)
        .attr('data-swiper-row', row);
    }
    if (slide.css('display') === 'none') continue; // eslint-disable-line

    if (params.slidesPerView === 'auto') {
      const slideStyles = __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].getComputedStyle(slide[0], null);
      const currentTransform = slide[0].style.transform;
      if (currentTransform) {
        slide[0].style.transform = 'none';
      }
      if (swiper.isHorizontal()) {
        slideSize = slide[0].getBoundingClientRect().width +
          parseFloat(slideStyles.getPropertyValue('margin-left')) +
          parseFloat(slideStyles.getPropertyValue('margin-right'));
      } else {
        slideSize = slide[0].getBoundingClientRect().height +
          parseFloat(slideStyles.getPropertyValue('margin-top')) +
          parseFloat(slideStyles.getPropertyValue('margin-bottom'));
      }
      if (currentTransform) {
        slide[0].style.transform = currentTransform;
      }
      if (params.roundLengths) slideSize = Math.floor(slideSize);
    } else {
      slideSize = (swiperSize - ((params.slidesPerView - 1) * spaceBetween)) / params.slidesPerView;
      if (params.roundLengths) slideSize = Math.floor(slideSize);

      if (slides[i]) {
        if (swiper.isHorizontal()) {
          slides[i].style.width = `${slideSize}px`;
        } else {
          slides[i].style.height = `${slideSize}px`;
        }
      }
    }
    if (slides[i]) {
      slides[i].swiperSlideSize = slideSize;
    }
    slidesSizesGrid.push(slideSize);


    if (params.centeredSlides) {
      slidePosition = slidePosition + (slideSize / 2) + (prevSlideSize / 2) + spaceBetween;
      if (prevSlideSize === 0 && i !== 0) slidePosition = slidePosition - (swiperSize / 2) - spaceBetween;
      if (i === 0) slidePosition = slidePosition - (swiperSize / 2) - spaceBetween;
      if (Math.abs(slidePosition) < 1 / 1000) slidePosition = 0;
      if ((index) % params.slidesPerGroup === 0) snapGrid.push(slidePosition);
      slidesGrid.push(slidePosition);
    } else {
      if ((index) % params.slidesPerGroup === 0) snapGrid.push(slidePosition);
      slidesGrid.push(slidePosition);
      slidePosition = slidePosition + slideSize + spaceBetween;
    }

    swiper.virtualSize += slideSize + spaceBetween;

    prevSlideSize = slideSize;

    index += 1;
  }
  swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;
  let newSlidesGrid;

  if (
    rtl && wrongRTL && (params.effect === 'slide' || params.effect === 'coverflow')) {
    $wrapperEl.css({ width: `${swiper.virtualSize + params.spaceBetween}px` });
  }
  if (!Support.flexbox || params.setWrapperSize) {
    if (swiper.isHorizontal()) $wrapperEl.css({ width: `${swiper.virtualSize + params.spaceBetween}px` });
    else $wrapperEl.css({ height: `${swiper.virtualSize + params.spaceBetween}px` });
  }

  if (params.slidesPerColumn > 1) {
    swiper.virtualSize = (slideSize + params.spaceBetween) * slidesNumberEvenToRows;
    swiper.virtualSize = Math.ceil(swiper.virtualSize / params.slidesPerColumn) - params.spaceBetween;
    if (swiper.isHorizontal()) $wrapperEl.css({ width: `${swiper.virtualSize + params.spaceBetween}px` });
    else $wrapperEl.css({ height: `${swiper.virtualSize + params.spaceBetween}px` });
    if (params.centeredSlides) {
      newSlidesGrid = [];
      for (let i = 0; i < snapGrid.length; i += 1) {
        if (snapGrid[i] < swiper.virtualSize + snapGrid[0]) newSlidesGrid.push(snapGrid[i]);
      }
      snapGrid = newSlidesGrid;
    }
  }

  // Remove last grid elements depending on width
  if (!params.centeredSlides) {
    newSlidesGrid = [];
    for (let i = 0; i < snapGrid.length; i += 1) {
      if (snapGrid[i] <= swiper.virtualSize - swiperSize) {
        newSlidesGrid.push(snapGrid[i]);
      }
    }
    snapGrid = newSlidesGrid;
    if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) {
      snapGrid.push(swiper.virtualSize - swiperSize);
    }
  }
  if (snapGrid.length === 0) snapGrid = [0];

  if (params.spaceBetween !== 0) {
    if (swiper.isHorizontal()) {
      if (rtl) slides.css({ marginLeft: `${spaceBetween}px` });
      else slides.css({ marginRight: `${spaceBetween}px` });
    } else slides.css({ marginBottom: `${spaceBetween}px` });
  }

  Utils.extend(swiper, {
    slides,
    snapGrid,
    slidesGrid,
    slidesSizesGrid,
  });

  if (slidesLength !== previousSlidesLength) {
    swiper.emit('slidesLengthChange');
  }
  if (snapGrid.length !== previousSnapGridLength) {
    if (swiper.params.watchOverflow) swiper.checkOverflow();
    swiper.emit('snapGridLengthChange');
  }
  if (slidesGrid.length !== previousSlidesGridLength) {
    swiper.emit('slidesGridLengthChange');
  }

  if (params.watchSlidesProgress || params.watchSlidesVisibility) {
    swiper.updateSlidesOffset();
  }
}

function updateAutoHeight (speed) {
  const swiper = this;
  const activeSlides = [];
  let newHeight = 0;
  let i;
  if (typeof speed === 'number') {
    swiper.setTransition(speed);
  } else if (speed === true) {
    swiper.setTransition(swiper.params.speed);
  }
  // Find slides currently in view
  if (swiper.params.slidesPerView !== 'auto' && swiper.params.slidesPerView > 1) {
    for (i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1) {
      const index = swiper.activeIndex + i;
      if (index > swiper.slides.length) break;
      activeSlides.push(swiper.slides.eq(index)[0]);
    }
  } else {
    activeSlides.push(swiper.slides.eq(swiper.activeIndex)[0]);
  }

  // Find new height from highest slide in view
  for (i = 0; i < activeSlides.length; i += 1) {
    if (typeof activeSlides[i] !== 'undefined') {
      const height = activeSlides[i].offsetHeight;
      newHeight = height > newHeight ? height : newHeight;
    }
  }

  // Update Height
  if (newHeight) swiper.$wrapperEl.css('height', `${newHeight}px`);
}

function updateSlidesOffset () {
  const swiper = this;
  const slides = swiper.slides;
  for (let i = 0; i < slides.length; i += 1) {
    slides[i].swiperSlideOffset = swiper.isHorizontal() ? slides[i].offsetLeft : slides[i].offsetTop;
  }
}

function updateSlidesProgress (translate = (this && this.translate) || 0) {
  const swiper = this;
  const params = swiper.params;

  const { slides, rtlTranslate: rtl } = swiper;

  if (slides.length === 0) return;
  if (typeof slides[0].swiperSlideOffset === 'undefined') swiper.updateSlidesOffset();

  let offsetCenter = -translate;
  if (rtl) offsetCenter = translate;

  // Visible Slides
  slides.removeClass(params.slideVisibleClass);

  for (let i = 0; i < slides.length; i += 1) {
    const slide = slides[i];
    const slideProgress =
      (
        (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0)) - slide.swiperSlideOffset
      ) / (slide.swiperSlideSize + params.spaceBetween);
    if (params.watchSlidesVisibility) {
      const slideBefore = -(offsetCenter - slide.swiperSlideOffset);
      const slideAfter = slideBefore + swiper.slidesSizesGrid[i];
      const isVisible =
                (slideBefore >= 0 && slideBefore < swiper.size) ||
                (slideAfter > 0 && slideAfter <= swiper.size) ||
                (slideBefore <= 0 && slideAfter >= swiper.size);
      if (isVisible) {
        slides.eq(i).addClass(params.slideVisibleClass);
      }
    }
    slide.progress = rtl ? -slideProgress : slideProgress;
  }
}

function updateProgress (translate = (this && this.translate) || 0) {
  const swiper = this;
  const params = swiper.params;

  const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
  let { progress, isBeginning, isEnd } = swiper;
  const wasBeginning = isBeginning;
  const wasEnd = isEnd;
  if (translatesDiff === 0) {
    progress = 0;
    isBeginning = true;
    isEnd = true;
  } else {
    progress = (translate - swiper.minTranslate()) / (translatesDiff);
    isBeginning = progress <= 0;
    isEnd = progress >= 1;
  }
  Utils.extend(swiper, {
    progress,
    isBeginning,
    isEnd,
  });

  if (params.watchSlidesProgress || params.watchSlidesVisibility) swiper.updateSlidesProgress(translate);

  if (isBeginning && !wasBeginning) {
    swiper.emit('reachBeginning toEdge');
  }
  if (isEnd && !wasEnd) {
    swiper.emit('reachEnd toEdge');
  }
  if ((wasBeginning && !isBeginning) || (wasEnd && !isEnd)) {
    swiper.emit('fromEdge');
  }

  swiper.emit('progress', progress);
}

function updateSlidesClasses () {
  const swiper = this;

  const {
    slides, params, $wrapperEl, activeIndex, realIndex,
  } = swiper;
  const isVirtual = swiper.virtual && params.virtual.enabled;

  slides.removeClass(`${params.slideActiveClass} ${params.slideNextClass} ${params.slidePrevClass} ${params.slideDuplicateActiveClass} ${params.slideDuplicateNextClass} ${params.slideDuplicatePrevClass}`);

  let activeSlide;
  if (isVirtual) {
    activeSlide = swiper.$wrapperEl.find(`.${params.slideClass}[data-swiper-slide-index="${activeIndex}"]`);
  } else {
    activeSlide = slides.eq(activeIndex);
  }

  // Active classes
  activeSlide.addClass(params.slideActiveClass);

  if (params.loop) {
    // Duplicate to all looped slides
    if (activeSlide.hasClass(params.slideDuplicateClass)) {
      $wrapperEl
        .children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index="${realIndex}"]`)
        .addClass(params.slideDuplicateActiveClass);
    } else {
      $wrapperEl
        .children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index="${realIndex}"]`)
        .addClass(params.slideDuplicateActiveClass);
    }
  }
  // Next Slide
  let nextSlide = activeSlide.nextAll(`.${params.slideClass}`).eq(0).addClass(params.slideNextClass);
  if (params.loop && nextSlide.length === 0) {
    nextSlide = slides.eq(0);
    nextSlide.addClass(params.slideNextClass);
  }
  // Prev Slide
  let prevSlide = activeSlide.prevAll(`.${params.slideClass}`).eq(0).addClass(params.slidePrevClass);
  if (params.loop && prevSlide.length === 0) {
    prevSlide = slides.eq(-1);
    prevSlide.addClass(params.slidePrevClass);
  }
  if (params.loop) {
    // Duplicate to all looped slides
    if (nextSlide.hasClass(params.slideDuplicateClass)) {
      $wrapperEl
        .children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index="${nextSlide.attr('data-swiper-slide-index')}"]`)
        .addClass(params.slideDuplicateNextClass);
    } else {
      $wrapperEl
        .children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index="${nextSlide.attr('data-swiper-slide-index')}"]`)
        .addClass(params.slideDuplicateNextClass);
    }
    if (prevSlide.hasClass(params.slideDuplicateClass)) {
      $wrapperEl
        .children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index="${prevSlide.attr('data-swiper-slide-index')}"]`)
        .addClass(params.slideDuplicatePrevClass);
    } else {
      $wrapperEl
        .children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index="${prevSlide.attr('data-swiper-slide-index')}"]`)
        .addClass(params.slideDuplicatePrevClass);
    }
  }
}

function updateActiveIndex (newActiveIndex) {
  const swiper = this;
  const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
  const {
    slidesGrid, snapGrid, params, activeIndex: previousIndex, realIndex: previousRealIndex, snapIndex: previousSnapIndex,
  } = swiper;
  let activeIndex = newActiveIndex;
  let snapIndex;
  if (typeof activeIndex === 'undefined') {
    for (let i = 0; i < slidesGrid.length; i += 1) {
      if (typeof slidesGrid[i + 1] !== 'undefined') {
        if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1] - ((slidesGrid[i + 1] - slidesGrid[i]) / 2)) {
          activeIndex = i;
        } else if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1]) {
          activeIndex = i + 1;
        }
      } else if (translate >= slidesGrid[i]) {
        activeIndex = i;
      }
    }
    // Normalize slideIndex
    if (params.normalizeSlideIndex) {
      if (activeIndex < 0 || typeof activeIndex === 'undefined') activeIndex = 0;
    }
  }
  if (snapGrid.indexOf(translate) >= 0) {
    snapIndex = snapGrid.indexOf(translate);
  } else {
    snapIndex = Math.floor(activeIndex / params.slidesPerGroup);
  }
  if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;
  if (activeIndex === previousIndex) {
    if (snapIndex !== previousSnapIndex) {
      swiper.snapIndex = snapIndex;
      swiper.emit('snapIndexChange');
    }
    return;
  }

  // Get real index
  const realIndex = parseInt(swiper.slides.eq(activeIndex).attr('data-swiper-slide-index') || activeIndex, 10);

  Utils.extend(swiper, {
    snapIndex,
    realIndex,
    previousIndex,
    activeIndex,
  });
  swiper.emit('activeIndexChange');
  swiper.emit('snapIndexChange');
  if (previousRealIndex !== realIndex) {
    swiper.emit('realIndexChange');
  }
  swiper.emit('slideChange');
}

function updateClickedSlide (e) {
  const swiper = this;
  const params = swiper.params;
  const slide = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(e.target).closest(`.${params.slideClass}`)[0];
  let slideFound = false;
  if (slide) {
    for (let i = 0; i < swiper.slides.length; i += 1) {
      if (swiper.slides[i] === slide) slideFound = true;
    }
  }

  if (slide && slideFound) {
    swiper.clickedSlide = slide;
    if (swiper.virtual && swiper.params.virtual.enabled) {
      swiper.clickedIndex = parseInt(Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(slide).attr('data-swiper-slide-index'), 10);
    } else {
      swiper.clickedIndex = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(slide).index();
    }
  } else {
    swiper.clickedSlide = undefined;
    swiper.clickedIndex = undefined;
    return;
  }
  if (params.slideToClickedSlide && swiper.clickedIndex !== undefined && swiper.clickedIndex !== swiper.activeIndex) {
    swiper.slideToClickedSlide();
  }
}

var update = {
  updateSize,
  updateSlides,
  updateAutoHeight,
  updateSlidesOffset,
  updateSlidesProgress,
  updateProgress,
  updateSlidesClasses,
  updateActiveIndex,
  updateClickedSlide,
};

function getTranslate (axis = this.isHorizontal() ? 'x' : 'y') {
  const swiper = this;

  const {
    params, rtlTranslate: rtl, translate, $wrapperEl,
  } = swiper;

  if (params.virtualTranslate) {
    return rtl ? -translate : translate;
  }

  let currentTranslate = Utils.getTranslate($wrapperEl[0], axis);
  if (rtl) currentTranslate = -currentTranslate;

  return currentTranslate || 0;
}

function setTranslate (translate, byController) {
  const swiper = this;
  const {
    rtlTranslate: rtl, params, $wrapperEl, progress,
  } = swiper;
  let x = 0;
  let y = 0;
  const z = 0;

  if (swiper.isHorizontal()) {
    x = rtl ? -translate : translate;
  } else {
    y = translate;
  }

  if (params.roundLengths) {
    x = Math.floor(x);
    y = Math.floor(y);
  }

  if (!params.virtualTranslate) {
    if (Support.transforms3d) $wrapperEl.transform(`translate3d(${x}px, ${y}px, ${z}px)`);
    else $wrapperEl.transform(`translate(${x}px, ${y}px)`);
  }

  swiper.translate = swiper.isHorizontal() ? x : y;

  // Check if we need to update progress
  let newProgress;
  const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
  if (translatesDiff === 0) {
    newProgress = 0;
  } else {
    newProgress = (translate - swiper.minTranslate()) / (translatesDiff);
  }
  if (newProgress !== progress) {
    swiper.updateProgress(translate);
  }

  swiper.emit('setTranslate', swiper.translate, byController);
}

function minTranslate () {
  return (-this.snapGrid[0]);
}

function maxTranslate () {
  return (-this.snapGrid[this.snapGrid.length - 1]);
}

var translate = {
  getTranslate,
  setTranslate,
  minTranslate,
  maxTranslate,
};

function setTransition (duration, byController) {
  const swiper = this;

  swiper.$wrapperEl.transition(duration);

  swiper.emit('setTransition', duration, byController);
}

function transitionStart (runCallbacks = true, direction) {
  const swiper = this;
  const { activeIndex, params, previousIndex } = swiper;
  if (params.autoHeight) {
    swiper.updateAutoHeight();
  }

  let dir = direction;
  if (!dir) {
    if (activeIndex > previousIndex) dir = 'next';
    else if (activeIndex < previousIndex) dir = 'prev';
    else dir = 'reset';
  }

  swiper.emit('transitionStart');

  if (runCallbacks && activeIndex !== previousIndex) {
    if (dir === 'reset') {
      swiper.emit('slideResetTransitionStart');
      return;
    }
    swiper.emit('slideChangeTransitionStart');
    if (dir === 'next') {
      swiper.emit('slideNextTransitionStart');
    } else {
      swiper.emit('slidePrevTransitionStart');
    }
  }
}

function transitionEnd (runCallbacks = true, direction) {
  const swiper = this;
  const { activeIndex, previousIndex } = swiper;
  swiper.animating = false;
  swiper.setTransition(0);

  let dir = direction;
  if (!dir) {
    if (activeIndex > previousIndex) dir = 'next';
    else if (activeIndex < previousIndex) dir = 'prev';
    else dir = 'reset';
  }

  swiper.emit('transitionEnd');

  if (runCallbacks && activeIndex !== previousIndex) {
    if (dir === 'reset') {
      swiper.emit('slideResetTransitionEnd');
      return;
    }
    swiper.emit('slideChangeTransitionEnd');
    if (dir === 'next') {
      swiper.emit('slideNextTransitionEnd');
    } else {
      swiper.emit('slidePrevTransitionEnd');
    }
  }
}

var transition = {
  setTransition,
  transitionStart,
  transitionEnd,
};

function slideTo (index = 0, speed = this.params.speed, runCallbacks = true, internal) {
  const swiper = this;
  let slideIndex = index;
  if (slideIndex < 0) slideIndex = 0;

  const {
    params, snapGrid, slidesGrid, previousIndex, activeIndex, rtlTranslate: rtl,
  } = swiper;
  if (swiper.animating && params.preventIntercationOnTransition) {
    return false;
  }

  let snapIndex = Math.floor(slideIndex / params.slidesPerGroup);
  if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;

  if ((activeIndex || params.initialSlide || 0) === (previousIndex || 0) && runCallbacks) {
    swiper.emit('beforeSlideChangeStart');
  }

  const translate = -snapGrid[snapIndex];

  // Update progress
  swiper.updateProgress(translate);

  // Normalize slideIndex
  if (params.normalizeSlideIndex) {
    for (let i = 0; i < slidesGrid.length; i += 1) {
      if (-Math.floor(translate * 100) >= Math.floor(slidesGrid[i] * 100)) {
        slideIndex = i;
      }
    }
  }
  // Directions locks
  if (swiper.initialized && slideIndex !== activeIndex) {
    if (!swiper.allowSlideNext && translate < swiper.translate && translate < swiper.minTranslate()) {
      return false;
    }
    if (!swiper.allowSlidePrev && translate > swiper.translate && translate > swiper.maxTranslate()) {
      if ((activeIndex || 0) !== slideIndex) return false;
    }
  }

  let direction;
  if (slideIndex > activeIndex) direction = 'next';
  else if (slideIndex < activeIndex) direction = 'prev';
  else direction = 'reset';


  // Update Index
  if ((rtl && -translate === swiper.translate) || (!rtl && translate === swiper.translate)) {
    swiper.updateActiveIndex(slideIndex);
    // Update Height
    if (params.autoHeight) {
      swiper.updateAutoHeight();
    }
    swiper.updateSlidesClasses();
    if (params.effect !== 'slide') {
      swiper.setTranslate(translate);
    }
    if (direction !== 'reset') {
      swiper.transitionStart(runCallbacks, direction);
      swiper.transitionEnd(runCallbacks, direction);
    }
    return false;
  }

  if (speed === 0 || !Support.transition) {
    swiper.setTransition(0);
    swiper.setTranslate(translate);
    swiper.updateActiveIndex(slideIndex);
    swiper.updateSlidesClasses();
    swiper.emit('beforeTransitionStart', speed, internal);
    swiper.transitionStart(runCallbacks, direction);
    swiper.transitionEnd(runCallbacks, direction);
  } else {
    swiper.setTransition(speed);
    swiper.setTranslate(translate);
    swiper.updateActiveIndex(slideIndex);
    swiper.updateSlidesClasses();
    swiper.emit('beforeTransitionStart', speed, internal);
    swiper.transitionStart(runCallbacks, direction);
    if (!swiper.animating) {
      swiper.animating = true;
      if (!swiper.onSlideToWrapperTransitionEnd) {
        swiper.onSlideToWrapperTransitionEnd = function transitionEnd(e) {
          if (!swiper || swiper.destroyed) return;
          if (e.target !== this) return;
          swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);
          swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);
          swiper.transitionEnd(runCallbacks, direction);
        };
      }
      swiper.$wrapperEl[0].addEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);
      swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);
    }
  }

  return true;
}

function slideToLoop (index = 0, speed = this.params.speed, runCallbacks = true, internal) {
  const swiper = this;
  let newIndex = index;
  if (swiper.params.loop) {
    newIndex += swiper.loopedSlides;
  }

  return swiper.slideTo(newIndex, speed, runCallbacks, internal);
}

/* eslint no-unused-vars: "off" */
function slideNext (speed = this.params.speed, runCallbacks = true, internal) {
  const swiper = this;
  const { params, animating } = swiper;
  if (params.loop) {
    if (animating) return false;
    swiper.loopFix();
    // eslint-disable-next-line
    swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
    return swiper.slideTo(swiper.activeIndex + params.slidesPerGroup, speed, runCallbacks, internal);
  }
  return swiper.slideTo(swiper.activeIndex + params.slidesPerGroup, speed, runCallbacks, internal);
}

/* eslint no-unused-vars: "off" */
function slidePrev (speed = this.params.speed, runCallbacks = true, internal) {
  const swiper = this;
  const {
    params, animating, snapGrid, slidesGrid, rtlTranslate,
  } = swiper;

  if (params.loop) {
    if (animating) return false;
    swiper.loopFix();
    // eslint-disable-next-line
    swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
  }
  const translate = rtlTranslate ? swiper.translate : -swiper.translate;
  const currentSnap = snapGrid[snapGrid.indexOf(translate)];
  const prevSnap = snapGrid[snapGrid.indexOf(translate) - 1];
  let prevIndex;

  if (prevSnap) {
    prevIndex = slidesGrid.indexOf(prevSnap);
    if (prevIndex < 0) prevIndex = swiper.activeIndex - 1;
  }
  return swiper.slideTo(prevIndex, speed, runCallbacks, internal);
}

/* eslint no-unused-vars: "off" */
function slideReset (speed = this.params.speed, runCallbacks = true, internal) {
  const swiper = this;
  return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);
}

/* eslint no-unused-vars: "off" */
function slideToClosest (speed = this.params.speed, runCallbacks = true, internal) {
  const swiper = this;
  let index = swiper.activeIndex;
  const snapIndex = Math.floor(index / swiper.params.slidesPerGroup);

  if (snapIndex < swiper.snapGrid.length - 1) {
    const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;

    const currentSnap = swiper.snapGrid[snapIndex];
    const nextSnap = swiper.snapGrid[snapIndex + 1];

    if ((translate - currentSnap) > (nextSnap - currentSnap) / 2) {
      index = swiper.params.slidesPerGroup;
    }
  }

  return swiper.slideTo(index, speed, runCallbacks, internal);
}

function slideToClickedSlide () {
  const swiper = this;
  const { params, $wrapperEl } = swiper;

  const slidesPerView = params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : params.slidesPerView;
  let slideToIndex = swiper.clickedIndex;
  let realIndex;
  if (params.loop) {
    if (swiper.animating) return;
    realIndex = parseInt(Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(swiper.clickedSlide).attr('data-swiper-slide-index'), 10);
    if (params.centeredSlides) {
      if (
        (slideToIndex < swiper.loopedSlides - (slidesPerView / 2)) ||
        (slideToIndex > (swiper.slides.length - swiper.loopedSlides) + (slidesPerView / 2))
      ) {
        swiper.loopFix();
        slideToIndex = $wrapperEl
          .children(`.${params.slideClass}[data-swiper-slide-index="${realIndex}"]:not(.${params.slideDuplicateClass})`)
          .eq(0)
          .index();

        Utils.nextTick(() => {
          swiper.slideTo(slideToIndex);
        });
      } else {
        swiper.slideTo(slideToIndex);
      }
    } else if (slideToIndex > swiper.slides.length - slidesPerView) {
      swiper.loopFix();
      slideToIndex = $wrapperEl
        .children(`.${params.slideClass}[data-swiper-slide-index="${realIndex}"]:not(.${params.slideDuplicateClass})`)
        .eq(0)
        .index();

      Utils.nextTick(() => {
        swiper.slideTo(slideToIndex);
      });
    } else {
      swiper.slideTo(slideToIndex);
    }
  } else {
    swiper.slideTo(slideToIndex);
  }
}

var slide = {
  slideTo,
  slideToLoop,
  slideNext,
  slidePrev,
  slideReset,
  slideToClosest,
  slideToClickedSlide,
};

function loopCreate () {
  const swiper = this;
  const { params, $wrapperEl } = swiper;
  // Remove duplicated slides
  $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass}`).remove();

  let slides = $wrapperEl.children(`.${params.slideClass}`);

  if (params.loopFillGroupWithBlank) {
    const blankSlidesNum = params.slidesPerGroup - (slides.length % params.slidesPerGroup);
    if (blankSlidesNum !== params.slidesPerGroup) {
      for (let i = 0; i < blankSlidesNum; i += 1) {
        const blankNode = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(__WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */].createElement('div')).addClass(`${params.slideClass} ${params.slideBlankClass}`);
        $wrapperEl.append(blankNode);
      }
      slides = $wrapperEl.children(`.${params.slideClass}`);
    }
  }

  if (params.slidesPerView === 'auto' && !params.loopedSlides) params.loopedSlides = slides.length;

  swiper.loopedSlides = parseInt(params.loopedSlides || params.slidesPerView, 10);
  swiper.loopedSlides += params.loopAdditionalSlides;
  if (swiper.loopedSlides > slides.length) {
    swiper.loopedSlides = slides.length;
  }

  const prependSlides = [];
  const appendSlides = [];
  slides.each((index, el) => {
    const slide = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(el);
    if (index < swiper.loopedSlides) appendSlides.push(el);
    if (index < slides.length && index >= slides.length - swiper.loopedSlides) prependSlides.push(el);
    slide.attr('data-swiper-slide-index', index);
  });
  for (let i = 0; i < appendSlides.length; i += 1) {
    $wrapperEl.append(Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(appendSlides[i].cloneNode(true)).addClass(params.slideDuplicateClass));
  }
  for (let i = prependSlides.length - 1; i >= 0; i -= 1) {
    $wrapperEl.prepend(Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(prependSlides[i].cloneNode(true)).addClass(params.slideDuplicateClass));
  }
}

function loopFix () {
  const swiper = this;
  const {
    params, activeIndex, slides, loopedSlides, allowSlidePrev, allowSlideNext, snapGrid, rtlTranslate: rtl,
  } = swiper;
  let newIndex;
  swiper.allowSlidePrev = true;
  swiper.allowSlideNext = true;

  const snapTranslate = -snapGrid[activeIndex];
  const diff = snapTranslate - swiper.getTranslate();


  // Fix For Negative Oversliding
  if (activeIndex < loopedSlides) {
    newIndex = (slides.length - (loopedSlides * 3)) + activeIndex;
    newIndex += loopedSlides;
    const slideChanged = swiper.slideTo(newIndex, 0, false, true);
    if (slideChanged && diff !== 0) {
      swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);
    }
  } else if ((params.slidesPerView === 'auto' && activeIndex >= loopedSlides * 2) || (activeIndex > slides.length - (params.slidesPerView * 2))) {
    // Fix For Positive Oversliding
    newIndex = -slides.length + activeIndex + loopedSlides;
    newIndex += loopedSlides;
    const slideChanged = swiper.slideTo(newIndex, 0, false, true);
    if (slideChanged && diff !== 0) {
      swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);
    }
  }
  swiper.allowSlidePrev = allowSlidePrev;
  swiper.allowSlideNext = allowSlideNext;
}

function loopDestroy () {
  const swiper = this;
  const { $wrapperEl, params, slides } = swiper;
  $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass}`).remove();
  slides.removeAttr('data-swiper-slide-index');
}

var loop = {
  loopCreate,
  loopFix,
  loopDestroy,
};

function setGrabCursor (moving) {
  const swiper = this;
  if (Support.touch || !swiper.params.simulateTouch || (swiper.params.watchOverflow && swiper.isLocked)) return;
  const el = swiper.el;
  el.style.cursor = 'move';
  el.style.cursor = moving ? '-webkit-grabbing' : '-webkit-grab';
  el.style.cursor = moving ? '-moz-grabbin' : '-moz-grab';
  el.style.cursor = moving ? 'grabbing' : 'grab';
}

function unsetGrabCursor () {
  const swiper = this;
  if (Support.touch || (swiper.params.watchOverflow && swiper.isLocked)) return;
  swiper.el.style.cursor = '';
}

var grabCursor = {
  setGrabCursor,
  unsetGrabCursor,
};

function appendSlide (slides) {
  const swiper = this;
  const { $wrapperEl, params } = swiper;
  if (params.loop) {
    swiper.loopDestroy();
  }
  if (typeof slides === 'object' && 'length' in slides) {
    for (let i = 0; i < slides.length; i += 1) {
      if (slides[i]) $wrapperEl.append(slides[i]);
    }
  } else {
    $wrapperEl.append(slides);
  }
  if (params.loop) {
    swiper.loopCreate();
  }
  if (!(params.observer && Support.observer)) {
    swiper.update();
  }
}

function prependSlide (slides) {
  const swiper = this;
  const { params, $wrapperEl, activeIndex } = swiper;

  if (params.loop) {
    swiper.loopDestroy();
  }
  let newActiveIndex = activeIndex + 1;
  if (typeof slides === 'object' && 'length' in slides) {
    for (let i = 0; i < slides.length; i += 1) {
      if (slides[i]) $wrapperEl.prepend(slides[i]);
    }
    newActiveIndex = activeIndex + slides.length;
  } else {
    $wrapperEl.prepend(slides);
  }
  if (params.loop) {
    swiper.loopCreate();
  }
  if (!(params.observer && Support.observer)) {
    swiper.update();
  }
  swiper.slideTo(newActiveIndex, 0, false);
}

function removeSlide (slidesIndexes) {
  const swiper = this;
  const { params, $wrapperEl, activeIndex } = swiper;

  if (params.loop) {
    swiper.loopDestroy();
    swiper.slides = $wrapperEl.children(`.${params.slideClass}`);
  }
  let newActiveIndex = activeIndex;
  let indexToRemove;

  if (typeof slidesIndexes === 'object' && 'length' in slidesIndexes) {
    for (let i = 0; i < slidesIndexes.length; i += 1) {
      indexToRemove = slidesIndexes[i];
      if (swiper.slides[indexToRemove]) swiper.slides.eq(indexToRemove).remove();
      if (indexToRemove < newActiveIndex) newActiveIndex -= 1;
    }
    newActiveIndex = Math.max(newActiveIndex, 0);
  } else {
    indexToRemove = slidesIndexes;
    if (swiper.slides[indexToRemove]) swiper.slides.eq(indexToRemove).remove();
    if (indexToRemove < newActiveIndex) newActiveIndex -= 1;
    newActiveIndex = Math.max(newActiveIndex, 0);
  }

  if (params.loop) {
    swiper.loopCreate();
  }

  if (!(params.observer && Support.observer)) {
    swiper.update();
  }
  if (params.loop) {
    swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);
  } else {
    swiper.slideTo(newActiveIndex, 0, false);
  }
}

function removeAllSlides () {
  const swiper = this;

  const slidesIndexes = [];
  for (let i = 0; i < swiper.slides.length; i += 1) {
    slidesIndexes.push(i);
  }
  swiper.removeSlide(slidesIndexes);
}

var manipulation = {
  appendSlide,
  prependSlide,
  removeSlide,
  removeAllSlides,
};

function onTouchStart (event) {
  const swiper = this;
  const data = swiper.touchEventsData;
  const { params, touches } = swiper;
  if (swiper.animating && params.preventIntercationOnTransition) {
    return;
  }
  let e = event;
  if (e.originalEvent) e = e.originalEvent;
  data.isTouchEvent = e.type === 'touchstart';
  if (!data.isTouchEvent && 'which' in e && e.which === 3) return;
  if (data.isTouched && data.isMoved) return;
  if (params.noSwiping && Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(e.target).closest(params.noSwipingSelector ? params.noSwipingSelector : `.${params.noSwipingClass}`)[0]) {
    swiper.allowClick = true;
    return;
  }
  if (params.swipeHandler) {
    if (!Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(e).closest(params.swipeHandler)[0]) return;
  }

  touches.currentX = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
  touches.currentY = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
  const startX = touches.currentX;
  const startY = touches.currentY;

  // Do NOT start if iOS edge swipe is detected. Otherwise iOS app (UIWebView) cannot swipe-to-go-back anymore

  if (
    Device.ios &&
    !Device.cordova &&
    params.iOSEdgeSwipeDetection &&
    (startX <= params.iOSEdgeSwipeThreshold) &&
    (startX >= __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].screen.width - params.iOSEdgeSwipeThreshold)
  ) {
    return;
  }

  Utils.extend(data, {
    isTouched: true,
    isMoved: false,
    allowTouchCallbacks: true,
    isScrolling: undefined,
    startMoving: undefined,
  });

  touches.startX = startX;
  touches.startY = startY;
  data.touchStartTime = Utils.now();
  swiper.allowClick = true;
  swiper.updateSize();
  swiper.swipeDirection = undefined;
  if (params.threshold > 0) data.allowThresholdMove = false;
  if (e.type !== 'touchstart') {
    let preventDefault = true;
    if (Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(e.target).is(data.formElements)) preventDefault = false;
    if (
      __WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */].activeElement &&
      Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(__WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */].activeElement).is(data.formElements) &&
      __WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */].activeElement !== e.target
    ) {
      __WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */].activeElement.blur();
    }
    if (preventDefault && swiper.allowTouchMove) {
      e.preventDefault();
    }
  }
  swiper.emit('touchStart', e);
}

function onTouchMove (event) {
  const swiper = this;
  const data = swiper.touchEventsData;
  const { params, touches, rtlTranslate: rtl } = swiper;
  let e = event;
  if (e.originalEvent) e = e.originalEvent;
  if (!data.isTouched) {
    if (data.startMoving && data.isScrolling) {
      swiper.emit('touchMoveOpposite', e);
    }
    return;
  }
  if (data.isTouchEvent && e.type === 'mousemove') return;
  const pageX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
  const pageY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
  if (e.preventedByNestedSwiper) {
    touches.startX = pageX;
    touches.startY = pageY;
    return;
  }
  if (!swiper.allowTouchMove) {
    // isMoved = true;
    swiper.allowClick = false;
    if (data.isTouched) {
      Utils.extend(touches, {
        startX: pageX,
        startY: pageY,
        currentX: pageX,
        currentY: pageY,
      });
      data.touchStartTime = Utils.now();
    }
    return;
  }
  if (data.isTouchEvent && params.touchReleaseOnEdges && !params.loop) {
    if (swiper.isVertical()) {
      // Vertical
      if (
        (pageY < touches.startY && swiper.translate <= swiper.maxTranslate()) ||
        (pageY > touches.startY && swiper.translate >= swiper.minTranslate())
      ) {
        data.isTouched = false;
        data.isMoved = false;
        return;
      }
    } else if (
      (pageX < touches.startX && swiper.translate <= swiper.maxTranslate()) ||
      (pageX > touches.startX && swiper.translate >= swiper.minTranslate())
    ) {
      return;
    }
  }
  if (data.isTouchEvent && __WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */].activeElement) {
    if (e.target === __WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */].activeElement && Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(e.target).is(data.formElements)) {
      data.isMoved = true;
      swiper.allowClick = false;
      return;
    }
  }
  if (data.allowTouchCallbacks) {
    swiper.emit('touchMove', e);
  }
  if (e.targetTouches && e.targetTouches.length > 1) return;

  touches.currentX = pageX;
  touches.currentY = pageY;

  const diffX = touches.currentX - touches.startX;
  const diffY = touches.currentY - touches.startY;

  if (typeof data.isScrolling === 'undefined') {
    let touchAngle;
    if ((swiper.isHorizontal() && touches.currentY === touches.startY) || (swiper.isVertical() && touches.currentX === touches.startX)) {
      data.isScrolling = false;
    } else {
      // eslint-disable-next-line
      if ((diffX * diffX) + (diffY * diffY) >= 25) {
        touchAngle = (Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180) / Math.PI;
        data.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : (90 - touchAngle > params.touchAngle);
      }
    }
  }
  if (data.isScrolling) {
    swiper.emit('touchMoveOpposite', e);
  }
  if (typeof startMoving === 'undefined') {
    if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) {
      data.startMoving = true;
    }
  }
  if (data.isScrolling) {
    data.isTouched = false;
    return;
  }
  if (!data.startMoving) {
    return;
  }
  swiper.allowClick = false;
  e.preventDefault();
  if (params.touchMoveStopPropagation && !params.nested) {
    e.stopPropagation();
  }

  if (!data.isMoved) {
    if (params.loop) {
      swiper.loopFix();
    }
    data.startTranslate = swiper.getTranslate();
    swiper.setTransition(0);
    if (swiper.animating) {
      swiper.$wrapperEl.trigger('webkitTransitionEnd transitionend');
    }
    data.allowMomentumBounce = false;
    // Grab Cursor
    if (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
      swiper.setGrabCursor(true);
    }
    swiper.emit('sliderFirstMove', e);
  }
  swiper.emit('sliderMove', e);
  data.isMoved = true;

  let diff = swiper.isHorizontal() ? diffX : diffY;
  touches.diff = diff;

  diff *= params.touchRatio;
  if (rtl) diff = -diff;

  swiper.swipeDirection = diff > 0 ? 'prev' : 'next';
  data.currentTranslate = diff + data.startTranslate;

  let disableParentSwiper = true;
  let resistanceRatio = params.resistanceRatio;
  if (params.touchReleaseOnEdges) {
    resistanceRatio = 0;
  }
  if ((diff > 0 && data.currentTranslate > swiper.minTranslate())) {
    disableParentSwiper = false;
    if (params.resistance) data.currentTranslate = (swiper.minTranslate() - 1) + ((-swiper.minTranslate() + data.startTranslate + diff) ** resistanceRatio);
  } else if (diff < 0 && data.currentTranslate < swiper.maxTranslate()) {
    disableParentSwiper = false;
    if (params.resistance) data.currentTranslate = (swiper.maxTranslate() + 1) - ((swiper.maxTranslate() - data.startTranslate - diff) ** resistanceRatio);
  }

  if (disableParentSwiper) {
    e.preventedByNestedSwiper = true;
  }

  // Directions locks
  if (!swiper.allowSlideNext && swiper.swipeDirection === 'next' && data.currentTranslate < data.startTranslate) {
    data.currentTranslate = data.startTranslate;
  }
  if (!swiper.allowSlidePrev && swiper.swipeDirection === 'prev' && data.currentTranslate > data.startTranslate) {
    data.currentTranslate = data.startTranslate;
  }


  // Threshold
  if (params.threshold > 0) {
    if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {
      if (!data.allowThresholdMove) {
        data.allowThresholdMove = true;
        touches.startX = touches.currentX;
        touches.startY = touches.currentY;
        data.currentTranslate = data.startTranslate;
        touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;
        return;
      }
    } else {
      data.currentTranslate = data.startTranslate;
      return;
    }
  }

  if (!params.followFinger) return;

  // Update active index in free mode
  if (params.freeMode || params.watchSlidesProgress || params.watchSlidesVisibility) {
    swiper.updateActiveIndex();
    swiper.updateSlidesClasses();
  }
  if (params.freeMode) {
    // Velocity
    if (data.velocities.length === 0) {
      data.velocities.push({
        position: touches[swiper.isHorizontal() ? 'startX' : 'startY'],
        time: data.touchStartTime,
      });
    }
    data.velocities.push({
      position: touches[swiper.isHorizontal() ? 'currentX' : 'currentY'],
      time: Utils.now(),
    });
  }
  // Update progress
  swiper.updateProgress(data.currentTranslate);
  // Update translate
  swiper.setTranslate(data.currentTranslate);
}

function onTouchEnd (event) {
  const swiper = this;
  const data = swiper.touchEventsData;

  const {
    params, touches, rtlTranslate: rtl, $wrapperEl, slidesGrid, snapGrid,
  } = swiper;
  let e = event;
  if (e.originalEvent) e = e.originalEvent;
  if (data.allowTouchCallbacks) {
    swiper.emit('touchEnd', e);
  }
  data.allowTouchCallbacks = false;
  if (!data.isTouched) {
    if (data.isMoved && params.grabCursor) {
      swiper.setGrabCursor(false);
    }
    data.isMoved = false;
    data.startMoving = false;
    return;
  }
  // Return Grab Cursor
  if (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
    swiper.setGrabCursor(false);
  }

  // Time diff
  const touchEndTime = Utils.now();
  const timeDiff = touchEndTime - data.touchStartTime;

  // Tap, doubleTap, Click
  if (swiper.allowClick) {
    swiper.updateClickedSlide(e);
    swiper.emit('tap', e);
    if (timeDiff < 300 && (touchEndTime - data.lastClickTime) > 300) {
      if (data.clickTimeout) clearTimeout(data.clickTimeout);
      data.clickTimeout = Utils.nextTick(() => {
        if (!swiper || swiper.destroyed) return;
        swiper.emit('click', e);
      }, 300);
    }
    if (timeDiff < 300 && (touchEndTime - data.lastClickTime) < 300) {
      if (data.clickTimeout) clearTimeout(data.clickTimeout);
      swiper.emit('doubleTap', e);
    }
  }

  data.lastClickTime = Utils.now();
  Utils.nextTick(() => {
    if (!swiper.destroyed) swiper.allowClick = true;
  });

  if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 || data.currentTranslate === data.startTranslate) {
    data.isTouched = false;
    data.isMoved = false;
    data.startMoving = false;
    return;
  }
  data.isTouched = false;
  data.isMoved = false;
  data.startMoving = false;

  let currentPos;
  if (params.followFinger) {
    currentPos = rtl ? swiper.translate : -swiper.translate;
  } else {
    currentPos = -data.currentTranslate;
  }

  if (params.freeMode) {
    if (currentPos < -swiper.minTranslate()) {
      swiper.slideTo(swiper.activeIndex);
      return;
    } else if (currentPos > -swiper.maxTranslate()) {
      if (swiper.slides.length < snapGrid.length) {
        swiper.slideTo(snapGrid.length - 1);
      } else {
        swiper.slideTo(swiper.slides.length - 1);
      }
      return;
    }

    if (params.freeModeMomentum) {
      if (data.velocities.length > 1) {
        const lastMoveEvent = data.velocities.pop();
        const velocityEvent = data.velocities.pop();

        const distance = lastMoveEvent.position - velocityEvent.position;
        const time = lastMoveEvent.time - velocityEvent.time;
        swiper.velocity = distance / time;
        swiper.velocity /= 2;
        if (Math.abs(swiper.velocity) < params.freeModeMinimumVelocity) {
          swiper.velocity = 0;
        }
        // this implies that the user stopped moving a finger then released.
        // There would be no events with distance zero, so the last event is stale.
        if (time > 150 || (Utils.now() - lastMoveEvent.time) > 300) {
          swiper.velocity = 0;
        }
      } else {
        swiper.velocity = 0;
      }
      swiper.velocity *= params.freeModeMomentumVelocityRatio;

      data.velocities.length = 0;
      let momentumDuration = 1000 * params.freeModeMomentumRatio;
      const momentumDistance = swiper.velocity * momentumDuration;

      let newPosition = swiper.translate + momentumDistance;
      if (rtl) newPosition = -newPosition;

      let doBounce = false;
      let afterBouncePosition;
      const bounceAmount = Math.abs(swiper.velocity) * 20 * params.freeModeMomentumBounceRatio;
      let needsLoopFix;
      if (newPosition < swiper.maxTranslate()) {
        if (params.freeModeMomentumBounce) {
          if (newPosition + swiper.maxTranslate() < -bounceAmount) {
            newPosition = swiper.maxTranslate() - bounceAmount;
          }
          afterBouncePosition = swiper.maxTranslate();
          doBounce = true;
          data.allowMomentumBounce = true;
        } else {
          newPosition = swiper.maxTranslate();
        }
        if (params.loop && params.centeredSlides) needsLoopFix = true;
      } else if (newPosition > swiper.minTranslate()) {
        if (params.freeModeMomentumBounce) {
          if (newPosition - swiper.minTranslate() > bounceAmount) {
            newPosition = swiper.minTranslate() + bounceAmount;
          }
          afterBouncePosition = swiper.minTranslate();
          doBounce = true;
          data.allowMomentumBounce = true;
        } else {
          newPosition = swiper.minTranslate();
        }
        if (params.loop && params.centeredSlides) needsLoopFix = true;
      } else if (params.freeModeSticky) {
        let nextSlide;
        for (let j = 0; j < snapGrid.length; j += 1) {
          if (snapGrid[j] > -newPosition) {
            nextSlide = j;
            break;
          }
        }

        if (Math.abs(snapGrid[nextSlide] - newPosition) < Math.abs(snapGrid[nextSlide - 1] - newPosition) || swiper.swipeDirection === 'next') {
          newPosition = snapGrid[nextSlide];
        } else {
          newPosition = snapGrid[nextSlide - 1];
        }
        newPosition = -newPosition;
      }
      if (needsLoopFix) {
        swiper.once('transitionEnd', () => {
          swiper.loopFix();
        });
      }
      // Fix duration
      if (swiper.velocity !== 0) {
        if (rtl) {
          momentumDuration = Math.abs((-newPosition - swiper.translate) / swiper.velocity);
        } else {
          momentumDuration = Math.abs((newPosition - swiper.translate) / swiper.velocity);
        }
      } else if (params.freeModeSticky) {
        swiper.slideToClosest();
        return;
      }

      if (params.freeModeMomentumBounce && doBounce) {
        swiper.updateProgress(afterBouncePosition);
        swiper.setTransition(momentumDuration);
        swiper.setTranslate(newPosition);
        swiper.transitionStart(true, swiper.swipeDirection);
        swiper.animating = true;
        $wrapperEl.transitionEnd(() => {
          if (!swiper || swiper.destroyed || !data.allowMomentumBounce) return;
          swiper.emit('momentumBounce');

          swiper.setTransition(params.speed);
          swiper.setTranslate(afterBouncePosition);
          $wrapperEl.transitionEnd(() => {
            if (!swiper || swiper.destroyed) return;
            swiper.transitionEnd();
          });
        });
      } else if (swiper.velocity) {
        swiper.updateProgress(newPosition);
        swiper.setTransition(momentumDuration);
        swiper.setTranslate(newPosition);
        swiper.transitionStart(true, swiper.swipeDirection);
        if (!swiper.animating) {
          swiper.animating = true;
          $wrapperEl.transitionEnd(() => {
            if (!swiper || swiper.destroyed) return;
            swiper.transitionEnd();
          });
        }
      } else {
        swiper.updateProgress(newPosition);
      }

      swiper.updateActiveIndex();
      swiper.updateSlidesClasses();
    } else if (params.freeModeSticky) {
      swiper.slideToClosest();
      return;
    }

    if (!params.freeModeMomentum || timeDiff >= params.longSwipesMs) {
      swiper.updateProgress();
      swiper.updateActiveIndex();
      swiper.updateSlidesClasses();
    }
    return;
  }

  // Find current slide
  let stopIndex = 0;
  let groupSize = swiper.slidesSizesGrid[0];
  for (let i = 0; i < slidesGrid.length; i += params.slidesPerGroup) {
    if (typeof slidesGrid[i + params.slidesPerGroup] !== 'undefined') {
      if (currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + params.slidesPerGroup]) {
        stopIndex = i;
        groupSize = slidesGrid[i + params.slidesPerGroup] - slidesGrid[i];
      }
    } else if (currentPos >= slidesGrid[i]) {
      stopIndex = i;
      groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];
    }
  }

  // Find current slide size
  const ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;

  if (timeDiff > params.longSwipesMs) {
    // Long touches
    if (!params.longSwipes) {
      swiper.slideTo(swiper.activeIndex);
      return;
    }
    if (swiper.swipeDirection === 'next') {
      if (ratio >= params.longSwipesRatio) swiper.slideTo(stopIndex + params.slidesPerGroup);
      else swiper.slideTo(stopIndex);
    }
    if (swiper.swipeDirection === 'prev') {
      if (ratio > (1 - params.longSwipesRatio)) swiper.slideTo(stopIndex + params.slidesPerGroup);
      else swiper.slideTo(stopIndex);
    }
  } else {
    // Short swipes
    if (!params.shortSwipes) {
      swiper.slideTo(swiper.activeIndex);
      return;
    }
    if (swiper.swipeDirection === 'next') {
      swiper.slideTo(stopIndex + params.slidesPerGroup);
    }
    if (swiper.swipeDirection === 'prev') {
      swiper.slideTo(stopIndex);
    }
  }
}

function onResize () {
  const swiper = this;

  const { params, el } = swiper;

  if (el && el.offsetWidth === 0) return;

  // Breakpoints
  if (params.breakpoints) {
    swiper.setBreakpoint();
  }

  // Save locks
  const { allowSlideNext, allowSlidePrev, snapGrid } = swiper;

  // Disable locks on resize
  swiper.allowSlideNext = true;
  swiper.allowSlidePrev = true;

  swiper.updateSize();
  swiper.updateSlides();

  if (params.freeMode) {
    const newTranslate = Math.min(Math.max(swiper.translate, swiper.maxTranslate()), swiper.minTranslate());
    swiper.setTranslate(newTranslate);
    swiper.updateActiveIndex();
    swiper.updateSlidesClasses();

    if (params.autoHeight) {
      swiper.updateAutoHeight();
    }
  } else {
    swiper.updateSlidesClasses();
    if ((params.slidesPerView === 'auto' || params.slidesPerView > 1) && swiper.isEnd && !swiper.params.centeredSlides) {
      swiper.slideTo(swiper.slides.length - 1, 0, false, true);
    } else {
      swiper.slideTo(swiper.activeIndex, 0, false, true);
    }
  }
  // Return locks after resize
  swiper.allowSlidePrev = allowSlidePrev;
  swiper.allowSlideNext = allowSlideNext;

  if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) {
    swiper.checkOverflow();
  }
}

function onClick (e) {
  const swiper = this;
  if (!swiper.allowClick) {
    if (swiper.params.preventClicks) e.preventDefault();
    if (swiper.params.preventClicksPropagation && swiper.animating) {
      e.stopPropagation();
      e.stopImmediatePropagation();
    }
  }
}

function attachEvents() {
  const swiper = this;
  const {
    params, touchEvents, el, wrapperEl,
  } = swiper;

  {
    swiper.onTouchStart = onTouchStart.bind(swiper);
    swiper.onTouchMove = onTouchMove.bind(swiper);
    swiper.onTouchEnd = onTouchEnd.bind(swiper);
  }

  swiper.onClick = onClick.bind(swiper);

  const target = params.touchEventsTarget === 'container' ? el : wrapperEl;
  const capture = !!params.nested;

  // Touch Events
  {
    if (!Support.touch && (Support.pointerEvents || Support.prefixedPointerEvents)) {
      target.addEventListener(touchEvents.start, swiper.onTouchStart, false);
      __WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */].addEventListener(touchEvents.move, swiper.onTouchMove, capture);
      __WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */].addEventListener(touchEvents.end, swiper.onTouchEnd, false);
    } else {
      if (Support.touch) {
        const passiveListener = touchEvents.start === 'touchstart' && Support.passiveListener && params.passiveListeners ? { passive: true, capture: false } : false;
        target.addEventListener(touchEvents.start, swiper.onTouchStart, passiveListener);
        target.addEventListener(touchEvents.move, swiper.onTouchMove, Support.passiveListener ? { passive: false, capture } : capture);
        target.addEventListener(touchEvents.end, swiper.onTouchEnd, passiveListener);
      }
      if ((params.simulateTouch && !Device.ios && !Device.android) || (params.simulateTouch && !Support.touch && Device.ios)) {
        target.addEventListener('mousedown', swiper.onTouchStart, false);
        __WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */].addEventListener('mousemove', swiper.onTouchMove, capture);
        __WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */].addEventListener('mouseup', swiper.onTouchEnd, false);
      }
    }
    // Prevent Links Clicks
    if (params.preventClicks || params.preventClicksPropagation) {
      target.addEventListener('click', swiper.onClick, true);
    }
  }

  // Resize handler
  swiper.on('resize observerUpdate', onResize, true);
}

function detachEvents() {
  const swiper = this;

  const {
    params, touchEvents, el, wrapperEl,
  } = swiper;

  const target = params.touchEventsTarget === 'container' ? el : wrapperEl;
  const capture = !!params.nested;

  // Touch Events
  {
    if (!Support.touch && (Support.pointerEvents || Support.prefixedPointerEvents)) {
      target.removeEventListener(touchEvents.start, swiper.onTouchStart, false);
      __WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */].removeEventListener(touchEvents.move, swiper.onTouchMove, capture);
      __WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */].removeEventListener(touchEvents.end, swiper.onTouchEnd, false);
    } else {
      if (Support.touch) {
        const passiveListener = touchEvents.start === 'onTouchStart' && Support.passiveListener && params.passiveListeners ? { passive: true, capture: false } : false;
        target.removeEventListener(touchEvents.start, swiper.onTouchStart, passiveListener);
        target.removeEventListener(touchEvents.move, swiper.onTouchMove, capture);
        target.removeEventListener(touchEvents.end, swiper.onTouchEnd, passiveListener);
      }
      if ((params.simulateTouch && !Device.ios && !Device.android) || (params.simulateTouch && !Support.touch && Device.ios)) {
        target.removeEventListener('mousedown', swiper.onTouchStart, false);
        __WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */].removeEventListener('mousemove', swiper.onTouchMove, capture);
        __WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */].removeEventListener('mouseup', swiper.onTouchEnd, false);
      }
    }
    // Prevent Links Clicks
    if (params.preventClicks || params.preventClicksPropagation) {
      target.removeEventListener('click', swiper.onClick, true);
    }
  }

  // Resize handler
  swiper.off('resize observerUpdate', onResize);
}

var events = {
  attachEvents,
  detachEvents,
};

function setBreakpoint () {
  const swiper = this;
  const {
    activeIndex, initialized, loopedSlides = 0, params,
  } = swiper;
  const breakpoints = params.breakpoints;
  if (!breakpoints || (breakpoints && Object.keys(breakpoints).length === 0)) return;
  // Set breakpoint for window width and update parameters
  const breakpoint = swiper.getBreakpoint(breakpoints);
  if (breakpoint && swiper.currentBreakpoint !== breakpoint) {
    const breakPointsParams = breakpoint in breakpoints ? breakpoints[breakpoint] : swiper.originalParams;
    const needsReLoop = params.loop && (breakPointsParams.slidesPerView !== params.slidesPerView);

    Utils.extend(swiper.params, breakPointsParams);

    Utils.extend(swiper, {
      allowTouchMove: swiper.params.allowTouchMove,
      allowSlideNext: swiper.params.allowSlideNext,
      allowSlidePrev: swiper.params.allowSlidePrev,
    });

    swiper.currentBreakpoint = breakpoint;

    if (needsReLoop && initialized) {
      swiper.loopDestroy();
      swiper.loopCreate();
      swiper.updateSlides();
      swiper.slideTo((activeIndex - loopedSlides) + swiper.loopedSlides, 0, false);
    }
    swiper.emit('breakpoint', breakPointsParams);
  }
}

function getBreakpoint (breakpoints) {
  // Get breakpoint for window width
  if (!breakpoints) return undefined;
  let breakpoint = false;
  const points = [];
  Object.keys(breakpoints).forEach((point) => {
    points.push(point);
  });
  points.sort((a, b) => parseInt(a, 10) - parseInt(b, 10));
  for (let i = 0; i < points.length; i += 1) {
    const point = points[i];
    if (point >= __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].innerWidth && !breakpoint) {
      breakpoint = point;
    }
  }
  return breakpoint || 'max';
}

var breakpoints = { setBreakpoint, getBreakpoint };

const Browser = (function Browser() {
  function isSafari() {
    const ua = __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].navigator.userAgent.toLowerCase();
    return (ua.indexOf('safari') >= 0 && ua.indexOf('chrome') < 0 && ua.indexOf('android') < 0);
  }
  return {
    isIE: !!__WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].navigator.userAgent.match(/Trident/g) || !!__WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].navigator.userAgent.match(/MSIE/g),
    isSafari: isSafari(),
    isUiWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(__WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].navigator.userAgent),
  };
}());

function addClasses () {
  const swiper = this;
  const {
    classNames, params, rtl, $el,
  } = swiper;
  const suffixes = [];

  suffixes.push(params.direction);

  if (params.freeMode) {
    suffixes.push('free-mode');
  }
  if (!Support.flexbox) {
    suffixes.push('no-flexbox');
  }
  if (params.autoHeight) {
    suffixes.push('autoheight');
  }
  if (rtl) {
    suffixes.push('rtl');
  }
  if (params.slidesPerColumn > 1) {
    suffixes.push('multirow');
  }
  if (Device.android) {
    suffixes.push('android');
  }
  if (Device.ios) {
    suffixes.push('ios');
  }
  // WP8 Touch Events Fix
  if (Browser.isIE && (Support.pointerEvents || Support.prefixedPointerEvents)) {
    suffixes.push(`wp8-${params.direction}`);
  }

  suffixes.forEach((suffix) => {
    classNames.push(params.containerModifierClass + suffix);
  });

  $el.addClass(classNames.join(' '));
}

function removeClasses () {
  const swiper = this;
  const { $el, classNames } = swiper;

  $el.removeClass(classNames.join(' '));
}

var classes = { addClasses, removeClasses };

function loadImage (imageEl, src, srcset, sizes, checkForComplete, callback) {
  let image;
  function onReady() {
    if (callback) callback();
  }
  if (!imageEl.complete || !checkForComplete) {
    if (src) {
      image = new __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].Image();
      image.onload = onReady;
      image.onerror = onReady;
      if (sizes) {
        image.sizes = sizes;
      }
      if (srcset) {
        image.srcset = srcset;
      }
      if (src) {
        image.src = src;
      }
    } else {
      onReady();
    }
  } else {
    // image already loaded...
    onReady();
  }
}

function preloadImages () {
  const swiper = this;
  swiper.imagesToLoad = swiper.$el.find('img');
  function onReady() {
    if (typeof swiper === 'undefined' || swiper === null || !swiper || swiper.destroyed) return;
    if (swiper.imagesLoaded !== undefined) swiper.imagesLoaded += 1;
    if (swiper.imagesLoaded === swiper.imagesToLoad.length) {
      if (swiper.params.updateOnImagesReady) swiper.update();
      swiper.emit('imagesReady');
    }
  }
  for (let i = 0; i < swiper.imagesToLoad.length; i += 1) {
    const imageEl = swiper.imagesToLoad[i];
    swiper.loadImage(
      imageEl,
      imageEl.currentSrc || imageEl.getAttribute('src'),
      imageEl.srcset || imageEl.getAttribute('srcset'),
      imageEl.sizes || imageEl.getAttribute('sizes'),
      true,
      onReady
    );
  }
}

var images = {
  loadImage,
  preloadImages,
};

function checkOverflow() {
  const swiper = this;
  const wasLocked = swiper.isLocked;

  swiper.isLocked = swiper.snapGrid.length === 1;
  swiper.allowSlideNext = !swiper.isLocked;
  swiper.allowSlidePrev = !swiper.isLocked;

  // events
  if (wasLocked !== swiper.isLocked) swiper.emit(swiper.isLocked ? 'lock' : 'unlock');

  if (wasLocked && wasLocked !== swiper.isLocked) {
    swiper.isEnd = false;
    swiper.navigation.update();
  }
}

var checkOverflow$1 = { checkOverflow };

var defaults = {
  init: true,
  direction: 'horizontal',
  touchEventsTarget: 'container',
  initialSlide: 0,
  speed: 300,
  //
  preventIntercationOnTransition: false,

  // To support iOS's swipe-to-go-back gesture (when being used in-app, with UIWebView).
  iOSEdgeSwipeDetection: false,
  iOSEdgeSwipeThreshold: 20,

  // Free mode
  freeMode: false,
  freeModeMomentum: true,
  freeModeMomentumRatio: 1,
  freeModeMomentumBounce: true,
  freeModeMomentumBounceRatio: 1,
  freeModeMomentumVelocityRatio: 1,
  freeModeSticky: false,
  freeModeMinimumVelocity: 0.02,

  // Autoheight
  autoHeight: false,

  // Set wrapper width
  setWrapperSize: false,

  // Virtual Translate
  virtualTranslate: false,

  // Effects
  effect: 'slide', // 'slide' or 'fade' or 'cube' or 'coverflow' or 'flip'

  // Breakpoints
  breakpoints: undefined,

  // Slides grid
  spaceBetween: 0,
  slidesPerView: 1,
  slidesPerColumn: 1,
  slidesPerColumnFill: 'column',
  slidesPerGroup: 1,
  centeredSlides: false,
  slidesOffsetBefore: 0, // in px
  slidesOffsetAfter: 0, // in px
  normalizeSlideIndex: true,

  // Disable swiper and hide navigation when container not overflow
  watchOverflow: false,

  // Round length
  roundLengths: false,

  // Touches
  touchRatio: 1,
  touchAngle: 45,
  simulateTouch: true,
  shortSwipes: true,
  longSwipes: true,
  longSwipesRatio: 0.5,
  longSwipesMs: 300,
  followFinger: true,
  allowTouchMove: true,
  threshold: 0,
  touchMoveStopPropagation: true,
  touchReleaseOnEdges: false,

  // Unique Navigation Elements
  uniqueNavElements: true,

  // Resistance
  resistance: true,
  resistanceRatio: 0.85,

  // Progress
  watchSlidesProgress: false,
  watchSlidesVisibility: false,

  // Cursor
  grabCursor: false,

  // Clicks
  preventClicks: true,
  preventClicksPropagation: true,
  slideToClickedSlide: false,

  // Images
  preloadImages: true,
  updateOnImagesReady: true,

  // loop
  loop: false,
  loopAdditionalSlides: 0,
  loopedSlides: null,
  loopFillGroupWithBlank: false,

  // Swiping/no swiping
  allowSlidePrev: true,
  allowSlideNext: true,
  swipeHandler: null, // '.swipe-handler',
  noSwiping: true,
  noSwipingClass: 'swiper-no-swiping',
  noSwipingSelector: null,

  // Passive Listeners
  passiveListeners: true,

  // NS
  containerModifierClass: 'swiper-container-', // NEW
  slideClass: 'swiper-slide',
  slideBlankClass: 'swiper-slide-invisible-blank',
  slideActiveClass: 'swiper-slide-active',
  slideDuplicateActiveClass: 'swiper-slide-duplicate-active',
  slideVisibleClass: 'swiper-slide-visible',
  slideDuplicateClass: 'swiper-slide-duplicate',
  slideNextClass: 'swiper-slide-next',
  slideDuplicateNextClass: 'swiper-slide-duplicate-next',
  slidePrevClass: 'swiper-slide-prev',
  slideDuplicatePrevClass: 'swiper-slide-duplicate-prev',
  wrapperClass: 'swiper-wrapper',

  // Callbacks
  runCallbacksOnInit: true,
};

const prototypes = {
  update,
  translate,
  transition,
  slide,
  loop,
  grabCursor,
  manipulation,
  events,
  breakpoints,
  checkOverflow: checkOverflow$1,
  classes,
  images,
};

const extendedDefaults = {};

class Swiper extends Framework7Class {
  constructor(...args) {
    let el;
    let params;
    if (args.length === 1 && args[0].constructor && args[0].constructor === Object) {
      params = args[0];
    } else {
      [el, params] = args;
    }
    if (!params) params = {};

    params = Utils.extend({}, params);
    if (el && !params.el) params.el = el;

    super(params);

    Object.keys(prototypes).forEach((prototypeGroup) => {
      Object.keys(prototypes[prototypeGroup]).forEach((protoMethod) => {
        if (!Swiper.prototype[protoMethod]) {
          Swiper.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];
        }
      });
    });

    // Swiper Instance
    const swiper = this;
    if (typeof swiper.modules === 'undefined') {
      swiper.modules = {};
    }
    Object.keys(swiper.modules).forEach((moduleName) => {
      const module = swiper.modules[moduleName];
      if (module.params) {
        const moduleParamName = Object.keys(module.params)[0];
        const moduleParams = module.params[moduleParamName];
        if (typeof moduleParams !== 'object') return;
        if (!(moduleParamName in params && 'enabled' in moduleParams)) return;
        if (params[moduleParamName] === true) {
          params[moduleParamName] = { enabled: true };
        }
        if (
          typeof params[moduleParamName] === 'object' &&
          !('enabled' in params[moduleParamName])
        ) {
          params[moduleParamName].enabled = true;
        }
        if (!params[moduleParamName]) params[moduleParamName] = { enabled: false };
      }
    });

    // Extend defaults with modules params
    const swiperParams = Utils.extend({}, defaults);
    swiper.useModulesParams(swiperParams);

    // Extend defaults with passed params
    swiper.params = Utils.extend({}, swiperParams, extendedDefaults, params);
    swiper.originalParams = Utils.extend({}, swiper.params);
    swiper.passedParams = Utils.extend({}, params);

    // Save Dom lib
    swiper.$ = __WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */];

    // Find el
    const $el = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(swiper.params.el);
    el = $el[0];

    if (!el) {
      return undefined;
    }

    if ($el.length > 1) {
      const swipers = [];
      $el.each((index, containerEl) => {
        const newParams = Utils.extend({}, params, { el: containerEl });
        swipers.push(new Swiper(newParams));
      });
      return swipers;
    }

    el.swiper = swiper;
    $el.data('swiper', swiper);

    // Find Wrapper
    const $wrapperEl = $el.children(`.${swiper.params.wrapperClass}`);

    // Extend Swiper
    Utils.extend(swiper, {
      $el,
      el,
      $wrapperEl,
      wrapperEl: $wrapperEl[0],

      // Classes
      classNames: [],

      // Slides
      slides: Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(),
      slidesGrid: [],
      snapGrid: [],
      slidesSizesGrid: [],

      // isDirection
      isHorizontal() {
        return swiper.params.direction === 'horizontal';
      },
      isVertical() {
        return swiper.params.direction === 'vertical';
      },
      // RTL
      rtl: (el.dir.toLowerCase() === 'rtl' || $el.css('direction') === 'rtl'),
      rtlTranslate: swiper.params.direction === 'horizontal' && (el.dir.toLowerCase() === 'rtl' || $el.css('direction') === 'rtl'),
      wrongRTL: $wrapperEl.css('display') === '-webkit-box',

      // Indexes
      activeIndex: 0,
      realIndex: 0,

      //
      isBeginning: true,
      isEnd: false,

      // Props
      translate: 0,
      progress: 0,
      velocity: 0,
      animating: false,

      // Locks
      allowSlideNext: swiper.params.allowSlideNext,
      allowSlidePrev: swiper.params.allowSlidePrev,

      // Touch Events
      touchEvents: (function touchEvents() {
        const touch = ['touchstart', 'touchmove', 'touchend'];
        let desktop = ['mousedown', 'mousemove', 'mouseup'];
        if (Support.pointerEvents) {
          desktop = ['pointerdown', 'pointermove', 'pointerup'];
        } else if (Support.prefixedPointerEvents) {
          desktop = ['MSPointerDown', 'MSPointerMove', 'MSPointerUp'];
        }
        swiper.touchEventsTouch = {
          start: touch[0],
          move: touch[1],
          end: touch[2],
        };
        swiper.touchEventsDesktop = {
          start: desktop[0],
          move: desktop[1],
          end: desktop[2],
        };
        return Support.touch || !swiper.params.simulateTouch ? swiper.touchEventsTouch : swiper.touchEventsDesktop;
      }()),
      touchEventsData: {
        isTouched: undefined,
        isMoved: undefined,
        allowTouchCallbacks: undefined,
        touchStartTime: undefined,
        isScrolling: undefined,
        currentTranslate: undefined,
        startTranslate: undefined,
        allowThresholdMove: undefined,
        // Form elements to match
        formElements: 'input, select, option, textarea, button, video',
        // Last click time
        lastClickTime: Utils.now(),
        clickTimeout: undefined,
        // Velocities
        velocities: [],
        allowMomentumBounce: undefined,
        isTouchEvent: undefined,
        startMoving: undefined,
      },

      // Clicks
      allowClick: true,

      // Touches
      allowTouchMove: swiper.params.allowTouchMove,

      touches: {
        startX: 0,
        startY: 0,
        currentX: 0,
        currentY: 0,
        diff: 0,
      },

      // Images
      imagesToLoad: [],
      imagesLoaded: 0,

    });

    // Install Modules
    swiper.useModules();

    // Init
    if (swiper.params.init) {
      swiper.init();
    }

    // Return app instance
    return swiper;
  }
  slidesPerViewDynamic() {
    const swiper = this;
    const {
      params, slides, slidesGrid, size: swiperSize, activeIndex,
    } = swiper;
    let spv = 1;
    if (params.centeredSlides) {
      let slideSize = slides[activeIndex].swiperSlideSize;
      let breakLoop;
      for (let i = activeIndex + 1; i < slides.length; i += 1) {
        if (slides[i] && !breakLoop) {
          slideSize += slides[i].swiperSlideSize;
          spv += 1;
          if (slideSize > swiperSize) breakLoop = true;
        }
      }
      for (let i = activeIndex - 1; i >= 0; i -= 1) {
        if (slides[i] && !breakLoop) {
          slideSize += slides[i].swiperSlideSize;
          spv += 1;
          if (slideSize > swiperSize) breakLoop = true;
        }
      }
    } else {
      for (let i = activeIndex + 1; i < slides.length; i += 1) {
        if (slidesGrid[i] - slidesGrid[activeIndex] < swiperSize) {
          spv += 1;
        }
      }
    }
    return spv;
  }
  update() {
    const swiper = this;
    if (!swiper || swiper.destroyed) return;
    const { snapGrid, params } = swiper;
    // Breakpoints
    if (params.breakpoints) {
      swiper.setBreakpoint();
    }
    swiper.updateSize();
    swiper.updateSlides();
    swiper.updateProgress();
    swiper.updateSlidesClasses();

    function setTranslate() {
      const translateValue = swiper.rtlTranslate ? swiper.translate * -1 : swiper.translate;
      const newTranslate = Math.min(Math.max(translateValue, swiper.maxTranslate()), swiper.minTranslate());
      swiper.setTranslate(newTranslate);
      swiper.updateActiveIndex();
      swiper.updateSlidesClasses();
    }
    let translated;
    if (swiper.params.freeMode) {
      setTranslate();
      if (swiper.params.autoHeight) {
        swiper.updateAutoHeight();
      }
    } else {
      if ((swiper.params.slidesPerView === 'auto' || swiper.params.slidesPerView > 1) && swiper.isEnd && !swiper.params.centeredSlides) {
        translated = swiper.slideTo(swiper.slides.length - 1, 0, false, true);
      } else {
        translated = swiper.slideTo(swiper.activeIndex, 0, false, true);
      }
      if (!translated) {
        setTranslate();
      }
    }
    if (params.watchOverflow && snapGrid !== swiper.snapGrid) {
      swiper.checkOverflow();
    }
    swiper.emit('update');
  }
  init() {
    const swiper = this;
    if (swiper.initialized) return;

    swiper.emit('beforeInit');

    // Set breakpoint
    if (swiper.params.breakpoints) {
      swiper.setBreakpoint();
    }

    // Add Classes
    swiper.addClasses();

    // Create loop
    if (swiper.params.loop) {
      swiper.loopCreate();
    }

    // Update size
    swiper.updateSize();

    // Update slides
    swiper.updateSlides();

    if (swiper.params.watchOverflow) {
      swiper.checkOverflow();
    }

    // Set Grab Cursor
    if (swiper.params.grabCursor) {
      swiper.setGrabCursor();
    }

    if (swiper.params.preloadImages) {
      swiper.preloadImages();
    }

    // Slide To Initial Slide
    if (swiper.params.loop) {
      swiper.slideTo(swiper.params.initialSlide + swiper.loopedSlides, 0, swiper.params.runCallbacksOnInit);
    } else {
      swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit);
    }

    // Attach events
    swiper.attachEvents();

    // Init Flag
    swiper.initialized = true;

    // Emit
    swiper.emit('init');
  }
  destroy(deleteInstance = true, cleanStyles = true) {
    const swiper = this;
    const {
      params, $el, $wrapperEl, slides,
    } = swiper;

    if (typeof swiper.params === 'undefined' || swiper.destroyed) {
      return null;
    }

    swiper.emit('beforeDestroy');

    // Init Flag
    swiper.initialized = false;

    // Detach events
    swiper.detachEvents();

    // Destroy loop
    if (params.loop) {
      swiper.loopDestroy();
    }

    // Cleanup styles
    if (cleanStyles) {
      swiper.removeClasses();
      $el.removeAttr('style');
      $wrapperEl.removeAttr('style');
      if (slides && slides.length) {
        slides
          .removeClass([
            params.slideVisibleClass,
            params.slideActiveClass,
            params.slideNextClass,
            params.slidePrevClass,
          ].join(' '))
          .removeAttr('style')
          .removeAttr('data-swiper-slide-index')
          .removeAttr('data-swiper-column')
          .removeAttr('data-swiper-row');
      }
    }

    swiper.emit('destroy');

    // Detach emitter events
    Object.keys(swiper.eventsListeners).forEach((eventName) => {
      swiper.off(eventName);
    });

    if (deleteInstance !== false) {
      swiper.$el[0].swiper = null;
      swiper.$el.data('swiper', null);
      Utils.deleteProps(swiper);
    }
    swiper.destroyed = true;

    return null;
  }
  static extendDefaults(newDefaults) {
    Utils.extend(extendedDefaults, newDefaults);
  }
  static get extendedDefaults() {
    return extendedDefaults;
  }
  static get defaults() {
    return defaults;
  }
  static get Class() {
    return Framework7Class;
  }
  static get $() {
    return __WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */];
  }
}

var Device$1 = {
  name: 'device',
  proto: {
    device: Device,
  },
  static: {
    device: Device,
  },
};

var Support$1 = {
  name: 'support',
  proto: {
    support: Support,
  },
  static: {
    support: Support,
  },
};

var Browser$1 = {
  name: 'browser',
  proto: {
    browser: Browser,
  },
  static: {
    browser: Browser,
  },
};

var Resize = {
  name: 'resize',
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      resize: {
        resizeHandler() {
          if (!swiper || swiper.destroyed || !swiper.initialized) return;
          swiper.emit('beforeResize');
          swiper.emit('resize');
        },
        orientationChangeHandler() {
          if (!swiper || swiper.destroyed || !swiper.initialized) return;
          swiper.emit('orientationchange');
        },
      },
    });
  },
  on: {
    init() {
      const swiper = this;
      // Emit resize
      __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].addEventListener('resize', swiper.resize.resizeHandler);

      // Emit orientationchange
      __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].addEventListener('orientationchange', swiper.resize.orientationChangeHandler);
    },
    destroy() {
      const swiper = this;
      __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].removeEventListener('resize', swiper.resize.resizeHandler);
      __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].removeEventListener('orientationchange', swiper.resize.orientationChangeHandler);
    },
  },
};

const Observer = {
  func: __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].MutationObserver || __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].WebkitMutationObserver,
  attach(target, options = {}) {
    const swiper = this;

    const ObserverFunc = Observer.func;
    const observer = new ObserverFunc((mutations) => {
      mutations.forEach((mutation) => {
        swiper.emit('observerUpdate', mutation);
      });
    });

    observer.observe(target, {
      attributes: typeof options.attributes === 'undefined' ? true : options.attributes,
      childList: typeof options.childList === 'undefined' ? true : options.childList,
      characterData: typeof options.characterData === 'undefined' ? true : options.characterData,
    });

    swiper.observer.observers.push(observer);
  },
  init() {
    const swiper = this;
    if (!Support.observer || !swiper.params.observer) return;
    if (swiper.params.observeParents) {
      const containerParents = swiper.$el.parents();
      for (let i = 0; i < containerParents.length; i += 1) {
        swiper.observer.attach(containerParents[i]);
      }
    }
    // Observe container
    swiper.observer.attach(swiper.$el[0], { childList: false });

    // Observe wrapper
    swiper.observer.attach(swiper.$wrapperEl[0], { attributes: false });
  },
  destroy() {
    const swiper = this;
    swiper.observer.observers.forEach((observer) => {
      observer.disconnect();
    });
    swiper.observer.observers = [];
  },
};

var Observer$1 = {
  name: 'observer',
  params: {
    observer: false,
    observeParents: false,
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      observer: {
        init: Observer.init.bind(swiper),
        attach: Observer.attach.bind(swiper),
        destroy: Observer.destroy.bind(swiper),
        observers: [],
      },
    });
  },
  on: {
    init() {
      const swiper = this;
      swiper.observer.init();
    },
    destroy() {
      const swiper = this;
      swiper.observer.destroy();
    },
  },
};

const Virtual = {
  update(force) {
    const swiper = this;
    const { slidesPerView, slidesPerGroup, centeredSlides } = swiper.params;
    const {
      from: previousFrom,
      to: previousTo,
      slides,
      slidesGrid: previousSlidesGrid,
      renderSlide,
      offset: previousOffset,
    } = swiper.virtual;
    swiper.updateActiveIndex();
    const activeIndex = swiper.activeIndex || 0;

    let offsetProp;
    if (swiper.rtlTranslate) offsetProp = 'right';
    else offsetProp = swiper.isHorizontal() ? 'left' : 'top';

    let slidesAfter;
    let slidesBefore;
    if (centeredSlides) {
      slidesAfter = Math.floor(slidesPerView / 2) + slidesPerGroup;
      slidesBefore = Math.floor(slidesPerView / 2) + slidesPerGroup;
    } else {
      slidesAfter = slidesPerView + (slidesPerGroup - 1);
      slidesBefore = slidesPerGroup;
    }
    const from = Math.max((activeIndex || 0) - slidesBefore, 0);
    const to = Math.min((activeIndex || 0) + slidesAfter, slides.length - 1);
    const offset = (swiper.slidesGrid[from] || 0) - (swiper.slidesGrid[0] || 0);

    Utils.extend(swiper.virtual, {
      from,
      to,
      offset,
      slidesGrid: swiper.slidesGrid,
    });

    function onRendered() {
      swiper.updateSlides();
      swiper.updateProgress();
      swiper.updateSlidesClasses();
      if (swiper.lazy && swiper.params.lazy.enabled) {
        swiper.lazy.load();
      }
    }

    if (previousFrom === from && previousTo === to && !force) {
      if (swiper.slidesGrid !== previousSlidesGrid && offset !== previousOffset) {
        swiper.slides.css(offsetProp, `${offset}px`);
      }
      swiper.updateProgress();
      return;
    }
    if (swiper.params.virtual.renderExternal) {
      swiper.params.virtual.renderExternal.call(swiper, {
        offset,
        from,
        to,
        slides: (function getSlides() {
          const slidesToRender = [];
          for (let i = from; i <= to; i += 1) {
            slidesToRender.push(slides[i]);
          }
          return slidesToRender;
        }()),
      });
      onRendered();
      return;
    }
    const prependIndexes = [];
    const appendIndexes = [];
    if (force) {
      swiper.$wrapperEl.find(`.${swiper.params.slideClass}`).remove();
    } else {
      for (let i = previousFrom; i <= previousTo; i += 1) {
        if (i < from || i > to) {
          swiper.$wrapperEl.find(`.${swiper.params.slideClass}[data-swiper-slide-index="${i}"]`).remove();
        }
      }
    }
    for (let i = 0; i < slides.length; i += 1) {
      if (i >= from && i <= to) {
        if (typeof previousTo === 'undefined' || force) {
          appendIndexes.push(i);
        } else {
          if (i > previousTo) appendIndexes.push(i);
          if (i < previousFrom) prependIndexes.push(i);
        }
      }
    }
    appendIndexes.forEach((index) => {
      swiper.$wrapperEl.append(renderSlide(slides[index], index));
    });
    prependIndexes.sort((a, b) => a < b).forEach((index) => {
      swiper.$wrapperEl.prepend(renderSlide(slides[index], index));
    });
    swiper.$wrapperEl.children('.swiper-slide').css(offsetProp, `${offset}px`);
    onRendered();
  },
  renderSlide(slide, index) {
    const swiper = this;
    const params = swiper.params.virtual;
    if (params.cache && swiper.virtual.cache[index]) {
      return swiper.virtual.cache[index];
    }
    const $slideEl = params.renderSlide
      ? Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(params.renderSlide.call(swiper, slide, index))
      : Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(`<div class="${swiper.params.slideClass}" data-swiper-slide-index="${index}">${slide}</div>`);
    if (!$slideEl.attr('data-swiper-slide-index')) $slideEl.attr('data-swiper-slide-index', index);
    if (params.cache) swiper.virtual.cache[index] = $slideEl;
    return $slideEl;
  },
  appendSlide(slide) {
    const swiper = this;
    swiper.virtual.slides.push(slide);
    swiper.virtual.update(true);
  },
  prependSlide(slide) {
    const swiper = this;
    swiper.virtual.slides.unshift(slide);
    if (swiper.params.virtual.cache) {
      const cache = swiper.virtual.cache;
      const newCache = {};
      Object.keys(cache).forEach((cachedIndex) => {
        newCache[cachedIndex + 1] = cache[cachedIndex];
      });
      swiper.virtual.cache = newCache;
    }
    swiper.virtual.update(true);
    swiper.slideNext(0);
  },
};

var Virtual$1 = {
  name: 'virtual',
  params: {
    virtual: {
      enabled: false,
      slides: [],
      cache: true,
      renderSlide: null,
      renderExternal: null,
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      virtual: {
        update: Virtual.update.bind(swiper),
        appendSlide: Virtual.appendSlide.bind(swiper),
        prependSlide: Virtual.prependSlide.bind(swiper),
        renderSlide: Virtual.renderSlide.bind(swiper),
        slides: swiper.params.virtual.slides,
        cache: {},
      },
    });
  },
  on: {
    beforeInit() {
      const swiper = this;
      if (!swiper.params.virtual.enabled) return;
      swiper.classNames.push(`${swiper.params.containerModifierClass}virtual`);
      const overwriteParams = {
        watchSlidesProgress: true,
      };
      Utils.extend(swiper.params, overwriteParams);
      Utils.extend(swiper.originalParams, overwriteParams);

      swiper.virtual.update();
    },
    setTranslate() {
      const swiper = this;
      if (!swiper.params.virtual.enabled) return;
      swiper.virtual.update();
    },
  },
};

const Navigation = {
  update() {
    // Update Navigation Buttons
    const swiper = this;
    const params = swiper.params.navigation;

    if (swiper.params.loop) return;
    const { $nextEl, $prevEl } = swiper.navigation;

    if ($prevEl && $prevEl.length > 0) {
      if (swiper.isBeginning) {
        $prevEl.addClass(params.disabledClass);
      } else {
        $prevEl.removeClass(params.disabledClass);
      }
      $prevEl[swiper.params.watchOverflow && swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);
    }
    if ($nextEl && $nextEl.length > 0) {
      if (swiper.isEnd) {
        $nextEl.addClass(params.disabledClass);
      } else {
        $nextEl.removeClass(params.disabledClass);
      }
      $nextEl[swiper.params.watchOverflow && swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);
    }
  },
  init() {
    const swiper = this;
    const params = swiper.params.navigation;
    if (!(params.nextEl || params.prevEl)) return;

    let $nextEl;
    let $prevEl;
    if (params.nextEl) {
      $nextEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(params.nextEl);
      if (
        swiper.params.uniqueNavElements &&
        typeof params.nextEl === 'string' &&
        $nextEl.length > 1 &&
        swiper.$el.find(params.nextEl).length === 1
      ) {
        $nextEl = swiper.$el.find(params.nextEl);
      }
    }
    if (params.prevEl) {
      $prevEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(params.prevEl);
      if (
        swiper.params.uniqueNavElements &&
        typeof params.prevEl === 'string' &&
        $prevEl.length > 1 &&
        swiper.$el.find(params.prevEl).length === 1
      ) {
        $prevEl = swiper.$el.find(params.prevEl);
      }
    }

    if ($nextEl && $nextEl.length > 0) {
      $nextEl.on('click', (e) => {
        e.preventDefault();
        if (swiper.isEnd && !swiper.params.loop) return;
        swiper.slideNext();
      });
    }
    if ($prevEl && $prevEl.length > 0) {
      $prevEl.on('click', (e) => {
        e.preventDefault();
        if (swiper.isBeginning && !swiper.params.loop) return;
        swiper.slidePrev();
      });
    }

    Utils.extend(swiper.navigation, {
      $nextEl,
      nextEl: $nextEl && $nextEl[0],
      $prevEl,
      prevEl: $prevEl && $prevEl[0],
    });
  },
  destroy() {
    const swiper = this;
    const { $nextEl, $prevEl } = swiper.navigation;
    if ($nextEl && $nextEl.length) {
      $nextEl.off('click');
      $nextEl.removeClass(swiper.params.navigation.disabledClass);
    }
    if ($prevEl && $prevEl.length) {
      $prevEl.off('click');
      $prevEl.removeClass(swiper.params.navigation.disabledClass);
    }
  },
};

var Navigation$1 = {
  name: 'navigation',
  params: {
    navigation: {
      nextEl: null,
      prevEl: null,

      hideOnClick: false,
      disabledClass: 'swiper-button-disabled',
      hiddenClass: 'swiper-button-hidden',
      lockClass: 'swiper-button-lock',
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      navigation: {
        init: Navigation.init.bind(swiper),
        update: Navigation.update.bind(swiper),
        destroy: Navigation.destroy.bind(swiper),
      },
    });
  },
  on: {
    init() {
      const swiper = this;
      swiper.navigation.init();
      swiper.navigation.update();
    },
    toEdge() {
      const swiper = this;
      swiper.navigation.update();
    },
    fromEdge() {
      const swiper = this;
      swiper.navigation.update();
    },
    destroy() {
      const swiper = this;
      swiper.navigation.destroy();
    },
    click(e) {
      const swiper = this;
      const { $nextEl, $prevEl } = swiper.navigation;
      if (
        swiper.params.navigation.hideOnClick &&
        !Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(e.target).is($prevEl) &&
        !Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(e.target).is($nextEl)
      ) {
        if ($nextEl) $nextEl.toggleClass(swiper.params.navigation.hiddenClass);
        if ($prevEl) $prevEl.toggleClass(swiper.params.navigation.hiddenClass);
      }
    },
  },
};

const Pagination = {
  update() {
    // Render || Update Pagination bullets/items
    const swiper = this;
    const rtl = swiper.rtl;
    const params = swiper.params.pagination;
    if (!params.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0) return;
    const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;
    const $el = swiper.pagination.$el;
    // Current/Total
    let current;
    const total = swiper.params.loop ? Math.ceil((slidesLength - (swiper.loopedSlides * 2)) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;
    if (swiper.params.loop) {
      current = Math.ceil((swiper.activeIndex - swiper.loopedSlides) / swiper.params.slidesPerGroup);
      if (current > slidesLength - 1 - (swiper.loopedSlides * 2)) {
        current -= (slidesLength - (swiper.loopedSlides * 2));
      }
      if (current > total - 1) current -= total;
      if (current < 0 && swiper.params.paginationType !== 'bullets') current = total + current;
    } else if (typeof swiper.snapIndex !== 'undefined') {
      current = swiper.snapIndex;
    } else {
      current = swiper.activeIndex || 0;
    }
    // Types
    if (params.type === 'bullets' && swiper.pagination.bullets && swiper.pagination.bullets.length > 0) {
      const bullets = swiper.pagination.bullets;
      let firstIndex;
      let lastIndex;
      let midIndex;
      if (params.dynamicBullets) {
        swiper.pagination.bulletSize = bullets.eq(0)[swiper.isHorizontal() ? 'outerWidth' : 'outerHeight'](true);
        $el.css(swiper.isHorizontal() ? 'width' : 'height', `${swiper.pagination.bulletSize * (params.dynamicMainBullets + 4)}px`);
        if (params.dynamicMainBullets > 1 && swiper.previousIndex !== undefined) {
          swiper.pagination.dynamicBulletIndex += (current - swiper.previousIndex);
          if (swiper.pagination.dynamicBulletIndex > (params.dynamicMainBullets - 1)) {
            swiper.pagination.dynamicBulletIndex = params.dynamicMainBullets - 1;
          } else if (swiper.pagination.dynamicBulletIndex < 0) {
            swiper.pagination.dynamicBulletIndex = 0;
          }
        }
        firstIndex = current - swiper.pagination.dynamicBulletIndex;
        lastIndex = firstIndex + (Math.min(bullets.length, params.dynamicMainBullets) - 1);
        midIndex = (lastIndex + firstIndex) / 2;
      }
      bullets.removeClass(`${params.bulletActiveClass} ${params.bulletActiveClass}-next ${params.bulletActiveClass}-next-next ${params.bulletActiveClass}-prev ${params.bulletActiveClass}-prev-prev ${params.bulletActiveClass}-main`);
      if ($el.length > 1) {
        bullets.each((index, bullet) => {
          const $bullet = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(bullet);
          const bulletIndex = $bullet.index();
          if (bulletIndex === current) {
            $bullet.addClass(params.bulletActiveClass);
          }
          if (params.dynamicBullets) {
            if (bulletIndex >= firstIndex && bulletIndex <= lastIndex) {
              $bullet.addClass(`${params.bulletActiveClass}-main`);
            }
            if (bulletIndex === firstIndex) {
              $bullet
                .prev()
                .addClass(`${params.bulletActiveClass}-prev`)
                .prev()
                .addClass(`${params.bulletActiveClass}-prev-prev`);
            }
            if (bulletIndex === lastIndex) {
              $bullet
                .next()
                .addClass(`${params.bulletActiveClass}-next`)
                .next()
                .addClass(`${params.bulletActiveClass}-next-next`);
            }
          }
        });
      } else {
        const $bullet = bullets.eq(current);
        $bullet.addClass(params.bulletActiveClass);
        if (params.dynamicBullets) {
          const $firstDisplayedBullet = bullets.eq(firstIndex);
          const $lastDisplayedBullet = bullets.eq(lastIndex);
          for (let i = firstIndex; i <= lastIndex; i += 1) {
            bullets.eq(i).addClass(`${params.bulletActiveClass}-main`);
          }
          $firstDisplayedBullet
            .prev()
            .addClass(`${params.bulletActiveClass}-prev`)
            .prev()
            .addClass(`${params.bulletActiveClass}-prev-prev`);
          $lastDisplayedBullet
            .next()
            .addClass(`${params.bulletActiveClass}-next`)
            .next()
            .addClass(`${params.bulletActiveClass}-next-next`);
        }
      }
      if (params.dynamicBullets) {
        const dynamicBulletsLength = Math.min(bullets.length, params.dynamicMainBullets + 4);
        const bulletsOffset = (((swiper.pagination.bulletSize * dynamicBulletsLength) - (swiper.pagination.bulletSize)) / 2) - (midIndex * swiper.pagination.bulletSize);
        const offsetProp = rtl ? 'right' : 'left';
        bullets.css(swiper.isHorizontal() ? offsetProp : 'top', `${bulletsOffset}px`);
      }
    }
    if (params.type === 'fraction') {
      $el.find(`.${params.currentClass}`).text(current + 1);
      $el.find(`.${params.totalClass}`).text(total);
    }
    if (params.type === 'progressbar') {
      let progressbarDirection;
      if (params.progressbarOpposite) {
        progressbarDirection = swiper.isHorizontal() ? 'vertical' : 'horizontal';
      } else {
        progressbarDirection = swiper.isHorizontal() ? 'horizontal' : 'vertical';
      }
      const scale = (current + 1) / total;
      let scaleX = 1;
      let scaleY = 1;
      if (progressbarDirection === 'horizontal') {
        scaleX = scale;
      } else {
        scaleY = scale;
      }
      $el.find(`.${params.progressbarFillClass}`).transform(`translate3d(0,0,0) scaleX(${scaleX}) scaleY(${scaleY})`).transition(swiper.params.speed);
    }
    if (params.type === 'custom' && params.renderCustom) {
      $el.html(params.renderCustom(swiper, current + 1, total));
      swiper.emit('paginationRender', swiper, $el[0]);
    } else {
      swiper.emit('paginationUpdate', swiper, $el[0]);
    }
    $el[swiper.params.watchOverflow && swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);
  },
  render() {
    // Render Container
    const swiper = this;
    const params = swiper.params.pagination;
    if (!params.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0) return;
    const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;

    const $el = swiper.pagination.$el;
    let paginationHTML = '';
    if (params.type === 'bullets') {
      const numberOfBullets = swiper.params.loop ? Math.ceil((slidesLength - (swiper.loopedSlides * 2)) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;
      for (let i = 0; i < numberOfBullets; i += 1) {
        if (params.renderBullet) {
          paginationHTML += params.renderBullet.call(swiper, i, params.bulletClass);
        } else {
          paginationHTML += `<${params.bulletElement} class="${params.bulletClass}"></${params.bulletElement}>`;
        }
      }
      $el.html(paginationHTML);
      swiper.pagination.bullets = $el.find(`.${params.bulletClass}`);
    }
    if (params.type === 'fraction') {
      if (params.renderFraction) {
        paginationHTML = params.renderFraction.call(swiper, params.currentClass, params.totalClass);
      } else {
        paginationHTML =
        `<span class="${params.currentClass}"></span>` +
        ' / ' +
        `<span class="${params.totalClass}"></span>`;
      }
      $el.html(paginationHTML);
    }
    if (params.type === 'progressbar') {
      if (params.renderProgressbar) {
        paginationHTML = params.renderProgressbar.call(swiper, params.progressbarFillClass);
      } else {
        paginationHTML = `<span class="${params.progressbarFillClass}"></span>`;
      }
      $el.html(paginationHTML);
    }
    if (params.type !== 'custom') {
      swiper.emit('paginationRender', swiper.pagination.$el[0]);
    }
  },
  init() {
    const swiper = this;
    const params = swiper.params.pagination;
    if (!params.el) return;

    let $el = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(params.el);
    if ($el.length === 0) return;

    if (
      swiper.params.uniqueNavElements &&
      typeof params.el === 'string' &&
      $el.length > 1 &&
      swiper.$el.find(params.el).length === 1
    ) {
      $el = swiper.$el.find(params.el);
    }

    if (params.type === 'bullets' && params.clickable) {
      $el.addClass(params.clickableClass);
    }

    $el.addClass(params.modifierClass + params.type);

    if (params.type === 'bullets' && params.dynamicBullets) {
      $el.addClass(`${params.modifierClass}${params.type}-dynamic`);
      swiper.pagination.dynamicBulletIndex = 0;
      if (params.dynamicMainBullets < 1) {
        params.dynamicMainBullets = 1;
      }
    }
    if (params.type === 'progressbar' && params.progressbarOpposite) {
      $el.addClass(params.progressbarOppositeClass);
    }

    if (params.clickable) {
      $el.on('click', `.${params.bulletClass}`, function onClick(e) {
        e.preventDefault();
        let index = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(this).index() * swiper.params.slidesPerGroup;
        if (swiper.params.loop) index += swiper.loopedSlides;
        swiper.slideTo(index);
      });
    }

    Utils.extend(swiper.pagination, {
      $el,
      el: $el[0],
    });
  },
  destroy() {
    const swiper = this;
    const params = swiper.params.pagination;
    if (!params.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0) return;
    const $el = swiper.pagination.$el;

    $el.removeClass(params.hiddenClass);
    $el.removeClass(params.modifierClass + params.type);
    if (swiper.pagination.bullets) swiper.pagination.bullets.removeClass(params.bulletActiveClass);
    if (params.clickable) {
      $el.off('click', `.${params.bulletClass}`);
    }
  },
};

var Pagination$1 = {
  name: 'pagination',
  params: {
    pagination: {
      el: null,
      bulletElement: 'span',
      clickable: false,
      hideOnClick: false,
      renderBullet: null,
      renderProgressbar: null,
      renderFraction: null,
      renderCustom: null,
      progressbarOpposite: false,
      type: 'bullets', // 'bullets' or 'progressbar' or 'fraction' or 'custom'
      dynamicBullets: false,
      dynamicMainBullets: 1,
      bulletClass: 'swiper-pagination-bullet',
      bulletActiveClass: 'swiper-pagination-bullet-active',
      modifierClass: 'swiper-pagination-', // NEW
      currentClass: 'swiper-pagination-current',
      totalClass: 'swiper-pagination-total',
      hiddenClass: 'swiper-pagination-hidden',
      progressbarFillClass: 'swiper-pagination-progressbar-fill',
      progressbarOppositeClass: 'swiper-pagination-progressbar-opposite',
      clickableClass: 'swiper-pagination-clickable', // NEW
      lockClass: 'swiper-pagination-lock',
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      pagination: {
        init: Pagination.init.bind(swiper),
        render: Pagination.render.bind(swiper),
        update: Pagination.update.bind(swiper),
        destroy: Pagination.destroy.bind(swiper),
        dynamicBulletIndex: 0,
      },
    });
  },
  on: {
    init() {
      const swiper = this;
      swiper.pagination.init();
      swiper.pagination.render();
      swiper.pagination.update();
    },
    activeIndexChange() {
      const swiper = this;
      if (swiper.params.loop) {
        swiper.pagination.update();
      } else if (typeof swiper.snapIndex === 'undefined') {
        swiper.pagination.update();
      }
    },
    snapIndexChange() {
      const swiper = this;
      if (!swiper.params.loop) {
        swiper.pagination.update();
      }
    },
    slidesLengthChange() {
      const swiper = this;
      if (swiper.params.loop) {
        swiper.pagination.render();
        swiper.pagination.update();
      }
    },
    snapGridLengthChange() {
      const swiper = this;
      if (!swiper.params.loop) {
        swiper.pagination.render();
        swiper.pagination.update();
      }
    },
    destroy() {
      const swiper = this;
      swiper.pagination.destroy();
    },
    click(e) {
      const swiper = this;
      if (
        swiper.params.pagination.el &&
        swiper.params.pagination.hideOnClick &&
        swiper.pagination.$el.length > 0 &&
        !Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(e.target).hasClass(swiper.params.pagination.bulletClass)
      ) {
        swiper.pagination.$el.toggleClass(swiper.params.pagination.hiddenClass);
      }
    },
  },
};

const Scrollbar = {
  setTranslate() {
    const swiper = this;
    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
    const { scrollbar, rtlTranslate: rtl, progress } = swiper;
    const {
      dragSize, trackSize, $dragEl, $el,
    } = scrollbar;
    const params = swiper.params.scrollbar;

    let newSize = dragSize;
    let newPos = (trackSize - dragSize) * progress;
    if (rtl) {
      newPos = -newPos;
      if (newPos > 0) {
        newSize = dragSize - newPos;
        newPos = 0;
      } else if (-newPos + dragSize > trackSize) {
        newSize = trackSize + newPos;
      }
    } else if (newPos < 0) {
      newSize = dragSize + newPos;
      newPos = 0;
    } else if (newPos + dragSize > trackSize) {
      newSize = trackSize - newPos;
    }
    if (swiper.isHorizontal()) {
      if (Support.transforms3d) {
        $dragEl.transform(`translate3d(${newPos}px, 0, 0)`);
      } else {
        $dragEl.transform(`translateX(${newPos}px)`);
      }
      $dragEl[0].style.width = `${newSize}px`;
    } else {
      if (Support.transforms3d) {
        $dragEl.transform(`translate3d(0px, ${newPos}px, 0)`);
      } else {
        $dragEl.transform(`translateY(${newPos}px)`);
      }
      $dragEl[0].style.height = `${newSize}px`;
    }
    if (params.hide) {
      clearTimeout(swiper.scrollbar.timeout);
      $el[0].style.opacity = 1;
      swiper.scrollbar.timeout = setTimeout(() => {
        $el[0].style.opacity = 0;
        $el.transition(400);
      }, 1000);
    }
  },
  setTransition(duration) {
    const swiper = this;
    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
    swiper.scrollbar.$dragEl.transition(duration);
  },
  updateSize() {
    const swiper = this;
    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;

    const { scrollbar } = swiper;
    const { $dragEl, $el } = scrollbar;

    $dragEl[0].style.width = '';
    $dragEl[0].style.height = '';
    const trackSize = swiper.isHorizontal() ? $el[0].offsetWidth : $el[0].offsetHeight;

    const divider = swiper.size / swiper.virtualSize;
    const moveDivider = divider * (trackSize / swiper.size);
    let dragSize;
    if (swiper.params.scrollbar.dragSize === 'auto') {
      dragSize = trackSize * divider;
    } else {
      dragSize = parseInt(swiper.params.scrollbar.dragSize, 10);
    }

    if (swiper.isHorizontal()) {
      $dragEl[0].style.width = `${dragSize}px`;
    } else {
      $dragEl[0].style.height = `${dragSize}px`;
    }

    if (divider >= 1) {
      $el[0].style.display = 'none';
    } else {
      $el[0].style.display = '';
    }
    if (swiper.params.scrollbarHide) {
      $el[0].style.opacity = 0;
    }
    Utils.extend(scrollbar, {
      trackSize,
      divider,
      moveDivider,
      dragSize,
    });
    scrollbar.$el[swiper.params.watchOverflow && swiper.isLocked ? 'addClass' : 'removeClass'](swiper.params.scrollbar.lockClass);
  },
  setDragPosition(e) {
    const swiper = this;
    const { scrollbar, rtlTranslate: rtl } = swiper;
    const { $el, dragSize, trackSize } = scrollbar;

    let pointerPosition;
    if (swiper.isHorizontal()) {
      pointerPosition = ((e.type === 'touchstart' || e.type === 'touchmove') ? e.targetTouches[0].pageX : e.pageX || e.clientX);
    } else {
      pointerPosition = ((e.type === 'touchstart' || e.type === 'touchmove') ? e.targetTouches[0].pageY : e.pageY || e.clientY);
    }
    let positionRatio;
    positionRatio = ((pointerPosition) - $el.offset()[swiper.isHorizontal() ? 'left' : 'top'] - (dragSize / 2)) / (trackSize - dragSize);
    positionRatio = Math.max(Math.min(positionRatio, 1), 0);
    if (rtl) {
      positionRatio = 1 - positionRatio;
    }

    const position = swiper.minTranslate() + ((swiper.maxTranslate() - swiper.minTranslate()) * positionRatio);

    swiper.updateProgress(position);
    swiper.setTranslate(position);
    swiper.updateActiveIndex();
    swiper.updateSlidesClasses();
  },
  onDragStart(e) {
    const swiper = this;
    const params = swiper.params.scrollbar;
    const { scrollbar, $wrapperEl } = swiper;
    const { $el, $dragEl } = scrollbar;
    swiper.scrollbar.isTouched = true;
    e.preventDefault();
    e.stopPropagation();

    $wrapperEl.transition(100);
    $dragEl.transition(100);
    scrollbar.setDragPosition(e);

    clearTimeout(swiper.scrollbar.dragTimeout);

    $el.transition(0);
    if (params.hide) {
      $el.css('opacity', 1);
    }
    swiper.emit('scrollbarDragStart', e);
  },
  onDragMove(e) {
    const swiper = this;
    const { scrollbar, $wrapperEl } = swiper;
    const { $el, $dragEl } = scrollbar;

    if (!swiper.scrollbar.isTouched) return;
    if (e.preventDefault) e.preventDefault();
    else e.returnValue = false;
    scrollbar.setDragPosition(e);
    $wrapperEl.transition(0);
    $el.transition(0);
    $dragEl.transition(0);
    swiper.emit('scrollbarDragMove', e);
  },
  onDragEnd(e) {
    const swiper = this;

    const params = swiper.params.scrollbar;
    const { scrollbar } = swiper;
    const { $el } = scrollbar;

    if (!swiper.scrollbar.isTouched) return;
    swiper.scrollbar.isTouched = false;
    if (params.hide) {
      clearTimeout(swiper.scrollbar.dragTimeout);
      swiper.scrollbar.dragTimeout = Utils.nextTick(() => {
        $el.css('opacity', 0);
        $el.transition(400);
      }, 1000);
    }
    swiper.emit('scrollbarDragEnd', e);
    if (params.snapOnRelease) {
      swiper.slideToClosest();
    }
  },
  enableDraggable() {
    const swiper = this;
    if (!swiper.params.scrollbar.el) return;
    const {
      scrollbar, touchEvents, touchEventsDesktop, params,
    } = swiper;
    const $el = scrollbar.$el;
    const target = $el[0];
    const activeListener = Support.passiveListener && params.passiveListener ? { passive: false, capture: false } : false;
    const passiveListener = Support.passiveListener && params.passiveListener ? { passive: true, capture: false } : false;
    if (!Support.touch && (Support.pointerEvents || Support.prefixedPointerEvents)) {
      target.addEventListener(touchEventsDesktop.start, swiper.scrollbar.onDragStart, activeListener);
      __WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */].addEventListener(touchEventsDesktop.move, swiper.scrollbar.onDragMove, activeListener);
      __WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */].addEventListener(touchEventsDesktop.end, swiper.scrollbar.onDragEnd, passiveListener);
    } else {
      if (Support.touch) {
        target.addEventListener(touchEvents.start, swiper.scrollbar.onDragStart, activeListener);
        target.addEventListener(touchEvents.move, swiper.scrollbar.onDragMove, activeListener);
        target.addEventListener(touchEvents.end, swiper.scrollbar.onDragEnd, passiveListener);
      }
      if ((params.simulateTouch && !Device.ios && !Device.android) || (params.simulateTouch && !Support.touch && Device.ios)) {
        target.addEventListener('mousedown', swiper.scrollbar.onDragStart, activeListener);
        __WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */].addEventListener('mousemove', swiper.scrollbar.onDragMove, activeListener);
        __WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */].addEventListener('mouseup', swiper.scrollbar.onDragEnd, passiveListener);
      }
    }
  },
  disableDraggable() {
    const swiper = this;
    if (!swiper.params.scrollbar.el) return;
    const {
      scrollbar, touchEvents, touchEventsDesktop, params,
    } = swiper;
    const $el = scrollbar.$el;
    const target = $el[0];
    const activeListener = Support.passiveListener && params.passiveListener ? { passive: false, capture: false } : false;
    const passiveListener = Support.passiveListener && params.passiveListener ? { passive: true, capture: false } : false;
    if (!Support.touch && (Support.pointerEvents || Support.prefixedPointerEvents)) {
      target.removeEventListener(touchEventsDesktop.start, swiper.scrollbar.onDragStart, activeListener);
      __WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */].removeEventListener(touchEventsDesktop.move, swiper.scrollbar.onDragMove, activeListener);
      __WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */].removeEventListener(touchEventsDesktop.end, swiper.scrollbar.onDragEnd, passiveListener);
    } else {
      if (Support.touch) {
        target.removeEventListener(touchEvents.start, swiper.scrollbar.onDragStart, activeListener);
        target.removeEventListener(touchEvents.move, swiper.scrollbar.onDragMove, activeListener);
        target.removeEventListener(touchEvents.end, swiper.scrollbar.onDragEnd, passiveListener);
      }
      if ((params.simulateTouch && !Device.ios && !Device.android) || (params.simulateTouch && !Support.touch && Device.ios)) {
        target.removeEventListener('mousedown', swiper.scrollbar.onDragStart, activeListener);
        __WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */].removeEventListener('mousemove', swiper.scrollbar.onDragMove, activeListener);
        __WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */].removeEventListener('mouseup', swiper.scrollbar.onDragEnd, passiveListener);
      }
    }
  },
  init() {
    const swiper = this;
    if (!swiper.params.scrollbar.el) return;
    const { scrollbar, $el: $swiperEl } = swiper;
    const params = swiper.params.scrollbar;

    let $el = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(params.el);
    if (swiper.params.uniqueNavElements && typeof params.el === 'string' && $el.length > 1 && $swiperEl.find(params.el).length === 1) {
      $el = $swiperEl.find(params.el);
    }

    let $dragEl = $el.find(`.${swiper.params.scrollbar.dragClass}`);
    if ($dragEl.length === 0) {
      $dragEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(`<div class="${swiper.params.scrollbar.dragClass}"></div>`);
      $el.append($dragEl);
    }

    Utils.extend(scrollbar, {
      $el,
      el: $el[0],
      $dragEl,
      dragEl: $dragEl[0],
    });

    if (params.draggable) {
      scrollbar.enableDraggable();
    }
  },
  destroy() {
    const swiper = this;
    swiper.scrollbar.disableDraggable();
  },
};

var Scrollbar$1 = {
  name: 'scrollbar',
  params: {
    scrollbar: {
      el: null,
      dragSize: 'auto',
      hide: false,
      draggable: false,
      snapOnRelease: true,
      lockClass: 'swiper-scrollbar-lock',
      dragClass: 'swiper-scrollbar-drag',
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      scrollbar: {
        init: Scrollbar.init.bind(swiper),
        destroy: Scrollbar.destroy.bind(swiper),
        updateSize: Scrollbar.updateSize.bind(swiper),
        setTranslate: Scrollbar.setTranslate.bind(swiper),
        setTransition: Scrollbar.setTransition.bind(swiper),
        enableDraggable: Scrollbar.enableDraggable.bind(swiper),
        disableDraggable: Scrollbar.disableDraggable.bind(swiper),
        setDragPosition: Scrollbar.setDragPosition.bind(swiper),
        onDragStart: Scrollbar.onDragStart.bind(swiper),
        onDragMove: Scrollbar.onDragMove.bind(swiper),
        onDragEnd: Scrollbar.onDragEnd.bind(swiper),
        isTouched: false,
        timeout: null,
        dragTimeout: null,
      },
    });
  },
  on: {
    init() {
      const swiper = this;
      swiper.scrollbar.init();
      swiper.scrollbar.updateSize();
      swiper.scrollbar.setTranslate();
    },
    update() {
      const swiper = this;
      swiper.scrollbar.updateSize();
    },
    resize() {
      const swiper = this;
      swiper.scrollbar.updateSize();
    },
    observerUpdate() {
      const swiper = this;
      swiper.scrollbar.updateSize();
    },
    setTranslate() {
      const swiper = this;
      swiper.scrollbar.setTranslate();
    },
    setTransition(duration) {
      const swiper = this;
      swiper.scrollbar.setTransition(duration);
    },
    destroy() {
      const swiper = this;
      swiper.scrollbar.destroy();
    },
  },
};

const Parallax = {
  setTransform(el, progress) {
    const swiper = this;
    const { rtl } = swiper;

    const $el = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(el);
    const rtlFactor = rtl ? -1 : 1;

    const p = $el.attr('data-swiper-parallax') || '0';
    let x = $el.attr('data-swiper-parallax-x');
    let y = $el.attr('data-swiper-parallax-y');
    const scale = $el.attr('data-swiper-parallax-scale');
    const opacity = $el.attr('data-swiper-parallax-opacity');

    if (x || y) {
      x = x || '0';
      y = y || '0';
    } else if (swiper.isHorizontal()) {
      x = p;
      y = '0';
    } else {
      y = p;
      x = '0';
    }

    if ((x).indexOf('%') >= 0) {
      x = `${parseInt(x, 10) * progress * rtlFactor}%`;
    } else {
      x = `${x * progress * rtlFactor}px`;
    }
    if ((y).indexOf('%') >= 0) {
      y = `${parseInt(y, 10) * progress}%`;
    } else {
      y = `${y * progress}px`;
    }

    if (typeof opacity !== 'undefined' && opacity !== null) {
      const currentOpacity = opacity - ((opacity - 1) * (1 - Math.abs(progress)));
      $el[0].style.opacity = currentOpacity;
    }
    if (typeof scale === 'undefined' || scale === null) {
      $el.transform(`translate3d(${x}, ${y}, 0px)`);
    } else {
      const currentScale = scale - ((scale - 1) * (1 - Math.abs(progress)));
      $el.transform(`translate3d(${x}, ${y}, 0px) scale(${currentScale})`);
    }
  },
  setTranslate() {
    const swiper = this;
    const {
      $el, slides, progress, snapGrid,
    } = swiper;
    $el.children('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]')
      .each((index, el) => {
        swiper.parallax.setTransform(el, progress);
      });
    slides.each((slideIndex, slideEl) => {
      let slideProgress = slideEl.progress;
      if (swiper.params.slidesPerGroup > 1 && swiper.params.slidesPerView !== 'auto') {
        slideProgress += Math.ceil(slideIndex / 2) - (progress * (snapGrid.length - 1));
      }
      slideProgress = Math.min(Math.max(slideProgress, -1), 1);
      Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(slideEl).find('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]')
        .each((index, el) => {
          swiper.parallax.setTransform(el, slideProgress);
        });
    });
  },
  setTransition(duration = this.params.speed) {
    const swiper = this;
    const { $el } = swiper;
    $el.find('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]')
      .each((index, parallaxEl) => {
        const $parallaxEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(parallaxEl);
        let parallaxDuration = parseInt($parallaxEl.attr('data-swiper-parallax-duration'), 10) || duration;
        if (duration === 0) parallaxDuration = 0;
        $parallaxEl.transition(parallaxDuration);
      });
  },
};

var Parallax$1 = {
  name: 'parallax',
  params: {
    parallax: {
      enabled: false,
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      parallax: {
        setTransform: Parallax.setTransform.bind(swiper),
        setTranslate: Parallax.setTranslate.bind(swiper),
        setTransition: Parallax.setTransition.bind(swiper),
      },
    });
  },
  on: {
    beforeInit() {
      const swiper = this;
      if (!swiper.params.parallax.enabled) return;
      swiper.params.watchSlidesProgress = true;
    },
    init() {
      const swiper = this;
      if (!swiper.params.parallax) return;
      swiper.parallax.setTranslate();
    },
    setTranslate() {
      const swiper = this;
      if (!swiper.params.parallax) return;
      swiper.parallax.setTranslate();
    },
    setTransition(duration) {
      const swiper = this;
      if (!swiper.params.parallax) return;
      swiper.parallax.setTransition(duration);
    },
  },
};

const Zoom = {
  // Calc Scale From Multi-touches
  getDistanceBetweenTouches(e) {
    if (e.targetTouches.length < 2) return 1;
    const x1 = e.targetTouches[0].pageX;
    const y1 = e.targetTouches[0].pageY;
    const x2 = e.targetTouches[1].pageX;
    const y2 = e.targetTouches[1].pageY;
    const distance = Math.sqrt(((x2 - x1) ** 2) + ((y2 - y1) ** 2));
    return distance;
  },
  // Events
  onGestureStart(e) {
    const swiper = this;
    const params = swiper.params.zoom;
    const zoom = swiper.zoom;
    const { gesture } = zoom;
    zoom.fakeGestureTouched = false;
    zoom.fakeGestureMoved = false;
    if (!Support.gestures) {
      if (e.type !== 'touchstart' || (e.type === 'touchstart' && e.targetTouches.length < 2)) {
        return;
      }
      zoom.fakeGestureTouched = true;
      gesture.scaleStart = Zoom.getDistanceBetweenTouches(e);
    }
    if (!gesture.$slideEl || !gesture.$slideEl.length) {
      gesture.$slideEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(e.target).closest('.swiper-slide');
      if (gesture.$slideEl.length === 0) gesture.$slideEl = swiper.slides.eq(swiper.activeIndex);
      gesture.$imageEl = gesture.$slideEl.find('img, svg, canvas');
      gesture.$imageWrapEl = gesture.$imageEl.parent(`.${params.containerClass}`);
      gesture.maxRatio = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;
      if (gesture.$imageWrapEl.length === 0) {
        gesture.$imageEl = undefined;
        return;
      }
    }
    gesture.$imageEl.transition(0);
    swiper.zoom.isScaling = true;
  },
  onGestureChange(e) {
    const swiper = this;
    const params = swiper.params.zoom;
    const zoom = swiper.zoom;
    const { gesture } = zoom;
    if (!Support.gestures) {
      if (e.type !== 'touchmove' || (e.type === 'touchmove' && e.targetTouches.length < 2)) {
        return;
      }
      zoom.fakeGestureMoved = true;
      gesture.scaleMove = Zoom.getDistanceBetweenTouches(e);
    }
    if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
    if (Support.gestures) {
      swiper.zoom.scale = e.scale * zoom.currentScale;
    } else {
      zoom.scale = (gesture.scaleMove / gesture.scaleStart) * zoom.currentScale;
    }
    if (zoom.scale > gesture.maxRatio) {
      zoom.scale = (gesture.maxRatio - 1) + (((zoom.scale - gesture.maxRatio) + 1) ** 0.5);
    }
    if (zoom.scale < params.minRatio) {
      zoom.scale = (params.minRatio + 1) - (((params.minRatio - zoom.scale) + 1) ** 0.5);
    }
    gesture.$imageEl.transform(`translate3d(0,0,0) scale(${zoom.scale})`);
  },
  onGestureEnd(e) {
    const swiper = this;
    const params = swiper.params.zoom;
    const zoom = swiper.zoom;
    const { gesture } = zoom;
    if (!Support.gestures) {
      if (!zoom.fakeGestureTouched || !zoom.fakeGestureMoved) {
        return;
      }
      if (e.type !== 'touchend' || (e.type === 'touchend' && e.changedTouches.length < 2 && !Device.android)) {
        return;
      }
      zoom.fakeGestureTouched = false;
      zoom.fakeGestureMoved = false;
    }
    if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
    zoom.scale = Math.max(Math.min(zoom.scale, gesture.maxRatio), params.minRatio);
    gesture.$imageEl.transition(swiper.params.speed).transform(`translate3d(0,0,0) scale(${zoom.scale})`);
    zoom.currentScale = zoom.scale;
    zoom.isScaling = false;
    if (zoom.scale === 1) gesture.$slideEl = undefined;
  },
  onTouchStart(e) {
    const swiper = this;
    const zoom = swiper.zoom;
    const { gesture, image } = zoom;
    if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
    if (image.isTouched) return;
    if (Device.android) e.preventDefault();
    image.isTouched = true;
    image.touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
    image.touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
  },
  onTouchMove(e) {
    const swiper = this;
    const zoom = swiper.zoom;
    const { gesture, image, velocity } = zoom;
    if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
    swiper.allowClick = false;
    if (!image.isTouched || !gesture.$slideEl) return;

    if (!image.isMoved) {
      image.width = gesture.$imageEl[0].offsetWidth;
      image.height = gesture.$imageEl[0].offsetHeight;
      image.startX = Utils.getTranslate(gesture.$imageWrapEl[0], 'x') || 0;
      image.startY = Utils.getTranslate(gesture.$imageWrapEl[0], 'y') || 0;
      gesture.slideWidth = gesture.$slideEl[0].offsetWidth;
      gesture.slideHeight = gesture.$slideEl[0].offsetHeight;
      gesture.$imageWrapEl.transition(0);
      if (swiper.rtl) {
        image.startX = -image.startX;
        image.startY = -image.startY;
      }
    }
    // Define if we need image drag
    const scaledWidth = image.width * zoom.scale;
    const scaledHeight = image.height * zoom.scale;

    if (scaledWidth < gesture.slideWidth && scaledHeight < gesture.slideHeight) return;

    image.minX = Math.min(((gesture.slideWidth / 2) - (scaledWidth / 2)), 0);
    image.maxX = -image.minX;
    image.minY = Math.min(((gesture.slideHeight / 2) - (scaledHeight / 2)), 0);
    image.maxY = -image.minY;

    image.touchesCurrent.x = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
    image.touchesCurrent.y = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;

    if (!image.isMoved && !zoom.isScaling) {
      if (
        swiper.isHorizontal() &&
        (
          (Math.floor(image.minX) === Math.floor(image.startX) && image.touchesCurrent.x < image.touchesStart.x) ||
          (Math.floor(image.maxX) === Math.floor(image.startX) && image.touchesCurrent.x > image.touchesStart.x)
        )
      ) {
        image.isTouched = false;
        return;
      } else if (
        !swiper.isHorizontal() &&
        (
          (Math.floor(image.minY) === Math.floor(image.startY) && image.touchesCurrent.y < image.touchesStart.y) ||
          (Math.floor(image.maxY) === Math.floor(image.startY) && image.touchesCurrent.y > image.touchesStart.y)
        )
      ) {
        image.isTouched = false;
        return;
      }
    }
    e.preventDefault();
    e.stopPropagation();

    image.isMoved = true;
    image.currentX = (image.touchesCurrent.x - image.touchesStart.x) + image.startX;
    image.currentY = (image.touchesCurrent.y - image.touchesStart.y) + image.startY;

    if (image.currentX < image.minX) {
      image.currentX = (image.minX + 1) - (((image.minX - image.currentX) + 1) ** 0.8);
    }
    if (image.currentX > image.maxX) {
      image.currentX = (image.maxX - 1) + (((image.currentX - image.maxX) + 1) ** 0.8);
    }

    if (image.currentY < image.minY) {
      image.currentY = (image.minY + 1) - (((image.minY - image.currentY) + 1) ** 0.8);
    }
    if (image.currentY > image.maxY) {
      image.currentY = (image.maxY - 1) + (((image.currentY - image.maxY) + 1) ** 0.8);
    }

    // Velocity
    if (!velocity.prevPositionX) velocity.prevPositionX = image.touchesCurrent.x;
    if (!velocity.prevPositionY) velocity.prevPositionY = image.touchesCurrent.y;
    if (!velocity.prevTime) velocity.prevTime = Date.now();
    velocity.x = (image.touchesCurrent.x - velocity.prevPositionX) / (Date.now() - velocity.prevTime) / 2;
    velocity.y = (image.touchesCurrent.y - velocity.prevPositionY) / (Date.now() - velocity.prevTime) / 2;
    if (Math.abs(image.touchesCurrent.x - velocity.prevPositionX) < 2) velocity.x = 0;
    if (Math.abs(image.touchesCurrent.y - velocity.prevPositionY) < 2) velocity.y = 0;
    velocity.prevPositionX = image.touchesCurrent.x;
    velocity.prevPositionY = image.touchesCurrent.y;
    velocity.prevTime = Date.now();

    gesture.$imageWrapEl.transform(`translate3d(${image.currentX}px, ${image.currentY}px,0)`);
  },
  onTouchEnd() {
    const swiper = this;
    const zoom = swiper.zoom;
    const { gesture, image, velocity } = zoom;
    if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
    if (!image.isTouched || !image.isMoved) {
      image.isTouched = false;
      image.isMoved = false;
      return;
    }
    image.isTouched = false;
    image.isMoved = false;
    let momentumDurationX = 300;
    let momentumDurationY = 300;
    const momentumDistanceX = velocity.x * momentumDurationX;
    const newPositionX = image.currentX + momentumDistanceX;
    const momentumDistanceY = velocity.y * momentumDurationY;
    const newPositionY = image.currentY + momentumDistanceY;

    // Fix duration
    if (velocity.x !== 0) momentumDurationX = Math.abs((newPositionX - image.currentX) / velocity.x);
    if (velocity.y !== 0) momentumDurationY = Math.abs((newPositionY - image.currentY) / velocity.y);
    const momentumDuration = Math.max(momentumDurationX, momentumDurationY);

    image.currentX = newPositionX;
    image.currentY = newPositionY;

    // Define if we need image drag
    const scaledWidth = image.width * zoom.scale;
    const scaledHeight = image.height * zoom.scale;
    image.minX = Math.min(((gesture.slideWidth / 2) - (scaledWidth / 2)), 0);
    image.maxX = -image.minX;
    image.minY = Math.min(((gesture.slideHeight / 2) - (scaledHeight / 2)), 0);
    image.maxY = -image.minY;
    image.currentX = Math.max(Math.min(image.currentX, image.maxX), image.minX);
    image.currentY = Math.max(Math.min(image.currentY, image.maxY), image.minY);

    gesture.$imageWrapEl.transition(momentumDuration).transform(`translate3d(${image.currentX}px, ${image.currentY}px,0)`);
  },
  onTransitionEnd() {
    const swiper = this;
    const zoom = swiper.zoom;
    const { gesture } = zoom;
    if (gesture.$slideEl && swiper.previousIndex !== swiper.activeIndex) {
      gesture.$imageEl.transform('translate3d(0,0,0) scale(1)');
      gesture.$imageWrapEl.transform('translate3d(0,0,0)');
      gesture.$slideEl = undefined;
      gesture.$imageEl = undefined;
      gesture.$imageWrapEl = undefined;

      zoom.scale = 1;
      zoom.currentScale = 1;
    }
  },
  // Toggle Zoom
  toggle(e) {
    const swiper = this;
    const zoom = swiper.zoom;

    if (zoom.scale && zoom.scale !== 1) {
      // Zoom Out
      zoom.out();
    } else {
      // Zoom In
      zoom.in(e);
    }
  },
  in(e) {
    const swiper = this;

    const zoom = swiper.zoom;
    const params = swiper.params.zoom;
    const { gesture, image } = zoom;

    if (!gesture.$slideEl) {
      gesture.$slideEl = swiper.clickedSlide ? Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(swiper.clickedSlide) : swiper.slides.eq(swiper.activeIndex);
      gesture.$imageEl = gesture.$slideEl.find('img, svg, canvas');
      gesture.$imageWrapEl = gesture.$imageEl.parent(`.${params.containerClass}`);
    }
    if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;

    gesture.$slideEl.addClass(`${params.zoomedSlideClass}`);

    let touchX;
    let touchY;
    let offsetX;
    let offsetY;
    let diffX;
    let diffY;
    let translateX;
    let translateY;
    let imageWidth;
    let imageHeight;
    let scaledWidth;
    let scaledHeight;
    let translateMinX;
    let translateMinY;
    let translateMaxX;
    let translateMaxY;
    let slideWidth;
    let slideHeight;

    if (typeof image.touchesStart.x === 'undefined' && e) {
      touchX = e.type === 'touchend' ? e.changedTouches[0].pageX : e.pageX;
      touchY = e.type === 'touchend' ? e.changedTouches[0].pageY : e.pageY;
    } else {
      touchX = image.touchesStart.x;
      touchY = image.touchesStart.y;
    }

    zoom.scale = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;
    zoom.currentScale = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;
    if (e) {
      slideWidth = gesture.$slideEl[0].offsetWidth;
      slideHeight = gesture.$slideEl[0].offsetHeight;
      offsetX = gesture.$slideEl.offset().left;
      offsetY = gesture.$slideEl.offset().top;
      diffX = (offsetX + (slideWidth / 2)) - touchX;
      diffY = (offsetY + (slideHeight / 2)) - touchY;

      imageWidth = gesture.$imageEl[0].offsetWidth;
      imageHeight = gesture.$imageEl[0].offsetHeight;
      scaledWidth = imageWidth * zoom.scale;
      scaledHeight = imageHeight * zoom.scale;

      translateMinX = Math.min(((slideWidth / 2) - (scaledWidth / 2)), 0);
      translateMinY = Math.min(((slideHeight / 2) - (scaledHeight / 2)), 0);
      translateMaxX = -translateMinX;
      translateMaxY = -translateMinY;

      translateX = diffX * zoom.scale;
      translateY = diffY * zoom.scale;

      if (translateX < translateMinX) {
        translateX = translateMinX;
      }
      if (translateX > translateMaxX) {
        translateX = translateMaxX;
      }

      if (translateY < translateMinY) {
        translateY = translateMinY;
      }
      if (translateY > translateMaxY) {
        translateY = translateMaxY;
      }
    } else {
      translateX = 0;
      translateY = 0;
    }
    gesture.$imageWrapEl.transition(300).transform(`translate3d(${translateX}px, ${translateY}px,0)`);
    gesture.$imageEl.transition(300).transform(`translate3d(0,0,0) scale(${zoom.scale})`);
  },
  out() {
    const swiper = this;

    const zoom = swiper.zoom;
    const params = swiper.params.zoom;
    const { gesture } = zoom;

    if (!gesture.$slideEl) {
      gesture.$slideEl = swiper.clickedSlide ? Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(swiper.clickedSlide) : swiper.slides.eq(swiper.activeIndex);
      gesture.$imageEl = gesture.$slideEl.find('img, svg, canvas');
      gesture.$imageWrapEl = gesture.$imageEl.parent(`.${params.containerClass}`);
    }
    if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;

    zoom.scale = 1;
    zoom.currentScale = 1;
    gesture.$imageWrapEl.transition(300).transform('translate3d(0,0,0)');
    gesture.$imageEl.transition(300).transform('translate3d(0,0,0) scale(1)');
    gesture.$slideEl.removeClass(`${params.zoomedSlideClass}`);
    gesture.$slideEl = undefined;
  },
  // Attach/Detach Events
  enable() {
    const swiper = this;
    const zoom = swiper.zoom;
    if (zoom.enabled) return;
    zoom.enabled = true;

    const passiveListener = swiper.touchEvents.start === 'touchstart' && Support.passiveListener && swiper.params.passiveListeners ? { passive: true, capture: false } : false;

    // Scale image
    if (Support.gestures) {
      swiper.$wrapperEl.on('gesturestart', '.swiper-slide', zoom.onGestureStart, passiveListener);
      swiper.$wrapperEl.on('gesturechange', '.swiper-slide', zoom.onGestureChange, passiveListener);
      swiper.$wrapperEl.on('gestureend', '.swiper-slide', zoom.onGestureEnd, passiveListener);
    } else if (swiper.touchEvents.start === 'touchstart') {
      swiper.$wrapperEl.on(swiper.touchEvents.start, '.swiper-slide', zoom.onGestureStart, passiveListener);
      swiper.$wrapperEl.on(swiper.touchEvents.move, '.swiper-slide', zoom.onGestureChange, passiveListener);
      swiper.$wrapperEl.on(swiper.touchEvents.end, '.swiper-slide', zoom.onGestureEnd, passiveListener);
    }

    // Move image
    swiper.$wrapperEl.on(swiper.touchEvents.move, `.${swiper.params.zoom.containerClass}`, zoom.onTouchMove);
  },
  disable() {
    const swiper = this;
    const zoom = swiper.zoom;
    if (!zoom.enabled) return;

    swiper.zoom.enabled = false;

    const passiveListener = swiper.touchEvents.start === 'touchstart' && Support.passiveListener && swiper.params.passiveListeners ? { passive: true, capture: false } : false;

    // Scale image
    if (Support.gestures) {
      swiper.$wrapperEl.off('gesturestart', '.swiper-slide', zoom.onGestureStart, passiveListener);
      swiper.$wrapperEl.off('gesturechange', '.swiper-slide', zoom.onGestureChange, passiveListener);
      swiper.$wrapperEl.off('gestureend', '.swiper-slide', zoom.onGestureEnd, passiveListener);
    } else if (swiper.touchEvents.start === 'touchstart') {
      swiper.$wrapperEl.off(swiper.touchEvents.start, '.swiper-slide', zoom.onGestureStart, passiveListener);
      swiper.$wrapperEl.off(swiper.touchEvents.move, '.swiper-slide', zoom.onGestureChange, passiveListener);
      swiper.$wrapperEl.off(swiper.touchEvents.end, '.swiper-slide', zoom.onGestureEnd, passiveListener);
    }

    // Move image
    swiper.$wrapperEl.off(swiper.touchEvents.move, `.${swiper.params.zoom.containerClass}`, zoom.onTouchMove);
  },
};

var Zoom$1 = {
  name: 'zoom',
  params: {
    zoom: {
      enabled: false,
      maxRatio: 3,
      minRatio: 1,
      toggle: true,
      containerClass: 'swiper-zoom-container',
      zoomedSlideClass: 'swiper-slide-zoomed',
    },
  },
  create() {
    const swiper = this;
    const zoom = {
      enabled: false,
      scale: 1,
      currentScale: 1,
      isScaling: false,
      gesture: {
        $slideEl: undefined,
        slideWidth: undefined,
        slideHeight: undefined,
        $imageEl: undefined,
        $imageWrapEl: undefined,
        maxRatio: 3,
      },
      image: {
        isTouched: undefined,
        isMoved: undefined,
        currentX: undefined,
        currentY: undefined,
        minX: undefined,
        minY: undefined,
        maxX: undefined,
        maxY: undefined,
        width: undefined,
        height: undefined,
        startX: undefined,
        startY: undefined,
        touchesStart: {},
        touchesCurrent: {},
      },
      velocity: {
        x: undefined,
        y: undefined,
        prevPositionX: undefined,
        prevPositionY: undefined,
        prevTime: undefined,
      },
    };
    ('onGestureStart onGestureChange onGestureEnd onTouchStart onTouchMove onTouchEnd onTransitionEnd toggle enable disable in out').split(' ').forEach((methodName) => {
      zoom[methodName] = Zoom[methodName].bind(swiper);
    });
    Utils.extend(swiper, {
      zoom,
    });
  },
  on: {
    init() {
      const swiper = this;
      if (swiper.params.zoom.enabled) {
        swiper.zoom.enable();
      }
    },
    destroy() {
      const swiper = this;
      swiper.zoom.disable();
    },
    touchStart(e) {
      const swiper = this;
      if (!swiper.zoom.enabled) return;
      swiper.zoom.onTouchStart(e);
    },
    touchEnd(e) {
      const swiper = this;
      if (!swiper.zoom.enabled) return;
      swiper.zoom.onTouchEnd(e);
    },
    doubleTap(e) {
      const swiper = this;
      if (swiper.params.zoom.enabled && swiper.zoom.enabled && swiper.params.zoom.toggle) {
        swiper.zoom.toggle(e);
      }
    },
    transitionEnd() {
      const swiper = this;
      if (swiper.zoom.enabled && swiper.params.zoom.enabled) {
        swiper.zoom.onTransitionEnd();
      }
    },
  },
};

const Lazy$2 = {
  loadInSlide(index, loadInDuplicate = true) {
    const swiper = this;
    const params = swiper.params.lazy;
    if (typeof index === 'undefined') return;
    if (swiper.slides.length === 0) return;
    const isVirtual = swiper.virtual && swiper.params.virtual.enabled;

    const $slideEl = isVirtual
      ? swiper.$wrapperEl.children(`.${swiper.params.slideClass}[data-swiper-slide-index="${index}"]`)
      : swiper.slides.eq(index);

    let $images = $slideEl.find(`.${params.elementClass}:not(.${params.loadedClass}):not(.${params.loadingClass})`);
    if ($slideEl.hasClass(params.elementClass) && !$slideEl.hasClass(params.loadedClass) && !$slideEl.hasClass(params.loadingClass)) {
      $images = $images.add($slideEl[0]);
    }
    if ($images.length === 0) return;

    $images.each((imageIndex, imageEl) => {
      const $imageEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(imageEl);
      $imageEl.addClass(params.loadingClass);

      const background = $imageEl.attr('data-background');
      const src = $imageEl.attr('data-src');
      const srcset = $imageEl.attr('data-srcset');
      const sizes = $imageEl.attr('data-sizes');

      swiper.loadImage($imageEl[0], (src || background), srcset, sizes, false, () => {
        if (typeof swiper === 'undefined' || swiper === null || !swiper || (swiper && !swiper.params) || swiper.destroyed) return;
        if (background) {
          $imageEl.css('background-image', `url("${background}")`);
          $imageEl.removeAttr('data-background');
        } else {
          if (srcset) {
            $imageEl.attr('srcset', srcset);
            $imageEl.removeAttr('data-srcset');
          }
          if (sizes) {
            $imageEl.attr('sizes', sizes);
            $imageEl.removeAttr('data-sizes');
          }
          if (src) {
            $imageEl.attr('src', src);
            $imageEl.removeAttr('data-src');
          }
        }

        $imageEl.addClass(params.loadedClass).removeClass(params.loadingClass);
        $slideEl.find(`.${params.preloaderClass}`).remove();
        if (swiper.params.loop && loadInDuplicate) {
          const slideOriginalIndex = $slideEl.attr('data-swiper-slide-index');
          if ($slideEl.hasClass(swiper.params.slideDuplicateClass)) {
            const originalSlide = swiper.$wrapperEl.children(`[data-swiper-slide-index="${slideOriginalIndex}"]:not(.${swiper.params.slideDuplicateClass})`);
            swiper.lazy.loadInSlide(originalSlide.index(), false);
          } else {
            const duplicatedSlide = swiper.$wrapperEl.children(`.${swiper.params.slideDuplicateClass}[data-swiper-slide-index="${slideOriginalIndex}"]`);
            swiper.lazy.loadInSlide(duplicatedSlide.index(), false);
          }
        }
        swiper.emit('lazyImageReady', $slideEl[0], $imageEl[0]);
      });

      swiper.emit('lazyImageLoad', $slideEl[0], $imageEl[0]);
    });
  },
  load() {
    const swiper = this;
    const {
      $wrapperEl, params: swiperParams, slides, activeIndex,
    } = swiper;
    const isVirtual = swiper.virtual && swiperParams.virtual.enabled;
    const params = swiperParams.lazy;

    let slidesPerView = swiperParams.slidesPerView;
    if (slidesPerView === 'auto') {
      slidesPerView = 0;
    }

    function slideExist(index) {
      if (isVirtual) {
        if ($wrapperEl.children(`.${swiperParams.slideClass}[data-swiper-slide-index="${index}"]`).length) {
          return true;
        }
      } else if (slides[index]) return true;
      return false;
    }
    function slideIndex(slideEl) {
      if (isVirtual) {
        return Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(slideEl).attr('data-swiper-slide-index');
      }
      return Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(slideEl).index();
    }

    if (!swiper.lazy.initialImageLoaded) swiper.lazy.initialImageLoaded = true;
    if (swiper.params.watchSlidesVisibility) {
      $wrapperEl.children(`.${swiperParams.slideVisibleClass}`).each((elIndex, slideEl) => {
        const index = isVirtual ? Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(slideEl).attr('data-swiper-slide-index') : Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(slideEl).index();
        swiper.lazy.loadInSlide(index);
      });
    } else if (slidesPerView > 1) {
      for (let i = activeIndex; i < activeIndex + slidesPerView; i += 1) {
        if (slideExist(i)) swiper.lazy.loadInSlide(i);
      }
    } else {
      swiper.lazy.loadInSlide(activeIndex);
    }
    if (params.loadPrevNext) {
      if (slidesPerView > 1 || (params.loadPrevNextAmount && params.loadPrevNextAmount > 1)) {
        const amount = params.loadPrevNextAmount;
        const spv = slidesPerView;
        const maxIndex = Math.min(activeIndex + spv + Math.max(amount, spv), slides.length);
        const minIndex = Math.max(activeIndex - Math.max(spv, amount), 0);
        // Next Slides
        for (let i = activeIndex + slidesPerView; i < maxIndex; i += 1) {
          if (slideExist(i)) swiper.lazy.loadInSlide(i);
        }
        // Prev Slides
        for (let i = minIndex; i < activeIndex; i += 1) {
          if (slideExist(i)) swiper.lazy.loadInSlide(i);
        }
      } else {
        const nextSlide = $wrapperEl.children(`.${swiperParams.slideNextClass}`);
        if (nextSlide.length > 0) swiper.lazy.loadInSlide(slideIndex(nextSlide));

        const prevSlide = $wrapperEl.children(`.${swiperParams.slidePrevClass}`);
        if (prevSlide.length > 0) swiper.lazy.loadInSlide(slideIndex(prevSlide));
      }
    }
  },
};

var Lazy$3 = {
  name: 'lazy',
  params: {
    lazy: {
      enabled: false,
      loadPrevNext: false,
      loadPrevNextAmount: 1,
      loadOnTransitionStart: false,

      elementClass: 'swiper-lazy',
      loadingClass: 'swiper-lazy-loading',
      loadedClass: 'swiper-lazy-loaded',
      preloaderClass: 'swiper-lazy-preloader',
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      lazy: {
        initialImageLoaded: false,
        load: Lazy$2.load.bind(swiper),
        loadInSlide: Lazy$2.loadInSlide.bind(swiper),
      },
    });
  },
  on: {
    beforeInit() {
      const swiper = this;
      if (swiper.params.lazy.enabled && swiper.params.preloadImages) {
        swiper.params.preloadImages = false;
      }
    },
    init() {
      const swiper = this;
      if (swiper.params.lazy.enabled && !swiper.params.loop && swiper.params.initialSlide === 0) {
        swiper.lazy.load();
      }
    },
    scroll() {
      const swiper = this;
      if (swiper.params.freeMode && !swiper.params.freeModeSticky) {
        swiper.lazy.load();
      }
    },
    resize() {
      const swiper = this;
      if (swiper.params.lazy.enabled) {
        swiper.lazy.load();
      }
    },
    scrollbarDragMove() {
      const swiper = this;
      if (swiper.params.lazy.enabled) {
        swiper.lazy.load();
      }
    },
    transitionStart() {
      const swiper = this;
      if (swiper.params.lazy.enabled) {
        if (swiper.params.lazy.loadOnTransitionStart || (!swiper.params.lazy.loadOnTransitionStart && !swiper.lazy.initialImageLoaded)) {
          swiper.lazy.load();
        }
      }
    },
    transitionEnd() {
      const swiper = this;
      if (swiper.params.lazy.enabled && !swiper.params.lazy.loadOnTransitionStart) {
        swiper.lazy.load();
      }
    },
  },
};

/* eslint no-bitwise: ["error", { "allow": [">>"] }] */

const Controller = {
  LinearSpline: function LinearSpline(x, y) {
    const binarySearch = (function search() {
      let maxIndex;
      let minIndex;
      let guess;
      return (array, val) => {
        minIndex = -1;
        maxIndex = array.length;
        while (maxIndex - minIndex > 1) {
          guess = maxIndex + minIndex >> 1;
          if (array[guess] <= val) {
            minIndex = guess;
          } else {
            maxIndex = guess;
          }
        }
        return maxIndex;
      };
    }());
    this.x = x;
    this.y = y;
    this.lastIndex = x.length - 1;
    // Given an x value (x2), return the expected y2 value:
    // (x1,y1) is the known point before given value,
    // (x3,y3) is the known point after given value.
    let i1;
    let i3;

    this.interpolate = function interpolate(x2) {
      if (!x2) return 0;

      // Get the indexes of x1 and x3 (the array indexes before and after given x2):
      i3 = binarySearch(this.x, x2);
      i1 = i3 - 1;

      // We have our indexes i1 & i3, so we can calculate already:
      // y2 := ((x2x1)  (y3y1))  (x3x1) + y1
      return (((x2 - this.x[i1]) * (this.y[i3] - this.y[i1])) / (this.x[i3] - this.x[i1])) + this.y[i1];
    };
    return this;
  },
  // xxx: for now i will just save one spline function to to
  getInterpolateFunction(c) {
    const swiper = this;
    if (!swiper.controller.spline) {
      swiper.controller.spline = swiper.params.loop ?
        new Controller.LinearSpline(swiper.slidesGrid, c.slidesGrid) :
        new Controller.LinearSpline(swiper.snapGrid, c.snapGrid);
    }
  },
  setTranslate(setTranslate, byController) {
    const swiper = this;
    const controlled = swiper.controller.control;
    let multiplier;
    let controlledTranslate;
    function setControlledTranslate(c) {
      // this will create an Interpolate function based on the snapGrids
      // x is the Grid of the scrolled scroller and y will be the controlled scroller
      // it makes sense to create this only once and recall it for the interpolation
      // the function does a lot of value caching for performance
      const translate = swiper.rtlTranslate ? -swiper.translate : swiper.translate;
      if (swiper.params.controller.by === 'slide') {
        swiper.controller.getInterpolateFunction(c);
        // i am not sure why the values have to be multiplicated this way, tried to invert the snapGrid
        // but it did not work out
        controlledTranslate = -swiper.controller.spline.interpolate(-translate);
      }

      if (!controlledTranslate || swiper.params.controller.by === 'container') {
        multiplier = (c.maxTranslate() - c.minTranslate()) / (swiper.maxTranslate() - swiper.minTranslate());
        controlledTranslate = ((translate - swiper.minTranslate()) * multiplier) + c.minTranslate();
      }

      if (swiper.params.controller.inverse) {
        controlledTranslate = c.maxTranslate() - controlledTranslate;
      }
      c.updateProgress(controlledTranslate);
      c.setTranslate(controlledTranslate, swiper);
      c.updateActiveIndex();
      c.updateSlidesClasses();
    }
    if (Array.isArray(controlled)) {
      for (let i = 0; i < controlled.length; i += 1) {
        if (controlled[i] !== byController && controlled[i] instanceof Swiper) {
          setControlledTranslate(controlled[i]);
        }
      }
    } else if (controlled instanceof Swiper && byController !== controlled) {
      setControlledTranslate(controlled);
    }
  },
  setTransition(duration, byController) {
    const swiper = this;
    const controlled = swiper.controller.control;
    let i;
    function setControlledTransition(c) {
      c.setTransition(duration, swiper);
      if (duration !== 0) {
        c.transitionStart();
        c.$wrapperEl.transitionEnd(() => {
          if (!controlled) return;
          if (c.params.loop && swiper.params.controller.by === 'slide') {
            c.loopFix();
          }
          c.transitionEnd();
        });
      }
    }
    if (Array.isArray(controlled)) {
      for (i = 0; i < controlled.length; i += 1) {
        if (controlled[i] !== byController && controlled[i] instanceof Swiper) {
          setControlledTransition(controlled[i]);
        }
      }
    } else if (controlled instanceof Swiper && byController !== controlled) {
      setControlledTransition(controlled);
    }
  },
};
var Controller$1 = {
  name: 'controller',
  params: {
    controller: {
      control: undefined,
      inverse: false,
      by: 'slide', // or 'container'
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      controller: {
        control: swiper.params.controller.control,
        getInterpolateFunction: Controller.getInterpolateFunction.bind(swiper),
        setTranslate: Controller.setTranslate.bind(swiper),
        setTransition: Controller.setTransition.bind(swiper),
      },
    });
  },
  on: {
    update() {
      const swiper = this;
      if (!swiper.controller.control) return;
      if (swiper.controller.spline) {
        swiper.controller.spline = undefined;
        delete swiper.controller.spline;
      }
    },
    resize() {
      const swiper = this;
      if (!swiper.controller.control) return;
      if (swiper.controller.spline) {
        swiper.controller.spline = undefined;
        delete swiper.controller.spline;
      }
    },
    observerUpdate() {
      const swiper = this;
      if (!swiper.controller.control) return;
      if (swiper.controller.spline) {
        swiper.controller.spline = undefined;
        delete swiper.controller.spline;
      }
    },
    setTranslate(translate, byController) {
      const swiper = this;
      if (!swiper.controller.control) return;
      swiper.controller.setTranslate(translate, byController);
    },
    setTransition(duration, byController) {
      const swiper = this;
      if (!swiper.controller.control) return;
      swiper.controller.setTransition(duration, byController);
    },
  },
};

const a11y = {
  makeElFocusable($el) {
    $el.attr('tabIndex', '0');
    return $el;
  },
  addElRole($el, role) {
    $el.attr('role', role);
    return $el;
  },
  addElLabel($el, label) {
    $el.attr('aria-label', label);
    return $el;
  },
  disableEl($el) {
    $el.attr('aria-disabled', true);
    return $el;
  },
  enableEl($el) {
    $el.attr('aria-disabled', false);
    return $el;
  },
  onEnterKey(e) {
    const swiper = this;
    const params = swiper.params.a11y;
    if (e.keyCode !== 13) return;
    const $targetEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(e.target);
    if (swiper.navigation && swiper.navigation.$nextEl && $targetEl.is(swiper.navigation.$nextEl)) {
      if (!(swiper.isEnd && !swiper.params.loop)) {
        swiper.slideNext();
      }
      if (swiper.isEnd) {
        swiper.a11y.notify(params.lastSlideMessage);
      } else {
        swiper.a11y.notify(params.nextSlideMessage);
      }
    }
    if (swiper.navigation && swiper.navigation.$prevEl && $targetEl.is(swiper.navigation.$prevEl)) {
      if (!(swiper.isBeginning && !swiper.params.loop)) {
        swiper.slidePrev();
      }
      if (swiper.isBeginning) {
        swiper.a11y.notify(params.firstSlideMessage);
      } else {
        swiper.a11y.notify(params.prevSlideMessage);
      }
    }
    if (swiper.pagination && $targetEl.is(`.${swiper.params.pagination.bulletClass}`)) {
      $targetEl[0].click();
    }
  },
  notify(message) {
    const swiper = this;
    const notification = swiper.a11y.liveRegion;
    if (notification.length === 0) return;
    notification.html('');
    notification.html(message);
  },
  updateNavigation() {
    const swiper = this;

    if (swiper.params.loop) return;
    const { $nextEl, $prevEl } = swiper.navigation;

    if ($prevEl && $prevEl.length > 0) {
      if (swiper.isBeginning) {
        swiper.a11y.disableEl($prevEl);
      } else {
        swiper.a11y.enableEl($prevEl);
      }
    }
    if ($nextEl && $nextEl.length > 0) {
      if (swiper.isEnd) {
        swiper.a11y.disableEl($nextEl);
      } else {
        swiper.a11y.enableEl($nextEl);
      }
    }
  },
  updatePagination() {
    const swiper = this;
    const params = swiper.params.a11y;
    if (swiper.pagination && swiper.params.pagination.clickable && swiper.pagination.bullets && swiper.pagination.bullets.length) {
      swiper.pagination.bullets.each((bulletIndex, bulletEl) => {
        const $bulletEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(bulletEl);
        swiper.a11y.makeElFocusable($bulletEl);
        swiper.a11y.addElRole($bulletEl, 'button');
        swiper.a11y.addElLabel($bulletEl, params.paginationBulletMessage.replace(/{{index}}/, $bulletEl.index() + 1));
      });
    }
  },
  init() {
    const swiper = this;

    swiper.$el.append(swiper.a11y.liveRegion);

    // Navigation
    const params = swiper.params.a11y;
    let $nextEl;
    let $prevEl;
    if (swiper.navigation && swiper.navigation.$nextEl) {
      $nextEl = swiper.navigation.$nextEl;
    }
    if (swiper.navigation && swiper.navigation.$prevEl) {
      $prevEl = swiper.navigation.$prevEl;
    }
    if ($nextEl) {
      swiper.a11y.makeElFocusable($nextEl);
      swiper.a11y.addElRole($nextEl, 'button');
      swiper.a11y.addElLabel($nextEl, params.nextSlideMessage);
      $nextEl.on('keydown', swiper.a11y.onEnterKey);
    }
    if ($prevEl) {
      swiper.a11y.makeElFocusable($prevEl);
      swiper.a11y.addElRole($prevEl, 'button');
      swiper.a11y.addElLabel($prevEl, params.prevSlideMessage);
      $prevEl.on('keydown', swiper.a11y.onEnterKey);
    }

    // Pagination
    if (swiper.pagination && swiper.params.pagination.clickable && swiper.pagination.bullets && swiper.pagination.bullets.length) {
      swiper.pagination.$el.on('keydown', `.${swiper.params.pagination.bulletClass}`, swiper.a11y.onEnterKey);
    }
  },
  destroy() {
    const swiper = this;
    if (swiper.a11y.liveRegion && swiper.a11y.liveRegion.length > 0) swiper.a11y.liveRegion.remove();

    let $nextEl;
    let $prevEl;
    if (swiper.navigation && swiper.navigation.$nextEl) {
      $nextEl = swiper.navigation.$nextEl;
    }
    if (swiper.navigation && swiper.navigation.$prevEl) {
      $prevEl = swiper.navigation.$prevEl;
    }
    if ($nextEl) {
      $nextEl.off('keydown', swiper.a11y.onEnterKey);
    }
    if ($prevEl) {
      $prevEl.off('keydown', swiper.a11y.onEnterKey);
    }

    // Pagination
    if (swiper.pagination && swiper.params.pagination.clickable && swiper.pagination.bullets && swiper.pagination.bullets.length) {
      swiper.pagination.$el.off('keydown', `.${swiper.params.pagination.bulletClass}`, swiper.a11y.onEnterKey);
    }
  },
};
var A11y = {
  name: 'a11y',
  params: {
    a11y: {
      enabled: true,
      notificationClass: 'swiper-notification',
      prevSlideMessage: 'Previous slide',
      nextSlideMessage: 'Next slide',
      firstSlideMessage: 'This is the first slide',
      lastSlideMessage: 'This is the last slide',
      paginationBulletMessage: 'Go to slide {{index}}',
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      a11y: {
        liveRegion: Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(`<span class="${swiper.params.a11y.notificationClass}" aria-live="assertive" aria-atomic="true"></span>`),
      },
    });
    Object.keys(a11y).forEach((methodName) => {
      swiper.a11y[methodName] = a11y[methodName].bind(swiper);
    });
  },
  on: {
    init() {
      const swiper = this;
      if (!swiper.params.a11y.enabled) return;
      swiper.a11y.init();
      swiper.a11y.updateNavigation();
    },
    toEdge() {
      const swiper = this;
      if (!swiper.params.a11y.enabled) return;
      swiper.a11y.updateNavigation();
    },
    fromEdge() {
      const swiper = this;
      if (!swiper.params.a11y.enabled) return;
      swiper.a11y.updateNavigation();
    },
    paginationUpdate() {
      const swiper = this;
      if (!swiper.params.a11y.enabled) return;
      swiper.a11y.updatePagination();
    },
    destroy() {
      const swiper = this;
      if (!swiper.params.a11y.enabled) return;
      swiper.a11y.destroy();
    },
  },
};

/* eslint no-underscore-dangle: "off" */

const Autoplay = {
  run() {
    const swiper = this;
    const $activeSlideEl = swiper.slides.eq(swiper.activeIndex);
    let delay = swiper.params.autoplay.delay;
    if ($activeSlideEl.attr('data-swiper-autoplay')) {
      delay = $activeSlideEl.attr('data-swiper-autoplay') || swiper.params.autoplay.delay;
    }
    swiper.autoplay.timeout = Utils.nextTick(() => {
      if (swiper.params.autoplay.reverseDirection) {
        if (swiper.params.loop) {
          swiper.loopFix();
          swiper.slidePrev(swiper.params.speed, true, true);
          swiper.emit('autoplay');
        } else if (!swiper.isBeginning) {
          swiper.slidePrev(swiper.params.speed, true, true);
          swiper.emit('autoplay');
        } else if (!swiper.params.autoplay.stopOnLastSlide) {
          swiper.slideTo(swiper.slides.length - 1, swiper.params.speed, true, true);
          swiper.emit('autoplay');
        } else {
          swiper.autoplay.stop();
        }
      } else if (swiper.params.loop) {
        swiper.loopFix();
        swiper.slideNext(swiper.params.speed, true, true);
        swiper.emit('autoplay');
      } else if (!swiper.isEnd) {
        swiper.slideNext(swiper.params.speed, true, true);
        swiper.emit('autoplay');
      } else if (!swiper.params.autoplay.stopOnLastSlide) {
        swiper.slideTo(0, swiper.params.speed, true, true);
        swiper.emit('autoplay');
      } else {
        swiper.autoplay.stop();
      }
    }, delay);
  },
  start() {
    const swiper = this;
    if (typeof swiper.autoplay.timeout !== 'undefined') return false;
    if (swiper.autoplay.running) return false;
    swiper.autoplay.running = true;
    swiper.emit('autoplayStart');
    swiper.autoplay.run();
    return true;
  },
  stop() {
    const swiper = this;
    if (!swiper.autoplay.running) return false;
    if (typeof swiper.autoplay.timeout === 'undefined') return false;

    if (swiper.autoplay.timeout) {
      clearTimeout(swiper.autoplay.timeout);
      swiper.autoplay.timeout = undefined;
    }
    swiper.autoplay.running = false;
    swiper.emit('autoplayStop');
    return true;
  },
  pause(speed) {
    const swiper = this;
    if (!swiper.autoplay.running) return;
    if (swiper.autoplay.paused) return;
    if (swiper.autoplay.timeout) clearTimeout(swiper.autoplay.timeout);
    swiper.autoplay.paused = true;
    if (speed === 0 || !swiper.params.autoplay.waitForTransition) {
      swiper.autoplay.paused = false;
      swiper.autoplay.run();
    } else {
      swiper.$wrapperEl[0].addEventListener('transitionend', swiper.autoplay.onTransitionEnd);
      swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.autoplay.onTransitionEnd);
    }
  },
};

var Autoplay$1 = {
  name: 'autoplay',
  params: {
    autoplay: {
      enabled: false,
      delay: 3000,
      waitForTransition: true,
      disableOnInteraction: true,
      stopOnLastSlide: false,
      reverseDirection: false,
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      autoplay: {
        running: false,
        paused: false,
        run: Autoplay.run.bind(swiper),
        start: Autoplay.start.bind(swiper),
        stop: Autoplay.stop.bind(swiper),
        pause: Autoplay.pause.bind(swiper),
        onTransitionEnd(e) {
          if (!swiper || swiper.destroyed || !swiper.$wrapperEl) return;
          if (e.target !== this) return;
          swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.autoplay.onTransitionEnd);
          swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.autoplay.onTransitionEnd);
          swiper.autoplay.paused = false;
          if (!swiper.autoplay.running) {
            swiper.autoplay.stop();
          } else {
            swiper.autoplay.run();
          }
        },
      },
    });
  },
  on: {
    init() {
      const swiper = this;
      if (swiper.params.autoplay.enabled) {
        swiper.autoplay.start();
      }
    },
    beforeTransitionStart(speed, internal) {
      const swiper = this;
      if (swiper.autoplay.running) {
        if (internal || !swiper.params.autoplay.disableOnInteraction) {
          swiper.autoplay.pause(speed);
        } else {
          swiper.autoplay.stop();
        }
      }
    },
    sliderFirstMove() {
      const swiper = this;
      if (swiper.autoplay.running) {
        if (swiper.params.autoplay.disableOnInteraction) {
          swiper.autoplay.stop();
        } else {
          swiper.autoplay.pause();
        }
      }
    },
    destroy() {
      const swiper = this;
      if (swiper.autoplay.running) {
        swiper.autoplay.stop();
      }
    },
  },
};

const Fade = {
  setTranslate() {
    const swiper = this;
    const { slides } = swiper;
    for (let i = 0; i < slides.length; i += 1) {
      const $slideEl = swiper.slides.eq(i);
      const offset = $slideEl[0].swiperSlideOffset;
      let tx = -offset;
      if (!swiper.params.virtualTranslate) tx -= swiper.translate;
      let ty = 0;
      if (!swiper.isHorizontal()) {
        ty = tx;
        tx = 0;
      }
      const slideOpacity = swiper.params.fadeEffect.crossFade ?
        Math.max(1 - Math.abs($slideEl[0].progress), 0) :
        1 + Math.min(Math.max($slideEl[0].progress, -1), 0);
      $slideEl
        .css({
          opacity: slideOpacity,
        })
        .transform(`translate3d(${tx}px, ${ty}px, 0px)`);
    }
  },
  setTransition(duration) {
    const swiper = this;
    const { slides, $wrapperEl } = swiper;
    slides.transition(duration);
    if (swiper.params.virtualTranslate && duration !== 0) {
      let eventTriggered = false;
      slides.transitionEnd(() => {
        if (eventTriggered) return;
        if (!swiper || swiper.destroyed) return;
        eventTriggered = true;
        swiper.animating = false;
        const triggerEvents = ['webkitTransitionEnd', 'transitionend'];
        for (let i = 0; i < triggerEvents.length; i += 1) {
          $wrapperEl.trigger(triggerEvents[i]);
        }
      });
    }
  },
};

var EffectFade = {
  name: 'effect-fade',
  params: {
    fadeEffect: {
      crossFade: false,
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      fadeEffect: {
        setTranslate: Fade.setTranslate.bind(swiper),
        setTransition: Fade.setTransition.bind(swiper),
      },
    });
  },
  on: {
    beforeInit() {
      const swiper = this;
      if (swiper.params.effect !== 'fade') return;
      swiper.classNames.push(`${swiper.params.containerModifierClass}fade`);
      const overwriteParams = {
        slidesPerView: 1,
        slidesPerColumn: 1,
        slidesPerGroup: 1,
        watchSlidesProgress: true,
        spaceBetween: 0,
        virtualTranslate: true,
      };
      Utils.extend(swiper.params, overwriteParams);
      Utils.extend(swiper.originalParams, overwriteParams);
    },
    setTranslate() {
      const swiper = this;
      if (swiper.params.effect !== 'fade') return;
      swiper.fadeEffect.setTranslate();
    },
    setTransition(duration) {
      const swiper = this;
      if (swiper.params.effect !== 'fade') return;
      swiper.fadeEffect.setTransition(duration);
    },
  },
};

const Cube = {
  setTranslate() {
    const swiper = this;
    const {
      $el, $wrapperEl, slides, width: swiperWidth, height: swiperHeight, rtlTranslate: rtl, size: swiperSize,
    } = swiper;
    const params = swiper.params.cubeEffect;
    const isHorizontal = swiper.isHorizontal();
    const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
    let wrapperRotate = 0;
    let $cubeShadowEl;
    if (params.shadow) {
      if (isHorizontal) {
        $cubeShadowEl = $wrapperEl.find('.swiper-cube-shadow');
        if ($cubeShadowEl.length === 0) {
          $cubeShadowEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])('<div class="swiper-cube-shadow"></div>');
          $wrapperEl.append($cubeShadowEl);
        }
        $cubeShadowEl.css({ height: `${swiperWidth}px` });
      } else {
        $cubeShadowEl = $el.find('.swiper-cube-shadow');
        if ($cubeShadowEl.length === 0) {
          $cubeShadowEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])('<div class="swiper-cube-shadow"></div>');
          $el.append($cubeShadowEl);
        }
      }
    }
    for (let i = 0; i < slides.length; i += 1) {
      const $slideEl = slides.eq(i);
      let slideIndex = i;
      if (isVirtual) {
        slideIndex = parseInt($slideEl.attr('data-swiper-slide-index'), 10);
      }
      let slideAngle = slideIndex * 90;
      let round = Math.floor(slideAngle / 360);
      if (rtl) {
        slideAngle = -slideAngle;
        round = Math.floor(-slideAngle / 360);
      }
      const progress = Math.max(Math.min($slideEl[0].progress, 1), -1);
      let tx = 0;
      let ty = 0;
      let tz = 0;
      if (slideIndex % 4 === 0) {
        tx = -round * 4 * swiperSize;
        tz = 0;
      } else if ((slideIndex - 1) % 4 === 0) {
        tx = 0;
        tz = -round * 4 * swiperSize;
      } else if ((slideIndex - 2) % 4 === 0) {
        tx = swiperSize + (round * 4 * swiperSize);
        tz = swiperSize;
      } else if ((slideIndex - 3) % 4 === 0) {
        tx = -swiperSize;
        tz = (3 * swiperSize) + (swiperSize * 4 * round);
      }
      if (rtl) {
        tx = -tx;
      }

      if (!isHorizontal) {
        ty = tx;
        tx = 0;
      }

      const transform = `rotateX(${isHorizontal ? 0 : -slideAngle}deg) rotateY(${isHorizontal ? slideAngle : 0}deg) translate3d(${tx}px, ${ty}px, ${tz}px)`;
      if (progress <= 1 && progress > -1) {
        wrapperRotate = (slideIndex * 90) + (progress * 90);
        if (rtl) wrapperRotate = (-slideIndex * 90) - (progress * 90);
      }
      $slideEl.transform(transform);
      if (params.slideShadows) {
        // Set shadows
        let shadowBefore = isHorizontal ? $slideEl.find('.swiper-slide-shadow-left') : $slideEl.find('.swiper-slide-shadow-top');
        let shadowAfter = isHorizontal ? $slideEl.find('.swiper-slide-shadow-right') : $slideEl.find('.swiper-slide-shadow-bottom');
        if (shadowBefore.length === 0) {
          shadowBefore = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(`<div class="swiper-slide-shadow-${isHorizontal ? 'left' : 'top'}"></div>`);
          $slideEl.append(shadowBefore);
        }
        if (shadowAfter.length === 0) {
          shadowAfter = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(`<div class="swiper-slide-shadow-${isHorizontal ? 'right' : 'bottom'}"></div>`);
          $slideEl.append(shadowAfter);
        }
        if (shadowBefore.length) shadowBefore[0].style.opacity = Math.max(-progress, 0);
        if (shadowAfter.length) shadowAfter[0].style.opacity = Math.max(progress, 0);
      }
    }
    $wrapperEl.css({
      '-webkit-transform-origin': `50% 50% -${swiperSize / 2}px`,
      '-moz-transform-origin': `50% 50% -${swiperSize / 2}px`,
      '-ms-transform-origin': `50% 50% -${swiperSize / 2}px`,
      'transform-origin': `50% 50% -${swiperSize / 2}px`,
    });

    if (params.shadow) {
      if (isHorizontal) {
        $cubeShadowEl.transform(`translate3d(0px, ${(swiperWidth / 2) + params.shadowOffset}px, ${-swiperWidth / 2}px) rotateX(90deg) rotateZ(0deg) scale(${params.shadowScale})`);
      } else {
        const shadowAngle = Math.abs(wrapperRotate) - (Math.floor(Math.abs(wrapperRotate) / 90) * 90);
        const multiplier = 1.5 - (
          (Math.sin((shadowAngle * 2 * Math.PI) / 360) / 2) +
          (Math.cos((shadowAngle * 2 * Math.PI) / 360) / 2)
        );
        const scale1 = params.shadowScale;
        const scale2 = params.shadowScale / multiplier;
        const offset = params.shadowOffset;
        $cubeShadowEl.transform(`scale3d(${scale1}, 1, ${scale2}) translate3d(0px, ${(swiperHeight / 2) + offset}px, ${-swiperHeight / 2 / scale2}px) rotateX(-90deg)`);
      }
    }
    const zFactor = (Browser.isSafari || Browser.isUiWebView) ? (-swiperSize / 2) : 0;
    $wrapperEl
      .transform(`translate3d(0px,0,${zFactor}px) rotateX(${swiper.isHorizontal() ? 0 : wrapperRotate}deg) rotateY(${swiper.isHorizontal() ? -wrapperRotate : 0}deg)`);
  },
  setTransition(duration) {
    const swiper = this;
    const { $el, slides } = swiper;
    slides
      .transition(duration)
      .find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left')
      .transition(duration);
    if (swiper.params.cubeEffect.shadow && !swiper.isHorizontal()) {
      $el.find('.swiper-cube-shadow').transition(duration);
    }
  },
};

var EffectCube = {
  name: 'effect-cube',
  params: {
    cubeEffect: {
      slideShadows: true,
      shadow: true,
      shadowOffset: 20,
      shadowScale: 0.94,
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      cubeEffect: {
        setTranslate: Cube.setTranslate.bind(swiper),
        setTransition: Cube.setTransition.bind(swiper),
      },
    });
  },
  on: {
    beforeInit() {
      const swiper = this;
      if (swiper.params.effect !== 'cube') return;
      swiper.classNames.push(`${swiper.params.containerModifierClass}cube`);
      swiper.classNames.push(`${swiper.params.containerModifierClass}3d`);
      const overwriteParams = {
        slidesPerView: 1,
        slidesPerColumn: 1,
        slidesPerGroup: 1,
        watchSlidesProgress: true,
        resistanceRatio: 0,
        spaceBetween: 0,
        centeredSlides: false,
        virtualTranslate: true,
      };
      Utils.extend(swiper.params, overwriteParams);
      Utils.extend(swiper.originalParams, overwriteParams);
    },
    setTranslate() {
      const swiper = this;
      if (swiper.params.effect !== 'cube') return;
      swiper.cubeEffect.setTranslate();
    },
    setTransition(duration) {
      const swiper = this;
      if (swiper.params.effect !== 'cube') return;
      swiper.cubeEffect.setTransition(duration);
    },
  },
};

const Flip = {
  setTranslate() {
    const swiper = this;
    const { slides, rtlTranslate: rtl } = swiper;
    for (let i = 0; i < slides.length; i += 1) {
      const $slideEl = slides.eq(i);
      let progress = $slideEl[0].progress;
      if (swiper.params.flipEffect.limitRotation) {
        progress = Math.max(Math.min($slideEl[0].progress, 1), -1);
      }
      const offset = $slideEl[0].swiperSlideOffset;
      const rotate = -180 * progress;
      let rotateY = rotate;
      let rotateX = 0;
      let tx = -offset;
      let ty = 0;
      if (!swiper.isHorizontal()) {
        ty = tx;
        tx = 0;
        rotateX = -rotateY;
        rotateY = 0;
      } else if (rtl) {
        rotateY = -rotateY;
      }

      $slideEl[0].style.zIndex = -Math.abs(Math.round(progress)) + slides.length;

      if (swiper.params.flipEffect.slideShadows) {
        // Set shadows
        let shadowBefore = swiper.isHorizontal() ? $slideEl.find('.swiper-slide-shadow-left') : $slideEl.find('.swiper-slide-shadow-top');
        let shadowAfter = swiper.isHorizontal() ? $slideEl.find('.swiper-slide-shadow-right') : $slideEl.find('.swiper-slide-shadow-bottom');
        if (shadowBefore.length === 0) {
          shadowBefore = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(`<div class="swiper-slide-shadow-${swiper.isHorizontal() ? 'left' : 'top'}"></div>`);
          $slideEl.append(shadowBefore);
        }
        if (shadowAfter.length === 0) {
          shadowAfter = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(`<div class="swiper-slide-shadow-${swiper.isHorizontal() ? 'right' : 'bottom'}"></div>`);
          $slideEl.append(shadowAfter);
        }
        if (shadowBefore.length) shadowBefore[0].style.opacity = Math.max(-progress, 0);
        if (shadowAfter.length) shadowAfter[0].style.opacity = Math.max(progress, 0);
      }
      $slideEl
        .transform(`translate3d(${tx}px, ${ty}px, 0px) rotateX(${rotateX}deg) rotateY(${rotateY}deg)`);
    }
  },
  setTransition(duration) {
    const swiper = this;
    const { slides, activeIndex, $wrapperEl } = swiper;
    slides
      .transition(duration)
      .find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left')
      .transition(duration);
    if (swiper.params.virtualTranslate && duration !== 0) {
      let eventTriggered = false;
      // eslint-disable-next-line
      slides.eq(activeIndex).transitionEnd(function onTransitionEnd() {
        if (eventTriggered) return;
        if (!swiper || swiper.destroyed) return;
        // if (!$(this).hasClass(swiper.params.slideActiveClass)) return;
        eventTriggered = true;
        swiper.animating = false;
        const triggerEvents = ['webkitTransitionEnd', 'transitionend'];
        for (let i = 0; i < triggerEvents.length; i += 1) {
          $wrapperEl.trigger(triggerEvents[i]);
        }
      });
    }
  },
};

var EffectFlip = {
  name: 'effect-flip',
  params: {
    flipEffect: {
      slideShadows: true,
      limitRotation: true,
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      flipEffect: {
        setTranslate: Flip.setTranslate.bind(swiper),
        setTransition: Flip.setTransition.bind(swiper),
      },
    });
  },
  on: {
    beforeInit() {
      const swiper = this;
      if (swiper.params.effect !== 'flip') return;
      swiper.classNames.push(`${swiper.params.containerModifierClass}flip`);
      swiper.classNames.push(`${swiper.params.containerModifierClass}3d`);
      const overwriteParams = {
        slidesPerView: 1,
        slidesPerColumn: 1,
        slidesPerGroup: 1,
        watchSlidesProgress: true,
        spaceBetween: 0,
        virtualTranslate: true,
      };
      Utils.extend(swiper.params, overwriteParams);
      Utils.extend(swiper.originalParams, overwriteParams);
    },
    setTranslate() {
      const swiper = this;
      if (swiper.params.effect !== 'flip') return;
      swiper.flipEffect.setTranslate();
    },
    setTransition(duration) {
      const swiper = this;
      if (swiper.params.effect !== 'flip') return;
      swiper.flipEffect.setTransition(duration);
    },
  },
};

const Coverflow = {
  setTranslate() {
    const swiper = this;
    const {
      width: swiperWidth, height: swiperHeight, slides, $wrapperEl, slidesSizesGrid,
    } = swiper;
    const params = swiper.params.coverflowEffect;
    const isHorizontal = swiper.isHorizontal();
    const transform = swiper.translate;
    const center = isHorizontal ? -transform + (swiperWidth / 2) : -transform + (swiperHeight / 2);
    const rotate = isHorizontal ? params.rotate : -params.rotate;
    const translate = params.depth;
    // Each slide offset from center
    for (let i = 0, length = slides.length; i < length; i += 1) {
      const $slideEl = slides.eq(i);
      const slideSize = slidesSizesGrid[i];
      const slideOffset = $slideEl[0].swiperSlideOffset;
      const offsetMultiplier = ((center - slideOffset - (slideSize / 2)) / slideSize) * params.modifier;

      let rotateY = isHorizontal ? rotate * offsetMultiplier : 0;
      let rotateX = isHorizontal ? 0 : rotate * offsetMultiplier;
      // var rotateZ = 0
      let translateZ = -translate * Math.abs(offsetMultiplier);

      let translateY = isHorizontal ? 0 : params.stretch * (offsetMultiplier);
      let translateX = isHorizontal ? params.stretch * (offsetMultiplier) : 0;

      // Fix for ultra small values
      if (Math.abs(translateX) < 0.001) translateX = 0;
      if (Math.abs(translateY) < 0.001) translateY = 0;
      if (Math.abs(translateZ) < 0.001) translateZ = 0;
      if (Math.abs(rotateY) < 0.001) rotateY = 0;
      if (Math.abs(rotateX) < 0.001) rotateX = 0;

      const slideTransform = `translate3d(${translateX}px,${translateY}px,${translateZ}px)  rotateX(${rotateX}deg) rotateY(${rotateY}deg)`;

      $slideEl.transform(slideTransform);
      $slideEl[0].style.zIndex = -Math.abs(Math.round(offsetMultiplier)) + 1;
      if (params.slideShadows) {
        // Set shadows
        let $shadowBeforeEl = isHorizontal ? $slideEl.find('.swiper-slide-shadow-left') : $slideEl.find('.swiper-slide-shadow-top');
        let $shadowAfterEl = isHorizontal ? $slideEl.find('.swiper-slide-shadow-right') : $slideEl.find('.swiper-slide-shadow-bottom');
        if ($shadowBeforeEl.length === 0) {
          $shadowBeforeEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(`<div class="swiper-slide-shadow-${isHorizontal ? 'left' : 'top'}"></div>`);
          $slideEl.append($shadowBeforeEl);
        }
        if ($shadowAfterEl.length === 0) {
          $shadowAfterEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(`<div class="swiper-slide-shadow-${isHorizontal ? 'right' : 'bottom'}"></div>`);
          $slideEl.append($shadowAfterEl);
        }
        if ($shadowBeforeEl.length) $shadowBeforeEl[0].style.opacity = offsetMultiplier > 0 ? offsetMultiplier : 0;
        if ($shadowAfterEl.length) $shadowAfterEl[0].style.opacity = (-offsetMultiplier) > 0 ? -offsetMultiplier : 0;
      }
    }

    // Set correct perspective for IE10
    if (Support.pointerEvents || Support.prefixedPointerEvents) {
      const ws = $wrapperEl[0].style;
      ws.perspectiveOrigin = `${center}px 50%`;
    }
  },
  setTransition(duration) {
    const swiper = this;
    swiper.slides
      .transition(duration)
      .find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left')
      .transition(duration);
  },
};

var EffectCoverflow = {
  name: 'effect-coverflow',
  params: {
    coverflowEffect: {
      rotate: 50,
      stretch: 0,
      depth: 100,
      modifier: 1,
      slideShadows: true,
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      coverflowEffect: {
        setTranslate: Coverflow.setTranslate.bind(swiper),
        setTransition: Coverflow.setTransition.bind(swiper),
      },
    });
  },
  on: {
    beforeInit() {
      const swiper = this;
      if (swiper.params.effect !== 'coverflow') return;

      swiper.classNames.push(`${swiper.params.containerModifierClass}coverflow`);
      swiper.classNames.push(`${swiper.params.containerModifierClass}3d`);

      swiper.params.watchSlidesProgress = true;
      swiper.originalParams.watchSlidesProgress = true;
    },
    setTranslate() {
      const swiper = this;
      if (swiper.params.effect !== 'coverflow') return;
      swiper.coverflowEffect.setTranslate();
    },
    setTransition(duration) {
      const swiper = this;
      if (swiper.params.effect !== 'coverflow') return;
      swiper.coverflowEffect.setTransition(duration);
    },
  },
};

// Swiper Class

Swiper.use([
  Device$1,
  Browser$1,
  Support$1,
  Resize,
  Observer$1,
  Virtual$1,
  Navigation$1,
  Pagination$1,
  Scrollbar$1,
  Parallax$1,
  Zoom$1,
  Lazy$3,
  Controller$1,
  A11y,
  Autoplay$1,
  EffectFade,
  EffectCube,
  EffectFlip,
  EffectCoverflow,
]);

function initSwipers(swiperEl) {
  const app = this;
  const $swiperEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(swiperEl);
  if ($swiperEl.length === 0) return;
  if ($swiperEl[0].swiper) return;
  let initialSlide;
  let params = {};
  let isTabs;
  let isRoutableTabs;
  if ($swiperEl.hasClass('tabs-swipeable-wrap')) {
    $swiperEl
      .addClass('swiper-container')
      .children('.tabs')
      .addClass('swiper-wrapper')
      .children('.tab')
      .addClass('swiper-slide');
    initialSlide = $swiperEl.children('.tabs').children('.tab-active').index();
    isTabs = true;
    isRoutableTabs = $swiperEl.find('.tabs-routable').length > 0;
  }
  if ($swiperEl.attr('data-swiper')) {
    params = JSON.parse($swiperEl.attr('data-swiper'));
  } else {
    params = $swiperEl.dataset();
    Object.keys(params).forEach((key) => {
      const value = params[key];
      if (typeof value === 'string' && value.indexOf('{') === 0 && value.indexOf('}') > 0) {
        try {
          params[key] = JSON.parse(value);
        } catch (e) {
          // not JSON
        }
      }
    });
  }
  if (typeof params.initialSlide === 'undefined' && typeof initialSlide !== 'undefined') {
    params.initialSlide = initialSlide;
  }

  const swiper = app.swiper.create($swiperEl[0], params);
  if (isTabs) {
    swiper.on('slideChange', () => {
      if (isRoutableTabs) {
        let view = app.views.get($swiperEl.parents('.view'));
        if (!view) view = app.views.main;
        const router = view.router;
        const tabRoute = router.findTabRoute(swiper.slides.eq(swiper.activeIndex)[0]);
        if (tabRoute) router.navigate(tabRoute.path);
      } else {
        app.tab.show({
          tabEl: swiper.slides.eq(swiper.activeIndex),
        });
      }
    });
  }
}

var Swiper$1 = {
  name: 'swiper',
  static: {
    Swiper,
  },
  create() {
    const app = this;
    app.swiper = ConstructorMethods({
      defaultSelector: '.swiper-container',
      constructor: Swiper,
      domProp: 'swiper',
    });
  },
  on: {
    pageBeforeRemove(page) {
      const app = this;
      page.$el.find('.swiper-init, .tabs-swipeable-wrap').each((index, swiperEl) => {
        app.swiper.destroy(swiperEl);
      });
    },
    pageMounted(page) {
      const app = this;
      page.$el.find('.tabs-swipeable-wrap').each((index, swiperEl) => {
        initSwipers.call(app, swiperEl);
      });
    },
    pageInit(page) {
      const app = this;
      page.$el.find('.swiper-init, .tabs-swipeable-wrap').each((index, swiperEl) => {
        initSwipers.call(app, swiperEl);
      });
    },
    pageReinit(page) {
      const app = this;
      page.$el.find('.swiper-init, .tabs-swipeable-wrap').each((index, swiperEl) => {
        const swiper = app.swiper.get(swiperEl);
        if (swiper && swiper.update) swiper.update();
      });
    },
    tabMounted(tabEl) {
      const app = this;
      Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(tabEl).find('.swiper-init, .tabs-swipeable-wrap').each((index, swiperEl) => {
        initSwipers.call(app, swiperEl);
      });
    },
    tabShow(tabEl) {
      const app = this;
      Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(tabEl).find('.swiper-init, .tabs-swipeable-wrap').each((index, swiperEl) => {
        const swiper = app.swiper.get(swiperEl);
        if (swiper && swiper.update) swiper.update();
      });
    },
    tabBeforeRemove(tabEl) {
      const app = this;
      Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(tabEl).find('.swiper-init, .tabs-swipeable-wrap').each((index, swiperEl) => {
        app.swiper.destroy(swiperEl);
      });
    },
  },
};

/* eslint indent: ["off"] */

class PhotoBrowser extends Framework7Class {
  constructor(app, params = {}) {
    super(params, [app]);

    const pb = this;
    pb.app = app;

    const defaults = Utils.extend({
      on: {},
    }, app.params.photoBrowser);

    // Extend defaults with modules params
    pb.useModulesParams(defaults);

    pb.params = Utils.extend(defaults, params);

    Utils.extend(pb, {
      exposed: false,
      opened: false,
      activeIndex: pb.params.swiper.initialSlide,
      url: pb.params.url,
      view: pb.params.view || app.views.main,
      swipeToClose: {
        allow: true,
        isTouched: false,
        diff: undefined,
        start: undefined,
        current: undefined,
        started: false,
        activeSlide: undefined,
        timeStart: undefined,
      },
    });

    // Install Modules
    pb.useModules();

    // Init
    pb.init();
  }
  onSlideChange(swiper) {
    const pb = this;
    pb.activeIndex = swiper.activeIndex;

    let current = swiper.activeIndex + 1;
    let total = pb.params.virtualSlides ? pb.params.photos.length : swiper.slides.length;
    if (swiper.params.loop) {
      total -= 2;
      current -= swiper.loopedSlides;
      if (current < 1) current = total + current;
      if (current > total) current -= total;
    }

    const $activeSlideEl = pb.params.virtualSlides
      ? swiper.$wrapperEl.find(`.swiper-slide[data-swiper-slide-index="${swiper.activeIndex}"]`)
      : swiper.slides.eq(swiper.activeIndex);
    const $previousSlideEl = pb.params.virtualSlides
      ? swiper.$wrapperEl.find(`.swiper-slide[data-swiper-slide-index="${swiper.previousIndex}"]`)
      : swiper.slides.eq(swiper.previousIndex);

    let $currentEl = pb.$el.find('.photo-browser-current');
    let $totalEl = pb.$el.find('.photo-browser-total');
    if (pb.params.type === 'page' && pb.params.navbar && $currentEl.length === 0 && pb.app.theme === 'ios') {
      const navbarEl = pb.app.navbar.getElByPage(pb.$el);
      if (navbarEl) {
        $currentEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(navbarEl).find('.photo-browser-current');
        $totalEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(navbarEl).find('.photo-browser-total');
      }
    }
    $currentEl.text(current);
    $totalEl.text(total);

    // Update captions
    if (pb.captions.length > 0) {
      const captionIndex = swiper.params.loop ? $activeSlideEl.attr('data-swiper-slide-index') : pb.activeIndex;
      pb.$captionsContainerEl.find('.photo-browser-caption-active').removeClass('photo-browser-caption-active');
      pb.$captionsContainerEl.find(`[data-caption-index="${captionIndex}"]`).addClass('photo-browser-caption-active');
    }

    // Stop Video
    const previousSlideVideo = $previousSlideEl.find('video');
    if (previousSlideVideo.length > 0) {
      if ('pause' in previousSlideVideo[0]) previousSlideVideo[0].pause();
    }
  }
  onTouchStart() {
    const pb = this;
    const swipeToClose = pb.swipeToClose;
    if (!swipeToClose.allow) return;
    swipeToClose.isTouched = true;
  }
  onTouchMove(e) {
    const pb = this;
    const swipeToClose = pb.swipeToClose;

    if (!swipeToClose.isTouched) return;
    if (!swipeToClose.started) {
      swipeToClose.started = true;
      swipeToClose.start = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
      if (pb.params.virtualSlides) {
        swipeToClose.activeSlide = pb.swiper.$wrapperEl.children('.swiper-slide-active');
      } else {
        swipeToClose.activeSlide = pb.swiper.slides.eq(pb.swiper.activeIndex);
      }
      swipeToClose.timeStart = Utils.now();
    }
    e.preventDefault();
    swipeToClose.current = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
    swipeToClose.diff = swipeToClose.start - swipeToClose.current;
    const opacity = 1 - (Math.abs(swipeToClose.diff) / 300);
    const color = pb.exposed || pb.params.theme === 'dark' ? 0 : 255;
    swipeToClose.activeSlide.transform(`translate3d(0,${-swipeToClose.diff}px,0)`);
    pb.swiper.$el.css('background-color', `rgba(${color}, ${color}, ${color}, ${opacity})`).transition(0);
  }
  onTouchEnd() {
    const pb = this;
    const swipeToClose = pb.swipeToClose;
    swipeToClose.isTouched = false;
    if (!swipeToClose.started) {
      swipeToClose.started = false;
      return;
    }
    swipeToClose.started = false;
    swipeToClose.allow = false;
    const diff = Math.abs(swipeToClose.diff);
    const timeDiff = (new Date()).getTime() - swipeToClose.timeStart;
    if ((timeDiff < 300 && diff > 20) || (timeDiff >= 300 && diff > 100)) {
      Utils.nextTick(() => {
        if (pb.$el) {
          if (swipeToClose.diff < 0) pb.$el.addClass('swipe-close-to-bottom');
          else pb.$el.addClass('swipe-close-to-top');
        }
        pb.emit('local::swipeToClose', pb);
        pb.close();
        swipeToClose.allow = true;
      });
      return;
    }
    if (diff !== 0) {
      swipeToClose.activeSlide.addClass('photo-browser-transitioning').transitionEnd(() => {
        swipeToClose.allow = true;
        swipeToClose.activeSlide.removeClass('photo-browser-transitioning');
      });
    } else {
      swipeToClose.allow = true;
    }
    pb.swiper.$el.transition('').css('background-color', '');
    swipeToClose.activeSlide.transform('');
  }

  // Render Functions
  renderNavbar() {
    const pb = this;
    if (pb.params.renderNavbar) return pb.params.renderNavbar.call(pb);

    let iconsColor = pb.params.iconsColor;
    if (!pb.params.iconsColor && pb.params.theme === 'dark') iconsColor = 'white';

    const backLinkText = pb.app.theme === 'ios' && pb.params.backLinkText ? pb.params.backLinkText : '';

    const isPopup = pb.params.type !== 'page';
    const navbarHtml = `
      <div class="navbar">
        <div class="navbar-inner sliding">
          <div class="left">
            <a href="#" class="link ${isPopup ? 'popup-close' : ''} ${!backLinkText ? 'icon-only' : ''} ${!isPopup ? 'back' : ''}" ${isPopup ? 'data-popup=".photo-browser-popup"' : ''}>
              <i class="icon icon-back ${iconsColor ? `color-${iconsColor}` : ''}"></i>
              ${backLinkText ? `<span>${backLinkText}</span>` : ''}
            </a>
          </div>
          <div class="title">
            <span class="photo-browser-current"></span>
            <span class="photo-browser-of">${pb.params.navbarOfText}</span>
            <span class="photo-browser-total"></span>
          </div>
          <div class="right"></div>
        </div>
      </div>
    `.trim();
    return navbarHtml;
  }
  renderToolbar() {
    const pb = this;
    if (pb.params.renderToolbar) return pb.params.renderToolbar.call(pb);

    let iconsColor = pb.params.iconsColor;
    if (!pb.params.iconsColor && pb.params.theme === 'dark') iconsColor = 'white';

    const toolbarHtml = `
      <div class="toolbar tabbar toolbar-bottom-md">
        <div class="toolbar-inner">
          <a href="#" class="link photo-browser-prev">
            <i class="icon icon-back ${iconsColor ? `color-${iconsColor}` : ''}"></i>
          </a>
          <a href="#" class="link photo-browser-next">
            <i class="icon icon-forward ${iconsColor ? `color-${iconsColor}` : ''}"></i>
          </a>
        </div>
      </div>
    `.trim();
    return toolbarHtml;
  }
  renderCaption(caption, index) {
    const pb = this;
    if (pb.params.renderCaption) return pb.params.renderCaption.call(pb, caption, index);
    const captionHtml = `
      <div class="photo-browser-caption" data-caption-index="${index}">
        ${caption}
      </div>
    `.trim();
    return captionHtml;
  }
  renderObject(photo, index) {
    const pb = this;
    if (pb.params.renderObject) return pb.params.renderObject.call(pb, photo, index);
    const objHtml = `
      <div class="photo-browser-slide photo-browser-object-slide swiper-slide" data-swiper-slide-index="${index}">${photo.html ? photo.html : photo}</div>
    `;
    return objHtml;
  }
  renderLazyPhoto(photo, index) {
    const pb = this;
    if (pb.params.renderLazyPhoto) return pb.params.renderLazyPhoto.call(pb, photo, index);
    const photoHtml = `
      <div class="photo-browser-slide photo-browser-slide-lazy swiper-slide" data-swiper-slide-index="${index}">
          <div class="preloader swiper-lazy-preloader ${pb.params.theme === 'dark' ? 'color-white' : ''}">${pb.app.theme === 'md' ? Utils.mdPreloaderContent : ''}</div>
          <span class="swiper-zoom-container">
              <img data-src="${photo.url ? photo.url : photo}" class="swiper-lazy">
          </span>
      </div>
    `.trim();
    return photoHtml;
  }
  renderPhoto(photo, index) {
    const pb = this;
    if (pb.params.renderPhoto) return pb.params.renderPhoto.call(pb, photo, index);
    const photoHtml = `
      <div class="photo-browser-slide swiper-slide" data-swiper-slide-index="${index}">
        <span class="swiper-zoom-container">
          <img src="${photo.url ? photo.url : photo}">
        </span>
      </div>
    `.trim();
    return photoHtml;
  }
  render() {
    const pb = this;
    if (pb.params.render) return pb.params.render.call(pb, pb.params);
    const html = `
      <div class="photo-browser photo-browser-${pb.params.theme}">
        <div class="view">
          <div class="page photo-browser-page photo-browser-page-${pb.params.theme} no-toolbar ${!pb.params.navbar ? 'no-navbar' : ''}" data-name="photo-browser-page">
            ${pb.params.navbar ? pb.renderNavbar() : ''}
            ${pb.params.toolbar ? pb.renderToolbar() : ''}
            <div class="photo-browser-captions photo-browser-captions-${pb.params.captionsTheme || pb.params.theme}">
              ${pb.params.photos.map((photo, index) => {
                if (photo.caption) return pb.renderCaption(photo.caption, index);
                return '';
              }).join(' ')}
            </div>
            <div class="photo-browser-swiper-container swiper-container">
              <div class="photo-browser-swiper-wrapper swiper-wrapper">
                ${pb.params.virtualSlides ? '' : pb.params.photos.map((photo, index) => {
                  if (photo.html || ((typeof photo === 'string' || photo instanceof String) && photo.indexOf('<') >= 0 && photo.indexOf('>') >= 0)) {
                    return pb.renderObject(photo, index);
                  } else if (pb.params.swiper.lazy === true || (pb.params.swiper.lazy && pb.params.swiper.lazy.enabled)) {
                    return pb.renderLazyPhoto(photo, index);
                  }
                  return pb.renderPhoto(photo, index);
                }).join(' ')}
              </div>
            </div>
          </div>
        </div>
      </div>
    `.trim();
    return html;
  }
  renderStandalone() {
    const pb = this;
    if (pb.params.renderStandalone) return pb.params.renderStandalone.call(pb);
    const standaloneHtml = `<div class="popup photo-browser-popup photo-browser-standalone popup-tablet-fullscreen">${pb.render()}</div>`;
    return standaloneHtml;
  }
  renderPage() {
    const pb = this;
    if (pb.params.renderPage) return pb.params.renderPage.call(pb);
    const pageHtml = pb.render();

    return pageHtml;
  }
  renderPopup() {
    const pb = this;
    if (pb.params.renderPopup) return pb.params.renderPopup.call(pb);
    const popupHtml = `<div class="popup photo-browser-popup">${pb.render()}</div>`;

    return popupHtml;
  }

  // Callbacks
  onOpen(type, el) {
    const pb = this;
    const app = pb.app;
    const $el = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(el);

    $el[0].f7PhotoBrowser = pb;

    pb.$el = $el;
    pb.el = $el[0];
    pb.openedIn = type;
    pb.opened = true;

    pb.$swiperContainerEl = pb.$el.find('.photo-browser-swiper-container');
    pb.$swiperWrapperEl = pb.$el.find('.photo-browser-swiper-wrapper');
    pb.slides = pb.$el.find('.photo-browser-slide');
    pb.$captionsContainerEl = pb.$el.find('.photo-browser-captions');
    pb.captions = pb.$el.find('.photo-browser-caption');

    // Init Swiper
    const swiperParams = Utils.extend({}, pb.params.swiper, {
      initialSlide: pb.activeIndex,
      on: {
        tap(e) {
          pb.emit('local::tap', e);
        },
        click(e) {
          if (pb.params.exposition) {
            pb.expositionToggle();
          }
          pb.emit('local::click', e);
        },
        doubleTap(e) {
          pb.emit('local::doubleTap', e);
        },
        slideChange(...args) {
          const swiper = this;
          pb.onSlideChange(swiper);
          pb.emit('local::slideChange', ...args);
        },
        transitionStart(...args) {
          pb.emit('local::transitionStart', ...args);
        },
        transitionEnd(...args) {
          pb.emit('local::transitionEnd', ...args);
        },
        slideChangeStart(...args) {
          pb.emit('local::slideChangeTransitionStart', ...args);
        },
        slideChangeEnd(...args) {
          pb.emit('local::slideChangeTransitionEnd', ...args);
        },
        lazyImageLoad(...args) {
          pb.emit('local::lazyImageLoad', ...args);
        },
        lazyImageReady(...args) {
          const slideEl = args[0];
          Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(slideEl).removeClass('photo-browser-slide-lazy');
          pb.emit('local::lazyImageReady', ...args);
        },
      },
    });
    if (pb.params.swipeToClose && pb.params.type !== 'page') {
      Utils.extend(swiperParams.on, {
        touchStart(e) {
          pb.onTouchStart(e);
          pb.emit('local::touchStart', e);
        },
        touchMoveOpposite(e) {
          pb.onTouchMove(e);
          pb.emit('local::touchMoveOpposite', e);
        },
        touchEnd(e) {
          pb.onTouchEnd(e);
          pb.emit('local::touchEnd', e);
        },
      });
    }
    if (pb.params.virtualSlides) {
      Utils.extend(swiperParams, {
        virtual: {
          slides: pb.params.photos,
          renderSlide(photo, index) {
            if (photo.html || ((typeof photo === 'string' || photo instanceof String) && photo.indexOf('<') >= 0 && photo.indexOf('>') >= 0)) {
              return pb.renderObject(photo, index);
            } else if (pb.params.swiper.lazy === true || (pb.params.swiper.lazy && pb.params.swiper.lazy.enabled)) {
              return pb.renderLazyPhoto(photo, index);
            }
            return pb.renderPhoto(photo, index);
          },
        },
      });
    }

    pb.swiper = app.swiper.create(pb.$swiperContainerEl, swiperParams);

    if (pb.activeIndex === 0) {
      pb.onSlideChange(pb.swiper);
    }
    if (pb.$el) {
      pb.$el.trigger('photobrowser:open');
    }
    pb.emit('local::open photoBrowserOpen', pb);
  }
  onOpened() {
    const pb = this;

    if (pb.$el) {
      pb.$el.trigger('photobrowser:opened');
    }
    pb.emit('local::opened photoBrowserOpened', pb);
  }
  onClose() {
    const pb = this;
    if (pb.destroyed) return;

    // Destroy Swiper
    if (pb.swiper && pb.swiper.destroy) {
      pb.swiper.destroy(true, false);
      pb.swiper = null;
      delete pb.swiper;
    }
    if (pb.$el) {
      pb.$el.trigger('photobrowser:close');
    }
    pb.emit('local::close photoBrowserClose', pb);
  }
  onClosed() {
    const pb = this;
    if (pb.destroyed) return;
    pb.opened = false;
    pb.$el = null;
    pb.el = null;
    delete pb.$el;
    delete pb.el;
    if (pb.$el) {
      pb.$el.trigger('photobrowser:closed');
    }
    pb.emit('local::closed photoBrowserClosed', pb);
  }

  // Open
  openPage() {
    const pb = this;
    if (pb.opened) return pb;

    const pageHtml = pb.renderPage();

    pb.view.router.navigate({
      url: pb.url,
      route: {
        content: pageHtml,
        path: pb.url,
        on: {
          pageBeforeIn(e, page) {
            pb.view.$el.addClass(`with-photo-browser-page with-photo-browser-page-${pb.params.theme}`);
            pb.onOpen('page', page.el);
          },
          pageAfterIn(e, page) {
            pb.onOpened('page', page.el);
          },
          pageBeforeOut(e, page) {
            pb.view.$el.removeClass(`with-photo-browser-page with-photo-browser-page-exposed with-photo-browser-page-${pb.params.theme}`);
            pb.onClose('page', page.el);
          },
          pageAfterOut(e, page) {
            pb.onClosed('page', page.el);
          },
        },
      },
    });
    return pb;
  }

  openStandalone() {
    const pb = this;
    if (pb.opened) return pb;

    const standaloneHtml = pb.renderStandalone();

    const popupParams = {
      backdrop: false,
      content: standaloneHtml,
      on: {
        popupOpen(popup) {
          pb.onOpen('popup', popup.el);
        },
        popupOpened(popup) {
          pb.onOpened('popup', popup.el);
        },
        popupClose(popup) {
          pb.onClose('popup', popup.el);
        },
        popupClosed(popup) {
          pb.onClosed('popup', popup.el);
        },
      },
    };

    if (pb.params.routableModals) {
      pb.view.router.navigate({
        url: pb.url,
        route: {
          path: pb.url,
          popup: popupParams,
        },
      });
    } else {
      pb.modal = pb.app.popup.create(popupParams).open();
    }
    return pb;
  }

  openPopup() {
    const pb = this;
    if (pb.opened) return pb;

    const popupHtml = pb.renderPopup();

    const popupParams = {
      content: popupHtml,
      on: {
        popupOpen(popup) {
          pb.onOpen('popup', popup.el);
        },
        popupOpened(popup) {
          pb.onOpened('popup', popup.el);
        },
        popupClose(popup) {
          pb.onClose('popup', popup.el);
        },
        popupClosed(popup) {
          pb.onClosed('popup', popup.el);
        },
      },
    };

    if (pb.params.routableModals) {
      pb.view.router.navigate({
        url: pb.url,
        route: {
          path: pb.url,
          popup: popupParams,
        },
      });
    } else {
      pb.modal = pb.app.popup.create(popupParams).open();
    }
    return pb;
  }

  // Exposition
  expositionEnable() {
    const pb = this;
    if (pb.params.type === 'page') {
      pb.view.$el.addClass('with-photo-browser-page-exposed');
    }
    if (pb.$el) pb.$el.addClass('photo-browser-exposed');
    if (pb.params.expositionHideCaptions) pb.$captionsContainerEl.addClass('photo-browser-captions-exposed');
    pb.exposed = true;
    return pb;
  }
  expositionDisable() {
    const pb = this;
    if (pb.params.type === 'page') {
      pb.view.$el.removeClass('with-photo-browser-page-exposed');
    }
    if (pb.$el) pb.$el.removeClass('photo-browser-exposed');
    if (pb.params.expositionHideCaptions) pb.$captionsContainerEl.removeClass('photo-browser-captions-exposed');
    pb.exposed = false;
    return pb;
  }
  expositionToggle() {
    const pb = this;
    if (pb.params.type === 'page') {
      pb.view.$el.toggleClass('with-photo-browser-page-exposed');
    }
    if (pb.$el) pb.$el.toggleClass('photo-browser-exposed');
    if (pb.params.expositionHideCaptions) pb.$captionsContainerEl.toggleClass('photo-browser-captions-exposed');
    pb.exposed = !pb.exposed;
    return pb;
  }
  open(index) {
    const pb = this;
    const type = pb.params.type;
    if (pb.opened) {
      if (pb.swiper && typeof index !== 'undefined') {
        pb.swiper.slideTo(parseInt(index, 10));
      }
      return pb;
    } else if (typeof index !== 'undefined') {
      pb.activeIndex = index;
    }
    if (type === 'standalone') {
      pb.openStandalone();
    }
    if (type === 'page') {
      pb.openPage();
    }
    if (type === 'popup') {
      pb.openPopup();
    }
    return pb;
  }
  close() {
    const pb = this;
    if (!pb.opened) return pb;
    if (pb.params.routableModals || pb.openedIn === 'page') {
      if (pb.view) pb.view.router.back();
    } else {
      pb.modal.once('modalClosed', () => {
        Utils.nextTick(() => {
          pb.modal.destroy();
          delete pb.modal;
        });
      });
      pb.modal.close();
    }
    return pb;
  }
  // eslint-disable-next-line
  init() {}
  destroy() {
    let pb = this;
    pb.emit('local::beforeDestroy photoBrowserBeforeDestroy', pb);
    if (pb.$el) {
      pb.$el.trigger('photobrowser:beforedestroy');
      delete pb.$el[0].f7PhotoBrowser;
    }
    Utils.deleteProps(pb);
    pb = null;
  }
}

var PhotoBrowser$1 = {
  name: 'photoBrowser',
  params: {
    photoBrowser: {
      photos: [],
      exposition: true,
      expositionHideCaptions: false,
      type: 'standalone',
      navbar: true,
      toolbar: true,
      theme: 'light',
      captionsTheme: undefined,
      iconsColor: undefined,
      swipeToClose: true,
      backLinkText: 'Close',
      navbarOfText: 'of',
      view: undefined,
      url: 'photos/',
      routableModals: true,
      virtualSlides: true,

      renderNavbar: undefined,
      renderToolbar: undefined,
      renderCaption: undefined,
      renderObject: undefined,
      renderLazyPhoto: undefined,
      renderPhoto: undefined,
      renderPage: undefined,
      renderPopup: undefined,
      renderStandalone: undefined,

      swiper: {
        initialSlide: 0,
        spaceBetween: 20,
        speed: 300,
        loop: false,
        preloadImages: true,
        navigation: {
          nextEl: '.photo-browser-next',
          prevEl: '.photo-browser-prev',
        },
        zoom: {
          enabled: true,
          maxRatio: 3,
          minRatio: 1,
        },
        lazy: {
          enabled: true,
        },
      },
    },
  },
  create() {
    const app = this;
    app.photoBrowser = ConstructorMethods({
      defaultSelector: '.photo-browser',
      constructor: PhotoBrowser,
      app,
      domProp: 'f7PhotoBrowser',
    });
  },
  static: {
    PhotoBrowser,
  },
};

class Notification extends Modal {
  constructor(app, params) {
    const extendedParams = Utils.extend({
      on: {},
    }, app.params.notification, params);

    // Extends with open/close Modal methods;
    super(app, extendedParams);

    const notification = this;

    notification.app = app;

    notification.params = extendedParams;

    const {
      icon,
      title,
      titleRightText,
      subtitle,
      text,
      closeButton,
      closeTimeout,
      cssClass,
      closeOnClick,
    } = notification.params;

    let $el;
    if (!notification.params.el) {
      // Find Element
      const notificationHtml = notification.render({
        icon,
        title,
        titleRightText,
        subtitle,
        text,
        closeButton,
        cssClass,
      });

      $el = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(notificationHtml);
    } else {
      $el = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(notification.params.el);
    }

    if ($el && $el.length > 0 && $el[0].f7Modal) {
      return $el[0].f7Modal;
    }

    if ($el.length === 0) {
      return notification.destroy();
    }

    Utils.extend(notification, {
      $el,
      el: $el[0],
      type: 'notification',
    });

    $el[0].f7Modal = notification;

    if (closeButton) {
      $el.find('.notification-close-button').on('click', () => {
        notification.close();
      });
    }
    $el.on('click', (e) => {
      if (closeButton && Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(e.target).closest('.notification-close-button').length) {
        return;
      }
      notification.emit('local::click notificationClick', notification);
      if (closeOnClick) notification.close();
    });

    notification.on('beforeDestroy', () => {
      $el.off('click');
    });

    /* Touch Events */
    let isTouched;
    let isMoved;
    let isScrolling;
    let touchesDiff;
    let touchStartTime;
    let notificationHeight;
    const touchesStart = {};
    function handleTouchStart(e) {
      if (isTouched) return;
      isTouched = true;
      isMoved = false;
      isScrolling = undefined;
      touchStartTime = Utils.now();
      touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
      touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
    }
    function handleTouchMove(e) {
      if (!isTouched) return;
      const pageX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
      const pageY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
      if (typeof isScrolling === 'undefined') {
        isScrolling = !!(isScrolling || Math.abs(pageY - touchesStart.y) < Math.abs(pageX - touchesStart.x));
      }
      if (isScrolling) {
        isTouched = false;
        return;
      }
      e.preventDefault();
      if (!isMoved) {
        notification.$el.removeClass('notification-transitioning');
        notification.$el.transition(0);
        notificationHeight = notification.$el[0].offsetHeight / 2;
      }
      isMoved = true;
      touchesDiff = (pageY - touchesStart.y);
      let newTranslate = touchesDiff;
      if (touchesDiff > 0) {
        newTranslate = touchesDiff ** 0.8;
      }
      notification.$el.transform(`translate3d(0, ${newTranslate}px, 0)`);
    }
    function handleTouchEnd() {
      if (!isTouched || !isMoved) {
        isTouched = false;
        isMoved = false;
        return;
      }
      isTouched = false;
      isMoved = false;
      if (touchesDiff === 0) {
        return;
      }

      const timeDiff = Utils.now() - touchStartTime;
      notification.$el.transition('');
      notification.$el.addClass('notification-transitioning');
      notification.$el.transform('');

      if (
        (touchesDiff < -10 && timeDiff < 300) ||
        (-touchesDiff >= notificationHeight / 1)
      ) {
        notification.close();
      }
    }

    function attachTouchEvents() {
      {
        notification.$el.on(app.touchEvents.start, handleTouchStart, { passive: true });
        app.on('touchmove:active', handleTouchMove);
        app.on('touchend:passive', handleTouchEnd);
      }
    }
    function detachTouchEvents() {
      {
        notification.$el.off(app.touchEvents.start, handleTouchStart, { passive: true });
        app.off('touchmove:active', handleTouchMove);
        app.off('touchend:passive', handleTouchEnd);
      }
    }

    let timeoutId;
    function closeOnTimeout() {
      timeoutId = Utils.nextTick(() => {
        if (isTouched && isMoved) {
          closeOnTimeout();
          return;
        }
        notification.close();
      }, closeTimeout);
    }
    notification.on('open', () => {
      if (notification.params.swipeToClose) {
        attachTouchEvents();
      }
      Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])('.notification.modal-in').each((index, openedEl) => {
        const notificationInstance = app.notification.get(openedEl);
        if (openedEl !== notification.el && notificationInstance) {
          notificationInstance.close();
        }
      });
      if (closeTimeout) {
        closeOnTimeout();
      }
    });
    notification.on('close beforeDestroy', () => {
      if (notification.params.swipeToClose) {
        detachTouchEvents();
      }
      __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].clearTimeout(timeoutId);
    });

    return notification;
  }
  render() {
    const notification = this;
    if (notification.params.render) return notification.params.render.call(notification, notification);
    const { icon, title, titleRightText, subtitle, text, closeButton, cssClass } = notification.params;
    return `
      <div class="notification ${cssClass || ''}">
        <div class="notification-header">
          ${icon ? `<div class="notification-icon">${icon}</div>` : ''}
          ${title ? `<div class="notification-title">${title}</div>` : ''}
          ${titleRightText ? `<div class="notification-title-right-text">${titleRightText}</div>` : ''}
          ${closeButton ? '<span class="notification-close-button"></span>' : ''}
        </div>
        <div class="notification-content">
          ${subtitle ? `<div class="notification-subtitle">${subtitle}</div>` : ''}
          ${text ? `<div class="notification-text">${text}</div>` : ''}
        </div>
      </div>
    `.trim();
  }
}

var Notification$1 = {
  name: 'notification',
  static: {
    Notification,
  },
  create() {
    const app = this;
    app.notification = Utils.extend(
      {},
      ModalMethods({
        app,
        constructor: Notification,
        defaultSelector: '.notification.modal-in',
      })
    );
  },
  params: {
    notification: {
      icon: null,
      title: null,
      titleRightText: null,
      subtitle: null,
      text: null,
      closeButton: false,
      closeTimeout: null,
      closeOnClick: false,
      swipeToClose: true,
      cssClass: null,
      render: null,
    },
  },
};

/* eslint "no-useless-escape": "off" */

class Autocomplete extends Framework7Class {
  constructor(app, params = {}) {
    super(params, [app]);

    const ac = this;
    ac.app = app;

    const defaults = Utils.extend({
      on: {},
    }, app.params.autocomplete);


    // Extend defaults with modules params
    ac.useModulesParams(defaults);

    ac.params = Utils.extend(defaults, params);

    let $openerEl;
    if (ac.params.openerEl) {
      $openerEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(ac.params.openerEl);
      if ($openerEl.length) $openerEl[0].f7Autocomplete = ac;
    }

    let $inputEl;
    if (ac.params.inputEl) {
      $inputEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(ac.params.inputEl);
      if ($inputEl.length) $inputEl[0].f7Autocomplete = ac;
    }

    let view;
    if (ac.params.view) {
      view = ac.params.view;
    } else if ($openerEl || $inputEl) {
      view = app.views.get($openerEl || $inputEl);
    }
    if (!view) view = app.views.main;

    const id = Utils.now();

    let url = params.url;
    if (!url && $openerEl && $openerEl.length) {
      if ($openerEl.attr('href')) url = $openerEl.attr('href');
      else if ($openerEl.find('a').length > 0) {
        url = $openerEl.find('a').attr('href');
      }
    }
    if (!url || url === '#' || url === '') url = ac.params.url;

    const inputType = ac.params.multiple ? 'checkbox' : 'radio';

    Utils.extend(ac, {
      $openerEl,
      openerEl: $openerEl && $openerEl[0],
      $inputEl,
      inputEl: $inputEl && $inputEl[0],
      id,
      view,
      url,
      value: ac.params.value || [],
      inputType,
      inputName: `${inputType}-${id}`,
      $modalEl: undefined,
      $dropdownEl: undefined,
    });

    let previousQuery = '';
    function onInputChange() {
      let query = ac.$inputEl.val().trim();

      if (!ac.params.source) return;
      ac.params.source.call(ac, query, (items) => {
        let itemsHTML = '';
        const limit = ac.params.limit ? Math.min(ac.params.limit, items.length) : items.length;
        ac.items = items;
        let regExp;
        if (ac.params.highlightMatches) {
          query = query.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, '\\$&');
          regExp = new RegExp(`(${query})`, 'i');
        }

        let firstValue;
        let firstItem;
        for (let i = 0; i < limit; i += 1) {
          const itemValue = typeof items[i] === 'object' ? items[i][ac.params.valueProperty] : items[i];
          const itemText = typeof items[i] === 'object' ? items[i][ac.params.textProperty] : items[i];
          if (i === 0) {
            firstValue = itemValue;
            firstItem = ac.items[i];
          }
          itemsHTML += ac.renderItem({
            value: itemValue,
            text: ac.params.highlightMatches ? itemText.replace(regExp, '<b>$1</b>') : itemText,
          }, i);
        }
        if (itemsHTML === '' && query === '' && ac.params.dropdownPlaceholderText) {
          itemsHTML += ac.renderItem({
            placeholder: true,
            text: ac.params.dropdownPlaceholderText,
          });
        }
        ac.$dropdownEl.find('ul').html(itemsHTML);
        if (ac.params.typeahead) {
          if (!firstValue || !firstItem) {
            return;
          }
          if (firstValue.toLowerCase().indexOf(query.toLowerCase()) !== 0) {
            return;
          }
          if (previousQuery.toLowerCase() === query.toLowerCase()) {
            ac.value = [];
            return;
          }

          if (previousQuery.toLowerCase().indexOf(query.toLowerCase()) === 0) {
            previousQuery = query;
            ac.value = [];
            return;
          }
          $inputEl.val(firstValue);
          $inputEl[0].setSelectionRange(query.length, firstValue.length);

          const previousValue = typeof ac.value[0] === 'object' ? ac.value[0][ac.params.valueProperty] : ac.value[0];
          if (!previousValue || firstValue.toLowerCase() !== previousValue.toLowerCase()) {
            ac.value = [firstItem];
            ac.emit('local::change autocompleteChange', [firstItem]);
          }
        }

        previousQuery = query;
      });
    }
    function onPageInputChange() {
      const input = this;
      const value = input.value;
      const isValues = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(input).parents('.autocomplete-values').length > 0;
      let item;
      let itemValue;
      let aValue;
      if (isValues) {
        if (ac.inputType === 'checkbox' && !input.checked) {
          for (let i = 0; i < ac.value.length; i += 1) {
            aValue = typeof ac.value[i] === 'string' ? ac.value[i] : ac.value[i][ac.params.valueProperty];
            if (aValue === value || aValue * 1 === value * 1) {
              ac.value.splice(i, 1);
            }
          }
          ac.updateValues();
          ac.emit('local::change autocompleteChange', ac.value);
        }
        return;
      }

      // Find Related Item
      for (let i = 0; i < ac.items.length; i += 1) {
        itemValue = typeof ac.items[i] === 'object' ? ac.items[i][ac.params.valueProperty] : ac.items[i];
        if (itemValue === value || itemValue * 1 === value * 1) item = ac.items[i];
      }
      if (ac.inputType === 'radio') {
        ac.value = [item];
      } else if (input.checked) {
        ac.value.push(item);
      } else {
        for (let i = 0; i < ac.value.length; i += 1) {
          aValue = typeof ac.value[i] === 'object' ? ac.value[i][ac.params.valueProperty] : ac.value[i];
          if (aValue === value || aValue * 1 === value * 1) {
            ac.value.splice(i, 1);
          }
        }
      }

      // Update Values Block
      ac.updateValues();

      // On Select Callback
      if (((ac.inputType === 'radio' && input.checked) || ac.inputType === 'checkbox')) {
        ac.emit('local::change autocompleteChange', ac.value);
      }
    }
    function onHtmlClick(e) {
      const $targetEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(e.target);
      if ($targetEl.is(ac.$inputEl[0]) || (ac.$dropdownEl && $targetEl.closest(ac.$dropdownEl[0]).length)) return;
      ac.close();
    }
    function onOpenerClick() {
      ac.open();
    }
    function onInputFocus() {
      ac.open();
    }
    function onInputBlur() {
      if (ac.$dropdownEl.find('label.active-state').length > 0) return;
      ac.close();
    }
    function onResize() {
      ac.positionDropDown();
    }

    function onKeyDown(e) {
      if (ac.opened && e.keyCode === 13) {
        e.preventDefault();
        ac.$inputEl.blur();
      }
    }
    function onDropdownclick() {
      const $clickedEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(this);
      let clickedItem;
      for (let i = 0; i < ac.items.length; i += 1) {
        const itemValue = typeof ac.items[i] === 'object' ? ac.items[i][ac.params.valueProperty] : ac.items[i];
        const value = $clickedEl.attr('data-value');
        if (itemValue === value || itemValue * 1 === value * 1) {
          clickedItem = ac.items[i];
        }
      }
      if (ac.params.updateInputValueOnSelect) {
        ac.$inputEl.val(typeof clickedItem === 'object' ? clickedItem[ac.params.valueProperty] : clickedItem);
        ac.$inputEl.trigger('input change');
      }
      ac.value = [clickedItem];
      ac.emit('local::change autocompleteChange', [clickedItem]);

      ac.close();
    }

    ac.attachEvents = function attachEvents() {
      if (ac.params.openIn !== 'dropdown' && ac.$openerEl) {
        ac.$openerEl.on('click', onOpenerClick);
      }
      if (ac.params.openIn === 'dropdown' && ac.$inputEl) {
        ac.$inputEl.on('focus', onInputFocus);
        ac.$inputEl.on(ac.params.inputEvents, onInputChange);
        if (app.device.android) {
          Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])('html').on('click', onHtmlClick);
        } else {
          ac.$inputEl.on('blur', onInputBlur);
        }
        if (ac.params.typeahead) {
          ac.$inputEl.on('keydown', onKeyDown);
        }
      }
    };
    ac.detachEvents = function attachEvents() {
      if (ac.params.openIn !== 'dropdown' && ac.$openerEl) {
        ac.$openerEl.off('click', onOpenerClick);
      }
      if (ac.params.openIn === 'dropdown' && ac.$inputEl) {
        ac.$inputEl.off('focus', onInputFocus);
        ac.$inputEl.off(ac.params.inputEvents, onInputChange);
        if (app.device.android) {
          Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])('html').off('click', onHtmlClick);
        } else {
          ac.$inputEl.off('blur', onInputBlur);
        }
        if (ac.params.typeahead) {
          ac.$inputEl.off('keydown', onKeyDown);
        }
      }
    };
    ac.attachDropdownEvents = function attachDropdownEvents() {
      ac.$dropdownEl.on('click', 'label', onDropdownclick);
      app.on('resize', onResize);
    };
    ac.detachDropdownEvents = function detachDropdownEvents() {
      ac.$dropdownEl.off('click', 'label', onDropdownclick);
      app.off('resize', onResize);
    };

    ac.attachPageEvents = function attachPageEvents() {
      ac.$el.on('change', 'input[type="radio"], input[type="checkbox"]', onPageInputChange);
      if (ac.params.closeOnSelect && !ac.params.multiple) {
        ac.$el.once('click', '.list label', () => {
          Utils.nextTick(() => {
            ac.close();
          });
        });
      }
    };
    ac.detachPageEvents = function detachPageEvents() {
      ac.$el.off('change', 'input[type="radio"], input[type="checkbox"]', onPageInputChange);
    };

    // Install Modules
    ac.useModules();

    // Init
    ac.init();

    return ac;
  }
  positionDropDown() {
    const ac = this;
    const { $inputEl, app, $dropdownEl } = ac;

    const $pageContentEl = $inputEl.parents('.page-content');
    if ($pageContentEl.length === 0) return;
    const inputOffset = $inputEl.offset();
    const inputOffsetWidth = $inputEl[0].offsetWidth;
    const inputOffsetHeight = $inputEl[0].offsetHeight;
    const $listEl = $inputEl.parents('.list');
    const listOffset = $listEl.offset();
    const paddingBottom = parseInt($pageContentEl.css('padding-bottom'), 10);
    const listOffsetLeft = $listEl.length > 0 ? listOffset.left - $listEl.parent().offset().left : 0;
    const inputOffsetLeft = inputOffset.left - ($listEl.length > 0 ? listOffset.left : 0) - (app.rtl ? 0 : 0);
    const inputOffsetTop = inputOffset.top - ($pageContentEl.offset().top - $pageContentEl[0].scrollTop);

    const maxHeight = $pageContentEl[0].scrollHeight - paddingBottom - (inputOffsetTop + $pageContentEl[0].scrollTop) - $inputEl[0].offsetHeight;

    const paddingProp = app.rtl ? 'padding-right' : 'padding-left';
    let paddingValue;
    if ($listEl.length && !ac.params.expandInput) {
      paddingValue = (app.rtl ? $listEl[0].offsetWidth - inputOffsetLeft - inputOffsetWidth : inputOffsetLeft) - (app.theme === 'md' ? 16 : 15);
    }


    $dropdownEl.css({
      left: `${$listEl.length > 0 ? listOffsetLeft : inputOffsetLeft}px`,
      top: `${inputOffsetTop + $pageContentEl[0].scrollTop + inputOffsetHeight}px`,
      width: `${$listEl.length > 0 ? $listEl[0].offsetWidth : inputOffsetWidth}px`,
    });
    $dropdownEl.children('.autocomplete-dropdown-inner').css({
      maxHeight: `${maxHeight}px`,
      [paddingProp]: $listEl.length > 0 && !ac.params.expandInput ? `${paddingValue}px` : '',
    });
  }
  focus() {
    const ac = this;
    ac.$el.find('input[type=search]').focus();
  }
  source(query) {
    const ac = this;
    if (!ac.params.source) return;

    const { $el } = ac;

    ac.params.source.call(ac, query, (items) => {
      let itemsHTML = '';
      const limit = ac.params.limit ? Math.min(ac.params.limit, items.length) : items.length;
      ac.items = items;
      for (let i = 0; i < limit; i += 1) {
        let selected = false;
        const itemValue = typeof items[i] === 'object' ? items[i][ac.params.valueProperty] : items[i];
        for (let j = 0; j < ac.value.length; j += 1) {
          const aValue = typeof ac.value[j] === 'object' ? ac.value[j][ac.params.valueProperty] : ac.value[j];
          if (aValue === itemValue || aValue * 1 === itemValue * 1) selected = true;
        }
        itemsHTML += ac.renderItem({
          value: itemValue,
          text: typeof items[i] === 'object' ? items[i][ac.params.textProperty] : items[i],
          inputType: ac.inputType,
          id: ac.id,
          inputName: ac.inputName,
          selected,
        }, i);
      }
      $el.find('.autocomplete-found ul').html(itemsHTML);
      if (items.length === 0) {
        if (query.length !== 0) {
          $el.find('.autocomplete-not-found').show();
          $el.find('.autocomplete-found, .autocomplete-values').hide();
        } else {
          $el.find('.autocomplete-values').show();
          $el.find('.autocomplete-found, .autocomplete-not-found').hide();
        }
      } else {
        $el.find('.autocomplete-found').show();
        $el.find('.autocomplete-not-found, .autocomplete-values').hide();
      }
    });
  }
  updateValues() {
    const ac = this;
    let valuesHTML = '';
    for (let i = 0; i < ac.value.length; i += 1) {
      valuesHTML += ac.renderItem({
        value: typeof ac.value[i] === 'object' ? ac.value[i][ac.params.valueProperty] : ac.value[i],
        text: typeof ac.value[i] === 'object' ? ac.value[i][ac.params.textProperty] : ac.value[i],
        inputType: ac.inputType,
        id: ac.id,
        inputName: `${ac.inputName}-checked}`,
        selected: true,
      }, i);
    }
    ac.$el.find('.autocomplete-values ul').html(valuesHTML);
  }
  preloaderHide() {
    const ac = this;
    if (ac.params.openIn === 'dropdown' && ac.$dropdownEl) {
      ac.$dropdownEl.find('.autocomplete-preloader').removeClass('autocomplete-preloader-visible');
    } else {
      Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])('.autocomplete-preloader').removeClass('autocomplete-preloader-visible');
    }
  }
  preloaderShow() {
    const ac = this;
    if (ac.params.openIn === 'dropdown' && ac.$dropdownEl) {
      ac.$dropdownEl.find('.autocomplete-preloader').addClass('autocomplete-preloader-visible');
    } else {
      Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])('.autocomplete-preloader').addClass('autocomplete-preloader-visible');
    }
  }
  renderPreloader() {
    const ac = this;
    return `
      <div class="autocomplete-preloader preloader ${ac.params.preloaderColor ? `color-${ac.params.preloaderColor}` : ''}">${ac.app.theme === 'md' ? Utils.mdPreloaderContent : ''}</div>
    `.trim();
  }
  renderSearchbar() {
    const ac = this;
    if (ac.params.renderSearchbar) return ac.params.renderSearchbar.call(ac);
    const searchbarHTML = `
      <form class="searchbar">
        <div class="searchbar-inner">
          <div class="searchbar-input-wrap">
            <input type="search" placeholder="${ac.params.searchbarPlaceholder}"/>
            <i class="searchbar-icon"></i>
            <span class="input-clear-button"></span>
          </div>
          <span class="searchbar-disable-button">${ac.params.searchbarDisableText}</span>
        </div>
      </form>
    `.trim();
    return searchbarHTML;
  }
  renderItem(item, index) {
    const ac = this;
    if (ac.params.renderItem) return ac.params.renderItem.call(ac, item, index);
    let itemHtml;
    if (ac.params.openIn !== 'dropdown') {
      itemHtml = `
        <li>
          <label class="item-${item.inputType} item-content">
            <input type="${item.inputType}" name="${item.inputName}" value="${item.value}" ${item.selected ? 'checked' : ''}>
            <i class="icon icon-${item.inputType}"></i>
            <div class="item-inner">
              <div class="item-title">${item.text}</div>
            </div>
          </label>
        </li>
      `;
    } else if (!item.placeholder) {
      // Dropdown
      itemHtml = `
        <li>
          <label class="item-radio item-content" data-value="${item.value}">
            <div class="item-inner">
              <div class="item-title">${item.text}</div>
            </div>
          </label>
        </li>
      `;
    } else {
      // Dropwdown placeholder
      itemHtml = `
        <li class="autocomplete-dropdown-placeholder">
          <div class="item-content">
            <div class="item-inner">
              <div class="item-title">${item.text}</div>
            </div>
          </label>
        </li>
      `;
    }
    return itemHtml.trim();
  }

  renderNavbar() {
    const ac = this;
    if (ac.params.renderNavbar) return ac.params.renderNavbar.call(ac);
    let pageTitle = ac.params.pageTitle;
    if (typeof pageTitle === 'undefined' && ac.$openerEl && ac.$openerEl.length) {
      pageTitle = ac.$openerEl.find('.item-title').text().trim();
    }
    const navbarHtml = `
      <div class="navbar ${ac.params.navbarColorTheme ? `color-theme-${ac.params.navbarColorTheme}` : ''}">
        <div class="navbar-inner ${ac.params.navbarColorTheme ? `color-theme-${ac.params.navbarColorTheme}` : ''}">
          <div class="left sliding">
            <a href="#" class="link ${ac.params.openIn === 'page' ? 'back' : 'popup-close'}" ${ac.params.openIn === 'popup' ? 'data-popup=".autocomplete-popup"' : ''}>
              <i class="icon icon-back"></i>
              <span class="ios-only">${ac.params.openIn === 'page' ? ac.params.pageBackLinkText : ac.params.popupCloseLinkText}</span>
            </a>
          </div>
          ${pageTitle ? `<div class="title sliding">${pageTitle}</div>` : ''}
          ${ac.params.preloader ? `
          <div class="right">
            ${ac.renderPreloader()}
          </div>
          ` : ''}
          <div class="subnavbar sliding">${ac.renderSearchbar()}</div>
        </div>
      </div>
    `.trim();
    return navbarHtml;
  }
  renderDropdown() {
    const ac = this;
    if (ac.params.renderDropdown) return ac.params.renderDropdown.call(ac, ac.items);
    const dropdownHtml = `
      <div class="autocomplete-dropdown">
        <div class="autocomplete-dropdown-inner">
          <div class="list ${!ac.params.expandInput ? 'no-ios-edge' : ''}">
            <ul></ul>
          </div>
        </div>
        ${ac.params.preloader ? ac.renderPreloader() : ''}
      </div>
    `.trim();
    return dropdownHtml;
  }
  renderPage() {
    const ac = this;
    if (ac.params.renderPage) return ac.params.renderPage.call(ac, ac.items);

    const pageHtml = `
      <div class="page page-with-subnavbar autocomplete-page" data-name="autocomplete-page">
        ${ac.renderNavbar()}
        <div class="searchbar-backdrop"></div>
        <div class="page-content">
          <div class="list autocomplete-list autocomplete-found autocomplete-list-${ac.id} ${ac.params.formColorTheme ? `color-theme-${ac.params.formColorTheme}` : ''}">
            <ul></ul>
          </div>
          <div class="list autocomplete-not-found">
            <ul>
              <li class="item-content"><div class="item-inner"><div class="item-title">${ac.params.notFoundText}</div></div></li>
            </ul>
          </div>
          <div class="list autocomplete-values">
            <ul></ul>
          </div>
        </div>
      </div>
    `.trim();
    return pageHtml;
  }
  renderPopup() {
    const ac = this;
    if (ac.params.renderPopup) return ac.params.renderPopup.call(ac, ac.items);
    const popupHtml = `
      <div class="popup autocomplete-popup">
        <div class="view">
          ${ac.renderPage()};
        </div>
      </div>
    `.trim();
    return popupHtml;
  }
  onOpen(type, el) {
    const ac = this;
    const app = ac.app;
    const $el = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(el);
    ac.$el = $el;
    ac.el = $el[0];
    ac.openedIn = type;
    ac.opened = true;

    if (ac.params.openIn === 'dropdown') {
      ac.attachDropdownEvents();

      ac.$dropdownEl.addClass('autocomplete-dropdown-in');
      ac.$inputEl.trigger('input');
    } else {
      // Init SB
      let $searchbarEl = $el.find('.searchbar');
      if (ac.params.openIn === 'page' && app.theme === 'ios' && $searchbarEl.length === 0) {
        $searchbarEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(app.navbar.getElByPage($el)).find('.searchbar');
      }
      ac.searchbar = app.searchbar.create({
        el: $searchbarEl,
        backdropEl: $el.find('.searchbar-backdrop'),
        customSearch: true,
        on: {
          searchbarSearch(sb, query) {
            if (query.length === 0 && ac.searchbar.enabled) {
              ac.searchbar.backdropShow();
            } else {
              ac.searchbar.backdropHide();
            }
            ac.source(query);
          },
        },
      });

      // Attach page events
      ac.attachPageEvents();

      // Update Values On Page Init
      ac.updateValues();

      // Source on load
      if (ac.params.requestSourceOnOpen) ac.source('');
    }

    ac.emit('local::open autocompleteOpen', ac);
  }
  onOpened() {
    const ac = this;
    if (ac.params.openIn !== 'dropdown' && ac.params.autoFocus) {
      ac.autoFocus();
    }
    ac.emit('local::opened autocompleteOpened', ac);
  }
  onClose() {
    const ac = this;
    if (ac.destroyed) return;

    // Destroy SB
    if (ac.searchbar && ac.searchbar.destroy) {
      ac.searchbar.destroy();
      ac.searchbar = null;
      delete ac.searchbar;
    }

    if (ac.params.openIn === 'dropdown') {
      ac.detachDropdownEvents();
      ac.$dropdownEl.removeClass('autocomplete-dropdown-in').remove();
      ac.$inputEl.parents('.item-content-dropdown-expanded').removeClass('item-content-dropdown-expanded');
    } else {
      ac.detachPageEvents();
    }

    ac.emit('local::close autocompleteClose', ac);
  }
  onClosed() {
    const ac = this;
    if (ac.destroyed) return;
    ac.opened = false;
    ac.$el = null;
    ac.el = null;
    delete ac.$el;
    delete ac.el;

    ac.emit('local::closed autocompleteClosed', ac);
  }
  openPage() {
    const ac = this;
    if (ac.opened) return ac;
    const pageHtml = ac.renderPage();
    ac.view.router.navigate({
      url: ac.url,
      route: {
        content: pageHtml,
        path: ac.url,
        on: {
          pageBeforeIn(e, page) {
            ac.onOpen('page', page.el);
          },
          pageAfterIn(e, page) {
            ac.onOpened('page', page.el);
          },
          pageBeforeOut(e, page) {
            ac.onClose('page', page.el);
          },
          pageAfterOut(e, page) {
            ac.onClosed('page', page.el);
          },
        },
        options: {
          animate: ac.params.animate,
        },
      },
    });
    return ac;
  }
  openPopup() {
    const ac = this;
    if (ac.opened) return ac;
    const popupHtml = ac.renderPopup();

    const popupParams = {
      content: popupHtml,
      animate: ac.params.animate,
      on: {
        popupOpen(popup) {
          ac.onOpen('popup', popup.el);
        },
        popupOpened(popup) {
          ac.onOpened('popup', popup.el);
        },
        popupClose(popup) {
          ac.onClose('popup', popup.el);
        },
        popupClosed(popup) {
          ac.onClosed('popup', popup.el);
        },
      },
    };

    if (ac.params.routableModals) {
      ac.view.router.navigate({
        url: ac.url,
        route: {
          path: ac.url,
          popup: popupParams,
        },
      });
    } else {
      ac.modal = ac.app.popup.create(popupParams).open(ac.params.animate);
    }
    return ac;
  }
  openDropdown() {
    const ac = this;

    if (!ac.$dropdownEl) {
      ac.$dropdownEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(ac.renderDropdown());
    }
    const $listEl = ac.$inputEl.parents('.list');
    if ($listEl.length && ac.$inputEl.parents('.item-content').length > 0 && ac.params.expandInput) {
      ac.$inputEl.parents('.item-content').addClass('item-content-dropdown-expanded');
    }
    ac.positionDropDown();
    const $pageContentEl = ac.$inputEl.parents('.page-content');
    if (ac.params.dropdownel) {
      Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(ac.params.dropdownel).append(ac.$dropdownEl);
    } else if ($pageContentEl.length === 0) {
      ac.$dropdownEl.insertAfter(ac.$inputEl);
    } else {
      $pageContentEl.append(ac.$dropdownEl);
    }
    ac.onOpen('dropdown', ac.$dropdownEl);
    ac.onOpened('dropdown', ac.$dropdownEl);
  }
  open() {
    const ac = this;
    if (ac.opened) return ac;
    const openIn = ac.params.openIn;
    ac[`open${openIn.split('').map((el, index) => {
      if (index === 0) return el.toUpperCase();
      return el;
    }).join('')}`]();
    return ac;
  }
  close() {
    const ac = this;
    if (!ac.opened) return ac;
    if (ac.params.openIn === 'dropdown') {
      ac.onClose();
      ac.onClosed();
    } else if (ac.params.routableModals || ac.openedIn === 'page') {
      ac.view.router.back({ animate: ac.params.animate });
    } else {
      ac.modal.once('modalClosed', () => {
        Utils.nextTick(() => {
          ac.modal.destroy();
          delete ac.modal;
        });
      });
      ac.modal.close();
    }
    return ac;
  }
  init() {
    const ac = this;
    ac.attachEvents();
  }
  destroy() {
    const ac = this;
    ac.emit('local::beforeDestroy autocompleteBeforeDestroy', ac);
    ac.detachEvents();
    if (ac.$inputEl && ac.$inputEl[0]) {
      delete ac.$inputEl[0].f7Autocomplete;
    }
    if (ac.$openerEl && ac.$openerEl[0]) {
      delete ac.$openerEl[0].f7Autocomplete;
    }
    Utils.deleteProps(ac);
    ac.destroyed = true;
  }
}

var Autocomplete$1 = {
  name: 'autocomplete',
  params: {
    autocomplete: {
      openerEl: undefined,
      inputEl: undefined,
      view: undefined,

      // DropDown
      dropdownContainerEl: undefined,
      dropdownPlaceholderText: undefined,
      typeahead: false,
      highlightMatches: true,
      expandInput: false,
      updateInputValueOnSelect: true,
      inputEvents: 'input',

      value: undefined,
      multiple: false,

      source: undefined,
      limit: undefined,
      valueProperty: 'id',
      textProperty: 'text',

      openIn: 'page', // or 'popup' or 'dropdown'
      pageBackLinkText: 'Back',
      popupCloseLinkText: 'Close',
      pageTitle: undefined,
      searchbarPlaceholder: 'Search...',
      searchbarDisableText: 'Cancel',

      animate: true,

      autoFocus: false,
      closeOnSelect: false,
      notFoundText: 'Nothing found',
      requestSourceOnOpen: false,

      // Preloader
      preloaderColor: undefined,
      preloader: false,

      // Colors
      formColorTheme: undefined,
      navbarColorTheme: undefined,

      // Routing
      routableModals: true,
      url: 'select/',

      // Custom render functions
      renderDropdown: undefined,
      renderPage: undefined,
      renderPopup: undefined,
      renderItem: undefined,
      renderSearchbar: undefined,
      renderNavbar: undefined,

    },
  },
  static: {
    Autocomplete,
  },
  create() {
    const app = this;
    app.autocomplete = Utils.extend(
      ConstructorMethods({
        defaultSelector: undefined,
        constructor: Autocomplete,
        app,
        domProp: 'f7Autocomplete',
      }),
      {
        open(autocompleteEl) {
          const ac = app.autocomplete.get(autocompleteEl);
          if (ac && ac.open) return ac.open();
          return undefined;
        },
        close(autocompleteEl) {
          const ac = app.autocomplete.get(autocompleteEl);
          if (ac && ac.close) return ac.close();
          return undefined;
        },
      }
    );
  },
};

class ViAd extends Framework7Class {
  constructor(app, params = {}) {
    super(params, [app]);
    const vi = this;
    if (!__WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].vi) {
      throw new Error('f7:vi SDK not found.');
    }

    let orientation;
    if (typeof __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].orientation !== 'undefined') {
      orientation = __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].orientation === -90 || __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].orientation === 90 ? 'horizontal' : 'vertical';
    }
    const defaults = Utils.extend(
      {},
      app.params.vi,
      {
        appId: app.id,
        appVer: app.version,
        language: app.language,
        width: app.width,
        height: app.height,
        os: Device.os,
        osVersion: Device.osVersion,
        orientation,
      }
    );

    // Extend defaults with modules params
    vi.useModulesParams(defaults);

    vi.params = Utils.extend(defaults, params);

    const adParams = {};
    const skipParams = ('on autoplay fallbackOverlay fallbackOverlayText enabled').split(' ');
    Object.keys(vi.params).forEach((paramName) => {
      if (skipParams.indexOf(paramName) >= 0) return;
      const paramValue = vi.params[paramName];
      if ([null, undefined].indexOf(paramValue) >= 0) return;
      adParams[paramName] = paramValue;
    });

    if (!vi.params.appId) {
      throw new Error('Framework7:"app.id" is required to display an ad. Make sure you have specified it on app initialization.');
    }
    if (!vi.params.placementId) {
      throw new Error('Framework7:"placementId" is required to display an ad.');
    }

    function onResize() {
      const $viFrame = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])('iframe#viAd');
      if ($viFrame.length === 0) return;
      $viFrame
        .css({
          width: `${app.width}px`,
          height: `${app.height}px`,
        });
    }

    function removeOverlay() {
      if (!vi.$overlayEl) return;
      vi.$overlayEl.off('click touchstart');
      vi.$overlayEl.remove();
    }
    function createOverlay(videoEl) {
      if (!videoEl) return;
      vi.$overlayEl = Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])(`
        <div class="vi-overlay no-fastclick">
          ${vi.params.fallbackOverlayText ? `<div class="vi-overlay-text">${vi.params.fallbackOverlayText}</div>` : ''}
          <div class="vi-overlay-play-button"></div>
        </div>
      `.trim());

      let touchStartTime;
      vi.$overlayEl.on('touchstart', () => {
        touchStartTime = Utils.now();
      });
      vi.$overlayEl.on('click', () => {
        const timeDiff = Utils.now() - touchStartTime;
        if (timeDiff > 300) return;
        if (videoEl) {
          videoEl.play();
          removeOverlay();
          return;
        }
        vi.start();
        removeOverlay();
      });
      app.root.append(vi.$overlayEl);
    }

    // Create ad
    vi.ad = new __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].vi.Ad(adParams);

    Utils.extend(vi.ad, {
      onAdReady() {
        app.on('resize', onResize);
        vi.emit('local::ready');
        if (vi.params.autoplay) {
          vi.start();
        }
      },
      onAdStarted() {
        vi.emit('local::started');
      },
      onAdClick(targetUrl) {
        vi.emit('local::click', targetUrl);
      },
      onAdImpression() {
        vi.emit('local::impression');
      },
      onAdStopped(reason) {
        app.off('resize', onResize);
        removeOverlay();

        vi.emit('local::stopped', reason);
        if (reason === 'complete') {
          vi.emit('local::complete');
          vi.emit('local::completed');
        }
        if (reason === 'userexit') {
          vi.emit('local::userexit');
        }
        vi.destroyed = true;
      },
      onAutoPlayFailed(reason, videoEl) {
        vi.emit('local::autoplayFailed', reason, videoEl);
        if (reason && reason.name && reason.name.indexOf('NotAllowedError') !== -1 && vi.params.fallbackOverlay) {
          createOverlay(videoEl);
        }
      },
      onAdError(msg) {
        removeOverlay();
        app.off('resize', onResize);
        vi.emit('local::error', msg);
        vi.destroyed = true;
      },
    });

    vi.init();

    Utils.extend(vi, {
      app,
    });
  }
  start() {
    const vi = this;
    if (vi.destroyed) return;
    if (vi.ad) vi.ad.startAd();
  }
  pause() {
    const vi = this;
    if (vi.destroyed) return;
    if (vi.ad) vi.ad.pauseAd();
  }
  resume() {
    const vi = this;
    if (vi.destroyed) return;
    if (vi.ad) vi.ad.resumeAd();
  }
  stop() {
    const vi = this;
    if (vi.destroyed) return;
    if (vi.ad) vi.ad.stopAd();
  }
  init() {
    const vi = this;
    if (vi.destroyed) return;
    if (vi.ad) vi.ad.initAd();
  }
  destroy() {
    const vi = this;
    vi.destroyed = true;
    vi.emit('local::beforeDestroy');
    Utils.deleteProps(vi);
  }
}

var Vi = {
  name: 'vi',
  params: {
    vi: {
      enabled: false,
      autoplay: true,
      fallbackOverlay: true,
      fallbackOverlayText: 'Please watch this ad',
      showMute: true,
      startMuted: (Device.ios || Device.android) && !Device.cordova,
      appId: null,
      appVer: null,
      language: null,
      width: null,
      height: null,
      placementId: 'pltd4o7ibb9rc653x14',
      placementType: 'interstitial',
      videoSlot: null,
      showProgress: true,
      showBranding: true,
      os: null,
      osVersion: null,
      orientation: null,
      age: null,
      gender: null,
      advertiserId: null,
      latitude: null,
      longitude: null,
      accuracy: null,
      storeId: null,
      ip: null,
      manufacturer: null,
      model: null,
      connectionType: null,
      connectionProvider: null,
    },
  },
  create() {
    const app = this;
    app.vi = {
      sdkReady: false,
      createAd(adParams) {
        return new ViAd(app, adParams);
      },
      loadSdk() {
        if (app.vi.skdReady) return;
        const script = __WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */].createElement('script');
        script.onload = function onload() {
          app.emit('viSdkReady');
          app.vi.skdReady = true;
        };
        script.src = 'https://c.vi-serve.com/viadshtml/vi.min.js';
        Object(__WEBPACK_IMPORTED_MODULE_1_dom7__["a" /* default */])('head').append(script);
      },
    };
  },
  on: {
    init() {
      const app = this;
      if (app.params.vi.enabled || (app.passedParams.vi && app.passedParams.vi.enabled !== false)) app.vi.loadSdk();
    },
  },
};

var Typography = {
  name: 'typography',
};

// Install Core Modules & Components
Framework7.use([
  DeviceModule,
  SupportModule,
  UtilsModule,
  ResizeModule,
  RequestModule,
  TouchModule,
  ClicksModule,
  Router$1,
  HistoryModule,
  StorageModule,
  Statusbar$1,
  View$1,
  Navbar$1,
  Toolbar$1,
  Subnavbar,
  TouchRipple$1,
  Modal$1,
  Dialog$1,
  Popup$1,
  LoginScreen$1,
  Popover$1,
  Actions$1,
  Sheet$1,
  Toast$1,
  Preloader$1,
  Progressbar$1,
  Sortable$1,
  Swipeout$1,
  Accordion$1,
  VirtualList$1,
  ListIndex$1,
  Timeline,
  Tabs,
  Panel$1,
  Card,
  Chip,
  Form,
  Input$1,
  Checkbox,
  Radio,
  Toggle$1,
  Range$1,
  Stepper$1,
  SmartSelect$1,
  Grid,
  Calendar$1,
  Picker$1,
  InfiniteScroll$1,
  PullToRefresh$1,
  Lazy$1,
  DataTable$1,
  Fab$1,
  Searchbar$1,
  Messages$1,
  Messagebar$1,
  Swiper$1,
  PhotoBrowser$1,
  Notification$1,
  Autocomplete$1,
  Vi,
  Typography
]);

/* harmony default export */ __webpack_exports__["a"] = (Framework7);



/***/ }),

/***/ "./node_modules/framework7/node_modules/path-to-regexp/index.js":
/***/ (function(module, exports) {

/**
 * Expose `pathToRegexp`.
 */
module.exports = pathToRegexp
module.exports.parse = parse
module.exports.compile = compile
module.exports.tokensToFunction = tokensToFunction
module.exports.tokensToRegExp = tokensToRegExp

/**
 * Default configs.
 */
var DEFAULT_DELIMITER = '/'
var DEFAULT_DELIMITERS = './'

/**
 * The main path matching regexp utility.
 *
 * @type {RegExp}
 */
var PATH_REGEXP = new RegExp([
  // Match escaped characters that would otherwise appear in future matches.
  // This allows the user to escape special characters that won't transform.
  '(\\\\.)',
  // Match Express-style parameters and un-named parameters with a prefix
  // and optional suffixes. Matches appear as:
  //
  // "/:test(\\d+)?" => ["/", "test", "\d+", undefined, "?"]
  // "/route(\\d+)"  => [undefined, undefined, undefined, "\d+", undefined]
  '(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?'
].join('|'), 'g')

/**
 * Parse a string for the raw tokens.
 *
 * @param  {string}  str
 * @param  {Object=} options
 * @return {!Array}
 */
function parse (str, options) {
  var tokens = []
  var key = 0
  var index = 0
  var path = ''
  var defaultDelimiter = (options && options.delimiter) || DEFAULT_DELIMITER
  var delimiters = (options && options.delimiters) || DEFAULT_DELIMITERS
  var pathEscaped = false
  var res

  while ((res = PATH_REGEXP.exec(str)) !== null) {
    var m = res[0]
    var escaped = res[1]
    var offset = res.index
    path += str.slice(index, offset)
    index = offset + m.length

    // Ignore already escaped sequences.
    if (escaped) {
      path += escaped[1]
      pathEscaped = true
      continue
    }

    var prev = ''
    var next = str[index]
    var name = res[2]
    var capture = res[3]
    var group = res[4]
    var modifier = res[5]

    if (!pathEscaped && path.length) {
      var k = path.length - 1

      if (delimiters.indexOf(path[k]) > -1) {
        prev = path[k]
        path = path.slice(0, k)
      }
    }

    // Push the current path onto the tokens.
    if (path) {
      tokens.push(path)
      path = ''
      pathEscaped = false
    }

    var partial = prev !== '' && next !== undefined && next !== prev
    var repeat = modifier === '+' || modifier === '*'
    var optional = modifier === '?' || modifier === '*'
    var delimiter = prev || defaultDelimiter
    var pattern = capture || group

    tokens.push({
      name: name || key++,
      prefix: prev,
      delimiter: delimiter,
      optional: optional,
      repeat: repeat,
      partial: partial,
      pattern: pattern ? escapeGroup(pattern) : '[^' + escapeString(delimiter) + ']+?'
    })
  }

  // Push any remaining characters.
  if (path || index < str.length) {
    tokens.push(path + str.substr(index))
  }

  return tokens
}

/**
 * Compile a string to a template function for the path.
 *
 * @param  {string}             str
 * @param  {Object=}            options
 * @return {!function(Object=, Object=)}
 */
function compile (str, options) {
  return tokensToFunction(parse(str, options))
}

/**
 * Expose a method for transforming tokens into the path function.
 */
function tokensToFunction (tokens) {
  // Compile all the tokens into regexps.
  var matches = new Array(tokens.length)

  // Compile all the patterns before compilation.
  for (var i = 0; i < tokens.length; i++) {
    if (typeof tokens[i] === 'object') {
      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$')
    }
  }

  return function (data, options) {
    var path = ''
    var encode = (options && options.encode) || encodeURIComponent

    for (var i = 0; i < tokens.length; i++) {
      var token = tokens[i]

      if (typeof token === 'string') {
        path += token
        continue
      }

      var value = data ? data[token.name] : undefined
      var segment

      if (Array.isArray(value)) {
        if (!token.repeat) {
          throw new TypeError('Expected "' + token.name + '" to not repeat, but got array')
        }

        if (value.length === 0) {
          if (token.optional) continue

          throw new TypeError('Expected "' + token.name + '" to not be empty')
        }

        for (var j = 0; j < value.length; j++) {
          segment = encode(value[j], token)

          if (!matches[i].test(segment)) {
            throw new TypeError('Expected all "' + token.name + '" to match "' + token.pattern + '"')
          }

          path += (j === 0 ? token.prefix : token.delimiter) + segment
        }

        continue
      }

      if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {
        segment = encode(String(value), token)

        if (!matches[i].test(segment)) {
          throw new TypeError('Expected "' + token.name + '" to match "' + token.pattern + '", but got "' + segment + '"')
        }

        path += token.prefix + segment
        continue
      }

      if (token.optional) {
        // Prepend partial segment prefixes.
        if (token.partial) path += token.prefix

        continue
      }

      throw new TypeError('Expected "' + token.name + '" to be ' + (token.repeat ? 'an array' : 'a string'))
    }

    return path
  }
}

/**
 * Escape a regular expression string.
 *
 * @param  {string} str
 * @return {string}
 */
function escapeString (str) {
  return str.replace(/([.+*?=^!:${}()[\]|/\\])/g, '\\$1')
}

/**
 * Escape the capturing group by escaping special characters and meaning.
 *
 * @param  {string} group
 * @return {string}
 */
function escapeGroup (group) {
  return group.replace(/([=!:$/()])/g, '\\$1')
}

/**
 * Get the flags for a regexp from the options.
 *
 * @param  {Object} options
 * @return {string}
 */
function flags (options) {
  return options && options.sensitive ? '' : 'i'
}

/**
 * Pull out keys from a regexp.
 *
 * @param  {!RegExp} path
 * @param  {Array=}  keys
 * @return {!RegExp}
 */
function regexpToRegexp (path, keys) {
  if (!keys) return path

  // Use a negative lookahead to match only capturing groups.
  var groups = path.source.match(/\((?!\?)/g)

  if (groups) {
    for (var i = 0; i < groups.length; i++) {
      keys.push({
        name: i,
        prefix: null,
        delimiter: null,
        optional: false,
        repeat: false,
        partial: false,
        pattern: null
      })
    }
  }

  return path
}

/**
 * Transform an array into a regexp.
 *
 * @param  {!Array}  path
 * @param  {Array=}  keys
 * @param  {Object=} options
 * @return {!RegExp}
 */
function arrayToRegexp (path, keys, options) {
  var parts = []

  for (var i = 0; i < path.length; i++) {
    parts.push(pathToRegexp(path[i], keys, options).source)
  }

  return new RegExp('(?:' + parts.join('|') + ')', flags(options))
}

/**
 * Create a path regexp from string input.
 *
 * @param  {string}  path
 * @param  {Array=}  keys
 * @param  {Object=} options
 * @return {!RegExp}
 */
function stringToRegexp (path, keys, options) {
  return tokensToRegExp(parse(path, options), keys, options)
}

/**
 * Expose a function for taking tokens and returning a RegExp.
 *
 * @param  {!Array}  tokens
 * @param  {Array=}  keys
 * @param  {Object=} options
 * @return {!RegExp}
 */
function tokensToRegExp (tokens, keys, options) {
  options = options || {}

  var strict = options.strict
  var end = options.end !== false
  var delimiter = escapeString(options.delimiter || DEFAULT_DELIMITER)
  var delimiters = options.delimiters || DEFAULT_DELIMITERS
  var endsWith = [].concat(options.endsWith || []).map(escapeString).concat('$').join('|')
  var route = ''
  var isEndDelimited = tokens.length === 0

  // Iterate over the tokens and create our regexp string.
  for (var i = 0; i < tokens.length; i++) {
    var token = tokens[i]

    if (typeof token === 'string') {
      route += escapeString(token)
      isEndDelimited = i === tokens.length - 1 && delimiters.indexOf(token[token.length - 1]) > -1
    } else {
      var prefix = escapeString(token.prefix)
      var capture = token.repeat
        ? '(?:' + token.pattern + ')(?:' + prefix + '(?:' + token.pattern + '))*'
        : token.pattern

      if (keys) keys.push(token)

      if (token.optional) {
        if (token.partial) {
          route += prefix + '(' + capture + ')?'
        } else {
          route += '(?:' + prefix + '(' + capture + '))?'
        }
      } else {
        route += prefix + '(' + capture + ')'
      }
    }
  }

  if (end) {
    if (!strict) route += '(?:' + delimiter + ')?'

    route += endsWith === '$' ? '$' : '(?=' + endsWith + ')'
  } else {
    if (!strict) route += '(?:' + delimiter + '(?=' + endsWith + '))?'
    if (!isEndDelimited) route += '(?=' + delimiter + '|' + endsWith + ')'
  }

  return new RegExp('^' + route, flags(options))
}

/**
 * Normalize the given path string, returning a regular expression.
 *
 * An empty array can be passed in for the keys, which will hold the
 * placeholder key descriptions. For example, using `/user/:id`, `keys` will
 * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
 *
 * @param  {(string|RegExp|Array)} path
 * @param  {Array=}                keys
 * @param  {Object=}               options
 * @return {!RegExp}
 */
function pathToRegexp (path, keys, options) {
  if (path instanceof RegExp) {
    return regexpToRegexp(path, keys)
  }

  if (Array.isArray(path)) {
    return arrayToRegexp(/** @type {!Array} */ (path), keys, options)
  }

  return stringToRegexp(/** @type {string} */ (path), keys, options)
}


/***/ }),

/***/ "./node_modules/process/browser.js":
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "./node_modules/setimmediate/setImmediate.js":
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
    "use strict";

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var registerImmediate;

    function setImmediate(callback) {
      // Callback can either be a function or a string
      if (typeof callback !== "function") {
        callback = new Function("" + callback);
      }
      // Copy function arguments
      var args = new Array(arguments.length - 1);
      for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i + 1];
      }
      // Store and register the task
      var task = { callback: callback, args: args };
      tasksByHandle[nextHandle] = task;
      registerImmediate(nextHandle);
      return nextHandle++;
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch (args.length) {
        case 0:
            callback();
            break;
        case 1:
            callback(args[0]);
            break;
        case 2:
            callback(args[0], args[1]);
            break;
        case 3:
            callback(args[0], args[1], args[2]);
            break;
        default:
            callback.apply(undefined, args);
            break;
        }
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(runIfPresent, 0, handle);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    run(task);
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function installNextTickImplementation() {
        registerImmediate = function(handle) {
            process.nextTick(function () { runIfPresent(handle); });
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function() {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function(event) {
            if (event.source === global &&
                typeof event.data === "string" &&
                event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        registerImmediate = function(handle) {
            global.postMessage(messagePrefix + handle, "*");
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function(event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        registerImmediate = function(handle) {
            channel.port2.postMessage(handle);
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        registerImmediate = function(handle) {
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
        };
    }

    function installSetTimeoutImplementation() {
        registerImmediate = function(handle) {
            setTimeout(runIfPresent, 0, handle);
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();

    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();

    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();

    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 68
        installReadyStateChangeImplementation();

    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__("./node_modules/webpack/buildin/global.js"), __webpack_require__("./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/ssr-window/dist/ssr-window.esm.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return win; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return doc; });
/**
 * SSR Window 1.0.0
 * Better handling for window object in SSR environment
 * https://github.com/nolimits4web/ssr-window
 *
 * Copyright 2018, Vladimir Kharlampidi
 *
 * Licensed under MIT
 *
 * Released on: February 10, 2018
 */
var d;
if (typeof document === 'undefined') {
  d = {
    body: {},
    addEventListener: function addEventListener() {},
    removeEventListener: function removeEventListener() {},
    activeElement: {
      blur: function blur() {},
      nodeName: '',
    },
    querySelector: function querySelector() {
      return null;
    },
    querySelectorAll: function querySelectorAll() {
      return [];
    },
    getElementById: function getElementById() {
      return null;
    },
    createEvent: function createEvent() {
      return {
        initEvent: function initEvent() {},
      };
    },
    createElement: function createElement() {
      return {
        children: [],
        childNodes: [],
        style: {},
        setAttribute: function setAttribute() {},
        getElementsByTagName: function getElementsByTagName() {
          return [];
        },
      };
    },
    location: { hash: '' },
  };
} else {
  // eslint-disable-next-line
  d = document;
}

var doc = d;

var w;
if (typeof window === 'undefined') {
  w = {
    document: doc,
    navigator: {
      userAgent: '',
    },
    location: {},
    history: {},
    CustomEvent: function CustomEvent() {
      return this;
    },
    addEventListener: function addEventListener() {},
    removeEventListener: function removeEventListener() {},
    getComputedStyle: function getComputedStyle() {
      return {
        getPropertyValue: function getPropertyValue() {
          return '';
        },
      };
    },
    Image: function Image() {},
    Date: function Date() {},
    screen: {},
    setTimeout: function setTimeout() {},
    clearTimeout: function clearTimeout() {},
  };
} else {
  // eslint-disable-next-line
  w = window;
}

var win = w;




/***/ }),

/***/ "./node_modules/template7/dist/template7.esm.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/**
 * Template7 1.3.5
 * Mobile-first HTML template engine
 * 
 * http://www.idangero.us/template7/
 * 
 * Copyright 2018, Vladimir Kharlampidi
 * The iDangero.us
 * http://www.idangero.us/
 * 
 * Licensed under MIT
 * 
 * Released on: January 22, 2018
 */
let t7ctx;
if (typeof window !== 'undefined') {
  t7ctx = window;
} else if (typeof global !== 'undefined') {
  t7ctx = global;
} else {
  t7ctx = undefined;
}

const Template7Context = t7ctx;

const Template7Utils = {
  quoteSingleRexExp: new RegExp('\'', 'g'),
  quoteDoubleRexExp: new RegExp('"', 'g'),
  isFunction(func) {
    return typeof func === 'function';
  },
  escape(string) {
    return (typeof Template7Context !== 'undefined' && Template7Context.escape) ?
      Template7Context.escape(string) :
      string
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;');
  },
  helperToSlices(string) {
    const { quoteDoubleRexExp, quoteSingleRexExp } = Template7Utils;
    const helperParts = string.replace(/[{}#}]/g, '').trim().split(' ');
    const slices = [];
    let shiftIndex;
    let i;
    let j;
    for (i = 0; i < helperParts.length; i += 1) {
      let part = helperParts[i];
      let blockQuoteRegExp;
      let openingQuote;
      if (i === 0) slices.push(part);
      else if (part.indexOf('"') === 0 || part.indexOf('\'') === 0) {
        blockQuoteRegExp = part.indexOf('"') === 0 ? quoteDoubleRexExp : quoteSingleRexExp;
        openingQuote = part.indexOf('"') === 0 ? '"' : '\'';
        // Plain String
        if (part.match(blockQuoteRegExp).length === 2) {
          // One word string
          slices.push(part);
        } else {
          // Find closed Index
          shiftIndex = 0;
          for (j = i + 1; j < helperParts.length; j += 1) {
            part += ` ${helperParts[j]}`;
            if (helperParts[j].indexOf(openingQuote) >= 0) {
              shiftIndex = j;
              slices.push(part);
              break;
            }
          }
          if (shiftIndex) i = shiftIndex;
        }
      } else if (part.indexOf('=') > 0) {
        // Hash
        const hashParts = part.split('=');
        const hashName = hashParts[0];
        let hashContent = hashParts[1];
        if (!blockQuoteRegExp) {
          blockQuoteRegExp = hashContent.indexOf('"') === 0 ? quoteDoubleRexExp : quoteSingleRexExp;
          openingQuote = hashContent.indexOf('"') === 0 ? '"' : '\'';
        }
        if (hashContent.match(blockQuoteRegExp).length !== 2) {
          shiftIndex = 0;
          for (j = i + 1; j < helperParts.length; j += 1) {
            hashContent += ` ${helperParts[j]}`;
            if (helperParts[j].indexOf(openingQuote) >= 0) {
              shiftIndex = j;
              break;
            }
          }
          if (shiftIndex) i = shiftIndex;
        }
        const hash = [hashName, hashContent.replace(blockQuoteRegExp, '')];
        slices.push(hash);
      } else {
        // Plain variable
        slices.push(part);
      }
    }
    return slices;
  },
  stringToBlocks(string) {
    const blocks = [];
    let i;
    let j;
    if (!string) return [];
    const stringBlocks = string.split(/({{[^{^}]*}})/);
    for (i = 0; i < stringBlocks.length; i += 1) {
      let block = stringBlocks[i];
      if (block === '') continue;
      if (block.indexOf('{{') < 0) {
        blocks.push({
          type: 'plain',
          content: block,
        });
      } else {
        if (block.indexOf('{/') >= 0) {
          continue;
        }
        block = block
          .replace(/{{([#/])*([ ])*/, '{{$1')
          .replace(/([ ])*}}/, '}}');
        if (block.indexOf('{#') < 0 && block.indexOf(' ') < 0 && block.indexOf('else') < 0) {
          // Simple variable
          blocks.push({
            type: 'variable',
            contextName: block.replace(/[{}]/g, ''),
          });
          continue;
        }
        // Helpers
        const helperSlices = Template7Utils.helperToSlices(block);
        let helperName = helperSlices[0];
        const isPartial = helperName === '>';
        const helperContext = [];
        const helperHash = {};
        for (j = 1; j < helperSlices.length; j += 1) {
          const slice = helperSlices[j];
          if (Array.isArray(slice)) {
            // Hash
            helperHash[slice[0]] = slice[1] === 'false' ? false : slice[1];
          } else {
            helperContext.push(slice);
          }
        }

        if (block.indexOf('{#') >= 0) {
          // Condition/Helper
          let helperContent = '';
          let elseContent = '';
          let toSkip = 0;
          let shiftIndex;
          let foundClosed = false;
          let foundElse = false;
          let depth = 0;
          for (j = i + 1; j < stringBlocks.length; j += 1) {
            if (stringBlocks[j].indexOf('{{#') >= 0) {
              depth += 1;
            }
            if (stringBlocks[j].indexOf('{{/') >= 0) {
              depth -= 1;
            }
            if (stringBlocks[j].indexOf(`{{#${helperName}`) >= 0) {
              helperContent += stringBlocks[j];
              if (foundElse) elseContent += stringBlocks[j];
              toSkip += 1;
            } else if (stringBlocks[j].indexOf(`{{/${helperName}`) >= 0) {
              if (toSkip > 0) {
                toSkip -= 1;
                helperContent += stringBlocks[j];
                if (foundElse) elseContent += stringBlocks[j];
              } else {
                shiftIndex = j;
                foundClosed = true;
                break;
              }
            } else if (stringBlocks[j].indexOf('else') >= 0 && depth === 0) {
              foundElse = true;
            } else {
              if (!foundElse) helperContent += stringBlocks[j];
              if (foundElse) elseContent += stringBlocks[j];
            }
          }
          if (foundClosed) {
            if (shiftIndex) i = shiftIndex;
            if (helperName === 'raw') {
              blocks.push({
                type: 'plain',
                content: helperContent,
              });
            } else {
              blocks.push({
                type: 'helper',
                helperName,
                contextName: helperContext,
                content: helperContent,
                inverseContent: elseContent,
                hash: helperHash,
              });
            }
          }
        } else if (block.indexOf(' ') > 0) {
          if (isPartial) {
            helperName = '_partial';
            if (helperContext[0]) {
              if (helperContext[0].indexOf('[') === 0) helperContext[0] = helperContext[0].replace(/[[\]]/g, '');
              else helperContext[0] = `"${helperContext[0].replace(/"|'/g, '')}"`;
            }
          }
          blocks.push({
            type: 'helper',
            helperName,
            contextName: helperContext,
            hash: helperHash,
          });
        }
      }
    }
    return blocks;
  },
  parseJsVariable(expression, replace, object) {
    return expression.split(/([+ -*/^])/g).map((part) => {
      if (part.indexOf(replace) < 0) return part;
      if (!object) return JSON.stringify('');
      let variable = object;
      if (part.indexOf(`${replace}.`) >= 0) {
        part.split(`${replace}.`)[1].split('.').forEach((partName) => {
          if (variable[partName]) variable = variable[partName];
          else variable = 'undefined';
        });
      }
      return JSON.stringify(variable);
    }).join('');
  },
  parseJsParents(expression, parents) {
    return expression.split(/([+ -*^])/g).map((part) => {
      if (part.indexOf('../') < 0) return part;
      if (!parents || parents.length === 0) return JSON.stringify('');
      const levelsUp = part.split('../').length - 1;
      const parentData = levelsUp > parents.length ? parents[parents.length - 1] : parents[levelsUp - 1];

      let variable = parentData;
      const parentPart = part.replace(/..\//g, '');
      parentPart.split('.').forEach((partName) => {
        if (variable[partName]) variable = variable[partName];
        else variable = 'undefined';
      });
      return JSON.stringify(variable);
    }).join('');
  },
  getCompileVar(name, ctx, data = 'data_1') {
    let variable = ctx;
    let parts;
    let levelsUp = 0;
    let newDepth;
    if (name.indexOf('../') === 0) {
      levelsUp = name.split('../').length - 1;
      newDepth = variable.split('_')[1] - levelsUp;
      variable = `ctx_${newDepth >= 1 ? newDepth : 1}`;
      parts = name.split('../')[levelsUp].split('.');
    } else if (name.indexOf('@global') === 0) {
      variable = 'Template7.global';
      parts = name.split('@global.')[1].split('.');
    } else if (name.indexOf('@root') === 0) {
      variable = 'root';
      parts = name.split('@root.')[1].split('.');
    } else {
      parts = name.split('.');
    }
    for (let i = 0; i < parts.length; i += 1) {
      const part = parts[i];
      if (part.indexOf('@') === 0) {
        let dataLevel = data.split('_')[1];
        if (levelsUp > 0) {
          dataLevel = newDepth;
        }
        if (i > 0) {
          variable += `[(data_${dataLevel} && data_${dataLevel}.${part.replace('@', '')})]`;
        } else {
          variable = `(data_${dataLevel} && data_${dataLevel}.${part.replace('@', '')})`;
        }
      } else if (Number.isFinite ? Number.isFinite(part) : Template7Context.isFinite(part)) {
        variable += `[${part}]`;
      } else if (part === 'this' || part.indexOf('this.') >= 0 || part.indexOf('this[') >= 0 || part.indexOf('this(') >= 0) {
        variable = part.replace('this', ctx);
      } else {
        variable += `.${part}`;
      }
    }
    return variable;
  },
  getCompiledArguments(contextArray, ctx, data) {
    const arr = [];
    for (let i = 0; i < contextArray.length; i += 1) {
      if (/^['"]/.test(contextArray[i])) arr.push(contextArray[i]);
      else if (/^(true|false|\d+)$/.test(contextArray[i])) arr.push(contextArray[i]);
      else {
        arr.push(Template7Utils.getCompileVar(contextArray[i], ctx, data));
      }
    }

    return arr.join(', ');
  },
};

/* eslint no-eval: "off" */
const Template7Helpers = {
  _partial(partialName, options) {
    const ctx = this;
    const p = Template7Class.partials[partialName];
    if (!p || (p && !p.template)) return '';
    if (!p.compiled) {
      p.compiled = new Template7Class(p.template).compile();
    }
    Object.keys(options.hash).forEach((hashName) => {
      ctx[hashName] = options.hash[hashName];
    });
    return p.compiled(ctx, options.data, options.root);
  },
  escape(context) {
    if (typeof context !== 'string') {
      throw new Error('Template7: Passed context to "escape" helper should be a string');
    }
    return Template7Utils.escape(context);
  },
  if(context, options) {
    let ctx = context;
    if (Template7Utils.isFunction(ctx)) { ctx = ctx.call(this); }
    if (ctx) {
      return options.fn(this, options.data);
    }

    return options.inverse(this, options.data);
  },
  unless(context, options) {
    let ctx = context;
    if (Template7Utils.isFunction(ctx)) { ctx = ctx.call(this); }
    if (!ctx) {
      return options.fn(this, options.data);
    }

    return options.inverse(this, options.data);
  },
  each(context, options) {
    let ctx = context;
    let ret = '';
    let i = 0;
    if (Template7Utils.isFunction(ctx)) { ctx = ctx.call(this); }
    if (Array.isArray(ctx)) {
      if (options.hash.reverse) {
        ctx = ctx.reverse();
      }
      for (i = 0; i < ctx.length; i += 1) {
        ret += options.fn(ctx[i], { first: i === 0, last: i === ctx.length - 1, index: i });
      }
      if (options.hash.reverse) {
        ctx = ctx.reverse();
      }
    } else {
      // eslint-disable-next-line
      for (const key in ctx) {
        i += 1;
        ret += options.fn(ctx[key], { key });
      }
    }
    if (i > 0) return ret;
    return options.inverse(this);
  },
  with(context, options) {
    let ctx = context;
    if (Template7Utils.isFunction(ctx)) { ctx = context.call(this); }
    return options.fn(ctx);
  },
  join(context, options) {
    let ctx = context;
    if (Template7Utils.isFunction(ctx)) { ctx = ctx.call(this); }
    return ctx.join(options.hash.delimiter || options.hash.delimeter);
  },
  js(expression, options) {
    const data = options.data;
    let func;
    let execute = expression;
    ('index first last key').split(' ').forEach((prop) => {
      if (typeof data[prop] !== 'undefined') {
        const re1 = new RegExp(`this.@${prop}`, 'g');
        const re2 = new RegExp(`@${prop}`, 'g');
        execute = execute
          .replace(re1, JSON.stringify(data[prop]))
          .replace(re2, JSON.stringify(data[prop]));
      }
    });
    if (options.root && execute.indexOf('@root') >= 0) {
      execute = Template7Utils.parseJsVariable(execute, '@root', options.root);
    }
    if (execute.indexOf('@global') >= 0) {
      execute = Template7Utils.parseJsVariable(execute, '@global', Template7Context.Template7.global);
    }
    if (execute.indexOf('../') >= 0) {
      execute = Template7Utils.parseJsParents(execute, options.parents);
    }
    if (execute.indexOf('return') >= 0) {
      func = `(function(){${execute}})`;
    } else {
      func = `(function(){return (${execute})})`;
    }
    return eval(func).call(this);
  },
  js_if(expression, options) {
    const data = options.data;
    let func;
    let execute = expression;
    ('index first last key').split(' ').forEach((prop) => {
      if (typeof data[prop] !== 'undefined') {
        const re1 = new RegExp(`this.@${prop}`, 'g');
        const re2 = new RegExp(`@${prop}`, 'g');
        execute = execute
          .replace(re1, JSON.stringify(data[prop]))
          .replace(re2, JSON.stringify(data[prop]));
      }
    });
    if (options.root && execute.indexOf('@root') >= 0) {
      execute = Template7Utils.parseJsVariable(execute, '@root', options.root);
    }
    if (execute.indexOf('@global') >= 0) {
      execute = Template7Utils.parseJsVariable(execute, '@global', Template7Class.global);
    }
    if (execute.indexOf('../') >= 0) {
      execute = Template7Utils.parseJsParents(execute, options.parents);
    }
    if (execute.indexOf('return') >= 0) {
      func = `(function(){${execute}})`;
    } else {
      func = `(function(){return (${execute})})`;
    }
    const condition = eval(func).call(this);
    if (condition) {
      return options.fn(this, options.data);
    }

    return options.inverse(this, options.data);
  },
};
Template7Helpers.js_compare = Template7Helpers.js_if;

const Template7Options = {};
const Template7Partials = {};
const script = Template7Context.document.createElement('script');
Template7Context.document.head.appendChild(script);

class Template7Class {
  constructor(template) {
    const t = this;
    t.template = template;
  }
  compile(template = this.template, depth = 1) {
    const t = this;
    if (t.compiled) return t.compiled;

    if (typeof template !== 'string') {
      throw new Error('Template7: Template must be a string');
    }
    const { stringToBlocks, getCompileVar, getCompiledArguments } = Template7Utils;

    const blocks = stringToBlocks(template);
    const ctx = `ctx_${depth}`;
    const data = `data_${depth}`;
    if (blocks.length === 0) {
      return function empty() { return ''; };
    }

    function getCompileFn(block, newDepth) {
      if (block.content) return t.compile(block.content, newDepth);
      return function empty() { return ''; };
    }
    function getCompileInverse(block, newDepth) {
      if (block.inverseContent) return t.compile(block.inverseContent, newDepth);
      return function empty() { return ''; };
    }

    let resultString = '';
    if (depth === 1) {
      resultString += `(function (${ctx}, ${data}, root) {\n`;
    } else {
      resultString += `(function (${ctx}, ${data}) {\n`;
    }
    if (depth === 1) {
      resultString += 'function isArray(arr){return Array.isArray(arr);}\n';
      resultString += 'function isFunction(func){return (typeof func === \'function\');}\n';
      resultString += 'function c(val, ctx) {if (typeof val !== "undefined" && val !== null) {if (isFunction(val)) {return val.call(ctx);} else return val;} else return "";}\n';
      resultString += 'root = root || ctx_1 || {};\n';
    }
    resultString += 'var r = \'\';\n';
    let i;
    for (i = 0; i < blocks.length; i += 1) {
      const block = blocks[i];
      // Plain block
      if (block.type === 'plain') {
        // eslint-disable-next-line
        resultString += `r +='${(block.content).replace(/\r/g, '\\r').replace(/\n/g, '\\n').replace(/'/g, '\\' + '\'')}';`;
        continue;
      }
      let variable;
      let compiledArguments;
      // Variable block
      if (block.type === 'variable') {
        variable = getCompileVar(block.contextName, ctx, data);
        resultString += `r += c(${variable}, ${ctx});`;
      }
      // Helpers block
      if (block.type === 'helper') {
        let parents;
        if (ctx !== 'ctx_1') {
          const level = ctx.split('_')[1];
          let parentsString = `ctx_${level - 1}`;
          for (let j = level - 2; j >= 1; j -= 1) {
            parentsString += `, ctx_${j}`;
          }
          parents = `[${parentsString}]`;
        } else {
          parents = `[${ctx}]`;
        }
        let dynamicHelper;
        if (block.helperName.indexOf('[') === 0) {
          block.helperName = getCompileVar(block.helperName.replace(/[[\]]/g, ''), ctx, data);
          dynamicHelper = true;
        }
        if (dynamicHelper || block.helperName in Template7Helpers) {
          compiledArguments = getCompiledArguments(block.contextName, ctx, data);
          resultString += `r += (Template7Helpers${dynamicHelper ? `[${block.helperName}]` : `.${block.helperName}`}).call(${ctx}, ${compiledArguments && (`${compiledArguments}, `)}{hash:${JSON.stringify(block.hash)}, data: ${data} || {}, fn: ${getCompileFn(block, depth + 1)}, inverse: ${getCompileInverse(block, depth + 1)}, root: root, parents: ${parents}});`;
        } else if (block.contextName.length > 0) {
          throw new Error(`Template7: Missing helper: "${block.helperName}"`);
        } else {
          variable = getCompileVar(block.helperName, ctx, data);
          resultString += `if (${variable}) {`;
          resultString += `if (isArray(${variable})) {`;
          resultString += `r += (Template7Helpers.each).call(${ctx}, ${variable}, {hash:${JSON.stringify(block.hash)}, data: ${data} || {}, fn: ${getCompileFn(block, depth + 1)}, inverse: ${getCompileInverse(block, depth + 1)}, root: root, parents: ${parents}});`;
          resultString += '}else {';
          resultString += `r += (Template7Helpers.with).call(${ctx}, ${variable}, {hash:${JSON.stringify(block.hash)}, data: ${data} || {}, fn: ${getCompileFn(block, depth + 1)}, inverse: ${getCompileInverse(block, depth + 1)}, root: root, parents: ${parents}});`;
          resultString += '}}';
        }
      }
    }
    resultString += '\nreturn r;})';

    if (depth === 1) {
      // eslint-disable-next-line
      t.compiled = eval(resultString);
      return t.compiled;
    }
    return resultString;
  }
  static get options() {
    return Template7Options;
  }
  static get partials() {
    return Template7Partials;
  }
  static get helpers() {
    return Template7Helpers;
  }
}

function Template7(...args) {
  const [template, data] = args;
  if (args.length === 2) {
    let instance = new Template7Class(template);
    const rendered = instance.compile()(data);
    instance = null;
    return (rendered);
  }
  return new Template7Class(template);
}
Template7.registerHelper = function registerHelper(name, fn) {
  Template7Class.helpers[name] = fn;
};
Template7.unregisterHelper = function unregisterHelper(name) {
  Template7Class.helpers[name] = undefined;
  delete Template7Class.helpers[name];
};
Template7.registerPartial = function registerPartial(name, template) {
  Template7Class.partials[name] = { template };
};
Template7.unregisterPartial = function unregisterPartial(name) {
  if (Template7Class.partials[name]) {
    Template7Class.partials[name] = undefined;
    delete Template7Class.partials[name];
  }
};
Template7.compile = function compile(template, options) {
  const instance = new Template7Class(template, options);
  return instance.compile();
};

Template7.options = Template7Class.options;
Template7.helpers = Template7Class.helpers;
Template7.partials = Template7Class.partials;

/* harmony default export */ __webpack_exports__["a"] = (Template7);

/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__("./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/timers-browserify/main.js":
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var scope = (typeof global !== "undefined" && global) ||
            (typeof self !== "undefined" && self) ||
            window;
var apply = Function.prototype.apply;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(scope, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// setimmediate attaches itself to the global object
__webpack_require__("./node_modules/setimmediate/setImmediate.js");
// On some exotic environments, it's not clear which object `setimmediate` was
// able to install onto.  Search each possibility in the same order as the
// `setimmediate` library.
exports.setImmediate = (typeof self !== "undefined" && self.setImmediate) ||
                       (typeof global !== "undefined" && global.setImmediate) ||
                       (this && this.setImmediate);
exports.clearImmediate = (typeof self !== "undefined" && self.clearImmediate) ||
                         (typeof global !== "undefined" && global.clearImmediate) ||
                         (this && this.clearImmediate);

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__("./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/vue/dist/vue.common.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global, setImmediate) {/*!
 * Vue.js v2.5.16
 * (c) 2014-2018 Evan You
 * Released under the MIT License.
 */


/*  */

var emptyObject = Object.freeze({});

// these helpers produces better vm code in JS engines due to their
// explicitness and function inlining
function isUndef (v) {
  return v === undefined || v === null
}

function isDef (v) {
  return v !== undefined && v !== null
}

function isTrue (v) {
  return v === true
}

function isFalse (v) {
  return v === false
}

/**
 * Check if value is primitive
 */
function isPrimitive (value) {
  return (
    typeof value === 'string' ||
    typeof value === 'number' ||
    // $flow-disable-line
    typeof value === 'symbol' ||
    typeof value === 'boolean'
  )
}

/**
 * Quick object check - this is primarily used to tell
 * Objects from primitive values when we know the value
 * is a JSON-compliant type.
 */
function isObject (obj) {
  return obj !== null && typeof obj === 'object'
}

/**
 * Get the raw type string of a value e.g. [object Object]
 */
var _toString = Object.prototype.toString;

function toRawType (value) {
  return _toString.call(value).slice(8, -1)
}

/**
 * Strict object type check. Only returns true
 * for plain JavaScript objects.
 */
function isPlainObject (obj) {
  return _toString.call(obj) === '[object Object]'
}

function isRegExp (v) {
  return _toString.call(v) === '[object RegExp]'
}

/**
 * Check if val is a valid array index.
 */
function isValidArrayIndex (val) {
  var n = parseFloat(String(val));
  return n >= 0 && Math.floor(n) === n && isFinite(val)
}

/**
 * Convert a value to a string that is actually rendered.
 */
function toString (val) {
  return val == null
    ? ''
    : typeof val === 'object'
      ? JSON.stringify(val, null, 2)
      : String(val)
}

/**
 * Convert a input value to a number for persistence.
 * If the conversion fails, return original string.
 */
function toNumber (val) {
  var n = parseFloat(val);
  return isNaN(n) ? val : n
}

/**
 * Make a map and return a function for checking if a key
 * is in that map.
 */
function makeMap (
  str,
  expectsLowerCase
) {
  var map = Object.create(null);
  var list = str.split(',');
  for (var i = 0; i < list.length; i++) {
    map[list[i]] = true;
  }
  return expectsLowerCase
    ? function (val) { return map[val.toLowerCase()]; }
    : function (val) { return map[val]; }
}

/**
 * Check if a tag is a built-in tag.
 */
var isBuiltInTag = makeMap('slot,component', true);

/**
 * Check if a attribute is a reserved attribute.
 */
var isReservedAttribute = makeMap('key,ref,slot,slot-scope,is');

/**
 * Remove an item from an array
 */
function remove (arr, item) {
  if (arr.length) {
    var index = arr.indexOf(item);
    if (index > -1) {
      return arr.splice(index, 1)
    }
  }
}

/**
 * Check whether the object has the property.
 */
var hasOwnProperty = Object.prototype.hasOwnProperty;
function hasOwn (obj, key) {
  return hasOwnProperty.call(obj, key)
}

/**
 * Create a cached version of a pure function.
 */
function cached (fn) {
  var cache = Object.create(null);
  return (function cachedFn (str) {
    var hit = cache[str];
    return hit || (cache[str] = fn(str))
  })
}

/**
 * Camelize a hyphen-delimited string.
 */
var camelizeRE = /-(\w)/g;
var camelize = cached(function (str) {
  return str.replace(camelizeRE, function (_, c) { return c ? c.toUpperCase() : ''; })
});

/**
 * Capitalize a string.
 */
var capitalize = cached(function (str) {
  return str.charAt(0).toUpperCase() + str.slice(1)
});

/**
 * Hyphenate a camelCase string.
 */
var hyphenateRE = /\B([A-Z])/g;
var hyphenate = cached(function (str) {
  return str.replace(hyphenateRE, '-$1').toLowerCase()
});

/**
 * Simple bind polyfill for environments that do not support it... e.g.
 * PhantomJS 1.x. Technically we don't need this anymore since native bind is
 * now more performant in most browsers, but removing it would be breaking for
 * code that was able to run in PhantomJS 1.x, so this must be kept for
 * backwards compatibility.
 */

/* istanbul ignore next */
function polyfillBind (fn, ctx) {
  function boundFn (a) {
    var l = arguments.length;
    return l
      ? l > 1
        ? fn.apply(ctx, arguments)
        : fn.call(ctx, a)
      : fn.call(ctx)
  }

  boundFn._length = fn.length;
  return boundFn
}

function nativeBind (fn, ctx) {
  return fn.bind(ctx)
}

var bind = Function.prototype.bind
  ? nativeBind
  : polyfillBind;

/**
 * Convert an Array-like object to a real Array.
 */
function toArray (list, start) {
  start = start || 0;
  var i = list.length - start;
  var ret = new Array(i);
  while (i--) {
    ret[i] = list[i + start];
  }
  return ret
}

/**
 * Mix properties into target object.
 */
function extend (to, _from) {
  for (var key in _from) {
    to[key] = _from[key];
  }
  return to
}

/**
 * Merge an Array of Objects into a single Object.
 */
function toObject (arr) {
  var res = {};
  for (var i = 0; i < arr.length; i++) {
    if (arr[i]) {
      extend(res, arr[i]);
    }
  }
  return res
}

/**
 * Perform no operation.
 * Stubbing args to make Flow happy without leaving useless transpiled code
 * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/)
 */
function noop (a, b, c) {}

/**
 * Always return false.
 */
var no = function (a, b, c) { return false; };

/**
 * Return same value
 */
var identity = function (_) { return _; };

/**
 * Generate a static keys string from compiler modules.
 */
function genStaticKeys (modules) {
  return modules.reduce(function (keys, m) {
    return keys.concat(m.staticKeys || [])
  }, []).join(',')
}

/**
 * Check if two values are loosely equal - that is,
 * if they are plain objects, do they have the same shape?
 */
function looseEqual (a, b) {
  if (a === b) { return true }
  var isObjectA = isObject(a);
  var isObjectB = isObject(b);
  if (isObjectA && isObjectB) {
    try {
      var isArrayA = Array.isArray(a);
      var isArrayB = Array.isArray(b);
      if (isArrayA && isArrayB) {
        return a.length === b.length && a.every(function (e, i) {
          return looseEqual(e, b[i])
        })
      } else if (!isArrayA && !isArrayB) {
        var keysA = Object.keys(a);
        var keysB = Object.keys(b);
        return keysA.length === keysB.length && keysA.every(function (key) {
          return looseEqual(a[key], b[key])
        })
      } else {
        /* istanbul ignore next */
        return false
      }
    } catch (e) {
      /* istanbul ignore next */
      return false
    }
  } else if (!isObjectA && !isObjectB) {
    return String(a) === String(b)
  } else {
    return false
  }
}

function looseIndexOf (arr, val) {
  for (var i = 0; i < arr.length; i++) {
    if (looseEqual(arr[i], val)) { return i }
  }
  return -1
}

/**
 * Ensure a function is called only once.
 */
function once (fn) {
  var called = false;
  return function () {
    if (!called) {
      called = true;
      fn.apply(this, arguments);
    }
  }
}

var SSR_ATTR = 'data-server-rendered';

var ASSET_TYPES = [
  'component',
  'directive',
  'filter'
];

var LIFECYCLE_HOOKS = [
  'beforeCreate',
  'created',
  'beforeMount',
  'mounted',
  'beforeUpdate',
  'updated',
  'beforeDestroy',
  'destroyed',
  'activated',
  'deactivated',
  'errorCaptured'
];

/*  */

var config = ({
  /**
   * Option merge strategies (used in core/util/options)
   */
  // $flow-disable-line
  optionMergeStrategies: Object.create(null),

  /**
   * Whether to suppress warnings.
   */
  silent: false,

  /**
   * Show production mode tip message on boot?
   */
  productionTip: "development" !== 'production',

  /**
   * Whether to enable devtools
   */
  devtools: "development" !== 'production',

  /**
   * Whether to record perf
   */
  performance: false,

  /**
   * Error handler for watcher errors
   */
  errorHandler: null,

  /**
   * Warn handler for watcher warns
   */
  warnHandler: null,

  /**
   * Ignore certain custom elements
   */
  ignoredElements: [],

  /**
   * Custom user key aliases for v-on
   */
  // $flow-disable-line
  keyCodes: Object.create(null),

  /**
   * Check if a tag is reserved so that it cannot be registered as a
   * component. This is platform-dependent and may be overwritten.
   */
  isReservedTag: no,

  /**
   * Check if an attribute is reserved so that it cannot be used as a component
   * prop. This is platform-dependent and may be overwritten.
   */
  isReservedAttr: no,

  /**
   * Check if a tag is an unknown element.
   * Platform-dependent.
   */
  isUnknownElement: no,

  /**
   * Get the namespace of an element
   */
  getTagNamespace: noop,

  /**
   * Parse the real tag name for the specific platform.
   */
  parsePlatformTagName: identity,

  /**
   * Check if an attribute must be bound using property, e.g. value
   * Platform-dependent.
   */
  mustUseProp: no,

  /**
   * Exposed for legacy reasons
   */
  _lifecycleHooks: LIFECYCLE_HOOKS
})

/*  */

/**
 * Check if a string starts with $ or _
 */
function isReserved (str) {
  var c = (str + '').charCodeAt(0);
  return c === 0x24 || c === 0x5F
}

/**
 * Define a property.
 */
function def (obj, key, val, enumerable) {
  Object.defineProperty(obj, key, {
    value: val,
    enumerable: !!enumerable,
    writable: true,
    configurable: true
  });
}

/**
 * Parse simple path.
 */
var bailRE = /[^\w.$]/;
function parsePath (path) {
  if (bailRE.test(path)) {
    return
  }
  var segments = path.split('.');
  return function (obj) {
    for (var i = 0; i < segments.length; i++) {
      if (!obj) { return }
      obj = obj[segments[i]];
    }
    return obj
  }
}

/*  */

// can we use __proto__?
var hasProto = '__proto__' in {};

// Browser environment sniffing
var inBrowser = typeof window !== 'undefined';
var inWeex = typeof WXEnvironment !== 'undefined' && !!WXEnvironment.platform;
var weexPlatform = inWeex && WXEnvironment.platform.toLowerCase();
var UA = inBrowser && window.navigator.userAgent.toLowerCase();
var isIE = UA && /msie|trident/.test(UA);
var isIE9 = UA && UA.indexOf('msie 9.0') > 0;
var isEdge = UA && UA.indexOf('edge/') > 0;
var isAndroid = (UA && UA.indexOf('android') > 0) || (weexPlatform === 'android');
var isIOS = (UA && /iphone|ipad|ipod|ios/.test(UA)) || (weexPlatform === 'ios');
var isChrome = UA && /chrome\/\d+/.test(UA) && !isEdge;

// Firefox has a "watch" function on Object.prototype...
var nativeWatch = ({}).watch;

var supportsPassive = false;
if (inBrowser) {
  try {
    var opts = {};
    Object.defineProperty(opts, 'passive', ({
      get: function get () {
        /* istanbul ignore next */
        supportsPassive = true;
      }
    })); // https://github.com/facebook/flow/issues/285
    window.addEventListener('test-passive', null, opts);
  } catch (e) {}
}

// this needs to be lazy-evaled because vue may be required before
// vue-server-renderer can set VUE_ENV
var _isServer;
var isServerRendering = function () {
  if (_isServer === undefined) {
    /* istanbul ignore if */
    if (!inBrowser && !inWeex && typeof global !== 'undefined') {
      // detect presence of vue-server-renderer and avoid
      // Webpack shimming the process
      _isServer = global['process'].env.VUE_ENV === 'server';
    } else {
      _isServer = false;
    }
  }
  return _isServer
};

// detect devtools
var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;

/* istanbul ignore next */
function isNative (Ctor) {
  return typeof Ctor === 'function' && /native code/.test(Ctor.toString())
}

var hasSymbol =
  typeof Symbol !== 'undefined' && isNative(Symbol) &&
  typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);

var _Set;
/* istanbul ignore if */ // $flow-disable-line
if (typeof Set !== 'undefined' && isNative(Set)) {
  // use native Set when available.
  _Set = Set;
} else {
  // a non-standard Set polyfill that only works with primitive keys.
  _Set = (function () {
    function Set () {
      this.set = Object.create(null);
    }
    Set.prototype.has = function has (key) {
      return this.set[key] === true
    };
    Set.prototype.add = function add (key) {
      this.set[key] = true;
    };
    Set.prototype.clear = function clear () {
      this.set = Object.create(null);
    };

    return Set;
  }());
}

/*  */

var warn = noop;
var tip = noop;
var generateComponentTrace = (noop); // work around flow check
var formatComponentName = (noop);

if (true) {
  var hasConsole = typeof console !== 'undefined';
  var classifyRE = /(?:^|[-_])(\w)/g;
  var classify = function (str) { return str
    .replace(classifyRE, function (c) { return c.toUpperCase(); })
    .replace(/[-_]/g, ''); };

  warn = function (msg, vm) {
    var trace = vm ? generateComponentTrace(vm) : '';

    if (config.warnHandler) {
      config.warnHandler.call(null, msg, vm, trace);
    } else if (hasConsole && (!config.silent)) {
      console.error(("[Vue warn]: " + msg + trace));
    }
  };

  tip = function (msg, vm) {
    if (hasConsole && (!config.silent)) {
      console.warn("[Vue tip]: " + msg + (
        vm ? generateComponentTrace(vm) : ''
      ));
    }
  };

  formatComponentName = function (vm, includeFile) {
    if (vm.$root === vm) {
      return '<Root>'
    }
    var options = typeof vm === 'function' && vm.cid != null
      ? vm.options
      : vm._isVue
        ? vm.$options || vm.constructor.options
        : vm || {};
    var name = options.name || options._componentTag;
    var file = options.__file;
    if (!name && file) {
      var match = file.match(/([^/\\]+)\.vue$/);
      name = match && match[1];
    }

    return (
      (name ? ("<" + (classify(name)) + ">") : "<Anonymous>") +
      (file && includeFile !== false ? (" at " + file) : '')
    )
  };

  var repeat = function (str, n) {
    var res = '';
    while (n) {
      if (n % 2 === 1) { res += str; }
      if (n > 1) { str += str; }
      n >>= 1;
    }
    return res
  };

  generateComponentTrace = function (vm) {
    if (vm._isVue && vm.$parent) {
      var tree = [];
      var currentRecursiveSequence = 0;
      while (vm) {
        if (tree.length > 0) {
          var last = tree[tree.length - 1];
          if (last.constructor === vm.constructor) {
            currentRecursiveSequence++;
            vm = vm.$parent;
            continue
          } else if (currentRecursiveSequence > 0) {
            tree[tree.length - 1] = [last, currentRecursiveSequence];
            currentRecursiveSequence = 0;
          }
        }
        tree.push(vm);
        vm = vm.$parent;
      }
      return '\n\nfound in\n\n' + tree
        .map(function (vm, i) { return ("" + (i === 0 ? '---> ' : repeat(' ', 5 + i * 2)) + (Array.isArray(vm)
            ? ((formatComponentName(vm[0])) + "... (" + (vm[1]) + " recursive calls)")
            : formatComponentName(vm))); })
        .join('\n')
    } else {
      return ("\n\n(found in " + (formatComponentName(vm)) + ")")
    }
  };
}

/*  */


var uid = 0;

/**
 * A dep is an observable that can have multiple
 * directives subscribing to it.
 */
var Dep = function Dep () {
  this.id = uid++;
  this.subs = [];
};

Dep.prototype.addSub = function addSub (sub) {
  this.subs.push(sub);
};

Dep.prototype.removeSub = function removeSub (sub) {
  remove(this.subs, sub);
};

Dep.prototype.depend = function depend () {
  if (Dep.target) {
    Dep.target.addDep(this);
  }
};

Dep.prototype.notify = function notify () {
  // stabilize the subscriber list first
  var subs = this.subs.slice();
  for (var i = 0, l = subs.length; i < l; i++) {
    subs[i].update();
  }
};

// the current target watcher being evaluated.
// this is globally unique because there could be only one
// watcher being evaluated at any time.
Dep.target = null;
var targetStack = [];

function pushTarget (_target) {
  if (Dep.target) { targetStack.push(Dep.target); }
  Dep.target = _target;
}

function popTarget () {
  Dep.target = targetStack.pop();
}

/*  */

var VNode = function VNode (
  tag,
  data,
  children,
  text,
  elm,
  context,
  componentOptions,
  asyncFactory
) {
  this.tag = tag;
  this.data = data;
  this.children = children;
  this.text = text;
  this.elm = elm;
  this.ns = undefined;
  this.context = context;
  this.fnContext = undefined;
  this.fnOptions = undefined;
  this.fnScopeId = undefined;
  this.key = data && data.key;
  this.componentOptions = componentOptions;
  this.componentInstance = undefined;
  this.parent = undefined;
  this.raw = false;
  this.isStatic = false;
  this.isRootInsert = true;
  this.isComment = false;
  this.isCloned = false;
  this.isOnce = false;
  this.asyncFactory = asyncFactory;
  this.asyncMeta = undefined;
  this.isAsyncPlaceholder = false;
};

var prototypeAccessors = { child: { configurable: true } };

// DEPRECATED: alias for componentInstance for backwards compat.
/* istanbul ignore next */
prototypeAccessors.child.get = function () {
  return this.componentInstance
};

Object.defineProperties( VNode.prototype, prototypeAccessors );

var createEmptyVNode = function (text) {
  if ( text === void 0 ) text = '';

  var node = new VNode();
  node.text = text;
  node.isComment = true;
  return node
};

function createTextVNode (val) {
  return new VNode(undefined, undefined, undefined, String(val))
}

// optimized shallow clone
// used for static nodes and slot nodes because they may be reused across
// multiple renders, cloning them avoids errors when DOM manipulations rely
// on their elm reference.
function cloneVNode (vnode) {
  var cloned = new VNode(
    vnode.tag,
    vnode.data,
    vnode.children,
    vnode.text,
    vnode.elm,
    vnode.context,
    vnode.componentOptions,
    vnode.asyncFactory
  );
  cloned.ns = vnode.ns;
  cloned.isStatic = vnode.isStatic;
  cloned.key = vnode.key;
  cloned.isComment = vnode.isComment;
  cloned.fnContext = vnode.fnContext;
  cloned.fnOptions = vnode.fnOptions;
  cloned.fnScopeId = vnode.fnScopeId;
  cloned.isCloned = true;
  return cloned
}

/*
 * not type checking this file because flow doesn't play well with
 * dynamically accessing methods on Array prototype
 */

var arrayProto = Array.prototype;
var arrayMethods = Object.create(arrayProto);

var methodsToPatch = [
  'push',
  'pop',
  'shift',
  'unshift',
  'splice',
  'sort',
  'reverse'
];

/**
 * Intercept mutating methods and emit events
 */
methodsToPatch.forEach(function (method) {
  // cache original method
  var original = arrayProto[method];
  def(arrayMethods, method, function mutator () {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

    var result = original.apply(this, args);
    var ob = this.__ob__;
    var inserted;
    switch (method) {
      case 'push':
      case 'unshift':
        inserted = args;
        break
      case 'splice':
        inserted = args.slice(2);
        break
    }
    if (inserted) { ob.observeArray(inserted); }
    // notify change
    ob.dep.notify();
    return result
  });
});

/*  */

var arrayKeys = Object.getOwnPropertyNames(arrayMethods);

/**
 * In some cases we may want to disable observation inside a component's
 * update computation.
 */
var shouldObserve = true;

function toggleObserving (value) {
  shouldObserve = value;
}

/**
 * Observer class that is attached to each observed
 * object. Once attached, the observer converts the target
 * object's property keys into getter/setters that
 * collect dependencies and dispatch updates.
 */
var Observer = function Observer (value) {
  this.value = value;
  this.dep = new Dep();
  this.vmCount = 0;
  def(value, '__ob__', this);
  if (Array.isArray(value)) {
    var augment = hasProto
      ? protoAugment
      : copyAugment;
    augment(value, arrayMethods, arrayKeys);
    this.observeArray(value);
  } else {
    this.walk(value);
  }
};

/**
 * Walk through each property and convert them into
 * getter/setters. This method should only be called when
 * value type is Object.
 */
Observer.prototype.walk = function walk (obj) {
  var keys = Object.keys(obj);
  for (var i = 0; i < keys.length; i++) {
    defineReactive(obj, keys[i]);
  }
};

/**
 * Observe a list of Array items.
 */
Observer.prototype.observeArray = function observeArray (items) {
  for (var i = 0, l = items.length; i < l; i++) {
    observe(items[i]);
  }
};

// helpers

/**
 * Augment an target Object or Array by intercepting
 * the prototype chain using __proto__
 */
function protoAugment (target, src, keys) {
  /* eslint-disable no-proto */
  target.__proto__ = src;
  /* eslint-enable no-proto */
}

/**
 * Augment an target Object or Array by defining
 * hidden properties.
 */
/* istanbul ignore next */
function copyAugment (target, src, keys) {
  for (var i = 0, l = keys.length; i < l; i++) {
    var key = keys[i];
    def(target, key, src[key]);
  }
}

/**
 * Attempt to create an observer instance for a value,
 * returns the new observer if successfully observed,
 * or the existing observer if the value already has one.
 */
function observe (value, asRootData) {
  if (!isObject(value) || value instanceof VNode) {
    return
  }
  var ob;
  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
    ob = value.__ob__;
  } else if (
    shouldObserve &&
    !isServerRendering() &&
    (Array.isArray(value) || isPlainObject(value)) &&
    Object.isExtensible(value) &&
    !value._isVue
  ) {
    ob = new Observer(value);
  }
  if (asRootData && ob) {
    ob.vmCount++;
  }
  return ob
}

/**
 * Define a reactive property on an Object.
 */
function defineReactive (
  obj,
  key,
  val,
  customSetter,
  shallow
) {
  var dep = new Dep();

  var property = Object.getOwnPropertyDescriptor(obj, key);
  if (property && property.configurable === false) {
    return
  }

  // cater for pre-defined getter/setters
  var getter = property && property.get;
  if (!getter && arguments.length === 2) {
    val = obj[key];
  }
  var setter = property && property.set;

  var childOb = !shallow && observe(val);
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter () {
      var value = getter ? getter.call(obj) : val;
      if (Dep.target) {
        dep.depend();
        if (childOb) {
          childOb.dep.depend();
          if (Array.isArray(value)) {
            dependArray(value);
          }
        }
      }
      return value
    },
    set: function reactiveSetter (newVal) {
      var value = getter ? getter.call(obj) : val;
      /* eslint-disable no-self-compare */
      if (newVal === value || (newVal !== newVal && value !== value)) {
        return
      }
      /* eslint-enable no-self-compare */
      if ("development" !== 'production' && customSetter) {
        customSetter();
      }
      if (setter) {
        setter.call(obj, newVal);
      } else {
        val = newVal;
      }
      childOb = !shallow && observe(newVal);
      dep.notify();
    }
  });
}

/**
 * Set a property on an object. Adds the new property and
 * triggers change notification if the property doesn't
 * already exist.
 */
function set (target, key, val) {
  if ("development" !== 'production' &&
    (isUndef(target) || isPrimitive(target))
  ) {
    warn(("Cannot set reactive property on undefined, null, or primitive value: " + ((target))));
  }
  if (Array.isArray(target) && isValidArrayIndex(key)) {
    target.length = Math.max(target.length, key);
    target.splice(key, 1, val);
    return val
  }
  if (key in target && !(key in Object.prototype)) {
    target[key] = val;
    return val
  }
  var ob = (target).__ob__;
  if (target._isVue || (ob && ob.vmCount)) {
    "development" !== 'production' && warn(
      'Avoid adding reactive properties to a Vue instance or its root $data ' +
      'at runtime - declare it upfront in the data option.'
    );
    return val
  }
  if (!ob) {
    target[key] = val;
    return val
  }
  defineReactive(ob.value, key, val);
  ob.dep.notify();
  return val
}

/**
 * Delete a property and trigger change if necessary.
 */
function del (target, key) {
  if ("development" !== 'production' &&
    (isUndef(target) || isPrimitive(target))
  ) {
    warn(("Cannot delete reactive property on undefined, null, or primitive value: " + ((target))));
  }
  if (Array.isArray(target) && isValidArrayIndex(key)) {
    target.splice(key, 1);
    return
  }
  var ob = (target).__ob__;
  if (target._isVue || (ob && ob.vmCount)) {
    "development" !== 'production' && warn(
      'Avoid deleting properties on a Vue instance or its root $data ' +
      '- just set it to null.'
    );
    return
  }
  if (!hasOwn(target, key)) {
    return
  }
  delete target[key];
  if (!ob) {
    return
  }
  ob.dep.notify();
}

/**
 * Collect dependencies on array elements when the array is touched, since
 * we cannot intercept array element access like property getters.
 */
function dependArray (value) {
  for (var e = (void 0), i = 0, l = value.length; i < l; i++) {
    e = value[i];
    e && e.__ob__ && e.__ob__.dep.depend();
    if (Array.isArray(e)) {
      dependArray(e);
    }
  }
}

/*  */

/**
 * Option overwriting strategies are functions that handle
 * how to merge a parent option value and a child option
 * value into the final value.
 */
var strats = config.optionMergeStrategies;

/**
 * Options with restrictions
 */
if (true) {
  strats.el = strats.propsData = function (parent, child, vm, key) {
    if (!vm) {
      warn(
        "option \"" + key + "\" can only be used during instance " +
        'creation with the `new` keyword.'
      );
    }
    return defaultStrat(parent, child)
  };
}

/**
 * Helper that recursively merges two data objects together.
 */
function mergeData (to, from) {
  if (!from) { return to }
  var key, toVal, fromVal;
  var keys = Object.keys(from);
  for (var i = 0; i < keys.length; i++) {
    key = keys[i];
    toVal = to[key];
    fromVal = from[key];
    if (!hasOwn(to, key)) {
      set(to, key, fromVal);
    } else if (isPlainObject(toVal) && isPlainObject(fromVal)) {
      mergeData(toVal, fromVal);
    }
  }
  return to
}

/**
 * Data
 */
function mergeDataOrFn (
  parentVal,
  childVal,
  vm
) {
  if (!vm) {
    // in a Vue.extend merge, both should be functions
    if (!childVal) {
      return parentVal
    }
    if (!parentVal) {
      return childVal
    }
    // when parentVal & childVal are both present,
    // we need to return a function that returns the
    // merged result of both functions... no need to
    // check if parentVal is a function here because
    // it has to be a function to pass previous merges.
    return function mergedDataFn () {
      return mergeData(
        typeof childVal === 'function' ? childVal.call(this, this) : childVal,
        typeof parentVal === 'function' ? parentVal.call(this, this) : parentVal
      )
    }
  } else {
    return function mergedInstanceDataFn () {
      // instance merge
      var instanceData = typeof childVal === 'function'
        ? childVal.call(vm, vm)
        : childVal;
      var defaultData = typeof parentVal === 'function'
        ? parentVal.call(vm, vm)
        : parentVal;
      if (instanceData) {
        return mergeData(instanceData, defaultData)
      } else {
        return defaultData
      }
    }
  }
}

strats.data = function (
  parentVal,
  childVal,
  vm
) {
  if (!vm) {
    if (childVal && typeof childVal !== 'function') {
      "development" !== 'production' && warn(
        'The "data" option should be a function ' +
        'that returns a per-instance value in component ' +
        'definitions.',
        vm
      );

      return parentVal
    }
    return mergeDataOrFn(parentVal, childVal)
  }

  return mergeDataOrFn(parentVal, childVal, vm)
};

/**
 * Hooks and props are merged as arrays.
 */
function mergeHook (
  parentVal,
  childVal
) {
  return childVal
    ? parentVal
      ? parentVal.concat(childVal)
      : Array.isArray(childVal)
        ? childVal
        : [childVal]
    : parentVal
}

LIFECYCLE_HOOKS.forEach(function (hook) {
  strats[hook] = mergeHook;
});

/**
 * Assets
 *
 * When a vm is present (instance creation), we need to do
 * a three-way merge between constructor options, instance
 * options and parent options.
 */
function mergeAssets (
  parentVal,
  childVal,
  vm,
  key
) {
  var res = Object.create(parentVal || null);
  if (childVal) {
    "development" !== 'production' && assertObjectType(key, childVal, vm);
    return extend(res, childVal)
  } else {
    return res
  }
}

ASSET_TYPES.forEach(function (type) {
  strats[type + 's'] = mergeAssets;
});

/**
 * Watchers.
 *
 * Watchers hashes should not overwrite one
 * another, so we merge them as arrays.
 */
strats.watch = function (
  parentVal,
  childVal,
  vm,
  key
) {
  // work around Firefox's Object.prototype.watch...
  if (parentVal === nativeWatch) { parentVal = undefined; }
  if (childVal === nativeWatch) { childVal = undefined; }
  /* istanbul ignore if */
  if (!childVal) { return Object.create(parentVal || null) }
  if (true) {
    assertObjectType(key, childVal, vm);
  }
  if (!parentVal) { return childVal }
  var ret = {};
  extend(ret, parentVal);
  for (var key$1 in childVal) {
    var parent = ret[key$1];
    var child = childVal[key$1];
    if (parent && !Array.isArray(parent)) {
      parent = [parent];
    }
    ret[key$1] = parent
      ? parent.concat(child)
      : Array.isArray(child) ? child : [child];
  }
  return ret
};

/**
 * Other object hashes.
 */
strats.props =
strats.methods =
strats.inject =
strats.computed = function (
  parentVal,
  childVal,
  vm,
  key
) {
  if (childVal && "development" !== 'production') {
    assertObjectType(key, childVal, vm);
  }
  if (!parentVal) { return childVal }
  var ret = Object.create(null);
  extend(ret, parentVal);
  if (childVal) { extend(ret, childVal); }
  return ret
};
strats.provide = mergeDataOrFn;

/**
 * Default strategy.
 */
var defaultStrat = function (parentVal, childVal) {
  return childVal === undefined
    ? parentVal
    : childVal
};

/**
 * Validate component names
 */
function checkComponents (options) {
  for (var key in options.components) {
    validateComponentName(key);
  }
}

function validateComponentName (name) {
  if (!/^[a-zA-Z][\w-]*$/.test(name)) {
    warn(
      'Invalid component name: "' + name + '". Component names ' +
      'can only contain alphanumeric characters and the hyphen, ' +
      'and must start with a letter.'
    );
  }
  if (isBuiltInTag(name) || config.isReservedTag(name)) {
    warn(
      'Do not use built-in or reserved HTML elements as component ' +
      'id: ' + name
    );
  }
}

/**
 * Ensure all props option syntax are normalized into the
 * Object-based format.
 */
function normalizeProps (options, vm) {
  var props = options.props;
  if (!props) { return }
  var res = {};
  var i, val, name;
  if (Array.isArray(props)) {
    i = props.length;
    while (i--) {
      val = props[i];
      if (typeof val === 'string') {
        name = camelize(val);
        res[name] = { type: null };
      } else if (true) {
        warn('props must be strings when using array syntax.');
      }
    }
  } else if (isPlainObject(props)) {
    for (var key in props) {
      val = props[key];
      name = camelize(key);
      res[name] = isPlainObject(val)
        ? val
        : { type: val };
    }
  } else if (true) {
    warn(
      "Invalid value for option \"props\": expected an Array or an Object, " +
      "but got " + (toRawType(props)) + ".",
      vm
    );
  }
  options.props = res;
}

/**
 * Normalize all injections into Object-based format
 */
function normalizeInject (options, vm) {
  var inject = options.inject;
  if (!inject) { return }
  var normalized = options.inject = {};
  if (Array.isArray(inject)) {
    for (var i = 0; i < inject.length; i++) {
      normalized[inject[i]] = { from: inject[i] };
    }
  } else if (isPlainObject(inject)) {
    for (var key in inject) {
      var val = inject[key];
      normalized[key] = isPlainObject(val)
        ? extend({ from: key }, val)
        : { from: val };
    }
  } else if (true) {
    warn(
      "Invalid value for option \"inject\": expected an Array or an Object, " +
      "but got " + (toRawType(inject)) + ".",
      vm
    );
  }
}

/**
 * Normalize raw function directives into object format.
 */
function normalizeDirectives (options) {
  var dirs = options.directives;
  if (dirs) {
    for (var key in dirs) {
      var def = dirs[key];
      if (typeof def === 'function') {
        dirs[key] = { bind: def, update: def };
      }
    }
  }
}

function assertObjectType (name, value, vm) {
  if (!isPlainObject(value)) {
    warn(
      "Invalid value for option \"" + name + "\": expected an Object, " +
      "but got " + (toRawType(value)) + ".",
      vm
    );
  }
}

/**
 * Merge two option objects into a new one.
 * Core utility used in both instantiation and inheritance.
 */
function mergeOptions (
  parent,
  child,
  vm
) {
  if (true) {
    checkComponents(child);
  }

  if (typeof child === 'function') {
    child = child.options;
  }

  normalizeProps(child, vm);
  normalizeInject(child, vm);
  normalizeDirectives(child);
  var extendsFrom = child.extends;
  if (extendsFrom) {
    parent = mergeOptions(parent, extendsFrom, vm);
  }
  if (child.mixins) {
    for (var i = 0, l = child.mixins.length; i < l; i++) {
      parent = mergeOptions(parent, child.mixins[i], vm);
    }
  }
  var options = {};
  var key;
  for (key in parent) {
    mergeField(key);
  }
  for (key in child) {
    if (!hasOwn(parent, key)) {
      mergeField(key);
    }
  }
  function mergeField (key) {
    var strat = strats[key] || defaultStrat;
    options[key] = strat(parent[key], child[key], vm, key);
  }
  return options
}

/**
 * Resolve an asset.
 * This function is used because child instances need access
 * to assets defined in its ancestor chain.
 */
function resolveAsset (
  options,
  type,
  id,
  warnMissing
) {
  /* istanbul ignore if */
  if (typeof id !== 'string') {
    return
  }
  var assets = options[type];
  // check local registration variations first
  if (hasOwn(assets, id)) { return assets[id] }
  var camelizedId = camelize(id);
  if (hasOwn(assets, camelizedId)) { return assets[camelizedId] }
  var PascalCaseId = capitalize(camelizedId);
  if (hasOwn(assets, PascalCaseId)) { return assets[PascalCaseId] }
  // fallback to prototype chain
  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];
  if ("development" !== 'production' && warnMissing && !res) {
    warn(
      'Failed to resolve ' + type.slice(0, -1) + ': ' + id,
      options
    );
  }
  return res
}

/*  */

function validateProp (
  key,
  propOptions,
  propsData,
  vm
) {
  var prop = propOptions[key];
  var absent = !hasOwn(propsData, key);
  var value = propsData[key];
  // boolean casting
  var booleanIndex = getTypeIndex(Boolean, prop.type);
  if (booleanIndex > -1) {
    if (absent && !hasOwn(prop, 'default')) {
      value = false;
    } else if (value === '' || value === hyphenate(key)) {
      // only cast empty string / same name to boolean if
      // boolean has higher priority
      var stringIndex = getTypeIndex(String, prop.type);
      if (stringIndex < 0 || booleanIndex < stringIndex) {
        value = true;
      }
    }
  }
  // check default value
  if (value === undefined) {
    value = getPropDefaultValue(vm, prop, key);
    // since the default value is a fresh copy,
    // make sure to observe it.
    var prevShouldObserve = shouldObserve;
    toggleObserving(true);
    observe(value);
    toggleObserving(prevShouldObserve);
  }
  if (
    true
  ) {
    assertProp(prop, key, value, vm, absent);
  }
  return value
}

/**
 * Get the default value of a prop.
 */
function getPropDefaultValue (vm, prop, key) {
  // no default, return undefined
  if (!hasOwn(prop, 'default')) {
    return undefined
  }
  var def = prop.default;
  // warn against non-factory defaults for Object & Array
  if ("development" !== 'production' && isObject(def)) {
    warn(
      'Invalid default value for prop "' + key + '": ' +
      'Props with type Object/Array must use a factory function ' +
      'to return the default value.',
      vm
    );
  }
  // the raw prop value was also undefined from previous render,
  // return previous default value to avoid unnecessary watcher trigger
  if (vm && vm.$options.propsData &&
    vm.$options.propsData[key] === undefined &&
    vm._props[key] !== undefined
  ) {
    return vm._props[key]
  }
  // call factory function for non-Function types
  // a value is Function if its prototype is function even across different execution context
  return typeof def === 'function' && getType(prop.type) !== 'Function'
    ? def.call(vm)
    : def
}

/**
 * Assert whether a prop is valid.
 */
function assertProp (
  prop,
  name,
  value,
  vm,
  absent
) {
  if (prop.required && absent) {
    warn(
      'Missing required prop: "' + name + '"',
      vm
    );
    return
  }
  if (value == null && !prop.required) {
    return
  }
  var type = prop.type;
  var valid = !type || type === true;
  var expectedTypes = [];
  if (type) {
    if (!Array.isArray(type)) {
      type = [type];
    }
    for (var i = 0; i < type.length && !valid; i++) {
      var assertedType = assertType(value, type[i]);
      expectedTypes.push(assertedType.expectedType || '');
      valid = assertedType.valid;
    }
  }
  if (!valid) {
    warn(
      "Invalid prop: type check failed for prop \"" + name + "\"." +
      " Expected " + (expectedTypes.map(capitalize).join(', ')) +
      ", got " + (toRawType(value)) + ".",
      vm
    );
    return
  }
  var validator = prop.validator;
  if (validator) {
    if (!validator(value)) {
      warn(
        'Invalid prop: custom validator check failed for prop "' + name + '".',
        vm
      );
    }
  }
}

var simpleCheckRE = /^(String|Number|Boolean|Function|Symbol)$/;

function assertType (value, type) {
  var valid;
  var expectedType = getType(type);
  if (simpleCheckRE.test(expectedType)) {
    var t = typeof value;
    valid = t === expectedType.toLowerCase();
    // for primitive wrapper objects
    if (!valid && t === 'object') {
      valid = value instanceof type;
    }
  } else if (expectedType === 'Object') {
    valid = isPlainObject(value);
  } else if (expectedType === 'Array') {
    valid = Array.isArray(value);
  } else {
    valid = value instanceof type;
  }
  return {
    valid: valid,
    expectedType: expectedType
  }
}

/**
 * Use function string name to check built-in types,
 * because a simple equality check will fail when running
 * across different vms / iframes.
 */
function getType (fn) {
  var match = fn && fn.toString().match(/^\s*function (\w+)/);
  return match ? match[1] : ''
}

function isSameType (a, b) {
  return getType(a) === getType(b)
}

function getTypeIndex (type, expectedTypes) {
  if (!Array.isArray(expectedTypes)) {
    return isSameType(expectedTypes, type) ? 0 : -1
  }
  for (var i = 0, len = expectedTypes.length; i < len; i++) {
    if (isSameType(expectedTypes[i], type)) {
      return i
    }
  }
  return -1
}

/*  */

function handleError (err, vm, info) {
  if (vm) {
    var cur = vm;
    while ((cur = cur.$parent)) {
      var hooks = cur.$options.errorCaptured;
      if (hooks) {
        for (var i = 0; i < hooks.length; i++) {
          try {
            var capture = hooks[i].call(cur, err, vm, info) === false;
            if (capture) { return }
          } catch (e) {
            globalHandleError(e, cur, 'errorCaptured hook');
          }
        }
      }
    }
  }
  globalHandleError(err, vm, info);
}

function globalHandleError (err, vm, info) {
  if (config.errorHandler) {
    try {
      return config.errorHandler.call(null, err, vm, info)
    } catch (e) {
      logError(e, null, 'config.errorHandler');
    }
  }
  logError(err, vm, info);
}

function logError (err, vm, info) {
  if (true) {
    warn(("Error in " + info + ": \"" + (err.toString()) + "\""), vm);
  }
  /* istanbul ignore else */
  if ((inBrowser || inWeex) && typeof console !== 'undefined') {
    console.error(err);
  } else {
    throw err
  }
}

/*  */
/* globals MessageChannel */

var callbacks = [];
var pending = false;

function flushCallbacks () {
  pending = false;
  var copies = callbacks.slice(0);
  callbacks.length = 0;
  for (var i = 0; i < copies.length; i++) {
    copies[i]();
  }
}

// Here we have async deferring wrappers using both microtasks and (macro) tasks.
// In < 2.4 we used microtasks everywhere, but there are some scenarios where
// microtasks have too high a priority and fire in between supposedly
// sequential events (e.g. #4521, #6690) or even between bubbling of the same
// event (#6566). However, using (macro) tasks everywhere also has subtle problems
// when state is changed right before repaint (e.g. #6813, out-in transitions).
// Here we use microtask by default, but expose a way to force (macro) task when
// needed (e.g. in event handlers attached by v-on).
var microTimerFunc;
var macroTimerFunc;
var useMacroTask = false;

// Determine (macro) task defer implementation.
// Technically setImmediate should be the ideal choice, but it's only available
// in IE. The only polyfill that consistently queues the callback after all DOM
// events triggered in the same loop is by using MessageChannel.
/* istanbul ignore if */
if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {
  macroTimerFunc = function () {
    setImmediate(flushCallbacks);
  };
} else if (typeof MessageChannel !== 'undefined' && (
  isNative(MessageChannel) ||
  // PhantomJS
  MessageChannel.toString() === '[object MessageChannelConstructor]'
)) {
  var channel = new MessageChannel();
  var port = channel.port2;
  channel.port1.onmessage = flushCallbacks;
  macroTimerFunc = function () {
    port.postMessage(1);
  };
} else {
  /* istanbul ignore next */
  macroTimerFunc = function () {
    setTimeout(flushCallbacks, 0);
  };
}

// Determine microtask defer implementation.
/* istanbul ignore next, $flow-disable-line */
if (typeof Promise !== 'undefined' && isNative(Promise)) {
  var p = Promise.resolve();
  microTimerFunc = function () {
    p.then(flushCallbacks);
    // in problematic UIWebViews, Promise.then doesn't completely break, but
    // it can get stuck in a weird state where callbacks are pushed into the
    // microtask queue but the queue isn't being flushed, until the browser
    // needs to do some other work, e.g. handle a timer. Therefore we can
    // "force" the microtask queue to be flushed by adding an empty timer.
    if (isIOS) { setTimeout(noop); }
  };
} else {
  // fallback to macro
  microTimerFunc = macroTimerFunc;
}

/**
 * Wrap a function so that if any code inside triggers state change,
 * the changes are queued using a (macro) task instead of a microtask.
 */
function withMacroTask (fn) {
  return fn._withTask || (fn._withTask = function () {
    useMacroTask = true;
    var res = fn.apply(null, arguments);
    useMacroTask = false;
    return res
  })
}

function nextTick (cb, ctx) {
  var _resolve;
  callbacks.push(function () {
    if (cb) {
      try {
        cb.call(ctx);
      } catch (e) {
        handleError(e, ctx, 'nextTick');
      }
    } else if (_resolve) {
      _resolve(ctx);
    }
  });
  if (!pending) {
    pending = true;
    if (useMacroTask) {
      macroTimerFunc();
    } else {
      microTimerFunc();
    }
  }
  // $flow-disable-line
  if (!cb && typeof Promise !== 'undefined') {
    return new Promise(function (resolve) {
      _resolve = resolve;
    })
  }
}

/*  */

var mark;
var measure;

if (true) {
  var perf = inBrowser && window.performance;
  /* istanbul ignore if */
  if (
    perf &&
    perf.mark &&
    perf.measure &&
    perf.clearMarks &&
    perf.clearMeasures
  ) {
    mark = function (tag) { return perf.mark(tag); };
    measure = function (name, startTag, endTag) {
      perf.measure(name, startTag, endTag);
      perf.clearMarks(startTag);
      perf.clearMarks(endTag);
      perf.clearMeasures(name);
    };
  }
}

/* not type checking this file because flow doesn't play well with Proxy */

var initProxy;

if (true) {
  var allowedGlobals = makeMap(
    'Infinity,undefined,NaN,isFinite,isNaN,' +
    'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' +
    'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' +
    'require' // for Webpack/Browserify
  );

  var warnNonPresent = function (target, key) {
    warn(
      "Property or method \"" + key + "\" is not defined on the instance but " +
      'referenced during render. Make sure that this property is reactive, ' +
      'either in the data option, or for class-based components, by ' +
      'initializing the property. ' +
      'See: https://vuejs.org/v2/guide/reactivity.html#Declaring-Reactive-Properties.',
      target
    );
  };

  var hasProxy =
    typeof Proxy !== 'undefined' && isNative(Proxy);

  if (hasProxy) {
    var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta,exact');
    config.keyCodes = new Proxy(config.keyCodes, {
      set: function set (target, key, value) {
        if (isBuiltInModifier(key)) {
          warn(("Avoid overwriting built-in modifier in config.keyCodes: ." + key));
          return false
        } else {
          target[key] = value;
          return true
        }
      }
    });
  }

  var hasHandler = {
    has: function has (target, key) {
      var has = key in target;
      var isAllowed = allowedGlobals(key) || key.charAt(0) === '_';
      if (!has && !isAllowed) {
        warnNonPresent(target, key);
      }
      return has || !isAllowed
    }
  };

  var getHandler = {
    get: function get (target, key) {
      if (typeof key === 'string' && !(key in target)) {
        warnNonPresent(target, key);
      }
      return target[key]
    }
  };

  initProxy = function initProxy (vm) {
    if (hasProxy) {
      // determine which proxy handler to use
      var options = vm.$options;
      var handlers = options.render && options.render._withStripped
        ? getHandler
        : hasHandler;
      vm._renderProxy = new Proxy(vm, handlers);
    } else {
      vm._renderProxy = vm;
    }
  };
}

/*  */

var seenObjects = new _Set();

/**
 * Recursively traverse an object to evoke all converted
 * getters, so that every nested property inside the object
 * is collected as a "deep" dependency.
 */
function traverse (val) {
  _traverse(val, seenObjects);
  seenObjects.clear();
}

function _traverse (val, seen) {
  var i, keys;
  var isA = Array.isArray(val);
  if ((!isA && !isObject(val)) || Object.isFrozen(val) || val instanceof VNode) {
    return
  }
  if (val.__ob__) {
    var depId = val.__ob__.dep.id;
    if (seen.has(depId)) {
      return
    }
    seen.add(depId);
  }
  if (isA) {
    i = val.length;
    while (i--) { _traverse(val[i], seen); }
  } else {
    keys = Object.keys(val);
    i = keys.length;
    while (i--) { _traverse(val[keys[i]], seen); }
  }
}

/*  */

var normalizeEvent = cached(function (name) {
  var passive = name.charAt(0) === '&';
  name = passive ? name.slice(1) : name;
  var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first
  name = once$$1 ? name.slice(1) : name;
  var capture = name.charAt(0) === '!';
  name = capture ? name.slice(1) : name;
  return {
    name: name,
    once: once$$1,
    capture: capture,
    passive: passive
  }
});

function createFnInvoker (fns) {
  function invoker () {
    var arguments$1 = arguments;

    var fns = invoker.fns;
    if (Array.isArray(fns)) {
      var cloned = fns.slice();
      for (var i = 0; i < cloned.length; i++) {
        cloned[i].apply(null, arguments$1);
      }
    } else {
      // return handler return value for single handlers
      return fns.apply(null, arguments)
    }
  }
  invoker.fns = fns;
  return invoker
}

function updateListeners (
  on,
  oldOn,
  add,
  remove$$1,
  vm
) {
  var name, def, cur, old, event;
  for (name in on) {
    def = cur = on[name];
    old = oldOn[name];
    event = normalizeEvent(name);
    /* istanbul ignore if */
    if (isUndef(cur)) {
      "development" !== 'production' && warn(
        "Invalid handler for event \"" + (event.name) + "\": got " + String(cur),
        vm
      );
    } else if (isUndef(old)) {
      if (isUndef(cur.fns)) {
        cur = on[name] = createFnInvoker(cur);
      }
      add(event.name, cur, event.once, event.capture, event.passive, event.params);
    } else if (cur !== old) {
      old.fns = cur;
      on[name] = old;
    }
  }
  for (name in oldOn) {
    if (isUndef(on[name])) {
      event = normalizeEvent(name);
      remove$$1(event.name, oldOn[name], event.capture);
    }
  }
}

/*  */

function mergeVNodeHook (def, hookKey, hook) {
  if (def instanceof VNode) {
    def = def.data.hook || (def.data.hook = {});
  }
  var invoker;
  var oldHook = def[hookKey];

  function wrappedHook () {
    hook.apply(this, arguments);
    // important: remove merged hook to ensure it's called only once
    // and prevent memory leak
    remove(invoker.fns, wrappedHook);
  }

  if (isUndef(oldHook)) {
    // no existing hook
    invoker = createFnInvoker([wrappedHook]);
  } else {
    /* istanbul ignore if */
    if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {
      // already a merged invoker
      invoker = oldHook;
      invoker.fns.push(wrappedHook);
    } else {
      // existing plain hook
      invoker = createFnInvoker([oldHook, wrappedHook]);
    }
  }

  invoker.merged = true;
  def[hookKey] = invoker;
}

/*  */

function extractPropsFromVNodeData (
  data,
  Ctor,
  tag
) {
  // we are only extracting raw values here.
  // validation and default values are handled in the child
  // component itself.
  var propOptions = Ctor.options.props;
  if (isUndef(propOptions)) {
    return
  }
  var res = {};
  var attrs = data.attrs;
  var props = data.props;
  if (isDef(attrs) || isDef(props)) {
    for (var key in propOptions) {
      var altKey = hyphenate(key);
      if (true) {
        var keyInLowerCase = key.toLowerCase();
        if (
          key !== keyInLowerCase &&
          attrs && hasOwn(attrs, keyInLowerCase)
        ) {
          tip(
            "Prop \"" + keyInLowerCase + "\" is passed to component " +
            (formatComponentName(tag || Ctor)) + ", but the declared prop name is" +
            " \"" + key + "\". " +
            "Note that HTML attributes are case-insensitive and camelCased " +
            "props need to use their kebab-case equivalents when using in-DOM " +
            "templates. You should probably use \"" + altKey + "\" instead of \"" + key + "\"."
          );
        }
      }
      checkProp(res, props, key, altKey, true) ||
      checkProp(res, attrs, key, altKey, false);
    }
  }
  return res
}

function checkProp (
  res,
  hash,
  key,
  altKey,
  preserve
) {
  if (isDef(hash)) {
    if (hasOwn(hash, key)) {
      res[key] = hash[key];
      if (!preserve) {
        delete hash[key];
      }
      return true
    } else if (hasOwn(hash, altKey)) {
      res[key] = hash[altKey];
      if (!preserve) {
        delete hash[altKey];
      }
      return true
    }
  }
  return false
}

/*  */

// The template compiler attempts to minimize the need for normalization by
// statically analyzing the template at compile time.
//
// For plain HTML markup, normalization can be completely skipped because the
// generated render function is guaranteed to return Array<VNode>. There are
// two cases where extra normalization is needed:

// 1. When the children contains components - because a functional component
// may return an Array instead of a single root. In this case, just a simple
// normalization is needed - if any child is an Array, we flatten the whole
// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep
// because functional components already normalize their own children.
function simpleNormalizeChildren (children) {
  for (var i = 0; i < children.length; i++) {
    if (Array.isArray(children[i])) {
      return Array.prototype.concat.apply([], children)
    }
  }
  return children
}

// 2. When the children contains constructs that always generated nested Arrays,
// e.g. <template>, <slot>, v-for, or when the children is provided by user
// with hand-written render functions / JSX. In such cases a full normalization
// is needed to cater to all possible types of children values.
function normalizeChildren (children) {
  return isPrimitive(children)
    ? [createTextVNode(children)]
    : Array.isArray(children)
      ? normalizeArrayChildren(children)
      : undefined
}

function isTextNode (node) {
  return isDef(node) && isDef(node.text) && isFalse(node.isComment)
}

function normalizeArrayChildren (children, nestedIndex) {
  var res = [];
  var i, c, lastIndex, last;
  for (i = 0; i < children.length; i++) {
    c = children[i];
    if (isUndef(c) || typeof c === 'boolean') { continue }
    lastIndex = res.length - 1;
    last = res[lastIndex];
    //  nested
    if (Array.isArray(c)) {
      if (c.length > 0) {
        c = normalizeArrayChildren(c, ((nestedIndex || '') + "_" + i));
        // merge adjacent text nodes
        if (isTextNode(c[0]) && isTextNode(last)) {
          res[lastIndex] = createTextVNode(last.text + (c[0]).text);
          c.shift();
        }
        res.push.apply(res, c);
      }
    } else if (isPrimitive(c)) {
      if (isTextNode(last)) {
        // merge adjacent text nodes
        // this is necessary for SSR hydration because text nodes are
        // essentially merged when rendered to HTML strings
        res[lastIndex] = createTextVNode(last.text + c);
      } else if (c !== '') {
        // convert primitive to vnode
        res.push(createTextVNode(c));
      }
    } else {
      if (isTextNode(c) && isTextNode(last)) {
        // merge adjacent text nodes
        res[lastIndex] = createTextVNode(last.text + c.text);
      } else {
        // default key for nested array children (likely generated by v-for)
        if (isTrue(children._isVList) &&
          isDef(c.tag) &&
          isUndef(c.key) &&
          isDef(nestedIndex)) {
          c.key = "__vlist" + nestedIndex + "_" + i + "__";
        }
        res.push(c);
      }
    }
  }
  return res
}

/*  */

function ensureCtor (comp, base) {
  if (
    comp.__esModule ||
    (hasSymbol && comp[Symbol.toStringTag] === 'Module')
  ) {
    comp = comp.default;
  }
  return isObject(comp)
    ? base.extend(comp)
    : comp
}

function createAsyncPlaceholder (
  factory,
  data,
  context,
  children,
  tag
) {
  var node = createEmptyVNode();
  node.asyncFactory = factory;
  node.asyncMeta = { data: data, context: context, children: children, tag: tag };
  return node
}

function resolveAsyncComponent (
  factory,
  baseCtor,
  context
) {
  if (isTrue(factory.error) && isDef(factory.errorComp)) {
    return factory.errorComp
  }

  if (isDef(factory.resolved)) {
    return factory.resolved
  }

  if (isTrue(factory.loading) && isDef(factory.loadingComp)) {
    return factory.loadingComp
  }

  if (isDef(factory.contexts)) {
    // already pending
    factory.contexts.push(context);
  } else {
    var contexts = factory.contexts = [context];
    var sync = true;

    var forceRender = function () {
      for (var i = 0, l = contexts.length; i < l; i++) {
        contexts[i].$forceUpdate();
      }
    };

    var resolve = once(function (res) {
      // cache resolved
      factory.resolved = ensureCtor(res, baseCtor);
      // invoke callbacks only if this is not a synchronous resolve
      // (async resolves are shimmed as synchronous during SSR)
      if (!sync) {
        forceRender();
      }
    });

    var reject = once(function (reason) {
      "development" !== 'production' && warn(
        "Failed to resolve async component: " + (String(factory)) +
        (reason ? ("\nReason: " + reason) : '')
      );
      if (isDef(factory.errorComp)) {
        factory.error = true;
        forceRender();
      }
    });

    var res = factory(resolve, reject);

    if (isObject(res)) {
      if (typeof res.then === 'function') {
        // () => Promise
        if (isUndef(factory.resolved)) {
          res.then(resolve, reject);
        }
      } else if (isDef(res.component) && typeof res.component.then === 'function') {
        res.component.then(resolve, reject);

        if (isDef(res.error)) {
          factory.errorComp = ensureCtor(res.error, baseCtor);
        }

        if (isDef(res.loading)) {
          factory.loadingComp = ensureCtor(res.loading, baseCtor);
          if (res.delay === 0) {
            factory.loading = true;
          } else {
            setTimeout(function () {
              if (isUndef(factory.resolved) && isUndef(factory.error)) {
                factory.loading = true;
                forceRender();
              }
            }, res.delay || 200);
          }
        }

        if (isDef(res.timeout)) {
          setTimeout(function () {
            if (isUndef(factory.resolved)) {
              reject(
                 true
                  ? ("timeout (" + (res.timeout) + "ms)")
                  : null
              );
            }
          }, res.timeout);
        }
      }
    }

    sync = false;
    // return in case resolved synchronously
    return factory.loading
      ? factory.loadingComp
      : factory.resolved
  }
}

/*  */

function isAsyncPlaceholder (node) {
  return node.isComment && node.asyncFactory
}

/*  */

function getFirstComponentChild (children) {
  if (Array.isArray(children)) {
    for (var i = 0; i < children.length; i++) {
      var c = children[i];
      if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {
        return c
      }
    }
  }
}

/*  */

/*  */

function initEvents (vm) {
  vm._events = Object.create(null);
  vm._hasHookEvent = false;
  // init parent attached events
  var listeners = vm.$options._parentListeners;
  if (listeners) {
    updateComponentListeners(vm, listeners);
  }
}

var target;

function add (event, fn, once) {
  if (once) {
    target.$once(event, fn);
  } else {
    target.$on(event, fn);
  }
}

function remove$1 (event, fn) {
  target.$off(event, fn);
}

function updateComponentListeners (
  vm,
  listeners,
  oldListeners
) {
  target = vm;
  updateListeners(listeners, oldListeners || {}, add, remove$1, vm);
  target = undefined;
}

function eventsMixin (Vue) {
  var hookRE = /^hook:/;
  Vue.prototype.$on = function (event, fn) {
    var this$1 = this;

    var vm = this;
    if (Array.isArray(event)) {
      for (var i = 0, l = event.length; i < l; i++) {
        this$1.$on(event[i], fn);
      }
    } else {
      (vm._events[event] || (vm._events[event] = [])).push(fn);
      // optimize hook:event cost by using a boolean flag marked at registration
      // instead of a hash lookup
      if (hookRE.test(event)) {
        vm._hasHookEvent = true;
      }
    }
    return vm
  };

  Vue.prototype.$once = function (event, fn) {
    var vm = this;
    function on () {
      vm.$off(event, on);
      fn.apply(vm, arguments);
    }
    on.fn = fn;
    vm.$on(event, on);
    return vm
  };

  Vue.prototype.$off = function (event, fn) {
    var this$1 = this;

    var vm = this;
    // all
    if (!arguments.length) {
      vm._events = Object.create(null);
      return vm
    }
    // array of events
    if (Array.isArray(event)) {
      for (var i = 0, l = event.length; i < l; i++) {
        this$1.$off(event[i], fn);
      }
      return vm
    }
    // specific event
    var cbs = vm._events[event];
    if (!cbs) {
      return vm
    }
    if (!fn) {
      vm._events[event] = null;
      return vm
    }
    if (fn) {
      // specific handler
      var cb;
      var i$1 = cbs.length;
      while (i$1--) {
        cb = cbs[i$1];
        if (cb === fn || cb.fn === fn) {
          cbs.splice(i$1, 1);
          break
        }
      }
    }
    return vm
  };

  Vue.prototype.$emit = function (event) {
    var vm = this;
    if (true) {
      var lowerCaseEvent = event.toLowerCase();
      if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {
        tip(
          "Event \"" + lowerCaseEvent + "\" is emitted in component " +
          (formatComponentName(vm)) + " but the handler is registered for \"" + event + "\". " +
          "Note that HTML attributes are case-insensitive and you cannot use " +
          "v-on to listen to camelCase events when using in-DOM templates. " +
          "You should probably use \"" + (hyphenate(event)) + "\" instead of \"" + event + "\"."
        );
      }
    }
    var cbs = vm._events[event];
    if (cbs) {
      cbs = cbs.length > 1 ? toArray(cbs) : cbs;
      var args = toArray(arguments, 1);
      for (var i = 0, l = cbs.length; i < l; i++) {
        try {
          cbs[i].apply(vm, args);
        } catch (e) {
          handleError(e, vm, ("event handler for \"" + event + "\""));
        }
      }
    }
    return vm
  };
}

/*  */



/**
 * Runtime helper for resolving raw children VNodes into a slot object.
 */
function resolveSlots (
  children,
  context
) {
  var slots = {};
  if (!children) {
    return slots
  }
  for (var i = 0, l = children.length; i < l; i++) {
    var child = children[i];
    var data = child.data;
    // remove slot attribute if the node is resolved as a Vue slot node
    if (data && data.attrs && data.attrs.slot) {
      delete data.attrs.slot;
    }
    // named slots should only be respected if the vnode was rendered in the
    // same context.
    if ((child.context === context || child.fnContext === context) &&
      data && data.slot != null
    ) {
      var name = data.slot;
      var slot = (slots[name] || (slots[name] = []));
      if (child.tag === 'template') {
        slot.push.apply(slot, child.children || []);
      } else {
        slot.push(child);
      }
    } else {
      (slots.default || (slots.default = [])).push(child);
    }
  }
  // ignore slots that contains only whitespace
  for (var name$1 in slots) {
    if (slots[name$1].every(isWhitespace)) {
      delete slots[name$1];
    }
  }
  return slots
}

function isWhitespace (node) {
  return (node.isComment && !node.asyncFactory) || node.text === ' '
}

function resolveScopedSlots (
  fns, // see flow/vnode
  res
) {
  res = res || {};
  for (var i = 0; i < fns.length; i++) {
    if (Array.isArray(fns[i])) {
      resolveScopedSlots(fns[i], res);
    } else {
      res[fns[i].key] = fns[i].fn;
    }
  }
  return res
}

/*  */

var activeInstance = null;
var isUpdatingChildComponent = false;

function initLifecycle (vm) {
  var options = vm.$options;

  // locate first non-abstract parent
  var parent = options.parent;
  if (parent && !options.abstract) {
    while (parent.$options.abstract && parent.$parent) {
      parent = parent.$parent;
    }
    parent.$children.push(vm);
  }

  vm.$parent = parent;
  vm.$root = parent ? parent.$root : vm;

  vm.$children = [];
  vm.$refs = {};

  vm._watcher = null;
  vm._inactive = null;
  vm._directInactive = false;
  vm._isMounted = false;
  vm._isDestroyed = false;
  vm._isBeingDestroyed = false;
}

function lifecycleMixin (Vue) {
  Vue.prototype._update = function (vnode, hydrating) {
    var vm = this;
    if (vm._isMounted) {
      callHook(vm, 'beforeUpdate');
    }
    var prevEl = vm.$el;
    var prevVnode = vm._vnode;
    var prevActiveInstance = activeInstance;
    activeInstance = vm;
    vm._vnode = vnode;
    // Vue.prototype.__patch__ is injected in entry points
    // based on the rendering backend used.
    if (!prevVnode) {
      // initial render
      vm.$el = vm.__patch__(
        vm.$el, vnode, hydrating, false /* removeOnly */,
        vm.$options._parentElm,
        vm.$options._refElm
      );
      // no need for the ref nodes after initial patch
      // this prevents keeping a detached DOM tree in memory (#5851)
      vm.$options._parentElm = vm.$options._refElm = null;
    } else {
      // updates
      vm.$el = vm.__patch__(prevVnode, vnode);
    }
    activeInstance = prevActiveInstance;
    // update __vue__ reference
    if (prevEl) {
      prevEl.__vue__ = null;
    }
    if (vm.$el) {
      vm.$el.__vue__ = vm;
    }
    // if parent is an HOC, update its $el as well
    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
      vm.$parent.$el = vm.$el;
    }
    // updated hook is called by the scheduler to ensure that children are
    // updated in a parent's updated hook.
  };

  Vue.prototype.$forceUpdate = function () {
    var vm = this;
    if (vm._watcher) {
      vm._watcher.update();
    }
  };

  Vue.prototype.$destroy = function () {
    var vm = this;
    if (vm._isBeingDestroyed) {
      return
    }
    callHook(vm, 'beforeDestroy');
    vm._isBeingDestroyed = true;
    // remove self from parent
    var parent = vm.$parent;
    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
      remove(parent.$children, vm);
    }
    // teardown watchers
    if (vm._watcher) {
      vm._watcher.teardown();
    }
    var i = vm._watchers.length;
    while (i--) {
      vm._watchers[i].teardown();
    }
    // remove reference from data ob
    // frozen object may not have observer.
    if (vm._data.__ob__) {
      vm._data.__ob__.vmCount--;
    }
    // call the last hook...
    vm._isDestroyed = true;
    // invoke destroy hooks on current rendered tree
    vm.__patch__(vm._vnode, null);
    // fire destroyed hook
    callHook(vm, 'destroyed');
    // turn off all instance listeners.
    vm.$off();
    // remove __vue__ reference
    if (vm.$el) {
      vm.$el.__vue__ = null;
    }
    // release circular reference (#6759)
    if (vm.$vnode) {
      vm.$vnode.parent = null;
    }
  };
}

function mountComponent (
  vm,
  el,
  hydrating
) {
  vm.$el = el;
  if (!vm.$options.render) {
    vm.$options.render = createEmptyVNode;
    if (true) {
      /* istanbul ignore if */
      if ((vm.$options.template && vm.$options.template.charAt(0) !== '#') ||
        vm.$options.el || el) {
        warn(
          'You are using the runtime-only build of Vue where the template ' +
          'compiler is not available. Either pre-compile the templates into ' +
          'render functions, or use the compiler-included build.',
          vm
        );
      } else {
        warn(
          'Failed to mount component: template or render function not defined.',
          vm
        );
      }
    }
  }
  callHook(vm, 'beforeMount');

  var updateComponent;
  /* istanbul ignore if */
  if ("development" !== 'production' && config.performance && mark) {
    updateComponent = function () {
      var name = vm._name;
      var id = vm._uid;
      var startTag = "vue-perf-start:" + id;
      var endTag = "vue-perf-end:" + id;

      mark(startTag);
      var vnode = vm._render();
      mark(endTag);
      measure(("vue " + name + " render"), startTag, endTag);

      mark(startTag);
      vm._update(vnode, hydrating);
      mark(endTag);
      measure(("vue " + name + " patch"), startTag, endTag);
    };
  } else {
    updateComponent = function () {
      vm._update(vm._render(), hydrating);
    };
  }

  // we set this to vm._watcher inside the watcher's constructor
  // since the watcher's initial patch may call $forceUpdate (e.g. inside child
  // component's mounted hook), which relies on vm._watcher being already defined
  new Watcher(vm, updateComponent, noop, null, true /* isRenderWatcher */);
  hydrating = false;

  // manually mounted instance, call mounted on self
  // mounted is called for render-created child components in its inserted hook
  if (vm.$vnode == null) {
    vm._isMounted = true;
    callHook(vm, 'mounted');
  }
  return vm
}

function updateChildComponent (
  vm,
  propsData,
  listeners,
  parentVnode,
  renderChildren
) {
  if (true) {
    isUpdatingChildComponent = true;
  }

  // determine whether component has slot children
  // we need to do this before overwriting $options._renderChildren
  var hasChildren = !!(
    renderChildren ||               // has new static slots
    vm.$options._renderChildren ||  // has old static slots
    parentVnode.data.scopedSlots || // has new scoped slots
    vm.$scopedSlots !== emptyObject // has old scoped slots
  );

  vm.$options._parentVnode = parentVnode;
  vm.$vnode = parentVnode; // update vm's placeholder node without re-render

  if (vm._vnode) { // update child tree's parent
    vm._vnode.parent = parentVnode;
  }
  vm.$options._renderChildren = renderChildren;

  // update $attrs and $listeners hash
  // these are also reactive so they may trigger child update if the child
  // used them during render
  vm.$attrs = parentVnode.data.attrs || emptyObject;
  vm.$listeners = listeners || emptyObject;

  // update props
  if (propsData && vm.$options.props) {
    toggleObserving(false);
    var props = vm._props;
    var propKeys = vm.$options._propKeys || [];
    for (var i = 0; i < propKeys.length; i++) {
      var key = propKeys[i];
      var propOptions = vm.$options.props; // wtf flow?
      props[key] = validateProp(key, propOptions, propsData, vm);
    }
    toggleObserving(true);
    // keep a copy of raw propsData
    vm.$options.propsData = propsData;
  }

  // update listeners
  listeners = listeners || emptyObject;
  var oldListeners = vm.$options._parentListeners;
  vm.$options._parentListeners = listeners;
  updateComponentListeners(vm, listeners, oldListeners);

  // resolve slots + force update if has children
  if (hasChildren) {
    vm.$slots = resolveSlots(renderChildren, parentVnode.context);
    vm.$forceUpdate();
  }

  if (true) {
    isUpdatingChildComponent = false;
  }
}

function isInInactiveTree (vm) {
  while (vm && (vm = vm.$parent)) {
    if (vm._inactive) { return true }
  }
  return false
}

function activateChildComponent (vm, direct) {
  if (direct) {
    vm._directInactive = false;
    if (isInInactiveTree(vm)) {
      return
    }
  } else if (vm._directInactive) {
    return
  }
  if (vm._inactive || vm._inactive === null) {
    vm._inactive = false;
    for (var i = 0; i < vm.$children.length; i++) {
      activateChildComponent(vm.$children[i]);
    }
    callHook(vm, 'activated');
  }
}

function deactivateChildComponent (vm, direct) {
  if (direct) {
    vm._directInactive = true;
    if (isInInactiveTree(vm)) {
      return
    }
  }
  if (!vm._inactive) {
    vm._inactive = true;
    for (var i = 0; i < vm.$children.length; i++) {
      deactivateChildComponent(vm.$children[i]);
    }
    callHook(vm, 'deactivated');
  }
}

function callHook (vm, hook) {
  // #7573 disable dep collection when invoking lifecycle hooks
  pushTarget();
  var handlers = vm.$options[hook];
  if (handlers) {
    for (var i = 0, j = handlers.length; i < j; i++) {
      try {
        handlers[i].call(vm);
      } catch (e) {
        handleError(e, vm, (hook + " hook"));
      }
    }
  }
  if (vm._hasHookEvent) {
    vm.$emit('hook:' + hook);
  }
  popTarget();
}

/*  */


var MAX_UPDATE_COUNT = 100;

var queue = [];
var activatedChildren = [];
var has = {};
var circular = {};
var waiting = false;
var flushing = false;
var index = 0;

/**
 * Reset the scheduler's state.
 */
function resetSchedulerState () {
  index = queue.length = activatedChildren.length = 0;
  has = {};
  if (true) {
    circular = {};
  }
  waiting = flushing = false;
}

/**
 * Flush both queues and run the watchers.
 */
function flushSchedulerQueue () {
  flushing = true;
  var watcher, id;

  // Sort queue before flush.
  // This ensures that:
  // 1. Components are updated from parent to child. (because parent is always
  //    created before the child)
  // 2. A component's user watchers are run before its render watcher (because
  //    user watchers are created before the render watcher)
  // 3. If a component is destroyed during a parent component's watcher run,
  //    its watchers can be skipped.
  queue.sort(function (a, b) { return a.id - b.id; });

  // do not cache length because more watchers might be pushed
  // as we run existing watchers
  for (index = 0; index < queue.length; index++) {
    watcher = queue[index];
    id = watcher.id;
    has[id] = null;
    watcher.run();
    // in dev build, check and stop circular updates.
    if ("development" !== 'production' && has[id] != null) {
      circular[id] = (circular[id] || 0) + 1;
      if (circular[id] > MAX_UPDATE_COUNT) {
        warn(
          'You may have an infinite update loop ' + (
            watcher.user
              ? ("in watcher with expression \"" + (watcher.expression) + "\"")
              : "in a component render function."
          ),
          watcher.vm
        );
        break
      }
    }
  }

  // keep copies of post queues before resetting state
  var activatedQueue = activatedChildren.slice();
  var updatedQueue = queue.slice();

  resetSchedulerState();

  // call component updated and activated hooks
  callActivatedHooks(activatedQueue);
  callUpdatedHooks(updatedQueue);

  // devtool hook
  /* istanbul ignore if */
  if (devtools && config.devtools) {
    devtools.emit('flush');
  }
}

function callUpdatedHooks (queue) {
  var i = queue.length;
  while (i--) {
    var watcher = queue[i];
    var vm = watcher.vm;
    if (vm._watcher === watcher && vm._isMounted) {
      callHook(vm, 'updated');
    }
  }
}

/**
 * Queue a kept-alive component that was activated during patch.
 * The queue will be processed after the entire tree has been patched.
 */
function queueActivatedComponent (vm) {
  // setting _inactive to false here so that a render function can
  // rely on checking whether it's in an inactive tree (e.g. router-view)
  vm._inactive = false;
  activatedChildren.push(vm);
}

function callActivatedHooks (queue) {
  for (var i = 0; i < queue.length; i++) {
    queue[i]._inactive = true;
    activateChildComponent(queue[i], true /* true */);
  }
}

/**
 * Push a watcher into the watcher queue.
 * Jobs with duplicate IDs will be skipped unless it's
 * pushed when the queue is being flushed.
 */
function queueWatcher (watcher) {
  var id = watcher.id;
  if (has[id] == null) {
    has[id] = true;
    if (!flushing) {
      queue.push(watcher);
    } else {
      // if already flushing, splice the watcher based on its id
      // if already past its id, it will be run next immediately.
      var i = queue.length - 1;
      while (i > index && queue[i].id > watcher.id) {
        i--;
      }
      queue.splice(i + 1, 0, watcher);
    }
    // queue the flush
    if (!waiting) {
      waiting = true;
      nextTick(flushSchedulerQueue);
    }
  }
}

/*  */

var uid$1 = 0;

/**
 * A watcher parses an expression, collects dependencies,
 * and fires callback when the expression value changes.
 * This is used for both the $watch() api and directives.
 */
var Watcher = function Watcher (
  vm,
  expOrFn,
  cb,
  options,
  isRenderWatcher
) {
  this.vm = vm;
  if (isRenderWatcher) {
    vm._watcher = this;
  }
  vm._watchers.push(this);
  // options
  if (options) {
    this.deep = !!options.deep;
    this.user = !!options.user;
    this.lazy = !!options.lazy;
    this.sync = !!options.sync;
  } else {
    this.deep = this.user = this.lazy = this.sync = false;
  }
  this.cb = cb;
  this.id = ++uid$1; // uid for batching
  this.active = true;
  this.dirty = this.lazy; // for lazy watchers
  this.deps = [];
  this.newDeps = [];
  this.depIds = new _Set();
  this.newDepIds = new _Set();
  this.expression =  true
    ? expOrFn.toString()
    : '';
  // parse expression for getter
  if (typeof expOrFn === 'function') {
    this.getter = expOrFn;
  } else {
    this.getter = parsePath(expOrFn);
    if (!this.getter) {
      this.getter = function () {};
      "development" !== 'production' && warn(
        "Failed watching path: \"" + expOrFn + "\" " +
        'Watcher only accepts simple dot-delimited paths. ' +
        'For full control, use a function instead.',
        vm
      );
    }
  }
  this.value = this.lazy
    ? undefined
    : this.get();
};

/**
 * Evaluate the getter, and re-collect dependencies.
 */
Watcher.prototype.get = function get () {
  pushTarget(this);
  var value;
  var vm = this.vm;
  try {
    value = this.getter.call(vm, vm);
  } catch (e) {
    if (this.user) {
      handleError(e, vm, ("getter for watcher \"" + (this.expression) + "\""));
    } else {
      throw e
    }
  } finally {
    // "touch" every property so they are all tracked as
    // dependencies for deep watching
    if (this.deep) {
      traverse(value);
    }
    popTarget();
    this.cleanupDeps();
  }
  return value
};

/**
 * Add a dependency to this directive.
 */
Watcher.prototype.addDep = function addDep (dep) {
  var id = dep.id;
  if (!this.newDepIds.has(id)) {
    this.newDepIds.add(id);
    this.newDeps.push(dep);
    if (!this.depIds.has(id)) {
      dep.addSub(this);
    }
  }
};

/**
 * Clean up for dependency collection.
 */
Watcher.prototype.cleanupDeps = function cleanupDeps () {
    var this$1 = this;

  var i = this.deps.length;
  while (i--) {
    var dep = this$1.deps[i];
    if (!this$1.newDepIds.has(dep.id)) {
      dep.removeSub(this$1);
    }
  }
  var tmp = this.depIds;
  this.depIds = this.newDepIds;
  this.newDepIds = tmp;
  this.newDepIds.clear();
  tmp = this.deps;
  this.deps = this.newDeps;
  this.newDeps = tmp;
  this.newDeps.length = 0;
};

/**
 * Subscriber interface.
 * Will be called when a dependency changes.
 */
Watcher.prototype.update = function update () {
  /* istanbul ignore else */
  if (this.lazy) {
    this.dirty = true;
  } else if (this.sync) {
    this.run();
  } else {
    queueWatcher(this);
  }
};

/**
 * Scheduler job interface.
 * Will be called by the scheduler.
 */
Watcher.prototype.run = function run () {
  if (this.active) {
    var value = this.get();
    if (
      value !== this.value ||
      // Deep watchers and watchers on Object/Arrays should fire even
      // when the value is the same, because the value may
      // have mutated.
      isObject(value) ||
      this.deep
    ) {
      // set new value
      var oldValue = this.value;
      this.value = value;
      if (this.user) {
        try {
          this.cb.call(this.vm, value, oldValue);
        } catch (e) {
          handleError(e, this.vm, ("callback for watcher \"" + (this.expression) + "\""));
        }
      } else {
        this.cb.call(this.vm, value, oldValue);
      }
    }
  }
};

/**
 * Evaluate the value of the watcher.
 * This only gets called for lazy watchers.
 */
Watcher.prototype.evaluate = function evaluate () {
  this.value = this.get();
  this.dirty = false;
};

/**
 * Depend on all deps collected by this watcher.
 */
Watcher.prototype.depend = function depend () {
    var this$1 = this;

  var i = this.deps.length;
  while (i--) {
    this$1.deps[i].depend();
  }
};

/**
 * Remove self from all dependencies' subscriber list.
 */
Watcher.prototype.teardown = function teardown () {
    var this$1 = this;

  if (this.active) {
    // remove self from vm's watcher list
    // this is a somewhat expensive operation so we skip it
    // if the vm is being destroyed.
    if (!this.vm._isBeingDestroyed) {
      remove(this.vm._watchers, this);
    }
    var i = this.deps.length;
    while (i--) {
      this$1.deps[i].removeSub(this$1);
    }
    this.active = false;
  }
};

/*  */

var sharedPropertyDefinition = {
  enumerable: true,
  configurable: true,
  get: noop,
  set: noop
};

function proxy (target, sourceKey, key) {
  sharedPropertyDefinition.get = function proxyGetter () {
    return this[sourceKey][key]
  };
  sharedPropertyDefinition.set = function proxySetter (val) {
    this[sourceKey][key] = val;
  };
  Object.defineProperty(target, key, sharedPropertyDefinition);
}

function initState (vm) {
  vm._watchers = [];
  var opts = vm.$options;
  if (opts.props) { initProps(vm, opts.props); }
  if (opts.methods) { initMethods(vm, opts.methods); }
  if (opts.data) {
    initData(vm);
  } else {
    observe(vm._data = {}, true /* asRootData */);
  }
  if (opts.computed) { initComputed(vm, opts.computed); }
  if (opts.watch && opts.watch !== nativeWatch) {
    initWatch(vm, opts.watch);
  }
}

function initProps (vm, propsOptions) {
  var propsData = vm.$options.propsData || {};
  var props = vm._props = {};
  // cache prop keys so that future props updates can iterate using Array
  // instead of dynamic object key enumeration.
  var keys = vm.$options._propKeys = [];
  var isRoot = !vm.$parent;
  // root instance props should be converted
  if (!isRoot) {
    toggleObserving(false);
  }
  var loop = function ( key ) {
    keys.push(key);
    var value = validateProp(key, propsOptions, propsData, vm);
    /* istanbul ignore else */
    if (true) {
      var hyphenatedKey = hyphenate(key);
      if (isReservedAttribute(hyphenatedKey) ||
          config.isReservedAttr(hyphenatedKey)) {
        warn(
          ("\"" + hyphenatedKey + "\" is a reserved attribute and cannot be used as component prop."),
          vm
        );
      }
      defineReactive(props, key, value, function () {
        if (vm.$parent && !isUpdatingChildComponent) {
          warn(
            "Avoid mutating a prop directly since the value will be " +
            "overwritten whenever the parent component re-renders. " +
            "Instead, use a data or computed property based on the prop's " +
            "value. Prop being mutated: \"" + key + "\"",
            vm
          );
        }
      });
    } else {
      defineReactive(props, key, value);
    }
    // static props are already proxied on the component's prototype
    // during Vue.extend(). We only need to proxy props defined at
    // instantiation here.
    if (!(key in vm)) {
      proxy(vm, "_props", key);
    }
  };

  for (var key in propsOptions) loop( key );
  toggleObserving(true);
}

function initData (vm) {
  var data = vm.$options.data;
  data = vm._data = typeof data === 'function'
    ? getData(data, vm)
    : data || {};
  if (!isPlainObject(data)) {
    data = {};
    "development" !== 'production' && warn(
      'data functions should return an object:\n' +
      'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',
      vm
    );
  }
  // proxy data on instance
  var keys = Object.keys(data);
  var props = vm.$options.props;
  var methods = vm.$options.methods;
  var i = keys.length;
  while (i--) {
    var key = keys[i];
    if (true) {
      if (methods && hasOwn(methods, key)) {
        warn(
          ("Method \"" + key + "\" has already been defined as a data property."),
          vm
        );
      }
    }
    if (props && hasOwn(props, key)) {
      "development" !== 'production' && warn(
        "The data property \"" + key + "\" is already declared as a prop. " +
        "Use prop default value instead.",
        vm
      );
    } else if (!isReserved(key)) {
      proxy(vm, "_data", key);
    }
  }
  // observe data
  observe(data, true /* asRootData */);
}

function getData (data, vm) {
  // #7573 disable dep collection when invoking data getters
  pushTarget();
  try {
    return data.call(vm, vm)
  } catch (e) {
    handleError(e, vm, "data()");
    return {}
  } finally {
    popTarget();
  }
}

var computedWatcherOptions = { lazy: true };

function initComputed (vm, computed) {
  // $flow-disable-line
  var watchers = vm._computedWatchers = Object.create(null);
  // computed properties are just getters during SSR
  var isSSR = isServerRendering();

  for (var key in computed) {
    var userDef = computed[key];
    var getter = typeof userDef === 'function' ? userDef : userDef.get;
    if ("development" !== 'production' && getter == null) {
      warn(
        ("Getter is missing for computed property \"" + key + "\"."),
        vm
      );
    }

    if (!isSSR) {
      // create internal watcher for the computed property.
      watchers[key] = new Watcher(
        vm,
        getter || noop,
        noop,
        computedWatcherOptions
      );
    }

    // component-defined computed properties are already defined on the
    // component prototype. We only need to define computed properties defined
    // at instantiation here.
    if (!(key in vm)) {
      defineComputed(vm, key, userDef);
    } else if (true) {
      if (key in vm.$data) {
        warn(("The computed property \"" + key + "\" is already defined in data."), vm);
      } else if (vm.$options.props && key in vm.$options.props) {
        warn(("The computed property \"" + key + "\" is already defined as a prop."), vm);
      }
    }
  }
}

function defineComputed (
  target,
  key,
  userDef
) {
  var shouldCache = !isServerRendering();
  if (typeof userDef === 'function') {
    sharedPropertyDefinition.get = shouldCache
      ? createComputedGetter(key)
      : userDef;
    sharedPropertyDefinition.set = noop;
  } else {
    sharedPropertyDefinition.get = userDef.get
      ? shouldCache && userDef.cache !== false
        ? createComputedGetter(key)
        : userDef.get
      : noop;
    sharedPropertyDefinition.set = userDef.set
      ? userDef.set
      : noop;
  }
  if ("development" !== 'production' &&
      sharedPropertyDefinition.set === noop) {
    sharedPropertyDefinition.set = function () {
      warn(
        ("Computed property \"" + key + "\" was assigned to but it has no setter."),
        this
      );
    };
  }
  Object.defineProperty(target, key, sharedPropertyDefinition);
}

function createComputedGetter (key) {
  return function computedGetter () {
    var watcher = this._computedWatchers && this._computedWatchers[key];
    if (watcher) {
      if (watcher.dirty) {
        watcher.evaluate();
      }
      if (Dep.target) {
        watcher.depend();
      }
      return watcher.value
    }
  }
}

function initMethods (vm, methods) {
  var props = vm.$options.props;
  for (var key in methods) {
    if (true) {
      if (methods[key] == null) {
        warn(
          "Method \"" + key + "\" has an undefined value in the component definition. " +
          "Did you reference the function correctly?",
          vm
        );
      }
      if (props && hasOwn(props, key)) {
        warn(
          ("Method \"" + key + "\" has already been defined as a prop."),
          vm
        );
      }
      if ((key in vm) && isReserved(key)) {
        warn(
          "Method \"" + key + "\" conflicts with an existing Vue instance method. " +
          "Avoid defining component methods that start with _ or $."
        );
      }
    }
    vm[key] = methods[key] == null ? noop : bind(methods[key], vm);
  }
}

function initWatch (vm, watch) {
  for (var key in watch) {
    var handler = watch[key];
    if (Array.isArray(handler)) {
      for (var i = 0; i < handler.length; i++) {
        createWatcher(vm, key, handler[i]);
      }
    } else {
      createWatcher(vm, key, handler);
    }
  }
}

function createWatcher (
  vm,
  expOrFn,
  handler,
  options
) {
  if (isPlainObject(handler)) {
    options = handler;
    handler = handler.handler;
  }
  if (typeof handler === 'string') {
    handler = vm[handler];
  }
  return vm.$watch(expOrFn, handler, options)
}

function stateMixin (Vue) {
  // flow somehow has problems with directly declared definition object
  // when using Object.defineProperty, so we have to procedurally build up
  // the object here.
  var dataDef = {};
  dataDef.get = function () { return this._data };
  var propsDef = {};
  propsDef.get = function () { return this._props };
  if (true) {
    dataDef.set = function (newData) {
      warn(
        'Avoid replacing instance root $data. ' +
        'Use nested data properties instead.',
        this
      );
    };
    propsDef.set = function () {
      warn("$props is readonly.", this);
    };
  }
  Object.defineProperty(Vue.prototype, '$data', dataDef);
  Object.defineProperty(Vue.prototype, '$props', propsDef);

  Vue.prototype.$set = set;
  Vue.prototype.$delete = del;

  Vue.prototype.$watch = function (
    expOrFn,
    cb,
    options
  ) {
    var vm = this;
    if (isPlainObject(cb)) {
      return createWatcher(vm, expOrFn, cb, options)
    }
    options = options || {};
    options.user = true;
    var watcher = new Watcher(vm, expOrFn, cb, options);
    if (options.immediate) {
      cb.call(vm, watcher.value);
    }
    return function unwatchFn () {
      watcher.teardown();
    }
  };
}

/*  */

function initProvide (vm) {
  var provide = vm.$options.provide;
  if (provide) {
    vm._provided = typeof provide === 'function'
      ? provide.call(vm)
      : provide;
  }
}

function initInjections (vm) {
  var result = resolveInject(vm.$options.inject, vm);
  if (result) {
    toggleObserving(false);
    Object.keys(result).forEach(function (key) {
      /* istanbul ignore else */
      if (true) {
        defineReactive(vm, key, result[key], function () {
          warn(
            "Avoid mutating an injected value directly since the changes will be " +
            "overwritten whenever the provided component re-renders. " +
            "injection being mutated: \"" + key + "\"",
            vm
          );
        });
      } else {
        defineReactive(vm, key, result[key]);
      }
    });
    toggleObserving(true);
  }
}

function resolveInject (inject, vm) {
  if (inject) {
    // inject is :any because flow is not smart enough to figure out cached
    var result = Object.create(null);
    var keys = hasSymbol
      ? Reflect.ownKeys(inject).filter(function (key) {
        /* istanbul ignore next */
        return Object.getOwnPropertyDescriptor(inject, key).enumerable
      })
      : Object.keys(inject);

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      var provideKey = inject[key].from;
      var source = vm;
      while (source) {
        if (source._provided && hasOwn(source._provided, provideKey)) {
          result[key] = source._provided[provideKey];
          break
        }
        source = source.$parent;
      }
      if (!source) {
        if ('default' in inject[key]) {
          var provideDefault = inject[key].default;
          result[key] = typeof provideDefault === 'function'
            ? provideDefault.call(vm)
            : provideDefault;
        } else if (true) {
          warn(("Injection \"" + key + "\" not found"), vm);
        }
      }
    }
    return result
  }
}

/*  */

/**
 * Runtime helper for rendering v-for lists.
 */
function renderList (
  val,
  render
) {
  var ret, i, l, keys, key;
  if (Array.isArray(val) || typeof val === 'string') {
    ret = new Array(val.length);
    for (i = 0, l = val.length; i < l; i++) {
      ret[i] = render(val[i], i);
    }
  } else if (typeof val === 'number') {
    ret = new Array(val);
    for (i = 0; i < val; i++) {
      ret[i] = render(i + 1, i);
    }
  } else if (isObject(val)) {
    keys = Object.keys(val);
    ret = new Array(keys.length);
    for (i = 0, l = keys.length; i < l; i++) {
      key = keys[i];
      ret[i] = render(val[key], key, i);
    }
  }
  if (isDef(ret)) {
    (ret)._isVList = true;
  }
  return ret
}

/*  */

/**
 * Runtime helper for rendering <slot>
 */
function renderSlot (
  name,
  fallback,
  props,
  bindObject
) {
  var scopedSlotFn = this.$scopedSlots[name];
  var nodes;
  if (scopedSlotFn) { // scoped slot
    props = props || {};
    if (bindObject) {
      if ("development" !== 'production' && !isObject(bindObject)) {
        warn(
          'slot v-bind without argument expects an Object',
          this
        );
      }
      props = extend(extend({}, bindObject), props);
    }
    nodes = scopedSlotFn(props) || fallback;
  } else {
    var slotNodes = this.$slots[name];
    // warn duplicate slot usage
    if (slotNodes) {
      if ("development" !== 'production' && slotNodes._rendered) {
        warn(
          "Duplicate presence of slot \"" + name + "\" found in the same render tree " +
          "- this will likely cause render errors.",
          this
        );
      }
      slotNodes._rendered = true;
    }
    nodes = slotNodes || fallback;
  }

  var target = props && props.slot;
  if (target) {
    return this.$createElement('template', { slot: target }, nodes)
  } else {
    return nodes
  }
}

/*  */

/**
 * Runtime helper for resolving filters
 */
function resolveFilter (id) {
  return resolveAsset(this.$options, 'filters', id, true) || identity
}

/*  */

function isKeyNotMatch (expect, actual) {
  if (Array.isArray(expect)) {
    return expect.indexOf(actual) === -1
  } else {
    return expect !== actual
  }
}

/**
 * Runtime helper for checking keyCodes from config.
 * exposed as Vue.prototype._k
 * passing in eventKeyName as last argument separately for backwards compat
 */
function checkKeyCodes (
  eventKeyCode,
  key,
  builtInKeyCode,
  eventKeyName,
  builtInKeyName
) {
  var mappedKeyCode = config.keyCodes[key] || builtInKeyCode;
  if (builtInKeyName && eventKeyName && !config.keyCodes[key]) {
    return isKeyNotMatch(builtInKeyName, eventKeyName)
  } else if (mappedKeyCode) {
    return isKeyNotMatch(mappedKeyCode, eventKeyCode)
  } else if (eventKeyName) {
    return hyphenate(eventKeyName) !== key
  }
}

/*  */

/**
 * Runtime helper for merging v-bind="object" into a VNode's data.
 */
function bindObjectProps (
  data,
  tag,
  value,
  asProp,
  isSync
) {
  if (value) {
    if (!isObject(value)) {
      "development" !== 'production' && warn(
        'v-bind without argument expects an Object or Array value',
        this
      );
    } else {
      if (Array.isArray(value)) {
        value = toObject(value);
      }
      var hash;
      var loop = function ( key ) {
        if (
          key === 'class' ||
          key === 'style' ||
          isReservedAttribute(key)
        ) {
          hash = data;
        } else {
          var type = data.attrs && data.attrs.type;
          hash = asProp || config.mustUseProp(tag, type, key)
            ? data.domProps || (data.domProps = {})
            : data.attrs || (data.attrs = {});
        }
        if (!(key in hash)) {
          hash[key] = value[key];

          if (isSync) {
            var on = data.on || (data.on = {});
            on[("update:" + key)] = function ($event) {
              value[key] = $event;
            };
          }
        }
      };

      for (var key in value) loop( key );
    }
  }
  return data
}

/*  */

/**
 * Runtime helper for rendering static trees.
 */
function renderStatic (
  index,
  isInFor
) {
  var cached = this._staticTrees || (this._staticTrees = []);
  var tree = cached[index];
  // if has already-rendered static tree and not inside v-for,
  // we can reuse the same tree.
  if (tree && !isInFor) {
    return tree
  }
  // otherwise, render a fresh tree.
  tree = cached[index] = this.$options.staticRenderFns[index].call(
    this._renderProxy,
    null,
    this // for render fns generated for functional component templates
  );
  markStatic(tree, ("__static__" + index), false);
  return tree
}

/**
 * Runtime helper for v-once.
 * Effectively it means marking the node as static with a unique key.
 */
function markOnce (
  tree,
  index,
  key
) {
  markStatic(tree, ("__once__" + index + (key ? ("_" + key) : "")), true);
  return tree
}

function markStatic (
  tree,
  key,
  isOnce
) {
  if (Array.isArray(tree)) {
    for (var i = 0; i < tree.length; i++) {
      if (tree[i] && typeof tree[i] !== 'string') {
        markStaticNode(tree[i], (key + "_" + i), isOnce);
      }
    }
  } else {
    markStaticNode(tree, key, isOnce);
  }
}

function markStaticNode (node, key, isOnce) {
  node.isStatic = true;
  node.key = key;
  node.isOnce = isOnce;
}

/*  */

function bindObjectListeners (data, value) {
  if (value) {
    if (!isPlainObject(value)) {
      "development" !== 'production' && warn(
        'v-on without argument expects an Object value',
        this
      );
    } else {
      var on = data.on = data.on ? extend({}, data.on) : {};
      for (var key in value) {
        var existing = on[key];
        var ours = value[key];
        on[key] = existing ? [].concat(existing, ours) : ours;
      }
    }
  }
  return data
}

/*  */

function installRenderHelpers (target) {
  target._o = markOnce;
  target._n = toNumber;
  target._s = toString;
  target._l = renderList;
  target._t = renderSlot;
  target._q = looseEqual;
  target._i = looseIndexOf;
  target._m = renderStatic;
  target._f = resolveFilter;
  target._k = checkKeyCodes;
  target._b = bindObjectProps;
  target._v = createTextVNode;
  target._e = createEmptyVNode;
  target._u = resolveScopedSlots;
  target._g = bindObjectListeners;
}

/*  */

function FunctionalRenderContext (
  data,
  props,
  children,
  parent,
  Ctor
) {
  var options = Ctor.options;
  // ensure the createElement function in functional components
  // gets a unique context - this is necessary for correct named slot check
  var contextVm;
  if (hasOwn(parent, '_uid')) {
    contextVm = Object.create(parent);
    // $flow-disable-line
    contextVm._original = parent;
  } else {
    // the context vm passed in is a functional context as well.
    // in this case we want to make sure we are able to get a hold to the
    // real context instance.
    contextVm = parent;
    // $flow-disable-line
    parent = parent._original;
  }
  var isCompiled = isTrue(options._compiled);
  var needNormalization = !isCompiled;

  this.data = data;
  this.props = props;
  this.children = children;
  this.parent = parent;
  this.listeners = data.on || emptyObject;
  this.injections = resolveInject(options.inject, parent);
  this.slots = function () { return resolveSlots(children, parent); };

  // support for compiled functional template
  if (isCompiled) {
    // exposing $options for renderStatic()
    this.$options = options;
    // pre-resolve slots for renderSlot()
    this.$slots = this.slots();
    this.$scopedSlots = data.scopedSlots || emptyObject;
  }

  if (options._scopeId) {
    this._c = function (a, b, c, d) {
      var vnode = createElement(contextVm, a, b, c, d, needNormalization);
      if (vnode && !Array.isArray(vnode)) {
        vnode.fnScopeId = options._scopeId;
        vnode.fnContext = parent;
      }
      return vnode
    };
  } else {
    this._c = function (a, b, c, d) { return createElement(contextVm, a, b, c, d, needNormalization); };
  }
}

installRenderHelpers(FunctionalRenderContext.prototype);

function createFunctionalComponent (
  Ctor,
  propsData,
  data,
  contextVm,
  children
) {
  var options = Ctor.options;
  var props = {};
  var propOptions = options.props;
  if (isDef(propOptions)) {
    for (var key in propOptions) {
      props[key] = validateProp(key, propOptions, propsData || emptyObject);
    }
  } else {
    if (isDef(data.attrs)) { mergeProps(props, data.attrs); }
    if (isDef(data.props)) { mergeProps(props, data.props); }
  }

  var renderContext = new FunctionalRenderContext(
    data,
    props,
    children,
    contextVm,
    Ctor
  );

  var vnode = options.render.call(null, renderContext._c, renderContext);

  if (vnode instanceof VNode) {
    return cloneAndMarkFunctionalResult(vnode, data, renderContext.parent, options)
  } else if (Array.isArray(vnode)) {
    var vnodes = normalizeChildren(vnode) || [];
    var res = new Array(vnodes.length);
    for (var i = 0; i < vnodes.length; i++) {
      res[i] = cloneAndMarkFunctionalResult(vnodes[i], data, renderContext.parent, options);
    }
    return res
  }
}

function cloneAndMarkFunctionalResult (vnode, data, contextVm, options) {
  // #7817 clone node before setting fnContext, otherwise if the node is reused
  // (e.g. it was from a cached normal slot) the fnContext causes named slots
  // that should not be matched to match.
  var clone = cloneVNode(vnode);
  clone.fnContext = contextVm;
  clone.fnOptions = options;
  if (data.slot) {
    (clone.data || (clone.data = {})).slot = data.slot;
  }
  return clone
}

function mergeProps (to, from) {
  for (var key in from) {
    to[camelize(key)] = from[key];
  }
}

/*  */




// Register the component hook to weex native render engine.
// The hook will be triggered by native, not javascript.


// Updates the state of the component to weex native render engine.

/*  */

// https://github.com/Hanks10100/weex-native-directive/tree/master/component

// listening on native callback

/*  */

/*  */

// inline hooks to be invoked on component VNodes during patch
var componentVNodeHooks = {
  init: function init (
    vnode,
    hydrating,
    parentElm,
    refElm
  ) {
    if (
      vnode.componentInstance &&
      !vnode.componentInstance._isDestroyed &&
      vnode.data.keepAlive
    ) {
      // kept-alive components, treat as a patch
      var mountedNode = vnode; // work around flow
      componentVNodeHooks.prepatch(mountedNode, mountedNode);
    } else {
      var child = vnode.componentInstance = createComponentInstanceForVnode(
        vnode,
        activeInstance,
        parentElm,
        refElm
      );
      child.$mount(hydrating ? vnode.elm : undefined, hydrating);
    }
  },

  prepatch: function prepatch (oldVnode, vnode) {
    var options = vnode.componentOptions;
    var child = vnode.componentInstance = oldVnode.componentInstance;
    updateChildComponent(
      child,
      options.propsData, // updated props
      options.listeners, // updated listeners
      vnode, // new parent vnode
      options.children // new children
    );
  },

  insert: function insert (vnode) {
    var context = vnode.context;
    var componentInstance = vnode.componentInstance;
    if (!componentInstance._isMounted) {
      componentInstance._isMounted = true;
      callHook(componentInstance, 'mounted');
    }
    if (vnode.data.keepAlive) {
      if (context._isMounted) {
        // vue-router#1212
        // During updates, a kept-alive component's child components may
        // change, so directly walking the tree here may call activated hooks
        // on incorrect children. Instead we push them into a queue which will
        // be processed after the whole patch process ended.
        queueActivatedComponent(componentInstance);
      } else {
        activateChildComponent(componentInstance, true /* direct */);
      }
    }
  },

  destroy: function destroy (vnode) {
    var componentInstance = vnode.componentInstance;
    if (!componentInstance._isDestroyed) {
      if (!vnode.data.keepAlive) {
        componentInstance.$destroy();
      } else {
        deactivateChildComponent(componentInstance, true /* direct */);
      }
    }
  }
};

var hooksToMerge = Object.keys(componentVNodeHooks);

function createComponent (
  Ctor,
  data,
  context,
  children,
  tag
) {
  if (isUndef(Ctor)) {
    return
  }

  var baseCtor = context.$options._base;

  // plain options object: turn it into a constructor
  if (isObject(Ctor)) {
    Ctor = baseCtor.extend(Ctor);
  }

  // if at this stage it's not a constructor or an async component factory,
  // reject.
  if (typeof Ctor !== 'function') {
    if (true) {
      warn(("Invalid Component definition: " + (String(Ctor))), context);
    }
    return
  }

  // async component
  var asyncFactory;
  if (isUndef(Ctor.cid)) {
    asyncFactory = Ctor;
    Ctor = resolveAsyncComponent(asyncFactory, baseCtor, context);
    if (Ctor === undefined) {
      // return a placeholder node for async component, which is rendered
      // as a comment node but preserves all the raw information for the node.
      // the information will be used for async server-rendering and hydration.
      return createAsyncPlaceholder(
        asyncFactory,
        data,
        context,
        children,
        tag
      )
    }
  }

  data = data || {};

  // resolve constructor options in case global mixins are applied after
  // component constructor creation
  resolveConstructorOptions(Ctor);

  // transform component v-model data into props & events
  if (isDef(data.model)) {
    transformModel(Ctor.options, data);
  }

  // extract props
  var propsData = extractPropsFromVNodeData(data, Ctor, tag);

  // functional component
  if (isTrue(Ctor.options.functional)) {
    return createFunctionalComponent(Ctor, propsData, data, context, children)
  }

  // extract listeners, since these needs to be treated as
  // child component listeners instead of DOM listeners
  var listeners = data.on;
  // replace with listeners with .native modifier
  // so it gets processed during parent component patch.
  data.on = data.nativeOn;

  if (isTrue(Ctor.options.abstract)) {
    // abstract components do not keep anything
    // other than props & listeners & slot

    // work around flow
    var slot = data.slot;
    data = {};
    if (slot) {
      data.slot = slot;
    }
  }

  // install component management hooks onto the placeholder node
  installComponentHooks(data);

  // return a placeholder vnode
  var name = Ctor.options.name || tag;
  var vnode = new VNode(
    ("vue-component-" + (Ctor.cid) + (name ? ("-" + name) : '')),
    data, undefined, undefined, undefined, context,
    { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children },
    asyncFactory
  );

  // Weex specific: invoke recycle-list optimized @render function for
  // extracting cell-slot template.
  // https://github.com/Hanks10100/weex-native-directive/tree/master/component
  /* istanbul ignore if */
  return vnode
}

function createComponentInstanceForVnode (
  vnode, // we know it's MountedComponentVNode but flow doesn't
  parent, // activeInstance in lifecycle state
  parentElm,
  refElm
) {
  var options = {
    _isComponent: true,
    parent: parent,
    _parentVnode: vnode,
    _parentElm: parentElm || null,
    _refElm: refElm || null
  };
  // check inline-template render functions
  var inlineTemplate = vnode.data.inlineTemplate;
  if (isDef(inlineTemplate)) {
    options.render = inlineTemplate.render;
    options.staticRenderFns = inlineTemplate.staticRenderFns;
  }
  return new vnode.componentOptions.Ctor(options)
}

function installComponentHooks (data) {
  var hooks = data.hook || (data.hook = {});
  for (var i = 0; i < hooksToMerge.length; i++) {
    var key = hooksToMerge[i];
    hooks[key] = componentVNodeHooks[key];
  }
}

// transform component v-model info (value and callback) into
// prop and event handler respectively.
function transformModel (options, data) {
  var prop = (options.model && options.model.prop) || 'value';
  var event = (options.model && options.model.event) || 'input';(data.props || (data.props = {}))[prop] = data.model.value;
  var on = data.on || (data.on = {});
  if (isDef(on[event])) {
    on[event] = [data.model.callback].concat(on[event]);
  } else {
    on[event] = data.model.callback;
  }
}

/*  */

var SIMPLE_NORMALIZE = 1;
var ALWAYS_NORMALIZE = 2;

// wrapper function for providing a more flexible interface
// without getting yelled at by flow
function createElement (
  context,
  tag,
  data,
  children,
  normalizationType,
  alwaysNormalize
) {
  if (Array.isArray(data) || isPrimitive(data)) {
    normalizationType = children;
    children = data;
    data = undefined;
  }
  if (isTrue(alwaysNormalize)) {
    normalizationType = ALWAYS_NORMALIZE;
  }
  return _createElement(context, tag, data, children, normalizationType)
}

function _createElement (
  context,
  tag,
  data,
  children,
  normalizationType
) {
  if (isDef(data) && isDef((data).__ob__)) {
    "development" !== 'production' && warn(
      "Avoid using observed data object as vnode data: " + (JSON.stringify(data)) + "\n" +
      'Always create fresh vnode data objects in each render!',
      context
    );
    return createEmptyVNode()
  }
  // object syntax in v-bind
  if (isDef(data) && isDef(data.is)) {
    tag = data.is;
  }
  if (!tag) {
    // in case of component :is set to falsy value
    return createEmptyVNode()
  }
  // warn against non-primitive key
  if ("development" !== 'production' &&
    isDef(data) && isDef(data.key) && !isPrimitive(data.key)
  ) {
    {
      warn(
        'Avoid using non-primitive value as key, ' +
        'use string/number value instead.',
        context
      );
    }
  }
  // support single function children as default scoped slot
  if (Array.isArray(children) &&
    typeof children[0] === 'function'
  ) {
    data = data || {};
    data.scopedSlots = { default: children[0] };
    children.length = 0;
  }
  if (normalizationType === ALWAYS_NORMALIZE) {
    children = normalizeChildren(children);
  } else if (normalizationType === SIMPLE_NORMALIZE) {
    children = simpleNormalizeChildren(children);
  }
  var vnode, ns;
  if (typeof tag === 'string') {
    var Ctor;
    ns = (context.$vnode && context.$vnode.ns) || config.getTagNamespace(tag);
    if (config.isReservedTag(tag)) {
      // platform built-in elements
      vnode = new VNode(
        config.parsePlatformTagName(tag), data, children,
        undefined, undefined, context
      );
    } else if (isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {
      // component
      vnode = createComponent(Ctor, data, context, children, tag);
    } else {
      // unknown or unlisted namespaced elements
      // check at runtime because it may get assigned a namespace when its
      // parent normalizes children
      vnode = new VNode(
        tag, data, children,
        undefined, undefined, context
      );
    }
  } else {
    // direct component options / constructor
    vnode = createComponent(tag, data, context, children);
  }
  if (Array.isArray(vnode)) {
    return vnode
  } else if (isDef(vnode)) {
    if (isDef(ns)) { applyNS(vnode, ns); }
    if (isDef(data)) { registerDeepBindings(data); }
    return vnode
  } else {
    return createEmptyVNode()
  }
}

function applyNS (vnode, ns, force) {
  vnode.ns = ns;
  if (vnode.tag === 'foreignObject') {
    // use default namespace inside foreignObject
    ns = undefined;
    force = true;
  }
  if (isDef(vnode.children)) {
    for (var i = 0, l = vnode.children.length; i < l; i++) {
      var child = vnode.children[i];
      if (isDef(child.tag) && (
        isUndef(child.ns) || (isTrue(force) && child.tag !== 'svg'))) {
        applyNS(child, ns, force);
      }
    }
  }
}

// ref #5318
// necessary to ensure parent re-render when deep bindings like :style and
// :class are used on slot nodes
function registerDeepBindings (data) {
  if (isObject(data.style)) {
    traverse(data.style);
  }
  if (isObject(data.class)) {
    traverse(data.class);
  }
}

/*  */

function initRender (vm) {
  vm._vnode = null; // the root of the child tree
  vm._staticTrees = null; // v-once cached trees
  var options = vm.$options;
  var parentVnode = vm.$vnode = options._parentVnode; // the placeholder node in parent tree
  var renderContext = parentVnode && parentVnode.context;
  vm.$slots = resolveSlots(options._renderChildren, renderContext);
  vm.$scopedSlots = emptyObject;
  // bind the createElement fn to this instance
  // so that we get proper render context inside it.
  // args order: tag, data, children, normalizationType, alwaysNormalize
  // internal version is used by render functions compiled from templates
  vm._c = function (a, b, c, d) { return createElement(vm, a, b, c, d, false); };
  // normalization is always applied for the public version, used in
  // user-written render functions.
  vm.$createElement = function (a, b, c, d) { return createElement(vm, a, b, c, d, true); };

  // $attrs & $listeners are exposed for easier HOC creation.
  // they need to be reactive so that HOCs using them are always updated
  var parentData = parentVnode && parentVnode.data;

  /* istanbul ignore else */
  if (true) {
    defineReactive(vm, '$attrs', parentData && parentData.attrs || emptyObject, function () {
      !isUpdatingChildComponent && warn("$attrs is readonly.", vm);
    }, true);
    defineReactive(vm, '$listeners', options._parentListeners || emptyObject, function () {
      !isUpdatingChildComponent && warn("$listeners is readonly.", vm);
    }, true);
  } else {
    defineReactive(vm, '$attrs', parentData && parentData.attrs || emptyObject, null, true);
    defineReactive(vm, '$listeners', options._parentListeners || emptyObject, null, true);
  }
}

function renderMixin (Vue) {
  // install runtime convenience helpers
  installRenderHelpers(Vue.prototype);

  Vue.prototype.$nextTick = function (fn) {
    return nextTick(fn, this)
  };

  Vue.prototype._render = function () {
    var vm = this;
    var ref = vm.$options;
    var render = ref.render;
    var _parentVnode = ref._parentVnode;

    // reset _rendered flag on slots for duplicate slot check
    if (true) {
      for (var key in vm.$slots) {
        // $flow-disable-line
        vm.$slots[key]._rendered = false;
      }
    }

    if (_parentVnode) {
      vm.$scopedSlots = _parentVnode.data.scopedSlots || emptyObject;
    }

    // set parent vnode. this allows render functions to have access
    // to the data on the placeholder node.
    vm.$vnode = _parentVnode;
    // render self
    var vnode;
    try {
      vnode = render.call(vm._renderProxy, vm.$createElement);
    } catch (e) {
      handleError(e, vm, "render");
      // return error render result,
      // or previous vnode to prevent render error causing blank component
      /* istanbul ignore else */
      if (true) {
        if (vm.$options.renderError) {
          try {
            vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e);
          } catch (e) {
            handleError(e, vm, "renderError");
            vnode = vm._vnode;
          }
        } else {
          vnode = vm._vnode;
        }
      } else {
        vnode = vm._vnode;
      }
    }
    // return empty vnode in case the render function errored out
    if (!(vnode instanceof VNode)) {
      if ("development" !== 'production' && Array.isArray(vnode)) {
        warn(
          'Multiple root nodes returned from render function. Render function ' +
          'should return a single root node.',
          vm
        );
      }
      vnode = createEmptyVNode();
    }
    // set parent
    vnode.parent = _parentVnode;
    return vnode
  };
}

/*  */

var uid$3 = 0;

function initMixin (Vue) {
  Vue.prototype._init = function (options) {
    var vm = this;
    // a uid
    vm._uid = uid$3++;

    var startTag, endTag;
    /* istanbul ignore if */
    if ("development" !== 'production' && config.performance && mark) {
      startTag = "vue-perf-start:" + (vm._uid);
      endTag = "vue-perf-end:" + (vm._uid);
      mark(startTag);
    }

    // a flag to avoid this being observed
    vm._isVue = true;
    // merge options
    if (options && options._isComponent) {
      // optimize internal component instantiation
      // since dynamic options merging is pretty slow, and none of the
      // internal component options needs special treatment.
      initInternalComponent(vm, options);
    } else {
      vm.$options = mergeOptions(
        resolveConstructorOptions(vm.constructor),
        options || {},
        vm
      );
    }
    /* istanbul ignore else */
    if (true) {
      initProxy(vm);
    } else {
      vm._renderProxy = vm;
    }
    // expose real self
    vm._self = vm;
    initLifecycle(vm);
    initEvents(vm);
    initRender(vm);
    callHook(vm, 'beforeCreate');
    initInjections(vm); // resolve injections before data/props
    initState(vm);
    initProvide(vm); // resolve provide after data/props
    callHook(vm, 'created');

    /* istanbul ignore if */
    if ("development" !== 'production' && config.performance && mark) {
      vm._name = formatComponentName(vm, false);
      mark(endTag);
      measure(("vue " + (vm._name) + " init"), startTag, endTag);
    }

    if (vm.$options.el) {
      vm.$mount(vm.$options.el);
    }
  };
}

function initInternalComponent (vm, options) {
  var opts = vm.$options = Object.create(vm.constructor.options);
  // doing this because it's faster than dynamic enumeration.
  var parentVnode = options._parentVnode;
  opts.parent = options.parent;
  opts._parentVnode = parentVnode;
  opts._parentElm = options._parentElm;
  opts._refElm = options._refElm;

  var vnodeComponentOptions = parentVnode.componentOptions;
  opts.propsData = vnodeComponentOptions.propsData;
  opts._parentListeners = vnodeComponentOptions.listeners;
  opts._renderChildren = vnodeComponentOptions.children;
  opts._componentTag = vnodeComponentOptions.tag;

  if (options.render) {
    opts.render = options.render;
    opts.staticRenderFns = options.staticRenderFns;
  }
}

function resolveConstructorOptions (Ctor) {
  var options = Ctor.options;
  if (Ctor.super) {
    var superOptions = resolveConstructorOptions(Ctor.super);
    var cachedSuperOptions = Ctor.superOptions;
    if (superOptions !== cachedSuperOptions) {
      // super option changed,
      // need to resolve new options.
      Ctor.superOptions = superOptions;
      // check if there are any late-modified/attached options (#4976)
      var modifiedOptions = resolveModifiedOptions(Ctor);
      // update base extend options
      if (modifiedOptions) {
        extend(Ctor.extendOptions, modifiedOptions);
      }
      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);
      if (options.name) {
        options.components[options.name] = Ctor;
      }
    }
  }
  return options
}

function resolveModifiedOptions (Ctor) {
  var modified;
  var latest = Ctor.options;
  var extended = Ctor.extendOptions;
  var sealed = Ctor.sealedOptions;
  for (var key in latest) {
    if (latest[key] !== sealed[key]) {
      if (!modified) { modified = {}; }
      modified[key] = dedupe(latest[key], extended[key], sealed[key]);
    }
  }
  return modified
}

function dedupe (latest, extended, sealed) {
  // compare latest and sealed to ensure lifecycle hooks won't be duplicated
  // between merges
  if (Array.isArray(latest)) {
    var res = [];
    sealed = Array.isArray(sealed) ? sealed : [sealed];
    extended = Array.isArray(extended) ? extended : [extended];
    for (var i = 0; i < latest.length; i++) {
      // push original options and not sealed options to exclude duplicated options
      if (extended.indexOf(latest[i]) >= 0 || sealed.indexOf(latest[i]) < 0) {
        res.push(latest[i]);
      }
    }
    return res
  } else {
    return latest
  }
}

function Vue (options) {
  if ("development" !== 'production' &&
    !(this instanceof Vue)
  ) {
    warn('Vue is a constructor and should be called with the `new` keyword');
  }
  this._init(options);
}

initMixin(Vue);
stateMixin(Vue);
eventsMixin(Vue);
lifecycleMixin(Vue);
renderMixin(Vue);

/*  */

function initUse (Vue) {
  Vue.use = function (plugin) {
    var installedPlugins = (this._installedPlugins || (this._installedPlugins = []));
    if (installedPlugins.indexOf(plugin) > -1) {
      return this
    }

    // additional parameters
    var args = toArray(arguments, 1);
    args.unshift(this);
    if (typeof plugin.install === 'function') {
      plugin.install.apply(plugin, args);
    } else if (typeof plugin === 'function') {
      plugin.apply(null, args);
    }
    installedPlugins.push(plugin);
    return this
  };
}

/*  */

function initMixin$1 (Vue) {
  Vue.mixin = function (mixin) {
    this.options = mergeOptions(this.options, mixin);
    return this
  };
}

/*  */

function initExtend (Vue) {
  /**
   * Each instance constructor, including Vue, has a unique
   * cid. This enables us to create wrapped "child
   * constructors" for prototypal inheritance and cache them.
   */
  Vue.cid = 0;
  var cid = 1;

  /**
   * Class inheritance
   */
  Vue.extend = function (extendOptions) {
    extendOptions = extendOptions || {};
    var Super = this;
    var SuperId = Super.cid;
    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});
    if (cachedCtors[SuperId]) {
      return cachedCtors[SuperId]
    }

    var name = extendOptions.name || Super.options.name;
    if ("development" !== 'production' && name) {
      validateComponentName(name);
    }

    var Sub = function VueComponent (options) {
      this._init(options);
    };
    Sub.prototype = Object.create(Super.prototype);
    Sub.prototype.constructor = Sub;
    Sub.cid = cid++;
    Sub.options = mergeOptions(
      Super.options,
      extendOptions
    );
    Sub['super'] = Super;

    // For props and computed properties, we define the proxy getters on
    // the Vue instances at extension time, on the extended prototype. This
    // avoids Object.defineProperty calls for each instance created.
    if (Sub.options.props) {
      initProps$1(Sub);
    }
    if (Sub.options.computed) {
      initComputed$1(Sub);
    }

    // allow further extension/mixin/plugin usage
    Sub.extend = Super.extend;
    Sub.mixin = Super.mixin;
    Sub.use = Super.use;

    // create asset registers, so extended classes
    // can have their private assets too.
    ASSET_TYPES.forEach(function (type) {
      Sub[type] = Super[type];
    });
    // enable recursive self-lookup
    if (name) {
      Sub.options.components[name] = Sub;
    }

    // keep a reference to the super options at extension time.
    // later at instantiation we can check if Super's options have
    // been updated.
    Sub.superOptions = Super.options;
    Sub.extendOptions = extendOptions;
    Sub.sealedOptions = extend({}, Sub.options);

    // cache constructor
    cachedCtors[SuperId] = Sub;
    return Sub
  };
}

function initProps$1 (Comp) {
  var props = Comp.options.props;
  for (var key in props) {
    proxy(Comp.prototype, "_props", key);
  }
}

function initComputed$1 (Comp) {
  var computed = Comp.options.computed;
  for (var key in computed) {
    defineComputed(Comp.prototype, key, computed[key]);
  }
}

/*  */

function initAssetRegisters (Vue) {
  /**
   * Create asset registration methods.
   */
  ASSET_TYPES.forEach(function (type) {
    Vue[type] = function (
      id,
      definition
    ) {
      if (!definition) {
        return this.options[type + 's'][id]
      } else {
        /* istanbul ignore if */
        if ("development" !== 'production' && type === 'component') {
          validateComponentName(id);
        }
        if (type === 'component' && isPlainObject(definition)) {
          definition.name = definition.name || id;
          definition = this.options._base.extend(definition);
        }
        if (type === 'directive' && typeof definition === 'function') {
          definition = { bind: definition, update: definition };
        }
        this.options[type + 's'][id] = definition;
        return definition
      }
    };
  });
}

/*  */

function getComponentName (opts) {
  return opts && (opts.Ctor.options.name || opts.tag)
}

function matches (pattern, name) {
  if (Array.isArray(pattern)) {
    return pattern.indexOf(name) > -1
  } else if (typeof pattern === 'string') {
    return pattern.split(',').indexOf(name) > -1
  } else if (isRegExp(pattern)) {
    return pattern.test(name)
  }
  /* istanbul ignore next */
  return false
}

function pruneCache (keepAliveInstance, filter) {
  var cache = keepAliveInstance.cache;
  var keys = keepAliveInstance.keys;
  var _vnode = keepAliveInstance._vnode;
  for (var key in cache) {
    var cachedNode = cache[key];
    if (cachedNode) {
      var name = getComponentName(cachedNode.componentOptions);
      if (name && !filter(name)) {
        pruneCacheEntry(cache, key, keys, _vnode);
      }
    }
  }
}

function pruneCacheEntry (
  cache,
  key,
  keys,
  current
) {
  var cached$$1 = cache[key];
  if (cached$$1 && (!current || cached$$1.tag !== current.tag)) {
    cached$$1.componentInstance.$destroy();
  }
  cache[key] = null;
  remove(keys, key);
}

var patternTypes = [String, RegExp, Array];

var KeepAlive = {
  name: 'keep-alive',
  abstract: true,

  props: {
    include: patternTypes,
    exclude: patternTypes,
    max: [String, Number]
  },

  created: function created () {
    this.cache = Object.create(null);
    this.keys = [];
  },

  destroyed: function destroyed () {
    var this$1 = this;

    for (var key in this$1.cache) {
      pruneCacheEntry(this$1.cache, key, this$1.keys);
    }
  },

  mounted: function mounted () {
    var this$1 = this;

    this.$watch('include', function (val) {
      pruneCache(this$1, function (name) { return matches(val, name); });
    });
    this.$watch('exclude', function (val) {
      pruneCache(this$1, function (name) { return !matches(val, name); });
    });
  },

  render: function render () {
    var slot = this.$slots.default;
    var vnode = getFirstComponentChild(slot);
    var componentOptions = vnode && vnode.componentOptions;
    if (componentOptions) {
      // check pattern
      var name = getComponentName(componentOptions);
      var ref = this;
      var include = ref.include;
      var exclude = ref.exclude;
      if (
        // not included
        (include && (!name || !matches(include, name))) ||
        // excluded
        (exclude && name && matches(exclude, name))
      ) {
        return vnode
      }

      var ref$1 = this;
      var cache = ref$1.cache;
      var keys = ref$1.keys;
      var key = vnode.key == null
        // same constructor may get registered as different local components
        // so cid alone is not enough (#3269)
        ? componentOptions.Ctor.cid + (componentOptions.tag ? ("::" + (componentOptions.tag)) : '')
        : vnode.key;
      if (cache[key]) {
        vnode.componentInstance = cache[key].componentInstance;
        // make current key freshest
        remove(keys, key);
        keys.push(key);
      } else {
        cache[key] = vnode;
        keys.push(key);
        // prune oldest entry
        if (this.max && keys.length > parseInt(this.max)) {
          pruneCacheEntry(cache, keys[0], keys, this._vnode);
        }
      }

      vnode.data.keepAlive = true;
    }
    return vnode || (slot && slot[0])
  }
}

var builtInComponents = {
  KeepAlive: KeepAlive
}

/*  */

function initGlobalAPI (Vue) {
  // config
  var configDef = {};
  configDef.get = function () { return config; };
  if (true) {
    configDef.set = function () {
      warn(
        'Do not replace the Vue.config object, set individual fields instead.'
      );
    };
  }
  Object.defineProperty(Vue, 'config', configDef);

  // exposed util methods.
  // NOTE: these are not considered part of the public API - avoid relying on
  // them unless you are aware of the risk.
  Vue.util = {
    warn: warn,
    extend: extend,
    mergeOptions: mergeOptions,
    defineReactive: defineReactive
  };

  Vue.set = set;
  Vue.delete = del;
  Vue.nextTick = nextTick;

  Vue.options = Object.create(null);
  ASSET_TYPES.forEach(function (type) {
    Vue.options[type + 's'] = Object.create(null);
  });

  // this is used to identify the "base" constructor to extend all plain-object
  // components with in Weex's multi-instance scenarios.
  Vue.options._base = Vue;

  extend(Vue.options.components, builtInComponents);

  initUse(Vue);
  initMixin$1(Vue);
  initExtend(Vue);
  initAssetRegisters(Vue);
}

initGlobalAPI(Vue);

Object.defineProperty(Vue.prototype, '$isServer', {
  get: isServerRendering
});

Object.defineProperty(Vue.prototype, '$ssrContext', {
  get: function get () {
    /* istanbul ignore next */
    return this.$vnode && this.$vnode.ssrContext
  }
});

// expose FunctionalRenderContext for ssr runtime helper installation
Object.defineProperty(Vue, 'FunctionalRenderContext', {
  value: FunctionalRenderContext
});

Vue.version = '2.5.16';

/*  */

// these are reserved for web because they are directly compiled away
// during template compilation
var isReservedAttr = makeMap('style,class');

// attributes that should be using props for binding
var acceptValue = makeMap('input,textarea,option,select,progress');
var mustUseProp = function (tag, type, attr) {
  return (
    (attr === 'value' && acceptValue(tag)) && type !== 'button' ||
    (attr === 'selected' && tag === 'option') ||
    (attr === 'checked' && tag === 'input') ||
    (attr === 'muted' && tag === 'video')
  )
};

var isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');

var isBooleanAttr = makeMap(
  'allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' +
  'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' +
  'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' +
  'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' +
  'required,reversed,scoped,seamless,selected,sortable,translate,' +
  'truespeed,typemustmatch,visible'
);

var xlinkNS = 'http://www.w3.org/1999/xlink';

var isXlink = function (name) {
  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink'
};

var getXlinkProp = function (name) {
  return isXlink(name) ? name.slice(6, name.length) : ''
};

var isFalsyAttrValue = function (val) {
  return val == null || val === false
};

/*  */

function genClassForVnode (vnode) {
  var data = vnode.data;
  var parentNode = vnode;
  var childNode = vnode;
  while (isDef(childNode.componentInstance)) {
    childNode = childNode.componentInstance._vnode;
    if (childNode && childNode.data) {
      data = mergeClassData(childNode.data, data);
    }
  }
  while (isDef(parentNode = parentNode.parent)) {
    if (parentNode && parentNode.data) {
      data = mergeClassData(data, parentNode.data);
    }
  }
  return renderClass(data.staticClass, data.class)
}

function mergeClassData (child, parent) {
  return {
    staticClass: concat(child.staticClass, parent.staticClass),
    class: isDef(child.class)
      ? [child.class, parent.class]
      : parent.class
  }
}

function renderClass (
  staticClass,
  dynamicClass
) {
  if (isDef(staticClass) || isDef(dynamicClass)) {
    return concat(staticClass, stringifyClass(dynamicClass))
  }
  /* istanbul ignore next */
  return ''
}

function concat (a, b) {
  return a ? b ? (a + ' ' + b) : a : (b || '')
}

function stringifyClass (value) {
  if (Array.isArray(value)) {
    return stringifyArray(value)
  }
  if (isObject(value)) {
    return stringifyObject(value)
  }
  if (typeof value === 'string') {
    return value
  }
  /* istanbul ignore next */
  return ''
}

function stringifyArray (value) {
  var res = '';
  var stringified;
  for (var i = 0, l = value.length; i < l; i++) {
    if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {
      if (res) { res += ' '; }
      res += stringified;
    }
  }
  return res
}

function stringifyObject (value) {
  var res = '';
  for (var key in value) {
    if (value[key]) {
      if (res) { res += ' '; }
      res += key;
    }
  }
  return res
}

/*  */

var namespaceMap = {
  svg: 'http://www.w3.org/2000/svg',
  math: 'http://www.w3.org/1998/Math/MathML'
};

var isHTMLTag = makeMap(
  'html,body,base,head,link,meta,style,title,' +
  'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' +
  'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' +
  'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' +
  's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' +
  'embed,object,param,source,canvas,script,noscript,del,ins,' +
  'caption,col,colgroup,table,thead,tbody,td,th,tr,' +
  'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' +
  'output,progress,select,textarea,' +
  'details,dialog,menu,menuitem,summary,' +
  'content,element,shadow,template,blockquote,iframe,tfoot'
);

// this map is intentionally selective, only covering SVG elements that may
// contain child elements.
var isSVG = makeMap(
  'svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' +
  'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' +
  'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view',
  true
);

var isPreTag = function (tag) { return tag === 'pre'; };

var isReservedTag = function (tag) {
  return isHTMLTag(tag) || isSVG(tag)
};

function getTagNamespace (tag) {
  if (isSVG(tag)) {
    return 'svg'
  }
  // basic support for MathML
  // note it doesn't support other MathML elements being component roots
  if (tag === 'math') {
    return 'math'
  }
}

var unknownElementCache = Object.create(null);
function isUnknownElement (tag) {
  /* istanbul ignore if */
  if (!inBrowser) {
    return true
  }
  if (isReservedTag(tag)) {
    return false
  }
  tag = tag.toLowerCase();
  /* istanbul ignore if */
  if (unknownElementCache[tag] != null) {
    return unknownElementCache[tag]
  }
  var el = document.createElement(tag);
  if (tag.indexOf('-') > -1) {
    // http://stackoverflow.com/a/28210364/1070244
    return (unknownElementCache[tag] = (
      el.constructor === window.HTMLUnknownElement ||
      el.constructor === window.HTMLElement
    ))
  } else {
    return (unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString()))
  }
}

var isTextInputType = makeMap('text,number,password,search,email,tel,url');

/*  */

/**
 * Query an element selector if it's not an element already.
 */
function query (el) {
  if (typeof el === 'string') {
    var selected = document.querySelector(el);
    if (!selected) {
      "development" !== 'production' && warn(
        'Cannot find element: ' + el
      );
      return document.createElement('div')
    }
    return selected
  } else {
    return el
  }
}

/*  */

function createElement$1 (tagName, vnode) {
  var elm = document.createElement(tagName);
  if (tagName !== 'select') {
    return elm
  }
  // false or null will remove the attribute but undefined will not
  if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {
    elm.setAttribute('multiple', 'multiple');
  }
  return elm
}

function createElementNS (namespace, tagName) {
  return document.createElementNS(namespaceMap[namespace], tagName)
}

function createTextNode (text) {
  return document.createTextNode(text)
}

function createComment (text) {
  return document.createComment(text)
}

function insertBefore (parentNode, newNode, referenceNode) {
  parentNode.insertBefore(newNode, referenceNode);
}

function removeChild (node, child) {
  node.removeChild(child);
}

function appendChild (node, child) {
  node.appendChild(child);
}

function parentNode (node) {
  return node.parentNode
}

function nextSibling (node) {
  return node.nextSibling
}

function tagName (node) {
  return node.tagName
}

function setTextContent (node, text) {
  node.textContent = text;
}

function setStyleScope (node, scopeId) {
  node.setAttribute(scopeId, '');
}


var nodeOps = Object.freeze({
	createElement: createElement$1,
	createElementNS: createElementNS,
	createTextNode: createTextNode,
	createComment: createComment,
	insertBefore: insertBefore,
	removeChild: removeChild,
	appendChild: appendChild,
	parentNode: parentNode,
	nextSibling: nextSibling,
	tagName: tagName,
	setTextContent: setTextContent,
	setStyleScope: setStyleScope
});

/*  */

var ref = {
  create: function create (_, vnode) {
    registerRef(vnode);
  },
  update: function update (oldVnode, vnode) {
    if (oldVnode.data.ref !== vnode.data.ref) {
      registerRef(oldVnode, true);
      registerRef(vnode);
    }
  },
  destroy: function destroy (vnode) {
    registerRef(vnode, true);
  }
}

function registerRef (vnode, isRemoval) {
  var key = vnode.data.ref;
  if (!isDef(key)) { return }

  var vm = vnode.context;
  var ref = vnode.componentInstance || vnode.elm;
  var refs = vm.$refs;
  if (isRemoval) {
    if (Array.isArray(refs[key])) {
      remove(refs[key], ref);
    } else if (refs[key] === ref) {
      refs[key] = undefined;
    }
  } else {
    if (vnode.data.refInFor) {
      if (!Array.isArray(refs[key])) {
        refs[key] = [ref];
      } else if (refs[key].indexOf(ref) < 0) {
        // $flow-disable-line
        refs[key].push(ref);
      }
    } else {
      refs[key] = ref;
    }
  }
}

/**
 * Virtual DOM patching algorithm based on Snabbdom by
 * Simon Friis Vindum (@paldepind)
 * Licensed under the MIT License
 * https://github.com/paldepind/snabbdom/blob/master/LICENSE
 *
 * modified by Evan You (@yyx990803)
 *
 * Not type-checking this because this file is perf-critical and the cost
 * of making flow understand it is not worth it.
 */

var emptyNode = new VNode('', {}, []);

var hooks = ['create', 'activate', 'update', 'remove', 'destroy'];

function sameVnode (a, b) {
  return (
    a.key === b.key && (
      (
        a.tag === b.tag &&
        a.isComment === b.isComment &&
        isDef(a.data) === isDef(b.data) &&
        sameInputType(a, b)
      ) || (
        isTrue(a.isAsyncPlaceholder) &&
        a.asyncFactory === b.asyncFactory &&
        isUndef(b.asyncFactory.error)
      )
    )
  )
}

function sameInputType (a, b) {
  if (a.tag !== 'input') { return true }
  var i;
  var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;
  var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;
  return typeA === typeB || isTextInputType(typeA) && isTextInputType(typeB)
}

function createKeyToOldIdx (children, beginIdx, endIdx) {
  var i, key;
  var map = {};
  for (i = beginIdx; i <= endIdx; ++i) {
    key = children[i].key;
    if (isDef(key)) { map[key] = i; }
  }
  return map
}

function createPatchFunction (backend) {
  var i, j;
  var cbs = {};

  var modules = backend.modules;
  var nodeOps = backend.nodeOps;

  for (i = 0; i < hooks.length; ++i) {
    cbs[hooks[i]] = [];
    for (j = 0; j < modules.length; ++j) {
      if (isDef(modules[j][hooks[i]])) {
        cbs[hooks[i]].push(modules[j][hooks[i]]);
      }
    }
  }

  function emptyNodeAt (elm) {
    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm)
  }

  function createRmCb (childElm, listeners) {
    function remove () {
      if (--remove.listeners === 0) {
        removeNode(childElm);
      }
    }
    remove.listeners = listeners;
    return remove
  }

  function removeNode (el) {
    var parent = nodeOps.parentNode(el);
    // element may have already been removed due to v-html / v-text
    if (isDef(parent)) {
      nodeOps.removeChild(parent, el);
    }
  }

  function isUnknownElement$$1 (vnode, inVPre) {
    return (
      !inVPre &&
      !vnode.ns &&
      !(
        config.ignoredElements.length &&
        config.ignoredElements.some(function (ignore) {
          return isRegExp(ignore)
            ? ignore.test(vnode.tag)
            : ignore === vnode.tag
        })
      ) &&
      config.isUnknownElement(vnode.tag)
    )
  }

  var creatingElmInVPre = 0;

  function createElm (
    vnode,
    insertedVnodeQueue,
    parentElm,
    refElm,
    nested,
    ownerArray,
    index
  ) {
    if (isDef(vnode.elm) && isDef(ownerArray)) {
      // This vnode was used in a previous render!
      // now it's used as a new node, overwriting its elm would cause
      // potential patch errors down the road when it's used as an insertion
      // reference node. Instead, we clone the node on-demand before creating
      // associated DOM element for it.
      vnode = ownerArray[index] = cloneVNode(vnode);
    }

    vnode.isRootInsert = !nested; // for transition enter check
    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {
      return
    }

    var data = vnode.data;
    var children = vnode.children;
    var tag = vnode.tag;
    if (isDef(tag)) {
      if (true) {
        if (data && data.pre) {
          creatingElmInVPre++;
        }
        if (isUnknownElement$$1(vnode, creatingElmInVPre)) {
          warn(
            'Unknown custom element: <' + tag + '> - did you ' +
            'register the component correctly? For recursive components, ' +
            'make sure to provide the "name" option.',
            vnode.context
          );
        }
      }

      vnode.elm = vnode.ns
        ? nodeOps.createElementNS(vnode.ns, tag)
        : nodeOps.createElement(tag, vnode);
      setScope(vnode);

      /* istanbul ignore if */
      {
        createChildren(vnode, children, insertedVnodeQueue);
        if (isDef(data)) {
          invokeCreateHooks(vnode, insertedVnodeQueue);
        }
        insert(parentElm, vnode.elm, refElm);
      }

      if ("development" !== 'production' && data && data.pre) {
        creatingElmInVPre--;
      }
    } else if (isTrue(vnode.isComment)) {
      vnode.elm = nodeOps.createComment(vnode.text);
      insert(parentElm, vnode.elm, refElm);
    } else {
      vnode.elm = nodeOps.createTextNode(vnode.text);
      insert(parentElm, vnode.elm, refElm);
    }
  }

  function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {
    var i = vnode.data;
    if (isDef(i)) {
      var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;
      if (isDef(i = i.hook) && isDef(i = i.init)) {
        i(vnode, false /* hydrating */, parentElm, refElm);
      }
      // after calling the init hook, if the vnode is a child component
      // it should've created a child instance and mounted it. the child
      // component also has set the placeholder vnode's elm.
      // in that case we can just return the element and be done.
      if (isDef(vnode.componentInstance)) {
        initComponent(vnode, insertedVnodeQueue);
        if (isTrue(isReactivated)) {
          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);
        }
        return true
      }
    }
  }

  function initComponent (vnode, insertedVnodeQueue) {
    if (isDef(vnode.data.pendingInsert)) {
      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);
      vnode.data.pendingInsert = null;
    }
    vnode.elm = vnode.componentInstance.$el;
    if (isPatchable(vnode)) {
      invokeCreateHooks(vnode, insertedVnodeQueue);
      setScope(vnode);
    } else {
      // empty component root.
      // skip all element-related modules except for ref (#3455)
      registerRef(vnode);
      // make sure to invoke the insert hook
      insertedVnodeQueue.push(vnode);
    }
  }

  function reactivateComponent (vnode, insertedVnodeQueue, parentElm, refElm) {
    var i;
    // hack for #4339: a reactivated component with inner transition
    // does not trigger because the inner node's created hooks are not called
    // again. It's not ideal to involve module-specific logic in here but
    // there doesn't seem to be a better way to do it.
    var innerNode = vnode;
    while (innerNode.componentInstance) {
      innerNode = innerNode.componentInstance._vnode;
      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {
        for (i = 0; i < cbs.activate.length; ++i) {
          cbs.activate[i](emptyNode, innerNode);
        }
        insertedVnodeQueue.push(innerNode);
        break
      }
    }
    // unlike a newly created component,
    // a reactivated keep-alive component doesn't insert itself
    insert(parentElm, vnode.elm, refElm);
  }

  function insert (parent, elm, ref$$1) {
    if (isDef(parent)) {
      if (isDef(ref$$1)) {
        if (ref$$1.parentNode === parent) {
          nodeOps.insertBefore(parent, elm, ref$$1);
        }
      } else {
        nodeOps.appendChild(parent, elm);
      }
    }
  }

  function createChildren (vnode, children, insertedVnodeQueue) {
    if (Array.isArray(children)) {
      if (true) {
        checkDuplicateKeys(children);
      }
      for (var i = 0; i < children.length; ++i) {
        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true, children, i);
      }
    } else if (isPrimitive(vnode.text)) {
      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(String(vnode.text)));
    }
  }

  function isPatchable (vnode) {
    while (vnode.componentInstance) {
      vnode = vnode.componentInstance._vnode;
    }
    return isDef(vnode.tag)
  }

  function invokeCreateHooks (vnode, insertedVnodeQueue) {
    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
      cbs.create[i$1](emptyNode, vnode);
    }
    i = vnode.data.hook; // Reuse variable
    if (isDef(i)) {
      if (isDef(i.create)) { i.create(emptyNode, vnode); }
      if (isDef(i.insert)) { insertedVnodeQueue.push(vnode); }
    }
  }

  // set scope id attribute for scoped CSS.
  // this is implemented as a special case to avoid the overhead
  // of going through the normal attribute patching process.
  function setScope (vnode) {
    var i;
    if (isDef(i = vnode.fnScopeId)) {
      nodeOps.setStyleScope(vnode.elm, i);
    } else {
      var ancestor = vnode;
      while (ancestor) {
        if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {
          nodeOps.setStyleScope(vnode.elm, i);
        }
        ancestor = ancestor.parent;
      }
    }
    // for slot content they should also get the scopeId from the host instance.
    if (isDef(i = activeInstance) &&
      i !== vnode.context &&
      i !== vnode.fnContext &&
      isDef(i = i.$options._scopeId)
    ) {
      nodeOps.setStyleScope(vnode.elm, i);
    }
  }

  function addVnodes (parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {
    for (; startIdx <= endIdx; ++startIdx) {
      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm, false, vnodes, startIdx);
    }
  }

  function invokeDestroyHook (vnode) {
    var i, j;
    var data = vnode.data;
    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.destroy)) { i(vnode); }
      for (i = 0; i < cbs.destroy.length; ++i) { cbs.destroy[i](vnode); }
    }
    if (isDef(i = vnode.children)) {
      for (j = 0; j < vnode.children.length; ++j) {
        invokeDestroyHook(vnode.children[j]);
      }
    }
  }

  function removeVnodes (parentElm, vnodes, startIdx, endIdx) {
    for (; startIdx <= endIdx; ++startIdx) {
      var ch = vnodes[startIdx];
      if (isDef(ch)) {
        if (isDef(ch.tag)) {
          removeAndInvokeRemoveHook(ch);
          invokeDestroyHook(ch);
        } else { // Text node
          removeNode(ch.elm);
        }
      }
    }
  }

  function removeAndInvokeRemoveHook (vnode, rm) {
    if (isDef(rm) || isDef(vnode.data)) {
      var i;
      var listeners = cbs.remove.length + 1;
      if (isDef(rm)) {
        // we have a recursively passed down rm callback
        // increase the listeners count
        rm.listeners += listeners;
      } else {
        // directly removing
        rm = createRmCb(vnode.elm, listeners);
      }
      // recursively invoke hooks on child component root node
      if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {
        removeAndInvokeRemoveHook(i, rm);
      }
      for (i = 0; i < cbs.remove.length; ++i) {
        cbs.remove[i](vnode, rm);
      }
      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {
        i(vnode, rm);
      } else {
        rm();
      }
    } else {
      removeNode(vnode.elm);
    }
  }

  function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
    var oldStartIdx = 0;
    var newStartIdx = 0;
    var oldEndIdx = oldCh.length - 1;
    var oldStartVnode = oldCh[0];
    var oldEndVnode = oldCh[oldEndIdx];
    var newEndIdx = newCh.length - 1;
    var newStartVnode = newCh[0];
    var newEndVnode = newCh[newEndIdx];
    var oldKeyToIdx, idxInOld, vnodeToMove, refElm;

    // removeOnly is a special flag used only by <transition-group>
    // to ensure removed elements stay in correct relative positions
    // during leaving transitions
    var canMove = !removeOnly;

    if (true) {
      checkDuplicateKeys(newCh);
    }

    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
      if (isUndef(oldStartVnode)) {
        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left
      } else if (isUndef(oldEndVnode)) {
        oldEndVnode = oldCh[--oldEndIdx];
      } else if (sameVnode(oldStartVnode, newStartVnode)) {
        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);
        oldStartVnode = oldCh[++oldStartIdx];
        newStartVnode = newCh[++newStartIdx];
      } else if (sameVnode(oldEndVnode, newEndVnode)) {
        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);
        oldEndVnode = oldCh[--oldEndIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right
        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);
        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));
        oldStartVnode = oldCh[++oldStartIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left
        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);
        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
        oldEndVnode = oldCh[--oldEndIdx];
        newStartVnode = newCh[++newStartIdx];
      } else {
        if (isUndef(oldKeyToIdx)) { oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx); }
        idxInOld = isDef(newStartVnode.key)
          ? oldKeyToIdx[newStartVnode.key]
          : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);
        if (isUndef(idxInOld)) { // New element
          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);
        } else {
          vnodeToMove = oldCh[idxInOld];
          if (sameVnode(vnodeToMove, newStartVnode)) {
            patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue);
            oldCh[idxInOld] = undefined;
            canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);
          } else {
            // same key but different element. treat as new element
            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);
          }
        }
        newStartVnode = newCh[++newStartIdx];
      }
    }
    if (oldStartIdx > oldEndIdx) {
      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;
      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
    } else if (newStartIdx > newEndIdx) {
      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
    }
  }

  function checkDuplicateKeys (children) {
    var seenKeys = {};
    for (var i = 0; i < children.length; i++) {
      var vnode = children[i];
      var key = vnode.key;
      if (isDef(key)) {
        if (seenKeys[key]) {
          warn(
            ("Duplicate keys detected: '" + key + "'. This may cause an update error."),
            vnode.context
          );
        } else {
          seenKeys[key] = true;
        }
      }
    }
  }

  function findIdxInOld (node, oldCh, start, end) {
    for (var i = start; i < end; i++) {
      var c = oldCh[i];
      if (isDef(c) && sameVnode(node, c)) { return i }
    }
  }

  function patchVnode (oldVnode, vnode, insertedVnodeQueue, removeOnly) {
    if (oldVnode === vnode) {
      return
    }

    var elm = vnode.elm = oldVnode.elm;

    if (isTrue(oldVnode.isAsyncPlaceholder)) {
      if (isDef(vnode.asyncFactory.resolved)) {
        hydrate(oldVnode.elm, vnode, insertedVnodeQueue);
      } else {
        vnode.isAsyncPlaceholder = true;
      }
      return
    }

    // reuse element for static trees.
    // note we only do this if the vnode is cloned -
    // if the new node is not cloned it means the render functions have been
    // reset by the hot-reload-api and we need to do a proper re-render.
    if (isTrue(vnode.isStatic) &&
      isTrue(oldVnode.isStatic) &&
      vnode.key === oldVnode.key &&
      (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))
    ) {
      vnode.componentInstance = oldVnode.componentInstance;
      return
    }

    var i;
    var data = vnode.data;
    if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {
      i(oldVnode, vnode);
    }

    var oldCh = oldVnode.children;
    var ch = vnode.children;
    if (isDef(data) && isPatchable(vnode)) {
      for (i = 0; i < cbs.update.length; ++i) { cbs.update[i](oldVnode, vnode); }
      if (isDef(i = data.hook) && isDef(i = i.update)) { i(oldVnode, vnode); }
    }
    if (isUndef(vnode.text)) {
      if (isDef(oldCh) && isDef(ch)) {
        if (oldCh !== ch) { updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly); }
      } else if (isDef(ch)) {
        if (isDef(oldVnode.text)) { nodeOps.setTextContent(elm, ''); }
        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
      } else if (isDef(oldCh)) {
        removeVnodes(elm, oldCh, 0, oldCh.length - 1);
      } else if (isDef(oldVnode.text)) {
        nodeOps.setTextContent(elm, '');
      }
    } else if (oldVnode.text !== vnode.text) {
      nodeOps.setTextContent(elm, vnode.text);
    }
    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.postpatch)) { i(oldVnode, vnode); }
    }
  }

  function invokeInsertHook (vnode, queue, initial) {
    // delay insert hooks for component root nodes, invoke them after the
    // element is really inserted
    if (isTrue(initial) && isDef(vnode.parent)) {
      vnode.parent.data.pendingInsert = queue;
    } else {
      for (var i = 0; i < queue.length; ++i) {
        queue[i].data.hook.insert(queue[i]);
      }
    }
  }

  var hydrationBailed = false;
  // list of modules that can skip create hook during hydration because they
  // are already rendered on the client or has no need for initialization
  // Note: style is excluded because it relies on initial clone for future
  // deep updates (#7063).
  var isRenderedModule = makeMap('attrs,class,staticClass,staticStyle,key');

  // Note: this is a browser-only function so we can assume elms are DOM nodes.
  function hydrate (elm, vnode, insertedVnodeQueue, inVPre) {
    var i;
    var tag = vnode.tag;
    var data = vnode.data;
    var children = vnode.children;
    inVPre = inVPre || (data && data.pre);
    vnode.elm = elm;

    if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {
      vnode.isAsyncPlaceholder = true;
      return true
    }
    // assert node match
    if (true) {
      if (!assertNodeMatch(elm, vnode, inVPre)) {
        return false
      }
    }
    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.init)) { i(vnode, true /* hydrating */); }
      if (isDef(i = vnode.componentInstance)) {
        // child component. it should have hydrated its own tree.
        initComponent(vnode, insertedVnodeQueue);
        return true
      }
    }
    if (isDef(tag)) {
      if (isDef(children)) {
        // empty element, allow client to pick up and populate children
        if (!elm.hasChildNodes()) {
          createChildren(vnode, children, insertedVnodeQueue);
        } else {
          // v-html and domProps: innerHTML
          if (isDef(i = data) && isDef(i = i.domProps) && isDef(i = i.innerHTML)) {
            if (i !== elm.innerHTML) {
              /* istanbul ignore if */
              if ("development" !== 'production' &&
                typeof console !== 'undefined' &&
                !hydrationBailed
              ) {
                hydrationBailed = true;
                console.warn('Parent: ', elm);
                console.warn('server innerHTML: ', i);
                console.warn('client innerHTML: ', elm.innerHTML);
              }
              return false
            }
          } else {
            // iterate and compare children lists
            var childrenMatch = true;
            var childNode = elm.firstChild;
            for (var i$1 = 0; i$1 < children.length; i$1++) {
              if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue, inVPre)) {
                childrenMatch = false;
                break
              }
              childNode = childNode.nextSibling;
            }
            // if childNode is not null, it means the actual childNodes list is
            // longer than the virtual children list.
            if (!childrenMatch || childNode) {
              /* istanbul ignore if */
              if ("development" !== 'production' &&
                typeof console !== 'undefined' &&
                !hydrationBailed
              ) {
                hydrationBailed = true;
                console.warn('Parent: ', elm);
                console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);
              }
              return false
            }
          }
        }
      }
      if (isDef(data)) {
        var fullInvoke = false;
        for (var key in data) {
          if (!isRenderedModule(key)) {
            fullInvoke = true;
            invokeCreateHooks(vnode, insertedVnodeQueue);
            break
          }
        }
        if (!fullInvoke && data['class']) {
          // ensure collecting deps for deep class bindings for future updates
          traverse(data['class']);
        }
      }
    } else if (elm.data !== vnode.text) {
      elm.data = vnode.text;
    }
    return true
  }

  function assertNodeMatch (node, vnode, inVPre) {
    if (isDef(vnode.tag)) {
      return vnode.tag.indexOf('vue-component') === 0 || (
        !isUnknownElement$$1(vnode, inVPre) &&
        vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase())
      )
    } else {
      return node.nodeType === (vnode.isComment ? 8 : 3)
    }
  }

  return function patch (oldVnode, vnode, hydrating, removeOnly, parentElm, refElm) {
    if (isUndef(vnode)) {
      if (isDef(oldVnode)) { invokeDestroyHook(oldVnode); }
      return
    }

    var isInitialPatch = false;
    var insertedVnodeQueue = [];

    if (isUndef(oldVnode)) {
      // empty mount (likely as component), create new root element
      isInitialPatch = true;
      createElm(vnode, insertedVnodeQueue, parentElm, refElm);
    } else {
      var isRealElement = isDef(oldVnode.nodeType);
      if (!isRealElement && sameVnode(oldVnode, vnode)) {
        // patch existing root node
        patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly);
      } else {
        if (isRealElement) {
          // mounting to a real element
          // check if this is server-rendered content and if we can perform
          // a successful hydration.
          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {
            oldVnode.removeAttribute(SSR_ATTR);
            hydrating = true;
          }
          if (isTrue(hydrating)) {
            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {
              invokeInsertHook(vnode, insertedVnodeQueue, true);
              return oldVnode
            } else if (true) {
              warn(
                'The client-side rendered virtual DOM tree is not matching ' +
                'server-rendered content. This is likely caused by incorrect ' +
                'HTML markup, for example nesting block-level elements inside ' +
                '<p>, or missing <tbody>. Bailing hydration and performing ' +
                'full client-side render.'
              );
            }
          }
          // either not server-rendered, or hydration failed.
          // create an empty node and replace it
          oldVnode = emptyNodeAt(oldVnode);
        }

        // replacing existing element
        var oldElm = oldVnode.elm;
        var parentElm$1 = nodeOps.parentNode(oldElm);

        // create new node
        createElm(
          vnode,
          insertedVnodeQueue,
          // extremely rare edge case: do not insert if old element is in a
          // leaving transition. Only happens when combining transition +
          // keep-alive + HOCs. (#4590)
          oldElm._leaveCb ? null : parentElm$1,
          nodeOps.nextSibling(oldElm)
        );

        // update parent placeholder node element, recursively
        if (isDef(vnode.parent)) {
          var ancestor = vnode.parent;
          var patchable = isPatchable(vnode);
          while (ancestor) {
            for (var i = 0; i < cbs.destroy.length; ++i) {
              cbs.destroy[i](ancestor);
            }
            ancestor.elm = vnode.elm;
            if (patchable) {
              for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
                cbs.create[i$1](emptyNode, ancestor);
              }
              // #6513
              // invoke insert hooks that may have been merged by create hooks.
              // e.g. for directives that uses the "inserted" hook.
              var insert = ancestor.data.hook.insert;
              if (insert.merged) {
                // start at index 1 to avoid re-invoking component mounted hook
                for (var i$2 = 1; i$2 < insert.fns.length; i$2++) {
                  insert.fns[i$2]();
                }
              }
            } else {
              registerRef(ancestor);
            }
            ancestor = ancestor.parent;
          }
        }

        // destroy old node
        if (isDef(parentElm$1)) {
          removeVnodes(parentElm$1, [oldVnode], 0, 0);
        } else if (isDef(oldVnode.tag)) {
          invokeDestroyHook(oldVnode);
        }
      }
    }

    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);
    return vnode.elm
  }
}

/*  */

var directives = {
  create: updateDirectives,
  update: updateDirectives,
  destroy: function unbindDirectives (vnode) {
    updateDirectives(vnode, emptyNode);
  }
}

function updateDirectives (oldVnode, vnode) {
  if (oldVnode.data.directives || vnode.data.directives) {
    _update(oldVnode, vnode);
  }
}

function _update (oldVnode, vnode) {
  var isCreate = oldVnode === emptyNode;
  var isDestroy = vnode === emptyNode;
  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);
  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);

  var dirsWithInsert = [];
  var dirsWithPostpatch = [];

  var key, oldDir, dir;
  for (key in newDirs) {
    oldDir = oldDirs[key];
    dir = newDirs[key];
    if (!oldDir) {
      // new directive, bind
      callHook$1(dir, 'bind', vnode, oldVnode);
      if (dir.def && dir.def.inserted) {
        dirsWithInsert.push(dir);
      }
    } else {
      // existing directive, update
      dir.oldValue = oldDir.value;
      callHook$1(dir, 'update', vnode, oldVnode);
      if (dir.def && dir.def.componentUpdated) {
        dirsWithPostpatch.push(dir);
      }
    }
  }

  if (dirsWithInsert.length) {
    var callInsert = function () {
      for (var i = 0; i < dirsWithInsert.length; i++) {
        callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);
      }
    };
    if (isCreate) {
      mergeVNodeHook(vnode, 'insert', callInsert);
    } else {
      callInsert();
    }
  }

  if (dirsWithPostpatch.length) {
    mergeVNodeHook(vnode, 'postpatch', function () {
      for (var i = 0; i < dirsWithPostpatch.length; i++) {
        callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);
      }
    });
  }

  if (!isCreate) {
    for (key in oldDirs) {
      if (!newDirs[key]) {
        // no longer present, unbind
        callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);
      }
    }
  }
}

var emptyModifiers = Object.create(null);

function normalizeDirectives$1 (
  dirs,
  vm
) {
  var res = Object.create(null);
  if (!dirs) {
    // $flow-disable-line
    return res
  }
  var i, dir;
  for (i = 0; i < dirs.length; i++) {
    dir = dirs[i];
    if (!dir.modifiers) {
      // $flow-disable-line
      dir.modifiers = emptyModifiers;
    }
    res[getRawDirName(dir)] = dir;
    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);
  }
  // $flow-disable-line
  return res
}

function getRawDirName (dir) {
  return dir.rawName || ((dir.name) + "." + (Object.keys(dir.modifiers || {}).join('.')))
}

function callHook$1 (dir, hook, vnode, oldVnode, isDestroy) {
  var fn = dir.def && dir.def[hook];
  if (fn) {
    try {
      fn(vnode.elm, dir, vnode, oldVnode, isDestroy);
    } catch (e) {
      handleError(e, vnode.context, ("directive " + (dir.name) + " " + hook + " hook"));
    }
  }
}

var baseModules = [
  ref,
  directives
]

/*  */

function updateAttrs (oldVnode, vnode) {
  var opts = vnode.componentOptions;
  if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {
    return
  }
  if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {
    return
  }
  var key, cur, old;
  var elm = vnode.elm;
  var oldAttrs = oldVnode.data.attrs || {};
  var attrs = vnode.data.attrs || {};
  // clone observed objects, as the user probably wants to mutate it
  if (isDef(attrs.__ob__)) {
    attrs = vnode.data.attrs = extend({}, attrs);
  }

  for (key in attrs) {
    cur = attrs[key];
    old = oldAttrs[key];
    if (old !== cur) {
      setAttr(elm, key, cur);
    }
  }
  // #4391: in IE9, setting type can reset value for input[type=radio]
  // #6666: IE/Edge forces progress value down to 1 before setting a max
  /* istanbul ignore if */
  if ((isIE || isEdge) && attrs.value !== oldAttrs.value) {
    setAttr(elm, 'value', attrs.value);
  }
  for (key in oldAttrs) {
    if (isUndef(attrs[key])) {
      if (isXlink(key)) {
        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));
      } else if (!isEnumeratedAttr(key)) {
        elm.removeAttribute(key);
      }
    }
  }
}

function setAttr (el, key, value) {
  if (el.tagName.indexOf('-') > -1) {
    baseSetAttr(el, key, value);
  } else if (isBooleanAttr(key)) {
    // set attribute for blank value
    // e.g. <option disabled>Select one</option>
    if (isFalsyAttrValue(value)) {
      el.removeAttribute(key);
    } else {
      // technically allowfullscreen is a boolean attribute for <iframe>,
      // but Flash expects a value of "true" when used on <embed> tag
      value = key === 'allowfullscreen' && el.tagName === 'EMBED'
        ? 'true'
        : key;
      el.setAttribute(key, value);
    }
  } else if (isEnumeratedAttr(key)) {
    el.setAttribute(key, isFalsyAttrValue(value) || value === 'false' ? 'false' : 'true');
  } else if (isXlink(key)) {
    if (isFalsyAttrValue(value)) {
      el.removeAttributeNS(xlinkNS, getXlinkProp(key));
    } else {
      el.setAttributeNS(xlinkNS, key, value);
    }
  } else {
    baseSetAttr(el, key, value);
  }
}

function baseSetAttr (el, key, value) {
  if (isFalsyAttrValue(value)) {
    el.removeAttribute(key);
  } else {
    // #7138: IE10 & 11 fires input event when setting placeholder on
    // <textarea>... block the first input event and remove the blocker
    // immediately.
    /* istanbul ignore if */
    if (
      isIE && !isIE9 &&
      el.tagName === 'TEXTAREA' &&
      key === 'placeholder' && !el.__ieph
    ) {
      var blocker = function (e) {
        e.stopImmediatePropagation();
        el.removeEventListener('input', blocker);
      };
      el.addEventListener('input', blocker);
      // $flow-disable-line
      el.__ieph = true; /* IE placeholder patched */
    }
    el.setAttribute(key, value);
  }
}

var attrs = {
  create: updateAttrs,
  update: updateAttrs
}

/*  */

function updateClass (oldVnode, vnode) {
  var el = vnode.elm;
  var data = vnode.data;
  var oldData = oldVnode.data;
  if (
    isUndef(data.staticClass) &&
    isUndef(data.class) && (
      isUndef(oldData) || (
        isUndef(oldData.staticClass) &&
        isUndef(oldData.class)
      )
    )
  ) {
    return
  }

  var cls = genClassForVnode(vnode);

  // handle transition classes
  var transitionClass = el._transitionClasses;
  if (isDef(transitionClass)) {
    cls = concat(cls, stringifyClass(transitionClass));
  }

  // set the class
  if (cls !== el._prevClass) {
    el.setAttribute('class', cls);
    el._prevClass = cls;
  }
}

var klass = {
  create: updateClass,
  update: updateClass
}

/*  */

var validDivisionCharRE = /[\w).+\-_$\]]/;

function parseFilters (exp) {
  var inSingle = false;
  var inDouble = false;
  var inTemplateString = false;
  var inRegex = false;
  var curly = 0;
  var square = 0;
  var paren = 0;
  var lastFilterIndex = 0;
  var c, prev, i, expression, filters;

  for (i = 0; i < exp.length; i++) {
    prev = c;
    c = exp.charCodeAt(i);
    if (inSingle) {
      if (c === 0x27 && prev !== 0x5C) { inSingle = false; }
    } else if (inDouble) {
      if (c === 0x22 && prev !== 0x5C) { inDouble = false; }
    } else if (inTemplateString) {
      if (c === 0x60 && prev !== 0x5C) { inTemplateString = false; }
    } else if (inRegex) {
      if (c === 0x2f && prev !== 0x5C) { inRegex = false; }
    } else if (
      c === 0x7C && // pipe
      exp.charCodeAt(i + 1) !== 0x7C &&
      exp.charCodeAt(i - 1) !== 0x7C &&
      !curly && !square && !paren
    ) {
      if (expression === undefined) {
        // first filter, end of expression
        lastFilterIndex = i + 1;
        expression = exp.slice(0, i).trim();
      } else {
        pushFilter();
      }
    } else {
      switch (c) {
        case 0x22: inDouble = true; break         // "
        case 0x27: inSingle = true; break         // '
        case 0x60: inTemplateString = true; break // `
        case 0x28: paren++; break                 // (
        case 0x29: paren--; break                 // )
        case 0x5B: square++; break                // [
        case 0x5D: square--; break                // ]
        case 0x7B: curly++; break                 // {
        case 0x7D: curly--; break                 // }
      }
      if (c === 0x2f) { // /
        var j = i - 1;
        var p = (void 0);
        // find first non-whitespace prev char
        for (; j >= 0; j--) {
          p = exp.charAt(j);
          if (p !== ' ') { break }
        }
        if (!p || !validDivisionCharRE.test(p)) {
          inRegex = true;
        }
      }
    }
  }

  if (expression === undefined) {
    expression = exp.slice(0, i).trim();
  } else if (lastFilterIndex !== 0) {
    pushFilter();
  }

  function pushFilter () {
    (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());
    lastFilterIndex = i + 1;
  }

  if (filters) {
    for (i = 0; i < filters.length; i++) {
      expression = wrapFilter(expression, filters[i]);
    }
  }

  return expression
}

function wrapFilter (exp, filter) {
  var i = filter.indexOf('(');
  if (i < 0) {
    // _f: resolveFilter
    return ("_f(\"" + filter + "\")(" + exp + ")")
  } else {
    var name = filter.slice(0, i);
    var args = filter.slice(i + 1);
    return ("_f(\"" + name + "\")(" + exp + (args !== ')' ? ',' + args : args))
  }
}

/*  */

function baseWarn (msg) {
  console.error(("[Vue compiler]: " + msg));
}

function pluckModuleFunction (
  modules,
  key
) {
  return modules
    ? modules.map(function (m) { return m[key]; }).filter(function (_) { return _; })
    : []
}

function addProp (el, name, value) {
  (el.props || (el.props = [])).push({ name: name, value: value });
  el.plain = false;
}

function addAttr (el, name, value) {
  (el.attrs || (el.attrs = [])).push({ name: name, value: value });
  el.plain = false;
}

// add a raw attr (use this in preTransforms)
function addRawAttr (el, name, value) {
  el.attrsMap[name] = value;
  el.attrsList.push({ name: name, value: value });
}

function addDirective (
  el,
  name,
  rawName,
  value,
  arg,
  modifiers
) {
  (el.directives || (el.directives = [])).push({ name: name, rawName: rawName, value: value, arg: arg, modifiers: modifiers });
  el.plain = false;
}

function addHandler (
  el,
  name,
  value,
  modifiers,
  important,
  warn
) {
  modifiers = modifiers || emptyObject;
  // warn prevent and passive modifier
  /* istanbul ignore if */
  if (
    "development" !== 'production' && warn &&
    modifiers.prevent && modifiers.passive
  ) {
    warn(
      'passive and prevent can\'t be used together. ' +
      'Passive handler can\'t prevent default event.'
    );
  }

  // check capture modifier
  if (modifiers.capture) {
    delete modifiers.capture;
    name = '!' + name; // mark the event as captured
  }
  if (modifiers.once) {
    delete modifiers.once;
    name = '~' + name; // mark the event as once
  }
  /* istanbul ignore if */
  if (modifiers.passive) {
    delete modifiers.passive;
    name = '&' + name; // mark the event as passive
  }

  // normalize click.right and click.middle since they don't actually fire
  // this is technically browser-specific, but at least for now browsers are
  // the only target envs that have right/middle clicks.
  if (name === 'click') {
    if (modifiers.right) {
      name = 'contextmenu';
      delete modifiers.right;
    } else if (modifiers.middle) {
      name = 'mouseup';
    }
  }

  var events;
  if (modifiers.native) {
    delete modifiers.native;
    events = el.nativeEvents || (el.nativeEvents = {});
  } else {
    events = el.events || (el.events = {});
  }

  var newHandler = {
    value: value.trim()
  };
  if (modifiers !== emptyObject) {
    newHandler.modifiers = modifiers;
  }

  var handlers = events[name];
  /* istanbul ignore if */
  if (Array.isArray(handlers)) {
    important ? handlers.unshift(newHandler) : handlers.push(newHandler);
  } else if (handlers) {
    events[name] = important ? [newHandler, handlers] : [handlers, newHandler];
  } else {
    events[name] = newHandler;
  }

  el.plain = false;
}

function getBindingAttr (
  el,
  name,
  getStatic
) {
  var dynamicValue =
    getAndRemoveAttr(el, ':' + name) ||
    getAndRemoveAttr(el, 'v-bind:' + name);
  if (dynamicValue != null) {
    return parseFilters(dynamicValue)
  } else if (getStatic !== false) {
    var staticValue = getAndRemoveAttr(el, name);
    if (staticValue != null) {
      return JSON.stringify(staticValue)
    }
  }
}

// note: this only removes the attr from the Array (attrsList) so that it
// doesn't get processed by processAttrs.
// By default it does NOT remove it from the map (attrsMap) because the map is
// needed during codegen.
function getAndRemoveAttr (
  el,
  name,
  removeFromMap
) {
  var val;
  if ((val = el.attrsMap[name]) != null) {
    var list = el.attrsList;
    for (var i = 0, l = list.length; i < l; i++) {
      if (list[i].name === name) {
        list.splice(i, 1);
        break
      }
    }
  }
  if (removeFromMap) {
    delete el.attrsMap[name];
  }
  return val
}

/*  */

/**
 * Cross-platform code generation for component v-model
 */
function genComponentModel (
  el,
  value,
  modifiers
) {
  var ref = modifiers || {};
  var number = ref.number;
  var trim = ref.trim;

  var baseValueExpression = '$$v';
  var valueExpression = baseValueExpression;
  if (trim) {
    valueExpression =
      "(typeof " + baseValueExpression + " === 'string'" +
      "? " + baseValueExpression + ".trim()" +
      ": " + baseValueExpression + ")";
  }
  if (number) {
    valueExpression = "_n(" + valueExpression + ")";
  }
  var assignment = genAssignmentCode(value, valueExpression);

  el.model = {
    value: ("(" + value + ")"),
    expression: ("\"" + value + "\""),
    callback: ("function (" + baseValueExpression + ") {" + assignment + "}")
  };
}

/**
 * Cross-platform codegen helper for generating v-model value assignment code.
 */
function genAssignmentCode (
  value,
  assignment
) {
  var res = parseModel(value);
  if (res.key === null) {
    return (value + "=" + assignment)
  } else {
    return ("$set(" + (res.exp) + ", " + (res.key) + ", " + assignment + ")")
  }
}

/**
 * Parse a v-model expression into a base path and a final key segment.
 * Handles both dot-path and possible square brackets.
 *
 * Possible cases:
 *
 * - test
 * - test[key]
 * - test[test1[key]]
 * - test["a"][key]
 * - xxx.test[a[a].test1[key]]
 * - test.xxx.a["asa"][test1[key]]
 *
 */

var len;
var str;
var chr;
var index$1;
var expressionPos;
var expressionEndPos;



function parseModel (val) {
  // Fix https://github.com/vuejs/vue/pull/7730
  // allow v-model="obj.val " (trailing whitespace)
  val = val.trim();
  len = val.length;

  if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {
    index$1 = val.lastIndexOf('.');
    if (index$1 > -1) {
      return {
        exp: val.slice(0, index$1),
        key: '"' + val.slice(index$1 + 1) + '"'
      }
    } else {
      return {
        exp: val,
        key: null
      }
    }
  }

  str = val;
  index$1 = expressionPos = expressionEndPos = 0;

  while (!eof()) {
    chr = next();
    /* istanbul ignore if */
    if (isStringStart(chr)) {
      parseString(chr);
    } else if (chr === 0x5B) {
      parseBracket(chr);
    }
  }

  return {
    exp: val.slice(0, expressionPos),
    key: val.slice(expressionPos + 1, expressionEndPos)
  }
}

function next () {
  return str.charCodeAt(++index$1)
}

function eof () {
  return index$1 >= len
}

function isStringStart (chr) {
  return chr === 0x22 || chr === 0x27
}

function parseBracket (chr) {
  var inBracket = 1;
  expressionPos = index$1;
  while (!eof()) {
    chr = next();
    if (isStringStart(chr)) {
      parseString(chr);
      continue
    }
    if (chr === 0x5B) { inBracket++; }
    if (chr === 0x5D) { inBracket--; }
    if (inBracket === 0) {
      expressionEndPos = index$1;
      break
    }
  }
}

function parseString (chr) {
  var stringQuote = chr;
  while (!eof()) {
    chr = next();
    if (chr === stringQuote) {
      break
    }
  }
}

/*  */

var warn$1;

// in some cases, the event used has to be determined at runtime
// so we used some reserved tokens during compile.
var RANGE_TOKEN = '__r';
var CHECKBOX_RADIO_TOKEN = '__c';

function model (
  el,
  dir,
  _warn
) {
  warn$1 = _warn;
  var value = dir.value;
  var modifiers = dir.modifiers;
  var tag = el.tag;
  var type = el.attrsMap.type;

  if (true) {
    // inputs with type="file" are read only and setting the input's
    // value will throw an error.
    if (tag === 'input' && type === 'file') {
      warn$1(
        "<" + (el.tag) + " v-model=\"" + value + "\" type=\"file\">:\n" +
        "File inputs are read only. Use a v-on:change listener instead."
      );
    }
  }

  if (el.component) {
    genComponentModel(el, value, modifiers);
    // component v-model doesn't need extra runtime
    return false
  } else if (tag === 'select') {
    genSelect(el, value, modifiers);
  } else if (tag === 'input' && type === 'checkbox') {
    genCheckboxModel(el, value, modifiers);
  } else if (tag === 'input' && type === 'radio') {
    genRadioModel(el, value, modifiers);
  } else if (tag === 'input' || tag === 'textarea') {
    genDefaultModel(el, value, modifiers);
  } else if (!config.isReservedTag(tag)) {
    genComponentModel(el, value, modifiers);
    // component v-model doesn't need extra runtime
    return false
  } else if (true) {
    warn$1(
      "<" + (el.tag) + " v-model=\"" + value + "\">: " +
      "v-model is not supported on this element type. " +
      'If you are working with contenteditable, it\'s recommended to ' +
      'wrap a library dedicated for that purpose inside a custom component.'
    );
  }

  // ensure runtime directive metadata
  return true
}

function genCheckboxModel (
  el,
  value,
  modifiers
) {
  var number = modifiers && modifiers.number;
  var valueBinding = getBindingAttr(el, 'value') || 'null';
  var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';
  var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';
  addProp(el, 'checked',
    "Array.isArray(" + value + ")" +
    "?_i(" + value + "," + valueBinding + ")>-1" + (
      trueValueBinding === 'true'
        ? (":(" + value + ")")
        : (":_q(" + value + "," + trueValueBinding + ")")
    )
  );
  addHandler(el, 'change',
    "var $$a=" + value + "," +
        '$$el=$event.target,' +
        "$$c=$$el.checked?(" + trueValueBinding + "):(" + falseValueBinding + ");" +
    'if(Array.isArray($$a)){' +
      "var $$v=" + (number ? '_n(' + valueBinding + ')' : valueBinding) + "," +
          '$$i=_i($$a,$$v);' +
      "if($$el.checked){$$i<0&&(" + (genAssignmentCode(value, '$$a.concat([$$v])')) + ")}" +
      "else{$$i>-1&&(" + (genAssignmentCode(value, '$$a.slice(0,$$i).concat($$a.slice($$i+1))')) + ")}" +
    "}else{" + (genAssignmentCode(value, '$$c')) + "}",
    null, true
  );
}

function genRadioModel (
  el,
  value,
  modifiers
) {
  var number = modifiers && modifiers.number;
  var valueBinding = getBindingAttr(el, 'value') || 'null';
  valueBinding = number ? ("_n(" + valueBinding + ")") : valueBinding;
  addProp(el, 'checked', ("_q(" + value + "," + valueBinding + ")"));
  addHandler(el, 'change', genAssignmentCode(value, valueBinding), null, true);
}

function genSelect (
  el,
  value,
  modifiers
) {
  var number = modifiers && modifiers.number;
  var selectedVal = "Array.prototype.filter" +
    ".call($event.target.options,function(o){return o.selected})" +
    ".map(function(o){var val = \"_value\" in o ? o._value : o.value;" +
    "return " + (number ? '_n(val)' : 'val') + "})";

  var assignment = '$event.target.multiple ? $$selectedVal : $$selectedVal[0]';
  var code = "var $$selectedVal = " + selectedVal + ";";
  code = code + " " + (genAssignmentCode(value, assignment));
  addHandler(el, 'change', code, null, true);
}

function genDefaultModel (
  el,
  value,
  modifiers
) {
  var type = el.attrsMap.type;

  // warn if v-bind:value conflicts with v-model
  // except for inputs with v-bind:type
  if (true) {
    var value$1 = el.attrsMap['v-bind:value'] || el.attrsMap[':value'];
    var typeBinding = el.attrsMap['v-bind:type'] || el.attrsMap[':type'];
    if (value$1 && !typeBinding) {
      var binding = el.attrsMap['v-bind:value'] ? 'v-bind:value' : ':value';
      warn$1(
        binding + "=\"" + value$1 + "\" conflicts with v-model on the same element " +
        'because the latter already expands to a value binding internally'
      );
    }
  }

  var ref = modifiers || {};
  var lazy = ref.lazy;
  var number = ref.number;
  var trim = ref.trim;
  var needCompositionGuard = !lazy && type !== 'range';
  var event = lazy
    ? 'change'
    : type === 'range'
      ? RANGE_TOKEN
      : 'input';

  var valueExpression = '$event.target.value';
  if (trim) {
    valueExpression = "$event.target.value.trim()";
  }
  if (number) {
    valueExpression = "_n(" + valueExpression + ")";
  }

  var code = genAssignmentCode(value, valueExpression);
  if (needCompositionGuard) {
    code = "if($event.target.composing)return;" + code;
  }

  addProp(el, 'value', ("(" + value + ")"));
  addHandler(el, event, code, null, true);
  if (trim || number) {
    addHandler(el, 'blur', '$forceUpdate()');
  }
}

/*  */

// normalize v-model event tokens that can only be determined at runtime.
// it's important to place the event as the first in the array because
// the whole point is ensuring the v-model callback gets called before
// user-attached handlers.
function normalizeEvents (on) {
  /* istanbul ignore if */
  if (isDef(on[RANGE_TOKEN])) {
    // IE input[type=range] only supports `change` event
    var event = isIE ? 'change' : 'input';
    on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);
    delete on[RANGE_TOKEN];
  }
  // This was originally intended to fix #4521 but no longer necessary
  // after 2.5. Keeping it for backwards compat with generated code from < 2.4
  /* istanbul ignore if */
  if (isDef(on[CHECKBOX_RADIO_TOKEN])) {
    on.change = [].concat(on[CHECKBOX_RADIO_TOKEN], on.change || []);
    delete on[CHECKBOX_RADIO_TOKEN];
  }
}

var target$1;

function createOnceHandler (handler, event, capture) {
  var _target = target$1; // save current target element in closure
  return function onceHandler () {
    var res = handler.apply(null, arguments);
    if (res !== null) {
      remove$2(event, onceHandler, capture, _target);
    }
  }
}

function add$1 (
  event,
  handler,
  once$$1,
  capture,
  passive
) {
  handler = withMacroTask(handler);
  if (once$$1) { handler = createOnceHandler(handler, event, capture); }
  target$1.addEventListener(
    event,
    handler,
    supportsPassive
      ? { capture: capture, passive: passive }
      : capture
  );
}

function remove$2 (
  event,
  handler,
  capture,
  _target
) {
  (_target || target$1).removeEventListener(
    event,
    handler._withTask || handler,
    capture
  );
}

function updateDOMListeners (oldVnode, vnode) {
  if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {
    return
  }
  var on = vnode.data.on || {};
  var oldOn = oldVnode.data.on || {};
  target$1 = vnode.elm;
  normalizeEvents(on);
  updateListeners(on, oldOn, add$1, remove$2, vnode.context);
  target$1 = undefined;
}

var events = {
  create: updateDOMListeners,
  update: updateDOMListeners
}

/*  */

function updateDOMProps (oldVnode, vnode) {
  if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {
    return
  }
  var key, cur;
  var elm = vnode.elm;
  var oldProps = oldVnode.data.domProps || {};
  var props = vnode.data.domProps || {};
  // clone observed objects, as the user probably wants to mutate it
  if (isDef(props.__ob__)) {
    props = vnode.data.domProps = extend({}, props);
  }

  for (key in oldProps) {
    if (isUndef(props[key])) {
      elm[key] = '';
    }
  }
  for (key in props) {
    cur = props[key];
    // ignore children if the node has textContent or innerHTML,
    // as these will throw away existing DOM nodes and cause removal errors
    // on subsequent patches (#3360)
    if (key === 'textContent' || key === 'innerHTML') {
      if (vnode.children) { vnode.children.length = 0; }
      if (cur === oldProps[key]) { continue }
      // #6601 work around Chrome version <= 55 bug where single textNode
      // replaced by innerHTML/textContent retains its parentNode property
      if (elm.childNodes.length === 1) {
        elm.removeChild(elm.childNodes[0]);
      }
    }

    if (key === 'value') {
      // store value as _value as well since
      // non-string values will be stringified
      elm._value = cur;
      // avoid resetting cursor position when value is the same
      var strCur = isUndef(cur) ? '' : String(cur);
      if (shouldUpdateValue(elm, strCur)) {
        elm.value = strCur;
      }
    } else {
      elm[key] = cur;
    }
  }
}

// check platforms/web/util/attrs.js acceptValue


function shouldUpdateValue (elm, checkVal) {
  return (!elm.composing && (
    elm.tagName === 'OPTION' ||
    isNotInFocusAndDirty(elm, checkVal) ||
    isDirtyWithModifiers(elm, checkVal)
  ))
}

function isNotInFocusAndDirty (elm, checkVal) {
  // return true when textbox (.number and .trim) loses focus and its value is
  // not equal to the updated value
  var notInFocus = true;
  // #6157
  // work around IE bug when accessing document.activeElement in an iframe
  try { notInFocus = document.activeElement !== elm; } catch (e) {}
  return notInFocus && elm.value !== checkVal
}

function isDirtyWithModifiers (elm, newVal) {
  var value = elm.value;
  var modifiers = elm._vModifiers; // injected by v-model runtime
  if (isDef(modifiers)) {
    if (modifiers.lazy) {
      // inputs with lazy should only be updated when not in focus
      return false
    }
    if (modifiers.number) {
      return toNumber(value) !== toNumber(newVal)
    }
    if (modifiers.trim) {
      return value.trim() !== newVal.trim()
    }
  }
  return value !== newVal
}

var domProps = {
  create: updateDOMProps,
  update: updateDOMProps
}

/*  */

var parseStyleText = cached(function (cssText) {
  var res = {};
  var listDelimiter = /;(?![^(]*\))/g;
  var propertyDelimiter = /:(.+)/;
  cssText.split(listDelimiter).forEach(function (item) {
    if (item) {
      var tmp = item.split(propertyDelimiter);
      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return res
});

// merge static and dynamic style data on the same vnode
function normalizeStyleData (data) {
  var style = normalizeStyleBinding(data.style);
  // static style is pre-processed into an object during compilation
  // and is always a fresh object, so it's safe to merge into it
  return data.staticStyle
    ? extend(data.staticStyle, style)
    : style
}

// normalize possible array / string values into Object
function normalizeStyleBinding (bindingStyle) {
  if (Array.isArray(bindingStyle)) {
    return toObject(bindingStyle)
  }
  if (typeof bindingStyle === 'string') {
    return parseStyleText(bindingStyle)
  }
  return bindingStyle
}

/**
 * parent component style should be after child's
 * so that parent component's style could override it
 */
function getStyle (vnode, checkChild) {
  var res = {};
  var styleData;

  if (checkChild) {
    var childNode = vnode;
    while (childNode.componentInstance) {
      childNode = childNode.componentInstance._vnode;
      if (
        childNode && childNode.data &&
        (styleData = normalizeStyleData(childNode.data))
      ) {
        extend(res, styleData);
      }
    }
  }

  if ((styleData = normalizeStyleData(vnode.data))) {
    extend(res, styleData);
  }

  var parentNode = vnode;
  while ((parentNode = parentNode.parent)) {
    if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {
      extend(res, styleData);
    }
  }
  return res
}

/*  */

var cssVarRE = /^--/;
var importantRE = /\s*!important$/;
var setProp = function (el, name, val) {
  /* istanbul ignore if */
  if (cssVarRE.test(name)) {
    el.style.setProperty(name, val);
  } else if (importantRE.test(val)) {
    el.style.setProperty(name, val.replace(importantRE, ''), 'important');
  } else {
    var normalizedName = normalize(name);
    if (Array.isArray(val)) {
      // Support values array created by autoprefixer, e.g.
      // {display: ["-webkit-box", "-ms-flexbox", "flex"]}
      // Set them one by one, and the browser will only set those it can recognize
      for (var i = 0, len = val.length; i < len; i++) {
        el.style[normalizedName] = val[i];
      }
    } else {
      el.style[normalizedName] = val;
    }
  }
};

var vendorNames = ['Webkit', 'Moz', 'ms'];

var emptyStyle;
var normalize = cached(function (prop) {
  emptyStyle = emptyStyle || document.createElement('div').style;
  prop = camelize(prop);
  if (prop !== 'filter' && (prop in emptyStyle)) {
    return prop
  }
  var capName = prop.charAt(0).toUpperCase() + prop.slice(1);
  for (var i = 0; i < vendorNames.length; i++) {
    var name = vendorNames[i] + capName;
    if (name in emptyStyle) {
      return name
    }
  }
});

function updateStyle (oldVnode, vnode) {
  var data = vnode.data;
  var oldData = oldVnode.data;

  if (isUndef(data.staticStyle) && isUndef(data.style) &&
    isUndef(oldData.staticStyle) && isUndef(oldData.style)
  ) {
    return
  }

  var cur, name;
  var el = vnode.elm;
  var oldStaticStyle = oldData.staticStyle;
  var oldStyleBinding = oldData.normalizedStyle || oldData.style || {};

  // if static style exists, stylebinding already merged into it when doing normalizeStyleData
  var oldStyle = oldStaticStyle || oldStyleBinding;

  var style = normalizeStyleBinding(vnode.data.style) || {};

  // store normalized style under a different key for next diff
  // make sure to clone it if it's reactive, since the user likely wants
  // to mutate it.
  vnode.data.normalizedStyle = isDef(style.__ob__)
    ? extend({}, style)
    : style;

  var newStyle = getStyle(vnode, true);

  for (name in oldStyle) {
    if (isUndef(newStyle[name])) {
      setProp(el, name, '');
    }
  }
  for (name in newStyle) {
    cur = newStyle[name];
    if (cur !== oldStyle[name]) {
      // ie9 setting to null has no effect, must use empty string
      setProp(el, name, cur == null ? '' : cur);
    }
  }
}

var style = {
  create: updateStyle,
  update: updateStyle
}

/*  */

/**
 * Add class with compatibility for SVG since classList is not supported on
 * SVG elements in IE
 */
function addClass (el, cls) {
  /* istanbul ignore if */
  if (!cls || !(cls = cls.trim())) {
    return
  }

  /* istanbul ignore else */
  if (el.classList) {
    if (cls.indexOf(' ') > -1) {
      cls.split(/\s+/).forEach(function (c) { return el.classList.add(c); });
    } else {
      el.classList.add(cls);
    }
  } else {
    var cur = " " + (el.getAttribute('class') || '') + " ";
    if (cur.indexOf(' ' + cls + ' ') < 0) {
      el.setAttribute('class', (cur + cls).trim());
    }
  }
}

/**
 * Remove class with compatibility for SVG since classList is not supported on
 * SVG elements in IE
 */
function removeClass (el, cls) {
  /* istanbul ignore if */
  if (!cls || !(cls = cls.trim())) {
    return
  }

  /* istanbul ignore else */
  if (el.classList) {
    if (cls.indexOf(' ') > -1) {
      cls.split(/\s+/).forEach(function (c) { return el.classList.remove(c); });
    } else {
      el.classList.remove(cls);
    }
    if (!el.classList.length) {
      el.removeAttribute('class');
    }
  } else {
    var cur = " " + (el.getAttribute('class') || '') + " ";
    var tar = ' ' + cls + ' ';
    while (cur.indexOf(tar) >= 0) {
      cur = cur.replace(tar, ' ');
    }
    cur = cur.trim();
    if (cur) {
      el.setAttribute('class', cur);
    } else {
      el.removeAttribute('class');
    }
  }
}

/*  */

function resolveTransition (def) {
  if (!def) {
    return
  }
  /* istanbul ignore else */
  if (typeof def === 'object') {
    var res = {};
    if (def.css !== false) {
      extend(res, autoCssTransition(def.name || 'v'));
    }
    extend(res, def);
    return res
  } else if (typeof def === 'string') {
    return autoCssTransition(def)
  }
}

var autoCssTransition = cached(function (name) {
  return {
    enterClass: (name + "-enter"),
    enterToClass: (name + "-enter-to"),
    enterActiveClass: (name + "-enter-active"),
    leaveClass: (name + "-leave"),
    leaveToClass: (name + "-leave-to"),
    leaveActiveClass: (name + "-leave-active")
  }
});

var hasTransition = inBrowser && !isIE9;
var TRANSITION = 'transition';
var ANIMATION = 'animation';

// Transition property/event sniffing
var transitionProp = 'transition';
var transitionEndEvent = 'transitionend';
var animationProp = 'animation';
var animationEndEvent = 'animationend';
if (hasTransition) {
  /* istanbul ignore if */
  if (window.ontransitionend === undefined &&
    window.onwebkittransitionend !== undefined
  ) {
    transitionProp = 'WebkitTransition';
    transitionEndEvent = 'webkitTransitionEnd';
  }
  if (window.onanimationend === undefined &&
    window.onwebkitanimationend !== undefined
  ) {
    animationProp = 'WebkitAnimation';
    animationEndEvent = 'webkitAnimationEnd';
  }
}

// binding to window is necessary to make hot reload work in IE in strict mode
var raf = inBrowser
  ? window.requestAnimationFrame
    ? window.requestAnimationFrame.bind(window)
    : setTimeout
  : /* istanbul ignore next */ function (fn) { return fn(); };

function nextFrame (fn) {
  raf(function () {
    raf(fn);
  });
}

function addTransitionClass (el, cls) {
  var transitionClasses = el._transitionClasses || (el._transitionClasses = []);
  if (transitionClasses.indexOf(cls) < 0) {
    transitionClasses.push(cls);
    addClass(el, cls);
  }
}

function removeTransitionClass (el, cls) {
  if (el._transitionClasses) {
    remove(el._transitionClasses, cls);
  }
  removeClass(el, cls);
}

function whenTransitionEnds (
  el,
  expectedType,
  cb
) {
  var ref = getTransitionInfo(el, expectedType);
  var type = ref.type;
  var timeout = ref.timeout;
  var propCount = ref.propCount;
  if (!type) { return cb() }
  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;
  var ended = 0;
  var end = function () {
    el.removeEventListener(event, onEnd);
    cb();
  };
  var onEnd = function (e) {
    if (e.target === el) {
      if (++ended >= propCount) {
        end();
      }
    }
  };
  setTimeout(function () {
    if (ended < propCount) {
      end();
    }
  }, timeout + 1);
  el.addEventListener(event, onEnd);
}

var transformRE = /\b(transform|all)(,|$)/;

function getTransitionInfo (el, expectedType) {
  var styles = window.getComputedStyle(el);
  var transitionDelays = styles[transitionProp + 'Delay'].split(', ');
  var transitionDurations = styles[transitionProp + 'Duration'].split(', ');
  var transitionTimeout = getTimeout(transitionDelays, transitionDurations);
  var animationDelays = styles[animationProp + 'Delay'].split(', ');
  var animationDurations = styles[animationProp + 'Duration'].split(', ');
  var animationTimeout = getTimeout(animationDelays, animationDurations);

  var type;
  var timeout = 0;
  var propCount = 0;
  /* istanbul ignore if */
  if (expectedType === TRANSITION) {
    if (transitionTimeout > 0) {
      type = TRANSITION;
      timeout = transitionTimeout;
      propCount = transitionDurations.length;
    }
  } else if (expectedType === ANIMATION) {
    if (animationTimeout > 0) {
      type = ANIMATION;
      timeout = animationTimeout;
      propCount = animationDurations.length;
    }
  } else {
    timeout = Math.max(transitionTimeout, animationTimeout);
    type = timeout > 0
      ? transitionTimeout > animationTimeout
        ? TRANSITION
        : ANIMATION
      : null;
    propCount = type
      ? type === TRANSITION
        ? transitionDurations.length
        : animationDurations.length
      : 0;
  }
  var hasTransform =
    type === TRANSITION &&
    transformRE.test(styles[transitionProp + 'Property']);
  return {
    type: type,
    timeout: timeout,
    propCount: propCount,
    hasTransform: hasTransform
  }
}

function getTimeout (delays, durations) {
  /* istanbul ignore next */
  while (delays.length < durations.length) {
    delays = delays.concat(delays);
  }

  return Math.max.apply(null, durations.map(function (d, i) {
    return toMs(d) + toMs(delays[i])
  }))
}

function toMs (s) {
  return Number(s.slice(0, -1)) * 1000
}

/*  */

function enter (vnode, toggleDisplay) {
  var el = vnode.elm;

  // call leave callback now
  if (isDef(el._leaveCb)) {
    el._leaveCb.cancelled = true;
    el._leaveCb();
  }

  var data = resolveTransition(vnode.data.transition);
  if (isUndef(data)) {
    return
  }

  /* istanbul ignore if */
  if (isDef(el._enterCb) || el.nodeType !== 1) {
    return
  }

  var css = data.css;
  var type = data.type;
  var enterClass = data.enterClass;
  var enterToClass = data.enterToClass;
  var enterActiveClass = data.enterActiveClass;
  var appearClass = data.appearClass;
  var appearToClass = data.appearToClass;
  var appearActiveClass = data.appearActiveClass;
  var beforeEnter = data.beforeEnter;
  var enter = data.enter;
  var afterEnter = data.afterEnter;
  var enterCancelled = data.enterCancelled;
  var beforeAppear = data.beforeAppear;
  var appear = data.appear;
  var afterAppear = data.afterAppear;
  var appearCancelled = data.appearCancelled;
  var duration = data.duration;

  // activeInstance will always be the <transition> component managing this
  // transition. One edge case to check is when the <transition> is placed
  // as the root node of a child component. In that case we need to check
  // <transition>'s parent for appear check.
  var context = activeInstance;
  var transitionNode = activeInstance.$vnode;
  while (transitionNode && transitionNode.parent) {
    transitionNode = transitionNode.parent;
    context = transitionNode.context;
  }

  var isAppear = !context._isMounted || !vnode.isRootInsert;

  if (isAppear && !appear && appear !== '') {
    return
  }

  var startClass = isAppear && appearClass
    ? appearClass
    : enterClass;
  var activeClass = isAppear && appearActiveClass
    ? appearActiveClass
    : enterActiveClass;
  var toClass = isAppear && appearToClass
    ? appearToClass
    : enterToClass;

  var beforeEnterHook = isAppear
    ? (beforeAppear || beforeEnter)
    : beforeEnter;
  var enterHook = isAppear
    ? (typeof appear === 'function' ? appear : enter)
    : enter;
  var afterEnterHook = isAppear
    ? (afterAppear || afterEnter)
    : afterEnter;
  var enterCancelledHook = isAppear
    ? (appearCancelled || enterCancelled)
    : enterCancelled;

  var explicitEnterDuration = toNumber(
    isObject(duration)
      ? duration.enter
      : duration
  );

  if ("development" !== 'production' && explicitEnterDuration != null) {
    checkDuration(explicitEnterDuration, 'enter', vnode);
  }

  var expectsCSS = css !== false && !isIE9;
  var userWantsControl = getHookArgumentsLength(enterHook);

  var cb = el._enterCb = once(function () {
    if (expectsCSS) {
      removeTransitionClass(el, toClass);
      removeTransitionClass(el, activeClass);
    }
    if (cb.cancelled) {
      if (expectsCSS) {
        removeTransitionClass(el, startClass);
      }
      enterCancelledHook && enterCancelledHook(el);
    } else {
      afterEnterHook && afterEnterHook(el);
    }
    el._enterCb = null;
  });

  if (!vnode.data.show) {
    // remove pending leave element on enter by injecting an insert hook
    mergeVNodeHook(vnode, 'insert', function () {
      var parent = el.parentNode;
      var pendingNode = parent && parent._pending && parent._pending[vnode.key];
      if (pendingNode &&
        pendingNode.tag === vnode.tag &&
        pendingNode.elm._leaveCb
      ) {
        pendingNode.elm._leaveCb();
      }
      enterHook && enterHook(el, cb);
    });
  }

  // start enter transition
  beforeEnterHook && beforeEnterHook(el);
  if (expectsCSS) {
    addTransitionClass(el, startClass);
    addTransitionClass(el, activeClass);
    nextFrame(function () {
      removeTransitionClass(el, startClass);
      if (!cb.cancelled) {
        addTransitionClass(el, toClass);
        if (!userWantsControl) {
          if (isValidDuration(explicitEnterDuration)) {
            setTimeout(cb, explicitEnterDuration);
          } else {
            whenTransitionEnds(el, type, cb);
          }
        }
      }
    });
  }

  if (vnode.data.show) {
    toggleDisplay && toggleDisplay();
    enterHook && enterHook(el, cb);
  }

  if (!expectsCSS && !userWantsControl) {
    cb();
  }
}

function leave (vnode, rm) {
  var el = vnode.elm;

  // call enter callback now
  if (isDef(el._enterCb)) {
    el._enterCb.cancelled = true;
    el._enterCb();
  }

  var data = resolveTransition(vnode.data.transition);
  if (isUndef(data) || el.nodeType !== 1) {
    return rm()
  }

  /* istanbul ignore if */
  if (isDef(el._leaveCb)) {
    return
  }

  var css = data.css;
  var type = data.type;
  var leaveClass = data.leaveClass;
  var leaveToClass = data.leaveToClass;
  var leaveActiveClass = data.leaveActiveClass;
  var beforeLeave = data.beforeLeave;
  var leave = data.leave;
  var afterLeave = data.afterLeave;
  var leaveCancelled = data.leaveCancelled;
  var delayLeave = data.delayLeave;
  var duration = data.duration;

  var expectsCSS = css !== false && !isIE9;
  var userWantsControl = getHookArgumentsLength(leave);

  var explicitLeaveDuration = toNumber(
    isObject(duration)
      ? duration.leave
      : duration
  );

  if ("development" !== 'production' && isDef(explicitLeaveDuration)) {
    checkDuration(explicitLeaveDuration, 'leave', vnode);
  }

  var cb = el._leaveCb = once(function () {
    if (el.parentNode && el.parentNode._pending) {
      el.parentNode._pending[vnode.key] = null;
    }
    if (expectsCSS) {
      removeTransitionClass(el, leaveToClass);
      removeTransitionClass(el, leaveActiveClass);
    }
    if (cb.cancelled) {
      if (expectsCSS) {
        removeTransitionClass(el, leaveClass);
      }
      leaveCancelled && leaveCancelled(el);
    } else {
      rm();
      afterLeave && afterLeave(el);
    }
    el._leaveCb = null;
  });

  if (delayLeave) {
    delayLeave(performLeave);
  } else {
    performLeave();
  }

  function performLeave () {
    // the delayed leave may have already been cancelled
    if (cb.cancelled) {
      return
    }
    // record leaving element
    if (!vnode.data.show) {
      (el.parentNode._pending || (el.parentNode._pending = {}))[(vnode.key)] = vnode;
    }
    beforeLeave && beforeLeave(el);
    if (expectsCSS) {
      addTransitionClass(el, leaveClass);
      addTransitionClass(el, leaveActiveClass);
      nextFrame(function () {
        removeTransitionClass(el, leaveClass);
        if (!cb.cancelled) {
          addTransitionClass(el, leaveToClass);
          if (!userWantsControl) {
            if (isValidDuration(explicitLeaveDuration)) {
              setTimeout(cb, explicitLeaveDuration);
            } else {
              whenTransitionEnds(el, type, cb);
            }
          }
        }
      });
    }
    leave && leave(el, cb);
    if (!expectsCSS && !userWantsControl) {
      cb();
    }
  }
}

// only used in dev mode
function checkDuration (val, name, vnode) {
  if (typeof val !== 'number') {
    warn(
      "<transition> explicit " + name + " duration is not a valid number - " +
      "got " + (JSON.stringify(val)) + ".",
      vnode.context
    );
  } else if (isNaN(val)) {
    warn(
      "<transition> explicit " + name + " duration is NaN - " +
      'the duration expression might be incorrect.',
      vnode.context
    );
  }
}

function isValidDuration (val) {
  return typeof val === 'number' && !isNaN(val)
}

/**
 * Normalize a transition hook's argument length. The hook may be:
 * - a merged hook (invoker) with the original in .fns
 * - a wrapped component method (check ._length)
 * - a plain function (.length)
 */
function getHookArgumentsLength (fn) {
  if (isUndef(fn)) {
    return false
  }
  var invokerFns = fn.fns;
  if (isDef(invokerFns)) {
    // invoker
    return getHookArgumentsLength(
      Array.isArray(invokerFns)
        ? invokerFns[0]
        : invokerFns
    )
  } else {
    return (fn._length || fn.length) > 1
  }
}

function _enter (_, vnode) {
  if (vnode.data.show !== true) {
    enter(vnode);
  }
}

var transition = inBrowser ? {
  create: _enter,
  activate: _enter,
  remove: function remove$$1 (vnode, rm) {
    /* istanbul ignore else */
    if (vnode.data.show !== true) {
      leave(vnode, rm);
    } else {
      rm();
    }
  }
} : {}

var platformModules = [
  attrs,
  klass,
  events,
  domProps,
  style,
  transition
]

/*  */

// the directive module should be applied last, after all
// built-in modules have been applied.
var modules = platformModules.concat(baseModules);

var patch = createPatchFunction({ nodeOps: nodeOps, modules: modules });

/**
 * Not type checking this file because flow doesn't like attaching
 * properties to Elements.
 */

/* istanbul ignore if */
if (isIE9) {
  // http://www.matts411.com/post/internet-explorer-9-oninput/
  document.addEventListener('selectionchange', function () {
    var el = document.activeElement;
    if (el && el.vmodel) {
      trigger(el, 'input');
    }
  });
}

var directive = {
  inserted: function inserted (el, binding, vnode, oldVnode) {
    if (vnode.tag === 'select') {
      // #6903
      if (oldVnode.elm && !oldVnode.elm._vOptions) {
        mergeVNodeHook(vnode, 'postpatch', function () {
          directive.componentUpdated(el, binding, vnode);
        });
      } else {
        setSelected(el, binding, vnode.context);
      }
      el._vOptions = [].map.call(el.options, getValue);
    } else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {
      el._vModifiers = binding.modifiers;
      if (!binding.modifiers.lazy) {
        el.addEventListener('compositionstart', onCompositionStart);
        el.addEventListener('compositionend', onCompositionEnd);
        // Safari < 10.2 & UIWebView doesn't fire compositionend when
        // switching focus before confirming composition choice
        // this also fixes the issue where some browsers e.g. iOS Chrome
        // fires "change" instead of "input" on autocomplete.
        el.addEventListener('change', onCompositionEnd);
        /* istanbul ignore if */
        if (isIE9) {
          el.vmodel = true;
        }
      }
    }
  },

  componentUpdated: function componentUpdated (el, binding, vnode) {
    if (vnode.tag === 'select') {
      setSelected(el, binding, vnode.context);
      // in case the options rendered by v-for have changed,
      // it's possible that the value is out-of-sync with the rendered options.
      // detect such cases and filter out values that no longer has a matching
      // option in the DOM.
      var prevOptions = el._vOptions;
      var curOptions = el._vOptions = [].map.call(el.options, getValue);
      if (curOptions.some(function (o, i) { return !looseEqual(o, prevOptions[i]); })) {
        // trigger change event if
        // no matching option found for at least one value
        var needReset = el.multiple
          ? binding.value.some(function (v) { return hasNoMatchingOption(v, curOptions); })
          : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, curOptions);
        if (needReset) {
          trigger(el, 'change');
        }
      }
    }
  }
};

function setSelected (el, binding, vm) {
  actuallySetSelected(el, binding, vm);
  /* istanbul ignore if */
  if (isIE || isEdge) {
    setTimeout(function () {
      actuallySetSelected(el, binding, vm);
    }, 0);
  }
}

function actuallySetSelected (el, binding, vm) {
  var value = binding.value;
  var isMultiple = el.multiple;
  if (isMultiple && !Array.isArray(value)) {
    "development" !== 'production' && warn(
      "<select multiple v-model=\"" + (binding.expression) + "\"> " +
      "expects an Array value for its binding, but got " + (Object.prototype.toString.call(value).slice(8, -1)),
      vm
    );
    return
  }
  var selected, option;
  for (var i = 0, l = el.options.length; i < l; i++) {
    option = el.options[i];
    if (isMultiple) {
      selected = looseIndexOf(value, getValue(option)) > -1;
      if (option.selected !== selected) {
        option.selected = selected;
      }
    } else {
      if (looseEqual(getValue(option), value)) {
        if (el.selectedIndex !== i) {
          el.selectedIndex = i;
        }
        return
      }
    }
  }
  if (!isMultiple) {
    el.selectedIndex = -1;
  }
}

function hasNoMatchingOption (value, options) {
  return options.every(function (o) { return !looseEqual(o, value); })
}

function getValue (option) {
  return '_value' in option
    ? option._value
    : option.value
}

function onCompositionStart (e) {
  e.target.composing = true;
}

function onCompositionEnd (e) {
  // prevent triggering an input event for no reason
  if (!e.target.composing) { return }
  e.target.composing = false;
  trigger(e.target, 'input');
}

function trigger (el, type) {
  var e = document.createEvent('HTMLEvents');
  e.initEvent(type, true, true);
  el.dispatchEvent(e);
}

/*  */

// recursively search for possible transition defined inside the component root
function locateNode (vnode) {
  return vnode.componentInstance && (!vnode.data || !vnode.data.transition)
    ? locateNode(vnode.componentInstance._vnode)
    : vnode
}

var show = {
  bind: function bind (el, ref, vnode) {
    var value = ref.value;

    vnode = locateNode(vnode);
    var transition$$1 = vnode.data && vnode.data.transition;
    var originalDisplay = el.__vOriginalDisplay =
      el.style.display === 'none' ? '' : el.style.display;
    if (value && transition$$1) {
      vnode.data.show = true;
      enter(vnode, function () {
        el.style.display = originalDisplay;
      });
    } else {
      el.style.display = value ? originalDisplay : 'none';
    }
  },

  update: function update (el, ref, vnode) {
    var value = ref.value;
    var oldValue = ref.oldValue;

    /* istanbul ignore if */
    if (!value === !oldValue) { return }
    vnode = locateNode(vnode);
    var transition$$1 = vnode.data && vnode.data.transition;
    if (transition$$1) {
      vnode.data.show = true;
      if (value) {
        enter(vnode, function () {
          el.style.display = el.__vOriginalDisplay;
        });
      } else {
        leave(vnode, function () {
          el.style.display = 'none';
        });
      }
    } else {
      el.style.display = value ? el.__vOriginalDisplay : 'none';
    }
  },

  unbind: function unbind (
    el,
    binding,
    vnode,
    oldVnode,
    isDestroy
  ) {
    if (!isDestroy) {
      el.style.display = el.__vOriginalDisplay;
    }
  }
}

var platformDirectives = {
  model: directive,
  show: show
}

/*  */

// Provides transition support for a single element/component.
// supports transition mode (out-in / in-out)

var transitionProps = {
  name: String,
  appear: Boolean,
  css: Boolean,
  mode: String,
  type: String,
  enterClass: String,
  leaveClass: String,
  enterToClass: String,
  leaveToClass: String,
  enterActiveClass: String,
  leaveActiveClass: String,
  appearClass: String,
  appearActiveClass: String,
  appearToClass: String,
  duration: [Number, String, Object]
};

// in case the child is also an abstract component, e.g. <keep-alive>
// we want to recursively retrieve the real component to be rendered
function getRealChild (vnode) {
  var compOptions = vnode && vnode.componentOptions;
  if (compOptions && compOptions.Ctor.options.abstract) {
    return getRealChild(getFirstComponentChild(compOptions.children))
  } else {
    return vnode
  }
}

function extractTransitionData (comp) {
  var data = {};
  var options = comp.$options;
  // props
  for (var key in options.propsData) {
    data[key] = comp[key];
  }
  // events.
  // extract listeners and pass them directly to the transition methods
  var listeners = options._parentListeners;
  for (var key$1 in listeners) {
    data[camelize(key$1)] = listeners[key$1];
  }
  return data
}

function placeholder (h, rawChild) {
  if (/\d-keep-alive$/.test(rawChild.tag)) {
    return h('keep-alive', {
      props: rawChild.componentOptions.propsData
    })
  }
}

function hasParentTransition (vnode) {
  while ((vnode = vnode.parent)) {
    if (vnode.data.transition) {
      return true
    }
  }
}

function isSameChild (child, oldChild) {
  return oldChild.key === child.key && oldChild.tag === child.tag
}

var Transition = {
  name: 'transition',
  props: transitionProps,
  abstract: true,

  render: function render (h) {
    var this$1 = this;

    var children = this.$slots.default;
    if (!children) {
      return
    }

    // filter out text nodes (possible whitespaces)
    children = children.filter(function (c) { return c.tag || isAsyncPlaceholder(c); });
    /* istanbul ignore if */
    if (!children.length) {
      return
    }

    // warn multiple elements
    if ("development" !== 'production' && children.length > 1) {
      warn(
        '<transition> can only be used on a single element. Use ' +
        '<transition-group> for lists.',
        this.$parent
      );
    }

    var mode = this.mode;

    // warn invalid mode
    if ("development" !== 'production' &&
      mode && mode !== 'in-out' && mode !== 'out-in'
    ) {
      warn(
        'invalid <transition> mode: ' + mode,
        this.$parent
      );
    }

    var rawChild = children[0];

    // if this is a component root node and the component's
    // parent container node also has transition, skip.
    if (hasParentTransition(this.$vnode)) {
      return rawChild
    }

    // apply transition data to child
    // use getRealChild() to ignore abstract components e.g. keep-alive
    var child = getRealChild(rawChild);
    /* istanbul ignore if */
    if (!child) {
      return rawChild
    }

    if (this._leaving) {
      return placeholder(h, rawChild)
    }

    // ensure a key that is unique to the vnode type and to this transition
    // component instance. This key will be used to remove pending leaving nodes
    // during entering.
    var id = "__transition-" + (this._uid) + "-";
    child.key = child.key == null
      ? child.isComment
        ? id + 'comment'
        : id + child.tag
      : isPrimitive(child.key)
        ? (String(child.key).indexOf(id) === 0 ? child.key : id + child.key)
        : child.key;

    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);
    var oldRawChild = this._vnode;
    var oldChild = getRealChild(oldRawChild);

    // mark v-show
    // so that the transition module can hand over the control to the directive
    if (child.data.directives && child.data.directives.some(function (d) { return d.name === 'show'; })) {
      child.data.show = true;
    }

    if (
      oldChild &&
      oldChild.data &&
      !isSameChild(child, oldChild) &&
      !isAsyncPlaceholder(oldChild) &&
      // #6687 component root is a comment node
      !(oldChild.componentInstance && oldChild.componentInstance._vnode.isComment)
    ) {
      // replace old child transition data with fresh one
      // important for dynamic transitions!
      var oldData = oldChild.data.transition = extend({}, data);
      // handle transition mode
      if (mode === 'out-in') {
        // return placeholder node and queue update when leave finishes
        this._leaving = true;
        mergeVNodeHook(oldData, 'afterLeave', function () {
          this$1._leaving = false;
          this$1.$forceUpdate();
        });
        return placeholder(h, rawChild)
      } else if (mode === 'in-out') {
        if (isAsyncPlaceholder(child)) {
          return oldRawChild
        }
        var delayedLeave;
        var performLeave = function () { delayedLeave(); };
        mergeVNodeHook(data, 'afterEnter', performLeave);
        mergeVNodeHook(data, 'enterCancelled', performLeave);
        mergeVNodeHook(oldData, 'delayLeave', function (leave) { delayedLeave = leave; });
      }
    }

    return rawChild
  }
}

/*  */

// Provides transition support for list items.
// supports move transitions using the FLIP technique.

// Because the vdom's children update algorithm is "unstable" - i.e.
// it doesn't guarantee the relative positioning of removed elements,
// we force transition-group to update its children into two passes:
// in the first pass, we remove all nodes that need to be removed,
// triggering their leaving transition; in the second pass, we insert/move
// into the final desired state. This way in the second pass removed
// nodes will remain where they should be.

var props = extend({
  tag: String,
  moveClass: String
}, transitionProps);

delete props.mode;

var TransitionGroup = {
  props: props,

  render: function render (h) {
    var tag = this.tag || this.$vnode.data.tag || 'span';
    var map = Object.create(null);
    var prevChildren = this.prevChildren = this.children;
    var rawChildren = this.$slots.default || [];
    var children = this.children = [];
    var transitionData = extractTransitionData(this);

    for (var i = 0; i < rawChildren.length; i++) {
      var c = rawChildren[i];
      if (c.tag) {
        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {
          children.push(c);
          map[c.key] = c
          ;(c.data || (c.data = {})).transition = transitionData;
        } else if (true) {
          var opts = c.componentOptions;
          var name = opts ? (opts.Ctor.options.name || opts.tag || '') : c.tag;
          warn(("<transition-group> children must be keyed: <" + name + ">"));
        }
      }
    }

    if (prevChildren) {
      var kept = [];
      var removed = [];
      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {
        var c$1 = prevChildren[i$1];
        c$1.data.transition = transitionData;
        c$1.data.pos = c$1.elm.getBoundingClientRect();
        if (map[c$1.key]) {
          kept.push(c$1);
        } else {
          removed.push(c$1);
        }
      }
      this.kept = h(tag, null, kept);
      this.removed = removed;
    }

    return h(tag, null, children)
  },

  beforeUpdate: function beforeUpdate () {
    // force removing pass
    this.__patch__(
      this._vnode,
      this.kept,
      false, // hydrating
      true // removeOnly (!important, avoids unnecessary moves)
    );
    this._vnode = this.kept;
  },

  updated: function updated () {
    var children = this.prevChildren;
    var moveClass = this.moveClass || ((this.name || 'v') + '-move');
    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {
      return
    }

    // we divide the work into three loops to avoid mixing DOM reads and writes
    // in each iteration - which helps prevent layout thrashing.
    children.forEach(callPendingCbs);
    children.forEach(recordPosition);
    children.forEach(applyTranslation);

    // force reflow to put everything in position
    // assign to this to avoid being removed in tree-shaking
    // $flow-disable-line
    this._reflow = document.body.offsetHeight;

    children.forEach(function (c) {
      if (c.data.moved) {
        var el = c.elm;
        var s = el.style;
        addTransitionClass(el, moveClass);
        s.transform = s.WebkitTransform = s.transitionDuration = '';
        el.addEventListener(transitionEndEvent, el._moveCb = function cb (e) {
          if (!e || /transform$/.test(e.propertyName)) {
            el.removeEventListener(transitionEndEvent, cb);
            el._moveCb = null;
            removeTransitionClass(el, moveClass);
          }
        });
      }
    });
  },

  methods: {
    hasMove: function hasMove (el, moveClass) {
      /* istanbul ignore if */
      if (!hasTransition) {
        return false
      }
      /* istanbul ignore if */
      if (this._hasMove) {
        return this._hasMove
      }
      // Detect whether an element with the move class applied has
      // CSS transitions. Since the element may be inside an entering
      // transition at this very moment, we make a clone of it and remove
      // all other transition classes applied to ensure only the move class
      // is applied.
      var clone = el.cloneNode();
      if (el._transitionClasses) {
        el._transitionClasses.forEach(function (cls) { removeClass(clone, cls); });
      }
      addClass(clone, moveClass);
      clone.style.display = 'none';
      this.$el.appendChild(clone);
      var info = getTransitionInfo(clone);
      this.$el.removeChild(clone);
      return (this._hasMove = info.hasTransform)
    }
  }
}

function callPendingCbs (c) {
  /* istanbul ignore if */
  if (c.elm._moveCb) {
    c.elm._moveCb();
  }
  /* istanbul ignore if */
  if (c.elm._enterCb) {
    c.elm._enterCb();
  }
}

function recordPosition (c) {
  c.data.newPos = c.elm.getBoundingClientRect();
}

function applyTranslation (c) {
  var oldPos = c.data.pos;
  var newPos = c.data.newPos;
  var dx = oldPos.left - newPos.left;
  var dy = oldPos.top - newPos.top;
  if (dx || dy) {
    c.data.moved = true;
    var s = c.elm.style;
    s.transform = s.WebkitTransform = "translate(" + dx + "px," + dy + "px)";
    s.transitionDuration = '0s';
  }
}

var platformComponents = {
  Transition: Transition,
  TransitionGroup: TransitionGroup
}

/*  */

// install platform specific utils
Vue.config.mustUseProp = mustUseProp;
Vue.config.isReservedTag = isReservedTag;
Vue.config.isReservedAttr = isReservedAttr;
Vue.config.getTagNamespace = getTagNamespace;
Vue.config.isUnknownElement = isUnknownElement;

// install platform runtime directives & components
extend(Vue.options.directives, platformDirectives);
extend(Vue.options.components, platformComponents);

// install platform patch function
Vue.prototype.__patch__ = inBrowser ? patch : noop;

// public mount method
Vue.prototype.$mount = function (
  el,
  hydrating
) {
  el = el && inBrowser ? query(el) : undefined;
  return mountComponent(this, el, hydrating)
};

// devtools global hook
/* istanbul ignore next */
if (inBrowser) {
  setTimeout(function () {
    if (config.devtools) {
      if (devtools) {
        devtools.emit('init', Vue);
      } else if (
        "development" !== 'production' &&
        "development" !== 'test' &&
        isChrome
      ) {
        console[console.info ? 'info' : 'log'](
          'Download the Vue Devtools extension for a better development experience:\n' +
          'https://github.com/vuejs/vue-devtools'
        );
      }
    }
    if ("development" !== 'production' &&
      "development" !== 'test' &&
      config.productionTip !== false &&
      typeof console !== 'undefined'
    ) {
      console[console.info ? 'info' : 'log'](
        "You are running Vue in development mode.\n" +
        "Make sure to turn on production mode when deploying for production.\n" +
        "See more tips at https://vuejs.org/guide/deployment.html"
      );
    }
  }, 0);
}

/*  */

var defaultTagRE = /\{\{((?:.|\n)+?)\}\}/g;
var regexEscapeRE = /[-.*+?^${}()|[\]\/\\]/g;

var buildRegex = cached(function (delimiters) {
  var open = delimiters[0].replace(regexEscapeRE, '\\$&');
  var close = delimiters[1].replace(regexEscapeRE, '\\$&');
  return new RegExp(open + '((?:.|\\n)+?)' + close, 'g')
});



function parseText (
  text,
  delimiters
) {
  var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;
  if (!tagRE.test(text)) {
    return
  }
  var tokens = [];
  var rawTokens = [];
  var lastIndex = tagRE.lastIndex = 0;
  var match, index, tokenValue;
  while ((match = tagRE.exec(text))) {
    index = match.index;
    // push text token
    if (index > lastIndex) {
      rawTokens.push(tokenValue = text.slice(lastIndex, index));
      tokens.push(JSON.stringify(tokenValue));
    }
    // tag token
    var exp = parseFilters(match[1].trim());
    tokens.push(("_s(" + exp + ")"));
    rawTokens.push({ '@binding': exp });
    lastIndex = index + match[0].length;
  }
  if (lastIndex < text.length) {
    rawTokens.push(tokenValue = text.slice(lastIndex));
    tokens.push(JSON.stringify(tokenValue));
  }
  return {
    expression: tokens.join('+'),
    tokens: rawTokens
  }
}

/*  */

function transformNode (el, options) {
  var warn = options.warn || baseWarn;
  var staticClass = getAndRemoveAttr(el, 'class');
  if ("development" !== 'production' && staticClass) {
    var res = parseText(staticClass, options.delimiters);
    if (res) {
      warn(
        "class=\"" + staticClass + "\": " +
        'Interpolation inside attributes has been removed. ' +
        'Use v-bind or the colon shorthand instead. For example, ' +
        'instead of <div class="{{ val }}">, use <div :class="val">.'
      );
    }
  }
  if (staticClass) {
    el.staticClass = JSON.stringify(staticClass);
  }
  var classBinding = getBindingAttr(el, 'class', false /* getStatic */);
  if (classBinding) {
    el.classBinding = classBinding;
  }
}

function genData (el) {
  var data = '';
  if (el.staticClass) {
    data += "staticClass:" + (el.staticClass) + ",";
  }
  if (el.classBinding) {
    data += "class:" + (el.classBinding) + ",";
  }
  return data
}

var klass$1 = {
  staticKeys: ['staticClass'],
  transformNode: transformNode,
  genData: genData
}

/*  */

function transformNode$1 (el, options) {
  var warn = options.warn || baseWarn;
  var staticStyle = getAndRemoveAttr(el, 'style');
  if (staticStyle) {
    /* istanbul ignore if */
    if (true) {
      var res = parseText(staticStyle, options.delimiters);
      if (res) {
        warn(
          "style=\"" + staticStyle + "\": " +
          'Interpolation inside attributes has been removed. ' +
          'Use v-bind or the colon shorthand instead. For example, ' +
          'instead of <div style="{{ val }}">, use <div :style="val">.'
        );
      }
    }
    el.staticStyle = JSON.stringify(parseStyleText(staticStyle));
  }

  var styleBinding = getBindingAttr(el, 'style', false /* getStatic */);
  if (styleBinding) {
    el.styleBinding = styleBinding;
  }
}

function genData$1 (el) {
  var data = '';
  if (el.staticStyle) {
    data += "staticStyle:" + (el.staticStyle) + ",";
  }
  if (el.styleBinding) {
    data += "style:(" + (el.styleBinding) + "),";
  }
  return data
}

var style$1 = {
  staticKeys: ['staticStyle'],
  transformNode: transformNode$1,
  genData: genData$1
}

/*  */

var decoder;

var he = {
  decode: function decode (html) {
    decoder = decoder || document.createElement('div');
    decoder.innerHTML = html;
    return decoder.textContent
  }
}

/*  */

var isUnaryTag = makeMap(
  'area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' +
  'link,meta,param,source,track,wbr'
);

// Elements that you can, intentionally, leave open
// (and which close themselves)
var canBeLeftOpenTag = makeMap(
  'colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source'
);

// HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3
// Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content
var isNonPhrasingTag = makeMap(
  'address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' +
  'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' +
  'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' +
  'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' +
  'title,tr,track'
);

/**
 * Not type-checking this file because it's mostly vendor code.
 */

/*!
 * HTML Parser By John Resig (ejohn.org)
 * Modified by Juriy "kangax" Zaytsev
 * Original code by Erik Arvidsson, Mozilla Public License
 * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js
 */

// Regular Expressions for parsing tags and attributes
var attribute = /^\s*([^\s"'<>\/=]+)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/;
// could use https://www.w3.org/TR/1999/REC-xml-names-19990114/#NT-QName
// but for Vue templates we can enforce a simple charset
var ncname = '[a-zA-Z_][\\w\\-\\.]*';
var qnameCapture = "((?:" + ncname + "\\:)?" + ncname + ")";
var startTagOpen = new RegExp(("^<" + qnameCapture));
var startTagClose = /^\s*(\/?)>/;
var endTag = new RegExp(("^<\\/" + qnameCapture + "[^>]*>"));
var doctype = /^<!DOCTYPE [^>]+>/i;
// #7298: escape - to avoid being pased as HTML comment when inlined in page
var comment = /^<!\--/;
var conditionalComment = /^<!\[/;

var IS_REGEX_CAPTURING_BROKEN = false;
'x'.replace(/x(.)?/g, function (m, g) {
  IS_REGEX_CAPTURING_BROKEN = g === '';
});

// Special Elements (can contain anything)
var isPlainTextElement = makeMap('script,style,textarea', true);
var reCache = {};

var decodingMap = {
  '&lt;': '<',
  '&gt;': '>',
  '&quot;': '"',
  '&amp;': '&',
  '&#10;': '\n',
  '&#9;': '\t'
};
var encodedAttr = /&(?:lt|gt|quot|amp);/g;
var encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#10|#9);/g;

// #5992
var isIgnoreNewlineTag = makeMap('pre,textarea', true);
var shouldIgnoreFirstNewline = function (tag, html) { return tag && isIgnoreNewlineTag(tag) && html[0] === '\n'; };

function decodeAttr (value, shouldDecodeNewlines) {
  var re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;
  return value.replace(re, function (match) { return decodingMap[match]; })
}

function parseHTML (html, options) {
  var stack = [];
  var expectHTML = options.expectHTML;
  var isUnaryTag$$1 = options.isUnaryTag || no;
  var canBeLeftOpenTag$$1 = options.canBeLeftOpenTag || no;
  var index = 0;
  var last, lastTag;
  while (html) {
    last = html;
    // Make sure we're not in a plaintext content element like script/style
    if (!lastTag || !isPlainTextElement(lastTag)) {
      var textEnd = html.indexOf('<');
      if (textEnd === 0) {
        // Comment:
        if (comment.test(html)) {
          var commentEnd = html.indexOf('-->');

          if (commentEnd >= 0) {
            if (options.shouldKeepComment) {
              options.comment(html.substring(4, commentEnd));
            }
            advance(commentEnd + 3);
            continue
          }
        }

        // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment
        if (conditionalComment.test(html)) {
          var conditionalEnd = html.indexOf(']>');

          if (conditionalEnd >= 0) {
            advance(conditionalEnd + 2);
            continue
          }
        }

        // Doctype:
        var doctypeMatch = html.match(doctype);
        if (doctypeMatch) {
          advance(doctypeMatch[0].length);
          continue
        }

        // End tag:
        var endTagMatch = html.match(endTag);
        if (endTagMatch) {
          var curIndex = index;
          advance(endTagMatch[0].length);
          parseEndTag(endTagMatch[1], curIndex, index);
          continue
        }

        // Start tag:
        var startTagMatch = parseStartTag();
        if (startTagMatch) {
          handleStartTag(startTagMatch);
          if (shouldIgnoreFirstNewline(lastTag, html)) {
            advance(1);
          }
          continue
        }
      }

      var text = (void 0), rest = (void 0), next = (void 0);
      if (textEnd >= 0) {
        rest = html.slice(textEnd);
        while (
          !endTag.test(rest) &&
          !startTagOpen.test(rest) &&
          !comment.test(rest) &&
          !conditionalComment.test(rest)
        ) {
          // < in plain text, be forgiving and treat it as text
          next = rest.indexOf('<', 1);
          if (next < 0) { break }
          textEnd += next;
          rest = html.slice(textEnd);
        }
        text = html.substring(0, textEnd);
        advance(textEnd);
      }

      if (textEnd < 0) {
        text = html;
        html = '';
      }

      if (options.chars && text) {
        options.chars(text);
      }
    } else {
      var endTagLength = 0;
      var stackedTag = lastTag.toLowerCase();
      var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\s\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));
      var rest$1 = html.replace(reStackedTag, function (all, text, endTag) {
        endTagLength = endTag.length;
        if (!isPlainTextElement(stackedTag) && stackedTag !== 'noscript') {
          text = text
            .replace(/<!\--([\s\S]*?)-->/g, '$1') // #7298
            .replace(/<!\[CDATA\[([\s\S]*?)]]>/g, '$1');
        }
        if (shouldIgnoreFirstNewline(stackedTag, text)) {
          text = text.slice(1);
        }
        if (options.chars) {
          options.chars(text);
        }
        return ''
      });
      index += html.length - rest$1.length;
      html = rest$1;
      parseEndTag(stackedTag, index - endTagLength, index);
    }

    if (html === last) {
      options.chars && options.chars(html);
      if ("development" !== 'production' && !stack.length && options.warn) {
        options.warn(("Mal-formatted tag at end of template: \"" + html + "\""));
      }
      break
    }
  }

  // Clean up any remaining tags
  parseEndTag();

  function advance (n) {
    index += n;
    html = html.substring(n);
  }

  function parseStartTag () {
    var start = html.match(startTagOpen);
    if (start) {
      var match = {
        tagName: start[1],
        attrs: [],
        start: index
      };
      advance(start[0].length);
      var end, attr;
      while (!(end = html.match(startTagClose)) && (attr = html.match(attribute))) {
        advance(attr[0].length);
        match.attrs.push(attr);
      }
      if (end) {
        match.unarySlash = end[1];
        advance(end[0].length);
        match.end = index;
        return match
      }
    }
  }

  function handleStartTag (match) {
    var tagName = match.tagName;
    var unarySlash = match.unarySlash;

    if (expectHTML) {
      if (lastTag === 'p' && isNonPhrasingTag(tagName)) {
        parseEndTag(lastTag);
      }
      if (canBeLeftOpenTag$$1(tagName) && lastTag === tagName) {
        parseEndTag(tagName);
      }
    }

    var unary = isUnaryTag$$1(tagName) || !!unarySlash;

    var l = match.attrs.length;
    var attrs = new Array(l);
    for (var i = 0; i < l; i++) {
      var args = match.attrs[i];
      // hackish work around FF bug https://bugzilla.mozilla.org/show_bug.cgi?id=369778
      if (IS_REGEX_CAPTURING_BROKEN && args[0].indexOf('""') === -1) {
        if (args[3] === '') { delete args[3]; }
        if (args[4] === '') { delete args[4]; }
        if (args[5] === '') { delete args[5]; }
      }
      var value = args[3] || args[4] || args[5] || '';
      var shouldDecodeNewlines = tagName === 'a' && args[1] === 'href'
        ? options.shouldDecodeNewlinesForHref
        : options.shouldDecodeNewlines;
      attrs[i] = {
        name: args[1],
        value: decodeAttr(value, shouldDecodeNewlines)
      };
    }

    if (!unary) {
      stack.push({ tag: tagName, lowerCasedTag: tagName.toLowerCase(), attrs: attrs });
      lastTag = tagName;
    }

    if (options.start) {
      options.start(tagName, attrs, unary, match.start, match.end);
    }
  }

  function parseEndTag (tagName, start, end) {
    var pos, lowerCasedTagName;
    if (start == null) { start = index; }
    if (end == null) { end = index; }

    if (tagName) {
      lowerCasedTagName = tagName.toLowerCase();
    }

    // Find the closest opened tag of the same type
    if (tagName) {
      for (pos = stack.length - 1; pos >= 0; pos--) {
        if (stack[pos].lowerCasedTag === lowerCasedTagName) {
          break
        }
      }
    } else {
      // If no tag name is provided, clean shop
      pos = 0;
    }

    if (pos >= 0) {
      // Close all the open elements, up the stack
      for (var i = stack.length - 1; i >= pos; i--) {
        if ("development" !== 'production' &&
          (i > pos || !tagName) &&
          options.warn
        ) {
          options.warn(
            ("tag <" + (stack[i].tag) + "> has no matching end tag.")
          );
        }
        if (options.end) {
          options.end(stack[i].tag, start, end);
        }
      }

      // Remove the open elements from the stack
      stack.length = pos;
      lastTag = pos && stack[pos - 1].tag;
    } else if (lowerCasedTagName === 'br') {
      if (options.start) {
        options.start(tagName, [], true, start, end);
      }
    } else if (lowerCasedTagName === 'p') {
      if (options.start) {
        options.start(tagName, [], false, start, end);
      }
      if (options.end) {
        options.end(tagName, start, end);
      }
    }
  }
}

/*  */

var onRE = /^@|^v-on:/;
var dirRE = /^v-|^@|^:/;
var forAliasRE = /([^]*?)\s+(?:in|of)\s+([^]*)/;
var forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/;
var stripParensRE = /^\(|\)$/g;

var argRE = /:(.*)$/;
var bindRE = /^:|^v-bind:/;
var modifierRE = /\.[^.]+/g;

var decodeHTMLCached = cached(he.decode);

// configurable state
var warn$2;
var delimiters;
var transforms;
var preTransforms;
var postTransforms;
var platformIsPreTag;
var platformMustUseProp;
var platformGetTagNamespace;



function createASTElement (
  tag,
  attrs,
  parent
) {
  return {
    type: 1,
    tag: tag,
    attrsList: attrs,
    attrsMap: makeAttrsMap(attrs),
    parent: parent,
    children: []
  }
}

/**
 * Convert HTML string to AST.
 */
function parse (
  template,
  options
) {
  warn$2 = options.warn || baseWarn;

  platformIsPreTag = options.isPreTag || no;
  platformMustUseProp = options.mustUseProp || no;
  platformGetTagNamespace = options.getTagNamespace || no;

  transforms = pluckModuleFunction(options.modules, 'transformNode');
  preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');
  postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');

  delimiters = options.delimiters;

  var stack = [];
  var preserveWhitespace = options.preserveWhitespace !== false;
  var root;
  var currentParent;
  var inVPre = false;
  var inPre = false;
  var warned = false;

  function warnOnce (msg) {
    if (!warned) {
      warned = true;
      warn$2(msg);
    }
  }

  function closeElement (element) {
    // check pre state
    if (element.pre) {
      inVPre = false;
    }
    if (platformIsPreTag(element.tag)) {
      inPre = false;
    }
    // apply post-transforms
    for (var i = 0; i < postTransforms.length; i++) {
      postTransforms[i](element, options);
    }
  }

  parseHTML(template, {
    warn: warn$2,
    expectHTML: options.expectHTML,
    isUnaryTag: options.isUnaryTag,
    canBeLeftOpenTag: options.canBeLeftOpenTag,
    shouldDecodeNewlines: options.shouldDecodeNewlines,
    shouldDecodeNewlinesForHref: options.shouldDecodeNewlinesForHref,
    shouldKeepComment: options.comments,
    start: function start (tag, attrs, unary) {
      // check namespace.
      // inherit parent ns if there is one
      var ns = (currentParent && currentParent.ns) || platformGetTagNamespace(tag);

      // handle IE svg bug
      /* istanbul ignore if */
      if (isIE && ns === 'svg') {
        attrs = guardIESVGBug(attrs);
      }

      var element = createASTElement(tag, attrs, currentParent);
      if (ns) {
        element.ns = ns;
      }

      if (isForbiddenTag(element) && !isServerRendering()) {
        element.forbidden = true;
        "development" !== 'production' && warn$2(
          'Templates should only be responsible for mapping the state to the ' +
          'UI. Avoid placing tags with side-effects in your templates, such as ' +
          "<" + tag + ">" + ', as they will not be parsed.'
        );
      }

      // apply pre-transforms
      for (var i = 0; i < preTransforms.length; i++) {
        element = preTransforms[i](element, options) || element;
      }

      if (!inVPre) {
        processPre(element);
        if (element.pre) {
          inVPre = true;
        }
      }
      if (platformIsPreTag(element.tag)) {
        inPre = true;
      }
      if (inVPre) {
        processRawAttrs(element);
      } else if (!element.processed) {
        // structural directives
        processFor(element);
        processIf(element);
        processOnce(element);
        // element-scope stuff
        processElement(element, options);
      }

      function checkRootConstraints (el) {
        if (true) {
          if (el.tag === 'slot' || el.tag === 'template') {
            warnOnce(
              "Cannot use <" + (el.tag) + "> as component root element because it may " +
              'contain multiple nodes.'
            );
          }
          if (el.attrsMap.hasOwnProperty('v-for')) {
            warnOnce(
              'Cannot use v-for on stateful component root element because ' +
              'it renders multiple elements.'
            );
          }
        }
      }

      // tree management
      if (!root) {
        root = element;
        checkRootConstraints(root);
      } else if (!stack.length) {
        // allow root elements with v-if, v-else-if and v-else
        if (root.if && (element.elseif || element.else)) {
          checkRootConstraints(element);
          addIfCondition(root, {
            exp: element.elseif,
            block: element
          });
        } else if (true) {
          warnOnce(
            "Component template should contain exactly one root element. " +
            "If you are using v-if on multiple elements, " +
            "use v-else-if to chain them instead."
          );
        }
      }
      if (currentParent && !element.forbidden) {
        if (element.elseif || element.else) {
          processIfConditions(element, currentParent);
        } else if (element.slotScope) { // scoped slot
          currentParent.plain = false;
          var name = element.slotTarget || '"default"';(currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;
        } else {
          currentParent.children.push(element);
          element.parent = currentParent;
        }
      }
      if (!unary) {
        currentParent = element;
        stack.push(element);
      } else {
        closeElement(element);
      }
    },

    end: function end () {
      // remove trailing whitespace
      var element = stack[stack.length - 1];
      var lastNode = element.children[element.children.length - 1];
      if (lastNode && lastNode.type === 3 && lastNode.text === ' ' && !inPre) {
        element.children.pop();
      }
      // pop stack
      stack.length -= 1;
      currentParent = stack[stack.length - 1];
      closeElement(element);
    },

    chars: function chars (text) {
      if (!currentParent) {
        if (true) {
          if (text === template) {
            warnOnce(
              'Component template requires a root element, rather than just text.'
            );
          } else if ((text = text.trim())) {
            warnOnce(
              ("text \"" + text + "\" outside root element will be ignored.")
            );
          }
        }
        return
      }
      // IE textarea placeholder bug
      /* istanbul ignore if */
      if (isIE &&
        currentParent.tag === 'textarea' &&
        currentParent.attrsMap.placeholder === text
      ) {
        return
      }
      var children = currentParent.children;
      text = inPre || text.trim()
        ? isTextTag(currentParent) ? text : decodeHTMLCached(text)
        // only preserve whitespace if its not right after a starting tag
        : preserveWhitespace && children.length ? ' ' : '';
      if (text) {
        var res;
        if (!inVPre && text !== ' ' && (res = parseText(text, delimiters))) {
          children.push({
            type: 2,
            expression: res.expression,
            tokens: res.tokens,
            text: text
          });
        } else if (text !== ' ' || !children.length || children[children.length - 1].text !== ' ') {
          children.push({
            type: 3,
            text: text
          });
        }
      }
    },
    comment: function comment (text) {
      currentParent.children.push({
        type: 3,
        text: text,
        isComment: true
      });
    }
  });
  return root
}

function processPre (el) {
  if (getAndRemoveAttr(el, 'v-pre') != null) {
    el.pre = true;
  }
}

function processRawAttrs (el) {
  var l = el.attrsList.length;
  if (l) {
    var attrs = el.attrs = new Array(l);
    for (var i = 0; i < l; i++) {
      attrs[i] = {
        name: el.attrsList[i].name,
        value: JSON.stringify(el.attrsList[i].value)
      };
    }
  } else if (!el.pre) {
    // non root node in pre blocks with no attributes
    el.plain = true;
  }
}

function processElement (element, options) {
  processKey(element);

  // determine whether this is a plain element after
  // removing structural attributes
  element.plain = !element.key && !element.attrsList.length;

  processRef(element);
  processSlot(element);
  processComponent(element);
  for (var i = 0; i < transforms.length; i++) {
    element = transforms[i](element, options) || element;
  }
  processAttrs(element);
}

function processKey (el) {
  var exp = getBindingAttr(el, 'key');
  if (exp) {
    if ("development" !== 'production' && el.tag === 'template') {
      warn$2("<template> cannot be keyed. Place the key on real elements instead.");
    }
    el.key = exp;
  }
}

function processRef (el) {
  var ref = getBindingAttr(el, 'ref');
  if (ref) {
    el.ref = ref;
    el.refInFor = checkInFor(el);
  }
}

function processFor (el) {
  var exp;
  if ((exp = getAndRemoveAttr(el, 'v-for'))) {
    var res = parseFor(exp);
    if (res) {
      extend(el, res);
    } else if (true) {
      warn$2(
        ("Invalid v-for expression: " + exp)
      );
    }
  }
}



function parseFor (exp) {
  var inMatch = exp.match(forAliasRE);
  if (!inMatch) { return }
  var res = {};
  res.for = inMatch[2].trim();
  var alias = inMatch[1].trim().replace(stripParensRE, '');
  var iteratorMatch = alias.match(forIteratorRE);
  if (iteratorMatch) {
    res.alias = alias.replace(forIteratorRE, '');
    res.iterator1 = iteratorMatch[1].trim();
    if (iteratorMatch[2]) {
      res.iterator2 = iteratorMatch[2].trim();
    }
  } else {
    res.alias = alias;
  }
  return res
}

function processIf (el) {
  var exp = getAndRemoveAttr(el, 'v-if');
  if (exp) {
    el.if = exp;
    addIfCondition(el, {
      exp: exp,
      block: el
    });
  } else {
    if (getAndRemoveAttr(el, 'v-else') != null) {
      el.else = true;
    }
    var elseif = getAndRemoveAttr(el, 'v-else-if');
    if (elseif) {
      el.elseif = elseif;
    }
  }
}

function processIfConditions (el, parent) {
  var prev = findPrevElement(parent.children);
  if (prev && prev.if) {
    addIfCondition(prev, {
      exp: el.elseif,
      block: el
    });
  } else if (true) {
    warn$2(
      "v-" + (el.elseif ? ('else-if="' + el.elseif + '"') : 'else') + " " +
      "used on element <" + (el.tag) + "> without corresponding v-if."
    );
  }
}

function findPrevElement (children) {
  var i = children.length;
  while (i--) {
    if (children[i].type === 1) {
      return children[i]
    } else {
      if ("development" !== 'production' && children[i].text !== ' ') {
        warn$2(
          "text \"" + (children[i].text.trim()) + "\" between v-if and v-else(-if) " +
          "will be ignored."
        );
      }
      children.pop();
    }
  }
}

function addIfCondition (el, condition) {
  if (!el.ifConditions) {
    el.ifConditions = [];
  }
  el.ifConditions.push(condition);
}

function processOnce (el) {
  var once$$1 = getAndRemoveAttr(el, 'v-once');
  if (once$$1 != null) {
    el.once = true;
  }
}

function processSlot (el) {
  if (el.tag === 'slot') {
    el.slotName = getBindingAttr(el, 'name');
    if ("development" !== 'production' && el.key) {
      warn$2(
        "`key` does not work on <slot> because slots are abstract outlets " +
        "and can possibly expand into multiple elements. " +
        "Use the key on a wrapping element instead."
      );
    }
  } else {
    var slotScope;
    if (el.tag === 'template') {
      slotScope = getAndRemoveAttr(el, 'scope');
      /* istanbul ignore if */
      if ("development" !== 'production' && slotScope) {
        warn$2(
          "the \"scope\" attribute for scoped slots have been deprecated and " +
          "replaced by \"slot-scope\" since 2.5. The new \"slot-scope\" attribute " +
          "can also be used on plain elements in addition to <template> to " +
          "denote scoped slots.",
          true
        );
      }
      el.slotScope = slotScope || getAndRemoveAttr(el, 'slot-scope');
    } else if ((slotScope = getAndRemoveAttr(el, 'slot-scope'))) {
      /* istanbul ignore if */
      if ("development" !== 'production' && el.attrsMap['v-for']) {
        warn$2(
          "Ambiguous combined usage of slot-scope and v-for on <" + (el.tag) + "> " +
          "(v-for takes higher priority). Use a wrapper <template> for the " +
          "scoped slot to make it clearer.",
          true
        );
      }
      el.slotScope = slotScope;
    }
    var slotTarget = getBindingAttr(el, 'slot');
    if (slotTarget) {
      el.slotTarget = slotTarget === '""' ? '"default"' : slotTarget;
      // preserve slot as an attribute for native shadow DOM compat
      // only for non-scoped slots.
      if (el.tag !== 'template' && !el.slotScope) {
        addAttr(el, 'slot', slotTarget);
      }
    }
  }
}

function processComponent (el) {
  var binding;
  if ((binding = getBindingAttr(el, 'is'))) {
    el.component = binding;
  }
  if (getAndRemoveAttr(el, 'inline-template') != null) {
    el.inlineTemplate = true;
  }
}

function processAttrs (el) {
  var list = el.attrsList;
  var i, l, name, rawName, value, modifiers, isProp;
  for (i = 0, l = list.length; i < l; i++) {
    name = rawName = list[i].name;
    value = list[i].value;
    if (dirRE.test(name)) {
      // mark element as dynamic
      el.hasBindings = true;
      // modifiers
      modifiers = parseModifiers(name);
      if (modifiers) {
        name = name.replace(modifierRE, '');
      }
      if (bindRE.test(name)) { // v-bind
        name = name.replace(bindRE, '');
        value = parseFilters(value);
        isProp = false;
        if (modifiers) {
          if (modifiers.prop) {
            isProp = true;
            name = camelize(name);
            if (name === 'innerHtml') { name = 'innerHTML'; }
          }
          if (modifiers.camel) {
            name = camelize(name);
          }
          if (modifiers.sync) {
            addHandler(
              el,
              ("update:" + (camelize(name))),
              genAssignmentCode(value, "$event")
            );
          }
        }
        if (isProp || (
          !el.component && platformMustUseProp(el.tag, el.attrsMap.type, name)
        )) {
          addProp(el, name, value);
        } else {
          addAttr(el, name, value);
        }
      } else if (onRE.test(name)) { // v-on
        name = name.replace(onRE, '');
        addHandler(el, name, value, modifiers, false, warn$2);
      } else { // normal directives
        name = name.replace(dirRE, '');
        // parse arg
        var argMatch = name.match(argRE);
        var arg = argMatch && argMatch[1];
        if (arg) {
          name = name.slice(0, -(arg.length + 1));
        }
        addDirective(el, name, rawName, value, arg, modifiers);
        if ("development" !== 'production' && name === 'model') {
          checkForAliasModel(el, value);
        }
      }
    } else {
      // literal attribute
      if (true) {
        var res = parseText(value, delimiters);
        if (res) {
          warn$2(
            name + "=\"" + value + "\": " +
            'Interpolation inside attributes has been removed. ' +
            'Use v-bind or the colon shorthand instead. For example, ' +
            'instead of <div id="{{ val }}">, use <div :id="val">.'
          );
        }
      }
      addAttr(el, name, JSON.stringify(value));
      // #6887 firefox doesn't update muted state if set via attribute
      // even immediately after element creation
      if (!el.component &&
          name === 'muted' &&
          platformMustUseProp(el.tag, el.attrsMap.type, name)) {
        addProp(el, name, 'true');
      }
    }
  }
}

function checkInFor (el) {
  var parent = el;
  while (parent) {
    if (parent.for !== undefined) {
      return true
    }
    parent = parent.parent;
  }
  return false
}

function parseModifiers (name) {
  var match = name.match(modifierRE);
  if (match) {
    var ret = {};
    match.forEach(function (m) { ret[m.slice(1)] = true; });
    return ret
  }
}

function makeAttrsMap (attrs) {
  var map = {};
  for (var i = 0, l = attrs.length; i < l; i++) {
    if (
      "development" !== 'production' &&
      map[attrs[i].name] && !isIE && !isEdge
    ) {
      warn$2('duplicate attribute: ' + attrs[i].name);
    }
    map[attrs[i].name] = attrs[i].value;
  }
  return map
}

// for script (e.g. type="x/template") or style, do not decode content
function isTextTag (el) {
  return el.tag === 'script' || el.tag === 'style'
}

function isForbiddenTag (el) {
  return (
    el.tag === 'style' ||
    (el.tag === 'script' && (
      !el.attrsMap.type ||
      el.attrsMap.type === 'text/javascript'
    ))
  )
}

var ieNSBug = /^xmlns:NS\d+/;
var ieNSPrefix = /^NS\d+:/;

/* istanbul ignore next */
function guardIESVGBug (attrs) {
  var res = [];
  for (var i = 0; i < attrs.length; i++) {
    var attr = attrs[i];
    if (!ieNSBug.test(attr.name)) {
      attr.name = attr.name.replace(ieNSPrefix, '');
      res.push(attr);
    }
  }
  return res
}

function checkForAliasModel (el, value) {
  var _el = el;
  while (_el) {
    if (_el.for && _el.alias === value) {
      warn$2(
        "<" + (el.tag) + " v-model=\"" + value + "\">: " +
        "You are binding v-model directly to a v-for iteration alias. " +
        "This will not be able to modify the v-for source array because " +
        "writing to the alias is like modifying a function local variable. " +
        "Consider using an array of objects and use v-model on an object property instead."
      );
    }
    _el = _el.parent;
  }
}

/*  */

/**
 * Expand input[v-model] with dyanmic type bindings into v-if-else chains
 * Turn this:
 *   <input v-model="data[type]" :type="type">
 * into this:
 *   <input v-if="type === 'checkbox'" type="checkbox" v-model="data[type]">
 *   <input v-else-if="type === 'radio'" type="radio" v-model="data[type]">
 *   <input v-else :type="type" v-model="data[type]">
 */

function preTransformNode (el, options) {
  if (el.tag === 'input') {
    var map = el.attrsMap;
    if (!map['v-model']) {
      return
    }

    var typeBinding;
    if (map[':type'] || map['v-bind:type']) {
      typeBinding = getBindingAttr(el, 'type');
    }
    if (!map.type && !typeBinding && map['v-bind']) {
      typeBinding = "(" + (map['v-bind']) + ").type";
    }

    if (typeBinding) {
      var ifCondition = getAndRemoveAttr(el, 'v-if', true);
      var ifConditionExtra = ifCondition ? ("&&(" + ifCondition + ")") : "";
      var hasElse = getAndRemoveAttr(el, 'v-else', true) != null;
      var elseIfCondition = getAndRemoveAttr(el, 'v-else-if', true);
      // 1. checkbox
      var branch0 = cloneASTElement(el);
      // process for on the main node
      processFor(branch0);
      addRawAttr(branch0, 'type', 'checkbox');
      processElement(branch0, options);
      branch0.processed = true; // prevent it from double-processed
      branch0.if = "(" + typeBinding + ")==='checkbox'" + ifConditionExtra;
      addIfCondition(branch0, {
        exp: branch0.if,
        block: branch0
      });
      // 2. add radio else-if condition
      var branch1 = cloneASTElement(el);
      getAndRemoveAttr(branch1, 'v-for', true);
      addRawAttr(branch1, 'type', 'radio');
      processElement(branch1, options);
      addIfCondition(branch0, {
        exp: "(" + typeBinding + ")==='radio'" + ifConditionExtra,
        block: branch1
      });
      // 3. other
      var branch2 = cloneASTElement(el);
      getAndRemoveAttr(branch2, 'v-for', true);
      addRawAttr(branch2, ':type', typeBinding);
      processElement(branch2, options);
      addIfCondition(branch0, {
        exp: ifCondition,
        block: branch2
      });

      if (hasElse) {
        branch0.else = true;
      } else if (elseIfCondition) {
        branch0.elseif = elseIfCondition;
      }

      return branch0
    }
  }
}

function cloneASTElement (el) {
  return createASTElement(el.tag, el.attrsList.slice(), el.parent)
}

var model$2 = {
  preTransformNode: preTransformNode
}

var modules$1 = [
  klass$1,
  style$1,
  model$2
]

/*  */

function text (el, dir) {
  if (dir.value) {
    addProp(el, 'textContent', ("_s(" + (dir.value) + ")"));
  }
}

/*  */

function html (el, dir) {
  if (dir.value) {
    addProp(el, 'innerHTML', ("_s(" + (dir.value) + ")"));
  }
}

var directives$1 = {
  model: model,
  text: text,
  html: html
}

/*  */

var baseOptions = {
  expectHTML: true,
  modules: modules$1,
  directives: directives$1,
  isPreTag: isPreTag,
  isUnaryTag: isUnaryTag,
  mustUseProp: mustUseProp,
  canBeLeftOpenTag: canBeLeftOpenTag,
  isReservedTag: isReservedTag,
  getTagNamespace: getTagNamespace,
  staticKeys: genStaticKeys(modules$1)
};

/*  */

var isStaticKey;
var isPlatformReservedTag;

var genStaticKeysCached = cached(genStaticKeys$1);

/**
 * Goal of the optimizer: walk the generated template AST tree
 * and detect sub-trees that are purely static, i.e. parts of
 * the DOM that never needs to change.
 *
 * Once we detect these sub-trees, we can:
 *
 * 1. Hoist them into constants, so that we no longer need to
 *    create fresh nodes for them on each re-render;
 * 2. Completely skip them in the patching process.
 */
function optimize (root, options) {
  if (!root) { return }
  isStaticKey = genStaticKeysCached(options.staticKeys || '');
  isPlatformReservedTag = options.isReservedTag || no;
  // first pass: mark all non-static nodes.
  markStatic$1(root);
  // second pass: mark static roots.
  markStaticRoots(root, false);
}

function genStaticKeys$1 (keys) {
  return makeMap(
    'type,tag,attrsList,attrsMap,plain,parent,children,attrs' +
    (keys ? ',' + keys : '')
  )
}

function markStatic$1 (node) {
  node.static = isStatic(node);
  if (node.type === 1) {
    // do not make component slot content static. this avoids
    // 1. components not able to mutate slot nodes
    // 2. static slot content fails for hot-reloading
    if (
      !isPlatformReservedTag(node.tag) &&
      node.tag !== 'slot' &&
      node.attrsMap['inline-template'] == null
    ) {
      return
    }
    for (var i = 0, l = node.children.length; i < l; i++) {
      var child = node.children[i];
      markStatic$1(child);
      if (!child.static) {
        node.static = false;
      }
    }
    if (node.ifConditions) {
      for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {
        var block = node.ifConditions[i$1].block;
        markStatic$1(block);
        if (!block.static) {
          node.static = false;
        }
      }
    }
  }
}

function markStaticRoots (node, isInFor) {
  if (node.type === 1) {
    if (node.static || node.once) {
      node.staticInFor = isInFor;
    }
    // For a node to qualify as a static root, it should have children that
    // are not just static text. Otherwise the cost of hoisting out will
    // outweigh the benefits and it's better off to just always render it fresh.
    if (node.static && node.children.length && !(
      node.children.length === 1 &&
      node.children[0].type === 3
    )) {
      node.staticRoot = true;
      return
    } else {
      node.staticRoot = false;
    }
    if (node.children) {
      for (var i = 0, l = node.children.length; i < l; i++) {
        markStaticRoots(node.children[i], isInFor || !!node.for);
      }
    }
    if (node.ifConditions) {
      for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {
        markStaticRoots(node.ifConditions[i$1].block, isInFor);
      }
    }
  }
}

function isStatic (node) {
  if (node.type === 2) { // expression
    return false
  }
  if (node.type === 3) { // text
    return true
  }
  return !!(node.pre || (
    !node.hasBindings && // no dynamic bindings
    !node.if && !node.for && // not v-if or v-for or v-else
    !isBuiltInTag(node.tag) && // not a built-in
    isPlatformReservedTag(node.tag) && // not a component
    !isDirectChildOfTemplateFor(node) &&
    Object.keys(node).every(isStaticKey)
  ))
}

function isDirectChildOfTemplateFor (node) {
  while (node.parent) {
    node = node.parent;
    if (node.tag !== 'template') {
      return false
    }
    if (node.for) {
      return true
    }
  }
  return false
}

/*  */

var fnExpRE = /^([\w$_]+|\([^)]*?\))\s*=>|^function\s*\(/;
var simplePathRE = /^[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['[^']*?']|\["[^"]*?"]|\[\d+]|\[[A-Za-z_$][\w$]*])*$/;

// KeyboardEvent.keyCode aliases
var keyCodes = {
  esc: 27,
  tab: 9,
  enter: 13,
  space: 32,
  up: 38,
  left: 37,
  right: 39,
  down: 40,
  'delete': [8, 46]
};

// KeyboardEvent.key aliases
var keyNames = {
  esc: 'Escape',
  tab: 'Tab',
  enter: 'Enter',
  space: ' ',
  // #7806: IE11 uses key names without `Arrow` prefix for arrow keys.
  up: ['Up', 'ArrowUp'],
  left: ['Left', 'ArrowLeft'],
  right: ['Right', 'ArrowRight'],
  down: ['Down', 'ArrowDown'],
  'delete': ['Backspace', 'Delete']
};

// #4868: modifiers that prevent the execution of the listener
// need to explicitly return null so that we can determine whether to remove
// the listener for .once
var genGuard = function (condition) { return ("if(" + condition + ")return null;"); };

var modifierCode = {
  stop: '$event.stopPropagation();',
  prevent: '$event.preventDefault();',
  self: genGuard("$event.target !== $event.currentTarget"),
  ctrl: genGuard("!$event.ctrlKey"),
  shift: genGuard("!$event.shiftKey"),
  alt: genGuard("!$event.altKey"),
  meta: genGuard("!$event.metaKey"),
  left: genGuard("'button' in $event && $event.button !== 0"),
  middle: genGuard("'button' in $event && $event.button !== 1"),
  right: genGuard("'button' in $event && $event.button !== 2")
};

function genHandlers (
  events,
  isNative,
  warn
) {
  var res = isNative ? 'nativeOn:{' : 'on:{';
  for (var name in events) {
    res += "\"" + name + "\":" + (genHandler(name, events[name])) + ",";
  }
  return res.slice(0, -1) + '}'
}

function genHandler (
  name,
  handler
) {
  if (!handler) {
    return 'function(){}'
  }

  if (Array.isArray(handler)) {
    return ("[" + (handler.map(function (handler) { return genHandler(name, handler); }).join(',')) + "]")
  }

  var isMethodPath = simplePathRE.test(handler.value);
  var isFunctionExpression = fnExpRE.test(handler.value);

  if (!handler.modifiers) {
    if (isMethodPath || isFunctionExpression) {
      return handler.value
    }
    /* istanbul ignore if */
    return ("function($event){" + (handler.value) + "}") // inline statement
  } else {
    var code = '';
    var genModifierCode = '';
    var keys = [];
    for (var key in handler.modifiers) {
      if (modifierCode[key]) {
        genModifierCode += modifierCode[key];
        // left/right
        if (keyCodes[key]) {
          keys.push(key);
        }
      } else if (key === 'exact') {
        var modifiers = (handler.modifiers);
        genModifierCode += genGuard(
          ['ctrl', 'shift', 'alt', 'meta']
            .filter(function (keyModifier) { return !modifiers[keyModifier]; })
            .map(function (keyModifier) { return ("$event." + keyModifier + "Key"); })
            .join('||')
        );
      } else {
        keys.push(key);
      }
    }
    if (keys.length) {
      code += genKeyFilter(keys);
    }
    // Make sure modifiers like prevent and stop get executed after key filtering
    if (genModifierCode) {
      code += genModifierCode;
    }
    var handlerCode = isMethodPath
      ? ("return " + (handler.value) + "($event)")
      : isFunctionExpression
        ? ("return (" + (handler.value) + ")($event)")
        : handler.value;
    /* istanbul ignore if */
    return ("function($event){" + code + handlerCode + "}")
  }
}

function genKeyFilter (keys) {
  return ("if(!('button' in $event)&&" + (keys.map(genFilterCode).join('&&')) + ")return null;")
}

function genFilterCode (key) {
  var keyVal = parseInt(key, 10);
  if (keyVal) {
    return ("$event.keyCode!==" + keyVal)
  }
  var keyCode = keyCodes[key];
  var keyName = keyNames[key];
  return (
    "_k($event.keyCode," +
    (JSON.stringify(key)) + "," +
    (JSON.stringify(keyCode)) + "," +
    "$event.key," +
    "" + (JSON.stringify(keyName)) +
    ")"
  )
}

/*  */

function on (el, dir) {
  if ("development" !== 'production' && dir.modifiers) {
    warn("v-on without argument does not support modifiers.");
  }
  el.wrapListeners = function (code) { return ("_g(" + code + "," + (dir.value) + ")"); };
}

/*  */

function bind$1 (el, dir) {
  el.wrapData = function (code) {
    return ("_b(" + code + ",'" + (el.tag) + "'," + (dir.value) + "," + (dir.modifiers && dir.modifiers.prop ? 'true' : 'false') + (dir.modifiers && dir.modifiers.sync ? ',true' : '') + ")")
  };
}

/*  */

var baseDirectives = {
  on: on,
  bind: bind$1,
  cloak: noop
}

/*  */

var CodegenState = function CodegenState (options) {
  this.options = options;
  this.warn = options.warn || baseWarn;
  this.transforms = pluckModuleFunction(options.modules, 'transformCode');
  this.dataGenFns = pluckModuleFunction(options.modules, 'genData');
  this.directives = extend(extend({}, baseDirectives), options.directives);
  var isReservedTag = options.isReservedTag || no;
  this.maybeComponent = function (el) { return !isReservedTag(el.tag); };
  this.onceId = 0;
  this.staticRenderFns = [];
};



function generate (
  ast,
  options
) {
  var state = new CodegenState(options);
  var code = ast ? genElement(ast, state) : '_c("div")';
  return {
    render: ("with(this){return " + code + "}"),
    staticRenderFns: state.staticRenderFns
  }
}

function genElement (el, state) {
  if (el.staticRoot && !el.staticProcessed) {
    return genStatic(el, state)
  } else if (el.once && !el.onceProcessed) {
    return genOnce(el, state)
  } else if (el.for && !el.forProcessed) {
    return genFor(el, state)
  } else if (el.if && !el.ifProcessed) {
    return genIf(el, state)
  } else if (el.tag === 'template' && !el.slotTarget) {
    return genChildren(el, state) || 'void 0'
  } else if (el.tag === 'slot') {
    return genSlot(el, state)
  } else {
    // component or element
    var code;
    if (el.component) {
      code = genComponent(el.component, el, state);
    } else {
      var data = el.plain ? undefined : genData$2(el, state);

      var children = el.inlineTemplate ? null : genChildren(el, state, true);
      code = "_c('" + (el.tag) + "'" + (data ? ("," + data) : '') + (children ? ("," + children) : '') + ")";
    }
    // module transforms
    for (var i = 0; i < state.transforms.length; i++) {
      code = state.transforms[i](el, code);
    }
    return code
  }
}

// hoist static sub-trees out
function genStatic (el, state) {
  el.staticProcessed = true;
  state.staticRenderFns.push(("with(this){return " + (genElement(el, state)) + "}"));
  return ("_m(" + (state.staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + ")")
}

// v-once
function genOnce (el, state) {
  el.onceProcessed = true;
  if (el.if && !el.ifProcessed) {
    return genIf(el, state)
  } else if (el.staticInFor) {
    var key = '';
    var parent = el.parent;
    while (parent) {
      if (parent.for) {
        key = parent.key;
        break
      }
      parent = parent.parent;
    }
    if (!key) {
      "development" !== 'production' && state.warn(
        "v-once can only be used inside v-for that is keyed. "
      );
      return genElement(el, state)
    }
    return ("_o(" + (genElement(el, state)) + "," + (state.onceId++) + "," + key + ")")
  } else {
    return genStatic(el, state)
  }
}

function genIf (
  el,
  state,
  altGen,
  altEmpty
) {
  el.ifProcessed = true; // avoid recursion
  return genIfConditions(el.ifConditions.slice(), state, altGen, altEmpty)
}

function genIfConditions (
  conditions,
  state,
  altGen,
  altEmpty
) {
  if (!conditions.length) {
    return altEmpty || '_e()'
  }

  var condition = conditions.shift();
  if (condition.exp) {
    return ("(" + (condition.exp) + ")?" + (genTernaryExp(condition.block)) + ":" + (genIfConditions(conditions, state, altGen, altEmpty)))
  } else {
    return ("" + (genTernaryExp(condition.block)))
  }

  // v-if with v-once should generate code like (a)?_m(0):_m(1)
  function genTernaryExp (el) {
    return altGen
      ? altGen(el, state)
      : el.once
        ? genOnce(el, state)
        : genElement(el, state)
  }
}

function genFor (
  el,
  state,
  altGen,
  altHelper
) {
  var exp = el.for;
  var alias = el.alias;
  var iterator1 = el.iterator1 ? ("," + (el.iterator1)) : '';
  var iterator2 = el.iterator2 ? ("," + (el.iterator2)) : '';

  if ("development" !== 'production' &&
    state.maybeComponent(el) &&
    el.tag !== 'slot' &&
    el.tag !== 'template' &&
    !el.key
  ) {
    state.warn(
      "<" + (el.tag) + " v-for=\"" + alias + " in " + exp + "\">: component lists rendered with " +
      "v-for should have explicit keys. " +
      "See https://vuejs.org/guide/list.html#key for more info.",
      true /* tip */
    );
  }

  el.forProcessed = true; // avoid recursion
  return (altHelper || '_l') + "((" + exp + ")," +
    "function(" + alias + iterator1 + iterator2 + "){" +
      "return " + ((altGen || genElement)(el, state)) +
    '})'
}

function genData$2 (el, state) {
  var data = '{';

  // directives first.
  // directives may mutate the el's other properties before they are generated.
  var dirs = genDirectives(el, state);
  if (dirs) { data += dirs + ','; }

  // key
  if (el.key) {
    data += "key:" + (el.key) + ",";
  }
  // ref
  if (el.ref) {
    data += "ref:" + (el.ref) + ",";
  }
  if (el.refInFor) {
    data += "refInFor:true,";
  }
  // pre
  if (el.pre) {
    data += "pre:true,";
  }
  // record original tag name for components using "is" attribute
  if (el.component) {
    data += "tag:\"" + (el.tag) + "\",";
  }
  // module data generation functions
  for (var i = 0; i < state.dataGenFns.length; i++) {
    data += state.dataGenFns[i](el);
  }
  // attributes
  if (el.attrs) {
    data += "attrs:{" + (genProps(el.attrs)) + "},";
  }
  // DOM props
  if (el.props) {
    data += "domProps:{" + (genProps(el.props)) + "},";
  }
  // event handlers
  if (el.events) {
    data += (genHandlers(el.events, false, state.warn)) + ",";
  }
  if (el.nativeEvents) {
    data += (genHandlers(el.nativeEvents, true, state.warn)) + ",";
  }
  // slot target
  // only for non-scoped slots
  if (el.slotTarget && !el.slotScope) {
    data += "slot:" + (el.slotTarget) + ",";
  }
  // scoped slots
  if (el.scopedSlots) {
    data += (genScopedSlots(el.scopedSlots, state)) + ",";
  }
  // component v-model
  if (el.model) {
    data += "model:{value:" + (el.model.value) + ",callback:" + (el.model.callback) + ",expression:" + (el.model.expression) + "},";
  }
  // inline-template
  if (el.inlineTemplate) {
    var inlineTemplate = genInlineTemplate(el, state);
    if (inlineTemplate) {
      data += inlineTemplate + ",";
    }
  }
  data = data.replace(/,$/, '') + '}';
  // v-bind data wrap
  if (el.wrapData) {
    data = el.wrapData(data);
  }
  // v-on data wrap
  if (el.wrapListeners) {
    data = el.wrapListeners(data);
  }
  return data
}

function genDirectives (el, state) {
  var dirs = el.directives;
  if (!dirs) { return }
  var res = 'directives:[';
  var hasRuntime = false;
  var i, l, dir, needRuntime;
  for (i = 0, l = dirs.length; i < l; i++) {
    dir = dirs[i];
    needRuntime = true;
    var gen = state.directives[dir.name];
    if (gen) {
      // compile-time directive that manipulates AST.
      // returns true if it also needs a runtime counterpart.
      needRuntime = !!gen(el, dir, state.warn);
    }
    if (needRuntime) {
      hasRuntime = true;
      res += "{name:\"" + (dir.name) + "\",rawName:\"" + (dir.rawName) + "\"" + (dir.value ? (",value:(" + (dir.value) + "),expression:" + (JSON.stringify(dir.value))) : '') + (dir.arg ? (",arg:\"" + (dir.arg) + "\"") : '') + (dir.modifiers ? (",modifiers:" + (JSON.stringify(dir.modifiers))) : '') + "},";
    }
  }
  if (hasRuntime) {
    return res.slice(0, -1) + ']'
  }
}

function genInlineTemplate (el, state) {
  var ast = el.children[0];
  if ("development" !== 'production' && (
    el.children.length !== 1 || ast.type !== 1
  )) {
    state.warn('Inline-template components must have exactly one child element.');
  }
  if (ast.type === 1) {
    var inlineRenderFns = generate(ast, state.options);
    return ("inlineTemplate:{render:function(){" + (inlineRenderFns.render) + "},staticRenderFns:[" + (inlineRenderFns.staticRenderFns.map(function (code) { return ("function(){" + code + "}"); }).join(',')) + "]}")
  }
}

function genScopedSlots (
  slots,
  state
) {
  return ("scopedSlots:_u([" + (Object.keys(slots).map(function (key) {
      return genScopedSlot(key, slots[key], state)
    }).join(',')) + "])")
}

function genScopedSlot (
  key,
  el,
  state
) {
  if (el.for && !el.forProcessed) {
    return genForScopedSlot(key, el, state)
  }
  var fn = "function(" + (String(el.slotScope)) + "){" +
    "return " + (el.tag === 'template'
      ? el.if
        ? ((el.if) + "?" + (genChildren(el, state) || 'undefined') + ":undefined")
        : genChildren(el, state) || 'undefined'
      : genElement(el, state)) + "}";
  return ("{key:" + key + ",fn:" + fn + "}")
}

function genForScopedSlot (
  key,
  el,
  state
) {
  var exp = el.for;
  var alias = el.alias;
  var iterator1 = el.iterator1 ? ("," + (el.iterator1)) : '';
  var iterator2 = el.iterator2 ? ("," + (el.iterator2)) : '';
  el.forProcessed = true; // avoid recursion
  return "_l((" + exp + ")," +
    "function(" + alias + iterator1 + iterator2 + "){" +
      "return " + (genScopedSlot(key, el, state)) +
    '})'
}

function genChildren (
  el,
  state,
  checkSkip,
  altGenElement,
  altGenNode
) {
  var children = el.children;
  if (children.length) {
    var el$1 = children[0];
    // optimize single v-for
    if (children.length === 1 &&
      el$1.for &&
      el$1.tag !== 'template' &&
      el$1.tag !== 'slot'
    ) {
      return (altGenElement || genElement)(el$1, state)
    }
    var normalizationType = checkSkip
      ? getNormalizationType(children, state.maybeComponent)
      : 0;
    var gen = altGenNode || genNode;
    return ("[" + (children.map(function (c) { return gen(c, state); }).join(',')) + "]" + (normalizationType ? ("," + normalizationType) : ''))
  }
}

// determine the normalization needed for the children array.
// 0: no normalization needed
// 1: simple normalization needed (possible 1-level deep nested array)
// 2: full normalization needed
function getNormalizationType (
  children,
  maybeComponent
) {
  var res = 0;
  for (var i = 0; i < children.length; i++) {
    var el = children[i];
    if (el.type !== 1) {
      continue
    }
    if (needsNormalization(el) ||
        (el.ifConditions && el.ifConditions.some(function (c) { return needsNormalization(c.block); }))) {
      res = 2;
      break
    }
    if (maybeComponent(el) ||
        (el.ifConditions && el.ifConditions.some(function (c) { return maybeComponent(c.block); }))) {
      res = 1;
    }
  }
  return res
}

function needsNormalization (el) {
  return el.for !== undefined || el.tag === 'template' || el.tag === 'slot'
}

function genNode (node, state) {
  if (node.type === 1) {
    return genElement(node, state)
  } if (node.type === 3 && node.isComment) {
    return genComment(node)
  } else {
    return genText(node)
  }
}

function genText (text) {
  return ("_v(" + (text.type === 2
    ? text.expression // no need for () because already wrapped in _s()
    : transformSpecialNewlines(JSON.stringify(text.text))) + ")")
}

function genComment (comment) {
  return ("_e(" + (JSON.stringify(comment.text)) + ")")
}

function genSlot (el, state) {
  var slotName = el.slotName || '"default"';
  var children = genChildren(el, state);
  var res = "_t(" + slotName + (children ? ("," + children) : '');
  var attrs = el.attrs && ("{" + (el.attrs.map(function (a) { return ((camelize(a.name)) + ":" + (a.value)); }).join(',')) + "}");
  var bind$$1 = el.attrsMap['v-bind'];
  if ((attrs || bind$$1) && !children) {
    res += ",null";
  }
  if (attrs) {
    res += "," + attrs;
  }
  if (bind$$1) {
    res += (attrs ? '' : ',null') + "," + bind$$1;
  }
  return res + ')'
}

// componentName is el.component, take it as argument to shun flow's pessimistic refinement
function genComponent (
  componentName,
  el,
  state
) {
  var children = el.inlineTemplate ? null : genChildren(el, state, true);
  return ("_c(" + componentName + "," + (genData$2(el, state)) + (children ? ("," + children) : '') + ")")
}

function genProps (props) {
  var res = '';
  for (var i = 0; i < props.length; i++) {
    var prop = props[i];
    /* istanbul ignore if */
    {
      res += "\"" + (prop.name) + "\":" + (transformSpecialNewlines(prop.value)) + ",";
    }
  }
  return res.slice(0, -1)
}

// #3895, #4268
function transformSpecialNewlines (text) {
  return text
    .replace(/\u2028/g, '\\u2028')
    .replace(/\u2029/g, '\\u2029')
}

/*  */

// these keywords should not appear inside expressions, but operators like
// typeof, instanceof and in are allowed
var prohibitedKeywordRE = new RegExp('\\b' + (
  'do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' +
  'super,throw,while,yield,delete,export,import,return,switch,default,' +
  'extends,finally,continue,debugger,function,arguments'
).split(',').join('\\b|\\b') + '\\b');

// these unary operators should not be used as property/method names
var unaryOperatorsRE = new RegExp('\\b' + (
  'delete,typeof,void'
).split(',').join('\\s*\\([^\\)]*\\)|\\b') + '\\s*\\([^\\)]*\\)');

// strip strings in expressions
var stripStringRE = /'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`/g;

// detect problematic expressions in a template
function detectErrors (ast) {
  var errors = [];
  if (ast) {
    checkNode(ast, errors);
  }
  return errors
}

function checkNode (node, errors) {
  if (node.type === 1) {
    for (var name in node.attrsMap) {
      if (dirRE.test(name)) {
        var value = node.attrsMap[name];
        if (value) {
          if (name === 'v-for') {
            checkFor(node, ("v-for=\"" + value + "\""), errors);
          } else if (onRE.test(name)) {
            checkEvent(value, (name + "=\"" + value + "\""), errors);
          } else {
            checkExpression(value, (name + "=\"" + value + "\""), errors);
          }
        }
      }
    }
    if (node.children) {
      for (var i = 0; i < node.children.length; i++) {
        checkNode(node.children[i], errors);
      }
    }
  } else if (node.type === 2) {
    checkExpression(node.expression, node.text, errors);
  }
}

function checkEvent (exp, text, errors) {
  var stipped = exp.replace(stripStringRE, '');
  var keywordMatch = stipped.match(unaryOperatorsRE);
  if (keywordMatch && stipped.charAt(keywordMatch.index - 1) !== '$') {
    errors.push(
      "avoid using JavaScript unary operator as property name: " +
      "\"" + (keywordMatch[0]) + "\" in expression " + (text.trim())
    );
  }
  checkExpression(exp, text, errors);
}

function checkFor (node, text, errors) {
  checkExpression(node.for || '', text, errors);
  checkIdentifier(node.alias, 'v-for alias', text, errors);
  checkIdentifier(node.iterator1, 'v-for iterator', text, errors);
  checkIdentifier(node.iterator2, 'v-for iterator', text, errors);
}

function checkIdentifier (
  ident,
  type,
  text,
  errors
) {
  if (typeof ident === 'string') {
    try {
      new Function(("var " + ident + "=_"));
    } catch (e) {
      errors.push(("invalid " + type + " \"" + ident + "\" in expression: " + (text.trim())));
    }
  }
}

function checkExpression (exp, text, errors) {
  try {
    new Function(("return " + exp));
  } catch (e) {
    var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);
    if (keywordMatch) {
      errors.push(
        "avoid using JavaScript keyword as property name: " +
        "\"" + (keywordMatch[0]) + "\"\n  Raw expression: " + (text.trim())
      );
    } else {
      errors.push(
        "invalid expression: " + (e.message) + " in\n\n" +
        "    " + exp + "\n\n" +
        "  Raw expression: " + (text.trim()) + "\n"
      );
    }
  }
}

/*  */

function createFunction (code, errors) {
  try {
    return new Function(code)
  } catch (err) {
    errors.push({ err: err, code: code });
    return noop
  }
}

function createCompileToFunctionFn (compile) {
  var cache = Object.create(null);

  return function compileToFunctions (
    template,
    options,
    vm
  ) {
    options = extend({}, options);
    var warn$$1 = options.warn || warn;
    delete options.warn;

    /* istanbul ignore if */
    if (true) {
      // detect possible CSP restriction
      try {
        new Function('return 1');
      } catch (e) {
        if (e.toString().match(/unsafe-eval|CSP/)) {
          warn$$1(
            'It seems you are using the standalone build of Vue.js in an ' +
            'environment with Content Security Policy that prohibits unsafe-eval. ' +
            'The template compiler cannot work in this environment. Consider ' +
            'relaxing the policy to allow unsafe-eval or pre-compiling your ' +
            'templates into render functions.'
          );
        }
      }
    }

    // check cache
    var key = options.delimiters
      ? String(options.delimiters) + template
      : template;
    if (cache[key]) {
      return cache[key]
    }

    // compile
    var compiled = compile(template, options);

    // check compilation errors/tips
    if (true) {
      if (compiled.errors && compiled.errors.length) {
        warn$$1(
          "Error compiling template:\n\n" + template + "\n\n" +
          compiled.errors.map(function (e) { return ("- " + e); }).join('\n') + '\n',
          vm
        );
      }
      if (compiled.tips && compiled.tips.length) {
        compiled.tips.forEach(function (msg) { return tip(msg, vm); });
      }
    }

    // turn code into functions
    var res = {};
    var fnGenErrors = [];
    res.render = createFunction(compiled.render, fnGenErrors);
    res.staticRenderFns = compiled.staticRenderFns.map(function (code) {
      return createFunction(code, fnGenErrors)
    });

    // check function generation errors.
    // this should only happen if there is a bug in the compiler itself.
    // mostly for codegen development use
    /* istanbul ignore if */
    if (true) {
      if ((!compiled.errors || !compiled.errors.length) && fnGenErrors.length) {
        warn$$1(
          "Failed to generate render function:\n\n" +
          fnGenErrors.map(function (ref) {
            var err = ref.err;
            var code = ref.code;

            return ((err.toString()) + " in\n\n" + code + "\n");
        }).join('\n'),
          vm
        );
      }
    }

    return (cache[key] = res)
  }
}

/*  */

function createCompilerCreator (baseCompile) {
  return function createCompiler (baseOptions) {
    function compile (
      template,
      options
    ) {
      var finalOptions = Object.create(baseOptions);
      var errors = [];
      var tips = [];
      finalOptions.warn = function (msg, tip) {
        (tip ? tips : errors).push(msg);
      };

      if (options) {
        // merge custom modules
        if (options.modules) {
          finalOptions.modules =
            (baseOptions.modules || []).concat(options.modules);
        }
        // merge custom directives
        if (options.directives) {
          finalOptions.directives = extend(
            Object.create(baseOptions.directives || null),
            options.directives
          );
        }
        // copy other options
        for (var key in options) {
          if (key !== 'modules' && key !== 'directives') {
            finalOptions[key] = options[key];
          }
        }
      }

      var compiled = baseCompile(template, finalOptions);
      if (true) {
        errors.push.apply(errors, detectErrors(compiled.ast));
      }
      compiled.errors = errors;
      compiled.tips = tips;
      return compiled
    }

    return {
      compile: compile,
      compileToFunctions: createCompileToFunctionFn(compile)
    }
  }
}

/*  */

// `createCompilerCreator` allows creating compilers that use alternative
// parser/optimizer/codegen, e.g the SSR optimizing compiler.
// Here we just export a default compiler using the default parts.
var createCompiler = createCompilerCreator(function baseCompile (
  template,
  options
) {
  var ast = parse(template.trim(), options);
  if (options.optimize !== false) {
    optimize(ast, options);
  }
  var code = generate(ast, options);
  return {
    ast: ast,
    render: code.render,
    staticRenderFns: code.staticRenderFns
  }
});

/*  */

var ref$1 = createCompiler(baseOptions);
var compileToFunctions = ref$1.compileToFunctions;

/*  */

// check whether current browser encodes a char inside attribute values
var div;
function getShouldDecode (href) {
  div = div || document.createElement('div');
  div.innerHTML = href ? "<a href=\"\n\"/>" : "<div a=\"\n\"/>";
  return div.innerHTML.indexOf('&#10;') > 0
}

// #3663: IE encodes newlines inside attribute values while other browsers don't
var shouldDecodeNewlines = inBrowser ? getShouldDecode(false) : false;
// #6828: chrome encodes content in a[href]
var shouldDecodeNewlinesForHref = inBrowser ? getShouldDecode(true) : false;

/*  */

var idToTemplate = cached(function (id) {
  var el = query(id);
  return el && el.innerHTML
});

var mount = Vue.prototype.$mount;
Vue.prototype.$mount = function (
  el,
  hydrating
) {
  el = el && query(el);

  /* istanbul ignore if */
  if (el === document.body || el === document.documentElement) {
    "development" !== 'production' && warn(
      "Do not mount Vue to <html> or <body> - mount to normal elements instead."
    );
    return this
  }

  var options = this.$options;
  // resolve template/el and convert to render function
  if (!options.render) {
    var template = options.template;
    if (template) {
      if (typeof template === 'string') {
        if (template.charAt(0) === '#') {
          template = idToTemplate(template);
          /* istanbul ignore if */
          if ("development" !== 'production' && !template) {
            warn(
              ("Template element not found or is empty: " + (options.template)),
              this
            );
          }
        }
      } else if (template.nodeType) {
        template = template.innerHTML;
      } else {
        if (true) {
          warn('invalid template option:' + template, this);
        }
        return this
      }
    } else if (el) {
      template = getOuterHTML(el);
    }
    if (template) {
      /* istanbul ignore if */
      if ("development" !== 'production' && config.performance && mark) {
        mark('compile');
      }

      var ref = compileToFunctions(template, {
        shouldDecodeNewlines: shouldDecodeNewlines,
        shouldDecodeNewlinesForHref: shouldDecodeNewlinesForHref,
        delimiters: options.delimiters,
        comments: options.comments
      }, this);
      var render = ref.render;
      var staticRenderFns = ref.staticRenderFns;
      options.render = render;
      options.staticRenderFns = staticRenderFns;

      /* istanbul ignore if */
      if ("development" !== 'production' && config.performance && mark) {
        mark('compile end');
        measure(("vue " + (this._name) + " compile"), 'compile', 'compile end');
      }
    }
  }
  return mount.call(this, el, hydrating)
};

/**
 * Get outerHTML of elements, taking care
 * of SVG elements in IE as well.
 */
function getOuterHTML (el) {
  if (el.outerHTML) {
    return el.outerHTML
  } else {
    var container = document.createElement('div');
    container.appendChild(el.cloneNode(true));
    return container.innerHTML
  }
}

Vue.compile = compileToFunctions;

module.exports = Vue;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__("./node_modules/webpack/buildin/global.js"), __webpack_require__("./node_modules/timers-browserify/main.js").setImmediate))

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "./resources/assets/js/login.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_vue__ = __webpack_require__("./node_modules/vue/dist/vue.common.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_framework7_dist_framework7_esm_bundle_js__ = __webpack_require__("./node_modules/framework7/dist/framework7.esm.bundle.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_framework7_vue_dist_framework7_vue_esm_bundle_js__ = __webpack_require__("./node_modules/framework7-vue/dist/framework7-vue.esm.bundle.js");
// require('./bootstrap');




__WEBPACK_IMPORTED_MODULE_0_vue___default.a.use(__WEBPACK_IMPORTED_MODULE_2_framework7_vue_dist_framework7_vue_esm_bundle_js__["a" /* default */], __WEBPACK_IMPORTED_MODULE_1_framework7_dist_framework7_esm_bundle_js__["a" /* default */]);

var app = new __WEBPACK_IMPORTED_MODULE_0_vue___default.a({
    el: '#app',
    framework7: {
        root: '#app',
        id: 'move-app',
        name: 'Move',
        theme: 'ios'
        // routes: routes,
    }
});

/***/ }),

/***/ 1:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__("./resources/assets/js/login.js");


/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgNDkwMDRmMDQwNTExNWNiYzU4ZjMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RvbTcvZGlzdC9kb203Lm1vZHVsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZnJhbWV3b3JrNy12dWUvZGlzdC9mcmFtZXdvcms3LXZ1ZS5lc20uYnVuZGxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mcmFtZXdvcms3L2Rpc3QvZnJhbWV3b3JrNy5lc20uYnVuZGxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mcmFtZXdvcms3L25vZGVfbW9kdWxlcy9wYXRoLXRvLXJlZ2V4cC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zZXRpbW1lZGlhdGUvc2V0SW1tZWRpYXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zc3Itd2luZG93L2Rpc3Qvc3NyLXdpbmRvdy5lc20uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3RlbXBsYXRlNy9kaXN0L3RlbXBsYXRlNy5lc20uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3RpbWVycy1icm93c2VyaWZ5L21haW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Z1ZS9kaXN0L3Z1ZS5jb21tb24uanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qcyIsIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvYXNzZXRzL2pzL2xvZ2luLmpzIl0sIm5hbWVzIjpbIlZ1ZSIsInVzZSIsImFwcCIsImVsIiwiZnJhbWV3b3JrNyIsInJvb3QiLCJpZCIsIm5hbWUiLCJ0aGVtZSJdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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UTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsbUJBQW1CO0FBQ3BDO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtQkFBbUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1CQUFtQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1CQUFtQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUJBQW1CO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Es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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlDQUFpQztBQUNwRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQix1QkFBdUI7QUFDeEM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLGdCQUFnQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQzs7QUFFRDs7Ozs7Ozs7O0FDOTZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNB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QUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLFdBQVcsMkJBQTJCOztBQUV0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBLDBCQUEwQixtQkFBbUIsYUFBYSwwQkFBMEIsd0JBQXdCLGlCQUFpQix1REFBdUQsd0JBQXdCO0FBQzVNO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsK0NBQStDLCtCQUErQjtBQUM1SDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7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LE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtB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QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLEtBQUssR0FBRyxPQUFPO0FBQ3REO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLGVBQWU7QUFDM0QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNULE9BQU87O0FBRVA7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsK0JBQStCO0FBQzdELDhCQUE4QiwrQkFBK0I7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQsbUJBQW1CLG1CQUFtQixhQUFhLDBCQUEwQix3QkFBd0Isa0JBQWtCLGtEQUFrRCxnQ0FBZ0MsaUJBQWlCLDRDQUE0QyxpQkFBaUIsVUFBVSxFQUFFLDZCQUE2Qiw4QkFBOEIsYUFBYSxrQ0FBa0MsMkRBQTJELDhCQUE4QixhQUFhLDBCQUEwQix3QkFBd0Isa0JBQWtCLG1DQUFtQyxhQUFhLDBDQUEwQyxJQUFJLFlBQVksYUFBYSwwQkFBMEIsd0JBQXdCLGtCQUFrQixvQ0FBb0MsYUFBYSwwQ0FBMEMsSUFBSTtBQUNqMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFdBQVc7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBLCtDQUErQyxnQkFBZ0I7QUFDL0QseURBQXlELGdCQUFnQjtBQUN6RSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUwsMkJBQTJCLDRCQUE0Qjs7QUFFdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxLQUFLO0FBQ25EO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTCxrQ0FBa0Msc0NBQXNDOztBQUV4RTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFD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QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxLQUFLO0FBQ2pEO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7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Q0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyw0Q0FBNEMsR0FBRyxZQUFZO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDOztBQUV4QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHVCQUF1QjtBQUNsRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixtQkFBbUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLDhCQUE4QjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QixvQkFBb0IsVUFBVSxHQUFHLCtCQUErQjtBQUNoRSxvQkFBb0IsVUFBVSxHQUFHLHFDQUFxQztBQUN0RTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsUUFBUTtBQUN6Qyw2Q0FBNkMsRUFBRTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNHQUFvRDtBQUNwRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscURBQXFELGdCQUFnQjtBQUNyRSxvREFBb0QsaUJBQWlCOztBQUVyRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFD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QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxpQkFBaUIsNkJBQTZCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsa0JBQWtCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyw2RUFBNkU7O0FBRXRGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQ0FBaUMsU0FBUyxpQkFBaUIsRUFBRTtBQUM3RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsMkRBQTJELFNBQVM7QUFDcEUsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxZQUFZO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QixLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUVBQWlFLFFBQVE7QUFDekUsR0FBRztBQUNILDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsbUJBQW1CLDRDQUE0QztBQUMvRDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxVQUFVLHVCQUF1QjtBQUMzRTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxZQUFZO0FBQ2pFLG1DQUFtQyxZQUFZO0FBQy9DLEdBQUc7QUFDSCxlQUFlLHFCQUFxQixJQUFJLFlBQVk7QUFDcEQsR0FBRztBQUNILGdCQUFnQixZQUFZO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVILFNBQVMsZ0RBQWdEOztBQUV6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG1FQUFtRTtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsdUNBQXVDO0FBQ3REO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFEQUFxRDtBQUNyRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLEdBQUc7O0FBRUgscUNBQXFDO0FBQ3JDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSwyQkFBMkIsd0JBQXdCO0FBQ25ELHNDQUFzQyxVQUFVO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJEQUEyRCxRQUFRO0FBQ25FOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCLHdCQUF3QixRQUFRLHdCQUF3QjtBQUNqRiw2QkFBNkIsVUFBVSxPQUFPLFVBQVU7QUFDeEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsK0RBQStEOztBQUUxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsOENBQThDO0FBQy9EO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsZ0JBQWdCO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtB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QVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEZBQXdDLGVBQWU7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1SEFBcUUsZUFBZTtBQUNwRixzSEFBb0UsZUFBZTtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZOztBQUV2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFO0FBQ3JFO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGdCQUFnQjtBQUM3QztBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0EsOENBQThDO0FBQzlDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsZUFBZSxtQ0FBbUMsNERBQTREO0FBQ3JKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFVBQVU7QUFDakMsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMLHVCQUF1QixXQUFXO0FBQ2xDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELGlDQUFpQztBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvSEFBa0UsVUFBVSxFQUFFLElBQUk7QUFDbEY7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsMkZBQXlDLFVBQVUsRUFBRSxJQUFJO0FBQ3pEO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLDhGQUE0QyxVQUFVLEVBQUUsSUFBSTtBQUM1RDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQSxHQUFHO0FBQ0g7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsVUFBVSxVQUFVLEtBQUs7QUFDMUM7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyx1Q0FBdUM7QUFDN0U7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBLHNDQUFzQztBQUN0QyxTQUFTLG9DQUFvQztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsVUFBVTtBQUNsRTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3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SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBLEtBQUs7QUFDTCwrREFBK0Q7QUFDL0Q7QUFDQTtBQUNBLEtBQUs7QUFDTCw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFZO0FBQzVCO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsWUFBWTtBQUNaOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhEQUE4RCxhQUFhO0FBQzNFOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxnQkFBZ0I7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLFNBQVMsaUNBQWlDO0FBQzFDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsS0FBSztBQUN4QztBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsS0FBSztBQUMzQztBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsS0FBSztBQUMzQztBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLEtBQUs7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsS0FBSztBQUMzQztBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLEtBQUs7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1AsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFDQUFxQyxhQUFhO0FBQ2xELGdEQUFnRCw2Q0FBNkM7QUFDN0YsT0FBTztBQUNQO0FBQ0EsZ0RBQWdELDZDQUE2QztBQUM3RjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtHQUFzQyx5RUFBeUU7QUFDL0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsZ0JBQWdCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxnQkFBZ0I7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsNklBQWlGLGVBQWU7QUFDaEcsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBLGlGQUFpRixlQUFlO0FBQ2hHLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBLFdBQVcscUNBQXFDO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsZ0JBQWdCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGdCQUFnQjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGtCQUFrQjtBQUNqRCxrQkFBa0Isa0NBQWtDO0FBQ3BELE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFFBQVE7QUFDakQ7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0EsbUNBQW1DLGVBQWU7O0FBRWxEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFFBQVE7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsV0FBVyx3QkFBd0I7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjs7QUFFNUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCx3QkFBd0I7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNULE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxLQUFL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QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxZQUFZO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGtCQUFrQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxT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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCOztBQUUzQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsc0JBQXNCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsVUFBVTtBQUM5RCxzREFBc0QsaUNBQWlDO0FBQ3ZGLFdBQVc7QUFDWCwyQ0FBMkMsVUFBVTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsaURBQWlELGdCQUFnQjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGdCQUFnQjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Es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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBLEtBQUs7QUFDTCxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQSw4QkFBOEI7QUFDOUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQywyQkFBMkIsTUFBTSxnQ0FBZ0M7QUFDdkcsK0NBQStDLDJCQUEyQjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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bUI7QUFDMUY7QUFDQSxZQUFZLGdEQUFnRCxlQUFlO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsNkJBQTZC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QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0dBQXdDLGtCQUFrQjtBQUMxRDtBQUNBO0FBQ0EsbUJBQW1CLDBCQUEwQjtBQUM3QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrRUFBa0UsRUFBRSxNQUFNLEVBQUUsTUFBTSxFQUFFO0FBQ3BGLDJDQUEyQyxFQUFFLE1BQU0sRUFBRTtBQUNyRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVMscUNBQXFDO0FBQzlDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUyw2QkFBNkI7QUFDdEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQix1QkFBdUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsb0JBQW9CO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFF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O0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0tBQXdHLHNCQUFzQjtBQUM5SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHFDQUFxQztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7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Q0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCO0FBQzVCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRTtBQUNBLEtBQUs7O0FBRUw7QUFDQSx3Q0FBd0M7QUFDeEM7O0FBRUE7QUFDQSxtQ0FBbUM7QUFDbkMsMkNBQTJDO0FBQzNDLHlDQUF5Qzs7QUFFekM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxXQUFXLGtCQUFrQjtBQUN0RTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx3Q0FBd0MsMkJBQTJCOztBQUVuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLG1CQUFtQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsUUFBUTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsbUNBQW1DLG1CQUFtQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUJBQW1CO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx5Q0FBeUM7QUFDcEQ7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsT0FBTztBQUNoRCxPQUFPO0FBQ1Asd0NBQXdDLE9BQU87QUFDL0M7QUFDQSxrQ0FBa0MsUUFBUTtBQUMxQyxLQUFLO0FBQ0w7QUFDQSw4Q0FBOEMsT0FBTztBQUNyRCxPQUFPO0FBQ1Asd0NBQXdDLE9BQU87QUFDL0M7QUFDQSxtQ0FBbUMsUUFBUTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsc0JBQXNCO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxXQUFXO0FBQ3RFLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRkFBMkYsV0FBVztBQUN0RztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLFdBQVcsMkJBQTJCO0FBQ3RDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztB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QTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsdUJBQXVCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsdUJBQXVCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMscUNBQXFDO0FBQ25GO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLG1CQUFtQjs7QUFFOUI7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9GQUFvRixPQUFPO0FBQzNGLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4Q0FBOEMscUNBQXFDO0FBQ25GO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQ0FBK0MscUNBQXFDO0FBQ3BGO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsT0FBTztBQUNyRCxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0dBQXNDLHFDQUFxQztBQUMzRSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCw0QkFBNEI7QUFDbkY7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQSw4QkFBOEI7QUFDOUI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWixLQUFLOztBQUVMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFD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QUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1QsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUCxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWixLQUFLOztBQUVMO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCLHFCQUFxQixXQUFXO0FBQ2hDLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdFQUFnRSw4QkFBOEI7QUFDMUc7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDUTs7Ozs7Ozs7QUN4dDBCUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxRQUFRO0FBQ3BCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQ0FBcUM7O0FBRXJDO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFVBQVU7Ozs7Ozs7O0FDdkx0QztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsaUJBQWlCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQ0FBMEMsc0JBQXNCLEVBQUU7QUFDbEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7Ozs7O0FDekxEO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQzlEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsa0NBQWtDOztBQUVsQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixpQkFBaUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLCtCQUErQjtBQUNyRCxzQkFBc0IsaUJBQWlCO0FBQ3ZDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FB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QTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsT0FBTztBQUMxQztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxPQUFPO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsT0FBTztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtB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QTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIscUJBQXFCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHFCQUFxQjtBQUNsQztBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQSwwQ0FBMEMsT0FBTztBQUNqRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLHFCQUFxQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVDQUF1QyxPQUFPO0FBQzlDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxPQUFPO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxPQUFPO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsZ0JBQWdCO0FBQ2pDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsMkJBQTJCO0FBQzlDLHFCQUFxQiwrQkFBK0I7QUFDcEQ7QUFDQTtBQUNBLEdBQUc7QUFDSCx5QkFBeUI7QUFDekI7QUFDQSxzQkFBc0IsaUNBQWlDO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBLDhCQUE4Qjs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixvQkFBb0I7QUFDekM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUEsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixPQUFPO0FBQ3RDO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsZ0NBQWdDLE9BQU87QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRDQUE0QyxlQUFlO0FBQzNELEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix1Q0FBdUM7O0FBRW5FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILHFDQUFxQyxnRUFBZ0U7QUFDckc7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILDRCQUE0QiwrQkFBK0I7QUFDM0QsNEJBQTRCLCtCQUErQjtBQUMzRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxtQkFBbUIsbUJBQW1CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7QUFLQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLHVGQUF1RjtBQUM1RjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQ0FBMEM7QUFDMUMsaUJBQWlCLHlCQUF5QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSwrQkFBK0I7QUFDL0YsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsb0JBQW9CLG9CQUFvQjtBQUN4QyxzQkFBc0IsNEJBQTRCO0FBQ2xEO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLE9BQU87QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsbUJBQW1CO0FBQ25CLHlCQUF5QjtBQUN6QjtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyw2Q0FBNkM7QUFDOUU7QUFDQTtBQUNBLDZDQUE2Qyw0Q0FBNEM7O0FBRXpGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQSxvQkFBb0I7QUFDcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixlQUFlO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbUJBQW1CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRTtBQUN0RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQzs7QUFFakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0EsMENBQTBDLDJCQUEyQixFQUFFO0FBQ3ZFLEtBQUs7QUFDTDtBQUNBLDBDQUEwQyw0QkFBNEIsRUFBRTtBQUN4RSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGVBQWU7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxPQUFPO0FBQzFDO0FBQ0EsZ0JBQWdCLFlBQVk7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixZQUFZO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQkFBK0Isc0JBQXNCOztBQUVyRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQjs7QUFFcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdDQUFnQzs7QUFFaEM7O0FBRUE7QUFD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OEI7QUFDbkQ7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGlCQUFpQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEVBQTRFO0FBQzVFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxnQkFBZ0I7QUFDN0I7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGtCQUFrQjtBQUMxRCxLQUFLO0FBQ0wsd0NBQXdDLGtCQUFrQjtBQUMxRCxLQUFLO0FBQ0wsd0NBQXdDLDBCQUEwQjtBQUNsRSxLQUFLO0FBQ0wsd0NBQXdDLGlCQUFpQjtBQUN6RCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxtQ0FBbUM7QUFDbkMsbUNBQW1DO0FBQ25DLDJDQUEyQztBQUMzQywyQkFBMkI7QUFDM0IsMkJBQTJCO0FBQzNCLDRCQUE0QjtBQUM1Qiw0QkFBNEI7QUFDNUIsMkJBQTJCO0FBQzNCLDJCQUEyQjtBQUMzQjtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxvQkFBb0I7QUFDbkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGVBQWUsRUFBRSx1QkFBdUIsVUFBVSxFQUFFO0FBQ3BGO0FBQ0E7O0FBRUE7QUFDQSxzQ0FBc0MsMkJBQTJCO0FBQ2pFO0FBQ0E7O0FBRUE7QUFDQSxzQ0FBc0MsMkJBQTJCO0FBQ2pFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDJCQUEyQjtBQUNoRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELDZFQUE2RTtBQUM3SDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JELEdBQUc7QUFDSCx5Q0FBeUM7QUFDekM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLE9BQU87QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsbUJBQW1CO0FBQzNFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixhQUFhO0FBQ3BDLHVCQUF1QixhQUFhO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGO0FBQ2pGLDRCQUE0QjtBQUM1QjtBQUNBLDJCQUEyQjtBQUMzQix3QkFBd0IsaUVBQWlFO0FBQ3pGLFlBQVksMEZBQTBGO0FBQ3RHLE1BQU0sS0FBSywwQ0FBMEM7QUFDckQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsa0JBQWtCO0FBQy9ELHNCQUFzQiwrQ0FBK0M7QUFDckUsaURBQWlEOztBQUVqRDtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixzREFBc0Q7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsMkJBQTJCO0FBQ3RELGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLDZDQUE2QyxFQUFFO0FBQ3REO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSx1Q0FBdUMsU0FBUztBQUNoRDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsd0JBQXdCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2Qyw0QkFBNEIsRUFBRTtBQUMzRSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QywrQkFBK0IsRUFBRTtBQUM5RSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGFBQWE7O0FBRTNEO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGlDQUFpQyxxQ0FBcUM7O0FBRXRFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyx1Q0FBdUMsRUFBRTtBQUNwRjtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsMkNBQTJDLEVBQUU7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsT0FBTztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUNBQXFDLDhCQUE4QixFQUFFO0FBQ3JFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkNBQTZDLHVDQUF1QyxFQUFFO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOENBQThDO0FBQzlDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBFQUEwRSwwQkFBMEIsRUFBRTtBQUN0RztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hE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QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9DQUFvQyxVQUFVO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZUFBZTtBQUMzQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwyQkFBMkI7QUFDOUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsMEJBQTBCO0FBQy9DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyw4QkFBOEI7QUFDdkM7QUFDQSx1REFBdUQsNkRBQTZEO0FBQ3BILFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix1QkFBdUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixPQUFPO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLG9CQUFvQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTyw0QkFBNEI7QUFDbkM7QUFDQTtBQUNBLE9BQU8sT0FBTztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLE9BQU87QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyx3QkFBd0IsRUFBRTtBQUMxRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1DQUFtQyxPQUFPO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLE9BQU87QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQs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OztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxpQkFBaUIsdUJBQXVCO0FBQ3hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLG1CQUFtQixFQUFFO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHFCQUFxQixFQUFFO0FBQ3JFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7Ozs7Ozs7QUMvc1ZBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0Q0FBNEM7O0FBRTVDOzs7Ozs7Ozs7Ozs7O0FDcEJBO0FBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkNBQUFBLENBQUlDLEdBQUosQ0FBUSxpR0FBUixFQUF1Qix5RkFBdkI7O0FBRUEsSUFBTUMsTUFBTSxJQUFJLDJDQUFKLENBQVE7QUFDaEJDLFFBQUksTUFEWTtBQUVoQkMsZ0JBQVk7QUFDUkMsY0FBTSxNQURFO0FBRVJDLFlBQUksVUFGSTtBQUdSQyxjQUFNLE1BSEU7QUFJUkMsZUFBTztBQUNQO0FBTFE7QUFGSSxDQUFSLENBQVosQyIsImZpbGUiOiIvanMvbG9naW4uanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbiBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbiBcdFx0XHR9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAxKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrL2Jvb3RzdHJhcCA0OTAwNGYwNDA1MTE1Y2JjNThmMyIsIi8qKlxuICogRG9tNyAyLjAuNVxuICogTWluaW1hbGlzdGljIEphdmFTY3JpcHQgbGlicmFyeSBmb3IgRE9NIG1hbmlwdWxhdGlvbiwgd2l0aCBhIGpRdWVyeS1jb21wYXRpYmxlIEFQSVxuICogaHR0cDovL2ZyYW1ld29yazcuaW8vZG9jcy9kb20uaHRtbFxuICpcbiAqIENvcHlyaWdodCAyMDE4LCBWbGFkaW1pciBLaGFybGFtcGlkaVxuICogVGhlIGlEYW5nZXJvLnVzXG4gKiBodHRwOi8vd3d3LmlkYW5nZXJvLnVzL1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVFxuICpcbiAqIFJlbGVhc2VkIG9uOiBBcHJpbCAyMCwgMjAxOFxuICovXG5pbXBvcnQgeyBkb2N1bWVudCwgd2luZG93IH0gZnJvbSAnc3NyLXdpbmRvdyc7XG5cbmNsYXNzIERvbTcge1xuICBjb25zdHJ1Y3RvcihhcnIpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAvLyBDcmVhdGUgYXJyYXktbGlrZSBvYmplY3RcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgc2VsZltpXSA9IGFycltpXTtcbiAgICB9XG4gICAgc2VsZi5sZW5ndGggPSBhcnIubGVuZ3RoO1xuICAgIC8vIFJldHVybiBjb2xsZWN0aW9uIHdpdGggbWV0aG9kc1xuICAgIHJldHVybiB0aGlzO1xuICB9XG59XG5cbmZ1bmN0aW9uICQkMShzZWxlY3RvciwgY29udGV4dCkge1xuICBjb25zdCBhcnIgPSBbXTtcbiAgbGV0IGkgPSAwO1xuICBpZiAoc2VsZWN0b3IgJiYgIWNvbnRleHQpIHtcbiAgICBpZiAoc2VsZWN0b3IgaW5zdGFuY2VvZiBEb203KSB7XG4gICAgICByZXR1cm4gc2VsZWN0b3I7XG4gICAgfVxuICB9XG4gIGlmIChzZWxlY3Rvcikge1xuICAgICAgLy8gU3RyaW5nXG4gICAgaWYgKHR5cGVvZiBzZWxlY3RvciA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGxldCBlbHM7XG4gICAgICBsZXQgdGVtcFBhcmVudDtcbiAgICAgIGNvbnN0IGh0bWwgPSBzZWxlY3Rvci50cmltKCk7XG4gICAgICBpZiAoaHRtbC5pbmRleE9mKCc8JykgPj0gMCAmJiBodG1sLmluZGV4T2YoJz4nKSA+PSAwKSB7XG4gICAgICAgIGxldCB0b0NyZWF0ZSA9ICdkaXYnO1xuICAgICAgICBpZiAoaHRtbC5pbmRleE9mKCc8bGknKSA9PT0gMCkgdG9DcmVhdGUgPSAndWwnO1xuICAgICAgICBpZiAoaHRtbC5pbmRleE9mKCc8dHInKSA9PT0gMCkgdG9DcmVhdGUgPSAndGJvZHknO1xuICAgICAgICBpZiAoaHRtbC5pbmRleE9mKCc8dGQnKSA9PT0gMCB8fCBodG1sLmluZGV4T2YoJzx0aCcpID09PSAwKSB0b0NyZWF0ZSA9ICd0cic7XG4gICAgICAgIGlmIChodG1sLmluZGV4T2YoJzx0Ym9keScpID09PSAwKSB0b0NyZWF0ZSA9ICd0YWJsZSc7XG4gICAgICAgIGlmIChodG1sLmluZGV4T2YoJzxvcHRpb24nKSA9PT0gMCkgdG9DcmVhdGUgPSAnc2VsZWN0JztcbiAgICAgICAgdGVtcFBhcmVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodG9DcmVhdGUpO1xuICAgICAgICB0ZW1wUGFyZW50LmlubmVySFRNTCA9IGh0bWw7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0ZW1wUGFyZW50LmNoaWxkTm9kZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICBhcnIucHVzaCh0ZW1wUGFyZW50LmNoaWxkTm9kZXNbaV0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIWNvbnRleHQgJiYgc2VsZWN0b3JbMF0gPT09ICcjJyAmJiAhc2VsZWN0b3IubWF0Y2goL1sgLjw+On5dLykpIHtcbiAgICAgICAgICAvLyBQdXJlIElEIHNlbGVjdG9yXG4gICAgICAgICAgZWxzID0gW2RvY3VtZW50LmdldEVsZW1lbnRCeUlkKHNlbGVjdG9yLnRyaW0oKS5zcGxpdCgnIycpWzFdKV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gT3RoZXIgc2VsZWN0b3JzXG4gICAgICAgICAgZWxzID0gKGNvbnRleHQgfHwgZG9jdW1lbnQpLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IudHJpbSgpKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZWxzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgaWYgKGVsc1tpXSkgYXJyLnB1c2goZWxzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoc2VsZWN0b3Iubm9kZVR5cGUgfHwgc2VsZWN0b3IgPT09IHdpbmRvdyB8fCBzZWxlY3RvciA9PT0gZG9jdW1lbnQpIHtcbiAgICAgIC8vIE5vZGUvZWxlbWVudFxuICAgICAgYXJyLnB1c2goc2VsZWN0b3IpO1xuICAgIH0gZWxzZSBpZiAoc2VsZWN0b3IubGVuZ3RoID4gMCAmJiBzZWxlY3RvclswXS5ub2RlVHlwZSkge1xuICAgICAgLy8gQXJyYXkgb2YgZWxlbWVudHMgb3IgaW5zdGFuY2Ugb2YgRG9tXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgc2VsZWN0b3IubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgYXJyLnB1c2goc2VsZWN0b3JbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3IERvbTcoYXJyKTtcbn1cblxuJCQxLmZuID0gRG9tNy5wcm90b3R5cGU7XG4kJDEuQ2xhc3MgPSBEb203O1xuJCQxLkRvbTcgPSBEb203O1xuXG5mdW5jdGlvbiB1bmlxdWUoYXJyKSB7XG4gIGNvbnN0IHVuaXF1ZUFycmF5ID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgaWYgKHVuaXF1ZUFycmF5LmluZGV4T2YoYXJyW2ldKSA9PT0gLTEpIHVuaXF1ZUFycmF5LnB1c2goYXJyW2ldKTtcbiAgfVxuICByZXR1cm4gdW5pcXVlQXJyYXk7XG59XG5mdW5jdGlvbiB0b0NhbWVsQ2FzZShzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoLy0oLikvZywgKG1hdGNoLCBncm91cDEpID0+IGdyb3VwMS50b1VwcGVyQ2FzZSgpKTtcbn1cblxuZnVuY3Rpb24gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGNhbGxiYWNrKSB7XG4gIGlmICh3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKSByZXR1cm4gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShjYWxsYmFjayk7XG4gIGVsc2UgaWYgKHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIHJldHVybiB3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lKGNhbGxiYWNrKTtcbiAgcmV0dXJuIHdpbmRvdy5zZXRUaW1lb3V0KGNhbGxiYWNrLCAxMDAwIC8gNjApO1xufVxuZnVuY3Rpb24gY2FuY2VsQW5pbWF0aW9uRnJhbWUoaWQpIHtcbiAgaWYgKHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSkgcmV0dXJuIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZShpZCk7XG4gIGVsc2UgaWYgKHdpbmRvdy53ZWJraXRDYW5jZWxBbmltYXRpb25GcmFtZSkgcmV0dXJuIHdpbmRvdy53ZWJraXRDYW5jZWxBbmltYXRpb25GcmFtZShpZCk7XG4gIHJldHVybiB3aW5kb3cuY2xlYXJUaW1lb3V0KGlkKTtcbn1cblxuLy8gQ2xhc3NlcyBhbmQgYXR0cmlidXRlc1xuZnVuY3Rpb24gYWRkQ2xhc3MoY2xhc3NOYW1lKSB7XG4gIGlmICh0eXBlb2YgY2xhc3NOYW1lID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGNvbnN0IGNsYXNzZXMgPSBjbGFzc05hbWUuc3BsaXQoJyAnKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjbGFzc2VzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLmxlbmd0aDsgaiArPSAxKSB7XG4gICAgICBpZiAodHlwZW9mIHRoaXNbal0uY2xhc3NMaXN0ICE9PSAndW5kZWZpbmVkJykgdGhpc1tqXS5jbGFzc0xpc3QuYWRkKGNsYXNzZXNbaV0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpcztcbn1cbmZ1bmN0aW9uIHJlbW92ZUNsYXNzKGNsYXNzTmFtZSkge1xuICBjb25zdCBjbGFzc2VzID0gY2xhc3NOYW1lLnNwbGl0KCcgJyk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY2xhc3Nlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy5sZW5ndGg7IGogKz0gMSkge1xuICAgICAgaWYgKHR5cGVvZiB0aGlzW2pdLmNsYXNzTGlzdCAhPT0gJ3VuZGVmaW5lZCcpIHRoaXNbal0uY2xhc3NMaXN0LnJlbW92ZShjbGFzc2VzW2ldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5mdW5jdGlvbiBoYXNDbGFzcyhjbGFzc05hbWUpIHtcbiAgaWYgKCF0aGlzWzBdKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiB0aGlzWzBdLmNsYXNzTGlzdC5jb250YWlucyhjbGFzc05hbWUpO1xufVxuZnVuY3Rpb24gdG9nZ2xlQ2xhc3MoY2xhc3NOYW1lKSB7XG4gIGNvbnN0IGNsYXNzZXMgPSBjbGFzc05hbWUuc3BsaXQoJyAnKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjbGFzc2VzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLmxlbmd0aDsgaiArPSAxKSB7XG4gICAgICBpZiAodHlwZW9mIHRoaXNbal0uY2xhc3NMaXN0ICE9PSAndW5kZWZpbmVkJykgdGhpc1tqXS5jbGFzc0xpc3QudG9nZ2xlKGNsYXNzZXNbaV0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpcztcbn1cbmZ1bmN0aW9uIGF0dHIoYXR0cnMsIHZhbHVlKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxICYmIHR5cGVvZiBhdHRycyA9PT0gJ3N0cmluZycpIHtcbiAgICAvLyBHZXQgYXR0clxuICAgIGlmICh0aGlzWzBdKSByZXR1cm4gdGhpc1swXS5nZXRBdHRyaWJ1dGUoYXR0cnMpO1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICAvLyBTZXQgYXR0cnNcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAgIC8vIFN0cmluZ1xuICAgICAgdGhpc1tpXS5zZXRBdHRyaWJ1dGUoYXR0cnMsIHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gT2JqZWN0XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgIGZvciAoY29uc3QgYXR0ck5hbWUgaW4gYXR0cnMpIHtcbiAgICAgICAgdGhpc1tpXVthdHRyTmFtZV0gPSBhdHRyc1thdHRyTmFtZV07XG4gICAgICAgIHRoaXNbaV0uc2V0QXR0cmlidXRlKGF0dHJOYW1lLCBhdHRyc1thdHRyTmFtZV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpcztcbn1cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuZnVuY3Rpb24gcmVtb3ZlQXR0cihhdHRyKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgIHRoaXNbaV0ucmVtb3ZlQXR0cmlidXRlKGF0dHIpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG5mdW5jdGlvbiBwcm9wKHByb3BzLCB2YWx1ZSkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJiB0eXBlb2YgcHJvcHMgPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gR2V0IHByb3BcbiAgICBpZiAodGhpc1swXSkgcmV0dXJuIHRoaXNbMF1bcHJvcHNdO1xuICB9IGVsc2Uge1xuICAgIC8vIFNldCBwcm9wc1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgLy8gU3RyaW5nXG4gICAgICAgIHRoaXNbaV1bcHJvcHNdID0gdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBPYmplY3RcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgIGZvciAoY29uc3QgcHJvcE5hbWUgaW4gcHJvcHMpIHtcbiAgICAgICAgICB0aGlzW2ldW3Byb3BOYW1lXSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxufVxuZnVuY3Rpb24gZGF0YShrZXksIHZhbHVlKSB7XG4gIGxldCBlbDtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBlbCA9IHRoaXNbMF07XG4gICAgLy8gR2V0IHZhbHVlXG4gICAgaWYgKGVsKSB7XG4gICAgICBpZiAoZWwuZG9tN0VsZW1lbnREYXRhU3RvcmFnZSAmJiAoa2V5IGluIGVsLmRvbTdFbGVtZW50RGF0YVN0b3JhZ2UpKSB7XG4gICAgICAgIHJldHVybiBlbC5kb203RWxlbWVudERhdGFTdG9yYWdlW2tleV07XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGRhdGFLZXkgPSBlbC5nZXRBdHRyaWJ1dGUoYGRhdGEtJHtrZXl9YCk7XG4gICAgICBpZiAoZGF0YUtleSkge1xuICAgICAgICByZXR1cm4gZGF0YUtleTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICAvLyBTZXQgdmFsdWVcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgZWwgPSB0aGlzW2ldO1xuICAgIGlmICghZWwuZG9tN0VsZW1lbnREYXRhU3RvcmFnZSkgZWwuZG9tN0VsZW1lbnREYXRhU3RvcmFnZSA9IHt9O1xuICAgIGVsLmRvbTdFbGVtZW50RGF0YVN0b3JhZ2Vba2V5XSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuZnVuY3Rpb24gcmVtb3ZlRGF0YShrZXkpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgY29uc3QgZWwgPSB0aGlzW2ldO1xuICAgIGlmIChlbC5kb203RWxlbWVudERhdGFTdG9yYWdlICYmIGVsLmRvbTdFbGVtZW50RGF0YVN0b3JhZ2Vba2V5XSkge1xuICAgICAgZWwuZG9tN0VsZW1lbnREYXRhU3RvcmFnZVtrZXldID0gbnVsbDtcbiAgICAgIGRlbGV0ZSBlbC5kb203RWxlbWVudERhdGFTdG9yYWdlW2tleV07XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBkYXRhc2V0KCkge1xuICBjb25zdCBlbCA9IHRoaXNbMF07XG4gIGlmICghZWwpIHJldHVybiB1bmRlZmluZWQ7XG4gIGNvbnN0IGRhdGFzZXQgPSB7fTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICBpZiAoZWwuZGF0YXNldCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgIGZvciAoY29uc3QgZGF0YUtleSBpbiBlbC5kYXRhc2V0KSB7XG4gICAgICBkYXRhc2V0W2RhdGFLZXldID0gZWwuZGF0YXNldFtkYXRhS2V5XTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbC5hdHRyaWJ1dGVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgIGNvbnN0IGF0dHIgPSBlbC5hdHRyaWJ1dGVzW2ldO1xuICAgICAgaWYgKGF0dHIubmFtZS5pbmRleE9mKCdkYXRhLScpID49IDApIHtcbiAgICAgICAgZGF0YXNldFt0b0NhbWVsQ2FzZShhdHRyLm5hbWUuc3BsaXQoJ2RhdGEtJylbMV0pXSA9IGF0dHIudmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICBmb3IgKGNvbnN0IGtleSBpbiBkYXRhc2V0KSB7XG4gICAgaWYgKGRhdGFzZXRba2V5XSA9PT0gJ2ZhbHNlJykgZGF0YXNldFtrZXldID0gZmFsc2U7XG4gICAgZWxzZSBpZiAoZGF0YXNldFtrZXldID09PSAndHJ1ZScpIGRhdGFzZXRba2V5XSA9IHRydWU7XG4gICAgZWxzZSBpZiAocGFyc2VGbG9hdChkYXRhc2V0W2tleV0pID09PSBkYXRhc2V0W2tleV0gKiAxKSBkYXRhc2V0W2tleV0gKj0gMTtcbiAgfVxuICByZXR1cm4gZGF0YXNldDtcbn1cbmZ1bmN0aW9uIHZhbCh2YWx1ZSkge1xuICBjb25zdCBkb20gPSB0aGlzO1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJykge1xuICAgIGlmIChkb21bMF0pIHtcbiAgICAgIGlmIChkb21bMF0ubXVsdGlwbGUgJiYgZG9tWzBdLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdzZWxlY3QnKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRvbVswXS5zZWxlY3RlZE9wdGlvbnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICB2YWx1ZXMucHVzaChkb21bMF0uc2VsZWN0ZWRPcHRpb25zW2ldLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRvbVswXS52YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZG9tLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgY29uc3QgZWwgPSBkb21baV07XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpICYmIGVsLm11bHRpcGxlICYmIGVsLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdzZWxlY3QnKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGVsLm9wdGlvbnMubGVuZ3RoOyBqICs9IDEpIHtcbiAgICAgICAgZWwub3B0aW9uc1tqXS5zZWxlY3RlZCA9IHZhbHVlLmluZGV4T2YoZWwub3B0aW9uc1tqXS52YWx1ZSkgPj0gMDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZWwudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRvbTtcbn1cbi8vIFRyYW5zZm9ybXNcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuZnVuY3Rpb24gdHJhbnNmb3JtKHRyYW5zZm9ybSkge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICBjb25zdCBlbFN0eWxlID0gdGhpc1tpXS5zdHlsZTtcbiAgICBlbFN0eWxlLndlYmtpdFRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcbiAgICBlbFN0eWxlLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cbmZ1bmN0aW9uIHRyYW5zaXRpb24oZHVyYXRpb24pIHtcbiAgaWYgKHR5cGVvZiBkdXJhdGlvbiAhPT0gJ3N0cmluZycpIHtcbiAgICBkdXJhdGlvbiA9IGAke2R1cmF0aW9ufW1zYDsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgIGNvbnN0IGVsU3R5bGUgPSB0aGlzW2ldLnN0eWxlO1xuICAgIGVsU3R5bGUud2Via2l0VHJhbnNpdGlvbkR1cmF0aW9uID0gZHVyYXRpb247XG4gICAgZWxTdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gPSBkdXJhdGlvbjtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cbi8vIEV2ZW50c1xuZnVuY3Rpb24gb24oLi4uYXJncykge1xuICBsZXQgW2V2ZW50VHlwZSwgdGFyZ2V0U2VsZWN0b3IsIGxpc3RlbmVyLCBjYXB0dXJlXSA9IGFyZ3M7XG4gIGlmICh0eXBlb2YgYXJnc1sxXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIFtldmVudFR5cGUsIGxpc3RlbmVyLCBjYXB0dXJlXSA9IGFyZ3M7XG4gICAgdGFyZ2V0U2VsZWN0b3IgPSB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKCFjYXB0dXJlKSBjYXB0dXJlID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gaGFuZGxlTGl2ZUV2ZW50KGUpIHtcbiAgICBjb25zdCB0YXJnZXQgPSBlLnRhcmdldDtcbiAgICBpZiAoIXRhcmdldCkgcmV0dXJuO1xuICAgIGNvbnN0IGV2ZW50RGF0YSA9IGUudGFyZ2V0LmRvbTdFdmVudERhdGEgfHwgW107XG4gICAgaWYgKGV2ZW50RGF0YS5pbmRleE9mKGUpIDwgMCkge1xuICAgICAgZXZlbnREYXRhLnVuc2hpZnQoZSk7XG4gICAgfVxuICAgIGlmICgkJDEodGFyZ2V0KS5pcyh0YXJnZXRTZWxlY3RvcikpIGxpc3RlbmVyLmFwcGx5KHRhcmdldCwgZXZlbnREYXRhKTtcbiAgICBlbHNlIHtcbiAgICAgIGNvbnN0IHBhcmVudHMgPSAkJDEodGFyZ2V0KS5wYXJlbnRzKCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgcGFyZW50cy5sZW5ndGg7IGsgKz0gMSkge1xuICAgICAgICBpZiAoJCQxKHBhcmVudHNba10pLmlzKHRhcmdldFNlbGVjdG9yKSkgbGlzdGVuZXIuYXBwbHkocGFyZW50c1trXSwgZXZlbnREYXRhKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gaGFuZGxlRXZlbnQoZSkge1xuICAgIGNvbnN0IGV2ZW50RGF0YSA9IGUgJiYgZS50YXJnZXQgPyBlLnRhcmdldC5kb203RXZlbnREYXRhIHx8IFtdIDogW107XG4gICAgaWYgKGV2ZW50RGF0YS5pbmRleE9mKGUpIDwgMCkge1xuICAgICAgZXZlbnREYXRhLnVuc2hpZnQoZSk7XG4gICAgfVxuICAgIGxpc3RlbmVyLmFwcGx5KHRoaXMsIGV2ZW50RGF0YSk7XG4gIH1cbiAgY29uc3QgZXZlbnRzID0gZXZlbnRUeXBlLnNwbGl0KCcgJyk7XG4gIGxldCBqO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICBjb25zdCBlbCA9IHRoaXNbaV07XG4gICAgaWYgKCF0YXJnZXRTZWxlY3Rvcikge1xuICAgICAgZm9yIChqID0gMDsgaiA8IGV2ZW50cy5sZW5ndGg7IGogKz0gMSkge1xuICAgICAgICBjb25zdCBldmVudCA9IGV2ZW50c1tqXTtcbiAgICAgICAgaWYgKCFlbC5kb203TGlzdGVuZXJzKSBlbC5kb203TGlzdGVuZXJzID0ge307XG4gICAgICAgIGlmICghZWwuZG9tN0xpc3RlbmVyc1tldmVudF0pIGVsLmRvbTdMaXN0ZW5lcnNbZXZlbnRdID0gW107XG4gICAgICAgIGVsLmRvbTdMaXN0ZW5lcnNbZXZlbnRdLnB1c2goe1xuICAgICAgICAgIGxpc3RlbmVyLFxuICAgICAgICAgIHByb3h5TGlzdGVuZXI6IGhhbmRsZUV2ZW50LFxuICAgICAgICB9KTtcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlRXZlbnQsIGNhcHR1cmUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBMaXZlIGV2ZW50c1xuICAgICAgZm9yIChqID0gMDsgaiA8IGV2ZW50cy5sZW5ndGg7IGogKz0gMSkge1xuICAgICAgICBjb25zdCBldmVudCA9IGV2ZW50c1tqXTtcbiAgICAgICAgaWYgKCFlbC5kb203TGl2ZUxpc3RlbmVycykgZWwuZG9tN0xpdmVMaXN0ZW5lcnMgPSB7fTtcbiAgICAgICAgaWYgKCFlbC5kb203TGl2ZUxpc3RlbmVyc1tldmVudF0pIGVsLmRvbTdMaXZlTGlzdGVuZXJzW2V2ZW50XSA9IFtdO1xuICAgICAgICBlbC5kb203TGl2ZUxpc3RlbmVyc1tldmVudF0ucHVzaCh7XG4gICAgICAgICAgbGlzdGVuZXIsXG4gICAgICAgICAgcHJveHlMaXN0ZW5lcjogaGFuZGxlTGl2ZUV2ZW50LFxuICAgICAgICB9KTtcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlTGl2ZUV2ZW50LCBjYXB0dXJlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5mdW5jdGlvbiBvZmYoLi4uYXJncykge1xuICBsZXQgW2V2ZW50VHlwZSwgdGFyZ2V0U2VsZWN0b3IsIGxpc3RlbmVyLCBjYXB0dXJlXSA9IGFyZ3M7XG4gIGlmICh0eXBlb2YgYXJnc1sxXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIFtldmVudFR5cGUsIGxpc3RlbmVyLCBjYXB0dXJlXSA9IGFyZ3M7XG4gICAgdGFyZ2V0U2VsZWN0b3IgPSB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKCFjYXB0dXJlKSBjYXB0dXJlID0gZmFsc2U7XG5cbiAgY29uc3QgZXZlbnRzID0gZXZlbnRUeXBlLnNwbGl0KCcgJyk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZXZlbnRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgY29uc3QgZXZlbnQgPSBldmVudHNbaV07XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLmxlbmd0aDsgaiArPSAxKSB7XG4gICAgICBjb25zdCBlbCA9IHRoaXNbal07XG4gICAgICBsZXQgaGFuZGxlcnM7XG4gICAgICBpZiAoIXRhcmdldFNlbGVjdG9yICYmIGVsLmRvbTdMaXN0ZW5lcnMpIHtcbiAgICAgICAgaGFuZGxlcnMgPSBlbC5kb203TGlzdGVuZXJzW2V2ZW50XTtcbiAgICAgIH0gZWxzZSBpZiAodGFyZ2V0U2VsZWN0b3IgJiYgZWwuZG9tN0xpdmVMaXN0ZW5lcnMpIHtcbiAgICAgICAgaGFuZGxlcnMgPSBlbC5kb203TGl2ZUxpc3RlbmVyc1tldmVudF07XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBrID0gaGFuZGxlcnMubGVuZ3RoIC0gMTsgayA+PSAwOyBrIC09IDEpIHtcbiAgICAgICAgY29uc3QgaGFuZGxlciA9IGhhbmRsZXJzW2tdO1xuICAgICAgICBpZiAobGlzdGVuZXIgJiYgaGFuZGxlci5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyLnByb3h5TGlzdGVuZXIsIGNhcHR1cmUpO1xuICAgICAgICAgIGhhbmRsZXJzLnNwbGljZShrLCAxKTtcbiAgICAgICAgfSBlbHNlIGlmICghbGlzdGVuZXIpIHtcbiAgICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyLnByb3h5TGlzdGVuZXIsIGNhcHR1cmUpO1xuICAgICAgICAgIGhhbmRsZXJzLnNwbGljZShrLCAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpcztcbn1cbmZ1bmN0aW9uIG9uY2UoLi4uYXJncykge1xuICBjb25zdCBkb20gPSB0aGlzO1xuICBsZXQgW2V2ZW50TmFtZSwgdGFyZ2V0U2VsZWN0b3IsIGxpc3RlbmVyLCBjYXB0dXJlXSA9IGFyZ3M7XG4gIGlmICh0eXBlb2YgYXJnc1sxXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIFtldmVudE5hbWUsIGxpc3RlbmVyLCBjYXB0dXJlXSA9IGFyZ3M7XG4gICAgdGFyZ2V0U2VsZWN0b3IgPSB1bmRlZmluZWQ7XG4gIH1cbiAgZnVuY3Rpb24gcHJveHkoLi4uZXZlbnRBcmdzKSB7XG4gICAgbGlzdGVuZXIuYXBwbHkodGhpcywgZXZlbnRBcmdzKTtcbiAgICBkb20ub2ZmKGV2ZW50TmFtZSwgdGFyZ2V0U2VsZWN0b3IsIHByb3h5LCBjYXB0dXJlKTtcbiAgfVxuICByZXR1cm4gZG9tLm9uKGV2ZW50TmFtZSwgdGFyZ2V0U2VsZWN0b3IsIHByb3h5LCBjYXB0dXJlKTtcbn1cbmZ1bmN0aW9uIHRyaWdnZXIoLi4uYXJncykge1xuICBjb25zdCBldmVudHMgPSBhcmdzWzBdLnNwbGl0KCcgJyk7XG4gIGNvbnN0IGV2ZW50RGF0YSA9IGFyZ3NbMV07XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZXZlbnRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgY29uc3QgZXZlbnQgPSBldmVudHNbaV07XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLmxlbmd0aDsgaiArPSAxKSB7XG4gICAgICBjb25zdCBlbCA9IHRoaXNbal07XG4gICAgICBsZXQgZXZ0O1xuICAgICAgdHJ5IHtcbiAgICAgICAgZXZ0ID0gbmV3IHdpbmRvdy5DdXN0b21FdmVudChldmVudCwge1xuICAgICAgICAgIGRldGFpbDogZXZlbnREYXRhLFxuICAgICAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICAgICAgY2FuY2VsYWJsZTogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpO1xuICAgICAgICBldnQuaW5pdEV2ZW50KGV2ZW50LCB0cnVlLCB0cnVlKTtcbiAgICAgICAgZXZ0LmRldGFpbCA9IGV2ZW50RGF0YTtcbiAgICAgIH1cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgZWwuZG9tN0V2ZW50RGF0YSA9IGFyZ3MuZmlsdGVyKChkYXRhLCBkYXRhSW5kZXgpID0+IGRhdGFJbmRleCA+IDApO1xuICAgICAgZWwuZGlzcGF0Y2hFdmVudChldnQpO1xuICAgICAgZWwuZG9tN0V2ZW50RGF0YSA9IFtdO1xuICAgICAgZGVsZXRlIGVsLmRvbTdFdmVudERhdGE7XG4gICAgfVxuICB9XG4gIHJldHVybiB0aGlzO1xufVxuZnVuY3Rpb24gdHJhbnNpdGlvbkVuZChjYWxsYmFjaykge1xuICBjb25zdCBldmVudHMgPSBbJ3dlYmtpdFRyYW5zaXRpb25FbmQnLCAndHJhbnNpdGlvbmVuZCddO1xuICBjb25zdCBkb20gPSB0aGlzO1xuICBsZXQgaTtcbiAgZnVuY3Rpb24gZmlyZUNhbGxCYWNrKGUpIHtcbiAgICAvKiBqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgICBpZiAoZS50YXJnZXQgIT09IHRoaXMpIHJldHVybjtcbiAgICBjYWxsYmFjay5jYWxsKHRoaXMsIGUpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBldmVudHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGRvbS5vZmYoZXZlbnRzW2ldLCBmaXJlQ2FsbEJhY2spO1xuICAgIH1cbiAgfVxuICBpZiAoY2FsbGJhY2spIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZXZlbnRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBkb20ub24oZXZlbnRzW2ldLCBmaXJlQ2FsbEJhY2spO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpcztcbn1cbmZ1bmN0aW9uIGFuaW1hdGlvbkVuZChjYWxsYmFjaykge1xuICBjb25zdCBldmVudHMgPSBbJ3dlYmtpdEFuaW1hdGlvbkVuZCcsICdhbmltYXRpb25lbmQnXTtcbiAgY29uc3QgZG9tID0gdGhpcztcbiAgbGV0IGk7XG4gIGZ1bmN0aW9uIGZpcmVDYWxsQmFjayhlKSB7XG4gICAgaWYgKGUudGFyZ2V0ICE9PSB0aGlzKSByZXR1cm47XG4gICAgY2FsbGJhY2suY2FsbCh0aGlzLCBlKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZXZlbnRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBkb20ub2ZmKGV2ZW50c1tpXSwgZmlyZUNhbGxCYWNrKTtcbiAgICB9XG4gIH1cbiAgaWYgKGNhbGxiYWNrKSB7XG4gICAgZm9yIChpID0gMDsgaSA8IGV2ZW50cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgZG9tLm9uKGV2ZW50c1tpXSwgZmlyZUNhbGxCYWNrKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG4vLyBTaXppbmcvU3R5bGVzXG5mdW5jdGlvbiB3aWR0aCgpIHtcbiAgaWYgKHRoaXNbMF0gPT09IHdpbmRvdykge1xuICAgIHJldHVybiB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgfVxuXG4gIGlmICh0aGlzLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gcGFyc2VGbG9hdCh0aGlzLmNzcygnd2lkdGgnKSk7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIG91dGVyV2lkdGgoaW5jbHVkZU1hcmdpbnMpIHtcbiAgaWYgKHRoaXMubGVuZ3RoID4gMCkge1xuICAgIGlmIChpbmNsdWRlTWFyZ2lucykge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICBjb25zdCBzdHlsZXMgPSB0aGlzLnN0eWxlcygpO1xuICAgICAgcmV0dXJuIHRoaXNbMF0ub2Zmc2V0V2lkdGggKyBwYXJzZUZsb2F0KHN0eWxlcy5nZXRQcm9wZXJ0eVZhbHVlKCdtYXJnaW4tcmlnaHQnKSkgKyBwYXJzZUZsb2F0KHN0eWxlcy5nZXRQcm9wZXJ0eVZhbHVlKCdtYXJnaW4tbGVmdCcpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXNbMF0ub2Zmc2V0V2lkdGg7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBoZWlnaHQoKSB7XG4gIGlmICh0aGlzWzBdID09PSB3aW5kb3cpIHtcbiAgICByZXR1cm4gd2luZG93LmlubmVySGVpZ2h0O1xuICB9XG5cbiAgaWYgKHRoaXMubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBwYXJzZUZsb2F0KHRoaXMuY3NzKCdoZWlnaHQnKSk7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIG91dGVySGVpZ2h0KGluY2x1ZGVNYXJnaW5zKSB7XG4gIGlmICh0aGlzLmxlbmd0aCA+IDApIHtcbiAgICBpZiAoaW5jbHVkZU1hcmdpbnMpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgY29uc3Qgc3R5bGVzID0gdGhpcy5zdHlsZXMoKTtcbiAgICAgIHJldHVybiB0aGlzWzBdLm9mZnNldEhlaWdodCArIHBhcnNlRmxvYXQoc3R5bGVzLmdldFByb3BlcnR5VmFsdWUoJ21hcmdpbi10b3AnKSkgKyBwYXJzZUZsb2F0KHN0eWxlcy5nZXRQcm9wZXJ0eVZhbHVlKCdtYXJnaW4tYm90dG9tJykpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpc1swXS5vZmZzZXRIZWlnaHQ7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBvZmZzZXQoKSB7XG4gIGlmICh0aGlzLmxlbmd0aCA+IDApIHtcbiAgICBjb25zdCBlbCA9IHRoaXNbMF07XG4gICAgY29uc3QgYm94ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgY29uc3QgYm9keSA9IGRvY3VtZW50LmJvZHk7XG4gICAgY29uc3QgY2xpZW50VG9wID0gZWwuY2xpZW50VG9wIHx8IGJvZHkuY2xpZW50VG9wIHx8IDA7XG4gICAgY29uc3QgY2xpZW50TGVmdCA9IGVsLmNsaWVudExlZnQgfHwgYm9keS5jbGllbnRMZWZ0IHx8IDA7XG4gICAgY29uc3Qgc2Nyb2xsVG9wID0gZWwgPT09IHdpbmRvdyA/IHdpbmRvdy5zY3JvbGxZIDogZWwuc2Nyb2xsVG9wO1xuICAgIGNvbnN0IHNjcm9sbExlZnQgPSBlbCA9PT0gd2luZG93ID8gd2luZG93LnNjcm9sbFggOiBlbC5zY3JvbGxMZWZ0O1xuICAgIHJldHVybiB7XG4gICAgICB0b3A6IChib3gudG9wICsgc2Nyb2xsVG9wKSAtIGNsaWVudFRvcCxcbiAgICAgIGxlZnQ6IChib3gubGVmdCArIHNjcm9sbExlZnQpIC0gY2xpZW50TGVmdCxcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBoaWRlKCkge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICB0aGlzW2ldLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5mdW5jdGlvbiBzaG93KCkge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICBjb25zdCBlbCA9IHRoaXNbaV07XG4gICAgaWYgKGVsLnN0eWxlLmRpc3BsYXkgPT09ICdub25lJykge1xuICAgICAgZWwuc3R5bGUuZGlzcGxheSA9ICcnO1xuICAgIH1cbiAgICBpZiAod2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwsIG51bGwpLmdldFByb3BlcnR5VmFsdWUoJ2Rpc3BsYXknKSA9PT0gJ25vbmUnKSB7XG4gICAgICAvLyBTdGlsbCBub3QgdmlzaWJsZVxuICAgICAgZWwuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgfVxuICB9XG4gIHJldHVybiB0aGlzO1xufVxuZnVuY3Rpb24gc3R5bGVzKCkge1xuICBpZiAodGhpc1swXSkgcmV0dXJuIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXNbMF0sIG51bGwpO1xuICByZXR1cm4ge307XG59XG5mdW5jdGlvbiBjc3MocHJvcHMsIHZhbHVlKSB7XG4gIGxldCBpO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIGlmICh0eXBlb2YgcHJvcHMgPT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAodGhpc1swXSkgcmV0dXJuIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXNbMF0sIG51bGwpLmdldFByb3BlcnR5VmFsdWUocHJvcHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgZm9yIChsZXQgcHJvcCBpbiBwcm9wcykge1xuICAgICAgICAgIHRoaXNbaV0uc3R5bGVbcHJvcF0gPSBwcm9wc1twcm9wXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyICYmIHR5cGVvZiBwcm9wcyA9PT0gJ3N0cmluZycpIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgdGhpc1tpXS5zdHlsZVtwcm9wc10gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8vIERvbSBtYW5pcHVsYXRpb25cbmZ1bmN0aW9uIHRvQXJyYXkoKSB7XG4gIGNvbnN0IGFyciA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICBhcnIucHVzaCh0aGlzW2ldKTtcbiAgfVxuICByZXR1cm4gYXJyO1xufVxuLy8gSXRlcmF0ZSBvdmVyIHRoZSBjb2xsZWN0aW9uIHBhc3NpbmcgZWxlbWVudHMgdG8gYGNhbGxiYWNrYFxuZnVuY3Rpb24gZWFjaChjYWxsYmFjaykge1xuICAvLyBEb24ndCBib3RoZXIgY29udGludWluZyB3aXRob3V0IGEgY2FsbGJhY2tcbiAgaWYgKCFjYWxsYmFjaykgcmV0dXJuIHRoaXM7XG4gIC8vIEl0ZXJhdGUgb3ZlciB0aGUgY3VycmVudCBjb2xsZWN0aW9uXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgIC8vIElmIHRoZSBjYWxsYmFjayByZXR1cm5zIGZhbHNlXG4gICAgaWYgKGNhbGxiYWNrLmNhbGwodGhpc1tpXSwgaSwgdGhpc1tpXSkgPT09IGZhbHNlKSB7XG4gICAgICAvLyBFbmQgdGhlIGxvb3AgZWFybHlcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfVxuICAvLyBSZXR1cm4gYHRoaXNgIHRvIGFsbG93IGNoYWluZWQgRE9NIG9wZXJhdGlvbnNcbiAgcmV0dXJuIHRoaXM7XG59XG5mdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrKSB7XG4gIC8vIERvbid0IGJvdGhlciBjb250aW51aW5nIHdpdGhvdXQgYSBjYWxsYmFja1xuICBpZiAoIWNhbGxiYWNrKSByZXR1cm4gdGhpcztcbiAgLy8gSXRlcmF0ZSBvdmVyIHRoZSBjdXJyZW50IGNvbGxlY3Rpb25cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgLy8gSWYgdGhlIGNhbGxiYWNrIHJldHVybnMgZmFsc2VcbiAgICBpZiAoY2FsbGJhY2suY2FsbCh0aGlzW2ldLCB0aGlzW2ldLCBpKSA9PT0gZmFsc2UpIHtcbiAgICAgIC8vIEVuZCB0aGUgbG9vcCBlYXJseVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9XG4gIC8vIFJldHVybiBgdGhpc2AgdG8gYWxsb3cgY2hhaW5lZCBET00gb3BlcmF0aW9uc1xuICByZXR1cm4gdGhpcztcbn1cbmZ1bmN0aW9uIGZpbHRlcihjYWxsYmFjaykge1xuICBjb25zdCBtYXRjaGVkSXRlbXMgPSBbXTtcbiAgY29uc3QgZG9tID0gdGhpcztcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBkb20ubGVuZ3RoOyBpICs9IDEpIHtcbiAgICBpZiAoY2FsbGJhY2suY2FsbChkb21baV0sIGksIGRvbVtpXSkpIG1hdGNoZWRJdGVtcy5wdXNoKGRvbVtpXSk7XG4gIH1cbiAgcmV0dXJuIG5ldyBEb203KG1hdGNoZWRJdGVtcyk7XG59XG5mdW5jdGlvbiBtYXAoY2FsbGJhY2spIHtcbiAgY29uc3QgbW9kaWZpZWRJdGVtcyA9IFtdO1xuICBjb25zdCBkb20gPSB0aGlzO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGRvbS5sZW5ndGg7IGkgKz0gMSkge1xuICAgIG1vZGlmaWVkSXRlbXMucHVzaChjYWxsYmFjay5jYWxsKGRvbVtpXSwgaSwgZG9tW2ldKSk7XG4gIH1cbiAgcmV0dXJuIG5ldyBEb203KG1vZGlmaWVkSXRlbXMpO1xufVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG5mdW5jdGlvbiBodG1sKGh0bWwpIHtcbiAgaWYgKHR5cGVvZiBodG1sID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiB0aGlzWzBdID8gdGhpc1swXS5pbm5lckhUTUwgOiB1bmRlZmluZWQ7XG4gIH1cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICB0aGlzW2ldLmlubmVySFRNTCA9IGh0bWw7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbmZ1bmN0aW9uIHRleHQodGV4dCkge1xuICBpZiAodHlwZW9mIHRleHQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKHRoaXNbMF0pIHtcbiAgICAgIHJldHVybiB0aGlzWzBdLnRleHRDb250ZW50LnRyaW0oKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICB0aGlzW2ldLnRleHRDb250ZW50ID0gdGV4dDtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cbmZ1bmN0aW9uIGlzKHNlbGVjdG9yKSB7XG4gIGNvbnN0IGVsID0gdGhpc1swXTtcbiAgbGV0IGNvbXBhcmVXaXRoO1xuICBsZXQgaTtcbiAgaWYgKCFlbCB8fCB0eXBlb2Ygc2VsZWN0b3IgPT09ICd1bmRlZmluZWQnKSByZXR1cm4gZmFsc2U7XG4gIGlmICh0eXBlb2Ygc2VsZWN0b3IgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKGVsLm1hdGNoZXMpIHJldHVybiBlbC5tYXRjaGVzKHNlbGVjdG9yKTtcbiAgICBlbHNlIGlmIChlbC53ZWJraXRNYXRjaGVzU2VsZWN0b3IpIHJldHVybiBlbC53ZWJraXRNYXRjaGVzU2VsZWN0b3Ioc2VsZWN0b3IpO1xuICAgIGVsc2UgaWYgKGVsLm1zTWF0Y2hlc1NlbGVjdG9yKSByZXR1cm4gZWwubXNNYXRjaGVzU2VsZWN0b3Ioc2VsZWN0b3IpO1xuXG4gICAgY29tcGFyZVdpdGggPSAkJDEoc2VsZWN0b3IpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBjb21wYXJlV2l0aC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgaWYgKGNvbXBhcmVXaXRoW2ldID09PSBlbCkgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIGlmIChzZWxlY3RvciA9PT0gZG9jdW1lbnQpIHJldHVybiBlbCA9PT0gZG9jdW1lbnQ7XG4gIGVsc2UgaWYgKHNlbGVjdG9yID09PSB3aW5kb3cpIHJldHVybiBlbCA9PT0gd2luZG93O1xuXG4gIGlmIChzZWxlY3Rvci5ub2RlVHlwZSB8fCBzZWxlY3RvciBpbnN0YW5jZW9mIERvbTcpIHtcbiAgICBjb21wYXJlV2l0aCA9IHNlbGVjdG9yLm5vZGVUeXBlID8gW3NlbGVjdG9yXSA6IHNlbGVjdG9yO1xuICAgIGZvciAoaSA9IDA7IGkgPCBjb21wYXJlV2l0aC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgaWYgKGNvbXBhcmVXaXRoW2ldID09PSBlbCkgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpbmRleE9mKGVsKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgIGlmICh0aGlzW2ldID09PSBlbCkgcmV0dXJuIGk7XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuZnVuY3Rpb24gaW5kZXgoKSB7XG4gIGxldCBjaGlsZCA9IHRoaXNbMF07XG4gIGxldCBpO1xuICBpZiAoY2hpbGQpIHtcbiAgICBpID0gMDtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICB3aGlsZSAoKGNoaWxkID0gY2hpbGQucHJldmlvdXNTaWJsaW5nKSAhPT0gbnVsbCkge1xuICAgICAgaWYgKGNoaWxkLm5vZGVUeXBlID09PSAxKSBpICs9IDE7XG4gICAgfVxuICAgIHJldHVybiBpO1xuICB9XG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbmZ1bmN0aW9uIGVxKGluZGV4KSB7XG4gIGlmICh0eXBlb2YgaW5kZXggPT09ICd1bmRlZmluZWQnKSByZXR1cm4gdGhpcztcbiAgY29uc3QgbGVuZ3RoID0gdGhpcy5sZW5ndGg7XG4gIGxldCByZXR1cm5JbmRleDtcbiAgaWYgKGluZGV4ID4gbGVuZ3RoIC0gMSkge1xuICAgIHJldHVybiBuZXcgRG9tNyhbXSk7XG4gIH1cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIHJldHVybkluZGV4ID0gbGVuZ3RoICsgaW5kZXg7XG4gICAgaWYgKHJldHVybkluZGV4IDwgMCkgcmV0dXJuIG5ldyBEb203KFtdKTtcbiAgICByZXR1cm4gbmV3IERvbTcoW3RoaXNbcmV0dXJuSW5kZXhdXSk7XG4gIH1cbiAgcmV0dXJuIG5ldyBEb203KFt0aGlzW2luZGV4XV0pO1xufVxuZnVuY3Rpb24gYXBwZW5kKC4uLmFyZ3MpIHtcbiAgbGV0IG5ld0NoaWxkO1xuXG4gIGZvciAobGV0IGsgPSAwOyBrIDwgYXJncy5sZW5ndGg7IGsgKz0gMSkge1xuICAgIG5ld0NoaWxkID0gYXJnc1trXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGNvbnN0IHRlbXBEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGVtcERpdi5pbm5lckhUTUwgPSBuZXdDaGlsZDtcbiAgICAgICAgd2hpbGUgKHRlbXBEaXYuZmlyc3RDaGlsZCkge1xuICAgICAgICAgIHRoaXNbaV0uYXBwZW5kQ2hpbGQodGVtcERpdi5maXJzdENoaWxkKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChuZXdDaGlsZCBpbnN0YW5jZW9mIERvbTcpIHtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBuZXdDaGlsZC5sZW5ndGg7IGogKz0gMSkge1xuICAgICAgICAgIHRoaXNbaV0uYXBwZW5kQ2hpbGQobmV3Q2hpbGRbal0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzW2ldLmFwcGVuZENoaWxkKG5ld0NoaWxkKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn1cbiAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbmZ1bmN0aW9uIGFwcGVuZFRvKHBhcmVudCkge1xuICAkJDEocGFyZW50KS5hcHBlbmQodGhpcyk7XG4gIHJldHVybiB0aGlzO1xufVxuZnVuY3Rpb24gcHJlcGVuZChuZXdDaGlsZCkge1xuICBsZXQgaTtcbiAgbGV0IGo7XG4gIGZvciAoaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNvbnN0IHRlbXBEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHRlbXBEaXYuaW5uZXJIVE1MID0gbmV3Q2hpbGQ7XG4gICAgICBmb3IgKGogPSB0ZW1wRGl2LmNoaWxkTm9kZXMubGVuZ3RoIC0gMTsgaiA+PSAwOyBqIC09IDEpIHtcbiAgICAgICAgdGhpc1tpXS5pbnNlcnRCZWZvcmUodGVtcERpdi5jaGlsZE5vZGVzW2pdLCB0aGlzW2ldLmNoaWxkTm9kZXNbMF0pO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobmV3Q2hpbGQgaW5zdGFuY2VvZiBEb203KSB7XG4gICAgICBmb3IgKGogPSAwOyBqIDwgbmV3Q2hpbGQubGVuZ3RoOyBqICs9IDEpIHtcbiAgICAgICAgdGhpc1tpXS5pbnNlcnRCZWZvcmUobmV3Q2hpbGRbal0sIHRoaXNbaV0uY2hpbGROb2Rlc1swXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXNbaV0uaW5zZXJ0QmVmb3JlKG5ld0NoaWxkLCB0aGlzW2ldLmNoaWxkTm9kZXNbMF0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpcztcbn1cbiAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbmZ1bmN0aW9uIHByZXBlbmRUbyhwYXJlbnQpIHtcbiAgJCQxKHBhcmVudCkucHJlcGVuZCh0aGlzKTtcbiAgcmV0dXJuIHRoaXM7XG59XG5mdW5jdGlvbiBpbnNlcnRCZWZvcmUoc2VsZWN0b3IpIHtcbiAgY29uc3QgYmVmb3JlID0gJCQxKHNlbGVjdG9yKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgaWYgKGJlZm9yZS5sZW5ndGggPT09IDEpIHtcbiAgICAgIGJlZm9yZVswXS5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzW2ldLCBiZWZvcmVbMF0pO1xuICAgIH0gZWxzZSBpZiAoYmVmb3JlLmxlbmd0aCA+IDEpIHtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgYmVmb3JlLmxlbmd0aDsgaiArPSAxKSB7XG4gICAgICAgIGJlZm9yZVtqXS5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzW2ldLmNsb25lTm9kZSh0cnVlKSwgYmVmb3JlW2pdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGluc2VydEFmdGVyKHNlbGVjdG9yKSB7XG4gIGNvbnN0IGFmdGVyID0gJCQxKHNlbGVjdG9yKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgaWYgKGFmdGVyLmxlbmd0aCA9PT0gMSkge1xuICAgICAgYWZ0ZXJbMF0ucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpc1tpXSwgYWZ0ZXJbMF0ubmV4dFNpYmxpbmcpO1xuICAgIH0gZWxzZSBpZiAoYWZ0ZXIubGVuZ3RoID4gMSkge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBhZnRlci5sZW5ndGg7IGogKz0gMSkge1xuICAgICAgICBhZnRlcltqXS5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzW2ldLmNsb25lTm9kZSh0cnVlKSwgYWZ0ZXJbal0ubmV4dFNpYmxpbmcpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gbmV4dChzZWxlY3Rvcikge1xuICBpZiAodGhpcy5sZW5ndGggPiAwKSB7XG4gICAgaWYgKHNlbGVjdG9yKSB7XG4gICAgICBpZiAodGhpc1swXS5uZXh0RWxlbWVudFNpYmxpbmcgJiYgJCQxKHRoaXNbMF0ubmV4dEVsZW1lbnRTaWJsaW5nKS5pcyhzZWxlY3RvcikpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEb203KFt0aGlzWzBdLm5leHRFbGVtZW50U2libGluZ10pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBEb203KFtdKTtcbiAgICB9XG5cbiAgICBpZiAodGhpc1swXS5uZXh0RWxlbWVudFNpYmxpbmcpIHJldHVybiBuZXcgRG9tNyhbdGhpc1swXS5uZXh0RWxlbWVudFNpYmxpbmddKTtcbiAgICByZXR1cm4gbmV3IERvbTcoW10pO1xuICB9XG4gIHJldHVybiBuZXcgRG9tNyhbXSk7XG59XG5mdW5jdGlvbiBuZXh0QWxsKHNlbGVjdG9yKSB7XG4gIGNvbnN0IG5leHRFbHMgPSBbXTtcbiAgbGV0IGVsID0gdGhpc1swXTtcbiAgaWYgKCFlbCkgcmV0dXJuIG5ldyBEb203KFtdKTtcbiAgd2hpbGUgKGVsLm5leHRFbGVtZW50U2libGluZykge1xuICAgIGNvbnN0IG5leHQgPSBlbC5uZXh0RWxlbWVudFNpYmxpbmc7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICBpZiAoc2VsZWN0b3IpIHtcbiAgICAgIGlmICgkJDEobmV4dCkuaXMoc2VsZWN0b3IpKSBuZXh0RWxzLnB1c2gobmV4dCk7XG4gICAgfSBlbHNlIG5leHRFbHMucHVzaChuZXh0KTtcbiAgICBlbCA9IG5leHQ7XG4gIH1cbiAgcmV0dXJuIG5ldyBEb203KG5leHRFbHMpO1xufVxuZnVuY3Rpb24gcHJldihzZWxlY3Rvcikge1xuICBpZiAodGhpcy5sZW5ndGggPiAwKSB7XG4gICAgY29uc3QgZWwgPSB0aGlzWzBdO1xuICAgIGlmIChzZWxlY3Rvcikge1xuICAgICAgaWYgKGVsLnByZXZpb3VzRWxlbWVudFNpYmxpbmcgJiYgJCQxKGVsLnByZXZpb3VzRWxlbWVudFNpYmxpbmcpLmlzKHNlbGVjdG9yKSkge1xuICAgICAgICByZXR1cm4gbmV3IERvbTcoW2VsLnByZXZpb3VzRWxlbWVudFNpYmxpbmddKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgRG9tNyhbXSk7XG4gICAgfVxuXG4gICAgaWYgKGVsLnByZXZpb3VzRWxlbWVudFNpYmxpbmcpIHJldHVybiBuZXcgRG9tNyhbZWwucHJldmlvdXNFbGVtZW50U2libGluZ10pO1xuICAgIHJldHVybiBuZXcgRG9tNyhbXSk7XG4gIH1cbiAgcmV0dXJuIG5ldyBEb203KFtdKTtcbn1cbmZ1bmN0aW9uIHByZXZBbGwoc2VsZWN0b3IpIHtcbiAgY29uc3QgcHJldkVscyA9IFtdO1xuICBsZXQgZWwgPSB0aGlzWzBdO1xuICBpZiAoIWVsKSByZXR1cm4gbmV3IERvbTcoW10pO1xuICB3aGlsZSAoZWwucHJldmlvdXNFbGVtZW50U2libGluZykge1xuICAgIGNvbnN0IHByZXYgPSBlbC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgaWYgKHNlbGVjdG9yKSB7XG4gICAgICBpZiAoJCQxKHByZXYpLmlzKHNlbGVjdG9yKSkgcHJldkVscy5wdXNoKHByZXYpO1xuICAgIH0gZWxzZSBwcmV2RWxzLnB1c2gocHJldik7XG4gICAgZWwgPSBwcmV2O1xuICB9XG4gIHJldHVybiBuZXcgRG9tNyhwcmV2RWxzKTtcbn1cbmZ1bmN0aW9uIHNpYmxpbmdzKHNlbGVjdG9yKSB7XG4gIHJldHVybiB0aGlzLm5leHRBbGwoc2VsZWN0b3IpLmFkZCh0aGlzLnByZXZBbGwoc2VsZWN0b3IpKTtcbn1cbmZ1bmN0aW9uIHBhcmVudChzZWxlY3Rvcikge1xuICBjb25zdCBwYXJlbnRzID0gW107IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgaWYgKHRoaXNbaV0ucGFyZW50Tm9kZSAhPT0gbnVsbCkge1xuICAgICAgaWYgKHNlbGVjdG9yKSB7XG4gICAgICAgIGlmICgkJDEodGhpc1tpXS5wYXJlbnROb2RlKS5pcyhzZWxlY3RvcikpIHBhcmVudHMucHVzaCh0aGlzW2ldLnBhcmVudE5vZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyZW50cy5wdXNoKHRoaXNbaV0ucGFyZW50Tm9kZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiAkJDEodW5pcXVlKHBhcmVudHMpKTtcbn1cbmZ1bmN0aW9uIHBhcmVudHMoc2VsZWN0b3IpIHtcbiAgY29uc3QgcGFyZW50cyA9IFtdOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgIGxldCBwYXJlbnQgPSB0aGlzW2ldLnBhcmVudE5vZGU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICBpZiAoc2VsZWN0b3IpIHtcbiAgICAgICAgaWYgKCQkMShwYXJlbnQpLmlzKHNlbGVjdG9yKSkgcGFyZW50cy5wdXNoKHBhcmVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJlbnRzLnB1c2gocGFyZW50KTtcbiAgICAgIH1cbiAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnROb2RlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gJCQxKHVuaXF1ZShwYXJlbnRzKSk7XG59XG5mdW5jdGlvbiBjbG9zZXN0KHNlbGVjdG9yKSB7XG4gIGxldCBjbG9zZXN0ID0gdGhpczsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICBpZiAodHlwZW9mIHNlbGVjdG9yID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBuZXcgRG9tNyhbXSk7XG4gIH1cbiAgaWYgKCFjbG9zZXN0LmlzKHNlbGVjdG9yKSkge1xuICAgIGNsb3Nlc3QgPSBjbG9zZXN0LnBhcmVudHMoc2VsZWN0b3IpLmVxKDApO1xuICB9XG4gIHJldHVybiBjbG9zZXN0O1xufVxuZnVuY3Rpb24gZmluZChzZWxlY3Rvcikge1xuICBjb25zdCBmb3VuZEVsZW1lbnRzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgIGNvbnN0IGZvdW5kID0gdGhpc1tpXS5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGZvdW5kLmxlbmd0aDsgaiArPSAxKSB7XG4gICAgICBmb3VuZEVsZW1lbnRzLnB1c2goZm91bmRbal0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3IERvbTcoZm91bmRFbGVtZW50cyk7XG59XG5mdW5jdGlvbiBjaGlsZHJlbihzZWxlY3Rvcikge1xuICBjb25zdCBjaGlsZHJlbiA9IFtdOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgIGNvbnN0IGNoaWxkTm9kZXMgPSB0aGlzW2ldLmNoaWxkTm9kZXM7XG5cbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNoaWxkTm9kZXMubGVuZ3RoOyBqICs9IDEpIHtcbiAgICAgIGlmICghc2VsZWN0b3IpIHtcbiAgICAgICAgaWYgKGNoaWxkTm9kZXNbal0ubm9kZVR5cGUgPT09IDEpIGNoaWxkcmVuLnB1c2goY2hpbGROb2Rlc1tqXSk7XG4gICAgICB9IGVsc2UgaWYgKGNoaWxkTm9kZXNbal0ubm9kZVR5cGUgPT09IDEgJiYgJCQxKGNoaWxkTm9kZXNbal0pLmlzKHNlbGVjdG9yKSkge1xuICAgICAgICBjaGlsZHJlbi5wdXNoKGNoaWxkTm9kZXNbal0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3IERvbTcodW5pcXVlKGNoaWxkcmVuKSk7XG59XG5mdW5jdGlvbiByZW1vdmUoKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgIGlmICh0aGlzW2ldLnBhcmVudE5vZGUpIHRoaXNbaV0ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzW2ldKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cbmZ1bmN0aW9uIGRldGFjaCgpIHtcbiAgcmV0dXJuIHRoaXMucmVtb3ZlKCk7XG59XG5mdW5jdGlvbiBhZGQoLi4uYXJncykge1xuICBjb25zdCBkb20gPSB0aGlzO1xuICBsZXQgaTtcbiAgbGV0IGo7XG4gIGZvciAoaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgY29uc3QgdG9BZGQgPSAkJDEoYXJnc1tpXSk7XG4gICAgZm9yIChqID0gMDsgaiA8IHRvQWRkLmxlbmd0aDsgaiArPSAxKSB7XG4gICAgICBkb21bZG9tLmxlbmd0aF0gPSB0b0FkZFtqXTtcbiAgICAgIGRvbS5sZW5ndGggKz0gMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRvbTtcbn1cbmZ1bmN0aW9uIGVtcHR5KCkge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICBjb25zdCBlbCA9IHRoaXNbaV07XG4gICAgaWYgKGVsLm5vZGVUeXBlID09PSAxKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGVsLmNoaWxkTm9kZXMubGVuZ3RoOyBqICs9IDEpIHtcbiAgICAgICAgaWYgKGVsLmNoaWxkTm9kZXNbal0ucGFyZW50Tm9kZSkge1xuICAgICAgICAgIGVsLmNoaWxkTm9kZXNbal0ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbC5jaGlsZE5vZGVzW2pdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWwudGV4dENvbnRlbnQgPSAnJztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5cblxuXG5cbnZhciBNZXRob2RzID0gT2JqZWN0LmZyZWV6ZSh7XG5cdGFkZENsYXNzOiBhZGRDbGFzcyxcblx0cmVtb3ZlQ2xhc3M6IHJlbW92ZUNsYXNzLFxuXHRoYXNDbGFzczogaGFzQ2xhc3MsXG5cdHRvZ2dsZUNsYXNzOiB0b2dnbGVDbGFzcyxcblx0YXR0cjogYXR0cixcblx0cmVtb3ZlQXR0cjogcmVtb3ZlQXR0cixcblx0cHJvcDogcHJvcCxcblx0ZGF0YTogZGF0YSxcblx0cmVtb3ZlRGF0YTogcmVtb3ZlRGF0YSxcblx0ZGF0YXNldDogZGF0YXNldCxcblx0dmFsOiB2YWwsXG5cdHRyYW5zZm9ybTogdHJhbnNmb3JtLFxuXHR0cmFuc2l0aW9uOiB0cmFuc2l0aW9uLFxuXHRvbjogb24sXG5cdG9mZjogb2ZmLFxuXHRvbmNlOiBvbmNlLFxuXHR0cmlnZ2VyOiB0cmlnZ2VyLFxuXHR0cmFuc2l0aW9uRW5kOiB0cmFuc2l0aW9uRW5kLFxuXHRhbmltYXRpb25FbmQ6IGFuaW1hdGlvbkVuZCxcblx0d2lkdGg6IHdpZHRoLFxuXHRvdXRlcldpZHRoOiBvdXRlcldpZHRoLFxuXHRoZWlnaHQ6IGhlaWdodCxcblx0b3V0ZXJIZWlnaHQ6IG91dGVySGVpZ2h0LFxuXHRvZmZzZXQ6IG9mZnNldCxcblx0aGlkZTogaGlkZSxcblx0c2hvdzogc2hvdyxcblx0c3R5bGVzOiBzdHlsZXMsXG5cdGNzczogY3NzLFxuXHR0b0FycmF5OiB0b0FycmF5LFxuXHRlYWNoOiBlYWNoLFxuXHRmb3JFYWNoOiBmb3JFYWNoLFxuXHRmaWx0ZXI6IGZpbHRlcixcblx0bWFwOiBtYXAsXG5cdGh0bWw6IGh0bWwsXG5cdHRleHQ6IHRleHQsXG5cdGlzOiBpcyxcblx0aW5kZXhPZjogaW5kZXhPZixcblx0aW5kZXg6IGluZGV4LFxuXHRlcTogZXEsXG5cdGFwcGVuZDogYXBwZW5kLFxuXHRhcHBlbmRUbzogYXBwZW5kVG8sXG5cdHByZXBlbmQ6IHByZXBlbmQsXG5cdHByZXBlbmRUbzogcHJlcGVuZFRvLFxuXHRpbnNlcnRCZWZvcmU6IGluc2VydEJlZm9yZSxcblx0aW5zZXJ0QWZ0ZXI6IGluc2VydEFmdGVyLFxuXHRuZXh0OiBuZXh0LFxuXHRuZXh0QWxsOiBuZXh0QWxsLFxuXHRwcmV2OiBwcmV2LFxuXHRwcmV2QWxsOiBwcmV2QWxsLFxuXHRzaWJsaW5nczogc2libGluZ3MsXG5cdHBhcmVudDogcGFyZW50LFxuXHRwYXJlbnRzOiBwYXJlbnRzLFxuXHRjbG9zZXN0OiBjbG9zZXN0LFxuXHRmaW5kOiBmaW5kLFxuXHRjaGlsZHJlbjogY2hpbGRyZW4sXG5cdHJlbW92ZTogcmVtb3ZlLFxuXHRkZXRhY2g6IGRldGFjaCxcblx0YWRkOiBhZGQsXG5cdGVtcHR5OiBlbXB0eVxufSk7XG5cbmZ1bmN0aW9uIHNjcm9sbFRvKC4uLmFyZ3MpIHtcbiAgbGV0IFtsZWZ0LCB0b3AsIGR1cmF0aW9uLCBlYXNpbmcsIGNhbGxiYWNrXSA9IGFyZ3M7XG4gIGlmIChhcmdzLmxlbmd0aCA9PT0gNCAmJiB0eXBlb2YgZWFzaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBlYXNpbmc7XG4gICAgW2xlZnQsIHRvcCwgZHVyYXRpb24sIGNhbGxiYWNrLCBlYXNpbmddID0gYXJncztcbiAgfVxuICBpZiAodHlwZW9mIGVhc2luZyA9PT0gJ3VuZGVmaW5lZCcpIGVhc2luZyA9ICdzd2luZyc7XG5cbiAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiBhbmltYXRlKCkge1xuICAgIGNvbnN0IGVsID0gdGhpcztcbiAgICBsZXQgY3VycmVudFRvcDtcbiAgICBsZXQgY3VycmVudExlZnQ7XG4gICAgbGV0IG1heFRvcDtcbiAgICBsZXQgbWF4TGVmdDtcbiAgICBsZXQgbmV3VG9wO1xuICAgIGxldCBuZXdMZWZ0O1xuICAgIGxldCBzY3JvbGxUb3A7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICBsZXQgc2Nyb2xsTGVmdDsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIGxldCBhbmltYXRlVG9wID0gdG9wID4gMCB8fCB0b3AgPT09IDA7XG4gICAgbGV0IGFuaW1hdGVMZWZ0ID0gbGVmdCA+IDAgfHwgbGVmdCA9PT0gMDtcbiAgICBpZiAodHlwZW9mIGVhc2luZyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGVhc2luZyA9ICdzd2luZyc7XG4gICAgfVxuICAgIGlmIChhbmltYXRlVG9wKSB7XG4gICAgICBjdXJyZW50VG9wID0gZWwuc2Nyb2xsVG9wO1xuICAgICAgaWYgKCFkdXJhdGlvbikge1xuICAgICAgICBlbC5zY3JvbGxUb3AgPSB0b3A7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChhbmltYXRlTGVmdCkge1xuICAgICAgY3VycmVudExlZnQgPSBlbC5zY3JvbGxMZWZ0O1xuICAgICAgaWYgKCFkdXJhdGlvbikge1xuICAgICAgICBlbC5zY3JvbGxMZWZ0ID0gbGVmdDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFkdXJhdGlvbikgcmV0dXJuO1xuICAgIGlmIChhbmltYXRlVG9wKSB7XG4gICAgICBtYXhUb3AgPSBlbC5zY3JvbGxIZWlnaHQgLSBlbC5vZmZzZXRIZWlnaHQ7XG4gICAgICBuZXdUb3AgPSBNYXRoLm1heChNYXRoLm1pbih0b3AsIG1heFRvcCksIDApO1xuICAgIH1cbiAgICBpZiAoYW5pbWF0ZUxlZnQpIHtcbiAgICAgIG1heExlZnQgPSBlbC5zY3JvbGxXaWR0aCAtIGVsLm9mZnNldFdpZHRoO1xuICAgICAgbmV3TGVmdCA9IE1hdGgubWF4KE1hdGgubWluKGxlZnQsIG1heExlZnQpLCAwKTtcbiAgICB9XG4gICAgbGV0IHN0YXJ0VGltZSA9IG51bGw7XG4gICAgaWYgKGFuaW1hdGVUb3AgJiYgbmV3VG9wID09PSBjdXJyZW50VG9wKSBhbmltYXRlVG9wID0gZmFsc2U7XG4gICAgaWYgKGFuaW1hdGVMZWZ0ICYmIG5ld0xlZnQgPT09IGN1cnJlbnRMZWZ0KSBhbmltYXRlTGVmdCA9IGZhbHNlO1xuICAgIGZ1bmN0aW9uIHJlbmRlcih0aW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCkpIHtcbiAgICAgIGlmIChzdGFydFRpbWUgPT09IG51bGwpIHtcbiAgICAgICAgc3RhcnRUaW1lID0gdGltZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHByb2dyZXNzID0gTWF0aC5tYXgoTWF0aC5taW4oKHRpbWUgLSBzdGFydFRpbWUpIC8gZHVyYXRpb24sIDEpLCAwKTtcbiAgICAgIGNvbnN0IGVhc2VQcm9ncmVzcyA9IGVhc2luZyA9PT0gJ2xpbmVhcicgPyBwcm9ncmVzcyA6ICgwLjUgLSAoTWF0aC5jb3MocHJvZ3Jlc3MgKiBNYXRoLlBJKSAvIDIpKTtcbiAgICAgIGxldCBkb25lO1xuICAgICAgaWYgKGFuaW1hdGVUb3ApIHNjcm9sbFRvcCA9IGN1cnJlbnRUb3AgKyAoZWFzZVByb2dyZXNzICogKG5ld1RvcCAtIGN1cnJlbnRUb3ApKTtcbiAgICAgIGlmIChhbmltYXRlTGVmdCkgc2Nyb2xsTGVmdCA9IGN1cnJlbnRMZWZ0ICsgKGVhc2VQcm9ncmVzcyAqIChuZXdMZWZ0IC0gY3VycmVudExlZnQpKTtcbiAgICAgIGlmIChhbmltYXRlVG9wICYmIG5ld1RvcCA+IGN1cnJlbnRUb3AgJiYgc2Nyb2xsVG9wID49IG5ld1RvcCkge1xuICAgICAgICBlbC5zY3JvbGxUb3AgPSBuZXdUb3A7XG4gICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGFuaW1hdGVUb3AgJiYgbmV3VG9wIDwgY3VycmVudFRvcCAmJiBzY3JvbGxUb3AgPD0gbmV3VG9wKSB7XG4gICAgICAgIGVsLnNjcm9sbFRvcCA9IG5ld1RvcDtcbiAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoYW5pbWF0ZUxlZnQgJiYgbmV3TGVmdCA+IGN1cnJlbnRMZWZ0ICYmIHNjcm9sbExlZnQgPj0gbmV3TGVmdCkge1xuICAgICAgICBlbC5zY3JvbGxMZWZ0ID0gbmV3TGVmdDtcbiAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoYW5pbWF0ZUxlZnQgJiYgbmV3TGVmdCA8IGN1cnJlbnRMZWZ0ICYmIHNjcm9sbExlZnQgPD0gbmV3TGVmdCkge1xuICAgICAgICBlbC5zY3JvbGxMZWZ0ID0gbmV3TGVmdDtcbiAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChkb25lKSB7XG4gICAgICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2soKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGFuaW1hdGVUb3ApIGVsLnNjcm9sbFRvcCA9IHNjcm9sbFRvcDtcbiAgICAgIGlmIChhbmltYXRlTGVmdCkgZWwuc2Nyb2xsTGVmdCA9IHNjcm9sbExlZnQ7XG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUocmVuZGVyKTtcbiAgICB9XG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJlbmRlcik7XG4gIH0pO1xufVxuLy8gc2Nyb2xsVG9wKHRvcCwgZHVyYXRpb24sIGVhc2luZywgY2FsbGJhY2spIHtcbmZ1bmN0aW9uIHNjcm9sbFRvcCguLi5hcmdzKSB7XG4gIGxldCBbdG9wLCBkdXJhdGlvbiwgZWFzaW5nLCBjYWxsYmFja10gPSBhcmdzO1xuICBpZiAoYXJncy5sZW5ndGggPT09IDMgJiYgdHlwZW9mIGVhc2luZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIFt0b3AsIGR1cmF0aW9uLCBjYWxsYmFjaywgZWFzaW5nXSA9IGFyZ3M7XG4gIH1cbiAgY29uc3QgZG9tID0gdGhpcztcbiAgaWYgKHR5cGVvZiB0b3AgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKGRvbS5sZW5ndGggPiAwKSByZXR1cm4gZG9tWzBdLnNjcm9sbFRvcDtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gZG9tLnNjcm9sbFRvKHVuZGVmaW5lZCwgdG9wLCBkdXJhdGlvbiwgZWFzaW5nLCBjYWxsYmFjayk7XG59XG5mdW5jdGlvbiBzY3JvbGxMZWZ0KC4uLmFyZ3MpIHtcbiAgbGV0IFtsZWZ0LCBkdXJhdGlvbiwgZWFzaW5nLCBjYWxsYmFja10gPSBhcmdzO1xuICBpZiAoYXJncy5sZW5ndGggPT09IDMgJiYgdHlwZW9mIGVhc2luZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIFtsZWZ0LCBkdXJhdGlvbiwgY2FsbGJhY2ssIGVhc2luZ10gPSBhcmdzO1xuICB9XG4gIGNvbnN0IGRvbSA9IHRoaXM7XG4gIGlmICh0eXBlb2YgbGVmdCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAoZG9tLmxlbmd0aCA+IDApIHJldHVybiBkb21bMF0uc2Nyb2xsTGVmdDtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gZG9tLnNjcm9sbFRvKGxlZnQsIHVuZGVmaW5lZCwgZHVyYXRpb24sIGVhc2luZywgY2FsbGJhY2spO1xufVxuXG5cblxuXG52YXIgU2Nyb2xsID0gT2JqZWN0LmZyZWV6ZSh7XG5cdHNjcm9sbFRvOiBzY3JvbGxUbyxcblx0c2Nyb2xsVG9wOiBzY3JvbGxUb3AsXG5cdHNjcm9sbExlZnQ6IHNjcm9sbExlZnRcbn0pO1xuXG5mdW5jdGlvbiBhbmltYXRlKGluaXRpYWxQcm9wcywgaW5pdGlhbFBhcmFtcykge1xuICBjb25zdCBlbHMgPSB0aGlzO1xuICBjb25zdCBhID0ge1xuICAgIHByb3BzOiBPYmplY3QuYXNzaWduKHt9LCBpbml0aWFsUHJvcHMpLFxuICAgIHBhcmFtczogT2JqZWN0LmFzc2lnbih7XG4gICAgICBkdXJhdGlvbjogMzAwLFxuICAgICAgZWFzaW5nOiAnc3dpbmcnLCAvLyBvciAnbGluZWFyJ1xuICAgICAgLyogQ2FsbGJhY2tzXG4gICAgICBiZWdpbihlbGVtZW50cylcbiAgICAgIGNvbXBsZXRlKGVsZW1lbnRzKVxuICAgICAgcHJvZ3Jlc3MoZWxlbWVudHMsIGNvbXBsZXRlLCByZW1haW5pbmcsIHN0YXJ0LCB0d2VlblZhbHVlKVxuICAgICAgKi9cbiAgICB9LCBpbml0aWFsUGFyYW1zKSxcblxuICAgIGVsZW1lbnRzOiBlbHMsXG4gICAgYW5pbWF0aW5nOiBmYWxzZSxcbiAgICBxdWU6IFtdLFxuXG4gICAgZWFzaW5nUHJvZ3Jlc3MoZWFzaW5nLCBwcm9ncmVzcykge1xuICAgICAgaWYgKGVhc2luZyA9PT0gJ3N3aW5nJykge1xuICAgICAgICByZXR1cm4gMC41IC0gKE1hdGguY29zKHByb2dyZXNzICogTWF0aC5QSSkgLyAyKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgZWFzaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBlYXNpbmcocHJvZ3Jlc3MpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHByb2dyZXNzO1xuICAgIH0sXG4gICAgc3RvcCgpIHtcbiAgICAgIGlmIChhLmZyYW1lSWQpIHtcbiAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoYS5mcmFtZUlkKTtcbiAgICAgIH1cbiAgICAgIGEuYW5pbWF0aW5nID0gZmFsc2U7XG4gICAgICBhLmVsZW1lbnRzLmVhY2goKGluZGV4LCBlbCkgPT4ge1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gZWw7XG4gICAgICAgIGRlbGV0ZSBlbGVtZW50LmRvbTdBbmltYXRlSW5zdGFuY2U7XG4gICAgICB9KTtcbiAgICAgIGEucXVlID0gW107XG4gICAgfSxcbiAgICBkb25lKGNvbXBsZXRlKSB7XG4gICAgICBhLmFuaW1hdGluZyA9IGZhbHNlO1xuICAgICAgYS5lbGVtZW50cy5lYWNoKChpbmRleCwgZWwpID0+IHtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IGVsO1xuICAgICAgICBkZWxldGUgZWxlbWVudC5kb203QW5pbWF0ZUluc3RhbmNlO1xuICAgICAgfSk7XG4gICAgICBpZiAoY29tcGxldGUpIGNvbXBsZXRlKGVscyk7XG4gICAgICBpZiAoYS5xdWUubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBxdWUgPSBhLnF1ZS5zaGlmdCgpO1xuICAgICAgICBhLmFuaW1hdGUocXVlWzBdLCBxdWVbMV0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgYW5pbWF0ZShwcm9wcywgcGFyYW1zKSB7XG4gICAgICBpZiAoYS5hbmltYXRpbmcpIHtcbiAgICAgICAgYS5xdWUucHVzaChbcHJvcHMsIHBhcmFtc10pO1xuICAgICAgICByZXR1cm4gYTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGVsZW1lbnRzID0gW107XG5cbiAgICAgIC8vIERlZmluZSAmIENhY2hlIEluaXRpYWxzICYgVW5pdHNcbiAgICAgIGEuZWxlbWVudHMuZWFjaCgoaW5kZXgsIGVsKSA9PiB7XG4gICAgICAgIGxldCBpbml0aWFsRnVsbFZhbHVlO1xuICAgICAgICBsZXQgaW5pdGlhbFZhbHVlO1xuICAgICAgICBsZXQgdW5pdDtcbiAgICAgICAgbGV0IGZpbmFsVmFsdWU7XG4gICAgICAgIGxldCBmaW5hbEZ1bGxWYWx1ZTtcblxuICAgICAgICBpZiAoIWVsLmRvbTdBbmltYXRlSW5zdGFuY2UpIGEuZWxlbWVudHNbaW5kZXhdLmRvbTdBbmltYXRlSW5zdGFuY2UgPSBhO1xuXG4gICAgICAgIGVsZW1lbnRzW2luZGV4XSA9IHtcbiAgICAgICAgICBjb250YWluZXI6IGVsLFxuICAgICAgICB9O1xuICAgICAgICBPYmplY3Qua2V5cyhwcm9wcykuZm9yRWFjaCgocHJvcCkgPT4ge1xuICAgICAgICAgIGluaXRpYWxGdWxsVmFsdWUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCwgbnVsbCkuZ2V0UHJvcGVydHlWYWx1ZShwcm9wKS5yZXBsYWNlKCcsJywgJy4nKTtcbiAgICAgICAgICBpbml0aWFsVmFsdWUgPSBwYXJzZUZsb2F0KGluaXRpYWxGdWxsVmFsdWUpO1xuICAgICAgICAgIHVuaXQgPSBpbml0aWFsRnVsbFZhbHVlLnJlcGxhY2UoaW5pdGlhbFZhbHVlLCAnJyk7XG4gICAgICAgICAgZmluYWxWYWx1ZSA9IHBhcnNlRmxvYXQocHJvcHNbcHJvcF0pO1xuICAgICAgICAgIGZpbmFsRnVsbFZhbHVlID0gcHJvcHNbcHJvcF0gKyB1bml0O1xuICAgICAgICAgIGVsZW1lbnRzW2luZGV4XVtwcm9wXSA9IHtcbiAgICAgICAgICAgIGluaXRpYWxGdWxsVmFsdWUsXG4gICAgICAgICAgICBpbml0aWFsVmFsdWUsXG4gICAgICAgICAgICB1bml0LFxuICAgICAgICAgICAgZmluYWxWYWx1ZSxcbiAgICAgICAgICAgIGZpbmFsRnVsbFZhbHVlLFxuICAgICAgICAgICAgY3VycmVudFZhbHVlOiBpbml0aWFsVmFsdWUsXG4gICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgbGV0IHN0YXJ0VGltZSA9IG51bGw7XG4gICAgICBsZXQgdGltZTtcbiAgICAgIGxldCBlbGVtZW50c0RvbmUgPSAwO1xuICAgICAgbGV0IHByb3BzRG9uZSA9IDA7XG4gICAgICBsZXQgZG9uZTtcbiAgICAgIGxldCBiZWdhbiA9IGZhbHNlO1xuXG4gICAgICBhLmFuaW1hdGluZyA9IHRydWU7XG5cbiAgICAgIGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgICAgdGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICBsZXQgcHJvZ3Jlc3M7XG4gICAgICAgIGxldCBlYXNlUHJvZ3Jlc3M7XG4gICAgICAgIC8vIGxldCBlbDtcbiAgICAgICAgaWYgKCFiZWdhbikge1xuICAgICAgICAgIGJlZ2FuID0gdHJ1ZTtcbiAgICAgICAgICBpZiAocGFyYW1zLmJlZ2luKSBwYXJhbXMuYmVnaW4oZWxzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhcnRUaW1lID09PSBudWxsKSB7XG4gICAgICAgICAgc3RhcnRUaW1lID0gdGltZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyYW1zLnByb2dyZXNzKSB7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgICAgcGFyYW1zLnByb2dyZXNzKGVscywgTWF0aC5tYXgoTWF0aC5taW4oKHRpbWUgLSBzdGFydFRpbWUpIC8gcGFyYW1zLmR1cmF0aW9uLCAxKSwgMCksICgoc3RhcnRUaW1lICsgcGFyYW1zLmR1cmF0aW9uKSAtIHRpbWUgPCAwID8gMCA6IChzdGFydFRpbWUgKyBwYXJhbXMuZHVyYXRpb24pIC0gdGltZSksIHN0YXJ0VGltZSk7XG4gICAgICAgIH1cblxuICAgICAgICBlbGVtZW50cy5mb3JFYWNoKChlbGVtZW50KSA9PiB7XG4gICAgICAgICAgY29uc3QgZWwgPSBlbGVtZW50O1xuICAgICAgICAgIGlmIChkb25lIHx8IGVsLmRvbmUpIHJldHVybjtcbiAgICAgICAgICBPYmplY3Qua2V5cyhwcm9wcykuZm9yRWFjaCgocHJvcCkgPT4ge1xuICAgICAgICAgICAgaWYgKGRvbmUgfHwgZWwuZG9uZSkgcmV0dXJuO1xuICAgICAgICAgICAgcHJvZ3Jlc3MgPSBNYXRoLm1heChNYXRoLm1pbigodGltZSAtIHN0YXJ0VGltZSkgLyBwYXJhbXMuZHVyYXRpb24sIDEpLCAwKTtcbiAgICAgICAgICAgIGVhc2VQcm9ncmVzcyA9IGEuZWFzaW5nUHJvZ3Jlc3MocGFyYW1zLmVhc2luZywgcHJvZ3Jlc3MpO1xuICAgICAgICAgICAgY29uc3QgeyBpbml0aWFsVmFsdWUsIGZpbmFsVmFsdWUsIHVuaXQgfSA9IGVsW3Byb3BdO1xuICAgICAgICAgICAgZWxbcHJvcF0uY3VycmVudFZhbHVlID0gaW5pdGlhbFZhbHVlICsgKGVhc2VQcm9ncmVzcyAqIChmaW5hbFZhbHVlIC0gaW5pdGlhbFZhbHVlKSk7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50VmFsdWUgPSBlbFtwcm9wXS5jdXJyZW50VmFsdWU7XG5cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgKGZpbmFsVmFsdWUgPiBpbml0aWFsVmFsdWUgJiYgY3VycmVudFZhbHVlID49IGZpbmFsVmFsdWUpIHx8XG4gICAgICAgICAgICAgIChmaW5hbFZhbHVlIDwgaW5pdGlhbFZhbHVlICYmIGN1cnJlbnRWYWx1ZSA8PSBmaW5hbFZhbHVlKSkge1xuICAgICAgICAgICAgICBlbC5jb250YWluZXIuc3R5bGVbcHJvcF0gPSBmaW5hbFZhbHVlICsgdW5pdDtcbiAgICAgICAgICAgICAgcHJvcHNEb25lICs9IDE7XG4gICAgICAgICAgICAgIGlmIChwcm9wc0RvbmUgPT09IE9iamVjdC5rZXlzKHByb3BzKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBlbC5kb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBlbGVtZW50c0RvbmUgKz0gMTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoZWxlbWVudHNEb25lID09PSBlbGVtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgYS5kb25lKHBhcmFtcy5jb21wbGV0ZSk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsLmNvbnRhaW5lci5zdHlsZVtwcm9wXSA9IGN1cnJlbnRWYWx1ZSArIHVuaXQ7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZG9uZSkgcmV0dXJuO1xuICAgICAgICAvLyBUaGVuIGNhbGxcbiAgICAgICAgYS5mcmFtZUlkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJlbmRlcik7XG4gICAgICB9XG4gICAgICBhLmZyYW1lSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUocmVuZGVyKTtcbiAgICAgIHJldHVybiBhO1xuICAgIH0sXG4gIH07XG5cbiAgaWYgKGEuZWxlbWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGVscztcbiAgfVxuXG4gIGxldCBhbmltYXRlSW5zdGFuY2U7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYS5lbGVtZW50cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgIGlmIChhLmVsZW1lbnRzW2ldLmRvbTdBbmltYXRlSW5zdGFuY2UpIHtcbiAgICAgIGFuaW1hdGVJbnN0YW5jZSA9IGEuZWxlbWVudHNbaV0uZG9tN0FuaW1hdGVJbnN0YW5jZTtcbiAgICB9IGVsc2UgYS5lbGVtZW50c1tpXS5kb203QW5pbWF0ZUluc3RhbmNlID0gYTtcbiAgfVxuICBpZiAoIWFuaW1hdGVJbnN0YW5jZSkge1xuICAgIGFuaW1hdGVJbnN0YW5jZSA9IGE7XG4gIH1cblxuICBpZiAoaW5pdGlhbFByb3BzID09PSAnc3RvcCcpIHtcbiAgICBhbmltYXRlSW5zdGFuY2Uuc3RvcCgpO1xuICB9IGVsc2Uge1xuICAgIGFuaW1hdGVJbnN0YW5jZS5hbmltYXRlKGEucHJvcHMsIGEucGFyYW1zKTtcbiAgfVxuXG4gIHJldHVybiBlbHM7XG59XG5cbmZ1bmN0aW9uIHN0b3AoKSB7XG4gIGNvbnN0IGVscyA9IHRoaXM7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZWxzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgaWYgKGVsc1tpXS5kb203QW5pbWF0ZUluc3RhbmNlKSB7XG4gICAgICBlbHNbaV0uZG9tN0FuaW1hdGVJbnN0YW5jZS5zdG9wKCk7XG4gICAgfVxuICB9XG59XG5cblxuXG5cbnZhciBBbmltYXRlID0gT2JqZWN0LmZyZWV6ZSh7XG5cdGFuaW1hdGU6IGFuaW1hdGUsXG5cdHN0b3A6IHN0b3Bcbn0pO1xuXG5jb25zdCBub1RyaWdnZXIgPSAoJ3Jlc2l6ZSBzY3JvbGwnKS5zcGxpdCgnICcpO1xuZnVuY3Rpb24gZXZlbnRTaG9ydGN1dChuYW1lLCAuLi5hcmdzKSB7XG4gIGlmICh0eXBlb2YgYXJnc1swXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGlmIChub1RyaWdnZXIuaW5kZXhPZihuYW1lKSA8IDApIHtcbiAgICAgICAgaWYgKG5hbWUgaW4gdGhpc1tpXSkgdGhpc1tpXVtuYW1lXSgpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAkJDEodGhpc1tpXSkudHJpZ2dlcihuYW1lKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICByZXR1cm4gdGhpcy5vbihuYW1lLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gY2xpY2soLi4uYXJncykge1xuICByZXR1cm4gZXZlbnRTaG9ydGN1dC5iaW5kKHRoaXMpKCdjbGljaycsIC4uLmFyZ3MpO1xufVxuZnVuY3Rpb24gYmx1ciguLi5hcmdzKSB7XG4gIHJldHVybiBldmVudFNob3J0Y3V0LmJpbmQodGhpcykoJ2JsdXInLCAuLi5hcmdzKTtcbn1cbmZ1bmN0aW9uIGZvY3VzKC4uLmFyZ3MpIHtcbiAgcmV0dXJuIGV2ZW50U2hvcnRjdXQuYmluZCh0aGlzKSgnZm9jdXMnLCAuLi5hcmdzKTtcbn1cbmZ1bmN0aW9uIGZvY3VzaW4oLi4uYXJncykge1xuICByZXR1cm4gZXZlbnRTaG9ydGN1dC5iaW5kKHRoaXMpKCdmb2N1c2luJywgLi4uYXJncyk7XG59XG5mdW5jdGlvbiBmb2N1c291dCguLi5hcmdzKSB7XG4gIHJldHVybiBldmVudFNob3J0Y3V0LmJpbmQodGhpcykoJ2ZvY3Vzb3V0JywgLi4uYXJncyk7XG59XG5mdW5jdGlvbiBrZXl1cCguLi5hcmdzKSB7XG4gIHJldHVybiBldmVudFNob3J0Y3V0LmJpbmQodGhpcykoJ2tleXVwJywgLi4uYXJncyk7XG59XG5mdW5jdGlvbiBrZXlkb3duKC4uLmFyZ3MpIHtcbiAgcmV0dXJuIGV2ZW50U2hvcnRjdXQuYmluZCh0aGlzKSgna2V5ZG93bicsIC4uLmFyZ3MpO1xufVxuZnVuY3Rpb24ga2V5cHJlc3MoLi4uYXJncykge1xuICByZXR1cm4gZXZlbnRTaG9ydGN1dC5iaW5kKHRoaXMpKCdrZXlwcmVzcycsIC4uLmFyZ3MpO1xufVxuZnVuY3Rpb24gc3VibWl0KC4uLmFyZ3MpIHtcbiAgcmV0dXJuIGV2ZW50U2hvcnRjdXQuYmluZCh0aGlzKSgnc3VibWl0JywgLi4uYXJncyk7XG59XG5mdW5jdGlvbiBjaGFuZ2UoLi4uYXJncykge1xuICByZXR1cm4gZXZlbnRTaG9ydGN1dC5iaW5kKHRoaXMpKCdjaGFuZ2UnLCAuLi5hcmdzKTtcbn1cbmZ1bmN0aW9uIG1vdXNlZG93biguLi5hcmdzKSB7XG4gIHJldHVybiBldmVudFNob3J0Y3V0LmJpbmQodGhpcykoJ21vdXNlZG93bicsIC4uLmFyZ3MpO1xufVxuZnVuY3Rpb24gbW91c2Vtb3ZlKC4uLmFyZ3MpIHtcbiAgcmV0dXJuIGV2ZW50U2hvcnRjdXQuYmluZCh0aGlzKSgnbW91c2Vtb3ZlJywgLi4uYXJncyk7XG59XG5mdW5jdGlvbiBtb3VzZXVwKC4uLmFyZ3MpIHtcbiAgcmV0dXJuIGV2ZW50U2hvcnRjdXQuYmluZCh0aGlzKSgnbW91c2V1cCcsIC4uLmFyZ3MpO1xufVxuZnVuY3Rpb24gbW91c2VlbnRlciguLi5hcmdzKSB7XG4gIHJldHVybiBldmVudFNob3J0Y3V0LmJpbmQodGhpcykoJ21vdXNlZW50ZXInLCAuLi5hcmdzKTtcbn1cbmZ1bmN0aW9uIG1vdXNlbGVhdmUoLi4uYXJncykge1xuICByZXR1cm4gZXZlbnRTaG9ydGN1dC5iaW5kKHRoaXMpKCdtb3VzZWxlYXZlJywgLi4uYXJncyk7XG59XG5mdW5jdGlvbiBtb3VzZW91dCguLi5hcmdzKSB7XG4gIHJldHVybiBldmVudFNob3J0Y3V0LmJpbmQodGhpcykoJ21vdXNlb3V0JywgLi4uYXJncyk7XG59XG5mdW5jdGlvbiBtb3VzZW92ZXIoLi4uYXJncykge1xuICByZXR1cm4gZXZlbnRTaG9ydGN1dC5iaW5kKHRoaXMpKCdtb3VzZW92ZXInLCAuLi5hcmdzKTtcbn1cbmZ1bmN0aW9uIHRvdWNoc3RhcnQoLi4uYXJncykge1xuICByZXR1cm4gZXZlbnRTaG9ydGN1dC5iaW5kKHRoaXMpKCd0b3VjaHN0YXJ0JywgLi4uYXJncyk7XG59XG5mdW5jdGlvbiB0b3VjaGVuZCguLi5hcmdzKSB7XG4gIHJldHVybiBldmVudFNob3J0Y3V0LmJpbmQodGhpcykoJ3RvdWNoZW5kJywgLi4uYXJncyk7XG59XG5mdW5jdGlvbiB0b3VjaG1vdmUoLi4uYXJncykge1xuICByZXR1cm4gZXZlbnRTaG9ydGN1dC5iaW5kKHRoaXMpKCd0b3VjaG1vdmUnLCAuLi5hcmdzKTtcbn1cbmZ1bmN0aW9uIHJlc2l6ZSguLi5hcmdzKSB7XG4gIHJldHVybiBldmVudFNob3J0Y3V0LmJpbmQodGhpcykoJ3Jlc2l6ZScsIC4uLmFyZ3MpO1xufVxuZnVuY3Rpb24gc2Nyb2xsKC4uLmFyZ3MpIHtcbiAgcmV0dXJuIGV2ZW50U2hvcnRjdXQuYmluZCh0aGlzKSgnc2Nyb2xsJywgLi4uYXJncyk7XG59XG5cblxuXG5cbnZhciBldmVudFNob3J0Y3V0cyA9IE9iamVjdC5mcmVlemUoe1xuXHRjbGljazogY2xpY2ssXG5cdGJsdXI6IGJsdXIsXG5cdGZvY3VzOiBmb2N1cyxcblx0Zm9jdXNpbjogZm9jdXNpbixcblx0Zm9jdXNvdXQ6IGZvY3Vzb3V0LFxuXHRrZXl1cDoga2V5dXAsXG5cdGtleWRvd246IGtleWRvd24sXG5cdGtleXByZXNzOiBrZXlwcmVzcyxcblx0c3VibWl0OiBzdWJtaXQsXG5cdGNoYW5nZTogY2hhbmdlLFxuXHRtb3VzZWRvd246IG1vdXNlZG93bixcblx0bW91c2Vtb3ZlOiBtb3VzZW1vdmUsXG5cdG1vdXNldXA6IG1vdXNldXAsXG5cdG1vdXNlZW50ZXI6IG1vdXNlZW50ZXIsXG5cdG1vdXNlbGVhdmU6IG1vdXNlbGVhdmUsXG5cdG1vdXNlb3V0OiBtb3VzZW91dCxcblx0bW91c2VvdmVyOiBtb3VzZW92ZXIsXG5cdHRvdWNoc3RhcnQ6IHRvdWNoc3RhcnQsXG5cdHRvdWNoZW5kOiB0b3VjaGVuZCxcblx0dG91Y2htb3ZlOiB0b3VjaG1vdmUsXG5cdHJlc2l6ZTogcmVzaXplLFxuXHRzY3JvbGw6IHNjcm9sbFxufSk7XG5cbltNZXRob2RzLCBTY3JvbGwsIEFuaW1hdGUsIGV2ZW50U2hvcnRjdXRzXS5mb3JFYWNoKChncm91cCkgPT4ge1xuICBPYmplY3Qua2V5cyhncm91cCkuZm9yRWFjaCgobWV0aG9kTmFtZSkgPT4ge1xuICAgICQkMS5mblttZXRob2ROYW1lXSA9IGdyb3VwW21ldGhvZE5hbWVdO1xuICB9KTtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCAkJDE7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9kb203L2Rpc3QvZG9tNy5tb2R1bGUuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2RvbTcvZGlzdC9kb203Lm1vZHVsZS5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxuICogRnJhbWV3b3JrNyBWdWUgMi4yLjVcbiAqIEJ1aWxkIGZ1bGwgZmVhdHVyZWQgaU9TICYgQW5kcm9pZCBhcHBzIHVzaW5nIEZyYW1ld29yazcgJiBWdWVcbiAqIGh0dHA6Ly9mcmFtZXdvcms3LmlvL3Z1ZS9cbiAqXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE4IFZsYWRpbWlyIEtoYXJsYW1waWRpXG4gKlxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG4gKlxuICogUmVsZWFzZWQgb246IEFwcmlsIDI5LCAyMDE4XG4gKi9cblxuY29uc3QgVXRpbHMgPSB7XG4gIGlzVHJ1ZVByb3AodmFsKSB7XG4gICAgcmV0dXJuIHZhbCA9PT0gdHJ1ZSB8fCB2YWwgPT09ICcnO1xuICB9LFxuICBpc1N0cmluZ1Byb3AodmFsKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnICYmIHZhbCAhPT0gJyc7XG4gIH0sXG4gIGlzT2JqZWN0KG8pIHtcbiAgICByZXR1cm4gdHlwZW9mIG8gPT09ICdvYmplY3QnICYmIG8gIT09IG51bGwgJiYgby5jb25zdHJ1Y3RvciAmJiBvLmNvbnN0cnVjdG9yID09PSBPYmplY3Q7XG4gIH0sXG4gIG5vdygpIHtcbiAgICByZXR1cm4gRGF0ZS5ub3coKTtcbiAgfSxcbiAgZXh0ZW5kKC4uLmFyZ3MpIHtcbiAgICBsZXQgZGVlcCA9IHRydWU7XG4gICAgbGV0IHRvO1xuICAgIGxldCBmcm9tO1xuICAgIGlmICh0eXBlb2YgYXJnc1swXSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICBbZGVlcCwgdG9dID0gYXJncztcbiAgICAgIGFyZ3Muc3BsaWNlKDAsIDIpO1xuICAgICAgZnJvbSA9IGFyZ3M7XG4gICAgfSBlbHNlIHtcbiAgICAgIFt0b10gPSBhcmdzO1xuICAgICAgYXJncy5zcGxpY2UoMCwgMSk7XG4gICAgICBmcm9tID0gYXJncztcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmcm9tLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBjb25zdCBuZXh0U291cmNlID0gYXJnc1tpXTtcbiAgICAgIGlmIChuZXh0U291cmNlICE9PSB1bmRlZmluZWQgJiYgbmV4dFNvdXJjZSAhPT0gbnVsbCkge1xuICAgICAgICBjb25zdCBrZXlzQXJyYXkgPSBPYmplY3Qua2V5cyhPYmplY3QobmV4dFNvdXJjZSkpO1xuICAgICAgICBmb3IgKGxldCBuZXh0SW5kZXggPSAwLCBsZW4gPSBrZXlzQXJyYXkubGVuZ3RoOyBuZXh0SW5kZXggPCBsZW47IG5leHRJbmRleCArPSAxKSB7XG4gICAgICAgICAgY29uc3QgbmV4dEtleSA9IGtleXNBcnJheVtuZXh0SW5kZXhdO1xuICAgICAgICAgIGNvbnN0IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG5leHRTb3VyY2UsIG5leHRLZXkpO1xuICAgICAgICAgIGlmIChkZXNjICE9PSB1bmRlZmluZWQgJiYgZGVzYy5lbnVtZXJhYmxlKSB7XG4gICAgICAgICAgICBpZiAoIWRlZXApIHtcbiAgICAgICAgICAgICAgdG9bbmV4dEtleV0gPSBuZXh0U291cmNlW25leHRLZXldO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChVdGlscy5pc09iamVjdCh0b1tuZXh0S2V5XSkgJiYgVXRpbHMuaXNPYmplY3QobmV4dFNvdXJjZVtuZXh0S2V5XSkpIHtcbiAgICAgICAgICAgICAgVXRpbHMuZXh0ZW5kKHRvW25leHRLZXldLCBuZXh0U291cmNlW25leHRLZXldKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIVV0aWxzLmlzT2JqZWN0KHRvW25leHRLZXldKSAmJiBVdGlscy5pc09iamVjdChuZXh0U291cmNlW25leHRLZXldKSkge1xuICAgICAgICAgICAgICB0b1tuZXh0S2V5XSA9IHt9O1xuICAgICAgICAgICAgICBVdGlscy5leHRlbmQodG9bbmV4dEtleV0sIG5leHRTb3VyY2VbbmV4dEtleV0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdG9bbmV4dEtleV0gPSBuZXh0U291cmNlW25leHRLZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdG87XG4gIH0sXG59O1xuXG5jb25zdCBEaXJlY3RpdmVzID0ge307XG5bJ2NvbG9yJywgJ2NvbG9yLXRoZW1lJywgJ3RleHQtY29sb3InLCAnYmctY29sb3InLCAnYm9yZGVyLWNvbG9yJywgJ3JpcHBsZS1jb2xvciddLmZvckVhY2goKG5hbWUpID0+IHtcbiAgRGlyZWN0aXZlc1tgZjctJHtuYW1lfWBdID0gZnVuY3Rpb24gZjdDb2xvckRpcmVjdGl2ZShlbCwgYmluZGluZykge1xuICAgIGNvbnN0IHsgdmFsdWUsIG9sZFZhbHVlIH0gPSBiaW5kaW5nO1xuICAgIGlmICh2YWx1ZSA9PT0gb2xkVmFsdWUpIHJldHVybjtcbiAgICBpZiAoIXZhbHVlICYmICFvbGRWYWx1ZSkgcmV0dXJuO1xuICAgIGlmIChvbGRWYWx1ZSkge1xuICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZShgJHtuYW1lfS0ke29sZFZhbHVlfWApO1xuICAgIH1cbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIGVsLmNsYXNzTGlzdC5hZGQoYCR7bmFtZX0tJHt2YWx1ZX1gKTtcbiAgICB9XG4gIH07XG59KTtcblxuLyogZXNsaW50IG5vLXVuZGVyc2NvcmUtZGFuZ2xlOiBcIm9mZlwiICovXG5cbmxldCByb3V0ZXJDb21wb25lbnRJZENvdW50ZXIgPSAwO1xuXG52YXIgVnVlUm91dGVyID0ge1xuICBwcm90bzoge1xuICAgIHBhZ2VDb21wb25lbnRMb2FkZXIocm91dGVyRWwsIGNvbXBvbmVudCwgY29tcG9uZW50VXJsLCBvcHRpb25zLCByZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIGNvbnN0IHJvdXRlciA9IHRoaXM7XG4gICAgICBjb25zdCBlbCA9IHJvdXRlci4kZWxbMF07XG4gICAgICBsZXQgcm91dGVyVnVlO1xuICAgICAgZnVuY3Rpb24gZmluZFJvdXRlclZ1ZSh2dWVDb21wb25lbnQpIHtcbiAgICAgICAgaWYgKHJvdXRlclZ1ZSkgcmV0dXJuO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgdnVlQ29tcG9uZW50LiR2bm9kZSAmJlxuICAgICAgICAgIHZ1ZUNvbXBvbmVudC4kdm5vZGUudGFnICYmXG4gICAgICAgICAgdnVlQ29tcG9uZW50LiR2bm9kZS50YWcuaW5kZXhPZignZjctdmlldycpID49IDAgJiZcbiAgICAgICAgICB2dWVDb21wb25lbnQucGFnZXNcbiAgICAgICAgKSB7XG4gICAgICAgICAgcm91dGVyVnVlID0gdnVlQ29tcG9uZW50O1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXZ1ZUNvbXBvbmVudC4kY2hpbGRyZW4gfHwgdnVlQ29tcG9uZW50LiRjaGlsZHJlbi5sZW5ndGggPT09IDApIHJldHVybjtcbiAgICAgICAgdnVlQ29tcG9uZW50LiRjaGlsZHJlbi5mb3JFYWNoKChjaGlsZENvbXBvbmVudCkgPT4ge1xuICAgICAgICAgIGZpbmRSb3V0ZXJWdWUoY2hpbGRDb21wb25lbnQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgZmluZFJvdXRlclZ1ZShlbC5fX3Z1ZV9fKTtcblxuICAgICAgaWYgKCFyb3V0ZXJWdWUgfHwgIXJvdXRlclZ1ZS5wYWdlcykge1xuICAgICAgICByZWplY3QoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgaWQgPSBgJHtVdGlscy5ub3coKX1fJHsocm91dGVyQ29tcG9uZW50SWRDb3VudGVyICs9IDEpfWA7XG4gICAgICBjb25zdCBwYWdlRGF0YSA9IHtcbiAgICAgICAgY29tcG9uZW50LFxuICAgICAgICBpZCxcbiAgICAgICAgcGFyYW1zOiBVdGlscy5leHRlbmQoe30sIG9wdGlvbnMucm91dGUucGFyYW1zKSxcbiAgICAgIH07XG4gICAgICByb3V0ZXJWdWUuJGY3cm91dGUgPSBvcHRpb25zLnJvdXRlO1xuICAgICAgcm91dGVyVnVlLnBhZ2VzLnB1c2gocGFnZURhdGEpO1xuICAgICAgcm91dGVyVnVlLiRuZXh0VGljaygoKSA9PiB7XG4gICAgICAgIGNvbnN0IHBhZ2VFbCA9IGVsLmNoaWxkcmVuW2VsLmNoaWxkcmVuLmxlbmd0aCAtIDFdO1xuICAgICAgICBwYWdlRGF0YS5lbCA9IHBhZ2VFbDtcblxuICAgICAgICBsZXQgcGFnZUV2ZW50cztcbiAgICAgICAgaWYgKGNvbXBvbmVudC5vbikge1xuICAgICAgICAgIGxldCBwYWdlVnVlRm91bmQ7XG4gICAgICAgICAgbGV0IHBhZ2VWdWUgPSBwYWdlRWwuX192dWVfXztcbiAgICAgICAgICB3aGlsZSAocGFnZVZ1ZS4kcGFyZW50ICYmICFwYWdlVnVlRm91bmQpIHtcbiAgICAgICAgICAgIGlmIChwYWdlVnVlLiRwYXJlbnQuJGVsID09PSBwYWdlRWwpIHtcbiAgICAgICAgICAgICAgcGFnZVZ1ZSA9IHBhZ2VWdWUuJHBhcmVudDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHBhZ2VWdWVGb3VuZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwYWdlVnVlKSB7XG4gICAgICAgICAgICBwYWdlRXZlbnRzID0gVXRpbHMuZXh0ZW5kKHt9LCBjb21wb25lbnQub24pO1xuICAgICAgICAgICAgT2JqZWN0LmtleXMocGFnZUV2ZW50cykuZm9yRWFjaCgocGFnZUV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgIHBhZ2VFdmVudHNbcGFnZUV2ZW50XSA9IHBhZ2VFdmVudHNbcGFnZUV2ZW50XS5iaW5kKHBhZ2VWdWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmVzb2x2ZShwYWdlRWwsIHsgb246IHBhZ2VFdmVudHMgfSk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIHJlbW92ZVBhZ2UoJHBhZ2VFbCkge1xuICAgICAgaWYgKCEkcGFnZUVsKSByZXR1cm47XG4gICAgICBjb25zdCByb3V0ZXIgPSB0aGlzO1xuICAgICAgY29uc3Qgcm91dGVyVnVlID0gcm91dGVyLiRlbFswXS5fX3Z1ZV9fO1xuXG4gICAgICBsZXQgcGFnZUVsO1xuICAgICAgaWYgKCdsZW5ndGgnIGluICRwYWdlRWwpIHtcbiAgICAgICAgLy8gRG9tN1xuICAgICAgICBpZiAoJHBhZ2VFbC5sZW5ndGggPT09IDApIHJldHVybjtcbiAgICAgICAgcGFnZUVsID0gJHBhZ2VFbFswXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhZ2VFbCA9ICRwYWdlRWw7XG4gICAgICB9XG4gICAgICBpZiAoIXBhZ2VFbCkgcmV0dXJuO1xuICAgICAgbGV0IHBhZ2VWdWVGb3VuZDtcbiAgICAgIHJvdXRlclZ1ZS5wYWdlcy5mb3JFYWNoKChwYWdlLCBpbmRleCkgPT4ge1xuICAgICAgICBpZiAocGFnZS5lbCA9PT0gcGFnZUVsKSB7XG4gICAgICAgICAgcGFnZVZ1ZUZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICByb3V0ZXJWdWUucGFnZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAoIXBhZ2VWdWVGb3VuZCkge1xuICAgICAgICBwYWdlRWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChwYWdlRWwpO1xuICAgICAgfVxuICAgIH0sXG4gICAgdGFiQ29tcG9uZW50TG9hZGVyKHRhYkVsLCBjb21wb25lbnQsIGNvbXBvbmVudFVybCwgb3B0aW9ucywgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBpZiAoIXRhYkVsKSByZWplY3QoKTtcblxuICAgICAgY29uc3QgdGFiVnVlID0gdGFiRWwuX192dWVfXztcbiAgICAgIGlmICghdGFiVnVlKSByZWplY3QoKTtcblxuICAgICAgY29uc3QgaWQgPSBgJHtVdGlscy5ub3coKX1fJHsocm91dGVyQ29tcG9uZW50SWRDb3VudGVyICs9IDEpfWA7XG4gICAgICB0YWJWdWUuJHNldCh0YWJWdWUsICd0YWJDb250ZW50Jywge1xuICAgICAgICBpZCxcbiAgICAgICAgY29tcG9uZW50LFxuICAgICAgICBwYXJhbXM6IFV0aWxzLmV4dGVuZCh7fSwgb3B0aW9ucy5yb3V0ZS5wYXJhbXMpLFxuICAgICAgfSk7XG5cbiAgICAgIGxldCBwYWdlRXZlbnRzO1xuICAgICAgaWYgKGNvbXBvbmVudC5vbikge1xuICAgICAgICBwYWdlRXZlbnRzID0gVXRpbHMuZXh0ZW5kKHt9LCBjb21wb25lbnQub24pO1xuICAgICAgICBPYmplY3Qua2V5cyhwYWdlRXZlbnRzKS5mb3JFYWNoKChwYWdlRXZlbnQpID0+IHtcbiAgICAgICAgICBwYWdlRXZlbnRzW3BhZ2VFdmVudF0gPSBwYWdlRXZlbnRzW3BhZ2VFdmVudF0uYmluZCh0YWJWdWUpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdGFiVnVlLiRuZXh0VGljaygoKSA9PiB7XG4gICAgICAgIGNvbnN0IHRhYkNvbnRlbnRFbCA9IHRhYkVsLmNoaWxkcmVuWzBdO1xuICAgICAgICByZXNvbHZlKHRhYkNvbnRlbnRFbCwgeyBvbjogcGFnZUV2ZW50cyB9KTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgcmVtb3ZlVGFiQ29udGVudCh0YWJFbCkge1xuICAgICAgaWYgKCF0YWJFbCkgcmV0dXJuO1xuXG4gICAgICBjb25zdCB0YWJWdWUgPSB0YWJFbC5fX3Z1ZV9fO1xuICAgICAgaWYgKCF0YWJWdWUpIHtcbiAgICAgICAgdGFiRWwuaW5uZXJIVE1MID0gJyc7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0YWJWdWUuJHNldCh0YWJWdWUsICd0YWJDb250ZW50JywgbnVsbCk7XG4gICAgfSxcbiAgICBtb2RhbENvbXBvbmVudExvYWRlcihyb290RWwsIGNvbXBvbmVudCwgY29tcG9uZW50VXJsLCBvcHRpb25zLCByZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIGNvbnN0IHJvdXRlciA9IHRoaXM7XG4gICAgICBjb25zdCBtb2RhbHNFbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5mcmFtZXdvcms3LW1vZGFscycpO1xuICAgICAgaWYgKCFtb2RhbHNFbCkge1xuICAgICAgICByZWplY3QoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBtb2RhbHNWdWUgPSBtb2RhbHNFbC5fX3Z1ZV9fO1xuICAgICAgaWYgKCFtb2RhbHNWdWUpIHtcbiAgICAgICAgcmVqZWN0KCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgaWQgPSBgJHtVdGlscy5ub3coKX1fJHsocm91dGVyQ29tcG9uZW50SWRDb3VudGVyICs9IDEpfWA7XG4gICAgICBjb25zdCBtb2RhbERhdGEgPSB7XG4gICAgICAgIGNvbXBvbmVudCxcbiAgICAgICAgaWQsXG4gICAgICAgIHBhcmFtczogVXRpbHMuZXh0ZW5kKHt9LCBvcHRpb25zLnJvdXRlLnBhcmFtcyksXG4gICAgICB9O1xuICAgICAgbW9kYWxzVnVlLiRmN3JvdXRlID0gb3B0aW9ucy5yb3V0ZTtcbiAgICAgIG1vZGFsc1Z1ZS5tb2RhbHMucHVzaChtb2RhbERhdGEpO1xuXG4gICAgICBtb2RhbHNWdWUuJG5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgY29uc3QgbW9kYWxFbCA9IG1vZGFsc0VsLmNoaWxkcmVuW21vZGFsc0VsLmNoaWxkcmVuLmxlbmd0aCAtIDFdO1xuICAgICAgICBtb2RhbERhdGEuZWwgPSBtb2RhbEVsO1xuXG4gICAgICAgIGxldCBtb2RhbEV2ZW50cztcbiAgICAgICAgbGV0IG1vZGFsVnVlRm91bmQ7XG4gICAgICAgIGxldCBtb2RhbFZ1ZSA9IG1vZGFsRWwuX192dWVfXztcbiAgICAgICAgd2hpbGUgKG1vZGFsVnVlLiRwYXJlbnQgJiYgIW1vZGFsVnVlRm91bmQpIHtcbiAgICAgICAgICBpZiAobW9kYWxWdWUuJHBhcmVudC4kZWwgPT09IG1vZGFsRWwpIHtcbiAgICAgICAgICAgIG1vZGFsVnVlID0gbW9kYWxWdWUuJHBhcmVudDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbW9kYWxWdWVGb3VuZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjb21wb25lbnQub24gJiYgbW9kYWxWdWUpIHtcbiAgICAgICAgICBtb2RhbEV2ZW50cyA9IFV0aWxzLmV4dGVuZCh7fSwgY29tcG9uZW50Lm9uKTtcbiAgICAgICAgICBPYmplY3Qua2V5cyhtb2RhbEV2ZW50cykuZm9yRWFjaCgocGFnZUV2ZW50KSA9PiB7XG4gICAgICAgICAgICBtb2RhbEV2ZW50c1twYWdlRXZlbnRdID0gbW9kYWxFdmVudHNbcGFnZUV2ZW50XS5iaW5kKG1vZGFsVnVlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIG1vZGFsRWwuYWRkRXZlbnRMaXN0ZW5lcignbW9kYWw6Y2xvc2VkJywgKCkgPT4ge1xuICAgICAgICAgIG1vZGFsc1Z1ZS4kbmV4dFRpY2soKCkgPT4ge1xuICAgICAgICAgICAgcm91dGVyLnJlbW92ZU1vZGFsKG1vZGFsRWwsIG1vZGFsVnVlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmVzb2x2ZShtb2RhbEVsLCB7IG9uOiBtb2RhbEV2ZW50cyB9KTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgcmVtb3ZlTW9kYWwobW9kYWxFbCwgbW9kYWxWdWUpIHtcbiAgICAgIGlmICghbW9kYWxWdWUpIHJldHVybjtcblxuICAgICAgY29uc3QgbW9kYWxzRWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuZnJhbWV3b3JrNy1tb2RhbHMnKTtcbiAgICAgIGlmICghbW9kYWxzRWwpIHJldHVybjtcblxuICAgICAgY29uc3QgbW9kYWxzVnVlID0gbW9kYWxzRWwuX192dWVfXztcbiAgICAgIGlmICghbW9kYWxzVnVlKSByZXR1cm47XG5cbiAgICAgIGxldCBtb2RhbFZ1ZUZvdW5kO1xuICAgICAgbW9kYWxzVnVlLm1vZGFscy5mb3JFYWNoKChtb2RhbCwgaW5kZXgpID0+IHtcbiAgICAgICAgaWYgKG1vZGFsLmVsID09PSBtb2RhbEVsKSB7XG4gICAgICAgICAgbW9kYWxWdWVGb3VuZCA9IHRydWU7XG4gICAgICAgICAgbW9kYWxzVnVlLm1vZGFscy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKCFtb2RhbFZ1ZUZvdW5kKSB7XG4gICAgICAgIG1vZGFsRWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChtb2RhbEVsKTtcbiAgICAgIH1cbiAgICB9LFxuICB9LFxufTtcblxuY29uc3QgTWl4aW5zID0ge1xuICBjb2xvclByb3BzOiB7XG4gICAgY29sb3I6IFN0cmluZyxcbiAgICBjb2xvclRoZW1lOiBTdHJpbmcsXG4gICAgdGV4dENvbG9yOiBTdHJpbmcsXG4gICAgYmdDb2xvcjogU3RyaW5nLFxuICAgIGJvcmRlckNvbG9yOiBTdHJpbmcsXG4gICAgcmlwcGxlQ29sb3I6IFN0cmluZyxcbiAgICB0aGVtZURhcms6IEJvb2xlYW4sXG4gIH0sXG4gIGNvbG9yQ2xhc3NlcyhzZWxmKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29sb3IsXG4gICAgICBjb2xvclRoZW1lLFxuICAgICAgdGV4dENvbG9yLFxuICAgICAgYmdDb2xvcixcbiAgICAgIGJvcmRlckNvbG9yLFxuICAgICAgcmlwcGxlQ29sb3IsXG4gICAgICB0aGVtZURhcmssXG4gICAgfSA9IHNlbGY7XG5cbiAgICByZXR1cm4ge1xuICAgICAgJ3RoZW1lLWRhcmsnOiB0aGVtZURhcmssXG4gICAgICBbYGNvbG9yLSR7Y29sb3J9YF06IGNvbG9yLFxuICAgICAgW2Bjb2xvci10aGVtZS0ke2NvbG9yVGhlbWV9YF06IGNvbG9yVGhlbWUsXG4gICAgICBbYHRleHQtY29sb3ItJHt0ZXh0Q29sb3J9YF06IHRleHRDb2xvcixcbiAgICAgIFtgYmctY29sb3ItJHtiZ0NvbG9yfWBdOiBiZ0NvbG9yLFxuICAgICAgW2Bib3JkZXItY29sb3ItJHtib3JkZXJDb2xvcn1gXTogYm9yZGVyQ29sb3IsXG4gICAgICBbYHJpcHBsZS1jb2xvci0ke3JpcHBsZUNvbG9yfWBdOiByaXBwbGVDb2xvcixcbiAgICB9O1xuICB9LFxuICBsaW5rSWNvblByb3BzOiB7XG4gICAgaWNvbjogU3RyaW5nLFxuICAgIGljb25NYXRlcmlhbDogU3RyaW5nLFxuICAgIGljb25Jb246IFN0cmluZyxcbiAgICBpY29uRmE6IFN0cmluZyxcbiAgICBpY29uRjc6IFN0cmluZyxcbiAgICBpY29uSWZNZDogU3RyaW5nLFxuICAgIGljb25JZklvczogU3RyaW5nLFxuICAgIGljb25Db2xvcjogU3RyaW5nLFxuICAgIGljb25TaXplOiBbU3RyaW5nLCBOdW1iZXJdLFxuICB9LFxuICBsaW5rUm91dGVyUHJvcHM6IHtcbiAgICBiYWNrOiBCb29sZWFuLFxuICAgIGV4dGVybmFsOiBCb29sZWFuLFxuICAgIGZvcmNlOiBCb29sZWFuLFxuICAgIGFuaW1hdGU6IEJvb2xlYW4sXG4gICAgaWdub3JlQ2FjaGU6IEJvb2xlYW4sXG4gICAgcGFnZU5hbWU6IFN0cmluZyxcbiAgICByZWxvYWRDdXJyZW50OiBCb29sZWFuLFxuICAgIHJlbG9hZEFsbDogQm9vbGVhbixcbiAgICByZWxvYWRQcmV2aW91czogQm9vbGVhbixcbiAgICByb3V0ZVRhYklkOiBTdHJpbmcsXG4gICAgdmlldzogU3RyaW5nLFxuICB9LFxuICBsaW5rUm91dGVyQXR0cnMoc2VsZikge1xuICAgIGNvbnN0IHtcbiAgICAgIGZvcmNlLFxuICAgICAgcmVsb2FkQ3VycmVudCxcbiAgICAgIHJlbG9hZFByZXZpb3VzLFxuICAgICAgcmVsb2FkQWxsLFxuICAgICAgYW5pbWF0ZSxcbiAgICAgIGlnbm9yZUNhY2hlLFxuICAgICAgcm91dGVUYWJJZCxcbiAgICAgIHZpZXcsXG4gICAgfSA9IHNlbGY7XG5cbiAgICByZXR1cm4ge1xuICAgICAgJ2RhdGEtZm9yY2UnOiBmb3JjZSxcbiAgICAgICdkYXRhLXJlbG9hZC1jdXJyZW50JzogcmVsb2FkQ3VycmVudCxcbiAgICAgICdkYXRhLXJlbG9hZC1hbGwnOiByZWxvYWRBbGwsXG4gICAgICAnZGF0YS1yZWxvYWQtcHJldmlvdXMnOiByZWxvYWRQcmV2aW91cyxcbiAgICAgICdkYXRhLWFuaW1hdGUnOiAoJ2FuaW1hdGUnIGluIHNlbGYuJG9wdGlvbnMucHJvcHNEYXRhKSA/IGFuaW1hdGUudG9TdHJpbmcoKSA6IHVuZGVmaW5lZCxcbiAgICAgICdkYXRhLWlnbm9yZS1jYWNoZSc6IGlnbm9yZUNhY2hlLFxuICAgICAgJ2RhdGEtcm91dGUtdGFiLWlkJzogcm91dGVUYWJJZCxcbiAgICAgICdkYXRhLXZpZXcnOiBVdGlscy5pc1N0cmluZ1Byb3AodmlldykgPyB2aWV3IDogZmFsc2UsXG4gICAgfTtcbiAgfSxcbiAgbGlua1JvdXRlckNsYXNzZXMoc2VsZikge1xuICAgIGNvbnN0IHsgYmFjaywgbGlua0JhY2ssIGV4dGVybmFsIH0gPSBzZWxmO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGJhY2s6IGJhY2sgfHwgbGlua0JhY2ssXG4gICAgICBleHRlcm5hbCxcbiAgICB9O1xuICB9LFxuICBsaW5rQWN0aW9uc1Byb3BzOiB7XG4gICAgLy8gUGFuZWxcbiAgICBwYW5lbE9wZW46IFtCb29sZWFuLCBTdHJpbmddLFxuICAgIHBhbmVsQ2xvc2U6IFtCb29sZWFuLCBTdHJpbmddLFxuXG4gICAgLy8gUG9wdXBcbiAgICBwb3B1cE9wZW46IFtCb29sZWFuLCBTdHJpbmddLFxuICAgIHBvcHVwQ2xvc2U6IFtCb29sZWFuLCBTdHJpbmddLFxuXG4gICAgLy8gQWN0aW9uc1xuICAgIGFjdGlvbnNPcGVuOiBbQm9vbGVhbiwgU3RyaW5nXSxcbiAgICBhY3Rpb25zQ2xvc2U6IFtCb29sZWFuLCBTdHJpbmddLFxuXG4gICAgLy8gUG9wb3ZlclxuICAgIHBvcG92ZXJPcGVuOiBbQm9vbGVhbiwgU3RyaW5nXSxcbiAgICBwb3BvdmVyQ2xvc2U6IFtCb29sZWFuLCBTdHJpbmddLFxuXG4gICAgLy8gTG9naW4gU2NyZWVuXG4gICAgbG9naW5TY3JlZW5PcGVuOiBbQm9vbGVhbiwgU3RyaW5nXSxcbiAgICBsb2dpblNjcmVlbkNsb3NlOiBbQm9vbGVhbiwgU3RyaW5nXSxcblxuICAgIC8vIFBpY2tlclxuICAgIHNoZWV0T3BlbjogW0Jvb2xlYW4sIFN0cmluZ10sXG4gICAgc2hlZXRDbG9zZTogW0Jvb2xlYW4sIFN0cmluZ10sXG5cbiAgICAvLyBTb3J0YWJsZVxuICAgIHNvcnRhYmxlRW5hYmxlOiBbQm9vbGVhbiwgU3RyaW5nXSxcbiAgICBzb3J0YWJsZURpc2FibGU6IFtCb29sZWFuLCBTdHJpbmddLFxuICAgIHNvcnRhYmxlVG9nZ2xlOiBbQm9vbGVhbiwgU3RyaW5nXSxcbiAgfSxcbiAgbGlua0FjdGlvbnNBdHRycyhzZWxmKSB7XG4gICAgY29uc3Qge1xuICAgICAgcGFuZWxPcGVuLFxuICAgICAgcGFuZWxDbG9zZSxcbiAgICAgIHBvcHVwT3BlbixcbiAgICAgIHBvcHVwQ2xvc2UsXG4gICAgICBhY3Rpb25zT3BlbixcbiAgICAgIGFjdGlvbnNDbG9zZSxcbiAgICAgIHBvcG92ZXJPcGVuLFxuICAgICAgcG9wb3ZlckNsb3NlLFxuICAgICAgbG9naW5TY3JlZW5PcGVuLFxuICAgICAgbG9naW5TY3JlZW5DbG9zZSxcbiAgICAgIHNoZWV0T3BlbixcbiAgICAgIHNoZWV0Q2xvc2UsXG4gICAgICBzb3J0YWJsZUVuYWJsZSxcbiAgICAgIHNvcnRhYmxlRGlzYWJsZSxcbiAgICAgIHNvcnRhYmxlVG9nZ2xlLFxuICAgIH0gPSBzZWxmO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICdkYXRhLXBhbmVsJzogKFV0aWxzLmlzU3RyaW5nUHJvcChwYW5lbE9wZW4pICYmIHBhbmVsT3BlbikgfHxcbiAgICAgICAgICAgICAgICAgICAgKFV0aWxzLmlzU3RyaW5nUHJvcChwYW5lbENsb3NlKSAmJiBwYW5lbENsb3NlKSxcbiAgICAgICdkYXRhLXBvcHVwJzogKFV0aWxzLmlzU3RyaW5nUHJvcChwb3B1cE9wZW4pICYmIHBvcHVwT3BlbikgfHxcbiAgICAgICAgICAgICAgICAgICAgKFV0aWxzLmlzU3RyaW5nUHJvcChwb3B1cENsb3NlKSAmJiBwb3B1cENsb3NlKSxcbiAgICAgICdkYXRhLWFjdGlvbnMnOiAoVXRpbHMuaXNTdHJpbmdQcm9wKGFjdGlvbnNPcGVuKSAmJiBhY3Rpb25zT3BlbikgfHxcbiAgICAgICAgICAgICAgICAgICAgKFV0aWxzLmlzU3RyaW5nUHJvcChhY3Rpb25zQ2xvc2UpICYmIGFjdGlvbnNDbG9zZSksXG4gICAgICAnZGF0YS1wb3BvdmVyJzogKFV0aWxzLmlzU3RyaW5nUHJvcChwb3BvdmVyT3BlbikgJiYgcG9wb3Zlck9wZW4pIHx8XG4gICAgICAgICAgICAgICAgICAgICAgKFV0aWxzLmlzU3RyaW5nUHJvcChwb3BvdmVyQ2xvc2UpICYmIHBvcG92ZXJDbG9zZSksXG4gICAgICAnZGF0YS1zaGVldCc6IChVdGlscy5pc1N0cmluZ1Byb3Aoc2hlZXRPcGVuKSAmJiBzaGVldE9wZW4pIHx8XG4gICAgICAgICAgICAgICAgICAgIChVdGlscy5pc1N0cmluZ1Byb3Aoc2hlZXRDbG9zZSkgJiYgc2hlZXRDbG9zZSksXG4gICAgICAnZGF0YS1sb2dpbi1zY3JlZW4nOiAoVXRpbHMuaXNTdHJpbmdQcm9wKGxvZ2luU2NyZWVuT3BlbikgJiYgbG9naW5TY3JlZW5PcGVuKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgKFV0aWxzLmlzU3RyaW5nUHJvcChsb2dpblNjcmVlbkNsb3NlKSAmJiBsb2dpblNjcmVlbkNsb3NlKSxcbiAgICAgICdkYXRhLXNvcnRhYmxlJzogKFV0aWxzLmlzU3RyaW5nUHJvcChzb3J0YWJsZUVuYWJsZSkgJiYgc29ydGFibGVFbmFibGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgIChVdGlscy5pc1N0cmluZ1Byb3Aoc29ydGFibGVEaXNhYmxlKSAmJiBzb3J0YWJsZURpc2FibGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgIChVdGlscy5pc1N0cmluZ1Byb3Aoc29ydGFibGVUb2dnbGUpICYmIHNvcnRhYmxlVG9nZ2xlKSxcbiAgICB9O1xuICB9LFxuICBsaW5rQWN0aW9uc0NsYXNzZXMoc2VsZikge1xuICAgIGNvbnN0IHtcbiAgICAgIHBhbmVsT3BlbixcbiAgICAgIHBhbmVsQ2xvc2UsXG4gICAgICBwb3B1cE9wZW4sXG4gICAgICBhY3Rpb25zQ2xvc2UsXG4gICAgICBhY3Rpb25zT3BlbixcbiAgICAgIHBvcHVwQ2xvc2UsXG4gICAgICBwb3BvdmVyT3BlbixcbiAgICAgIHBvcG92ZXJDbG9zZSxcbiAgICAgIGxvZ2luU2NyZWVuT3BlbixcbiAgICAgIGxvZ2luU2NyZWVuQ2xvc2UsXG4gICAgICBzaGVldE9wZW4sXG4gICAgICBzaGVldENsb3NlLFxuICAgICAgc29ydGFibGVFbmFibGUsXG4gICAgICBzb3J0YWJsZURpc2FibGUsXG4gICAgICBzb3J0YWJsZVRvZ2dsZSxcbiAgICB9ID0gc2VsZjtcbiAgICByZXR1cm4ge1xuICAgICAgJ3BhbmVsLWNsb3NlJzogVXRpbHMuaXNUcnVlUHJvcChwYW5lbENsb3NlKSxcbiAgICAgICdwYW5lbC1vcGVuJzogcGFuZWxPcGVuIHx8IHBhbmVsT3BlbiA9PT0gJycsXG4gICAgICAncG9wdXAtY2xvc2UnOiBVdGlscy5pc1RydWVQcm9wKHBvcHVwQ2xvc2UpLFxuICAgICAgJ3BvcHVwLW9wZW4nOiBwb3B1cE9wZW4gfHwgcG9wdXBPcGVuID09PSAnJyxcbiAgICAgICdhY3Rpb25zLWNsb3NlJzogVXRpbHMuaXNUcnVlUHJvcChhY3Rpb25zQ2xvc2UpLFxuICAgICAgJ2FjdGlvbnMtb3Blbic6IGFjdGlvbnNPcGVuIHx8IGFjdGlvbnNPcGVuID09PSAnJyxcbiAgICAgICdwb3BvdmVyLWNsb3NlJzogVXRpbHMuaXNUcnVlUHJvcChwb3BvdmVyQ2xvc2UpLFxuICAgICAgJ3BvcG92ZXItb3Blbic6IHBvcG92ZXJPcGVuIHx8IHBvcG92ZXJPcGVuID09PSAnJyxcbiAgICAgICdzaGVldC1jbG9zZSc6IFV0aWxzLmlzVHJ1ZVByb3Aoc2hlZXRDbG9zZSksXG4gICAgICAnc2hlZXQtb3Blbic6IHNoZWV0T3BlbiB8fCBzaGVldE9wZW4gPT09ICcnLFxuICAgICAgJ2xvZ2luLXNjcmVlbi1jbG9zZSc6IFV0aWxzLmlzVHJ1ZVByb3AobG9naW5TY3JlZW5DbG9zZSksXG4gICAgICAnbG9naW4tc2NyZWVuLW9wZW4nOiBsb2dpblNjcmVlbk9wZW4gfHwgbG9naW5TY3JlZW5PcGVuID09PSAnJyxcbiAgICAgICdzb3J0YWJsZS1lbmFibGUnOiBVdGlscy5pc1RydWVQcm9wKHNvcnRhYmxlRW5hYmxlKSxcbiAgICAgICdzb3J0YWJsZS1kaXNhYmxlJzogVXRpbHMuaXNUcnVlUHJvcChzb3J0YWJsZURpc2FibGUpLFxuICAgICAgJ3NvcnRhYmxlLXRvZ2dsZSc6IHNvcnRhYmxlVG9nZ2xlID09PSB0cnVlIHx8IHNvcnRhYmxlVG9nZ2xlLmxlbmd0aCxcbiAgICB9O1xuICB9LFxufTtcblxudmFyIGY3QWNjb3JkaW9uQ29udGVudCA9IHtyZW5kZXI6IGZ1bmN0aW9uKCl7dmFyIF92bT10aGlzO3ZhciBfaD1fdm0uJGNyZWF0ZUVsZW1lbnQ7dmFyIF9jPV92bS5fc2VsZi5fY3x8X2g7cmV0dXJuIF9jKCdkaXYnLHtzdGF0aWNDbGFzczpcImFjY29yZGlvbi1pdGVtLWNvbnRlbnRcIixjbGFzczpfdm0uY2xhc3Nlc30sW192bS5fdChcImRlZmF1bHRcIildLDIpfSxzdGF0aWNSZW5kZXJGbnM6IFtdLFxuICBwcm9wczogTWl4aW5zLmNvbG9yUHJvcHMsXG4gIG5hbWU6ICdmNy1hY2NvcmRpb24tY29udGVudCcsXG4gIGNvbXB1dGVkOiB7XG4gICAgY2xhc3NlcygpIHtcbiAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgcmV0dXJuIE1peGlucy5jb2xvckNsYXNzZXMoc2VsZik7XG4gICAgfSxcbiAgfSxcbn07XG5cbmNvbnN0IEFjY29yZGlvbkl0ZW1Qcm9wcyA9IFV0aWxzLmV4dGVuZChcbiAge1xuICAgIG9wZW5lZDogQm9vbGVhbixcbiAgfSxcbiAgTWl4aW5zLmNvbG9yUHJvcHNcbik7XG5cbnZhciBmN0FjY29yZGlvbkl0ZW0gPSB7cmVuZGVyOiBmdW5jdGlvbigpe3ZhciBfdm09dGhpczt2YXIgX2g9X3ZtLiRjcmVhdGVFbGVtZW50O3ZhciBfYz1fdm0uX3NlbGYuX2N8fF9oO3JldHVybiBfYygnZGl2Jyx7c3RhdGljQ2xhc3M6XCJhY2NvcmRpb24taXRlbVwiLGNsYXNzOl92bS5jbGFzc2VzLG9uOntcImFjY29yZGlvbjpvcGVuXCI6X3ZtLm9uT3BlbixcImFjY29yZGlvbjpvcGVuZWRcIjpfdm0ub25PcGVuZWQsXCJhY2NvcmRpb246Y2xvc2VcIjpfdm0ub25DbG9zZSxcImFjY29yZGlvbjpjbG9zZWRcIjpfdm0ub25DbG9zZWR9fSxbX3ZtLl90KFwiZGVmYXVsdFwiKV0sMil9LHN0YXRpY1JlbmRlckZuczogW10sXG4gIG5hbWU6ICdmNy1hY2NvcmRpb24taXRlbScsXG4gIHByb3BzOiBBY2NvcmRpb25JdGVtUHJvcHMsXG4gIGNvbXB1dGVkOiB7XG4gICAgY2xhc3NlcygpIHtcbiAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgcmV0dXJuIFV0aWxzLmV4dGVuZChcbiAgICAgICAge1xuICAgICAgICAgICdhY2NvcmRpb24taXRlbS1vcGVuZWQnOiBzZWxmLm9wZW5lZCxcbiAgICAgICAgfSxcbiAgICAgICAgTWl4aW5zLmNvbG9yQ2xhc3NlcyhzZWxmKVxuICAgICAgKTtcbiAgICB9LFxuICB9LFxuICBtZXRob2RzOiB7XG4gICAgb25PcGVuKGV2ZW50KSB7XG4gICAgICB0aGlzLiRlbWl0KCdhY2NvcmRpb246b3BlbicsIGV2ZW50KTtcbiAgICB9LFxuICAgIG9uT3BlbmVkKGV2ZW50KSB7XG4gICAgICB0aGlzLiRlbWl0KCdhY2NvcmRpb246b3BlbmVkJywgZXZlbnQpO1xuICAgIH0sXG4gICAgb25DbG9zZShldmVudCkge1xuICAgICAgdGhpcy4kZW1pdCgnYWNjb3JkaW9uOmNsb3NlJywgZXZlbnQpO1xuICAgIH0sXG4gICAgb25DbG9zZWQoZXZlbnQpIHtcbiAgICAgIHRoaXMuJGVtaXQoJ2FjY29yZGlvbjpjbG9zZWQnLCBldmVudCk7XG4gICAgfSxcbiAgfSxcbn07XG5cbnZhciBmN0FjY29yZGlvblRvZ2dsZSA9IHtyZW5kZXI6IGZ1bmN0aW9uKCl7dmFyIF92bT10aGlzO3ZhciBfaD1fdm0uJGNyZWF0ZUVsZW1lbnQ7dmFyIF9jPV92bS5fc2VsZi5fY3x8X2g7cmV0dXJuIF9jKCdkaXYnLHtzdGF0aWNDbGFzczpcImFjY29yZGlvbi1pdGVtLXRvZ2dsZVwiLGNsYXNzOl92bS5jbGFzc2VzfSxbX3ZtLl90KFwiZGVmYXVsdFwiKV0sMil9LHN0YXRpY1JlbmRlckZuczogW10sXG4gIHByb3BzOiBNaXhpbnMuY29sb3JQcm9wcyxcbiAgbmFtZTogJ2Y3LWFjY29yZGlvbi10b2dnbGUnLFxuICBjb21wdXRlZDoge1xuICAgIGNsYXNzZXMoKSB7XG4gICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgIHJldHVybiBNaXhpbnMuY29sb3JDbGFzc2VzKHNlbGYpO1xuICAgIH0sXG4gIH0sXG59O1xuXG52YXIgZjdBY2NvcmRpb24gPSB7cmVuZGVyOiBmdW5jdGlvbigpe3ZhciBfdm09dGhpczt2YXIgX2g9X3ZtLiRjcmVhdGVFbGVtZW50O3ZhciBfYz1fdm0uX3NlbGYuX2N8fF9oO3JldHVybiBfYygnZGl2Jyx7c3RhdGljQ2xhc3M6XCJhY2NvcmRpb24tbGlzdFwiLGNsYXNzOl92bS5jbGFzc2VzfSxbX3ZtLl90KFwiZGVmYXVsdFwiKV0sMil9LHN0YXRpY1JlbmRlckZuczogW10sXG4gIHByb3BzOiBNaXhpbnMuY29sb3JQcm9wcyxcbiAgbmFtZTogJ2Y3LWFjY29yZGlvbicsXG4gIGNvbXB1dGVkOiB7XG4gICAgY2xhc3NlcygpIHtcbiAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgcmV0dXJuIE1peGlucy5jb2xvckNsYXNzZXMoc2VsZik7XG4gICAgfSxcbiAgfSxcbn07XG5cbmNvbnN0IEFjdGlvbnNCdXR0b25Qcm9wcyA9IFV0aWxzLmV4dGVuZChcbiAge1xuICAgIGJvbGQ6IEJvb2xlYW4sXG4gICAgY2xvc2U6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiB0cnVlLFxuICAgIH0sXG4gIH0sXG4gIE1peGlucy5jb2xvclByb3BzXG4pO1xuXG52YXIgZjdBY3Rpb25zQnV0dG9uID0ge1xuICBuYW1lOiAnZjctYWN0aW9ucy1idXR0b24nLFxuICByZW5kZXIoYykge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIGxldCBtZWRpYUVsO1xuICAgIGlmIChzZWxmLiRzbG90cy5tZWRpYSAmJiBzZWxmLiRzbG90cy5tZWRpYS5sZW5ndGgpIHtcbiAgICAgIG1lZGlhRWwgPSBjKCdkaXYnLCB7XG4gICAgICAgIHN0YXRpY0NsYXNzOiAnYWN0aW9ucy1idXR0b24tbWVkaWEnLFxuICAgICAgfSwgc2VsZi4kc2xvdHMubWVkaWEpO1xuICAgIH1cbiAgICBjb25zdCB0ZXh0RWwgPSBjKCdkaXYnLCB7XG4gICAgICBzdGF0aWNDbGFzczogJ2FjdGlvbnMtYnV0dG9uLXRleHQnLFxuICAgIH0sIHNlbGYuJHNsb3RzLmRlZmF1bHQpO1xuXG4gICAgcmV0dXJuIGMoJ2RpdicsIHtcbiAgICAgIHN0YXRpY0NsYXNzOiAnYWN0aW9ucy1idXR0b24nLFxuICAgICAgY2xhc3M6IHNlbGYuY2xhc3NlcyxcbiAgICAgIG9uOiB7XG4gICAgICAgIGNsaWNrOiBzZWxmLm9uQ2xpY2ssXG4gICAgICB9LFxuICAgIH0sIFttZWRpYUVsLCB0ZXh0RWxdKTtcbiAgfSxcbiAgcHJvcHM6IEFjdGlvbnNCdXR0b25Qcm9wcyxcbiAgY29tcHV0ZWQ6IHtcbiAgICBjbGFzc2VzKCkge1xuICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG5cbiAgICAgIHJldHVybiBVdGlscy5leHRlbmQoe1xuICAgICAgICAnYWN0aW9ucy1idXR0b24tYm9sZCc6IHNlbGYuYm9sZCxcbiAgICAgIH0sIE1peGlucy5jb2xvckNsYXNzZXMoc2VsZikpO1xuICAgIH0sXG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBvbkNsaWNrKGV2ZW50KSB7XG4gICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgIGNvbnN0ICQkID0gc2VsZi4kJDtcbiAgICAgIGlmIChzZWxmLmNsb3NlICYmIHNlbGYuJGY3KSB7XG4gICAgICAgIHNlbGYuJGY3LmFjdGlvbnMuY2xvc2UoJCQoc2VsZi4kZWwpLnBhcmVudHMoJy5hY3Rpb25zLW1vZGFsJykpO1xuICAgICAgfVxuICAgICAgc2VsZi4kZW1pdCgnY2xpY2snLCBldmVudCk7XG4gICAgfSxcbiAgfSxcbn07XG5cbnZhciBmN0FjdGlvbnNHcm91cCA9IHtcbiAgbmFtZTogJ2Y3LWFjdGlvbnMtZ3JvdXAnLFxuICByZW5kZXIoYykge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjKCdkaXYnLCB7IHN0YXRpY0NsYXNzOiAnYWN0aW9ucy1ncm91cCcgfSwgc2VsZi4kc2xvdHMuZGVmYXVsdCk7XG4gIH0sXG59O1xuXG5jb25zdCBBY3Rpb25zTGFiZWxQcm9wcyA9IFV0aWxzLmV4dGVuZChcbiAge1xuICAgIGJvbGQ6IEJvb2xlYW4sXG4gIH0sXG4gIE1peGlucy5jb2xvclByb3BzXG4pO1xudmFyIGY3QWN0aW9uc0xhYmVsID0ge1xuICBuYW1lOiAnZjctYWN0aW9ucy1sYWJlbCcsXG4gIHJlbmRlcihjKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIGMoJ2RpdicsIHtcbiAgICAgIHN0YXRpY0NsYXNzOiAnYWN0aW9ucy1sYWJlbCcsXG4gICAgICBjbGFzczogc2VsZi5jbGFzc2VzLFxuICAgICAgb246IHtcbiAgICAgICAgY2xpY2s6IHNlbGYub25DbGljayxcbiAgICAgIH0sXG4gICAgfSwgc2VsZi4kc2xvdHMuZGVmYXVsdCk7XG4gIH0sXG4gIHByb3BzOiBBY3Rpb25zTGFiZWxQcm9wcyxcbiAgY29tcHV0ZWQ6IHtcbiAgICBjbGFzc2VzKCkge1xuICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICByZXR1cm4gVXRpbHMuZXh0ZW5kKHtcbiAgICAgICAgJ2FjdGlvbnMtYnV0dG9uLWJvbGQnOiBzZWxmLmJvbGQsXG4gICAgICB9LCBNaXhpbnMuY29sb3JDbGFzc2VzKHNlbGYpKTtcbiAgICB9LFxuICB9LFxuICBtZXRob2RzOiB7XG4gICAgb25DbGljayhldmVudCkge1xuICAgICAgdGhpcy4kZW1pdCgnY2xpY2snLCBldmVudCk7XG4gICAgfSxcbiAgfSxcbn07XG5cbmNvbnN0IEFjdGlvbnNQcm9wcyA9IFV0aWxzLmV4dGVuZChcbiAge1xuICAgIG9wZW5lZDogQm9vbGVhbixcbiAgICBncmlkOiBCb29sZWFuLFxuICAgIGNvbnZlcnRUb1BvcG92ZXI6IEJvb2xlYW4sXG4gICAgZm9yY2VUb1BvcG92ZXI6IEJvb2xlYW4sXG4gICAgdGFyZ2V0OiBbU3RyaW5nLCBPYmplY3RdLFxuICB9LFxuICBNaXhpbnMuY29sb3JQcm9wc1xuKTtcblxudmFyIGY3QWN0aW9ucyA9IHtcbiAgbmFtZTogJ2Y3LWFjdGlvbnMnLFxuICByZW5kZXIoYykge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuXG4gICAgcmV0dXJuIGMoJ2RpdicsIHtcbiAgICAgIHN0YXRpY0NsYXNzOiAnYWN0aW9ucy1tb2RhbCcsXG4gICAgICBjbGFzczogc2VsZi5jbGFzc2VzLFxuICAgICAgb246IHtcbiAgICAgICAgJ2FjdGlvbnM6b3Blbic6IHNlbGYub25PcGVuLFxuICAgICAgICAnYWN0aW9uczpvcGVuZWQnOiBzZWxmLm9uT3BlbmVkLFxuICAgICAgICAnYWN0aW9uczpjbG9zZSc6IHNlbGYub25DbG9zZSxcbiAgICAgICAgJ2FjdGlvbnM6Y2xvc2VkJzogc2VsZi5vbkNsb3NlZCxcbiAgICAgIH0sXG4gICAgfSwgc2VsZi4kc2xvdHMuZGVmYXVsdCk7XG4gIH0sXG4gIHdhdGNoOiB7XG4gICAgb3BlbmVkKG9wZW5lZCkge1xuICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICBpZiAoIXNlbGYuZjdBY3Rpb25zKSByZXR1cm47XG4gICAgICBpZiAob3BlbmVkKSB7XG4gICAgICAgIHNlbGYuZjdBY3Rpb25zLm9wZW4oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGYuZjdBY3Rpb25zLmNsb3NlKCk7XG4gICAgICB9XG4gICAgfSxcbiAgfSxcbiAgcHJvcHM6IEFjdGlvbnNQcm9wcyxcbiAgY29tcHV0ZWQ6IHtcbiAgICBjbGFzc2VzKCkge1xuICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICByZXR1cm4gVXRpbHMuZXh0ZW5kKHtcbiAgICAgICAgJ2FjdGlvbnMtZ3JpZCc6IHNlbGYuZ3JpZCxcbiAgICAgIH0sIE1peGlucy5jb2xvckNsYXNzZXMoc2VsZikpO1xuICAgIH0sXG4gIH0sXG4gIGJlZm9yZURlc3Ryb3koKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgaWYgKHNlbGYuZjdBY3Rpb25zKSBzZWxmLmY3QWN0aW9ucy5kZXN0cm95KCk7XG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBvbk9wZW4oZXZlbnQpIHtcbiAgICAgIHRoaXMuJGVtaXQoJ2FjdGlvbnM6b3BlbicsIGV2ZW50KTtcbiAgICB9LFxuICAgIG9uT3BlbmVkKGV2ZW50KSB7XG4gICAgICB0aGlzLiRlbWl0KCdhY3Rpb25zOm9wZW5lZCcsIGV2ZW50KTtcbiAgICB9LFxuICAgIG9uQ2xvc2UoZXZlbnQpIHtcbiAgICAgIHRoaXMuJGVtaXQoJ2FjdGlvbnM6Y2xvc2UnLCBldmVudCk7XG4gICAgfSxcbiAgICBvbkNsb3NlZChldmVudCkge1xuICAgICAgdGhpcy4kZW1pdCgnYWN0aW9uczpjbG9zZWQnLCBldmVudCk7XG4gICAgfSxcbiAgICBvcGVuKGFuaW1hdGUpIHtcbiAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgaWYgKCFzZWxmLiRmNykgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiBzZWxmLiRmNy5hY3Rpb25zLm9wZW4oc2VsZi4kZWwsIGFuaW1hdGUpO1xuICAgIH0sXG4gICAgY2xvc2UoYW5pbWF0ZSkge1xuICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICBpZiAoIXNlbGYuJGY3KSByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIHNlbGYuJGY3LmFjdGlvbnMuY2xvc2Uoc2VsZi4kZWwsIGFuaW1hdGUpO1xuICAgIH0sXG4gICAgb25GN1JlYWR5KCkge1xuICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG5cbiAgICAgIGNvbnN0IGFjdGlvbnNQYXJhbXMgPSB7XG4gICAgICAgIGVsOiBzZWxmLiRlbCxcbiAgICAgICAgZ3JpZDogc2VsZi5ncmlkLFxuICAgICAgfTtcbiAgICAgIGlmIChzZWxmLnRhcmdldCkgYWN0aW9uc1BhcmFtcy50YXJnZXRFbCA9IHNlbGYudGFyZ2V0O1xuICAgICAgaWYgKHR5cGVvZiBzZWxmLiRvcHRpb25zLnByb3BzRGF0YS5jb252ZXJ0VG9Qb3BvdmVyICE9PSAndW5kZWZpbmVkJykgYWN0aW9uc1BhcmFtcy5jb252ZXJ0VG9Qb3BvdmVyID0gc2VsZi5jb252ZXJ0VG9Qb3BvdmVyO1xuICAgICAgaWYgKHR5cGVvZiBzZWxmLiRvcHRpb25zLnByb3BzRGF0YS5mb3JjZVRvUG9wb3ZlciAhPT0gJ3VuZGVmaW5lZCcpIGFjdGlvbnNQYXJhbXMuZm9yY2VUb1BvcG92ZXIgPSBzZWxmLmZvcmNlVG9Qb3BvdmVyO1xuXG4gICAgICBzZWxmLmY3QWN0aW9ucyA9IHNlbGYuJGY3LmFjdGlvbnMuY3JlYXRlKGFjdGlvbnNQYXJhbXMpO1xuXG4gICAgICBpZiAoc2VsZi5vcGVuZWQpIHtcbiAgICAgICAgc2VsZi5mN0FjdGlvbnMub3BlbihmYWxzZSk7XG4gICAgICB9XG4gICAgfSxcbiAgfSxcbn07XG5cbnZhciBmN0JhZGdlID0ge3JlbmRlcjogZnVuY3Rpb24oKXt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtyZXR1cm4gX2MoJ3NwYW4nLHtzdGF0aWNDbGFzczpcImJhZGdlXCIsY2xhc3M6X3ZtLmNsYXNzZXN9LFtfdm0uX3QoXCJkZWZhdWx0XCIpXSwyKX0sc3RhdGljUmVuZGVyRm5zOiBbXSxcbiAgcHJvcHM6IE1peGlucy5jb2xvclByb3BzLFxuICBuYW1lOiAnZjctYmFkZ2UnLFxuICBjb21wdXRlZDoge1xuICAgIGNsYXNzZXMoKSB7XG4gICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgIHJldHVybiBNaXhpbnMuY29sb3JDbGFzc2VzKHNlbGYpO1xuICAgIH0sXG4gIH0sXG59O1xuXG52YXIgZjdCbG9ja0Zvb3RlciA9IHtyZW5kZXI6IGZ1bmN0aW9uKCl7dmFyIF92bT10aGlzO3ZhciBfaD1fdm0uJGNyZWF0ZUVsZW1lbnQ7dmFyIF9jPV92bS5fc2VsZi5fY3x8X2g7cmV0dXJuIF9jKCdkaXYnLHtzdGF0aWNDbGFzczpcImJsb2NrLWZvb3RlclwiLGNsYXNzOl92bS5jbGFzc2VzfSxbX3ZtLl90KFwiZGVmYXVsdFwiKV0sMil9LHN0YXRpY1JlbmRlckZuczogW10sXG4gIG5hbWU6ICdmNy1ibG9jay1mb290ZXInLFxuICBwcm9wczogTWl4aW5zLmNvbG9yUHJvcHMsXG4gIGNvbXB1dGVkOiB7XG4gICAgY2xhc3NlcygpIHtcbiAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgcmV0dXJuIE1peGlucy5jb2xvckNsYXNzZXMoc2VsZik7XG4gICAgfSxcbiAgfSxcbn07XG5cbnZhciBmN0Jsb2NrSGVhZGVyID0ge3JlbmRlcjogZnVuY3Rpb24oKXt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtyZXR1cm4gX2MoJ2Rpdicse3N0YXRpY0NsYXNzOlwiYmxvY2staGVhZGVyXCIsY2xhc3M6X3ZtLmNsYXNzZXN9LFtfdm0uX3QoXCJkZWZhdWx0XCIpXSwyKX0sc3RhdGljUmVuZGVyRm5zOiBbXSxcbiAgcHJvcHM6IE1peGlucy5jb2xvclByb3BzLFxuICBuYW1lOiAnZjctYmxvY2staGVhZGVyJyxcbiAgY29tcHV0ZWQ6IHtcbiAgICBjbGFzc2VzKCkge1xuICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICByZXR1cm4gTWl4aW5zLmNvbG9yQ2xhc3NlcyhzZWxmKTtcbiAgICB9LFxuICB9LFxufTtcblxudmFyIGY3QmxvY2tUaXRsZSA9IHtyZW5kZXI6IGZ1bmN0aW9uKCl7dmFyIF92bT10aGlzO3ZhciBfaD1fdm0uJGNyZWF0ZUVsZW1lbnQ7dmFyIF9jPV92bS5fc2VsZi5fY3x8X2g7cmV0dXJuIF9jKCdkaXYnLHtzdGF0aWNDbGFzczpcImJsb2NrLXRpdGxlXCIsY2xhc3M6X3ZtLmNsYXNzZXN9LFtfdm0uX3QoXCJkZWZhdWx0XCIpXSwyKX0sc3RhdGljUmVuZGVyRm5zOiBbXSxcbiAgcHJvcHM6IE1peGlucy5jb2xvclByb3BzLFxuICBuYW1lOiAnZjctYmxvY2stdGl0bGUnLFxuICBjb21wdXRlZDoge1xuICAgIGNsYXNzZXMoKSB7XG4gICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgIHJldHVybiBNaXhpbnMuY29sb3JDbGFzc2VzKHNlbGYpO1xuICAgIH0sXG4gIH0sXG59O1xuXG5jb25zdCBCbG9ja1Byb3BzID0gVXRpbHMuZXh0ZW5kKFxuICB7XG4gICAgaW5zZXQ6IEJvb2xlYW4sXG4gICAgdGFibGV0SW5zZXQ6IEJvb2xlYW4sXG4gICAgc3Ryb25nOiBCb29sZWFuLFxuICAgIHRhYnM6IEJvb2xlYW4sXG4gICAgdGFiOiBCb29sZWFuLFxuICAgIHRhYkFjdGl2ZTogQm9vbGVhbixcbiAgICBhY2NvcmRpb25MaXN0OiBCb29sZWFuLFxuICAgIG5vSGFpcmxpbmVzOiBCb29sZWFuLFxuICAgIG5vSGFpcmxpbmVzTWQ6IEJvb2xlYW4sXG4gICAgbm9IYWlybGluZXNJb3M6IEJvb2xlYW4sXG4gIH0sXG4gIE1peGlucy5jb2xvclByb3BzXG4pO1xuXG52YXIgZjdCbG9jayA9IHtyZW5kZXI6IGZ1bmN0aW9uKCl7dmFyIF92bT10aGlzO3ZhciBfaD1fdm0uJGNyZWF0ZUVsZW1lbnQ7dmFyIF9jPV92bS5fc2VsZi5fY3x8X2g7cmV0dXJuIF9jKCdkaXYnLHtzdGF0aWNDbGFzczpcImJsb2NrXCIsY2xhc3M6X3ZtLmNsYXNzZXMsb246e1widGFiOnNob3dcIjpfdm0ub25UYWJTaG93LFwidGFiOmhpZGVcIjpfdm0ub25UYWJIaWRlfX0sW192bS5fdChcImRlZmF1bHRcIildLDIpfSxzdGF0aWNSZW5kZXJGbnM6IFtdLFxuICBuYW1lOiAnZjctYmxvY2snLFxuICBwcm9wczogQmxvY2tQcm9wcyxcbiAgY29tcHV0ZWQ6IHtcbiAgICBjbGFzc2VzKCkge1xuICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICByZXR1cm4gVXRpbHMuZXh0ZW5kKFxuICAgICAgICB7XG4gICAgICAgICAgaW5zZXQ6IHNlbGYuaW5zZXQsXG4gICAgICAgICAgJ2Jsb2NrLXN0cm9uZyc6IHNlbGYuc3Ryb25nLFxuICAgICAgICAgICdhY2NvcmRpb24tbGlzdCc6IHNlbGYuYWNjb3JkaW9uTGlzdCxcbiAgICAgICAgICAndGFibGV0LWluc2V0Jzogc2VsZi50YWJsZXRJbnNldCxcbiAgICAgICAgICB0YWJzOiBzZWxmLnRhYnMsXG4gICAgICAgICAgdGFiOiBzZWxmLnRhYixcbiAgICAgICAgICAndGFiLWFjdGl2ZSc6IHNlbGYudGFiQWN0aXZlLFxuICAgICAgICAgICduby1oYWlybGluZXMnOiBzZWxmLm5vSGFpcmxpbmVzLFxuICAgICAgICAgICduby1oYWlybGluZXMtbWQnOiBzZWxmLm5vSGFpcmxpbmVzTWQsXG4gICAgICAgICAgJ25vLWhhaXJsaW5lcy1pb3MnOiBzZWxmLm5vSGFpcmxpbmVzSW9zLFxuICAgICAgICB9LFxuICAgICAgICBNaXhpbnMuY29sb3JDbGFzc2VzKHNlbGYpXG4gICAgICApO1xuICAgIH0sXG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBvblRhYlNob3coZSkge1xuICAgICAgdGhpcy4kZW1pdCgndGFiOnNob3cnLCBlKTtcbiAgICB9LFxuICAgIG9uVGFiSGlkZShlKSB7XG4gICAgICB0aGlzLiRlbWl0KCd0YWI6aGlkZScsIGUpO1xuICAgIH0sXG4gIH0sXG59O1xuXG5jb25zdCBJY29uUHJvcHMgPSBVdGlscy5leHRlbmQoXG4gIHtcbiAgICBtYXRlcmlhbDogU3RyaW5nLCAvLyBNYXRlcmlhbCBJY29uc1xuICAgIGY3OiBTdHJpbmcsIC8vIEZyYW1ld29yazcgSWNvbnNcbiAgICBpb246IFN0cmluZywgLy8gSW9uaWNvbnNcbiAgICBmYTogU3RyaW5nLCAvLyBGb250IEF3ZXNvbWVcbiAgICBpY29uOiBTdHJpbmcsIC8vIEN1c3RvbVxuICAgIGlmTWQ6IFN0cmluZyxcbiAgICBpZklvczogU3RyaW5nLFxuICAgIHNpemU6IFtTdHJpbmcsIE51bWJlcl0sXG4gIH0sXG4gIE1peGlucy5jb2xvclByb3BzXG4pO1xuXG52YXIgZjdJY29uID0ge3JlbmRlcjogZnVuY3Rpb24oKXt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtyZXR1cm4gX2MoJ2knLHtzdGF0aWNDbGFzczpcImljb25cIixjbGFzczpfdm0uY2xhc3NlcyxzdHlsZTooeydmb250LXNpemUnOl92bS5zaXplQ29tcHV0ZWR9KX0sW192bS5fdihfdm0uX3MoX3ZtLmljb25UZXh0Q29tcHV0ZWQpKSxfdm0uX3QoXCJkZWZhdWx0XCIpXSwyKX0sc3RhdGljUmVuZGVyRm5zOiBbXSxcbiAgbmFtZTogJ2Y3LWljb24nLFxuICBwcm9wczogSWNvblByb3BzLFxuICBjb21wdXRlZDoge1xuICAgIHNpemVDb21wdXRlZCgpIHtcbiAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgbGV0IHNpemUgPSBzZWxmLnNpemU7XG4gICAgICBpZiAodHlwZW9mIHNpemUgPT09ICdudW1iZXInIHx8IHBhcnNlRmxvYXQoc2l6ZSkgPT09IHNpemUgKiAxKSB7XG4gICAgICAgIHNpemUgPSBgJHtzaXplfXB4YDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzaXplO1xuICAgIH0sXG4gICAgaWNvblRleHRDb21wdXRlZCgpIHtcbiAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgbGV0IHRleHQgPSBzZWxmLm1hdGVyaWFsIHx8IHNlbGYuZjc7XG4gICAgICBpZiAoc2VsZi5pZk1kICYmIHNlbGYuJHRoZW1lLm1kICYmIChzZWxmLmlmTWQuaW5kZXhPZignbWF0ZXJpYWw6JykgPj0gMCB8fCBzZWxmLmlmTWQuaW5kZXhPZignZjc6JykgPj0gMCkpIHtcbiAgICAgICAgdGV4dCA9IHNlbGYuaWZNZC5zcGxpdCgnOicpWzFdO1xuICAgICAgfSBlbHNlIGlmIChzZWxmLmlmSW9zICYmIHNlbGYuJHRoZW1lLmlvcyAmJiAoc2VsZi5pZklvcy5pbmRleE9mKCdtYXRlcmlhbDonKSA+PSAwIHx8IHNlbGYuaWZJb3MuaW5kZXhPZignZjc6JykgPj0gMCkpIHtcbiAgICAgICAgdGV4dCA9IHNlbGYuaWZJb3Muc3BsaXQoJzonKVsxXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0ZXh0O1xuICAgIH0sXG4gICAgY2xhc3NlcygpIHtcbiAgICAgIGxldCBjbGFzc2VzID0ge307XG4gICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgIGlmIChzZWxmLmlmTWQgfHwgc2VsZi5pZklvcykge1xuICAgICAgICBjb25zdCBwYXJ0cyA9IHNlbGZbc2VsZi4kdGhlbWUubWQgPyAnaWZNZCcgOiAnaWZJb3MnXS5zcGxpdCgnOicpO1xuICAgICAgICBjb25zdCBwcm9wID0gcGFydHNbMF07XG4gICAgICAgIGNvbnN0IHZhbHVlID0gcGFydHNbMV07XG4gICAgICAgIGlmIChwcm9wID09PSAnbWF0ZXJpYWwnIHx8IHByb3AgPT09ICdmYScgfHwgcHJvcCA9PT0gJ2Y3Jykge1xuICAgICAgICAgIGNsYXNzZXMuZmEgPSBwcm9wID09PSAnZmEnO1xuICAgICAgICAgIGNsYXNzZXNbJ21hdGVyaWFsLWljb25zJ10gPSBwcm9wID09PSAnbWF0ZXJpYWwnO1xuICAgICAgICAgIGNsYXNzZXNbJ2Y3LWljb25zJ10gPSBwcm9wID09PSAnZjcnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9wID09PSAnZmEnIHx8IHByb3AgPT09ICdpb24nKSB7XG4gICAgICAgICAgY2xhc3Nlc1tgJHtwcm9wfS0ke3ZhbHVlfWBdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvcCA9PT0gJ2ljb24nKSB7XG4gICAgICAgICAgY2xhc3Nlc1t2YWx1ZV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjbGFzc2VzID0ge1xuICAgICAgICAgICdtYXRlcmlhbC1pY29ucyc6IHRoaXMubWF0ZXJpYWwsXG4gICAgICAgICAgJ2Y3LWljb25zJzogdGhpcy5mNyxcbiAgICAgICAgICBmYTogdGhpcy5mYSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMuaW9uKSBjbGFzc2VzW2Bpb24tJHt0aGlzLmlvbn1gXSA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLmZhKSBjbGFzc2VzW2BmYS0ke3RoaXMuZmF9YF0gPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5pY29uKSBjbGFzc2VzW3RoaXMuaWNvbl0gPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFV0aWxzLmV4dGVuZChjbGFzc2VzLCBNaXhpbnMuY29sb3JDbGFzc2VzKHNlbGYpKTtcbiAgICB9LFxuICB9LFxufTtcblxuY29uc3QgQnV0dG9uUHJvcHMgPSBVdGlscy5leHRlbmQoXG4gIHtcbiAgICBub0Zhc3RjbGljazogQm9vbGVhbixcbiAgICBub0Zhc3RDbGljazogQm9vbGVhbixcbiAgICB0ZXh0OiBTdHJpbmcsXG4gICAgdGFiTGluazogW0Jvb2xlYW4sIFN0cmluZ10sXG4gICAgdGFiTGlua0FjdGl2ZTogQm9vbGVhbixcbiAgICBocmVmOiB7XG4gICAgICB0eXBlOiBbU3RyaW5nLCBCb29sZWFuXSxcbiAgICAgIGRlZmF1bHQ6ICcjJyxcbiAgICB9LFxuXG4gICAgcm91bmQ6IEJvb2xlYW4sXG4gICAgcm91bmRNZDogQm9vbGVhbixcbiAgICByb3VuZElvczogQm9vbGVhbixcbiAgICBmaWxsOiBCb29sZWFuLFxuICAgIGZpbGxNZDogQm9vbGVhbixcbiAgICBmaWxsSW9zOiBCb29sZWFuLFxuICAgIGJpZzogQm9vbGVhbixcbiAgICBiaWdNZDogQm9vbGVhbixcbiAgICBiaWdJb3M6IEJvb2xlYW4sXG4gICAgc21hbGw6IEJvb2xlYW4sXG4gICAgc21hbGxNZDogQm9vbGVhbixcbiAgICBzbWFsbElvczogQm9vbGVhbixcbiAgICByYWlzZWQ6IEJvb2xlYW4sXG4gICAgb3V0bGluZTogQm9vbGVhbixcbiAgICBhY3RpdmU6IEJvb2xlYW4sXG4gICAgZGlzYWJsZWQ6IEJvb2xlYW4sXG4gIH0sXG4gIE1peGlucy5jb2xvclByb3BzLFxuICBNaXhpbnMubGlua0ljb25Qcm9wcyxcbiAgTWl4aW5zLmxpbmtSb3V0ZXJQcm9wcyxcbiAgTWl4aW5zLmxpbmtBY3Rpb25zUHJvcHNcbik7XG5cbnZhciBmN0J1dHRvbiA9IHtcbiAgbmFtZTogJ2Y3LWJ1dHRvbicsXG4gIGNvbXBvbmVudHM6IHtcbiAgICBmN0ljb24sXG4gIH0sXG4gIHByb3BzOiBCdXR0b25Qcm9wcyxcbiAgcmVuZGVyKGMpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBsZXQgaWNvbkVsO1xuICAgIGxldCB0ZXh0RWw7XG4gICAgaWYgKHNlbGYudGV4dCkge1xuICAgICAgdGV4dEVsID0gYygnc3BhbicsIHt9LCBzZWxmLnRleHQpO1xuICAgIH1cbiAgICBpZiAoc2VsZi5pY29uIHx8IHNlbGYuaWNvbk1hdGVyaWFsIHx8IHNlbGYuaWNvbklvbiB8fCBzZWxmLmljb25GYSB8fCBzZWxmLmljb25GNyB8fCBzZWxmLmljb25JZk1kIHx8IHNlbGYuaWNvbklmSW9zKSB7XG4gICAgICBpY29uRWwgPSBjKCdmNy1pY29uJywge1xuICAgICAgICBwcm9wczoge1xuICAgICAgICAgIG1hdGVyaWFsOiBzZWxmLmljb25NYXRlcmlhbCxcbiAgICAgICAgICBpb246IHNlbGYuaWNvbklvbixcbiAgICAgICAgICBmYTogc2VsZi5pY29uRmEsXG4gICAgICAgICAgZjc6IHNlbGYuaWNvbkY3LFxuICAgICAgICAgIGljb246IHNlbGYuaWNvbixcbiAgICAgICAgICBpZk1kOiBzZWxmLmljb25JZk1kLFxuICAgICAgICAgIGlmSW9zOiBzZWxmLmljb25JZklvcyxcbiAgICAgICAgICBjb2xvcjogc2VsZi5pY29uQ29sb3IsXG4gICAgICAgICAgc2l6ZTogc2VsZi5pY29uU2l6ZSxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgIH1cbiAgICBzZWxmLmNsYXNzZXMuYnV0dG9uID0gdHJ1ZTtcbiAgICBjb25zdCBsaW5rRWwgPSBjKCdhJywge1xuICAgICAgY2xhc3M6IHNlbGYuY2xhc3NlcyxcbiAgICAgIGF0dHJzOiBzZWxmLmF0dHJzLFxuICAgICAgb246IHtcbiAgICAgICAgY2xpY2s6IHNlbGYub25DbGljayxcbiAgICAgIH0sXG4gICAgfSwgW2ljb25FbCwgdGV4dEVsLCBzZWxmLiRzbG90cy5kZWZhdWx0XSk7XG5cbiAgICByZXR1cm4gbGlua0VsO1xuICB9LFxuICBjb21wdXRlZDoge1xuICAgIGF0dHJzKCkge1xuICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICBjb25zdCB7IGhyZWYsIHRhcmdldCwgdGFiTGluayB9ID0gc2VsZjtcbiAgICAgIGxldCBocmVmQ29tcHV0ZWQgPSBocmVmO1xuICAgICAgaWYgKGhyZWYgPT09IHRydWUpIGhyZWZDb21wdXRlZCA9ICcjJztcbiAgICAgIGlmIChocmVmID09PSBmYWxzZSkgaHJlZkNvbXB1dGVkID0gdW5kZWZpbmVkOyAvLyBubyBocmVmIGF0dHJpYnV0ZVxuICAgICAgcmV0dXJuIFV0aWxzLmV4dGVuZChcbiAgICAgICAge1xuICAgICAgICAgIGhyZWY6IGhyZWZDb21wdXRlZCxcbiAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgJ2RhdGEtdGFiJzogVXRpbHMuaXNTdHJpbmdQcm9wKHRhYkxpbmspICYmIHRhYkxpbmssXG4gICAgICAgIH0sXG4gICAgICAgIE1peGlucy5saW5rUm91dGVyQXR0cnMoc2VsZiksXG4gICAgICAgIE1peGlucy5saW5rQWN0aW9uc0F0dHJzKHNlbGYpXG4gICAgICApO1xuICAgIH0sXG4gICAgY2xhc3NlcygpIHtcbiAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgY29uc3Qge1xuICAgICAgICBub0Zhc3RjbGljayxcbiAgICAgICAgbm9GYXN0Q2xpY2ssXG4gICAgICAgIHRhYkxpbmssXG4gICAgICAgIHRhYkxpbmtBY3RpdmUsXG4gICAgICAgIHJvdW5kLFxuICAgICAgICByb3VuZElvcyxcbiAgICAgICAgcm91bmRNZCxcbiAgICAgICAgZmlsbCxcbiAgICAgICAgZmlsbElvcyxcbiAgICAgICAgZmlsbE1kLFxuICAgICAgICBiaWcsXG4gICAgICAgIGJpZ0lvcyxcbiAgICAgICAgYmlnTWQsXG4gICAgICAgIHNtYWxsLFxuICAgICAgICBzbWFsbElvcyxcbiAgICAgICAgc21hbGxNZCxcbiAgICAgICAgcmFpc2VkLFxuICAgICAgICBhY3RpdmUsXG4gICAgICAgIG91dGxpbmUsXG4gICAgICAgIGRpc2FibGVkLFxuICAgICAgfSA9IHNlbGY7XG5cbiAgICAgIHJldHVybiBVdGlscy5leHRlbmQoXG4gICAgICAgIHtcbiAgICAgICAgICAndGFiLWxpbmsnOiB0YWJMaW5rIHx8IHRhYkxpbmsgPT09ICcnLFxuICAgICAgICAgICd0YWItbGluay1hY3RpdmUnOiB0YWJMaW5rQWN0aXZlLFxuICAgICAgICAgICduby1mYXN0Y2xpY2snOiBub0Zhc3RjbGljayB8fCBub0Zhc3RDbGljayxcblxuICAgICAgICAgICdidXR0b24tcm91bmQnOiByb3VuZCxcbiAgICAgICAgICAnYnV0dG9uLXJvdW5kLWlvcyc6IHJvdW5kSW9zLFxuICAgICAgICAgICdidXR0b24tcm91bmQtbWQnOiByb3VuZE1kLFxuICAgICAgICAgICdidXR0b24tZmlsbCc6IGZpbGwsXG4gICAgICAgICAgJ2J1dHRvbi1maWxsLWlvcyc6IGZpbGxJb3MsXG4gICAgICAgICAgJ2J1dHRvbi1maWxsLW1kJzogZmlsbE1kLFxuICAgICAgICAgICdidXR0b24tYmlnJzogYmlnLFxuICAgICAgICAgICdidXR0b24tYmlnLWlvcyc6IGJpZ0lvcyxcbiAgICAgICAgICAnYnV0dG9uLWJpZy1tZCc6IGJpZ01kLFxuICAgICAgICAgICdidXR0b24tc21hbGwnOiBzbWFsbCxcbiAgICAgICAgICAnYnV0dG9uLXNtYWxsLWlvcyc6IHNtYWxsSW9zLFxuICAgICAgICAgICdidXR0b24tc21hbGwtbWQnOiBzbWFsbE1kLFxuICAgICAgICAgICdidXR0b24tcmFpc2VkJzogcmFpc2VkLFxuICAgICAgICAgICdidXR0b24tYWN0aXZlJzogYWN0aXZlLFxuICAgICAgICAgICdidXR0b24tb3V0bGluZSc6IG91dGxpbmUsXG5cbiAgICAgICAgICBkaXNhYmxlZCxcbiAgICAgICAgfSxcbiAgICAgICAgTWl4aW5zLmNvbG9yQ2xhc3NlcyhzZWxmKSxcbiAgICAgICAgTWl4aW5zLmxpbmtSb3V0ZXJDbGFzc2VzKHNlbGYpLFxuICAgICAgICBNaXhpbnMubGlua0FjdGlvbnNDbGFzc2VzKHNlbGYpXG4gICAgICApO1xuICAgIH0sXG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBvbkNsaWNrKGV2ZW50KSB7XG4gICAgICB0aGlzLiRlbWl0KCdjbGljaycsIGV2ZW50KTtcbiAgICB9LFxuICB9LFxufTtcblxuY29uc3QgQ2FyZENvbnRlbnRQcm9wcyA9IFV0aWxzLmV4dGVuZChcbiAge1xuICAgIHBhZGRpbmc6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiB0cnVlLFxuICAgIH0sXG4gIH0sXG4gIE1peGlucy5jb2xvclByb3BzXG4pO1xuXG52YXIgZjdDYXJkQ29udGVudCA9IHtyZW5kZXI6IGZ1bmN0aW9uKCl7dmFyIF92bT10aGlzO3ZhciBfaD1fdm0uJGNyZWF0ZUVsZW1lbnQ7dmFyIF9jPV92bS5fc2VsZi5fY3x8X2g7cmV0dXJuIF9jKCdkaXYnLHtzdGF0aWNDbGFzczpcImNhcmQtY29udGVudFwiLGNsYXNzOl92bS5jbGFzc2VzfSxbX3ZtLl90KFwiZGVmYXVsdFwiKV0sMil9LHN0YXRpY1JlbmRlckZuczogW10sXG4gIG5hbWU6ICdmNy1jYXJkLWNvbnRlbnQnLFxuICBwcm9wczogQ2FyZENvbnRlbnRQcm9wcyxcbiAgY29tcHV0ZWQ6IHtcbiAgICBjbGFzc2VzKCkge1xuICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICByZXR1cm4gVXRpbHMuZXh0ZW5kKFxuICAgICAgICB7XG4gICAgICAgICAgJ2NhcmQtY29udGVudC1wYWRkaW5nJzogc2VsZi5wYWRkaW5nLFxuICAgICAgICB9LFxuICAgICAgICBNaXhpbnMuY29sb3JDbGFzc2VzKHNlbGYpXG4gICAgICApO1xuICAgIH0sXG4gIH0sXG59O1xuXG52YXIgZjdDYXJkRm9vdGVyID0ge3JlbmRlcjogZnVuY3Rpb24oKXt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtyZXR1cm4gX2MoJ2Rpdicse3N0YXRpY0NsYXNzOlwiY2FyZC1mb290ZXJcIixjbGFzczpfdm0uY2xhc3Nlc30sW192bS5fdChcImRlZmF1bHRcIildLDIpfSxzdGF0aWNSZW5kZXJGbnM6IFtdLFxuICBwcm9wczogTWl4aW5zLmNvbG9yUHJvcHMsXG4gIG5hbWU6ICdmNy1jYXJkLWZvb3RlcicsXG4gIGNvbXB1dGVkOiB7XG4gICAgY2xhc3NlcygpIHtcbiAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgcmV0dXJuIE1peGlucy5jb2xvckNsYXNzZXMoc2VsZik7XG4gICAgfSxcbiAgfSxcbn07XG5cbnZhciBmN0NhcmRIZWFkZXIgPSB7cmVuZGVyOiBmdW5jdGlvbigpe3ZhciBfdm09dGhpczt2YXIgX2g9X3ZtLiRjcmVhdGVFbGVtZW50O3ZhciBfYz1fdm0uX3NlbGYuX2N8fF9oO3JldHVybiBfYygnZGl2Jyx7c3RhdGljQ2xhc3M6XCJjYXJkLWhlYWRlclwiLGNsYXNzOl92bS5jbGFzc2VzfSxbX3ZtLl90KFwiZGVmYXVsdFwiKV0sMil9LHN0YXRpY1JlbmRlckZuczogW10sXG4gIHByb3BzOiBNaXhpbnMuY29sb3JQcm9wcyxcbiAgbmFtZTogJ2Y3LWNhcmQtaGVhZGVyJyxcbiAgY29tcHV0ZWQ6IHtcbiAgICBjbGFzc2VzKCkge1xuICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICByZXR1cm4gTWl4aW5zLmNvbG9yQ2xhc3NlcyhzZWxmKTtcbiAgICB9LFxuICB9LFxufTtcblxuY29uc3QgQ2FyZFByb3BzID0gVXRpbHMuZXh0ZW5kKFxuICB7XG4gICAgdGl0bGU6IFtTdHJpbmcsIE51bWJlcl0sXG4gICAgY29udGVudDogW1N0cmluZywgTnVtYmVyXSxcbiAgICBmb290ZXI6IFtTdHJpbmcsIE51bWJlcl0sXG4gICAgcGFkZGluZzoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgfSxcbiAgfSxcbiAgTWl4aW5zLmNvbG9yUHJvcHNcbik7XG5cbnZhciBmN0NhcmQgPSB7XG4gIG5hbWU6ICdmNy1jYXJkJyxcbiAgY29tcG9uZW50czoge1xuICAgIGY3Q2FyZEhlYWRlcixcbiAgICBmN0NhcmRDb250ZW50LFxuICAgIGY3Q2FyZEZvb3RlcixcbiAgfSxcbiAgcHJvcHM6IENhcmRQcm9wcyxcbiAgcmVuZGVyKGMpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBsZXQgaGVhZGVyRWw7XG4gICAgbGV0IGNvbnRlbnRFbDtcbiAgICBsZXQgZm9vdGVyRWw7XG5cbiAgICBpZiAoc2VsZi50aXRsZSB8fCAoc2VsZi4kc2xvdHMgJiYgc2VsZi4kc2xvdHMuaGVhZGVyKSkge1xuICAgICAgaGVhZGVyRWwgPSBjKCdmNy1jYXJkLWhlYWRlcicsIFtzZWxmLnRpdGxlLCBzZWxmLiRzbG90cy5oZWFkZXJdKTtcbiAgICB9XG4gICAgaWYgKHNlbGYuY29udGVudCB8fCAoc2VsZi4kc2xvdHMgJiYgc2VsZi4kc2xvdHMuY29udGVudCkpIHtcbiAgICAgIGNvbnRlbnRFbCA9IGMoJ2Y3LWNhcmQtY29udGVudCcsIHsgcHJvcHM6IHsgcGFkZGluZzogc2VsZi5wYWRkaW5nIH0gfSwgW3NlbGYuY29udGVudCwgc2VsZi4kc2xvdHMuY29udGVudF0pO1xuICAgIH1cbiAgICBpZiAoc2VsZi5mb290ZXIgfHwgKHNlbGYuJHNsb3RzICYmIHNlbGYuJHNsb3RzLmZvb3RlcikpIHtcbiAgICAgIGZvb3RlckVsID0gYygnZjctY2FyZC1mb290ZXInLCBbc2VsZi5mb290ZXIsIHNlbGYuJHNsb3RzLmZvb3Rlcl0pO1xuICAgIH1cbiAgICByZXR1cm4gYygnZGl2JywgeyBzdGF0aWNDbGFzczogJ2NhcmQnLCBjbGFzczogc2VsZi5jbGFzc2VzIH0sIFtoZWFkZXJFbCwgY29udGVudEVsLCBmb290ZXJFbCwgc2VsZi4kc2xvdHMuZGVmYXVsdF0pO1xuICB9LFxuICBjb21wdXRlZDoge1xuICAgIGNsYXNzZXMoKSB7XG4gICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgIHJldHVybiBNaXhpbnMuY29sb3JDbGFzc2VzKHNlbGYpO1xuICAgIH0sXG4gIH0sXG59O1xuXG5jb25zdCBDaGVja2JveFByb3BzID0gVXRpbHMuZXh0ZW5kKHtcbiAgY2hlY2tlZDogQm9vbGVhbixcbiAgbmFtZTogW051bWJlciwgU3RyaW5nXSxcbiAgdmFsdWU6IFtOdW1iZXIsIFN0cmluZywgQm9vbGVhbl0sXG4gIGRpc2FibGVkOiBCb29sZWFuLFxuICByZWFkb25seTogQm9vbGVhbixcbn0sIE1peGlucy5jb2xvclByb3BzKTtcblxudmFyIGY3Q2hlY2tib3ggPSB7XG4gIG5hbWU6ICdmNy1jaGVja2JveCcsXG4gIHByb3BzOiBDaGVja2JveFByb3BzLFxuICByZW5kZXIoYykge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuXG4gICAgY29uc3QgaW5wdXRFbCA9IGMoJ2lucHV0Jywge1xuICAgICAgYXR0cnM6IHtcbiAgICAgICAgdHlwZTogJ2NoZWNrYm94JyxcbiAgICAgICAgbmFtZTogc2VsZi5uYW1lLFxuICAgICAgfSxcbiAgICAgIGRvbVByb3BzOiB7XG4gICAgICAgIHZhbHVlOiBzZWxmLnZhbHVlLFxuICAgICAgICBkaXNhYmxlZDogc2VsZi5kaXNhYmxlZCxcbiAgICAgICAgcmVhZG9ubHk6IHNlbGYucmVhZG9ubHksXG4gICAgICAgIGNoZWNrZWQ6IHNlbGYuY2hlY2tlZCxcbiAgICAgIH0sXG4gICAgICBvbjoge1xuICAgICAgICBjaGFuZ2U6IHNlbGYub25DaGFuZ2UsXG4gICAgICB9LFxuICAgIH0pO1xuXG4gICAgY29uc3QgaWNvbkVsID0gYygnaScsIHsgc3RhdGljQ2xhc3M6ICdpY29uLWNoZWNrYm94JyB9KTtcblxuICAgIHJldHVybiBjKCdsYWJlbCcsIHtcbiAgICAgIHN0YXRpY0NsYXNzOiAnY2hlY2tib3gnLFxuICAgICAgY2xhc3M6IHNlbGYuY2xhc3NlcyxcbiAgICB9LCBbaW5wdXRFbCwgaWNvbkVsLCBzZWxmLiRzbG90cy5kZWZhdWx0XSk7XG4gIH0sXG4gIGNvbXB1dGVkOiB7XG4gICAgY2xhc3NlcygpIHtcbiAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgcmV0dXJuIFV0aWxzLmV4dGVuZChcbiAgICAgICAge1xuICAgICAgICAgIGRpc2FibGVkOiBzZWxmLmRpc2FibGVkLFxuICAgICAgICB9LFxuICAgICAgICBNaXhpbnMuY29sb3JDbGFzc2VzKHNlbGYpXG4gICAgICApO1xuICAgIH0sXG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBvbkNoYW5nZShldmVudCkge1xuICAgICAgdGhpcy4kZW1pdCgnY2hhbmdlJywgZXZlbnQpO1xuICAgIH0sXG4gIH0sXG59O1xuXG5jb25zdCBDaGlwUHJvcHMgPSBVdGlscy5leHRlbmQoe1xuICBtZWRpYTogU3RyaW5nLFxuICB0ZXh0OiBbU3RyaW5nLCBOdW1iZXJdLFxuICBkZWxldGVhYmxlOiBCb29sZWFuLFxuICBtZWRpYUJnQ29sb3I6IFN0cmluZyxcbiAgbWVkaWFUZXh0Q29sb3I6IFN0cmluZyxcbn0sIE1peGlucy5jb2xvclByb3BzKTtcblxudmFyIGY3Q2hpcCA9IHtcbiAgbmFtZTogJ2Y3LWNoaXAnLFxuICBwcm9wczogQ2hpcFByb3BzLFxuICByZW5kZXIoYykge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIGxldCBtZWRpYUVsO1xuICAgIGxldCBsYWJlbEVsO1xuICAgIGxldCBkZWxldGVFbDtcbiAgICBpZiAoc2VsZi5tZWRpYSB8fCAoc2VsZi4kc2xvdHMgJiYgc2VsZi4kc2xvdHMubWVkaWEpKSB7XG4gICAgICBtZWRpYUVsID0gYygnZGl2JywgeyBzdGF0aWNDbGFzczogJ2NoaXAtbWVkaWEnLCBjbGFzczogc2VsZi5tZWRpYUNsYXNzZXMgfSwgc2VsZi5tZWRpYSB8fCBzZWxmLiRzbG90cy5tZWRpYSk7XG4gICAgfVxuICAgIGlmIChzZWxmLnRleHQgfHwgKHNlbGYuJHNsb3RzICYmIHNlbGYuJHNsb3RzLnRleHQpKSB7XG4gICAgICBsYWJlbEVsID0gYygnZGl2JywgeyBzdGF0aWNDbGFzczogJ2NoaXAtbGFiZWwnIH0sIFtzZWxmLnRleHQsIHNlbGYuJHNsb3RzLnRleHRdKTtcbiAgICB9XG4gICAgaWYgKHNlbGYuZGVsZXRlYWJsZSkge1xuICAgICAgZGVsZXRlRWwgPSBjKCdhJywge1xuICAgICAgICBzdGF0aWNDbGFzczogJ2NoaXAtZGVsZXRlJyxcbiAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICBocmVmOiAnIycsXG4gICAgICAgIH0sXG4gICAgICAgIG9uOiB7XG4gICAgICAgICAgY2xpY2s6IHNlbGYub25EZWxldGVDbGljayxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gYygnZGl2Jywge1xuICAgICAgc3RhdGljQ2xhc3M6ICdjaGlwJyxcbiAgICAgIGNsYXNzOiBzZWxmLmNsYXNzZXMsXG4gICAgICBvbjoge1xuICAgICAgICBjbGljazogc2VsZi5vbkNsaWNrLFxuICAgICAgfSxcbiAgICB9LCBbbWVkaWFFbCwgbGFiZWxFbCwgZGVsZXRlRWxdKTtcbiAgfSxcbiAgY29tcHV0ZWQ6IHtcbiAgICBjbGFzc2VzKCkge1xuICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICByZXR1cm4gTWl4aW5zLmNvbG9yQ2xhc3NlcyhzZWxmKTtcbiAgICB9LFxuICAgIG1lZGlhQ2xhc3NlcygpIHtcbiAgICAgIGNvbnN0IGMgPSB7fTtcbiAgICAgIGlmICh0aGlzLm1lZGlhVGV4dENvbG9yKSBjW2B0ZXh0LWNvbG9yLSR7dGhpcy5tZWRpYVRleHRDb2xvcn1gXSA9IHRydWU7XG4gICAgICBpZiAodGhpcy5tZWRpYUJnQ29sb3IpIGNbYGJnLWNvbG9yLSR7dGhpcy5tZWRpYUJnQ29sb3J9YF0gPSB0cnVlO1xuICAgICAgcmV0dXJuIGM7XG4gICAgfSxcbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIG9uQ2xpY2soZXZlbnQpIHtcbiAgICAgIHRoaXMuJGVtaXQoJ2NsaWNrJywgZXZlbnQpO1xuICAgIH0sXG4gICAgb25EZWxldGVDbGljayhldmVudCkge1xuICAgICAgdGhpcy4kZW1pdCgnZGVsZXRlJywgZXZlbnQpO1xuICAgIH0sXG4gIH0sXG59O1xuXG5jb25zdCBDb2xQcm9wcyA9IFV0aWxzLmV4dGVuZChcbiAge1xuICAgIHRhZzoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogJ2RpdicsXG4gICAgfSxcbiAgICB3aWR0aDoge1xuICAgICAgdHlwZTogW051bWJlciwgU3RyaW5nXSxcbiAgICAgIGRlZmF1bHQ6ICdhdXRvJyxcbiAgICB9LFxuICAgIHRhYmxldFdpZHRoOiB7XG4gICAgICB0eXBlOiBbTnVtYmVyLCBTdHJpbmddLFxuICAgIH0sXG4gICAgZGVza3RvcFdpZHRoOiB7XG4gICAgICB0eXBlOiBbTnVtYmVyLCBTdHJpbmddLFxuICAgIH0sXG4gIH0sXG4gIE1peGlucy5jb2xvclByb3BzXG4pO1xuXG52YXIgZjdDb2wgPSB7XG4gIG5hbWU6ICdmNy1jb2wnLFxuICBwcm9wczogQ29sUHJvcHMsXG4gIHJlbmRlcihjKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIGMoc2VsZi50YWcsIHtcbiAgICAgIGNsYXNzOiBzZWxmLmNsYXNzZXMsXG4gICAgfSwgW3NlbGYuJHNsb3RzLmRlZmF1bHRdKTtcbiAgfSxcbiAgY29tcHV0ZWQ6IHtcbiAgICBjbGFzc2VzKCkge1xuICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICByZXR1cm4gVXRpbHMuZXh0ZW5kKFxuICAgICAgICB7XG4gICAgICAgICAgY29sOiBzZWxmLndpZHRoID09PSAnYXV0bycsXG4gICAgICAgICAgW2Bjb2wtJHtzZWxmLndpZHRofWBdOiBzZWxmLndpZHRoICE9PSAnYXV0bycsXG4gICAgICAgICAgW2B0YWJsZXQtJHtzZWxmLnRhYmxldFdpZHRofWBdOiBzZWxmLnRhYmxldFdpZHRoLFxuICAgICAgICAgIFtgZGVza3RvcC0ke3NlbGYuZGVza3RvcFdpZHRofWBdOiBzZWxmLmRlc2t0b3BXaWR0aCxcbiAgICAgICAgfSxcbiAgICAgICAgTWl4aW5zLmNvbG9yQ2xhc3NlcyhzZWxmKVxuICAgICAgKTtcbiAgICB9LFxuICB9LFxufTtcblxuY29uc3QgRmFiQnV0dG9uUHJvcHMgPSBVdGlscy5leHRlbmQoXG4gIHtcbiAgICBmYWJDbG9zZTogQm9vbGVhbixcbiAgfSxcbiAgTWl4aW5zLmNvbG9yUHJvcHNcbik7XG5cbnZhciBmN0ZhYkJ1dHRvbiA9IHtyZW5kZXI6IGZ1bmN0aW9uKCl7dmFyIF92bT10aGlzO3ZhciBfaD1fdm0uJGNyZWF0ZUVsZW1lbnQ7dmFyIF9jPV92bS5fc2VsZi5fY3x8X2g7cmV0dXJuIF9jKCdhJyx7Y2xhc3M6X3ZtLmNsYXNzZXMsb246e1wiY2xpY2tcIjpfdm0ub25DbGlja319LFtfdm0uX3QoXCJkZWZhdWx0XCIpXSwyKX0sc3RhdGljUmVuZGVyRm5zOiBbXSxcbiAgbmFtZTogJ2Y3LWZhYi1idXR0b24nLFxuICBwcm9wczogRmFiQnV0dG9uUHJvcHMsXG4gIGNvbXB1dGVkOiB7XG4gICAgY2xhc3NlcygpIHtcbiAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgcmV0dXJuIFV0aWxzLmV4dGVuZChcbiAgICAgICAge1xuICAgICAgICAgICdmYWItY2xvc2UnOiBzZWxmLmZhYkNsb3NlLFxuICAgICAgICB9LFxuICAgICAgICBNaXhpbnMuY29sb3JDbGFzc2VzKHNlbGYpXG4gICAgICApO1xuICAgIH0sXG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBvbkNsaWNrKGV2ZW50KSB7XG4gICAgICB0aGlzLiRlbWl0KCdjbGljaycsIGV2ZW50KTtcbiAgICB9LFxuICB9LFxufTtcblxuY29uc3QgRmFiQnV0dG9uc1Byb3BzID0gVXRpbHMuZXh0ZW5kKFxuICB7XG4gICAgcG9zaXRpb246IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6ICd0b3AnLFxuICAgIH0sXG4gIH0sXG4gIE1peGlucy5jb2xvclByb3BzXG4pO1xuXG52YXIgZjdGYWJCdXR0b25zID0ge3JlbmRlcjogZnVuY3Rpb24oKXt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtyZXR1cm4gX2MoJ2Rpdicse3N0YXRpY0NsYXNzOlwiZmFiLWJ1dHRvbnNcIixjbGFzczpfdm0uY2xhc3Nlc30sW192bS5fdChcImRlZmF1bHRcIildLDIpfSxzdGF0aWNSZW5kZXJGbnM6IFtdLFxuICBuYW1lOiAnZjctZmFiLWJ1dHRvbnMnLFxuICBwcm9wczogRmFiQnV0dG9uc1Byb3BzLFxuICBjb21wdXRlZDoge1xuICAgIGNsYXNzZXMoKSB7XG4gICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgIHJldHVybiBVdGlscy5leHRlbmQoXG4gICAgICAgIHtcbiAgICAgICAgICBbYGZhYi1idXR0b25zLSR7c2VsZi5wb3NpdGlvbn1gXTogdHJ1ZSxcbiAgICAgICAgfSxcbiAgICAgICAgTWl4aW5zLmNvbG9yQ2xhc3NlcyhzZWxmKVxuICAgICAgKTtcbiAgICB9LFxuICB9LFxufTtcblxuY29uc3QgRmFiUHJvcHMgPSBVdGlscy5leHRlbmQoXG4gIHtcbiAgICBtb3JwaFRvOiBTdHJpbmcsXG4gICAgaHJlZjogW0Jvb2xlYW4sIFN0cmluZ10sXG4gICAgcG9zaXRpb246IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6ICdyaWdodC1ib3R0b20nLFxuICAgIH0sXG4gIH0sXG4gIE1peGlucy5jb2xvclByb3BzXG4pO1xuXG52YXIgZjdGYWIgPSB7XG4gIG5hbWU6ICdmNy1mYWInLFxuICBwcm9wczogRmFiUHJvcHMsXG4gIHJlbmRlcihjKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG5cbiAgICBsZXQgaHJlZiA9IHNlbGYuaHJlZjtcbiAgICBpZiAoaHJlZiA9PT0gdHJ1ZSkgaHJlZiA9ICcjJztcbiAgICBpZiAoaHJlZiA9PT0gZmFsc2UpIGhyZWYgPSB1bmRlZmluZWQ7IC8vIG5vIGhyZWYgYXR0cmlidXRlXG5cbiAgICBjb25zdCBsaW5rQ2hpbGRyZW4gPSBbXTtcbiAgICBjb25zdCBmYWJDaGlsZHJlbiA9IFtdO1xuXG4gICAgaWYgKHNlbGYuJHNsb3RzLmRlZmF1bHQpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VsZi4kc2xvdHMuZGVmYXVsdC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBjb25zdCBjaGlsZCA9IHNlbGYuJHNsb3RzLmRlZmF1bHRbaV07XG4gICAgICAgIGlmIChjaGlsZC50YWcgJiYgY2hpbGQudGFnLmluZGV4T2YoJ2ZhYi1idXR0b25zJykgPj0gMCkge1xuICAgICAgICAgIGZhYkNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxpbmtDaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGxpbmtFbCA9IGMoJ2EnLCB7XG4gICAgICBhdHRyczoge1xuICAgICAgICBocmVmLFxuICAgICAgfSxcbiAgICAgIG9uOiB7XG4gICAgICAgIGNsaWNrOiBzZWxmLm9uQ2xpY2ssXG4gICAgICB9LFxuICAgIH0sIGxpbmtDaGlsZHJlbik7XG5cbiAgICBmYWJDaGlsZHJlbi5wdXNoKGxpbmtFbCk7XG5cbiAgICByZXR1cm4gYygnZGl2Jywge1xuICAgICAgc3RhdGljQ2xhc3M6ICdmYWInLFxuICAgICAgY2xhc3M6IHNlbGYuY2xhc3NlcyxcbiAgICAgIGF0dHJzOiB7XG4gICAgICAgICdkYXRhLW1vcnBoLXRvJzogc2VsZi5tb3JwaFRvLFxuICAgICAgfSxcbiAgICB9LCBmYWJDaGlsZHJlbik7XG4gIH0sXG4gIGNvbXB1dGVkOiB7XG4gICAgY2xhc3NlcygpIHtcbiAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgcmV0dXJuIFV0aWxzLmV4dGVuZChcbiAgICAgICAge1xuICAgICAgICAgICdmYWItbW9ycGgnOiBzZWxmLm1vcnBoVG8sXG4gICAgICAgICAgW2BmYWItJHtzZWxmLnBvc2l0aW9ufWBdOiB0cnVlLFxuICAgICAgICB9LFxuICAgICAgICBNaXhpbnMuY29sb3JDbGFzc2VzKHNlbGYpXG4gICAgICApO1xuICAgIH0sXG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBvbkNsaWNrKGV2ZW50KSB7XG4gICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgIHNlbGYuJGVtaXQoJ2NsaWNrJywgZXZlbnQpO1xuICAgIH0sXG4gIH0sXG59O1xuXG5jb25zdCBUb2dnbGVQcm9wcyA9IFV0aWxzLmV4dGVuZCh7XG4gIGluaXQ6IHtcbiAgICB0eXBlOiBCb29sZWFuLFxuICAgIGRlZmF1bHQ6IHRydWUsXG4gIH0sXG4gIGNoZWNrZWQ6IEJvb2xlYW4sXG4gIGRpc2FibGVkOiBCb29sZWFuLFxuICByZWFkb25seTogQm9vbGVhbixcbiAgbmFtZTogU3RyaW5nLFxuICB2YWx1ZTogW1N0cmluZywgTnVtYmVyLCBBcnJheV0sXG59LCBNaXhpbnMuY29sb3JQcm9wcyk7XG5cbnZhciBmN1RvZ2dsZSA9IHtcbiAgbmFtZTogJ2Y3LXRvZ2dsZScsXG4gIHJlbmRlcihjKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG5cbiAgICByZXR1cm4gYygnbGFiZWwnLCB7XG4gICAgICBzdGF0aWNDbGFzczogJ3RvZ2dsZScsXG4gICAgICBjbGFzczogVXRpbHMuZXh0ZW5kKFxuICAgICAgICB7XG4gICAgICAgICAgZGlzYWJsZWQ6IHNlbGYuZGlzYWJsZWQsXG4gICAgICAgIH0sXG4gICAgICAgIE1peGlucy5jb2xvckNsYXNzZXMoc2VsZilcbiAgICAgICksXG4gICAgfSwgW1xuICAgICAgYygnaW5wdXQnLCB7XG4gICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgdHlwZTogJ2NoZWNrYm94JyxcbiAgICAgICAgICBuYW1lOiBzZWxmLm5hbWUsXG4gICAgICAgIH0sXG4gICAgICAgIGRvbVByb3BzOiB7XG4gICAgICAgICAgZGlzYWJsZWQ6IHNlbGYuZGlzYWJsZWQsXG4gICAgICAgICAgcmVhZG9ubHk6IHNlbGYucmVhZG9ubHksXG4gICAgICAgICAgY2hlY2tlZDogc2VsZi5jaGVja2VkLFxuICAgICAgICAgIHZhbHVlOiBzZWxmLnZhbHVlLFxuICAgICAgICB9LFxuICAgICAgICBvbjoge1xuICAgICAgICAgIGNoYW5nZTogc2VsZi5vbkNoYW5nZSxcbiAgICAgICAgfSxcbiAgICAgIH0pLFxuICAgICAgYygnc3BhbicsIHsgc3RhdGljQ2xhc3M6ICd0b2dnbGUtaWNvbicgfSksXG4gICAgXSk7XG4gIH0sXG4gIHByb3BzOiBUb2dnbGVQcm9wcyxcbiAgd2F0Y2g6IHtcbiAgICBjaGVja2VkKG5ld1ZhbHVlKSB7XG4gICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgIGlmICghc2VsZi5mN1RvZ2dsZSkgcmV0dXJuO1xuICAgICAgc2VsZi5mN1RvZ2dsZS5jaGVja2VkID0gbmV3VmFsdWU7XG4gICAgfSxcbiAgfSxcbiAgYmVmb3JlRGVzdHJveSgpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBpZiAoc2VsZi5mN1RvZ2dsZSAmJiBzZWxmLmY3VG9nZ2xlLmRlc3Ryb3kgJiYgc2VsZi5mN1RvZ2dsZS4kZWwpIHNlbGYuZjdUb2dnbGUuZGVzdHJveSgpO1xuICB9LFxuICBtZXRob2RzOiB7XG4gICAgdG9nZ2xlKCkge1xuICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICBpZiAoc2VsZi5mN1RvZ2dsZSAmJiBzZWxmLmY3VG9nZ2xlLnNldFZhbHVlKSBzZWxmLmY3VG9nZ2xlLnRvZ2dsZSgpO1xuICAgIH0sXG4gICAgb25DaGFuZ2UoZSkge1xuICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICBzZWxmLiRlbWl0KCdjaGFuZ2UnLCBlKTtcbiAgICB9LFxuICAgIG9uRjdSZWFkeShmNykge1xuICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICBpZiAoIXNlbGYuaW5pdCkgcmV0dXJuO1xuICAgICAgc2VsZi4kbmV4dFRpY2soKCkgPT4ge1xuICAgICAgICBzZWxmLmY3VG9nZ2xlID0gZjcudG9nZ2xlLmNyZWF0ZSh7XG4gICAgICAgICAgZWw6IHNlbGYuJGVsLFxuICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICBjaGFuZ2UodG9nZ2xlKSB7XG4gICAgICAgICAgICAgIHNlbGYuJGVtaXQoJ3RvZ2dsZTpjaGFuZ2UnLCB0b2dnbGUuY2hlY2tlZCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSxcbiAgfSxcbn07XG5cbmNvbnN0IFJhbmdlUHJvcHMgPSBVdGlscy5leHRlbmQoe1xuICBpbml0OiB7XG4gICAgdHlwZTogQm9vbGVhbixcbiAgICBkZWZhdWx0OiB0cnVlLFxuICB9LFxuICB2YWx1ZToge1xuICAgIHR5cGU6IFtOdW1iZXIsIEFycmF5LCBTdHJpbmddLFxuICAgIGRlZmF1bHQ6IDAsXG4gIH0sXG4gIG1pbjoge1xuICAgIHR5cGU6IFtOdW1iZXIsIFN0cmluZ10sXG4gICAgZGVmYXVsdDogMCxcbiAgfSxcbiAgbWF4OiB7XG4gICAgdHlwZTogW051bWJlciwgU3RyaW5nXSxcbiAgICBkZWZhdWx0OiAxMDAsXG4gIH0sXG4gIHN0ZXA6IHtcbiAgICB0eXBlOiBbTnVtYmVyLCBTdHJpbmddLFxuICAgIGRlZmF1bHQ6IDEsXG4gIH0sXG4gIGxhYmVsOiB7XG4gICAgdHlwZTogQm9vbGVhbixcbiAgICBkZWZhdWx0OiBmYWxzZSxcbiAgfSxcbiAgZHVhbDoge1xuICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgZGVmYXVsdDogZmFsc2UsXG4gIH0sXG4gIGRpc2FibGVkOiBCb29sZWFuLFxuICBkcmFnZ2FibGVCYXI6IHtcbiAgICB0eXBlOiBCb29sZWFuLFxuICAgIGRlZmF1bHQ6IHRydWUsXG4gIH0sXG59LCBNaXhpbnMuY29sb3JQcm9wcyk7XG5cbnZhciBmN1JhbmdlID0ge1xuICBuYW1lOiAnZjctcmFuZ2UnLFxuICByZW5kZXIoYykge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuXG4gICAgcmV0dXJuIGMoJ2RpdicsIHtcbiAgICAgIHN0YXRpY0NsYXNzOiAncmFuZ2Utc2xpZGVyJyxcbiAgICAgIGNsYXNzOiBVdGlscy5leHRlbmQoe1xuICAgICAgICBkaXNhYmxlZDogc2VsZi5kaXNhYmxlZCxcbiAgICAgIH0sIE1peGlucy5jb2xvckNsYXNzZXMoc2VsZikpLFxuICAgIH0pO1xuICB9LFxuICBwcm9wczogUmFuZ2VQcm9wcyxcbiAgd2F0Y2g6IHtcbiAgICB2YWx1ZShuZXdWYWx1ZSkge1xuICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICBpZiAoIXNlbGYuZjdSYW5nZSkgcmV0dXJuO1xuICAgICAgc2VsZi5mN1JhbmdlLnNldFZhbHVlKG5ld1ZhbHVlKTtcbiAgICB9LFxuICB9LFxuICBiZWZvcmVEZXN0cm95KCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIGlmIChzZWxmLmY3UmFuZ2UgJiYgc2VsZi5mN1JhbmdlLmRlc3Ryb3kpIHNlbGYuZjdSYW5nZS5kZXN0cm95KCk7XG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBzZXRWYWx1ZShuZXdWYWx1ZSkge1xuICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICBpZiAoc2VsZi5mN1JhbmdlICYmIHNlbGYuZjdSYW5nZS5zZXRWYWx1ZSkgc2VsZi5mN1JhbmdlLnNldFZhbHVlKG5ld1ZhbHVlKTtcbiAgICB9LFxuICAgIGdldFZhbHVlKCkge1xuICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICBpZiAoc2VsZi5mN1JhbmdlICYmIHNlbGYuZjdSYW5nZS5nZXRWYWx1ZSkge1xuICAgICAgICByZXR1cm4gc2VsZi5mN1JhbmdlLmdldFZhbHVlKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0sXG4gICAgb25GN1JlYWR5KGY3KSB7XG4gICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgIGlmICghc2VsZi5pbml0KSByZXR1cm47XG4gICAgICBzZWxmLiRuZXh0VGljaygoKSA9PiB7XG4gICAgICAgIHNlbGYuZjdSYW5nZSA9IGY3LnJhbmdlLmNyZWF0ZSh7XG4gICAgICAgICAgZWw6IHNlbGYuJGVsLFxuICAgICAgICAgIHZhbHVlOiBzZWxmLnZhbHVlLFxuICAgICAgICAgIG1pbjogc2VsZi5taW4sXG4gICAgICAgICAgbWF4OiBzZWxmLm1heCxcbiAgICAgICAgICBzdGVwOiBzZWxmLnN0ZXAsXG4gICAgICAgICAgbGFiZWw6IHNlbGYubGFiZWwsXG4gICAgICAgICAgZHVhbDogc2VsZi5kdWFsLFxuICAgICAgICAgIGRyYWdnYWJsZUJhcjogc2VsZi5kcmFnZ2FibGVCYXIsXG4gICAgICAgICAgb246IHtcbiAgICAgICAgICAgIGNoYW5nZShyYW5nZSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgc2VsZi4kZW1pdCgncmFuZ2U6Y2hhbmdlJywgdmFsdWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNoYW5nZWQocmFuZ2UsIHZhbHVlKSB7XG4gICAgICAgICAgICAgIHNlbGYuJGVtaXQoJ3JhbmdlOmNoYW5nZWQnLCB2YWx1ZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSxcbiAgfSxcbn07XG5cbmNvbnN0IElucHV0UHJvcHMgPSBVdGlscy5leHRlbmQoXG4gIHtcbiAgICAvLyBJbnB1dHNcbiAgICB0eXBlOiBTdHJpbmcsXG4gICAgbmFtZTogU3RyaW5nLFxuICAgIHZhbHVlOiBbU3RyaW5nLCBOdW1iZXIsIEFycmF5XSxcbiAgICBwbGFjZWhvbGRlcjogU3RyaW5nLFxuICAgIGlkOiBTdHJpbmcsXG4gICAgc2l6ZTogW1N0cmluZywgTnVtYmVyXSxcbiAgICBhY2NlcHQ6IFtTdHJpbmcsIE51bWJlcl0sXG4gICAgYXV0b2NvbXBsZXRlOiBbU3RyaW5nXSxcbiAgICBhdXRvY29ycmVjdDogW1N0cmluZ10sXG4gICAgYXV0b2NhcGl0YWxpemU6IFtTdHJpbmddLFxuICAgIHNwZWxsY2hlY2s6IFtTdHJpbmddLFxuICAgIGF1dG9mb2N1czogQm9vbGVhbixcbiAgICBhdXRvc2F2ZTogU3RyaW5nLFxuICAgIGNoZWNrZWQ6IEJvb2xlYW4sXG4gICAgZGlzYWJsZWQ6IEJvb2xlYW4sXG4gICAgbWF4OiBbU3RyaW5nLCBOdW1iZXJdLFxuICAgIG1pbjogW1N0cmluZywgTnVtYmVyXSxcbiAgICBzdGVwOiBbU3RyaW5nLCBOdW1iZXJdLFxuICAgIG1heGxlbmd0aDogW1N0cmluZywgTnVtYmVyXSxcbiAgICBtaW5sZW5ndGg6IFtTdHJpbmcsIE51bWJlcl0sXG4gICAgbXVsdGlwbGU6IEJvb2xlYW4sXG4gICAgcmVhZG9ubHk6IEJvb2xlYW4sXG4gICAgcmVxdWlyZWQ6IEJvb2xlYW4sXG4gICAgaW5wdXRTdHlsZTogU3RyaW5nLFxuICAgIHBhdHRlcm46IFN0cmluZyxcbiAgICB2YWxpZGF0ZTogQm9vbGVhbixcbiAgICB0YWJpbmRleDogW1N0cmluZywgTnVtYmVyXSxcbiAgICByZXNpemFibGU6IEJvb2xlYW4sXG4gICAgY2xlYXJCdXR0b246IEJvb2xlYW4sXG5cbiAgICAvLyBFcnJvciwgSW5mb1xuICAgIGVycm9yTWVzc2FnZTogU3RyaW5nLFxuICAgIGluZm86IFN0cmluZyxcblxuICAgIC8vIENvbXBvbmVudHNcbiAgICB3cmFwOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogdHJ1ZSxcbiAgICB9LFxuICB9LFxuICBNaXhpbnMuY29sb3JQcm9wc1xuKTtcblxudmFyIGY3SW5wdXQgPSB7XG4gIG5hbWU6ICdmNy1pbnB1dCcsXG4gIGNvbXBvbmVudHM6IHtcbiAgICBmN1RvZ2dsZSxcbiAgICBmN1JhbmdlLFxuICB9LFxuICBwcm9wczogSW5wdXRQcm9wcyxcbiAgcmVuZGVyKGMpIHtcbiAgICBsZXQgaW5wdXRFbDtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBjb25zdCBhdHRycyA9IHtcbiAgICAgIG5hbWU6IHNlbGYubmFtZSxcbiAgICAgIHR5cGU6IHNlbGYudHlwZSxcbiAgICAgIHBsYWNlaG9sZGVyOiBzZWxmLnBsYWNlaG9sZGVyLFxuICAgICAgaWQ6IHNlbGYuaWQsXG4gICAgICB2YWx1ZTogc2VsZi52YWx1ZSxcbiAgICAgIHNpemU6IHNlbGYuc2l6ZSxcbiAgICAgIGFjY2VwdDogc2VsZi5hY2NlcHQsXG4gICAgICBhdXRvY29tcGxldGU6IHNlbGYuYXV0b2NvbXBsZXRlLFxuICAgICAgYXV0b2NvcnJlY3Q6IHNlbGYuYXV0b2NvcnJlY3QsXG4gICAgICBhdXRvY2FwaXRhbGl6ZTogc2VsZi5hdXRvY2FwaXRhbGl6ZSxcbiAgICAgIHNwZWxsY2hlY2s6IHNlbGYuc3BlbGxjaGVjayxcbiAgICAgIGF1dG9mb2N1czogc2VsZi5hdXRvZm9jdXMsXG4gICAgICBhdXRvc2F2ZTogc2VsZi5hdXRvc2F2ZSxcbiAgICAgIGNoZWNrZWQ6IHNlbGYuY2hlY2tlZCxcbiAgICAgIGRpc2FibGVkOiBzZWxmLmRpc2FibGVkLFxuICAgICAgbWF4OiBzZWxmLm1heCxcbiAgICAgIG1heGxlbmd0aDogc2VsZi5tYXhsZW5ndGgsXG4gICAgICBtaW46IHNlbGYubWluLFxuICAgICAgbWlubGVuZ3RoOiBzZWxmLm1pbmxlbmd0aCxcbiAgICAgIHN0ZXA6IHNlbGYuc3RlcCxcbiAgICAgIG11bHRpcGxlOiBzZWxmLm11bHRpcGxlLFxuICAgICAgcmVhZG9ubHk6IHNlbGYucmVhZG9ubHksXG4gICAgICByZXF1aXJlZDogc2VsZi5yZXF1aXJlZCxcbiAgICAgIHBhdHRlcm46IHNlbGYucGF0dGVybixcbiAgICAgIHZhbGlkYXRlOiBzZWxmLnZhbGlkYXRlLFxuICAgICAgdGFiaW5kZXg6IHNlbGYudGFiaW5kZXgsXG4gICAgICAnZGF0YS1lcnJvci1tZXNzYWdlJzogc2VsZi5lcnJvck1lc3NhZ2UsXG4gICAgfTtcbiAgICBjb25zdCBvbiA9IHtcbiAgICAgIGZvY3VzOiBzZWxmLm9uRm9jdXMsXG4gICAgICBibHVyOiBzZWxmLm9uQmx1cixcbiAgICAgIGlucHV0OiBzZWxmLm9uSW5wdXQsXG4gICAgICBjaGFuZ2U6IHNlbGYub25DaGFuZ2UsXG4gICAgICAndGV4dGFyZWE6cmVzaXplJzogc2VsZi5vblRleHRhcmVhUmVzaXplLFxuICAgICAgJ2lucHV0Om5vdGVtcHR5Jzogc2VsZi5vbklucHV0Tm90RW1wdHksXG4gICAgICAnaW5wdXQ6ZW1wdHknOiBzZWxmLm9uSW5wdXRFbXB0eSxcbiAgICAgICdpbnB1dDpjbGVhcic6IHNlbGYub25JbnB1dENsZWFyLFxuICAgIH07XG4gICAgaWYgKHNlbGYudHlwZSA9PT0gJ3NlbGVjdCcgfHwgc2VsZi50eXBlID09PSAndGV4dGFyZWEnIHx8IHNlbGYudHlwZSA9PT0gJ2ZpbGUnKSB7XG4gICAgICBkZWxldGUgYXR0cnMudmFsdWU7XG4gICAgICBpZiAoc2VsZi50eXBlID09PSAnc2VsZWN0Jykge1xuICAgICAgICBpbnB1dEVsID0gYygnc2VsZWN0Jywge1xuICAgICAgICAgIGF0dHJzLCBvbiwgc3R5bGU6IHNlbGYuaW5wdXRTdHlsZSwgZG9tUHJvcHM6IHsgdmFsdWU6IHNlbGYudmFsdWUgfSxcbiAgICAgICAgfSwgc2VsZi4kc2xvdHMuZGVmYXVsdCk7XG4gICAgICB9IGVsc2UgaWYgKHNlbGYudHlwZSA9PT0gJ2ZpbGUnKSB7XG4gICAgICAgIGlucHV0RWwgPSBjKCdpbnB1dCcsIHsgYXR0cnMsIHN0eWxlOiBzZWxmLmlucHV0U3R5bGUsIG9uIH0sIHNlbGYuJHNsb3RzLmRlZmF1bHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5wdXRFbCA9IGMoJ3RleHRhcmVhJywge1xuICAgICAgICAgIGF0dHJzLFxuICAgICAgICAgIHN0eWxlOiBzZWxmLmlucHV0U3R5bGUsXG4gICAgICAgICAgb24sXG4gICAgICAgICAgY2xhc3M6IHsgcmVzaXphYmxlOiBzZWxmLnJlc2l6YWJsZSB9LFxuICAgICAgICAgIGRvbVByb3BzOiB7IHZhbHVlOiBzZWxmLnZhbHVlIH0sXG4gICAgICAgIH0sIHNlbGYuJHNsb3RzLmRlZmF1bHQpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoKHNlbGYuJHNsb3RzLmRlZmF1bHQgJiYgc2VsZi4kc2xvdHMuZGVmYXVsdC5sZW5ndGggPiAwKSB8fCAhc2VsZi50eXBlKSB7XG4gICAgICBpbnB1dEVsID0gc2VsZi4kc2xvdHMuZGVmYXVsdDtcbiAgICB9IGVsc2UgaWYgKHNlbGYudHlwZSA9PT0gJ3RvZ2dsZScpIHtcbiAgICAgIGlucHV0RWwgPSBjKCdmNy10b2dnbGUnLCB7IHByb3BzOiBhdHRycywgb24gfSk7XG4gICAgfSBlbHNlIGlmIChzZWxmLnR5cGUgPT09ICdyYW5nZScpIHtcbiAgICAgIG9uWydyYW5nZTpjaGFuZ2UnXSA9IHNlbGYub25DaGFuZ2U7XG4gICAgICBpbnB1dEVsID0gYygnZjctcmFuZ2UnLCB7IHByb3BzOiBhdHRycywgb24gfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlucHV0RWwgPSBjKCdpbnB1dCcsIHtcbiAgICAgICAgYXR0cnMsXG4gICAgICAgIHN0eWxlOiBzZWxmLmlucHV0U3R5bGUsXG4gICAgICAgIG9uLFxuICAgICAgICBkb21Qcm9wczogeyB2YWx1ZTogc2VsZi52YWx1ZSwgY2hlY2tlZDogc2VsZi5jaGVja2VkIH0sXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBsZXQgY2xlYXJCdXR0b25FbDtcbiAgICBpZiAoc2VsZi5jbGVhckJ1dHRvbikge1xuICAgICAgY2xlYXJCdXR0b25FbCA9IGMoJ3NwYW4nLCB7IHN0YXRpY0NsYXNzOiAnaW5wdXQtY2xlYXItYnV0dG9uJyB9KTtcbiAgICB9XG5cbiAgICBsZXQgJHBhcmVudCA9IHNlbGYuJHBhcmVudDtcbiAgICBsZXQgZm91bmRJdGVtQ29udGVudDtcbiAgICB3aGlsZSAoJHBhcmVudCAmJiAhZm91bmRJdGVtQ29udGVudCkge1xuICAgICAgY29uc3QgdGFnID0gJHBhcmVudC4kdm5vZGUgJiYgJHBhcmVudC4kdm5vZGUudGFnO1xuICAgICAgaWYgKHRhZyAmJiAodGFnLmluZGV4T2YoJ2xpc3QtaXRlbScpID4gMCB8fCB0YWcuaW5kZXhPZignbGlzdC1pdGVtLWNvbnRlbnQnKSA+IDApKSB7XG4gICAgICAgIGZvdW5kSXRlbUNvbnRlbnQgPSAkcGFyZW50O1xuICAgICAgfVxuICAgICAgJHBhcmVudCA9ICRwYXJlbnQuJHBhcmVudDtcbiAgICB9XG4gICAgaWYgKGZvdW5kSXRlbUNvbnRlbnQpIGZvdW5kSXRlbUNvbnRlbnQuaXRlbUlucHV0Rm9yY2VkID0gdHJ1ZTtcbiAgICBpZiAoZm91bmRJdGVtQ29udGVudCAmJiAoc2VsZi5pbmZvIHx8IChzZWxmLiRzbG90cy5pbmZvICYmIHNlbGYuJHNsb3RzLmluZm8ubGVuZ3RoKSkpIGZvdW5kSXRlbUNvbnRlbnQuaXRlbUlucHV0V2l0aEluZm9Gb3JjZWQgPSB0cnVlO1xuXG4gICAgbGV0IGluZm9FbDtcbiAgICBpZiAoc2VsZi5pbmZvIHx8IChzZWxmLiRzbG90cy5pbmZvICYmIHNlbGYuJHNsb3RzLmluZm8ubGVuZ3RoKSkge1xuICAgICAgaW5mb0VsID0gYygnZGl2JywgeyBzdGF0aWNDbGFzczogJ2l0ZW0taW5wdXQtaW5mbycgfSwgW3NlbGYuaW5mbywgc2VsZi4kc2xvdHMuaW5mb10pO1xuICAgIH1cblxuICAgIGNvbnN0IGl0ZW1JbnB1dCA9IHNlbGYud3JhcCA/IGMoJ2RpdicsIHsgc3RhdGljQ2xhc3M6ICdpdGVtLWlucHV0LXdyYXAnLCBjbGFzczogc2VsZi5jbGFzc2VzIH0sIFtpbnB1dEVsLCBjbGVhckJ1dHRvbkVsLCBpbmZvRWxdKSA6IGlucHV0RWw7XG4gICAgcmV0dXJuIGl0ZW1JbnB1dDtcbiAgfSxcbiAgY29tcHV0ZWQ6IHtcbiAgICBjbGFzc2VzKCkge1xuICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICByZXR1cm4gTWl4aW5zLmNvbG9yQ2xhc3NlcyhzZWxmKTtcbiAgICB9LFxuICB9LFxuICB3YXRjaDoge1xuICAgIHZhbHVlKCkge1xuICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICBpZiAoc2VsZi50eXBlID09PSAncmFuZ2UnIHx8IHNlbGYudHlwZSA9PT0gJ3RvZ2dsZScpIHJldHVybjtcbiAgICAgIGNvbnN0IGY3ID0gc2VsZi4kZjc7XG4gICAgICBpZiAoIWY3KSByZXR1cm47XG4gICAgICBjb25zdCBpbnB1dEVsID0gc2VsZi53cmFwID8gc2VsZi4kZWwucXVlcnlTZWxlY3RvcignaW5wdXQsIHNlbGVjdCwgdGV4dGFyZWEnKSA6IHNlbGYuJGVsO1xuICAgICAgc2VsZi4kbmV4dFRpY2soKCkgPT4ge1xuICAgICAgICBmNy5pbnB1dC5jaGVja0VtcHR5U3RhdGUoaW5wdXRFbCk7XG4gICAgICAgIGlmIChzZWxmLnZhbGlkYXRlKSB7XG4gICAgICAgICAgZjcuaW5wdXQudmFsaWRhdGUoaW5wdXRFbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlbGYucmVzaXphYmxlKSB7XG4gICAgICAgICAgZjcuaW5wdXQucmVzaXplVGV4dGFyZWEoaW5wdXRFbCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBvbkY3UmVhZHkoZjcpIHtcbiAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgY29uc3QgaW5wdXRFbCA9IHNlbGYud3JhcCA/IHNlbGYuJGVsLnF1ZXJ5U2VsZWN0b3IoJ2lucHV0LCBzZWxlY3QsIHRleHRhcmVhJykgOiBzZWxmLiRlbDtcbiAgICAgIGY3LmlucHV0LmNoZWNrRW1wdHlTdGF0ZShpbnB1dEVsKTtcbiAgICAgIGlmIChzZWxmLnZhbGlkYXRlKSB7XG4gICAgICAgIGY3LmlucHV0LnZhbGlkYXRlKGlucHV0RWwpO1xuICAgICAgfVxuICAgICAgaWYgKHNlbGYucmVzaXphYmxlKSB7XG4gICAgICAgIGY3LmlucHV0LnJlc2l6ZVRleHRhcmVhKGlucHV0RWwpO1xuICAgICAgfVxuICAgIH0sXG4gICAgb25UZXh0YXJlYVJlc2l6ZShldmVudCkge1xuICAgICAgdGhpcy4kZW1pdCgndGV4dGFyZWE6cmVzaXplJywgZXZlbnQpO1xuICAgIH0sXG4gICAgb25JbnB1dE5vdEVtcHR5KGV2ZW50KSB7XG4gICAgICB0aGlzLiRlbWl0KCdpbnB1dDpub3RlbXB0eScsIGV2ZW50KTtcbiAgICB9LFxuICAgIG9uSW5wdXRFbXB0eShldmVudCkge1xuICAgICAgdGhpcy4kZW1pdCgnaW5wdXQ6ZW1wdHknLCBldmVudCk7XG4gICAgfSxcbiAgICBvbklucHV0Q2xlYXIoZXZlbnQpIHtcbiAgICAgIHRoaXMuJGVtaXQoJ2lucHV0OmNsZWFyJywgZXZlbnQpO1xuICAgIH0sXG4gICAgb25JbnB1dChldmVudCkge1xuICAgICAgdGhpcy4kZW1pdCgnaW5wdXQnLCBldmVudCk7XG4gICAgfSxcbiAgICBvbkZvY3VzKGV2ZW50KSB7XG4gICAgICB0aGlzLiRlbWl0KCdmb2N1cycsIGV2ZW50KTtcbiAgICB9LFxuICAgIG9uQmx1cihldmVudCkge1xuICAgICAgdGhpcy4kZW1pdCgnYmx1cicsIGV2ZW50KTtcbiAgICB9LFxuICAgIG9uQ2hhbmdlKGV2ZW50KSB7XG4gICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgIHNlbGYuJGVtaXQoJ2NoYW5nZScsIGV2ZW50KTtcbiAgICB9LFxuICB9LFxufTtcblxuY29uc3QgTGFiZWxQcm9wcyA9IFV0aWxzLmV4dGVuZChcbiAge1xuICAgIGZsb2F0aW5nOiBCb29sZWFuLFxuICAgIGlubGluZTogQm9vbGVhbixcbiAgfSxcbiAgTWl4aW5zLmNvbG9yUHJvcHNcbik7XG5cbnZhciBmN0xhYmVsID0ge1xuICBuYW1lOiAnZjctbGFiZWwnLFxuICBwcm9wczogTGFiZWxQcm9wcyxcbiAgcmVuZGVyKGMpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcblxuICAgIGlmIChzZWxmLmlubGluZSkge1xuICAgICAgbGV0ICRwYXJlbnQgPSBzZWxmLiRwYXJlbnQ7XG4gICAgICBsZXQgZm91bmRJdGVtQ29udGVudDtcbiAgICAgIHdoaWxlICgkcGFyZW50ICYmICFmb3VuZEl0ZW1Db250ZW50KSB7XG4gICAgICAgIGNvbnN0IHRhZyA9ICRwYXJlbnQuJHZub2RlICYmICRwYXJlbnQuJHZub2RlLnRhZztcbiAgICAgICAgaWYgKHRhZyAmJiAodGFnLmluZGV4T2YoJ2xpc3QtaXRlbScpID4gMCB8fCB0YWcuaW5kZXhPZignbGlzdC1pdGVtLWNvbnRlbnQnKSA+IDApKSB7XG4gICAgICAgICAgZm91bmRJdGVtQ29udGVudCA9ICRwYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgJHBhcmVudCA9ICRwYXJlbnQuJHBhcmVudDtcbiAgICAgIH1cbiAgICAgIGlmIChmb3VuZEl0ZW1Db250ZW50KSBmb3VuZEl0ZW1Db250ZW50LmlubGluZUxhYmVsRm9yY2VkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gYygnZGl2Jywge1xuICAgICAgc3RhdGljQ2xhc3M6ICdpdGVtLXRpdGxlJyxcbiAgICAgIGNsYXNzOiBzZWxmLmNsYXNzZXMsXG4gICAgfSwgW3NlbGYuJHNsb3RzLmRlZmF1bHRdKTtcbiAgfSxcbiAgY29tcHV0ZWQ6IHtcbiAgICBjbGFzc2VzKCkge1xuICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICByZXR1cm4gVXRpbHMuZXh0ZW5kKFxuICAgICAgICB7XG4gICAgICAgICAgJ2l0ZW0tbGFiZWwnOiAhc2VsZi5mbG9hdGluZyxcbiAgICAgICAgICAnaXRlbS1mbG9hdGluZy1sYWJlbCc6IHNlbGYuZmxvYXRpbmcsXG4gICAgICAgIH0sXG4gICAgICAgIE1peGlucy5jb2xvckNsYXNzZXMoc2VsZilcbiAgICAgICk7XG4gICAgfSxcbiAgfSxcbn07XG5cbmNvbnN0IExpbmtQcm9wcyA9IFV0aWxzLmV4dGVuZChcbiAge1xuICAgIG5vTGlua0NsYXNzOiBCb29sZWFuLFxuICAgIG5vRmFzdENsaWNrOiBCb29sZWFuLFxuICAgIG5vRmFzdGNsaWNrOiBCb29sZWFuLFxuICAgIHRleHQ6IFN0cmluZyxcbiAgICB0YWJMaW5rOiBbQm9vbGVhbiwgU3RyaW5nXSxcbiAgICB0YWJMaW5rQWN0aXZlOiBCb29sZWFuLFxuICAgIGljb25Pbmx5OiBCb29sZWFuLFxuICAgIGJhZGdlOiBbU3RyaW5nLCBOdW1iZXJdLFxuICAgIGJhZGdlQ29sb3I6IFtTdHJpbmddLFxuICAgIGljb25CYWRnZTogW1N0cmluZywgTnVtYmVyXSxcbiAgICBocmVmOiB7XG4gICAgICB0eXBlOiBbU3RyaW5nLCBCb29sZWFuXSxcbiAgICAgIGRlZmF1bHQ6ICcjJyxcbiAgICB9LFxuICB9LFxuICBNaXhpbnMuY29sb3JQcm9wcyxcbiAgTWl4aW5zLmxpbmtJY29uUHJvcHMsXG4gIE1peGlucy5saW5rUm91dGVyUHJvcHMsXG4gIE1peGlucy5saW5rQWN0aW9uc1Byb3BzXG4pO1xuXG52YXIgZjdMaW5rID0ge1xuICBuYW1lOiAnZjctbGluaycsXG4gIGNvbXBvbmVudHM6IHtcbiAgICBmN0JhZGdlLFxuICAgIGY3SWNvbixcbiAgfSxcbiAgcHJvcHM6IExpbmtQcm9wcyxcbiAgcmVuZGVyKGMpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBjb25zdCBpc1RhYmJhckxhYmVsID0gKHNlbGYudGFiTGluayB8fCBzZWxmLnRhYkxpbmsgPT09ICcnKSAmJiBzZWxmLiRwYXJlbnQgJiYgc2VsZi4kcGFyZW50LnRhYmJhciAmJiBzZWxmLiRwYXJlbnQubGFiZWxzO1xuXG4gICAgbGV0IGljb25FbDtcbiAgICBsZXQgdGV4dEVsO1xuICAgIGxldCBiYWRnZUVsO1xuICAgIGxldCBpY29uQmFkZ2VFbDtcblxuICAgIGlmIChzZWxmLnRleHQpIHtcbiAgICAgIGlmIChzZWxmLmJhZGdlKSBiYWRnZUVsID0gYygnZjctYmFkZ2UnLCB7IHByb3BzOiB7IGNvbG9yOiBzZWxmLmJhZGdlQ29sb3IgfSB9LCBzZWxmLmJhZGdlKTtcbiAgICAgIHRleHRFbCA9IGMoJ3NwYW4nLCB7IGNsYXNzOiB7ICd0YWJiYXItbGFiZWwnOiBpc1RhYmJhckxhYmVsIH0gfSwgW3NlbGYudGV4dCwgYmFkZ2VFbF0pO1xuICAgIH1cbiAgICBpZiAoc2VsZi5pY29uIHx8IHNlbGYuaWNvbk1hdGVyaWFsIHx8IHNlbGYuaWNvbklvbiB8fCBzZWxmLmljb25GYSB8fCBzZWxmLmljb25GNyB8fCAoc2VsZi5pY29uSWZNZCAmJiBzZWxmLiR0aGVtZS5tZCkgfHwgKHNlbGYuaWNvbklmSW9zICYmIHNlbGYuJHRoZW1lLmlvcykpIHtcbiAgICAgIGlmIChzZWxmLmljb25CYWRnZSkgaWNvbkJhZGdlRWwgPSBjKCdmNy1iYWRnZScsIHsgcHJvcHM6IHsgY29sb3I6IHNlbGYuYmFkZ2VDb2xvciB9IH0sIHNlbGYuaWNvbkJhZGdlKTtcbiAgICAgIGljb25FbCA9IGMoJ2Y3LWljb24nLCB7XG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgbWF0ZXJpYWw6IHNlbGYuaWNvbk1hdGVyaWFsLFxuICAgICAgICAgIGlvbjogc2VsZi5pY29uSW9uLFxuICAgICAgICAgIGZhOiBzZWxmLmljb25GYSxcbiAgICAgICAgICBmNzogc2VsZi5pY29uRjcsXG4gICAgICAgICAgaWNvbjogc2VsZi5pY29uLFxuICAgICAgICAgIGlmTWQ6IHNlbGYuaWNvbklmTWQsXG4gICAgICAgICAgaWZJb3M6IHNlbGYuaWNvbklmSW9zLFxuICAgICAgICAgIGNvbG9yOiBzZWxmLmljb25Db2xvcixcbiAgICAgICAgICBzaXplOiBzZWxmLmljb25TaXplLFxuICAgICAgICB9LFxuICAgICAgfSwgW2ljb25CYWRnZUVsXSk7XG4gICAgfVxuICAgIGlmIChcbiAgICAgIHNlbGYuaWNvbk9ubHkgfHxcbiAgICAgICghc2VsZi50ZXh0ICYmIHNlbGYuJHNsb3RzLmRlZmF1bHQgJiYgc2VsZi4kc2xvdHMuZGVmYXVsdC5sZW5ndGggPT09IDApIHx8XG4gICAgICAoIXNlbGYudGV4dCAmJiAhc2VsZi4kc2xvdHMuZGVmYXVsdClcbiAgICApIHtcbiAgICAgIHNlbGYuY2xhc3Nlc1snaWNvbi1vbmx5J10gPSB0cnVlO1xuICAgIH1cbiAgICBzZWxmLmNsYXNzZXMubGluayA9ICEoc2VsZi5ub0xpbmtDbGFzcyB8fCBpc1RhYmJhckxhYmVsKTtcbiAgICBjb25zdCBsaW5rRWwgPSBjKCdhJywge1xuICAgICAgY2xhc3M6IHNlbGYuY2xhc3NlcyxcbiAgICAgIGF0dHJzOiBzZWxmLmF0dHJzLFxuICAgICAgb246IHtcbiAgICAgICAgY2xpY2s6IHNlbGYub25DbGljayxcbiAgICAgIH0sXG4gICAgfSwgW2ljb25FbCwgdGV4dEVsLCBzZWxmLiRzbG90cy5kZWZhdWx0XSk7XG4gICAgcmV0dXJuIGxpbmtFbDtcbiAgfSxcbiAgY29tcHV0ZWQ6IHtcbiAgICBhdHRycygpIHtcbiAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgY29uc3QgeyBocmVmLCB0YXJnZXQsIHRhYkxpbmsgfSA9IHNlbGY7XG4gICAgICBsZXQgaHJlZkNvbXB1dGVkID0gaHJlZjtcbiAgICAgIGlmIChocmVmID09PSB0cnVlKSBocmVmQ29tcHV0ZWQgPSAnIyc7XG4gICAgICBpZiAoaHJlZiA9PT0gZmFsc2UpIGhyZWZDb21wdXRlZCA9IHVuZGVmaW5lZDsgLy8gbm8gaHJlZiBhdHRyaWJ1dGVcbiAgICAgIHJldHVybiBVdGlscy5leHRlbmQoXG4gICAgICAgIHtcbiAgICAgICAgICBocmVmOiBocmVmQ29tcHV0ZWQsXG4gICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICdkYXRhLXRhYic6IFV0aWxzLmlzU3RyaW5nUHJvcCh0YWJMaW5rKSAmJiB0YWJMaW5rLFxuICAgICAgICB9LFxuICAgICAgICBNaXhpbnMubGlua1JvdXRlckF0dHJzKHNlbGYpLFxuICAgICAgICBNaXhpbnMubGlua0FjdGlvbnNBdHRycyhzZWxmKVxuICAgICAgKTtcbiAgICB9LFxuICAgIGNsYXNzZXMoKSB7XG4gICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbm9GYXN0Y2xpY2ssXG4gICAgICAgIG5vRmFzdENsaWNrLFxuICAgICAgICB0YWJMaW5rLFxuICAgICAgICB0YWJMaW5rQWN0aXZlLFxuICAgICAgfSA9IHNlbGY7XG5cbiAgICAgIHJldHVybiBVdGlscy5leHRlbmQoXG4gICAgICAgIHtcbiAgICAgICAgICAndGFiLWxpbmsnOiB0YWJMaW5rIHx8IHRhYkxpbmsgPT09ICcnLFxuICAgICAgICAgICd0YWItbGluay1hY3RpdmUnOiB0YWJMaW5rQWN0aXZlLFxuICAgICAgICAgICduby1mYXN0Y2xpY2snOiBub0Zhc3RjbGljayB8fCBub0Zhc3RDbGljayxcbiAgICAgICAgfSxcbiAgICAgICAgTWl4aW5zLmNvbG9yQ2xhc3NlcyhzZWxmKSxcbiAgICAgICAgTWl4aW5zLmxpbmtSb3V0ZXJDbGFzc2VzKHNlbGYpLFxuICAgICAgICBNaXhpbnMubGlua0FjdGlvbnNDbGFzc2VzKHNlbGYpXG4gICAgICApO1xuICAgIH0sXG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBvbkNsaWNrKGV2ZW50KSB7XG4gICAgICB0aGlzLiRlbWl0KCdjbGljaycsIGV2ZW50KTtcbiAgICB9LFxuICB9LFxufTtcblxuY29uc3QgTGlzdEJ1dHRvblByb3BzID0gVXRpbHMuZXh0ZW5kKFxuICB7XG4gICAgbm9GYXN0Y2xpY2s6IEJvb2xlYW4sXG4gICAgbm9GYXN0Q2xpY2s6IEJvb2xlYW4sXG4gICAgdGl0bGU6IFtTdHJpbmcsIE51bWJlcl0sXG4gICAgdGV4dDogW1N0cmluZywgTnVtYmVyXSxcbiAgICB0YWJMaW5rOiBbQm9vbGVhbiwgU3RyaW5nXSxcbiAgICB0YWJMaW5rQWN0aXZlOiBCb29sZWFuLFxuICAgIGxpbms6IFtCb29sZWFuLCBTdHJpbmddLFxuICAgIGhyZWY6IFtCb29sZWFuLCBTdHJpbmddLFxuICAgIHRhcmdldDogU3RyaW5nLFxuICB9LFxuICBNaXhpbnMuY29sb3JQcm9wcyxcbiAgTWl4aW5zLmxpbmtSb3V0ZXJQcm9wcyxcbiAgTWl4aW5zLmxpbmtBY3Rpb25zUHJvcHNcbik7XG5cbnZhciBmN0xpc3RCdXR0b24gPSB7XG4gIG5hbWU6ICdmNy1saXN0LWJ1dHRvbicsXG4gIHJlbmRlcihjKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgY29uc3QgbGlua0VsID0gYygnYScsIHtcbiAgICAgIHN0YXRpY0NsYXNzOiAnaXRlbS1saW5rIGxpc3QtYnV0dG9uJyxcbiAgICAgIGF0dHJzOiBzZWxmLmF0dHJzLFxuICAgICAgY2xhc3M6IHNlbGYuY2xhc3NlcyxcbiAgICAgIG9uOiB7XG4gICAgICAgIGNsaWNrOiBzZWxmLm9uQ2xpY2ssXG4gICAgICB9LFxuICAgIH0sIFtzZWxmLnRpdGxlIHx8IHNlbGYudGV4dCwgc2VsZi4kc2xvdHMuZGVmYXVsdF0pO1xuICAgIHJldHVybiBjKCdsaScsIHt9LCBbbGlua0VsXSk7XG4gIH0sXG4gIHByb3BzOiBMaXN0QnV0dG9uUHJvcHMsXG4gIGNvbXB1dGVkOiB7XG4gICAgYXR0cnMoKSB7XG4gICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgIC8vIExpbmsgUHJvcHNcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbGluayxcbiAgICAgICAgaHJlZixcbiAgICAgICAgdGFyZ2V0LFxuICAgICAgICB0YWJMaW5rLFxuICAgICAgfSA9IHNlbGY7XG5cbiAgICAgIHJldHVybiBVdGlscy5leHRlbmQoXG4gICAgICAgIHtcbiAgICAgICAgICBocmVmOiAoKHR5cGVvZiBsaW5rID09PSAnYm9vbGVhbicgJiYgdHlwZW9mIGhyZWYgPT09ICdib29sZWFuJykgPyAnIycgOiAobGluayB8fCBocmVmKSksXG4gICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICdkYXRhLXRhYic6IFV0aWxzLmlzU3RyaW5nUHJvcCh0YWJMaW5rKSAmJiB0YWJMaW5rLFxuICAgICAgICB9LFxuICAgICAgICBNaXhpbnMubGlua1JvdXRlckF0dHJzKHNlbGYpLFxuICAgICAgICBNaXhpbnMubGlua0FjdGlvbnNBdHRycyhzZWxmKVxuICAgICAgKTtcbiAgICB9LFxuICAgIGNsYXNzZXMoKSB7XG4gICAgICBjb25zdCBzZWxmID0gdGhpcztcblxuICAgICAgY29uc3Qge1xuICAgICAgICBub0Zhc3RjbGljayxcbiAgICAgICAgbm9GYXN0Q2xpY2ssXG4gICAgICAgIHRhYkxpbmssXG4gICAgICAgIHRhYkxpbmtBY3RpdmUsXG4gICAgICB9ID0gc2VsZjtcblxuICAgICAgcmV0dXJuIFV0aWxzLmV4dGVuZChcbiAgICAgICAge1xuICAgICAgICAgICd0YWItbGluayc6IHRhYkxpbmsgfHwgdGFiTGluayA9PT0gJycsXG4gICAgICAgICAgJ3RhYi1saW5rLWFjdGl2ZSc6IHRhYkxpbmtBY3RpdmUsXG4gICAgICAgICAgJ25vLWZhc3RjbGljayc6IG5vRmFzdGNsaWNrIHx8IG5vRmFzdENsaWNrLFxuICAgICAgICB9LFxuICAgICAgICBNaXhpbnMuY29sb3JDbGFzc2VzKHNlbGYpLFxuICAgICAgICBNaXhpbnMubGlua1JvdXRlckNsYXNzZXMoc2VsZiksXG4gICAgICAgIE1peGlucy5saW5rQWN0aW9uc0NsYXNzZXMoc2VsZilcbiAgICAgICk7XG4gICAgfSxcbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIG9uQ2xpY2soZXZlbnQpIHtcbiAgICAgIHRoaXMuJGVtaXQoJ2NsaWNrJywgZXZlbnQpO1xuICAgIH0sXG4gIH0sXG59O1xuXG5jb25zdCBMaXN0R3JvdXBQcm9wcyA9IFV0aWxzLmV4dGVuZChcbiAge1xuICAgIG1lZGlhTGlzdDogQm9vbGVhbixcbiAgICBzb3J0YWJsZTogQm9vbGVhbixcbiAgfSxcbiAgTWl4aW5zLmNvbG9yUHJvcHNcbik7XG5cbnZhciBmN0xpc3RHcm91cCA9IHtyZW5kZXI6IGZ1bmN0aW9uKCl7dmFyIF92bT10aGlzO3ZhciBfaD1fdm0uJGNyZWF0ZUVsZW1lbnQ7dmFyIF9jPV92bS5fc2VsZi5fY3x8X2g7cmV0dXJuIF9jKCdkaXYnLHtzdGF0aWNDbGFzczpcImxpc3QtZ3JvdXBcIixjbGFzczpfdm0uY2xhc3Nlc30sW19jKCd1bCcsW192bS5fdChcImRlZmF1bHRcIildLDIpXSl9LHN0YXRpY1JlbmRlckZuczogW10sXG4gIG5hbWU6ICdmNy1saXN0LWdyb3VwJyxcbiAgcHJvcHM6IExpc3RHcm91cFByb3BzLFxuICBjb21wdXRlZDoge1xuICAgIGNsYXNzZXMoKSB7XG4gICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgIHJldHVybiBNaXhpbnMuY29sb3JDbGFzc2VzKHNlbGYpO1xuICAgIH0sXG4gICAgc29ydGFibGVDb21wdXRlZCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNvcnRhYmxlIHx8IHRoaXMuJHBhcmVudC5zb3J0YWJsZTtcbiAgICB9LFxuICAgIG1lZGlhTGlzdENvbXB1dGVkKCkge1xuICAgICAgcmV0dXJuIHRoaXMubWVkaWFMaXN0IHx8IHRoaXMuJHBhcmVudC5tZWRpYUxpc3Q7XG4gICAgfSxcbiAgfSxcbiAgZGF0YSgpIHtcbiAgICByZXR1cm4ge307XG4gIH0sXG59O1xuXG5jb25zdCBMaXN0SW5kZXhQcm9wcyA9IFV0aWxzLmV4dGVuZChcbiAge1xuICAgIGluaXQ6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiB0cnVlLFxuICAgIH0sXG4gICAgbGlzdEVsOiBbU3RyaW5nLCBPYmplY3RdLFxuICAgIGluZGV4ZXM6IHtcbiAgICAgIHR5cGU6IFtTdHJpbmcsIEFycmF5XSxcbiAgICAgIGRlZmF1bHQ6ICdhdXRvJyxcbiAgICB9LFxuICAgIHNjcm9sbExpc3Q6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiB0cnVlLFxuICAgIH0sXG4gICAgbGFiZWw6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiBmYWxzZSxcbiAgICB9LFxuICAgIGlvc0l0ZW1IZWlnaHQ6IHtcbiAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgIGRlZmF1bHQ6IDE0LFxuICAgIH0sXG4gICAgbWRJdGVtSGVpZ2h0OiB7XG4gICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICBkZWZhdWx0OiAxNCxcbiAgICB9LFxuICB9LFxuICBNaXhpbnMuY29sb3JQcm9wc1xuKTtcbnZhciBmN0xpc3RJbmRleCA9IHtyZW5kZXI6IGZ1bmN0aW9uKCl7dmFyIF92bT10aGlzO3ZhciBfaD1fdm0uJGNyZWF0ZUVsZW1lbnQ7dmFyIF9jPV92bS5fc2VsZi5fY3x8X2g7cmV0dXJuIF9jKCdkaXYnLHtzdGF0aWNDbGFzczpcImxpc3QtaW5kZXhcIixjbGFzczpfdm0uY2xhc3Nlc30sW192bS5fdChcImRlZmF1bHRcIildLDIpfSxzdGF0aWNSZW5kZXJGbnM6IFtdLFxuICBwcm9wczogTGlzdEluZGV4UHJvcHMsXG4gIG5hbWU6ICdmNy1saXN0LWluZGV4JyxcbiAgY29tcHV0ZWQ6IHtcbiAgICBjbGFzc2VzKCkge1xuICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICByZXR1cm4gTWl4aW5zLmNvbG9yQ2xhc3NlcyhzZWxmKTtcbiAgICB9LFxuICB9LFxuICBiZWZvcmVEZXN0cm95KCkge1xuICAgIGlmICghdGhpcy5pbml0KSByZXR1cm47XG4gICAgaWYgKHRoaXMuZjdMaXN0SW5kZXggJiYgdGhpcy5mN0xpc3RJbmRleC5kZXN0cm95KSB7XG4gICAgICB0aGlzLmY3TGlzdEluZGV4LmRlc3Ryb3koKTtcbiAgICB9XG4gIH0sXG4gIHdhdGNoOiB7XG4gICAgaW5kZXhlcygpIHtcbiAgICAgIGlmICghdGhpcy5mN0xpc3RJbmRleCkgcmV0dXJuO1xuICAgICAgdGhpcy5mN0xpc3RJbmRleC5wYXJhbXMuaW5kZXhlcyA9IHRoaXMuaW5kZXhlcztcbiAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfSxcbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIHVwZGF0ZSgpIHtcbiAgICAgIGlmICghdGhpcy5mN0xpc3RJbmRleCkgcmV0dXJuO1xuICAgICAgdGhpcy5mN0xpc3RJbmRleC51cGRhdGUoKTtcbiAgICB9LFxuICAgIHNjcm9sbExpc3RUb0luZGV4KGl0ZW1Db250ZW50KSB7XG4gICAgICBpZiAoIXRoaXMuZjdMaXN0SW5kZXgpIHJldHVybjtcbiAgICAgIHRoaXMuZjdMaXN0SW5kZXguc2Nyb2xsTGlzdFRvSW5kZXgoaXRlbUNvbnRlbnQpO1xuICAgIH0sXG4gICAgb25GN1JlYWR5KGY3KSB7XG4gICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgIGlmICghc2VsZi5pbml0KSByZXR1cm47XG4gICAgICBjb25zdCB7XG4gICAgICAgICRlbCwgbGlzdEVsLCBpbmRleGVzLCBpb3NJdGVtSGVpZ2h0LCBtZEl0ZW1IZWlnaHQsIHNjcm9sbExpc3QsIGxhYmVsLFxuICAgICAgfSA9IHNlbGY7XG4gICAgICBzZWxmLmY3TGlzdEluZGV4ID0gZjcubGlzdEluZGV4LmNyZWF0ZSh7XG4gICAgICAgIGVsOiAkZWwsXG4gICAgICAgIGxpc3RFbCxcbiAgICAgICAgaW5kZXhlcyxcbiAgICAgICAgaW9zSXRlbUhlaWdodCxcbiAgICAgICAgbWRJdGVtSGVpZ2h0LFxuICAgICAgICBzY3JvbGxMaXN0LFxuICAgICAgICBsYWJlbCxcbiAgICAgICAgb246IHtcbiAgICAgICAgICBzZWxlY3QoaW5kZXgsIGl0ZW1Db250ZW50LCBpdGVtSW5kZXgpIHtcbiAgICAgICAgICAgIHNlbGYuJGVtaXQoJ2xpc3RpbmRleDpzZWxlY3QnLCBpdGVtQ29udGVudCwgaXRlbUluZGV4KTtcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgfSk7XG4gICAgfSxcbiAgfSxcbn07XG5cbnZhciBmN0xpc3RJdGVtQ2VsbCA9IHtyZW5kZXI6IGZ1bmN0aW9uKCl7dmFyIF92bT10aGlzO3ZhciBfaD1fdm0uJGNyZWF0ZUVsZW1lbnQ7dmFyIF9jPV92bS5fc2VsZi5fY3x8X2g7cmV0dXJuIF9jKCdkaXYnLHtzdGF0aWNDbGFzczpcIml0ZW0tY2VsbFwiLGNsYXNzOl92bS5jbGFzc2VzfSxbX3ZtLl90KFwiZGVmYXVsdFwiKV0sMil9LHN0YXRpY1JlbmRlckZuczogW10sXG4gIG5hbWU6ICdmNy1saXN0LWl0ZW0tY2VsbCcsXG4gIHByb3BzOiBNaXhpbnMuY29sb3JQcm9wcyxcbiAgY29tcHV0ZWQ6IHtcbiAgICBjbGFzc2VzKCkge1xuICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICByZXR1cm4gTWl4aW5zLmNvbG9yQ2xhc3NlcyhzZWxmKTtcbiAgICB9LFxuICB9LFxufTtcblxuY29uc3QgTGlzdEl0ZW1Db250ZW50UHJvcHMgPSBVdGlscy5leHRlbmQoXG4gIHtcbiAgICB0aXRsZTogW1N0cmluZywgTnVtYmVyXSxcbiAgICB0ZXh0OiBbU3RyaW5nLCBOdW1iZXJdLFxuICAgIG1lZGlhOiBTdHJpbmcsXG4gICAgc3VidGl0bGU6IFtTdHJpbmcsIE51bWJlcl0sXG4gICAgaGVhZGVyOiBbU3RyaW5nLCBOdW1iZXJdLFxuICAgIGZvb3RlcjogW1N0cmluZywgTnVtYmVyXSxcbiAgICBhZnRlcjogW1N0cmluZywgTnVtYmVyXSxcbiAgICBiYWRnZTogW1N0cmluZywgTnVtYmVyXSxcbiAgICBiYWRnZUNvbG9yOiBTdHJpbmcsXG4gICAgbWVkaWFMaXN0OiBCb29sZWFuLFxuICAgIGl0ZW1JbnB1dDogQm9vbGVhbixcbiAgICBpdGVtSW5wdXRXaXRoSW5mbzogQm9vbGVhbixcbiAgICBpbmxpbmVMYWJlbDogQm9vbGVhbixcblxuICAgIGNoZWNrYm94OiBCb29sZWFuLFxuICAgIGNoZWNrZWQ6IEJvb2xlYW4sXG4gICAgcmFkaW86IEJvb2xlYW4sXG4gICAgbmFtZTogU3RyaW5nLFxuICAgIHZhbHVlOiBbU3RyaW5nLCBOdW1iZXIsIEFycmF5XSxcbiAgICByZWFkb25seTogQm9vbGVhbixcbiAgICByZXF1aXJlZDogQm9vbGVhbixcbiAgICBkaXNhYmxlZDogQm9vbGVhbixcbiAgfSxcbiAgTWl4aW5zLmNvbG9yUHJvcHNcbik7XG5cbnZhciBmN0xpc3RJdGVtQ29udGVudCA9IHtcbiAgbmFtZTogJ2Y3LWxpc3QtaXRlbS1jb250ZW50JyxcbiAgY29tcG9uZW50czoge1xuICAgIGY3QmFkZ2UsXG4gIH0sXG4gIHByb3BzOiBMaXN0SXRlbUNvbnRlbnRQcm9wcyxcbiAgcmVuZGVyKGMpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBjb25zdCBzbG90c0NvbnRlbnRTdGFydCA9IFtdO1xuICAgIGNvbnN0IHNsb3RzQ29udGVudCA9IFtdO1xuICAgIGNvbnN0IHNsb3RzQ29udGVudEVuZCA9IFtdO1xuICAgIGNvbnN0IHNsb3RzSW5uZXJTdGFydCA9IFtdO1xuICAgIGNvbnN0IHNsb3RzSW5uZXIgPSBbXTtcbiAgICBjb25zdCBzbG90c0lubmVyRW5kID0gW107XG4gICAgY29uc3Qgc2xvdHNBZnRlclN0YXJ0ID0gW107XG4gICAgY29uc3Qgc2xvdHNBZnRlciA9IFtdO1xuICAgIGNvbnN0IHNsb3RzQWZ0ZXJFbmQgPSBbXTtcbiAgICBjb25zdCBzbG90c01lZGlhID0gW107XG4gICAgY29uc3Qgc2xvdHNCZWZvcmVUaXRsZSA9IFtdO1xuICAgIGNvbnN0IHNsb3RzVGl0bGUgPSBbXTtcbiAgICBjb25zdCBzbG90c0FmdGVyVGl0bGUgPSBbXTtcbiAgICBjb25zdCBzbG90c1N1YnRpdGxlID0gW107XG4gICAgY29uc3Qgc2xvdHNUZXh0ID0gW107XG4gICAgY29uc3Qgc2xvdHNIZWFkZXIgPSBbXTtcbiAgICBjb25zdCBzbG90c0Zvb3RlciA9IFtdO1xuXG4gICAgbGV0IFt0aXRsZUVsLCBhZnRlcldyYXBFbCwgYWZ0ZXJFbCwgYmFkZ2VFbCwgaW5uZXJFbCwgdGl0bGVSb3dFbCwgc3VidGl0bGVFbCwgdGV4dEVsLCBtZWRpYUVsLCBpbnB1dEVsLCBpbnB1dEljb25FbCwgaGVhZGVyRWwsIGZvb3RlckVsXSA9IFtdO1xuXG4gICAgaWYgKHNlbGYuJHNsb3RzLmRlZmF1bHQgJiYgc2VsZi4kc2xvdHMuZGVmYXVsdC5sZW5ndGggPiAwKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlbGYuJHNsb3RzLmRlZmF1bHQubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgY29uc3Qgc2xvdE5hbWUgPSBzZWxmLiRzbG90cy5kZWZhdWx0W2ldLmRhdGEgPyBzZWxmLiRzbG90cy5kZWZhdWx0W2ldLmRhdGEuc2xvdCA6IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKCFzbG90TmFtZSB8fCAoc2xvdE5hbWUgPT09ICdpbm5lcicpKSBzbG90c0lubmVyLnB1c2goc2VsZi4kc2xvdHMuZGVmYXVsdFtpXSk7XG4gICAgICAgIGlmIChzbG90TmFtZSA9PT0gJ2NvbnRlbnQtc3RhcnQnKSBzbG90c0NvbnRlbnRTdGFydC5wdXNoKHNlbGYuJHNsb3RzLmRlZmF1bHRbaV0pO1xuICAgICAgICBpZiAoc2xvdE5hbWUgPT09ICdjb250ZW50Jykgc2xvdHNDb250ZW50LnB1c2goc2VsZi4kc2xvdHMuZGVmYXVsdFtpXSk7XG4gICAgICAgIGlmIChzbG90TmFtZSA9PT0gJ2NvbnRlbnQtZW5kJykgc2xvdHNDb250ZW50RW5kLnB1c2goc2VsZi4kc2xvdHMuZGVmYXVsdFtpXSk7XG4gICAgICAgIGlmIChzbG90TmFtZSA9PT0gJ2FmdGVyLXN0YXJ0Jykgc2xvdHNBZnRlclN0YXJ0LnB1c2goc2VsZi4kc2xvdHMuZGVmYXVsdFtpXSk7XG4gICAgICAgIGlmIChzbG90TmFtZSA9PT0gJ2FmdGVyJykgc2xvdHNBZnRlci5wdXNoKHNlbGYuJHNsb3RzLmRlZmF1bHRbaV0pO1xuICAgICAgICBpZiAoc2xvdE5hbWUgPT09ICdhZnRlci1lbmQnKSBzbG90c0FmdGVyRW5kLnB1c2goc2VsZi4kc2xvdHMuZGVmYXVsdFtpXSk7XG4gICAgICAgIGlmIChzbG90TmFtZSA9PT0gJ21lZGlhJykgc2xvdHNNZWRpYS5wdXNoKHNlbGYuJHNsb3RzLmRlZmF1bHRbaV0pO1xuICAgICAgICBpZiAoc2xvdE5hbWUgPT09ICdpbm5lci1zdGFydCcpIHNsb3RzSW5uZXJTdGFydC5wdXNoKHNlbGYuJHNsb3RzLmRlZmF1bHRbaV0pO1xuICAgICAgICBpZiAoc2xvdE5hbWUgPT09ICdpbm5lci1lbmQnKSBzbG90c0lubmVyRW5kLnB1c2goc2VsZi4kc2xvdHMuZGVmYXVsdFtpXSk7XG4gICAgICAgIGlmIChzbG90TmFtZSA9PT0gJ2JlZm9yZS10aXRsZScpIHNsb3RzQmVmb3JlVGl0bGUucHVzaChzZWxmLiRzbG90cy5kZWZhdWx0W2ldKTtcbiAgICAgICAgaWYgKHNsb3ROYW1lID09PSAndGl0bGUnKSBzbG90c1RpdGxlLnB1c2goc2VsZi4kc2xvdHMuZGVmYXVsdFtpXSk7XG4gICAgICAgIGlmIChzbG90TmFtZSA9PT0gJ2FmdGVyLXRpdGxlJykgc2xvdHNBZnRlclRpdGxlLnB1c2goc2VsZi4kc2xvdHMuZGVmYXVsdFtpXSk7XG4gICAgICAgIGlmIChzbG90TmFtZSA9PT0gJ3N1YnRpdGxlJykgc2xvdHNTdWJ0aXRsZS5wdXNoKHNlbGYuJHNsb3RzLmRlZmF1bHRbaV0pO1xuICAgICAgICBpZiAoc2xvdE5hbWUgPT09ICd0ZXh0Jykgc2xvdHNUZXh0LnB1c2goc2VsZi4kc2xvdHMuZGVmYXVsdFtpXSk7XG4gICAgICAgIGlmIChzbG90TmFtZSA9PT0gJ2hlYWRlcicpIHNsb3RzSGVhZGVyLnB1c2goc2VsZi4kc2xvdHMuZGVmYXVsdFtpXSk7XG4gICAgICAgIGlmIChzbG90TmFtZSA9PT0gJ2Zvb3RlcicpIHNsb3RzRm9vdGVyLnB1c2goc2VsZi4kc2xvdHMuZGVmYXVsdFtpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSW5wdXRcbiAgICBpZiAoc2VsZi5yYWRpbyB8fCBzZWxmLmNoZWNrYm94KSB7XG4gICAgICBpbnB1dEVsID0gYygnaW5wdXQnLCB7XG4gICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgdmFsdWU6IHNlbGYudmFsdWUsXG4gICAgICAgICAgbmFtZTogc2VsZi5uYW1lLFxuICAgICAgICAgIGNoZWNrZWQ6IHNlbGYuY2hlY2tlZCxcbiAgICAgICAgICByZWFkb25seTogc2VsZi5yZWFkb25seSxcbiAgICAgICAgICBkaXNhYmxlZDogc2VsZi5kaXNhYmxlZCxcbiAgICAgICAgICByZXF1aXJlZDogc2VsZi5yZXF1aXJlZCxcbiAgICAgICAgICB0eXBlOiBzZWxmLnJhZGlvID8gJ3JhZGlvJyA6ICdjaGVja2JveCcsXG4gICAgICAgIH0sXG4gICAgICAgIG9uOiB7XG4gICAgICAgICAgY2hhbmdlOiBzZWxmLm9uQ2hhbmdlLFxuICAgICAgICB9LFxuICAgICAgICBkb21Qcm9wczoge1xuICAgICAgICAgIGNoZWNrZWQ6IHNlbGYuY2hlY2tlZCxcbiAgICAgICAgICBkaXNhYmxlZDogc2VsZi5kaXNhYmxlZCxcbiAgICAgICAgICByZXF1aXJlZDogc2VsZi5yZXF1aXJlZCxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgICAgaW5wdXRJY29uRWwgPSBjKCdpJywgeyBzdGF0aWNDbGFzczogYGljb24gaWNvbi0ke3NlbGYucmFkaW8gPyAncmFkaW8nIDogJ2NoZWNrYm94J31gIH0pO1xuICAgIH1cbiAgICAvLyBNZWRpYVxuICAgIGlmIChzZWxmLm1lZGlhIHx8IHNsb3RzTWVkaWEubGVuZ3RoKSB7XG4gICAgICBsZXQgbWVkaWFJbWdFbDtcbiAgICAgIGlmIChzZWxmLm1lZGlhKSB7XG4gICAgICAgIG1lZGlhSW1nRWwgPSBjKCdpbWcnLCB7IGF0dHJzOiB7IHNyYzogc2VsZi5tZWRpYSB9IH0pO1xuICAgICAgfVxuICAgICAgbWVkaWFFbCA9IGMoJ2RpdicsIHsgc3RhdGljQ2xhc3M6ICdpdGVtLW1lZGlhJyB9LCBbbWVkaWFJbWdFbCwgc2xvdHNNZWRpYV0pO1xuICAgIH1cbiAgICAvLyBJbm5lciBFbGVtZW50c1xuICAgIGlmIChzZWxmLmhlYWRlciB8fCBzbG90c0hlYWRlci5sZW5ndGgpIHtcbiAgICAgIGhlYWRlckVsID0gYygnZGl2JywgeyBzdGF0aWNDbGFzczogJ2l0ZW0taGVhZGVyJyB9LCBbc2VsZi5oZWFkZXIsIHNsb3RzSGVhZGVyXSk7XG4gICAgfVxuICAgIGlmIChzZWxmLmZvb3RlciB8fCBzbG90c0Zvb3Rlci5sZW5ndGgpIHtcbiAgICAgIGZvb3RlckVsID0gYygnZGl2JywgeyBzdGF0aWNDbGFzczogJ2l0ZW0tZm9vdGVyJyB9LCBbc2VsZi5mb290ZXIsIHNsb3RzRm9vdGVyXSk7XG4gICAgfVxuICAgIGlmIChzZWxmLnRpdGxlIHx8IHNsb3RzVGl0bGUubGVuZ3RoKSB7XG4gICAgICB0aXRsZUVsID0gYygnZGl2JywgeyBzdGF0aWNDbGFzczogJ2l0ZW0tdGl0bGUnIH0sIFshc2VsZi5tZWRpYUxpc3QgJiYgaGVhZGVyRWwsIHNlbGYudGl0bGUsIHNsb3RzVGl0bGUsICFzZWxmLm1lZGlhTGlzdCAmJiBmb290ZXJFbF0pO1xuICAgIH1cbiAgICBpZiAoc2VsZi5zdWJ0aXRsZSB8fCBzbG90c1N1YnRpdGxlLmxlbmd0aCkge1xuICAgICAgc3VidGl0bGVFbCA9IGMoJ2RpdicsIHsgc3RhdGljQ2xhc3M6ICdpdGVtLXN1YnRpdGxlJyB9LCBbc2VsZi5zdWJ0aXRsZSwgc2xvdHNTdWJ0aXRsZV0pO1xuICAgIH1cbiAgICBpZiAoc2VsZi50ZXh0IHx8IHNsb3RzVGV4dC5sZW5ndGgpIHtcbiAgICAgIHRleHRFbCA9IGMoJ2RpdicsIHsgc3RhdGljQ2xhc3M6ICdpdGVtLXRleHQnIH0sIFtzZWxmLnRleHQsIHNsb3RzVGV4dF0pO1xuICAgIH1cbiAgICBpZiAoc2VsZi5hZnRlciB8fCBzZWxmLmJhZGdlIHx8IHNsb3RzQWZ0ZXIubGVuZ3RoKSB7XG4gICAgICBpZiAoc2VsZi5hZnRlcikge1xuICAgICAgICBhZnRlckVsID0gYygnc3BhbicsIFtzZWxmLmFmdGVyXSk7XG4gICAgICB9XG4gICAgICBpZiAoc2VsZi5iYWRnZSkge1xuICAgICAgICBiYWRnZUVsID0gYygnZjctYmFkZ2UnLCB7IHByb3BzOiB7IGNvbG9yOiBzZWxmLmJhZGdlQ29sb3IgfSB9LCBbc2VsZi5iYWRnZV0pO1xuICAgICAgfVxuICAgICAgYWZ0ZXJXcmFwRWwgPSBjKCdkaXYnLCB7IHN0YXRpY0NsYXNzOiAnaXRlbS1hZnRlcicgfSwgW3Nsb3RzQWZ0ZXJTdGFydCwgYWZ0ZXJFbCwgYmFkZ2VFbCwgc2xvdHNBZnRlciwgc2xvdHNBZnRlckVuZF0pO1xuICAgIH1cbiAgICBpZiAoc2VsZi5tZWRpYUxpc3QpIHtcbiAgICAgIHRpdGxlUm93RWwgPSBjKCdkaXYnLCB7IHN0YXRpY0NsYXNzOiAnaXRlbS10aXRsZS1yb3cnIH0sIFtzbG90c0JlZm9yZVRpdGxlLCB0aXRsZUVsLCBzbG90c0FmdGVyVGl0bGUsIGFmdGVyV3JhcEVsXSk7XG4gICAgfVxuICAgIGlubmVyRWwgPSBjKCdkaXYnLCB7IHN0YXRpY0NsYXNzOiAnaXRlbS1pbm5lcicgfSwgc2VsZi5tZWRpYUxpc3QgPyBbc2xvdHNJbm5lclN0YXJ0LCBoZWFkZXJFbCwgdGl0bGVSb3dFbCwgc3VidGl0bGVFbCwgdGV4dEVsLCBzbG90c0lubmVyLCBmb290ZXJFbCwgc2xvdHNJbm5lckVuZF0gOiBbc2xvdHNJbm5lclN0YXJ0LCBzbG90c0JlZm9yZVRpdGxlLCB0aXRsZUVsLCBzbG90c0FmdGVyVGl0bGUsIGFmdGVyV3JhcEVsLCBzbG90c0lubmVyLCBzbG90c0lubmVyRW5kXSk7XG5cbiAgICAvLyBGaW5hbGl6ZVxuICAgIHJldHVybiBjKChzZWxmLmNoZWNrYm94IHx8IHNlbGYucmFkaW8pID8gJ2xhYmVsJyA6ICdkaXYnLCB7XG4gICAgICBzdGF0aWNDbGFzczogJ2l0ZW0tY29udGVudCcsXG4gICAgICBjbGFzczogVXRpbHMuZXh0ZW5kKFxuICAgICAgICB7XG4gICAgICAgICAgJ2l0ZW0tY2hlY2tib3gnOiBzZWxmLmNoZWNrYm94LFxuICAgICAgICAgICdpdGVtLXJhZGlvJzogc2VsZi5yYWRpbyxcbiAgICAgICAgICAnaXRlbS1pbnB1dCc6IHNlbGYuaXRlbUlucHV0IHx8IHNlbGYuaXRlbUlucHV0Rm9yY2VkLFxuICAgICAgICAgICdpbmxpbmUtbGFiZWwnOiBzZWxmLmlubGluZUxhYmVsIHx8IHNlbGYuaW5saW5lTGFiZWxGb3JjZWQsXG4gICAgICAgICAgJ2l0ZW0taW5wdXQtd2l0aC1pbmZvJzogc2VsZi5pdGVtSW5wdXRXaXRoSW5mbyB8fCBzZWxmLml0ZW1JbnB1dFdpdGhJbmZvRm9yY2VkLFxuICAgICAgICB9LFxuICAgICAgICBNaXhpbnMuY29sb3JDbGFzc2VzKHNlbGYpXG4gICAgICApLFxuICAgICAgb246IHtcbiAgICAgICAgY2xpY2s6IHNlbGYub25DbGljayxcbiAgICAgIH0sXG4gICAgfSwgW3Nsb3RzQ29udGVudFN0YXJ0LCBpbnB1dEVsLCBpbnB1dEljb25FbCwgbWVkaWFFbCwgaW5uZXJFbCwgc2xvdHNDb250ZW50LCBzbG90c0NvbnRlbnRFbmRdKTtcbiAgfSxcbiAgZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaXRlbUlucHV0Rm9yY2VkOiBmYWxzZSxcbiAgICAgIGlubGluZUxhYmVsRm9yY2VkOiBmYWxzZSxcbiAgICAgIGl0ZW1JbnB1dFdpdGhJbmZvRm9yY2VkOiBmYWxzZSxcbiAgICB9O1xuICB9LFxuICBtZXRob2RzOiB7XG4gICAgb25DbGljayhldmVudCkge1xuICAgICAgdGhpcy4kZW1pdCgnY2xpY2snLCBldmVudCk7XG4gICAgfSxcbiAgICBvbkNoYW5nZShldmVudCkge1xuICAgICAgdGhpcy4kZW1pdCgnY2hhbmdlJywgZXZlbnQpO1xuICAgIH0sXG4gICAgb25JbnB1dChldmVudCkge1xuICAgICAgdGhpcy4kZW1pdCgnaW5wdXQnLCBldmVudCk7XG4gICAgfSxcbiAgfSxcbn07XG5cbnZhciBmN0xpc3RJdGVtUm93ID0ge3JlbmRlcjogZnVuY3Rpb24oKXt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtyZXR1cm4gX2MoJ2Rpdicse3N0YXRpY0NsYXNzOlwiaXRlbS1yb3dcIixjbGFzczpfdm0uY2xhc3Nlc30sW192bS5fdChcImRlZmF1bHRcIildLDIpfSxzdGF0aWNSZW5kZXJGbnM6IFtdLFxuICBuYW1lOiAnZjctbGlzdC1pdGVtLXJvdycsXG4gIHByb3BzOiBNaXhpbnMuY29sb3JQcm9wcyxcbiAgY29tcHV0ZWQ6IHtcbiAgICBjbGFzc2VzKCkge1xuICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICByZXR1cm4gTWl4aW5zLmNvbG9yQ2xhc3NlcyhzZWxmKTtcbiAgICB9LFxuICB9LFxufTtcblxuY29uc3QgTGlzdEl0ZW1Qcm9wcyA9IFV0aWxzLmV4dGVuZChcbiAge1xuICAgIHRpdGxlOiBbU3RyaW5nLCBOdW1iZXJdLFxuICAgIHRleHQ6IFtTdHJpbmcsIE51bWJlcl0sXG4gICAgbWVkaWE6IFN0cmluZyxcbiAgICBzdWJ0aXRsZTogW1N0cmluZywgTnVtYmVyXSxcbiAgICBoZWFkZXI6IFtTdHJpbmcsIE51bWJlcl0sXG4gICAgZm9vdGVyOiBbU3RyaW5nLCBOdW1iZXJdLFxuXG4gICAgLy8gTGluayBQcm9wc1xuICAgIGxpbms6IFtCb29sZWFuLCBTdHJpbmddLFxuICAgIHRhcmdldDogU3RyaW5nLFxuICAgIG5vRmFzdGNsaWNrOiBCb29sZWFuLFxuICAgIG5vRmFzdENsaWNrOiBCb29sZWFuLFxuXG4gICAgYWZ0ZXI6IFtTdHJpbmcsIE51bWJlcl0sXG4gICAgYmFkZ2U6IFtTdHJpbmcsIE51bWJlcl0sXG4gICAgYmFkZ2VDb2xvcjogU3RyaW5nLFxuXG4gICAgbWVkaWFJdGVtOiBCb29sZWFuLFxuICAgIG1lZGlhTGlzdDogQm9vbGVhbixcbiAgICBkaXZpZGVyOiBCb29sZWFuLFxuICAgIGdyb3VwVGl0bGU6IEJvb2xlYW4sXG4gICAgc3dpcGVvdXQ6IEJvb2xlYW4sXG4gICAgc29ydGFibGU6IEJvb2xlYW4sXG4gICAgYWNjb3JkaW9uSXRlbTogQm9vbGVhbixcbiAgICBhY2NvcmRpb25JdGVtT3BlbmVkOiBCb29sZWFuLFxuXG4gICAgLy8gU21hcnQgU2VsZWN0XG4gICAgc21hcnRTZWxlY3Q6IEJvb2xlYW4sXG4gICAgc21hcnRTZWxlY3RQYXJhbXM6IE9iamVjdCxcblxuICAgIC8vIElucHV0c1xuICAgIGNoZWNrYm94OiBCb29sZWFuLFxuICAgIHJhZGlvOiBCb29sZWFuLFxuICAgIGNoZWNrZWQ6IEJvb2xlYW4sXG4gICAgbmFtZTogU3RyaW5nLFxuICAgIHZhbHVlOiBbU3RyaW5nLCBOdW1iZXIsIEFycmF5XSxcbiAgICByZWFkb25seTogQm9vbGVhbixcbiAgICByZXF1aXJlZDogQm9vbGVhbixcbiAgICBkaXNhYmxlZDogQm9vbGVhbixcbiAgICBpdGVtSW5wdXQ6IEJvb2xlYW4sXG4gICAgaXRlbUlucHV0V2l0aEluZm86IEJvb2xlYW4sXG4gICAgaW5saW5lTGFiZWw6IEJvb2xlYW4sXG4gIH0sXG4gIE1peGlucy5jb2xvclByb3BzLFxuICBNaXhpbnMubGlua1JvdXRlclByb3BzLFxuICBNaXhpbnMubGlua0FjdGlvbnNQcm9wc1xuKTtcblxudmFyIGY3TGlzdEl0ZW0gPSB7XG4gIG5hbWU6ICdmNy1saXN0LWl0ZW0nLFxuICBjb21wb25lbnRzOiB7XG4gICAgZjdMaXN0SXRlbUNvbnRlbnQsXG4gIH0sXG4gIHByb3BzOiBMaXN0SXRlbVByb3BzLFxuICByZW5kZXIoYykge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuXG4gICAgbGV0IGxpQ2hpbGRyZW47XG4gICAgbGV0IGxpbmtFbDtcbiAgICBsZXQgaXRlbUNvbnRlbnRFbDtcblxuICAgIGlmICghc2VsZi5zaW1wbGVMaXN0Q29tcHV0ZWQpIHtcbiAgICAgIC8vIEl0ZW0gQ29udGVudFxuICAgICAgaXRlbUNvbnRlbnRFbCA9IGMoJ2Y3LWxpc3QtaXRlbS1jb250ZW50Jywge1xuICAgICAgICBwcm9wczoge1xuICAgICAgICAgIHRpdGxlOiBzZWxmLnRpdGxlLFxuICAgICAgICAgIHRleHQ6IHNlbGYudGV4dCxcbiAgICAgICAgICBtZWRpYTogc2VsZi5tZWRpYSxcbiAgICAgICAgICBzdWJ0aXRsZTogc2VsZi5zdWJ0aXRsZSxcbiAgICAgICAgICBhZnRlcjogc2VsZi5hZnRlcixcbiAgICAgICAgICBoZWFkZXI6IHNlbGYuaGVhZGVyLFxuICAgICAgICAgIGZvb3Rlcjogc2VsZi5mb290ZXIsXG4gICAgICAgICAgYmFkZ2U6IHNlbGYuYmFkZ2UsXG4gICAgICAgICAgYmFkZ2VDb2xvcjogc2VsZi5iYWRnZUNvbG9yLFxuICAgICAgICAgIG1lZGlhTGlzdDogc2VsZi5tZWRpYUxpc3RDb21wdXRlZCxcbiAgICAgICAgICBhY2NvcmRpb25JdGVtOiBzZWxmLmFjY29yZGlvbkl0ZW0sXG5cbiAgICAgICAgICBjaGVja2JveDogc2VsZi5jaGVja2JveCxcbiAgICAgICAgICBjaGVja2VkOiBzZWxmLmNoZWNrZWQsXG4gICAgICAgICAgcmFkaW86IHNlbGYucmFkaW8sXG4gICAgICAgICAgbmFtZTogc2VsZi5uYW1lLFxuICAgICAgICAgIHZhbHVlOiBzZWxmLnZhbHVlLFxuICAgICAgICAgIHJlYWRvbmx5OiBzZWxmLnJlYWRvbmx5LFxuICAgICAgICAgIHJlcXVpcmVkOiBzZWxmLnJlcXVpcmVkLFxuICAgICAgICAgIGRpc2FibGVkOiBzZWxmLmRpc2FibGVkLFxuICAgICAgICAgIGl0ZW1JbnB1dDogc2VsZi5pdGVtSW5wdXQgfHwgc2VsZi5pdGVtSW5wdXRGb3JjZWQsXG4gICAgICAgICAgaXRlbUlucHV0V2l0aEluZm86IHNlbGYuaXRlbUlucHV0V2l0aEluZm8gfHwgc2VsZi5pdGVtSW5wdXRXaXRoSW5mb0ZvcmNlZCxcbiAgICAgICAgICBpbmxpbmVMYWJlbDogc2VsZi5pbmxpbmVMYWJlbCB8fCBzZWxmLmlubGluZUxhYmVsRm9yY2VkLFxuICAgICAgICB9LFxuICAgICAgICBvbjogKHNlbGYubGluayB8fCBzZWxmLmhyZWYgfHwgc2VsZi5hY2NvcmRpb25JdGVtIHx8IHNlbGYuc21hcnRTZWxlY3QpID8ge30gOiB7IGNsaWNrOiBzZWxmLm9uQ2xpY2ssIGNoYW5nZTogc2VsZi5vbkNoYW5nZSB9LFxuICAgICAgfSwgW1xuICAgICAgICBzZWxmLiRzbG90c1snY29udGVudC1zdGFydCddLFxuICAgICAgICBzZWxmLiRzbG90cy5jb250ZW50LFxuICAgICAgICBzZWxmLiRzbG90c1snY29udGVudC1lbmQnXSxcbiAgICAgICAgc2VsZi4kc2xvdHMubWVkaWEsXG4gICAgICAgIHNlbGYuJHNsb3RzWydpbm5lci1zdGFydCddLFxuICAgICAgICBzZWxmLiRzbG90cy5pbm5lcixcbiAgICAgICAgc2VsZi4kc2xvdHNbJ2lubmVyLWVuZCddLFxuICAgICAgICBzZWxmLiRzbG90c1snYWZ0ZXItc3RhcnQnXSxcbiAgICAgICAgc2VsZi4kc2xvdHMuYWZ0ZXIsXG4gICAgICAgIHNlbGYuJHNsb3RzWydhZnRlci1lbmQnXSxcbiAgICAgICAgc2VsZi4kc2xvdHMuaGVhZGVyLFxuICAgICAgICBzZWxmLiRzbG90cy5mb290ZXIsXG4gICAgICAgIHNlbGYuJHNsb3RzWydiZWZvcmUtdGl0bGUnXSxcbiAgICAgICAgc2VsZi4kc2xvdHMudGl0bGUsXG4gICAgICAgIHNlbGYuJHNsb3RzWydhZnRlci10aXRsZSddLFxuICAgICAgICBzZWxmLiRzbG90cy5zdWJ0aXRsZSxcbiAgICAgICAgc2VsZi4kc2xvdHMudGV4dCxcbiAgICAgICAgKHNlbGYuc3dpcGVvdXQgfHwgc2VsZi5hY2NvcmRpb25JdGVtID8gW10gOiBzZWxmLiRzbG90cy5kZWZhdWx0KSxcbiAgICAgIF0pO1xuXG4gICAgICAvLyBMaW5rXG4gICAgICBpZiAoc2VsZi5saW5rIHx8IHNlbGYuaHJlZiB8fCBzZWxmLmFjY29yZGlvbkl0ZW0gfHwgc2VsZi5zbWFydFNlbGVjdCkge1xuICAgICAgICBsaW5rRWwgPSBjKCdhJywge1xuICAgICAgICAgIGF0dHJzOiBVdGlscy5leHRlbmQoXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGhyZWY6IHNlbGYubGluayA9PT0gdHJ1ZSB8fCBzZWxmLmFjY29yZGlvbkl0ZW0gfHwgc2VsZi5zbWFydFNlbGVjdCA/ICcjJyA6IHNlbGYubGluayB8fCBzZWxmLmhyZWYsXG4gICAgICAgICAgICAgIHRhcmdldDogc2VsZi50YXJnZXQsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgTWl4aW5zLmxpbmtSb3V0ZXJBdHRycyhzZWxmKSxcbiAgICAgICAgICAgIE1peGlucy5saW5rQWN0aW9uc0F0dHJzKHNlbGYpXG4gICAgICAgICAgKSxcbiAgICAgICAgICBjbGFzczogVXRpbHMuZXh0ZW5kKFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAnaXRlbS1saW5rJzogdHJ1ZSxcbiAgICAgICAgICAgICAgJ25vLWZhc3RjbGljayc6IHNlbGYubm9GYXN0Y2xpY2sgfHwgc2VsZi5ub0Zhc3RDbGljayxcbiAgICAgICAgICAgICAgJ3NtYXJ0LXNlbGVjdCc6IHNlbGYuc21hcnRTZWxlY3QsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgTWl4aW5zLmxpbmtSb3V0ZXJDbGFzc2VzKHNlbGYpLFxuICAgICAgICAgICAgTWl4aW5zLmxpbmtBY3Rpb25zQ2xhc3NlcyhzZWxmKVxuICAgICAgICAgICksXG4gICAgICAgICAgb246IHtcbiAgICAgICAgICAgIGNsaWNrOiBzZWxmLm9uQ2xpY2ssXG4gICAgICAgICAgfSxcbiAgICAgICAgfSwgW2l0ZW1Db250ZW50RWxdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc2VsZi5kaXZpZGVyIHx8IHNlbGYuZ3JvdXBUaXRsZSkge1xuICAgICAgbGlDaGlsZHJlbiA9IFtjKCdzcGFuJywgc2VsZi4kc2xvdHMuZGVmYXVsdCB8fCBzZWxmLnRpdGxlKV07XG4gICAgfSBlbHNlIGlmIChzZWxmLnNpbXBsZUxpc3RDb21wdXRlZCkge1xuICAgICAgbGlDaGlsZHJlbiA9IFtzZWxmLnRpdGxlLCBzZWxmLiRzbG90cy5kZWZhdWx0XTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbGlua0l0ZW1FbCA9IChzZWxmLmxpbmsgfHwgc2VsZi5ocmVmIHx8IHNlbGYuc21hcnRTZWxlY3QgfHwgc2VsZi5hY2NvcmRpb25JdGVtKSA/IGxpbmtFbCA6IGl0ZW1Db250ZW50RWw7XG4gICAgICBpZiAoc2VsZi5zd2lwZW91dCkge1xuICAgICAgICBsaUNoaWxkcmVuID0gW2MoJ2RpdicsIHsgY2xhc3M6IHsgJ3N3aXBlb3V0LWNvbnRlbnQnOiB0cnVlIH0gfSwgW2xpbmtJdGVtRWxdKV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaUNoaWxkcmVuID0gW2xpbmtJdGVtRWxdO1xuICAgICAgfVxuICAgICAgaWYgKHNlbGYuc29ydGFibGVDb21wdXRlZCkge1xuICAgICAgICBsaUNoaWxkcmVuLnB1c2goYygnZGl2JywgeyBjbGFzczogeyAnc29ydGFibGUtaGFuZGxlcic6IHRydWUgfSB9KSk7XG4gICAgICB9XG4gICAgICBpZiAoc2VsZi5zd2lwZW91dCB8fCBzZWxmLmFjY29yZGlvbkl0ZW0pIHtcbiAgICAgICAgbGlDaGlsZHJlbi5wdXNoKHNlbGYuJHNsb3RzLmRlZmF1bHQpO1xuICAgICAgfVxuICAgICAgbGlDaGlsZHJlbi51bnNoaWZ0KHNlbGYuJHNsb3RzWydyb290LXN0YXJ0J10pO1xuICAgICAgbGlDaGlsZHJlbi5wdXNoKHNlbGYuJHNsb3RzLnJvb3QpO1xuICAgICAgbGlDaGlsZHJlbi5wdXNoKHNlbGYuJHNsb3RzWydyb290LWVuZCddKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYyhcbiAgICAgICdsaScsXG4gICAgICB7XG4gICAgICAgIGNsYXNzOiBVdGlscy5leHRlbmQoXG4gICAgICAgICAge1xuICAgICAgICAgICAgJ2l0ZW0tZGl2aWRlcic6IHNlbGYuZGl2aWRlcixcbiAgICAgICAgICAgICdsaXN0LWdyb3VwLXRpdGxlJzogc2VsZi5ncm91cFRpdGxlLFxuICAgICAgICAgICAgJ21lZGlhLWl0ZW0nOiBzZWxmLm1lZGlhSXRlbSxcbiAgICAgICAgICAgIHN3aXBlb3V0OiBzZWxmLnN3aXBlb3V0LFxuICAgICAgICAgICAgJ2FjY29yZGlvbi1pdGVtJzogc2VsZi5hY2NvcmRpb25JdGVtLFxuICAgICAgICAgICAgJ2FjY29yZGlvbi1pdGVtLW9wZW5lZCc6IHNlbGYuYWNjb3JkaW9uSXRlbU9wZW5lZCxcbiAgICAgICAgICB9LFxuICAgICAgICAgIE1peGlucy5jb2xvckNsYXNzZXMoc2VsZilcbiAgICAgICAgKSxcbiAgICAgICAgb246IHtcbiAgICAgICAgICAnc3dpcGVvdXQ6b3Blbic6IHNlbGYub25Td2lwZW91dE9wZW4sXG4gICAgICAgICAgJ3N3aXBlb3V0Om9wZW5lZCc6IHNlbGYub25Td2lwZW91dE9wZW5lZCxcbiAgICAgICAgICAnc3dpcGVvdXQ6Y2xvc2UnOiBzZWxmLm9uU3dpcGVvdXRDbG9zZSxcbiAgICAgICAgICAnc3dpcGVvdXQ6Y2xvc2VkJzogc2VsZi5vblN3aXBlb3V0Q2xvc2VkLFxuICAgICAgICAgICdzd2lwZW91dDpkZWxldGUnOiBzZWxmLm9uU3dpcGVvdXREZWxldGUsXG4gICAgICAgICAgJ3N3aXBlb3V0OmRlbGV0ZWQnOiBzZWxmLm9uU3dpcGVvdXREZWxldGVkLFxuICAgICAgICAgIHN3aXBlb3V0OiBzZWxmLm9uU3dpcGVvdXQsXG4gICAgICAgICAgJ2FjY29yZGlvbjpvcGVuJzogc2VsZi5vbkFjY09wZW4sXG4gICAgICAgICAgJ2FjY29yZGlvbjpvcGVuZWQnOiBzZWxmLm9uQWNjT3BlbmVkLFxuICAgICAgICAgICdhY2NvcmRpb246Y2xvc2UnOiBzZWxmLm9uQWNjQ2xvc2UsXG4gICAgICAgICAgJ2FjY29yZGlvbjpjbG9zZWQnOiBzZWxmLm9uQWNjQ2xvc2VkLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICAgIGxpQ2hpbGRyZW5cbiAgICApO1xuICB9LFxuICBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBpdGVtSW5wdXRGb3JjZWQ6IGZhbHNlLFxuICAgICAgaW5saW5lTGFiZWxGb3JjZWQ6IGZhbHNlLFxuICAgICAgaXRlbUlucHV0V2l0aEluZm9Gb3JjZWQ6IGZhbHNlLFxuICAgIH07XG4gIH0sXG4gIGNvbXB1dGVkOiB7XG4gICAgc29ydGFibGVDb21wdXRlZCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNvcnRhYmxlIHx8IHRoaXMuJHBhcmVudC5zb3J0YWJsZSB8fCB0aGlzLiRwYXJlbnQuc29ydGFibGVDb21wdXRlZDtcbiAgICB9LFxuICAgIG1lZGlhTGlzdENvbXB1dGVkKCkge1xuICAgICAgcmV0dXJuIHRoaXMubWVkaWFMaXN0IHx8IHRoaXMubWVkaWFJdGVtIHx8IHRoaXMuJHBhcmVudC5tZWRpYUxpc3QgfHwgdGhpcy4kcGFyZW50Lm1lZGlhTGlzdENvbXB1dGVkO1xuICAgIH0sXG4gICAgc2ltcGxlTGlzdENvbXB1dGVkKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2ltcGxlTGlzdCB8fCB0aGlzLiRwYXJlbnQuc2ltcGxlTGlzdCB8fCAodGhpcy4kcGFyZW50LiRwYXJlbnQgJiYgdGhpcy4kcGFyZW50LnNpbXBsZUxpc3QpO1xuICAgIH0sXG4gIH0sXG4gIGJlZm9yZURlc3Ryb3koKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgaWYgKHNlbGYuc21hcnRTZWxlY3QgJiYgc2VsZi5mN1NtYXJ0U2VsZWN0KSB7XG4gICAgICBzZWxmLmY3U21hcnRTZWxlY3QuZGVzdHJveSgpO1xuICAgIH1cbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIG9uRjdSZWFkeShmNykge1xuICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICBpZiAoIXNlbGYuc21hcnRTZWxlY3QpIHJldHVybjtcbiAgICAgIGNvbnN0IHNtYXJ0U2VsZWN0UGFyYW1zID0gVXRpbHMuZXh0ZW5kKHsgZWw6IHNlbGYuJGVsLnF1ZXJ5U2VsZWN0b3IoJ2Euc21hcnQtc2VsZWN0JykgfSwgKHNlbGYuc21hcnRTZWxlY3RQYXJhbXMgfHwge30pKTtcbiAgICAgIHNlbGYuZjdTbWFydFNlbGVjdCA9IGY3LnNtYXJ0U2VsZWN0LmNyZWF0ZShzbWFydFNlbGVjdFBhcmFtcyk7XG4gICAgfSxcbiAgICBvbkNsaWNrKGV2ZW50KSB7XG4gICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgIGlmIChzZWxmLnNtYXJ0U2VsZWN0ICYmIHNlbGYuZjdTbWFydFNlbGVjdCkge1xuICAgICAgICBzZWxmLmY3U21hcnRTZWxlY3Qub3BlbigpO1xuICAgICAgfVxuICAgICAgaWYgKGV2ZW50LnRhcmdldC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgIT09ICdpbnB1dCcpIHtcbiAgICAgICAgc2VsZi4kZW1pdCgnY2xpY2snLCBldmVudCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBvblN3aXBlb3V0RGVsZXRlZChldmVudCkge1xuICAgICAgdGhpcy4kZW1pdCgnc3dpcGVvdXQ6ZGVsZXRlZCcsIGV2ZW50KTtcbiAgICB9LFxuICAgIG9uU3dpcGVvdXREZWxldGUoZXZlbnQpIHtcbiAgICAgIHRoaXMuJGVtaXQoJ3N3aXBlb3V0OmRlbGV0ZScsIGV2ZW50KTtcbiAgICB9LFxuICAgIG9uU3dpcGVvdXRDbG9zZShldmVudCkge1xuICAgICAgdGhpcy4kZW1pdCgnc3dpcGVvdXQ6Y2xvc2UnLCBldmVudCk7XG4gICAgfSxcbiAgICBvblN3aXBlb3V0Q2xvc2VkKGV2ZW50KSB7XG4gICAgICB0aGlzLiRlbWl0KCdzd2lwZW91dDpjbG9zZWQnLCBldmVudCk7XG4gICAgfSxcbiAgICBvblN3aXBlb3V0T3BlbihldmVudCkge1xuICAgICAgdGhpcy4kZW1pdCgnc3dpcGVvdXQ6b3BlbicsIGV2ZW50KTtcbiAgICB9LFxuICAgIG9uU3dpcGVvdXRPcGVuZWQoZXZlbnQpIHtcbiAgICAgIHRoaXMuJGVtaXQoJ3N3aXBlb3V0Om9wZW5lZCcsIGV2ZW50KTtcbiAgICB9LFxuICAgIG9uU3dpcGVvdXQoZXZlbnQpIHtcbiAgICAgIHRoaXMuJGVtaXQoJ3N3aXBlb3V0JywgZXZlbnQpO1xuICAgIH0sXG4gICAgb25BY2NDbG9zZShldmVudCkge1xuICAgICAgdGhpcy4kZW1pdCgnYWNjb3JkaW9uOmNsb3NlJywgZXZlbnQpO1xuICAgIH0sXG4gICAgb25BY2NDbG9zZWQoZXZlbnQpIHtcbiAgICAgIHRoaXMuJGVtaXQoJ2FjY29yZGlvbjpjbG9zZWQnLCBldmVudCk7XG4gICAgfSxcbiAgICBvbkFjY09wZW4oZXZlbnQpIHtcbiAgICAgIHRoaXMuJGVtaXQoJ2FjY29yZGlvbjpvcGVuJywgZXZlbnQpO1xuICAgIH0sXG4gICAgb25BY2NPcGVuZWQoZXZlbnQpIHtcbiAgICAgIHRoaXMuJGVtaXQoJ2FjY29yZGlvbjpvcGVuZWQnLCBldmVudCk7XG4gICAgfSxcbiAgICBvbkNoYW5nZShldmVudCkge1xuICAgICAgdGhpcy4kZW1pdCgnY2hhbmdlJywgZXZlbnQpO1xuICAgIH0sXG4gICAgb25JbnB1dChldmVudCkge1xuICAgICAgdGhpcy4kZW1pdCgnaW5wdXQnLCBldmVudCk7XG4gICAgfSxcbiAgfSxcbn07XG5cbmNvbnN0IExpc3RQcm9wcyA9IFV0aWxzLmV4dGVuZChcbiAge1xuICAgIGluc2V0OiBCb29sZWFuLFxuICAgIHRhYmxldEluc2V0OiBCb29sZWFuLFxuICAgIG1lZGlhTGlzdDogQm9vbGVhbixcbiAgICBzb3J0YWJsZTogQm9vbGVhbixcbiAgICBzb3J0YWJsZUVuYWJsZWQ6IEJvb2xlYW4sXG4gICAgYWNjb3JkaW9uTGlzdDogQm9vbGVhbixcbiAgICBjb250YWN0c0xpc3Q6IEJvb2xlYW4sXG4gICAgc2ltcGxlTGlzdDogQm9vbGVhbixcbiAgICBsaW5rc0xpc3Q6IEJvb2xlYW4sXG5cbiAgICBub0hhaXJsaW5lczogQm9vbGVhbixcbiAgICBub0hhaXJsaW5lc0JldHdlZW46IEJvb2xlYW4sXG4gICAgbm9IYWlybGluZXNNZDogQm9vbGVhbixcbiAgICBub0hhaXJsaW5lc0JldHdlZW5NZDogQm9vbGVhbixcbiAgICBub0hhaXJsaW5lc0lvczogQm9vbGVhbixcbiAgICBub0hhaXJsaW5lc0JldHdlZW5Jb3M6IEJvb2xlYW4sXG5cbiAgICAvLyBUYWJcbiAgICB0YWI6IEJvb2xlYW4sXG4gICAgdGFiQWN0aXZlOiBCb29sZWFuLFxuXG4gICAgLy8gRm9ybVxuICAgIGZvcm06IEJvb2xlYW4sXG4gICAgZm9ybVN0b3JlRGF0YTogQm9vbGVhbixcbiAgICBpbmxpbmVMYWJlbHM6IEJvb2xlYW4sXG5cbiAgICAvLyBWaXJ0dWFsIExpc3RcbiAgICB2aXJ0dWFsTGlzdDogQm9vbGVhbixcbiAgICB2aXJ0dWFsTGlzdFBhcmFtczogT2JqZWN0LFxuICB9LFxuICBNaXhpbnMuY29sb3JQcm9wc1xuKTtcblxudmFyIGY3TGlzdCA9IHtcbiAgbmFtZTogJ2Y3LWxpc3QnLFxuICBwcm9wczogTGlzdFByb3BzLFxuICBiZWZvcmVEZXN0cm95KCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIGlmICghKHNlbGYudmlydHVhbExpc3QgJiYgc2VsZi5mN1ZpcnR1YWxMaXN0KSkgcmV0dXJuO1xuICAgIGlmIChzZWxmLmY3VmlydHVhbExpc3QuZGVzdHJveSkgc2VsZi5mN1ZpcnR1YWxMaXN0LmRlc3Ryb3koKTtcbiAgfSxcbiAgcmVuZGVyKGMpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcblxuICAgIGNvbnN0IGxpc3RDaGlsZHJlbiA9IFtdO1xuICAgIGNvbnN0IHVsQ2hpbGRyZW4gPSBzZWxmLiRzbG90cy5saXN0IHx8IFtdO1xuXG4gICAgaWYgKHNlbGYuJHNsb3RzLmRlZmF1bHQpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VsZi4kc2xvdHMuZGVmYXVsdC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBjb25zdCB0YWcgPSBzZWxmLiRzbG90cy5kZWZhdWx0W2ldLnRhZztcbiAgICAgICAgaWYgKHRhZyAmJiAhKHRhZyA9PT0gJ2xpJyB8fCB0YWcuaW5kZXhPZignbGlzdC1pdGVtJykgPj0gMCB8fCB0YWcuaW5kZXhPZignbGlzdC1idXR0b24nKSA+PSAwKSkge1xuICAgICAgICAgIGxpc3RDaGlsZHJlbi5wdXNoKHNlbGYuJHNsb3RzLmRlZmF1bHRbaV0pO1xuICAgICAgICB9IGVsc2UgaWYgKHRhZykge1xuICAgICAgICAgIHVsQ2hpbGRyZW4ucHVzaChzZWxmLiRzbG90cy5kZWZhdWx0W2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBibG9ja0VsID0gYyhcbiAgICAgIHNlbGYuZm9ybSA/ICdmb3JtJyA6ICdkaXYnLFxuICAgICAge1xuICAgICAgICBzdGF0aWNDbGFzczogJ2xpc3QnLFxuICAgICAgICBjbGFzczogVXRpbHMuZXh0ZW5kKFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGluc2V0OiBzZWxmLmluc2V0LFxuICAgICAgICAgICAgJ3RhYmxldC1pbnNldCc6IHNlbGYudGFibGV0SW5zZXQsXG4gICAgICAgICAgICAnbWVkaWEtbGlzdCc6IHNlbGYubWVkaWFMaXN0LFxuICAgICAgICAgICAgJ3NpbXBsZS1saXN0Jzogc2VsZi5zaW1wbGVMaXN0LFxuICAgICAgICAgICAgJ2xpbmtzLWxpc3QnOiBzZWxmLmxpbmtzTGlzdCxcbiAgICAgICAgICAgIHNvcnRhYmxlOiBzZWxmLnNvcnRhYmxlLFxuICAgICAgICAgICAgJ2FjY29yZGlvbi1saXN0Jzogc2VsZi5hY2NvcmRpb25MaXN0LFxuICAgICAgICAgICAgJ2NvbnRhY3RzLWxpc3QnOiBzZWxmLmNvbnRhY3RzTGlzdCxcbiAgICAgICAgICAgICd2aXJ0dWFsLWxpc3QnOiBzZWxmLnZpcnR1YWxMaXN0LFxuICAgICAgICAgICAgJ3NvcnRhYmxlLWVuYWJsZWQnOiBzZWxmLnNvcnRhYmxlRW5hYmxlZCxcbiAgICAgICAgICAgIHRhYjogc2VsZi50YWIsXG4gICAgICAgICAgICAndGFiLWFjdGl2ZSc6IHNlbGYudGFiQWN0aXZlLFxuICAgICAgICAgICAgJ25vLWhhaXJsaW5lcyc6IHNlbGYubm9IYWlybGluZXMsXG4gICAgICAgICAgICAnbm8taGFpcmxpbmVzLWJldHdlZW4nOiBzZWxmLm5vSGFpcmxpbmVzQmV0d2VlbixcbiAgICAgICAgICAgICduby1oYWlybGluZXMtbWQnOiBzZWxmLm5vSGFpcmxpbmVzTWQsXG4gICAgICAgICAgICAnbm8taGFpcmxpbmVzLWJldHdlZW4tbWQnOiBzZWxmLm5vSGFpcmxpbmVzQmV0d2Vlbk1kLFxuICAgICAgICAgICAgJ25vLWhhaXJsaW5lcy1pb3MnOiBzZWxmLm5vSGFpcmxpbmVzSW9zLFxuICAgICAgICAgICAgJ25vLWhhaXJsaW5lcy1iZXR3ZWVuLWlvcyc6IHNlbGYubm9IYWlybGluZXNCZXR3ZWVuSW9zLFxuICAgICAgICAgICAgJ2Zvcm0tc3RvcmUtZGF0YSc6IHNlbGYuZm9ybVN0b3JlRGF0YSxcbiAgICAgICAgICAgICdpbmxpbmUtbGFiZWxzJzogc2VsZi5pbmxpbmVMYWJlbHMsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBNaXhpbnMuY29sb3JDbGFzc2VzKHNlbGYpXG4gICAgICAgICksXG4gICAgICAgIG9uOiB7XG4gICAgICAgICAgJ3NvcnRhYmxlOmVuYWJsZSc6IHNlbGYub25Tb3J0YWJsZUVuYWJsZSxcbiAgICAgICAgICAnc29ydGFibGU6ZGlzYWJsZSc6IHNlbGYub25Tb3J0YWJsZURpc2FibGUsXG4gICAgICAgICAgJ3NvcnRhYmxlOnNvcnQnOiBzZWxmLm9uU29ydGFibGVTb3J0LFxuICAgICAgICAgICd0YWI6c2hvdyc6IHNlbGYub25UYWJTaG93LFxuICAgICAgICAgICd0YWI6aGlkZSc6IHNlbGYub25UYWJIaWRlLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICAgIFtcbiAgICAgICAgdWxDaGlsZHJlbi5sZW5ndGggPiAwID9cbiAgICAgICAgICBbXG4gICAgICAgICAgICBzZWxmLiRzbG90c1snYmVmb3JlLWxpc3QnXSxcbiAgICAgICAgICAgIGMoJ3VsJywge30sIHVsQ2hpbGRyZW4pLFxuICAgICAgICAgICAgc2VsZi4kc2xvdHNbJ2FmdGVyLWxpc3QnXSxcbiAgICAgICAgICAgIGxpc3RDaGlsZHJlbixcbiAgICAgICAgICBdIDpcbiAgICAgICAgICBbXG4gICAgICAgICAgICBzZWxmLiRzbG90c1snYmVmb3JlLWxpc3QnXSxcbiAgICAgICAgICAgIGxpc3RDaGlsZHJlbixcbiAgICAgICAgICAgIHNlbGYuJHNsb3RzWydhZnRlci1saXN0J10sXG4gICAgICAgICAgXSxcbiAgICAgIF1cbiAgICApO1xuICAgIHJldHVybiBibG9ja0VsO1xuICB9LFxuICBtZXRob2RzOiB7XG4gICAgb25Tb3J0YWJsZUVuYWJsZShldmVudCkge1xuICAgICAgdGhpcy4kZW1pdCgnc29ydGFibGU6ZW5hYmxlJywgZXZlbnQpO1xuICAgIH0sXG4gICAgb25Tb3J0YWJsZURpc2FibGUoZXZlbnQpIHtcbiAgICAgIHRoaXMuJGVtaXQoJ3NvcnRhYmxlOmRpc2FibGUnLCBldmVudCk7XG4gICAgfSxcbiAgICBvblNvcnRhYmxlU29ydChldmVudCkge1xuICAgICAgdGhpcy4kZW1pdCgnc29ydGFibGU6c29ydCcsIGV2ZW50LCBldmVudC5kZXRhaWwpO1xuICAgIH0sXG4gICAgb25UYWJTaG93KGUpIHtcbiAgICAgIHRoaXMuJGVtaXQoJ3RhYjpzaG93JywgZSk7XG4gICAgfSxcbiAgICBvblRhYkhpZGUoZSkge1xuICAgICAgdGhpcy4kZW1pdCgndGFiOmhpZGUnLCBlKTtcbiAgICB9LFxuICAgIG9uRjdSZWFkeShmNykge1xuICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAvLyBJbml0IFZpcnR1YWwgTGlzdFxuICAgICAgaWYgKCFzZWxmLnZpcnR1YWxMaXN0KSByZXR1cm47XG4gICAgICBjb25zdCAkJCA9IHNlbGYuJCQ7XG4gICAgICBjb25zdCAkZWwgPSAkJChzZWxmLiRlbCk7XG4gICAgICBjb25zdCB0ZW1wbGF0ZVNjcmlwdCA9ICRlbC5maW5kKCdzY3JpcHQnKTtcbiAgICAgIGxldCB0ZW1wbGF0ZSA9IHRlbXBsYXRlU2NyaXB0Lmh0bWwoKTtcbiAgICAgIGlmICghdGVtcGxhdGUgJiYgdGVtcGxhdGVTY3JpcHQubGVuZ3RoID4gMCkge1xuICAgICAgICB0ZW1wbGF0ZSA9IHRlbXBsYXRlU2NyaXB0WzBdLm91dGVySFRNTDtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgIHRlbXBsYXRlID0gL1xcPHNjcmlwdCB0eXBlPVwidGV4dFxcL3RlbXBsYXRlN1wiXFw+KC4qKTxcXC9zY3JpcHQ+Ly5leGVjKHRlbXBsYXRlKVsxXTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHZsUGFyYW1zID0gc2VsZi52aXJ0dWFsTGlzdFBhcmFtcyB8fCB7fTtcbiAgICAgIGlmICghdGVtcGxhdGUgJiYgIXZsUGFyYW1zLnJlbmRlckl0ZW0gJiYgIXZsUGFyYW1zLml0ZW1UZW1wbGF0ZSAmJiAhdmxQYXJhbXMucmVuZGVyRXh0ZXJuYWwpIHJldHVybjtcbiAgICAgIGlmICh0ZW1wbGF0ZSkgdGVtcGxhdGUgPSBzZWxmLiR0Ny5jb21waWxlKHRlbXBsYXRlKTtcblxuICAgICAgc2VsZi5mN1ZpcnR1YWxMaXN0ID0gZjcudmlydHVhbExpc3QuY3JlYXRlKFV0aWxzLmV4dGVuZChcbiAgICAgICAge1xuICAgICAgICAgIGVsOiBzZWxmLiRlbCxcbiAgICAgICAgICBpdGVtVGVtcGxhdGU6IHRlbXBsYXRlLFxuICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICBpdGVtQmVmb3JlSW5zZXJ0KGl0ZW1FbCwgaXRlbSkge1xuICAgICAgICAgICAgICBjb25zdCB2bCA9IHRoaXM7XG4gICAgICAgICAgICAgIHNlbGYuJGVtaXQoJ3ZpcnR1YWw6aXRlbWJlZm9yZWluc2VydCcsIHZsLCBpdGVtRWwsIGl0ZW0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJlZm9yZUNsZWFyKGZyYWdtZW50KSB7XG4gICAgICAgICAgICAgIGNvbnN0IHZsID0gdGhpcztcbiAgICAgICAgICAgICAgc2VsZi4kZW1pdCgndmlydHVhbDpiZWZvcmVjbGVhcicsIHZsLCBmcmFnbWVudCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaXRlbXNCZWZvcmVJbnNlcnQoZnJhZ21lbnQpIHtcbiAgICAgICAgICAgICAgY29uc3QgdmwgPSB0aGlzO1xuICAgICAgICAgICAgICBzZWxmLiRlbWl0KCd2aXJ0dWFsOml0ZW1zYmVmb3JlaW5zZXJ0JywgdmwsIGZyYWdtZW50KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpdGVtc0FmdGVySW5zZXJ0KGZyYWdtZW50KSB7XG4gICAgICAgICAgICAgIGNvbnN0IHZsID0gdGhpcztcbiAgICAgICAgICAgICAgc2VsZi4kZW1pdCgndmlydHVhbDppdGVtc2FmdGVyaW5zZXJ0JywgdmwsIGZyYWdtZW50KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgdmxQYXJhbXNcbiAgICAgICkpO1xuICAgIH0sXG4gIH0sXG59O1xuXG52YXIgZjdMb2dpblNjcmVlblRpdGxlID0ge3JlbmRlcjogZnVuY3Rpb24oKXt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtyZXR1cm4gX2MoJ2Rpdicse3N0YXRpY0NsYXNzOlwibG9naW4tc2NyZWVuLXRpdGxlXCIsY2xhc3M6X3ZtLmNsYXNzZXN9LFtfdm0uX3QoXCJkZWZhdWx0XCIpXSwyKX0sc3RhdGljUmVuZGVyRm5zOiBbXSxcbiAgbmFtZTogJ2Y3LWxvZ2luLXNjcmVlbi10aXRsZScsXG4gIHByb3BzOiBNaXhpbnMuY29sb3JQcm9wcyxcbiAgY29tcHV0ZWQ6IHtcbiAgICBjbGFzc2VzKCkge1xuICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICByZXR1cm4gTWl4aW5zLmNvbG9yQ2xhc3NlcyhzZWxmKTtcbiAgICB9LFxuICB9LFxufTtcblxuY29uc3QgTG9naW5TY3JlZW5Qcm9wcyA9IFV0aWxzLmV4dGVuZChcbiAge1xuICAgIG9wZW5lZDogQm9vbGVhbixcbiAgfSxcbiAgTWl4aW5zLmNvbG9yUHJvcHNcbik7XG5cbnZhciBmN0xvZ2luU2NyZWVuID0ge1xuICBuYW1lOiAnZjctbG9naW4tc2NyZWVuJyxcbiAgcmVuZGVyKGMpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gYygnZGl2Jywge1xuICAgICAgc3RhdGljQ2xhc3M6ICdsb2dpbi1zY3JlZW4nLFxuICAgICAgY2xhc3M6IHNlbGYuY2xhc3NlcyxcbiAgICAgIG9uOiB7XG4gICAgICAgICdsb2dpbnNjcmVlbjpvcGVuJzogc2VsZi5vbk9wZW4sXG4gICAgICAgICdsb2dpbnNjcmVlbjpvcGVuZWQnOiBzZWxmLm9uT3BlbmVkLFxuICAgICAgICAnbG9naW5zY3JlZW46Y2xvc2UnOiBzZWxmLm9uQ2xvc2UsXG4gICAgICAgICdsb2dpbnNjcmVlbjpjbG9zZWQnOiBzZWxmLm9uQ2xvc2VkLFxuICAgICAgfSxcbiAgICB9LCBzZWxmLiRzbG90cy5kZWZhdWx0KTtcbiAgfSxcbiAgd2F0Y2g6IHtcbiAgICBvcGVuZWQob3BlbmVkKSB7XG4gICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgIGlmICghc2VsZi5mN0xvZ2luU2NyZWVuKSByZXR1cm47XG4gICAgICBpZiAob3BlbmVkKSB7XG4gICAgICAgIHNlbGYuZjdMb2dpblNjcmVlbi5vcGVuKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxmLmY3TG9naW5TY3JlZW4uY2xvc2UoKTtcbiAgICAgIH1cbiAgICB9LFxuICB9LFxuICBwcm9wczogTG9naW5TY3JlZW5Qcm9wcyxcbiAgY29tcHV0ZWQ6IHtcbiAgICBjbGFzc2VzKCkge1xuICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICByZXR1cm4gTWl4aW5zLmNvbG9yQ2xhc3NlcyhzZWxmKTtcbiAgICB9LFxuICB9LFxuICBiZWZvcmVEZXN0cm95KCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIGlmIChzZWxmLmY3TG9naW5TY3JlZW4pIHNlbGYuZjdMb2dpblNjcmVlbi5kZXN0cm95KCk7XG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBvbk9wZW4oZXZlbnQpIHtcbiAgICAgIHRoaXMuJGVtaXQoJ2xvZ2luc2NyZWVuOm9wZW4nLCBldmVudCk7XG4gICAgfSxcbiAgICBvbk9wZW5lZChldmVudCkge1xuICAgICAgdGhpcy4kZW1pdCgnbG9naW5zY3JlZW46b3BlbmVkJywgZXZlbnQpO1xuICAgIH0sXG4gICAgb25DbG9zZShldmVudCkge1xuICAgICAgdGhpcy4kZW1pdCgnbG9naW5zY3JlZW46Y2xvc2UnLCBldmVudCk7XG4gICAgfSxcbiAgICBvbkNsb3NlZChldmVudCkge1xuICAgICAgdGhpcy4kZW1pdCgnbG9naW5zY3JlZW46Y2xvc2VkJywgZXZlbnQpO1xuICAgIH0sXG4gICAgb3BlbihhbmltYXRlKSB7XG4gICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgIGlmICghc2VsZi4kZjcpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gc2VsZi4kZjcubG9naW5TY3JlZW4ub3BlbihzZWxmLiRlbCwgYW5pbWF0ZSk7XG4gICAgfSxcbiAgICBjbG9zZShhbmltYXRlKSB7XG4gICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgIGlmICghc2VsZi4kZjcpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gc2VsZi4kZjcubG9naW5TY3JlZW4uY2xvc2Uoc2VsZi4kZWwsIGFuaW1hdGUpO1xuICAgIH0sXG4gICAgb25GN1JlYWR5KCkge1xuICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICBzZWxmLmY3TG9naW5TY3JlZW4gPSBzZWxmLiRmNy5sb2dpblNjcmVlbi5jcmVhdGUoe1xuICAgICAgICBlbDogc2VsZi4kZWwsXG4gICAgICB9KTtcbiAgICAgIGlmIChzZWxmLm9wZW5lZCkge1xuICAgICAgICBzZWxmLmY3TG9naW5TY3JlZW4ub3BlbihmYWxzZSk7XG4gICAgICB9XG4gICAgfSxcbiAgfSxcbn07XG5cbmNvbnN0IE1lc3NhZ2VQcm9wcyA9IFV0aWxzLmV4dGVuZChcbiAge1xuICAgIHRleHQ6IFN0cmluZyxcbiAgICBuYW1lOiBTdHJpbmcsXG4gICAgYXZhdGFyOiBTdHJpbmcsXG4gICAgdHlwZToge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogJ3NlbnQnLFxuICAgIH0sXG4gICAgaW1hZ2U6IFN0cmluZyxcbiAgICBoZWFkZXI6IFN0cmluZyxcbiAgICBmb290ZXI6IFN0cmluZyxcbiAgICB0ZXh0SGVhZGVyOiBTdHJpbmcsXG4gICAgdGV4dEZvb3RlcjogU3RyaW5nLFxuICAgIGZpcnN0OiBCb29sZWFuLFxuICAgIGxhc3Q6IEJvb2xlYW4sXG4gICAgdGFpbDogQm9vbGVhbixcbiAgICBzYW1lTmFtZTogQm9vbGVhbixcbiAgICBzYW1lSGVhZGVyOiBCb29sZWFuLFxuICAgIHNhbWVGb290ZXI6IEJvb2xlYW4sXG4gICAgc2FtZUF2YXRhcjogQm9vbGVhbixcbiAgICB0eXBpbmc6IEJvb2xlYW4sXG4gIH0sXG4gIE1peGlucy5jb2xvclByb3BzXG4pO1xudmFyIGY3TWVzc2FnZSA9IHtyZW5kZXI6IGZ1bmN0aW9uKCl7dmFyIF92bT10aGlzO3ZhciBfaD1fdm0uJGNyZWF0ZUVsZW1lbnQ7dmFyIF9jPV92bS5fc2VsZi5fY3x8X2g7cmV0dXJuIF9jKCdkaXYnLHtzdGF0aWNDbGFzczpcIm1lc3NhZ2VcIixjbGFzczpfdm0uY2xhc3Nlcyxvbjp7XCJjbGlja1wiOl92bS5vbkNsaWNrfX0sW192bS5fdChcInN0YXJ0XCIpLF92bS5fdihcIiBcIiksKF92bS5hdmF0YXIgfHwgX3ZtLiRzbG90cy5hdmF0YXIpP19jKCdkaXYnLHtzdGF0aWNDbGFzczpcIm1lc3NhZ2UtYXZhdGFyXCIsc3R5bGU6KHsnYmFja2dyb3VuZC1pbWFnZSc6IF92bS5hdmF0YXIgJiYgJ3VybCgnICsgX3ZtLmF2YXRhciArICcpJ30pLG9uOntcImNsaWNrXCI6X3ZtLm9uQXZhdGFyQ2xpY2t9fSk6X3ZtLl9lKCksX3ZtLl92KFwiIFwiKSxfYygnZGl2Jyx7c3RhdGljQ2xhc3M6XCJtZXNzYWdlLWNvbnRlbnRcIn0sW192bS5fdChcImNvbnRlbnQtc3RhcnRcIiksX3ZtLl92KFwiIFwiKSwoX3ZtLm5hbWUgfHwgX3ZtLiRzbG90cy5uYW1lKT9fYygnZGl2Jyx7c3RhdGljQ2xhc3M6XCJtZXNzYWdlLW5hbWVcIixvbjp7XCJjbGlja1wiOl92bS5vbk5hbWVDbGlja319LFtfdm0uX3QoXCJuYW1lXCIsW192bS5fdihfdm0uX3MoX3ZtLm5hbWUpKV0pXSwyKTpfdm0uX2UoKSxfdm0uX3YoXCIgXCIpLChfdm0uaGVhZGVyIHx8IF92bS4kc2xvdHMuaGVhZGVyKT9fYygnZGl2Jyx7c3RhdGljQ2xhc3M6XCJtZXNzYWdlLWhlYWRlclwiLG9uOntcImNsaWNrXCI6X3ZtLm9uSGVhZGVyQ2xpY2t9fSxbX3ZtLl90KFwiaGVhZGVyXCIsW192bS5fdihfdm0uX3MoX3ZtLmhlYWRlcikpXSldLDIpOl92bS5fZSgpLF92bS5fdihcIiBcIiksX2MoJ2Rpdicse3N0YXRpY0NsYXNzOlwibWVzc2FnZS1idWJibGVcIixvbjp7XCJjbGlja1wiOl92bS5vbkJ1YmJsZUNsaWNrfX0sW192bS5fdChcImJ1YmJsZS1zdGFydFwiKSxfdm0uX3YoXCIgXCIpLChfdm0uaW1hZ2UgfHwgX3ZtLiRzbG90cy5pbWFnZSk/X2MoJ2Rpdicse3N0YXRpY0NsYXNzOlwibWVzc2FnZS1pbWFnZVwifSxbX3ZtLl90KFwiaW1hZ2VcIixbX2MoJ2ltZycse2F0dHJzOntcInNyY1wiOl92bS5pbWFnZX19KV0pXSwyKTpfdm0uX2UoKSxfdm0uX3YoXCIgXCIpLChfdm0udGV4dEhlYWRlciB8fCBfdm0uJHNsb3RzWyd0ZXh0LWhlYWRlciddKT9fYygnZGl2Jyx7c3RhdGljQ2xhc3M6XCJtZXNzYWdlLXRleHQtaGVhZGVyXCJ9LFtfdm0uX3QoXCJ0ZXh0LWhlYWRlclwiLFtfdm0uX3YoX3ZtLl9zKF92bS50ZXh0SGVhZGVyKSldKV0sMik6X3ZtLl9lKCksX3ZtLl92KFwiIFwiKSwoX3ZtLnRleHQgfHwgX3ZtLiRzbG90cy50ZXh0IHx8IF92bS50eXBpbmcpP19jKCdkaXYnLHtzdGF0aWNDbGFzczpcIm1lc3NhZ2UtdGV4dFwiLG9uOntcImNsaWNrXCI6X3ZtLm9uVGV4dENsaWNrfX0sW192bS5fdChcInRleHRcIixbX3ZtLl92KF92bS5fcyhfdm0udGV4dCkpXSksX3ZtLl92KFwiIFwiKSwoX3ZtLnR5cGluZyk/X2MoJ2Rpdicse3N0YXRpY0NsYXNzOlwibWVzc2FnZS10eXBpbmctaW5kaWNhdG9yXCJ9LFtfYygnZGl2JyksX3ZtLl92KFwiIFwiKSxfYygnZGl2JyksX3ZtLl92KFwiIFwiKSxfYygnZGl2JyldKTpfdm0uX2UoKV0sMik6X3ZtLl9lKCksX3ZtLl92KFwiIFwiKSwoX3ZtLnRleHRGb290ZXIgfHwgX3ZtLiRzbG90c1sndGV4dC1mb290ZXInXSk/X2MoJ2Rpdicse3N0YXRpY0NsYXNzOlwibWVzc2FnZS10ZXh0LWZvb3RlclwifSxbX3ZtLl90KFwidGV4dC1mb290ZXJcIixbX3ZtLl92KF92bS5fcyhfdm0udGV4dEZvb3RlcikpXSldLDIpOl92bS5fZSgpLF92bS5fdihcIiBcIiksX3ZtLl90KFwiYnViYmxlLWVuZFwiKSxfdm0uX3YoXCIgXCIpLF92bS5fdChcImRlZmF1bHRcIildLDIpLF92bS5fdihcIiBcIiksKF92bS5mb290ZXIgfHwgX3ZtLiRzbG90cy5mb290ZXIpP19jKCdkaXYnLHtzdGF0aWNDbGFzczpcIm1lc3NhZ2UtZm9vdGVyXCIsb246e1wiY2xpY2tcIjpfdm0ub25Gb290ZXJDbGlja319LFtfdm0uX3QoXCJmb290ZXJcIixbX3ZtLl92KF92bS5fcyhfdm0uZm9vdGVyKSldKV0sMik6X3ZtLl9lKCksX3ZtLl92KFwiIFwiKSxfdm0uX3QoXCJjb250ZW50LWVuZFwiKV0sMiksX3ZtLl92KFwiIFwiKSxfdm0uX3QoXCJlbmRcIildLDIpfSxzdGF0aWNSZW5kZXJGbnM6IFtdLFxuICBuYW1lOiAnZjctbWVzc2FnZScsXG4gIHByb3BzOiBNZXNzYWdlUHJvcHMsXG4gIGNvbXB1dGVkOiB7XG4gICAgY2xhc3NlcygpIHtcbiAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgcmV0dXJuIFV0aWxzLmV4dGVuZCh7XG4gICAgICAgICdtZXNzYWdlLXNlbnQnOiBzZWxmLnR5cGUgPT09ICdzZW50JyxcbiAgICAgICAgJ21lc3NhZ2UtcmVjZWl2ZWQnOiBzZWxmLnR5cGUgPT09ICdyZWNlaXZlZCcsXG4gICAgICAgICdtZXNzYWdlLXR5cGluZyc6IHNlbGYudHlwaW5nLFxuICAgICAgICAnbWVzc2FnZS1maXJzdCc6IHNlbGYuZmlyc3QsXG4gICAgICAgICdtZXNzYWdlLWxhc3QnOiBzZWxmLmxhc3QsXG4gICAgICAgICdtZXNzYWdlLXRhaWwnOiBzZWxmLnRhaWwsXG4gICAgICAgICdtZXNzYWdlLXNhbWUtbmFtZSc6IHNlbGYuc2FtZU5hbWUsXG4gICAgICAgICdtZXNzYWdlLXNhbWUtaGVhZGVyJzogc2VsZi5zYW1lSGVhZGVyLFxuICAgICAgICAnbWVzc2FnZS1zYW1lLWZvb3Rlcic6IHNlbGYuc2FtZUZvb3RlcixcbiAgICAgICAgJ21lc3NhZ2Utc2FtZS1hdmF0YXInOiBzZWxmLnNhbWVBdmF0YXIsXG4gICAgICB9LCBNaXhpbnMuY29sb3JDbGFzc2VzKHNlbGYpKTtcbiAgICB9LFxuICB9LFxuICBtZXRob2RzOiB7XG4gICAgb25DbGljayhldmVudCkge1xuICAgICAgdGhpcy4kZW1pdCgnY2xpY2snLCBldmVudCk7XG4gICAgfSxcbiAgICBvbk5hbWVDbGljayhldmVudCkge1xuICAgICAgdGhpcy4kZW1pdCgnY2xpY2s6bmFtZScsIGV2ZW50KTtcbiAgICB9LFxuICAgIG9uVGV4dENsaWNrKGV2ZW50KSB7XG4gICAgICB0aGlzLiRlbWl0KCdjbGljazp0ZXh0JywgZXZlbnQpO1xuICAgIH0sXG4gICAgb25BdmF0YXJDbGljayhldmVudCkge1xuICAgICAgdGhpcy4kZW1pdCgnY2xpY2s6YXZhdGFyJywgZXZlbnQpO1xuICAgIH0sXG4gICAgb25IZWFkZXJDbGljayhldmVudCkge1xuICAgICAgdGhpcy4kZW1pdCgnY2xpY2s6aGVhZGVyJywgZXZlbnQpO1xuICAgIH0sXG4gICAgb25Gb290ZXJDbGljayhldmVudCkge1xuICAgICAgdGhpcy4kZW1pdCgnY2xpY2s6Zm9vdGVyJywgZXZlbnQpO1xuICAgIH0sXG4gICAgb25CdWJibGVDbGljayhldmVudCkge1xuICAgICAgdGhpcy4kZW1pdCgnY2xpY2s6YnViYmxlJywgZXZlbnQpO1xuICAgIH0sXG4gIH0sXG59O1xuXG5jb25zdCBNZXNzYWdlYmFyQXR0YWNobWVudFByb3BzID0gVXRpbHMuZXh0ZW5kKFxuICB7XG4gICAgaW1hZ2U6IFN0cmluZyxcbiAgICBkZWxldGFibGU6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiB0cnVlLFxuICAgIH0sXG4gIH0sXG4gIE1peGlucy5jb2xvclByb3BzXG4pO1xuXG52YXIgZjdNZXNzYWdlYmFyQXR0YWNobWVudCA9IHtyZW5kZXI6IGZ1bmN0aW9uKCl7dmFyIF92bT10aGlzO3ZhciBfaD1fdm0uJGNyZWF0ZUVsZW1lbnQ7dmFyIF9jPV92bS5fc2VsZi5fY3x8X2g7cmV0dXJuIF9jKCdkaXYnLHtzdGF0aWNDbGFzczpcIm1lc3NhZ2ViYXItYXR0YWNobWVudFwiLGNsYXNzOl92bS5jbGFzc2VzLG9uOntcImNsaWNrXCI6X3ZtLm9uQ2xpY2t9fSxbKF92bS5pbWFnZSk/X2MoJ2ltZycse2F0dHJzOntcInNyY1wiOl92bS5pbWFnZX19KTpfdm0uX2UoKSxfdm0uX3YoXCIgXCIpLChfdm0uZGVsZXRhYmxlKT9fYygnc3Bhbicse3N0YXRpY0NsYXNzOlwibWVzc2FnZWJhci1hdHRhY2htZW50LWRlbGV0ZVwiLG9uOntcImNsaWNrXCI6X3ZtLm9uRGVsZXRlQ2xpY2t9fSk6X3ZtLl9lKCksX3ZtLl92KFwiIFwiKSxfdm0uX3QoXCJkZWZhdWx0XCIpXSwyKX0sc3RhdGljUmVuZGVyRm5zOiBbXSxcbiAgcHJvcHM6IE1lc3NhZ2ViYXJBdHRhY2htZW50UHJvcHMsXG4gIG5hbWU6ICdmNy1tZXNzYWdlYmFyLWF0dGFjaG1lbnQnLFxuICBjb21wdXRlZDoge1xuICAgIGNsYXNzZXMoKSB7XG4gICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgIHJldHVybiBNaXhpbnMuY29sb3JDbGFzc2VzKHNlbGYpO1xuICAgIH0sXG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBvbkNsaWNrKGUpIHtcbiAgICAgIHRoaXMuJGVtaXQoJ2F0dGFjaG1lbnQ6Y2xpY2snLCBlKTtcbiAgICB9LFxuICAgIG9uRGVsZXRlQ2xpY2soZSkge1xuICAgICAgdGhpcy4kZW1pdCgnYXR0YWNobWVudDpkZWxldGUnLCBlKTtcbiAgICB9LFxuICB9LFxufTtcblxudmFyIGY3TWVzc2FnZWJhckF0dGFjaG1lbnRzID0ge3JlbmRlcjogZnVuY3Rpb24oKXt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtyZXR1cm4gX2MoJ2Rpdicse3N0YXRpY0NsYXNzOlwibWVzc2FnZWJhci1hdHRhY2htZW50c1wiLGNsYXNzOl92bS5jbGFzc2VzfSxbX3ZtLl90KFwiZGVmYXVsdFwiKV0sMil9LHN0YXRpY1JlbmRlckZuczogW10sXG4gIHByb3BzOiBNaXhpbnMuY29sb3JQcm9wcyxcbiAgbmFtZTogJ2Y3LW1lc3NhZ2ViYXItYXR0YWNobWVudHMnLFxuICBjb21wdXRlZDoge1xuICAgIGNsYXNzZXMoKSB7XG4gICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgIHJldHVybiBNaXhpbnMuY29sb3JDbGFzc2VzKHNlbGYpO1xuICAgIH0sXG4gIH0sXG59O1xuXG5jb25zdCBNZXNzYWdlYmFyU2hlZXRJdGVtUHJvcHMgPSBVdGlscy5leHRlbmQoXG4gIHtcbiAgICBpbWFnZTogU3RyaW5nLFxuICAgIGNoZWNrZWQ6IEJvb2xlYW4sXG4gIH0sXG4gIE1peGlucy5jb2xvclByb3BzXG4pO1xuXG52YXIgZjdNZXNzYWdlYmFyU2hlZXRJbWFnZSA9IHtyZW5kZXI6IGZ1bmN0aW9uKCl7dmFyIF92bT10aGlzO3ZhciBfaD1fdm0uJGNyZWF0ZUVsZW1lbnQ7dmFyIF9jPV92bS5fc2VsZi5fY3x8X2g7cmV0dXJuIF9jKCdsYWJlbCcse3N0YXRpY0NsYXNzOlwibWVzc2FnZWJhci1zaGVldC1pbWFnZSBjaGVja2JveFwiLGNsYXNzOl92bS5jbGFzc2VzLHN0eWxlOih7ICdiYWNrZ3JvdW5kLWltYWdlJzogX3ZtLmltYWdlICYmIGB1cmwoJHtfdm0uaW1hZ2V9KWB9KX0sW19jKCdpbnB1dCcse2F0dHJzOntcInR5cGVcIjpcImNoZWNrYm94XCJ9LGRvbVByb3BzOntcImNoZWNrZWRcIjpfdm0uY2hlY2tlZH0sb246e1wiY2hhbmdlXCI6X3ZtLm9uQ2hhbmdlfX0pLF92bS5fdihcIiBcIiksX2MoJ2knLHtzdGF0aWNDbGFzczpcImljb24gaWNvbi1jaGVja2JveFwifSksX3ZtLl92KFwiIFwiKSxfdm0uX3QoXCJkZWZhdWx0XCIpXSwyKX0sc3RhdGljUmVuZGVyRm5zOiBbXSxcbiAgcHJvcHM6IE1lc3NhZ2ViYXJTaGVldEl0ZW1Qcm9wcyxcbiAgbmFtZTogJ2Y3LW1lc3NhZ2ViYXItc2hlZXQtaW1hZ2UnLFxuICBjb21wdXRlZDoge1xuICAgIGNsYXNzZXMoKSB7XG4gICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgIHJldHVybiBNaXhpbnMuY29sb3JDbGFzc2VzKHNlbGYpO1xuICAgIH0sXG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBvbkNoYW5nZShlKSB7XG4gICAgICBpZiAodGhpcy5jaGVja2VkKSB0aGlzLiRlbWl0KCdjaGVja2VkJywgZSk7XG4gICAgICBlbHNlIHRoaXMuJGVtaXQoJ3VuY2hlY2tlZCcsIGUpO1xuICAgICAgdGhpcy4kZW1pdCgnY2hhbmdlJywgZSk7XG4gICAgfSxcbiAgfSxcbn07XG5cbnZhciBmN01lc3NhZ2ViYXJTaGVldEl0ZW0gPSB7cmVuZGVyOiBmdW5jdGlvbigpe3ZhciBfdm09dGhpczt2YXIgX2g9X3ZtLiRjcmVhdGVFbGVtZW50O3ZhciBfYz1fdm0uX3NlbGYuX2N8fF9oO3JldHVybiBfYygnZGl2Jyx7c3RhdGljQ2xhc3M6XCJtZXNzYWdlYmFyLXNoZWV0LWl0ZW1cIixjbGFzczpfdm0uY2xhc3Nlc30sW192bS5fdChcImRlZmF1bHRcIildLDIpfSxzdGF0aWNSZW5kZXJGbnM6IFtdLFxuICBwcm9wczogTWl4aW5zLmNvbG9yUHJvcHMsXG4gIG5hbWU6ICdmNy1tZXNzYWdlYmFyLXNoZWV0LWl0ZW0nLFxuICBjb21wdXRlZDoge1xuICAgIGNsYXNzZXMoKSB7XG4gICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgIHJldHVybiBNaXhpbnMuY29sb3JDbGFzc2VzKHNlbGYpO1xuICAgIH0sXG4gIH0sXG59O1xuXG52YXIgZjdNZXNzYWdlYmFyU2hlZXQgPSB7cmVuZGVyOiBmdW5jdGlvbigpe3ZhciBfdm09dGhpczt2YXIgX2g9X3ZtLiRjcmVhdGVFbGVtZW50O3ZhciBfYz1fdm0uX3NlbGYuX2N8fF9oO3JldHVybiBfYygnZGl2Jyx7c3RhdGljQ2xhc3M6XCJtZXNzYWdlYmFyLXNoZWV0XCIsY2xhc3M6X3ZtLmNsYXNzZXN9LFtfdm0uX3QoXCJkZWZhdWx0XCIpXSwyKX0sc3RhdGljUmVuZGVyRm5zOiBbXSxcbiAgcHJvcHM6IE1peGlucy5jb2xvclByb3BzLFxuICBuYW1lOiAnZjctbWVzc2FnZWJhci1zaGVldCcsXG4gIGNvbXB1dGVkOiB7XG4gICAgY2xhc3NlcygpIHtcbiAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgcmV0dXJuIE1peGlucy5jb2xvckNsYXNzZXMoc2VsZik7XG4gICAgfSxcbiAgfSxcbn07XG5cbmNvbnN0IE1lc3NhZ2ViYXJQcm9wcyA9IFV0aWxzLmV4dGVuZChcbiAge1xuICAgIHNoZWV0VmlzaWJsZTogQm9vbGVhbixcbiAgICBhdHRhY2htZW50c1Zpc2libGU6IEJvb2xlYW4sXG4gICAgdG9wOiBCb29sZWFuLFxuICAgIHJlc2l6YWJsZToge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgfSxcbiAgICBib3R0b21PZmZzZXQ6IHtcbiAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgIGRlZmF1bHQ6IDAsXG4gICAgfSxcbiAgICB0b3BPZmZzZXQ6IHtcbiAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgIGRlZmF1bHQ6IDAsXG4gICAgfSxcbiAgICBtYXhIZWlnaHQ6IE51bWJlcixcbiAgICBzZW5kTGluazogU3RyaW5nLFxuICAgIHZhbHVlOiBbU3RyaW5nLCBOdW1iZXIsIEFycmF5XSxcbiAgICBkaXNhYmxlZDogQm9vbGVhbixcbiAgICByZWFkb25seTogQm9vbGVhbixcbiAgICBuYW1lOiBTdHJpbmcsXG4gICAgcGxhY2Vob2xkZXI6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6ICdNZXNzYWdlJyxcbiAgICB9LFxuICAgIGluaXQ6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiB0cnVlLFxuICAgIH0sXG4gIH0sXG4gIE1peGlucy5jb2xvclByb3BzXG4pO1xuXG52YXIgZjdNZXNzYWdlYmFyID0ge1xuICBuYW1lOiAnZjctbWVzc2FnZWJhcicsXG4gIGNvbXBvbmVudHM6IHtcbiAgICBmN0lucHV0LFxuICAgIGY3TGluayxcbiAgfSxcbiAgcmVuZGVyKGMpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBjb25zdCBiZWZvcmVJbm5lckVscyA9IFtdO1xuICAgIGNvbnN0IGFmdGVySW5uZXJFbHMgPSBbXTtcbiAgICBjb25zdCBpbm5lclN0YXJ0RWxzID0gW107XG4gICAgY29uc3QgaW5uZXJFbmRFbHMgPSBbXTsgLy8gYWRkIHNlbmQgbGluayBoZXJlXG4gICAgY29uc3QgYmVmb3JlQXJlYUVscyA9IFtdOyAvLyBhZGQgYXR0YWNobWVudHMgaGVyZVxuICAgIGNvbnN0IGFmdGVyQXJlYUVscyA9IFtdO1xuXG4gICAgbGV0IGxpbmtFbDtcbiAgICBpZiAoKHNlbGYuc2VuZExpbmsgJiYgc2VsZi5zZW5kTGluay5sZW5ndGggPiAwKSB8fCBzZWxmLiRzbG90c1snc2VuZC1saW5rJ10pIHtcbiAgICAgIGxpbmtFbCA9IGMoJ2Y3LWxpbmsnLCB7XG4gICAgICAgIG9uOiB7XG4gICAgICAgICAgY2xpY2s6IHNlbGYub25DbGljayxcbiAgICAgICAgfSxcbiAgICAgIH0sIFtzZWxmLnNlbmRMaW5rID8gc2VsZi5zZW5kTGluayA6IHNlbGYuJHNsb3RzWydzZW5kLWxpbmsnXV0pO1xuICAgICAgaW5uZXJFbmRFbHMucHVzaChsaW5rRWwpO1xuICAgIH1cblxuICAgIGlmIChzZWxmLiRzbG90c1snYmVmb3JlLWlubmVyJ10pIHtcbiAgICAgIHNlbGYuJHNsb3RzWydiZWZvcmUtaW5uZXInXS5mb3JFYWNoKChlbCkgPT4ge1xuICAgICAgICBiZWZvcmVJbm5lckVscy5wdXNoKGVsKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoc2VsZi4kc2xvdHNbJ2FmdGVyLWlubmVyJ10pIHtcbiAgICAgIHNlbGYuJHNsb3RzWydhZnRlci1pbm5lciddLmZvckVhY2goKGVsKSA9PiB7XG4gICAgICAgIGFmdGVySW5uZXJFbHMucHVzaChlbCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHNlbGYuJHNsb3RzWydpbm5lci1zdGFydCddKSB7XG4gICAgICBzZWxmLiRzbG90c1snaW5uZXItc3RhcnQnXS5mb3JFYWNoKChlbCkgPT4ge1xuICAgICAgICBpbm5lclN0YXJ0RWxzLnB1c2goZWwpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChzZWxmLiRzbG90c1snaW5uZXItZW5kJ10pIHtcbiAgICAgIHNlbGYuJHNsb3RzWydpbm5lci1lbmQnXS5mb3JFYWNoKChlbCkgPT4ge1xuICAgICAgICBpbm5lckVuZEVscy5wdXNoKGVsKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoc2VsZi4kc2xvdHNbJ2JlZm9yZS1hcmVhJ10pIHtcbiAgICAgIHNlbGYuJHNsb3RzWydiZWZvcmUtYXJlYSddLmZvckVhY2goKGVsKSA9PiB7XG4gICAgICAgIGJlZm9yZUFyZWFFbHMucHVzaChlbCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHNlbGYuJHNsb3RzWydhZnRlci1hcmVhJ10pIHtcbiAgICAgIHNlbGYuJHNsb3RzWydhZnRlci1hcmVhJ10uZm9yRWFjaCgoZWwpID0+IHtcbiAgICAgICAgYWZ0ZXJBcmVhRWxzLnB1c2goZWwpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChzZWxmLiRzbG90cy5kZWZhdWx0KSB7XG4gICAgICBzZWxmLiRzbG90cy5kZWZhdWx0LmZvckVhY2goKGVsKSA9PiB7XG4gICAgICAgIGNvbnN0IHRhZyA9IGVsLnRhZztcbiAgICAgICAgaWYgKHRhZyAmJiB0YWcuaW5kZXhPZignbWVzc2FnZWJhci1hdHRhY2htZW50cycpID49IDApIHtcbiAgICAgICAgICBiZWZvcmVBcmVhRWxzLnB1c2goZWwpO1xuICAgICAgICB9IGVsc2UgaWYgKHRhZyAmJiB0YWcuaW5kZXhPZignbWVzc2FnZWJhci1zaGVldCcpID49IDApIHtcbiAgICAgICAgICBhZnRlcklubmVyRWxzLnB1c2goZWwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlubmVyRW5kRWxzLnB1c2goZWwpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjb25zdCBpbnB1dEVsID0gYygnZjctaW5wdXQnLCB7XG4gICAgICBwcm9wczoge1xuICAgICAgICB0eXBlOiAndGV4dGFyZWEnLFxuICAgICAgICB3cmFwOiBmYWxzZSxcbiAgICAgICAgcGxhY2Vob2xkZXI6IHNlbGYucGxhY2Vob2xkZXIsXG4gICAgICAgIGRpc2FibGVkOiBzZWxmLmRpc2FibGVkLFxuICAgICAgICBuYW1lOiBzZWxmLm5hbWUsXG4gICAgICAgIHJlYWRvbmx5OiBzZWxmLnJlYWRvbmx5LFxuICAgICAgICByZXNpemFibGU6IHNlbGYucmVzaXphYmxlLFxuICAgICAgICB2YWx1ZTogc2VsZi52YWx1ZSxcbiAgICAgIH0sXG4gICAgICByZWY6ICdhcmVhJyxcbiAgICAgIG9uOiB7XG4gICAgICAgIGlucHV0OiBzZWxmLm9uSW5wdXQsXG4gICAgICAgIGNoYW5nZTogc2VsZi5vbkNoYW5nZSxcbiAgICAgICAgZm9jdXM6IHNlbGYub25Gb2N1cyxcbiAgICAgICAgYmx1cjogc2VsZi5vbkJsdXIsXG4gICAgICB9LFxuICAgIH0pO1xuXG4gICAgY29uc3QgYXJlYUVsID0gYygnZGl2Jywge1xuICAgICAgc3RhdGljQ2xhc3M6ICdtZXNzYWdlYmFyLWFyZWEnLFxuICAgIH0sIFtcbiAgICAgIGJlZm9yZUFyZWFFbHMsXG4gICAgICBpbnB1dEVsLFxuICAgICAgYWZ0ZXJBcmVhRWxzLFxuICAgIF0pO1xuXG4gICAgY29uc3QgaW5uZXJFbCA9IGMoJ2RpdicsIHtcbiAgICAgIHN0YXRpY0NsYXNzOiAndG9vbGJhci1pbm5lcicsXG4gICAgfSwgW1xuICAgICAgaW5uZXJTdGFydEVscyxcbiAgICAgIGFyZWFFbCxcbiAgICAgIGlubmVyRW5kRWxzLFxuICAgIF0pO1xuXG4gICAgcmV0dXJuIGMoJ2RpdicsIHtcbiAgICAgIHN0YXRpY0NsYXNzOiAndG9vbGJhciBtZXNzYWdlYmFyJyxcbiAgICAgIGNsYXNzOiBzZWxmLmNsYXNzZXMsXG4gICAgICBvbjoge1xuICAgICAgICAnbWVzc2FnZWJhcjphdHRhY2htZW50ZGVsZXRlJzogc2VsZi5vbkRlbGV0ZUF0dGFjaG1lbnQsXG4gICAgICAgICdtZXNzYWdlYmFyOmF0dGFjaG1lbnRjbGljayc6IHNlbGYub25DbGlja0F0dGFjaG1lbnQsXG4gICAgICAgICdtZXNzYWdlYmFyOnJlc2l6ZXBhZ2UnOiBzZWxmLm9uUmVzaXplUGFnZSxcbiAgICAgIH0sXG4gICAgfSwgW1xuICAgICAgYmVmb3JlSW5uZXJFbHMsXG4gICAgICBpbm5lckVsLFxuICAgICAgYWZ0ZXJJbm5lckVscyxcbiAgICBdKTtcbiAgfSxcbiAgcHJvcHM6IE1lc3NhZ2ViYXJQcm9wcyxcbiAgY29tcHV0ZWQ6IHtcbiAgICBjbGFzc2VzKCkge1xuICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICByZXR1cm4gVXRpbHMuZXh0ZW5kKHtcbiAgICAgICAgJ21lc3NhZ2ViYXItYXR0YWNobWVudHMtdmlzaWJsZSc6IHNlbGYuYXR0YWNobWVudHNWaXNpYmxlLFxuICAgICAgICAnbWVzc2FnZWJhci1zaGVldC12aXNpYmxlJzogc2VsZi5zaGVldFZpc2libGUsXG4gICAgICB9LCBNaXhpbnMuY29sb3JDbGFzc2VzKTtcbiAgICB9LFxuICB9LFxuICB3YXRjaDoge1xuICAgIHNoZWV0VmlzaWJsZSgpIHtcbiAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgaWYgKCFzZWxmLnJlc2l6YWJsZSkgcmV0dXJuO1xuICAgICAgc2VsZi4kbmV4dFRpY2soKCkgPT4ge1xuICAgICAgICBpZiAoIXNlbGYuZjdNZXNzYWdlYmFyKSByZXR1cm47XG4gICAgICAgIHNlbGYuZjdNZXNzYWdlYmFyLnNoZWV0VmlzaWJsZSA9IHNlbGYuc2hlZXRWaXNpYmxlO1xuICAgICAgICBzZWxmLmY3TWVzc2FnZWJhci5yZXNpemVQYWdlKCk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGF0dGFjaG1lbnRzVmlzaWJsZSgpIHtcbiAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgaWYgKCFzZWxmLnJlc2l6YWJsZSkgcmV0dXJuO1xuICAgICAgc2VsZi4kbmV4dFRpY2soKCkgPT4ge1xuICAgICAgICBpZiAoIXNlbGYuZjdNZXNzYWdlYmFyKSByZXR1cm47XG4gICAgICAgIHNlbGYuZjdNZXNzYWdlYmFyLmF0dGFjaG1lbnRzVmlzaWJsZSA9IHNlbGYuYXR0YWNobWVudHNWaXNpYmxlO1xuICAgICAgICBzZWxmLmY3TWVzc2FnZWJhci5yZXNpemVQYWdlKCk7XG4gICAgICB9KTtcbiAgICB9LFxuICB9LFxuICBiZWZvcmVEZXN0cm95KCkge1xuICAgIGlmICh0aGlzLmY3TWVzc2FnZWJhciAmJiB0aGlzLmY3TWVzc2FnZWJhci5kZXN0cm95KSB0aGlzLmY3TWVzc2FnZWJhci5kZXN0cm95KCk7XG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBjbGVhciguLi5hcmdzKSB7XG4gICAgICBpZiAoIXRoaXMuZjdNZXNzYWdlYmFyKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIHRoaXMuZjdNZXNzYWdlYmFyLmNsZWFyKC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgZ2V0VmFsdWUoLi4uYXJncykge1xuICAgICAgaWYgKCF0aGlzLmY3TWVzc2FnZWJhcikgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiB0aGlzLmY3TWVzc2FnZWJhci5nZXRWYWx1ZSguLi5hcmdzKTtcbiAgICB9LFxuICAgIHNldFZhbHVlKC4uLmFyZ3MpIHtcbiAgICAgIGlmICghdGhpcy5mN01lc3NhZ2ViYXIpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gdGhpcy5mN01lc3NhZ2ViYXIuc2V0VmFsdWUoLi4uYXJncyk7XG4gICAgfSxcbiAgICBzZXRQbGFjZWhvbGRlciguLi5hcmdzKSB7XG4gICAgICBpZiAoIXRoaXMuZjdNZXNzYWdlYmFyKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIHRoaXMuZjdNZXNzYWdlYmFyLnNldFBsYWNlaG9sZGVyKC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgcmVzaXplUGFnZSguLi5hcmdzKSB7XG4gICAgICBpZiAoIXRoaXMuZjdNZXNzYWdlYmFyKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIHRoaXMuZjdNZXNzYWdlYmFyLnJlc2l6ZVBhZ2UoLi4uYXJncyk7XG4gICAgfSxcbiAgICBmb2N1cyguLi5hcmdzKSB7XG4gICAgICBpZiAoIXRoaXMuZjdNZXNzYWdlYmFyKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIHRoaXMuZjdNZXNzYWdlYmFyLmZvY3VzKC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgYmx1ciguLi5hcmdzKSB7XG4gICAgICBpZiAoIXRoaXMuZjdNZXNzYWdlYmFyKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIHRoaXMuZjdNZXNzYWdlYmFyLmJsdXIoLi4uYXJncyk7XG4gICAgfSxcbiAgICBhdHRhY2htZW50c1Nob3coLi4uYXJncykge1xuICAgICAgaWYgKCF0aGlzLmY3TWVzc2FnZWJhcikgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiB0aGlzLmY3TWVzc2FnZWJhci5hdHRhY2htZW50c1Nob3coLi4uYXJncyk7XG4gICAgfSxcbiAgICBhdHRhY2htZW50c0hpZGUoLi4uYXJncykge1xuICAgICAgaWYgKCF0aGlzLmY3TWVzc2FnZWJhcikgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiB0aGlzLmY3TWVzc2FnZWJhci5hdHRhY2htZW50c0hpZGUoLi4uYXJncyk7XG4gICAgfSxcbiAgICBhdHRhY2htZW50c1RvZ2dsZSguLi5hcmdzKSB7XG4gICAgICBpZiAoIXRoaXMuZjdNZXNzYWdlYmFyKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIHRoaXMuZjdNZXNzYWdlYmFyLmF0dGFjaG1lbnRzVG9nZ2xlKC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgc2hlZXRTaG93KC4uLmFyZ3MpIHtcbiAgICAgIGlmICghdGhpcy5mN01lc3NhZ2ViYXIpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gdGhpcy5mN01lc3NhZ2ViYXIuc2hlZXRTaG93KC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgc2hlZXRIaWRlKC4uLmFyZ3MpIHtcbiAgICAgIGlmICghdGhpcy5mN01lc3NhZ2ViYXIpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gdGhpcy5mN01lc3NhZ2ViYXIuc2hlZXRIaWRlKC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgc2hlZXRUb2dnbGUoLi4uYXJncykge1xuICAgICAgaWYgKCF0aGlzLmY3TWVzc2FnZWJhcikgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiB0aGlzLmY3TWVzc2FnZWJhci5zaGVldFRvZ2dsZSguLi5hcmdzKTtcbiAgICB9LFxuICAgIG9uQ2hhbmdlKGV2ZW50KSB7XG4gICAgICB0aGlzLiRlbWl0KCdjaGFuZ2UnLCBldmVudCk7XG4gICAgfSxcbiAgICBvbklucHV0KGV2ZW50KSB7XG4gICAgICB0aGlzLiRlbWl0KCdpbnB1dCcsIGV2ZW50KTtcbiAgICB9LFxuICAgIG9uRm9jdXMoZXZlbnQpIHtcbiAgICAgIHRoaXMuJGVtaXQoJ2ZvY3VzJywgZXZlbnQpO1xuICAgIH0sXG4gICAgb25CbHVyKGV2ZW50KSB7XG4gICAgICB0aGlzLiRlbWl0KCdibHVyJywgZXZlbnQpO1xuICAgIH0sXG4gICAgb25DbGljayhldmVudCkge1xuICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICBjb25zdCB2YWx1ZSA9IHNlbGYuJHJlZnMuYXJlYS4kZWwudmFsdWU7XG4gICAgICBjb25zdCBjbGVhciA9IHNlbGYuZjdNZXNzYWdlYmFyID8gc2VsZi5mN01lc3NhZ2ViYXIuY2xlYXIgOiAoKSA9PiB7fTtcbiAgICAgIHRoaXMuJGVtaXQoJ3N1Ym1pdCcsIHZhbHVlLCBjbGVhcik7XG4gICAgICB0aGlzLiRlbWl0KCdzZW5kJywgdmFsdWUsIGNsZWFyKTtcbiAgICAgIHRoaXMuJGVtaXQoJ2NsaWNrJywgZXZlbnQpO1xuICAgIH0sXG4gICAgb25EZWxldGVBdHRhY2htZW50KGUpIHtcbiAgICAgIHRoaXMuJGVtaXQoJ21lc3NhZ2ViYXI6YXR0YWNobWVudGRlbGV0ZScsIGUpO1xuICAgIH0sXG4gICAgb25DbGlja0F0dGFjaG1lbnQoZSkge1xuICAgICAgdGhpcy4kZW1pdCgnbWVzc2FnZWJhcjphdHRhY2htZW50Y2xpY2snLCBlKTtcbiAgICB9LFxuICAgIG9uUmVzaXplUGFnZShlKSB7XG4gICAgICB0aGlzLiRlbWl0KCdtZXNzYWdlYmFyOnJlc2l6ZXBhZ2UnLCBlKTtcbiAgICB9LFxuICAgIG9uRjdSZWFkeSgpIHtcbiAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgaWYgKCFzZWxmLmluaXQpIHJldHVybjtcbiAgICAgIHNlbGYuZjdNZXNzYWdlYmFyID0gc2VsZi4kZjcubWVzc2FnZWJhci5jcmVhdGUoe1xuICAgICAgICBlbDogc2VsZi4kZWwsXG4gICAgICAgIHRvcDogc2VsZi50b3AsXG4gICAgICAgIHJlc2l6ZVBhZ2U6IHNlbGYucmVzaXphYmxlLFxuICAgICAgICBib3R0b21PZmZzZXQ6IHNlbGYuYm90dG9tT2Zmc2V0LFxuICAgICAgICB0b3BPZmZzZXQ6IHNlbGYudG9wT2Zmc2V0LFxuICAgICAgICBtYXhIZWlnaHQ6IHNlbGYubWF4SGVpZ2h0LFxuICAgICAgfSk7XG4gICAgfSxcbiAgfSxcbn07XG5cbnZhciBmN01lc3NhZ2VzVGl0bGUgPSB7cmVuZGVyOiBmdW5jdGlvbigpe3ZhciBfdm09dGhpczt2YXIgX2g9X3ZtLiRjcmVhdGVFbGVtZW50O3ZhciBfYz1fdm0uX3NlbGYuX2N8fF9oO3JldHVybiBfYygnZGl2Jyx7c3RhdGljQ2xhc3M6XCJtZXNzYWdlcy10aXRsZVwiLGNsYXNzOl92bS5jbGFzc2VzfSxbX3ZtLl90KFwiZGVmYXVsdFwiKV0sMil9LHN0YXRpY1JlbmRlckZuczogW10sXG4gIHByb3BzOiBNaXhpbnMuY29sb3JQcm9wcyxcbiAgbmFtZTogJ2Y3LW1lc3NhZ2VzLXRpdGxlJyxcbiAgY29tcHV0ZWQ6IHtcbiAgICBjbGFzc2VzKCkge1xuICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICByZXR1cm4gTWl4aW5zLmNvbG9yQ2xhc3NlcyhzZWxmKTtcbiAgICB9LFxuICB9LFxufTtcblxuY29uc3QgTWVzc2FnZXNQcm9wcyA9IFV0aWxzLmV4dGVuZChcbiAge1xuICAgIGF1dG9MYXlvdXQ6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiBmYWxzZSxcbiAgICB9LFxuICAgIG1lc3NhZ2VzOiB7XG4gICAgICB0eXBlOiBBcnJheSxcbiAgICAgIGRlZmF1bHQoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH0sXG4gICAgfSxcbiAgICBuZXdNZXNzYWdlc0ZpcnN0OiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogZmFsc2UsXG4gICAgfSxcbiAgICBzY3JvbGxNZXNzYWdlczoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgfSxcbiAgICBzY3JvbGxNZXNzYWdlc09uRWRnZToge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgfSxcbiAgICBmaXJzdE1lc3NhZ2VSdWxlOiBGdW5jdGlvbixcbiAgICBsYXN0TWVzc2FnZVJ1bGU6IEZ1bmN0aW9uLFxuICAgIHRhaWxNZXNzYWdlUnVsZTogRnVuY3Rpb24sXG4gICAgc2FtZU5hbWVNZXNzYWdlUnVsZTogRnVuY3Rpb24sXG4gICAgc2FtZUhlYWRlck1lc3NhZ2VSdWxlOiBGdW5jdGlvbixcbiAgICBzYW1lRm9vdGVyTWVzc2FnZVJ1bGU6IEZ1bmN0aW9uLFxuICAgIHNhbWVBdmF0YXJNZXNzYWdlUnVsZTogRnVuY3Rpb24sXG4gICAgY3VzdG9tQ2xhc3NNZXNzYWdlUnVsZTogRnVuY3Rpb24sXG4gICAgcmVuZGVyTWVzc2FnZTogRnVuY3Rpb24sXG5cbiAgICBpbml0OiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogdHJ1ZSxcbiAgICB9LFxuICB9LFxuICBNaXhpbnMuY29sb3JQcm9wc1xuKTtcbnZhciBmN01lc3NhZ2VzID0ge1xuICBuYW1lOiAnZjctbWVzc2FnZXMnLFxuICByZW5kZXIoYykge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjKCdkaXYnLCB7XG4gICAgICBzdGF0aWNDbGFzczogJ21lc3NhZ2VzJyxcbiAgICAgIGNsYXNzOiBNaXhpbnMuY29sb3JDbGFzc2VzKHNlbGYpLFxuICAgIH0sIHNlbGYuJHNsb3RzLmRlZmF1bHQpO1xuICB9LFxuICBwcm9wczogTWVzc2FnZXNQcm9wcyxcbiAgYmVmb3JlRGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy5mN01lc3NhZ2VzICYmIHRoaXMuZjdNZXNzYWdlcy5kZXN0cm95KSB0aGlzLmY3TWVzc2FnZXMuZGVzdHJveSgpO1xuICB9LFxuICBiZWZvcmVVcGRhdGUoKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgaWYgKCFzZWxmLmluaXQpIHJldHVybjtcbiAgICBzZWxmLiRjaGlsZHJlbi5mb3JFYWNoKChlbCkgPT4ge1xuICAgICAgc2VsZi4kJChlbC4kZWwpLmFkZENsYXNzKCdtZXNzYWdlLWFwcGVhcmVkJyk7XG4gICAgfSk7XG4gIH0sXG4gIHVwZGF0ZWQoKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgaWYgKCFzZWxmLmluaXQpIHJldHVybjtcbiAgICBzZWxmLiRjaGlsZHJlbi5mb3JFYWNoKChlbCkgPT4ge1xuICAgICAgY29uc3QgJGVsID0gc2VsZi4kJChlbC4kZWwpO1xuICAgICAgaWYgKCEkZWwuaGFzQ2xhc3MoJ21lc3NhZ2UtYXBwZWFyZWQnKSkge1xuICAgICAgICAkZWwuYWRkQ2xhc3MoJ21lc3NhZ2UtYXBwZWFyLWZyb20tYm90dG9tJyk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHNlbGYuZjdNZXNzYWdlcyAmJiBzZWxmLmY3TWVzc2FnZXMubGF5b3V0ICYmIHNlbGYuYXV0b0xheW91dCkge1xuICAgICAgc2VsZi5mN01lc3NhZ2VzLmxheW91dCgpO1xuICAgIH1cbiAgICBpZiAoc2VsZi5mN01lc3NhZ2VzICYmIHNlbGYuZjdNZXNzYWdlcy5zY3JvbGwgJiYgc2VsZi5zY3JvbGxNZXNzYWdlcykge1xuICAgICAgc2VsZi5mN01lc3NhZ2VzLnNjcm9sbCgpO1xuICAgIH1cbiAgfSxcblxuICBtZXRob2RzOiB7XG4gICAgcmVuZGVyTWVzc2FnZXMobWVzc2FnZXNUb1JlbmRlciwgbWV0aG9kKSB7XG4gICAgICBpZiAoIXRoaXMuZjdNZXNzYWdlcykgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiB0aGlzLnJlbmRlck1lc3NhZ2VzKG1lc3NhZ2VzVG9SZW5kZXIsIG1ldGhvZCk7XG4gICAgfSxcbiAgICBsYXlvdXQoKSB7XG4gICAgICBpZiAoIXRoaXMuZjdNZXNzYWdlcykgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiB0aGlzLmxheW91dCgpO1xuICAgIH0sXG4gICAgc2Nyb2xsKGR1cmF0aW9uLCBzY3JvbGxUb3ApIHtcbiAgICAgIGlmICghdGhpcy5mN01lc3NhZ2VzKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIHRoaXMuc2Nyb2xsKGR1cmF0aW9uLCBzY3JvbGxUb3ApO1xuICAgIH0sXG4gICAgY2xlYXIoKSB7XG4gICAgICBpZiAoIXRoaXMuZjdNZXNzYWdlcykgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiB0aGlzLmNsZWFyKCk7XG4gICAgfSxcbiAgICByZW1vdmVNZXNzYWdlKG1lc3NhZ2VUb1JlbW92ZSwgbGF5b3V0KSB7XG4gICAgICBpZiAoIXRoaXMuZjdNZXNzYWdlcykgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiB0aGlzLnJlbW92ZU1lc3NhZ2UobWVzc2FnZVRvUmVtb3ZlLCBsYXlvdXQpO1xuICAgIH0sXG4gICAgcmVtb3ZlTWVzc2FnZXMobWVzc2FnZXNUb1JlbW92ZSwgbGF5b3V0KSB7XG4gICAgICBpZiAoIXRoaXMuZjdNZXNzYWdlcykgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiB0aGlzLnJlbW92ZU1lc3NhZ2VzKG1lc3NhZ2VzVG9SZW1vdmUsIGxheW91dCk7XG4gICAgfSxcbiAgICBhZGRNZXNzYWdlKC4uLmFyZ3MpIHtcbiAgICAgIGlmICghdGhpcy5mN01lc3NhZ2VzKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIHRoaXMuYWRkTWVzc2FnZSguLi5hcmdzKTtcbiAgICB9LFxuICAgIGFkZE1lc3NhZ2VzKC4uLmFyZ3MpIHtcbiAgICAgIGlmICghdGhpcy5mN01lc3NhZ2VzKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIHRoaXMuYWRkTWVzc2FnZXMoLi4uYXJncyk7XG4gICAgfSxcbiAgICBzaG93VHlwaW5nKG1lc3NhZ2UpIHtcbiAgICAgIGlmICghdGhpcy5mN01lc3NhZ2VzKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIHRoaXMuc2hvd1R5cGluZyhtZXNzYWdlKTtcbiAgICB9LFxuICAgIGhpZGVUeXBpbmcoKSB7XG4gICAgICBpZiAoIXRoaXMuZjdNZXNzYWdlcykgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiB0aGlzLmhpZGVUeXBpbmcoKTtcbiAgICB9LFxuICAgIGRlc3Ryb3koKSB7XG4gICAgICBpZiAoIXRoaXMuZjdNZXNzYWdlcykgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiB0aGlzLmRlc3Ryb3koKTtcbiAgICB9LFxuICAgIG9uRjdSZWFkeShmNykge1xuICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICBpZiAoIXNlbGYuaW5pdCkgcmV0dXJuO1xuICAgICAgc2VsZi5mN01lc3NhZ2VzID0gZjcubWVzc2FnZXMuY3JlYXRlKHtcbiAgICAgICAgZWw6IHNlbGYuJGVsLFxuICAgICAgICBhdXRvTGF5b3V0OiBzZWxmLmF1dG9MYXlvdXQsXG4gICAgICAgIG1lc3NhZ2VzOiBzZWxmLm1lc3NhZ2VzLFxuICAgICAgICBuZXdNZXNzYWdlc0ZpcnN0OiBzZWxmLm5ld01lc3NhZ2VzRmlyc3QsXG4gICAgICAgIHNjcm9sbE1lc3NhZ2VzOiBzZWxmLnNjcm9sbE1lc3NhZ2VzLFxuICAgICAgICBzY3JvbGxNZXNzYWdlc09uRWRnZTogc2VsZi5zY3JvbGxNZXNzYWdlc09uRWRnZSxcbiAgICAgICAgZmlyc3RNZXNzYWdlUnVsZTogc2VsZi5maXJzdE1lc3NhZ2VSdWxlLFxuICAgICAgICBsYXN0TWVzc2FnZVJ1bGU6IHNlbGYubGFzdE1lc3NhZ2VSdWxlLFxuICAgICAgICB0YWlsTWVzc2FnZVJ1bGU6IHNlbGYudGFpbE1lc3NhZ2VSdWxlLFxuICAgICAgICBzYW1lTmFtZU1lc3NhZ2VSdWxlOiBzZWxmLnNhbWVOYW1lTWVzc2FnZVJ1bGUsXG4gICAgICAgIHNhbWVIZWFkZXJNZXNzYWdlUnVsZTogc2VsZi5zYW1lSGVhZGVyTWVzc2FnZVJ1bGUsXG4gICAgICAgIHNhbWVGb290ZXJNZXNzYWdlUnVsZTogc2VsZi5zYW1lRm9vdGVyTWVzc2FnZVJ1bGUsXG4gICAgICAgIHNhbWVBdmF0YXJNZXNzYWdlUnVsZTogc2VsZi5zYW1lQXZhdGFyTWVzc2FnZVJ1bGUsXG4gICAgICAgIGN1c3RvbUNsYXNzTWVzc2FnZVJ1bGU6IHNlbGYuY3VzdG9tQ2xhc3NNZXNzYWdlUnVsZSxcbiAgICAgICAgcmVuZGVyTWVzc2FnZTogc2VsZi5yZW5kZXJNZXNzYWdlLFxuICAgICAgfSk7XG4gICAgfSxcbiAgfSxcbn07XG5cbmNvbnN0IE5hdkxlZnRQcm9wcyA9IFV0aWxzLmV4dGVuZCh7XG4gIGJhY2tMaW5rOiBbQm9vbGVhbiwgU3RyaW5nXSxcbiAgYmFja0xpbmtVcmw6IFN0cmluZyxcbiAgc2xpZGluZzogQm9vbGVhbixcbn0sIE1peGlucy5jb2xvclByb3BzKTtcblxudmFyIGY3TmF2TGVmdCA9IHtyZW5kZXI6IGZ1bmN0aW9uKCl7dmFyIF92bT10aGlzO3ZhciBfaD1fdm0uJGNyZWF0ZUVsZW1lbnQ7dmFyIF9jPV92bS5fc2VsZi5fY3x8X2g7cmV0dXJuIF9jKCdkaXYnLHtzdGF0aWNDbGFzczpcImxlZnRcIixjbGFzczpfdm0uY2xhc3Nlc30sWyhfdm0uYmFja0xpbmspP19jKCdmNy1saW5rJyx7Y2xhc3M6eydpY29uLW9ubHknOiAoX3ZtLmJhY2tMaW5rID09PSB0cnVlIHx8IF92bS5iYWNrTGluayAmJiBfdm0uJHRoZW1lLm1kKX0sYXR0cnM6e1wiaHJlZlwiOl92bS5iYWNrTGlua1VybCB8fCAnIycsXCJiYWNrXCI6XCJcIixcImljb25cIjpcImljb24tYmFja1wiLFwidGV4dFwiOl92bS5iYWNrTGluayAhPT0gdHJ1ZSAmJiAhX3ZtLiR0aGVtZS5tZCA/IF92bS5iYWNrTGluayA6IHVuZGVmaW5lZH0sb246e1wiY2xpY2tcIjpfdm0ub25CYWNrQ2xpY2t9fSk6X3ZtLl9lKCksX3ZtLl92KFwiIFwiKSxfdm0uX3QoXCJkZWZhdWx0XCIpXSwyKX0sc3RhdGljUmVuZGVyRm5zOiBbXSxcbiAgbmFtZTogJ2Y3LW5hdi1sZWZ0JyxcbiAgY29tcG9uZW50czoge1xuICAgIGY3TGluayxcbiAgfSxcbiAgcHJvcHM6IE5hdkxlZnRQcm9wcyxcbiAgY29tcHV0ZWQ6IHtcbiAgICBjbGFzc2VzKCkge1xuICAgICAgcmV0dXJuIFV0aWxzLmV4dGVuZCh7XG4gICAgICAgIHNsaWRpbmc6IHRoaXMuc2xpZG5nLFxuICAgICAgfSwgTWl4aW5zLmNvbG9yQ2xhc3Nlcyh0aGlzKSk7XG4gICAgfSxcbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIG9uQmFja0NsaWNrKGUpIHtcbiAgICAgIHRoaXMuJGVtaXQoJ2JhY2stY2xpY2snLCBlKTtcbiAgICAgIHRoaXMuJGVtaXQoJ2NsaWNrOmJhY2snLCBlKTtcbiAgICB9LFxuICB9LFxufTtcblxuY29uc3QgTmF2UmlnaHRQcm9wcyA9IFV0aWxzLmV4dGVuZCh7XG4gIHNsaWRpbmc6IEJvb2xlYW4sXG59LCBNaXhpbnMuY29sb3JQcm9wcyk7XG5cbnZhciBmN05hdlJpZ2h0ID0ge3JlbmRlcjogZnVuY3Rpb24oKXt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtyZXR1cm4gX2MoJ2Rpdicse3N0YXRpY0NsYXNzOlwicmlnaHRcIixjbGFzczpfdm0uY2xhc3Nlc30sW192bS5fdChcImRlZmF1bHRcIildLDIpfSxzdGF0aWNSZW5kZXJGbnM6IFtdLFxuICBuYW1lOiAnZjctbmF2LXJpZ2h0JyxcbiAgcHJvcHM6IE5hdlJpZ2h0UHJvcHMsXG4gIGNvbXB1dGVkOiB7XG4gICAgY2xhc3NlcygpIHtcbiAgICAgIHJldHVybiBVdGlscy5leHRlbmQoe1xuICAgICAgICBzbGlkaW5nOiB0aGlzLnNsaWRuZyxcbiAgICAgIH0sIE1peGlucy5jb2xvckNsYXNzZXModGhpcykpO1xuICAgIH0sXG4gIH0sXG59O1xuXG5jb25zdCBOYXZUaXRsZVByb3BzID0gVXRpbHMuZXh0ZW5kKHtcbiAgdGl0bGU6IFN0cmluZyxcbiAgc3VidGl0bGU6IFN0cmluZyxcbiAgc2xpZGluZzogQm9vbGVhbixcbn0sIE1peGlucy5jb2xvclByb3BzKTtcblxudmFyIGY3TmF2VGl0bGUgPSB7cmVuZGVyOiBmdW5jdGlvbigpe3ZhciBfdm09dGhpczt2YXIgX2g9X3ZtLiRjcmVhdGVFbGVtZW50O3ZhciBfYz1fdm0uX3NlbGYuX2N8fF9oO3JldHVybiBfYygnZGl2Jyx7c3RhdGljQ2xhc3M6XCJ0aXRsZVwiLGNsYXNzOl92bS5jbGFzc2VzfSxbX3ZtLl90KFwiZGVmYXVsdFwiLFtfdm0uX3YoX3ZtLl9zKF92bS50aXRsZSkpLChfdm0uc3VidGl0bGUpP19jKCdzcGFuJyx7c3RhdGljQ2xhc3M6XCJzdWJ0aXRsZVwifSxbX3ZtLl92KF92bS5fcyhfdm0uc3VidGl0bGUpKV0pOl92bS5fZSgpXSldLDIpfSxzdGF0aWNSZW5kZXJGbnM6IFtdLFxuICBuYW1lOiAnZjctbmF2LXRpdGxlJyxcbiAgcHJvcHM6IE5hdlRpdGxlUHJvcHMsXG4gIGNvbXB1dGVkOiB7XG4gICAgY2xhc3NlcygpIHtcbiAgICAgIHJldHVybiBVdGlscy5leHRlbmQoe1xuICAgICAgICBzbGlkaW5nOiB0aGlzLnNsaWRuZyxcbiAgICAgIH0sIE1peGlucy5jb2xvckNsYXNzZXModGhpcykpO1xuICAgIH0sXG4gIH0sXG59O1xuXG5jb25zdCBOYXZiYXJQcm9wcyA9IFV0aWxzLmV4dGVuZCh7XG4gIGJhY2tMaW5rOiBbQm9vbGVhbiwgU3RyaW5nXSxcbiAgYmFja0xpbmtVcmw6IFN0cmluZyxcbiAgc2xpZGluZzoge1xuICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgZGVmYXVsdDogdHJ1ZSxcbiAgfSxcbiAgdGl0bGU6IFN0cmluZyxcbiAgc3VidGl0bGU6IFN0cmluZyxcbiAgaGlkZGVuOiBCb29sZWFuLFxuICBub1NoYWRvdzogQm9vbGVhbixcbiAgbm9IYWlybGluZTogQm9vbGVhbixcbiAgaW5uZXI6IHtcbiAgICB0eXBlOiBCb29sZWFuLFxuICAgIGRlZmF1bHQ6IHRydWUsXG4gIH0sXG59LCBNaXhpbnMuY29sb3JQcm9wcyk7XG5cbnZhciBmN05hdmJhciA9IHtcbiAgbmFtZTogJ2Y3LW5hdmJhcicsXG4gIGNvbXBvbmVudHM6IHtcbiAgICBmN05hdkxlZnQsXG4gICAgZjdOYXZUaXRsZSxcbiAgfSxcbiAgcmVuZGVyKGMpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBsZXQgaW5uZXJFbDtcbiAgICBsZXQgbGVmdEVsO1xuICAgIGxldCB0aXRsZUVsO1xuICAgIGlmIChzZWxmLmlubmVyKSB7XG4gICAgICBpZiAoc2VsZi5iYWNrTGluaykge1xuICAgICAgICBsZWZ0RWwgPSBjKCdmNy1uYXYtbGVmdCcsIHtcbiAgICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgYmFja0xpbms6IHNlbGYuYmFja0xpbmssXG4gICAgICAgICAgICBiYWNrTGlua1VybDogc2VsZi5iYWNrTGlua1VybCxcbiAgICAgICAgICB9LFxuICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICAnYmFjay1jbGljayc6IHNlbGYub25CYWNrQ2xpY2ssXG4gICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoc2VsZi50aXRsZSB8fCBzZWxmLnN1YnRpdGxlKSB7XG4gICAgICAgIHRpdGxlRWwgPSBjKCdmNy1uYXYtdGl0bGUnLCB7XG4gICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgIHRpdGxlOiBzZWxmLnRpdGxlLFxuICAgICAgICAgICAgc3VidGl0bGU6IHNlbGYuc3VidGl0bGUsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpbm5lckVsID0gYygnZGl2JywgeyByZWY6ICdpbm5lcicsIHN0YXRpY0NsYXNzOiAnbmF2YmFyLWlubmVyJywgY2xhc3M6IHsgc2xpZGluZzogc2VsZi5zbGlkaW5nIH0gfSwgW2xlZnRFbCwgdGl0bGVFbCwgc2VsZi4kc2xvdHMuZGVmYXVsdF0pO1xuICAgIH1cbiAgICByZXR1cm4gYygnZGl2Jywge1xuICAgICAgc3RhdGljQ2xhc3M6ICduYXZiYXInLFxuICAgICAgY2xhc3M6IHNlbGYuY2xhc3NlcyxcbiAgICB9LCBbc2VsZi4kc2xvdHNbJ2JlZm9yZS1pbm5lciddLCBpbm5lckVsLCBzZWxmLiRzbG90c1snYWZ0ZXItaW5uZXInXV0pO1xuICB9LFxuICB1cGRhdGVkKCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIGlmICghc2VsZi4kZjcpIHJldHVybjtcbiAgICBzZWxmLiRuZXh0VGljaygoKSA9PiB7XG4gICAgICBpZiAoc2VsZi4kZWwgJiYgc2VsZi4kZWwuY2hpbGRyZW4gJiYgc2VsZi4kZWwuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgIHNlbGYuJGY3Lm5hdmJhci5zaXplKHNlbGYuJGVsKTtcbiAgICAgIH0gZWxzZSBpZiAoc2VsZi4kcmVmcy5pbm5lcikge1xuICAgICAgICBzZWxmLiRmNy5uYXZiYXIuc2l6ZShzZWxmLiRyZWZzLmlubmVyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcbiAgcHJvcHM6IE5hdmJhclByb3BzLFxuICBjb21wdXRlZDoge1xuICAgIGNsYXNzZXMoKSB7XG4gICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgIHJldHVybiBVdGlscy5leHRlbmQoe1xuICAgICAgICAnbmF2YmFyLWhpZGRlbic6IHNlbGYuaGlkZGVuLFxuICAgICAgICAnbm8tc2hhZG93Jzogc2VsZi5ub1NoYWRvdyxcbiAgICAgICAgJ25vLWhhaXJsaW5lJzogc2VsZi5ub0hhaXJsaW5lLFxuICAgICAgfSwgTWl4aW5zLmNvbG9yQ2xhc3NlcyhzZWxmKSk7XG4gICAgfSxcbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIGhpZGUoYW5pbWF0ZSkge1xuICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICBpZiAoIXNlbGYuJGY3KSByZXR1cm47XG4gICAgICBzZWxmLiRmNy5uYXZiYXIuaGlkZShzZWxmLiRlbCwgYW5pbWF0ZSk7XG4gICAgfSxcbiAgICBzaG93KGFuaW1hdGUpIHtcbiAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgaWYgKCFzZWxmLiRmNykgcmV0dXJuO1xuICAgICAgc2VsZi4kZjcubmF2YmFyLnNob3coc2VsZi4kZWwsIGFuaW1hdGUpO1xuICAgIH0sXG4gICAgc2l6ZSgpIHtcbiAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgaWYgKCFzZWxmLiRmNykgcmV0dXJuO1xuICAgICAgc2VsZi4kZjcubmF2YmFyLnNpemUoc2VsZi4kZWwpO1xuICAgIH0sXG4gICAgb25CYWNrQ2xpY2soZSkge1xuICAgICAgdGhpcy4kZW1pdCgnYmFjay1jbGljaycsIGUpO1xuICAgICAgdGhpcy4kZW1pdCgnY2xpY2s6YmFjaycsIGUpO1xuICAgIH0sXG4gIH0sXG59O1xuXG5jb25zdCBQYWdlQ29udGVudFByb3BzID0gVXRpbHMuZXh0ZW5kKHtcbiAgdGFiOiBCb29sZWFuLFxuICB0YWJBY3RpdmU6IEJvb2xlYW4sXG4gIHB0cjogQm9vbGVhbixcbiAgcHRyRGlzdGFuY2U6IE51bWJlcixcbiAgcHRyUHJlbG9hZGVyOiB7XG4gICAgdHlwZTogQm9vbGVhbixcbiAgICBkZWZhdWx0OiB0cnVlLFxuICB9LFxuICBpbmZpbml0ZTogQm9vbGVhbixcbiAgaW5maW5pdGVUb3A6IEJvb2xlYW4sXG4gIGluZmluaXRlRGlzdGFuY2U6IE51bWJlcixcbiAgaW5maW5pdGVQcmVsb2FkZXI6IHtcbiAgICB0eXBlOiBCb29sZWFuLFxuICAgIGRlZmF1bHQ6IHRydWUsXG4gIH0sXG4gIGhpZGVCYXJzT25TY3JvbGw6IEJvb2xlYW4sXG4gIGhpZGVOYXZiYXJPblNjcm9sbDogQm9vbGVhbixcbiAgaGlkZVRvb2xiYXJPblNjcm9sbDogQm9vbGVhbixcbiAgbWVzc2FnZXNDb250ZW50OiBCb29sZWFuLFxuICBsb2dpblNjcmVlbjogQm9vbGVhbixcbn0sIE1peGlucy5jb2xvclByb3BzKTtcblxudmFyIGY3UGFnZUNvbnRlbnQgPSB7XG4gIG5hbWU6ICdmNy1wYWdlLWNvbnRlbnQnLFxuICByZW5kZXIoYykge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuXG4gICAgbGV0IHB0ckVsO1xuICAgIGxldCBpbmZpbml0ZUVsO1xuXG4gICAgaWYgKHNlbGYucHRyICYmIChzZWxmLnB0clByZWxvYWRlcikpIHtcbiAgICAgIHB0ckVsID0gYygnZGl2JywgeyBzdGF0aWNDbGFzczogJ3B0ci1wcmVsb2FkZXInIH0sIFtcbiAgICAgICAgYygnZGl2JywgeyBzdGF0aWNDbGFzczogJ3ByZWxvYWRlcicgfSksXG4gICAgICAgIGMoJ2RpdicsIHsgc3RhdGljQ2xhc3M6ICdwdHItYXJyb3cnIH0pLFxuICAgICAgXSk7XG4gICAgfVxuICAgIGlmICgoc2VsZi5pbmZpbml0ZSkgJiYgc2VsZi5pbmZpbml0ZVByZWxvYWRlcikge1xuICAgICAgaW5maW5pdGVFbCA9IGMoJ2RpdicsIHsgc3RhdGljQ2xhc3M6ICdwcmVsb2FkZXIgaW5maW5pdGUtc2Nyb2xsLXByZWxvYWRlcicgfSk7XG4gICAgfVxuICAgIHJldHVybiBjKCdkaXYnLCB7XG4gICAgICBzdGF0aWNDbGFzczogJ3BhZ2UtY29udGVudCcsXG4gICAgICBjbGFzczogc2VsZi5jbGFzc2VzLFxuICAgICAgYXR0cnM6IHtcbiAgICAgICAgJ2RhdGEtcHRyLWRpc3RhbmNlJzogc2VsZi5wdHJEaXN0YW5jZSxcbiAgICAgICAgJ2RhdGEtaW5maW5pdGUtZGlzdGFuY2UnOiBzZWxmLmluZmluaXRlRGlzdGFuY2UsXG4gICAgICB9LFxuICAgICAgb246IHtcbiAgICAgICAgJ3B0cjpwdWxsc3RhcnQnOiBzZWxmLm9uUHRyUHVsbFN0YXJ0LFxuICAgICAgICAncHRyOnB1bGxtb3ZlJzogc2VsZi5vblB0clB1bGxNb3ZlLFxuICAgICAgICAncHRyOnB1bGxlbmQnOiBzZWxmLm9uUHRyUHVsbEVuZCxcbiAgICAgICAgJ3B0cjpyZWZyZXNoJzogc2VsZi5vblB0clJlZnJlc2gsXG4gICAgICAgICdwdHI6ZG9uZSc6IHNlbGYub25QdHJSZWZyZXNoRG9uZSxcbiAgICAgICAgaW5maW5pdGU6IHNlbGYub25JbmZpbml0ZSxcbiAgICAgICAgJ3RhYjpzaG93Jzogc2VsZi5vblRhYlNob3csXG4gICAgICAgICd0YWI6aGlkZSc6IHNlbGYub25UYWJIaWRlLFxuICAgICAgfSxcbiAgICB9LCAoc2VsZi5pbmZpbml0ZVRvcCA/IFtwdHJFbCwgaW5maW5pdGVFbCwgc2VsZi4kc2xvdHMuZGVmYXVsdF0gOiBbcHRyRWwsIHNlbGYuJHNsb3RzLmRlZmF1bHQsIGluZmluaXRlRWxdKSk7XG4gIH0sXG4gIHByb3BzOiBQYWdlQ29udGVudFByb3BzLFxuICBjb21wdXRlZDoge1xuICAgIGNsYXNzZXMoKSB7XG4gICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgIHJldHVybiBVdGlscy5leHRlbmQoe1xuICAgICAgICB0YWI6IHNlbGYudGFiLFxuICAgICAgICAndGFiLWFjdGl2ZSc6IHNlbGYudGFiQWN0aXZlLFxuICAgICAgICAncHRyLWNvbnRlbnQnOiBzZWxmLnB0cixcbiAgICAgICAgJ2luZmluaXRlLXNjcm9sbC1jb250ZW50Jzogc2VsZi5pbmZpbml0ZSxcbiAgICAgICAgJ2luZmluaXRlLXNjcm9sbC10b3AnOiBzZWxmLmluZmluaXRlVG9wLFxuICAgICAgICAnaGlkZS1iYXJzLW9uLXNjcm9sbCc6IHNlbGYuaGlkZUJhcnNPblNjcm9sbCxcbiAgICAgICAgJ2hpZGUtbmF2YmFyLW9uLXNjcm9sbCc6IHNlbGYuaGlkZU5hdmJhck9uU2Nyb2xsLFxuICAgICAgICAnaGlkZS10b29sYmFyLW9uLXNjcm9sbCc6IHNlbGYuaGlkZVRvb2xiYXJPblNjcm9sbCxcbiAgICAgICAgJ21lc3NhZ2VzLWNvbnRlbnQnOiBzZWxmLm1lc3NhZ2VzQ29udGVudCxcbiAgICAgICAgJ2xvZ2luLXNjcmVlbi1jb250ZW50Jzogc2VsZi5sb2dpblNjcmVlbixcbiAgICAgIH0sIE1peGlucy5jb2xvckNsYXNzZXMoc2VsZikpO1xuICAgIH0sXG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBvblB0clB1bGxTdGFydChldmVudCkge1xuICAgICAgdGhpcy4kZW1pdCgncHRyOnB1bGxzdGFydCcsIGV2ZW50KTtcbiAgICB9LFxuICAgIG9uUHRyUHVsbE1vdmUoZXZlbnQpIHtcbiAgICAgIHRoaXMuJGVtaXQoJ3B0cjpwdWxsbW92ZScsIGV2ZW50KTtcbiAgICB9LFxuICAgIG9uUHRyUHVsbEVuZChldmVudCkge1xuICAgICAgdGhpcy4kZW1pdCgncHRyOnB1bGxlbmQnLCBldmVudCk7XG4gICAgfSxcbiAgICBvblB0clJlZnJlc2goZXZlbnQpIHtcbiAgICAgIHRoaXMuJGVtaXQoJ3B0cjpyZWZyZXNoJywgZXZlbnQsIGV2ZW50LmRldGFpbCk7XG4gICAgfSxcbiAgICBvblB0clJlZnJlc2hEb25lKGV2ZW50KSB7XG4gICAgICB0aGlzLiRlbWl0KCdwdHI6ZG9uZScsIGV2ZW50KTtcbiAgICB9LFxuICAgIG9uSW5maW5pdGUoZXZlbnQpIHtcbiAgICAgIHRoaXMuJGVtaXQoJ2luZmluaXRlJywgZXZlbnQpO1xuICAgIH0sXG4gICAgb25UYWJTaG93KGUpIHtcbiAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgc2VsZi4kZW1pdCgndGFiOnNob3cnLCBlKTtcbiAgICB9LFxuICAgIG9uVGFiSGlkZShlKSB7XG4gICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgIHNlbGYuJGVtaXQoJ3RhYjpoaWRlJywgZSk7XG4gICAgfSxcbiAgfSxcbn07XG5cbmNvbnN0IFBhZ2VQcm9wcyA9IFV0aWxzLmV4dGVuZCh7XG4gIG5hbWU6IFN0cmluZyxcbiAgc3RhY2tlZDogQm9vbGVhbixcbiAgd2l0aFN1Ym5hdmJhcjogQm9vbGVhbixcbiAgc3VibmF2YmFyOiBCb29sZWFuLFxuICBub05hdmJhcjogQm9vbGVhbixcbiAgbm9Ub29sYmFyOiBCb29sZWFuLFxuICB0YWJzOiBCb29sZWFuLFxuICBwYWdlQ29udGVudDoge1xuICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgZGVmYXVsdDogdHJ1ZSxcbiAgfSxcbiAgbm9Td2lwZWJhY2s6IEJvb2xlYW4sXG4gIC8vIFBhZ2UgQ29udGVudCBQcm9wc1xuICBwdHI6IEJvb2xlYW4sXG4gIHB0ckRpc3RhbmNlOiBOdW1iZXIsXG4gIHB0clByZWxvYWRlcjoge1xuICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgZGVmYXVsdDogdHJ1ZSxcbiAgfSxcbiAgaW5maW5pdGU6IEJvb2xlYW4sXG4gIGluZmluaXRlVG9wOiBCb29sZWFuLFxuICBpbmZpbml0ZURpc3RhbmNlOiBOdW1iZXIsXG4gIGluZmluaXRlUHJlbG9hZGVyOiB7XG4gICAgdHlwZTogQm9vbGVhbixcbiAgICBkZWZhdWx0OiB0cnVlLFxuICB9LFxuICBoaWRlQmFyc09uU2Nyb2xsOiBCb29sZWFuLFxuICBoaWRlTmF2YmFyT25TY3JvbGw6IEJvb2xlYW4sXG4gIGhpZGVUb29sYmFyT25TY3JvbGw6IEJvb2xlYW4sXG4gIG1lc3NhZ2VzQ29udGVudDogQm9vbGVhbixcbiAgbG9naW5TY3JlZW46IEJvb2xlYW4sXG59LCBNaXhpbnMuY29sb3JQcm9wcyk7XG5cbnZhciBmN1BhZ2UgPSB7XG4gIG5hbWU6ICdmNy1wYWdlJyxcbiAgY29tcG9uZW50czoge1xuICAgIGY3UGFnZUNvbnRlbnQsXG4gIH0sXG4gIHJlbmRlcihjKSB7XG4gICAgY29uc3QgZml4ZWRMaXN0ID0gW107XG4gICAgY29uc3Qgc3RhdGljTGlzdCA9IFtdO1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuXG4gICAgbGV0IHBhZ2VDb250ZW50RWw7XG5cbiAgICBjb25zdCBmaXhlZFRhZ3MgPSAoJ25hdmJhciB0b29sYmFyIHRhYmJhciBzdWJuYXZiYXIgc2VhcmNoYmFyIG1lc3NhZ2ViYXIgZmFiIGxpc3QtaW5kZXgnKS5zcGxpdCgnICcpO1xuXG4gICAgbGV0IHRhZztcbiAgICBsZXQgY2hpbGQ7XG4gICAgbGV0IHdpdGhTdWJuYXZiYXI7XG4gICAgbGV0IHdpdGhTZWFyY2hiYXI7XG4gICAgbGV0IHdpdGhNZXNzYWdlcyA9IHNlbGYuJG9wdGlvbnMucHJvcHNEYXRhLndpdGhNZXNzYWdlcztcblxuICAgIGlmIChzZWxmLiRzbG90cy5kZWZhdWx0KSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlbGYuJHNsb3RzLmRlZmF1bHQubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgY2hpbGQgPSBzZWxmLiRzbG90cy5kZWZhdWx0W2ldO1xuICAgICAgICB0YWcgPSBjaGlsZC50YWc7XG4gICAgICAgIGlmICghdGFnKSB7XG4gICAgICAgICAgc3RhdGljTGlzdC5wdXNoKGNoaWxkKTtcbiAgICAgICAgICBjb250aW51ZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgICB9XG4gICAgICAgIGxldCBpc0ZpeGVkID0gZmFsc2U7XG4gICAgICAgIGlmICh0YWcuaW5kZXhPZignc3VibmF2YmFyJykgPj0gMCkgd2l0aFN1Ym5hdmJhciA9IHRydWU7XG4gICAgICAgIGlmICh0YWcuaW5kZXhPZignc2VhcmNoYmFyJykgPj0gMCkgd2l0aFNlYXJjaGJhciA9IHRydWU7XG4gICAgICAgIGlmICh0eXBlb2Ygd2l0aE1lc3NhZ2VzID09PSAndW5kZWZpbmVkJyAmJiB0YWcuaW5kZXhPZignbWVzc2FnZXMnKSA+PSAwKSB3aXRoTWVzc2FnZXMgPSB0cnVlO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGZpeGVkVGFncy5sZW5ndGg7IGogKz0gMSkge1xuICAgICAgICAgIGlmICh0YWcuaW5kZXhPZihmaXhlZFRhZ3Nbal0pID49IDApIHtcbiAgICAgICAgICAgIGlzRml4ZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNGaXhlZCkgZml4ZWRMaXN0LnB1c2goY2hpbGQpO1xuICAgICAgICBlbHNlIHN0YXRpY0xpc3QucHVzaChjaGlsZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGZpeGVkTGlzdC5sZW5ndGggPiAwICYmIHdpdGhTZWFyY2hiYXIpIHtcbiAgICAgIGZpeGVkTGlzdC5wdXNoKGMoJ2RpdicsIHsgY2xhc3M6IHsgJ3NlYXJjaGJhci1vdmVybGF5JzogdHJ1ZSB9IH0pKTtcbiAgICB9XG4gICAgaWYgKHNlbGYucGFnZUNvbnRlbnQpIHtcbiAgICAgIHBhZ2VDb250ZW50RWwgPSBjKCdmNy1wYWdlLWNvbnRlbnQnLCB7XG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgcHRyOiBzZWxmLnB0cixcbiAgICAgICAgICBwdHJEaXN0YW5jZTogc2VsZi5wdHJEaXN0YW5jZSxcbiAgICAgICAgICBwdHJQcmVsb2FkZXI6IHNlbGYucHRyUHJlbG9hZGVyLFxuICAgICAgICAgIGluZmluaXRlOiBzZWxmLmluZmluaXRlLFxuICAgICAgICAgIGluZmluaXRlVG9wOiBzZWxmLmluZmluaXRlVG9wLFxuICAgICAgICAgIGluZmluaXRlRGlzdGFuY2U6IHNlbGYuaW5maW5pdGVEaXN0YW5jZSxcbiAgICAgICAgICBpbmZpbml0ZVByZWxvYWRlcjogc2VsZi5pbmZpbml0ZVByZWxvYWRlcixcbiAgICAgICAgICBoaWRlQmFyc09uU2Nyb2xsOiBzZWxmLmhpZGVCYXJzT25TY3JvbGwsXG4gICAgICAgICAgaGlkZU5hdmJhck9uU2Nyb2xsOiBzZWxmLmhpZGVOYXZiYXJPblNjcm9sbCxcbiAgICAgICAgICBoaWRlVG9vbGJhck9uU2Nyb2xsOiBzZWxmLmhpZGVUb29sYmFyT25TY3JvbGwsXG4gICAgICAgICAgbWVzc2FnZXNDb250ZW50OiBzZWxmLm1lc3NhZ2VzQ29udGVudCB8fCB3aXRoTWVzc2FnZXMsXG4gICAgICAgICAgbG9naW5TY3JlZW46IHNlbGYubG9naW5TY3JlZW4sXG4gICAgICAgIH0sXG4gICAgICAgIG9uOiB7XG4gICAgICAgICAgJ3B0cjpwdWxsc3RhcnQnOiBzZWxmLm9uUHRyUHVsbFN0YXJ0LFxuICAgICAgICAgICdwdHI6cHVsbG1vdmUnOiBzZWxmLm9uUHRyUHVsbE1vdmUsXG4gICAgICAgICAgJ3B0cjpwdWxsZW5kJzogc2VsZi5vblB0clB1bGxFbmQsXG4gICAgICAgICAgJ3B0cjpyZWZyZXNoJzogc2VsZi5vblB0clJlZnJlc2gsXG4gICAgICAgICAgJ3B0cjpkb25lJzogc2VsZi5vblB0clJlZnJlc2hEb25lLFxuICAgICAgICAgIGluZmluaXRlOiBzZWxmLm9uSW5maW5pdGUsXG4gICAgICAgIH0sXG4gICAgICB9LCBbc2VsZi4kc2xvdHMuc3RhdGljLCBzdGF0aWNMaXN0XSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhZ2VDb250ZW50RWwgPSBbXTtcbiAgICAgIGlmIChzZWxmLiRzbG90cy5kZWZhdWx0ICYmIGZpeGVkTGlzdC5sZW5ndGggPiAwKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VsZi4kc2xvdHMuZGVmYXVsdC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgIGlmIChmaXhlZExpc3QuaW5kZXhPZihzZWxmLiRzbG90cy5kZWZhdWx0W2ldKSA8IDApIHtcbiAgICAgICAgICAgIHBhZ2VDb250ZW50RWwucHVzaChzZWxmLiRzbG90cy5kZWZhdWx0W2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhZ2VDb250ZW50RWwgPSBbc2VsZi4kc2xvdHMuZGVmYXVsdF07XG4gICAgICB9XG4gICAgfVxuICAgIGZpeGVkTGlzdC5wdXNoKHNlbGYuJHNsb3RzLmZpeGVkKTtcblxuICAgIGlmICh3aXRoU3VibmF2YmFyKSBzZWxmLmNsYXNzZXNbJ3BhZ2Utd2l0aC1zdWJuYXZiYXInXSA9IHRydWU7XG5cbiAgICBjb25zdCBwYWdlRWwgPSBjKCdkaXYnLCB7XG4gICAgICBzdGF0aWNDbGFzczogJ3BhZ2UnLFxuICAgICAgY2xhc3M6IHNlbGYuY2xhc3NlcyxcbiAgICAgIGF0dHJzOiB7XG4gICAgICAgICdkYXRhLW5hbWUnOiBzZWxmLm5hbWUsXG4gICAgICB9LFxuICAgICAgb246IHtcbiAgICAgICAgJ3BhZ2U6bW91bnRlZCc6IHNlbGYub25QYWdlTW91bnRlZCxcbiAgICAgICAgJ3BhZ2U6aW5pdCc6IHNlbGYub25QYWdlSW5pdCxcbiAgICAgICAgJ3BhZ2U6cmVpbml0Jzogc2VsZi5vblBhZ2VSZWluaXQsXG4gICAgICAgICdwYWdlOmJlZm9yZWluJzogc2VsZi5vblBhZ2VCZWZvcmVJbixcbiAgICAgICAgJ3BhZ2U6YWZ0ZXJpbic6IHNlbGYub25QYWdlQWZ0ZXJJbixcbiAgICAgICAgJ3BhZ2U6YmVmb3Jlb3V0Jzogc2VsZi5vblBhZ2VCZWZvcmVPdXQsXG4gICAgICAgICdwYWdlOmFmdGVyb3V0Jzogc2VsZi5vblBhZ2VBZnRlck91dCxcbiAgICAgICAgJ3BhZ2U6YmVmb3JlcmVtb3ZlJzogc2VsZi5vblBhZ2VCZWZvcmVSZW1vdmUsXG4gICAgICB9LFxuICAgIH0sIFtmaXhlZExpc3QsIHBhZ2VDb250ZW50RWxdKTtcblxuICAgIHJldHVybiBwYWdlRWw7XG4gIH0sXG4gIHByb3BzOiBQYWdlUHJvcHMsXG4gIGNvbXB1dGVkOiB7XG4gICAgY2xhc3NlcygpIHtcbiAgICAgIHJldHVybiBVdGlscy5leHRlbmQoe1xuICAgICAgICBzdGFja2VkOiB0aGlzLnN0YWNrZWQsXG4gICAgICAgIHRhYnM6IHRoaXMudGFicyxcbiAgICAgICAgJ3BhZ2Utd2l0aC1zdWJuYXZiYXInOiB0aGlzLnN1Ym5hdmJhciB8fCB0aGlzLndpdGhTdWJuYXZiYXIsXG4gICAgICAgICduby1uYXZiYXInOiB0aGlzLm5vTmF2YmFyLFxuICAgICAgICAnbm8tdG9vbGJhcic6IHRoaXMubm9Ub29sYmFyLFxuICAgICAgICAnbm8tc3dpcGViYWNrJzogdGhpcy5ub1N3aXBlYmFjayxcbiAgICAgIH0sIE1peGlucy5jb2xvckNsYXNzZXModGhpcykpO1xuICAgIH0sXG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBvblB0clB1bGxTdGFydChldmVudCkge1xuICAgICAgdGhpcy4kZW1pdCgncHRyOnB1bGxzdGFydCcsIGV2ZW50KTtcbiAgICB9LFxuICAgIG9uUHRyUHVsbE1vdmUoZXZlbnQpIHtcbiAgICAgIHRoaXMuJGVtaXQoJ3B0cjpwdWxsbW92ZScsIGV2ZW50KTtcbiAgICB9LFxuICAgIG9uUHRyUHVsbEVuZChldmVudCkge1xuICAgICAgdGhpcy4kZW1pdCgncHRyOnB1bGxlbmQnLCBldmVudCk7XG4gICAgfSxcbiAgICBvblB0clJlZnJlc2goZXZlbnQpIHtcbiAgICAgIHRoaXMuJGVtaXQoJ3B0cjpyZWZyZXNoJywgZXZlbnQsIGV2ZW50LmRldGFpbCk7XG4gICAgfSxcbiAgICBvblB0clJlZnJlc2hEb25lKGV2ZW50KSB7XG4gICAgICB0aGlzLiRlbWl0KCdwdHI6ZG9uZScsIGV2ZW50KTtcbiAgICB9LFxuICAgIG9uSW5maW5pdGUoZXZlbnQpIHtcbiAgICAgIHRoaXMuJGVtaXQoJ2luZmluaXRlJywgZXZlbnQpO1xuICAgIH0sXG4gICAgb25QYWdlTW91bnRlZChldmVudCkge1xuICAgICAgdGhpcy4kZW1pdCgncGFnZTptb3VudGVkJywgZXZlbnQsIGV2ZW50LmRldGFpbCk7XG4gICAgfSxcbiAgICBvblBhZ2VJbml0KGV2ZW50KSB7XG4gICAgICB0aGlzLiRlbWl0KCdwYWdlOmluaXQnLCBldmVudCwgZXZlbnQuZGV0YWlsKTtcbiAgICB9LFxuICAgIG9uUGFnZVJlaW5pdChldmVudCkge1xuICAgICAgdGhpcy4kZW1pdCgncGFnZTpyZWluaXQnLCBldmVudCwgZXZlbnQuZGV0YWlsKTtcbiAgICB9LFxuICAgIG9uUGFnZUJlZm9yZUluKGV2ZW50KSB7XG4gICAgICB0aGlzLiRlbWl0KCdwYWdlOmJlZm9yZWluJywgZXZlbnQsIGV2ZW50LmRldGFpbCk7XG4gICAgfSxcbiAgICBvblBhZ2VCZWZvcmVPdXQoZXZlbnQpIHtcbiAgICAgIHRoaXMuJGVtaXQoJ3BhZ2U6YmVmb3Jlb3V0JywgZXZlbnQsIGV2ZW50LmRldGFpbCk7XG4gICAgfSxcbiAgICBvblBhZ2VBZnRlck91dChldmVudCkge1xuICAgICAgdGhpcy4kZW1pdCgncGFnZTphZnRlcm91dCcsIGV2ZW50LCBldmVudC5kZXRhaWwpO1xuICAgIH0sXG4gICAgb25QYWdlQWZ0ZXJJbihldmVudCkge1xuICAgICAgdGhpcy4kZW1pdCgncGFnZTphZnRlcmluJywgZXZlbnQsIGV2ZW50LmRldGFpbCk7XG4gICAgfSxcbiAgICBvblBhZ2VCZWZvcmVSZW1vdmUoZXZlbnQpIHtcbiAgICAgIHRoaXMuJGVtaXQoJ3BhZ2U6YmVmb3JlcmVtb3ZlJywgZXZlbnQsIGV2ZW50LmRldGFpbCk7XG4gICAgfSxcbiAgfSxcbn07XG5cbmNvbnN0IFBhbmVsUHJvcHMgPSBVdGlscy5leHRlbmQoXG4gIHtcbiAgICBzaWRlOiBTdHJpbmcsXG4gICAgZWZmZWN0OiBTdHJpbmcsXG4gICAgY292ZXI6IEJvb2xlYW4sXG4gICAgcmV2ZWFsOiBCb29sZWFuLFxuICAgIGxlZnQ6IEJvb2xlYW4sXG4gICAgcmlnaHQ6IEJvb2xlYW4sXG4gICAgb3BlbmVkOiBCb29sZWFuLFxuICB9LFxuICBNaXhpbnMuY29sb3JQcm9wc1xuKTtcblxudmFyIGY3UGFuZWwgPSB7cmVuZGVyOiBmdW5jdGlvbigpe3ZhciBfdm09dGhpczt2YXIgX2g9X3ZtLiRjcmVhdGVFbGVtZW50O3ZhciBfYz1fdm0uX3NlbGYuX2N8fF9oO3JldHVybiBfYygnZGl2Jyx7c3RhdGljQ2xhc3M6XCJwYW5lbFwiLGNsYXNzOl92bS5jbGFzc2VzLG9uOntcInBhbmVsOm9wZW5cIjpfdm0ub25PcGVuLFwicGFuZWw6b3BlbmVkXCI6X3ZtLm9uT3BlbmVkLFwicGFuZWw6Y2xvc2VcIjpfdm0ub25DbG9zZSxcInBhbmVsOmNsb3NlZFwiOl92bS5vbkNsb3NlZCxcInBhbmVsOmJhY2tkcm9wLWNsaWNrXCI6X3ZtLm9uQmFja2Ryb3BDbGljayxcInBhbmVsOnN3aXBlXCI6X3ZtLm9uUGFuZWxTd2lwZSxcInBhbmVsOnN3aXBlb3BlblwiOl92bS5vblBhbmVsU3dpcGVPcGVuLFwicGFuZWw6YnJlYWtwb2ludFwiOl92bS5vbkJyZWFrcG9pbnR9fSxbX3ZtLl90KFwiZGVmYXVsdFwiKV0sMil9LHN0YXRpY1JlbmRlckZuczogW10sXG4gIHByb3BzOiBQYW5lbFByb3BzLFxuICBjb21wdXRlZDoge1xuICAgIGNsYXNzZXMoKSB7XG4gICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgIGNvbnN0IHNpZGUgPSBzZWxmLnNpZGUgfHwgKHNlbGYubGVmdCA/ICdsZWZ0JyA6ICdyaWdodCcpO1xuICAgICAgY29uc3QgZWZmZWN0ID0gc2VsZi5lZmZlY3QgfHwgKHNlbGYucmV2ZWFsID8gJ3JldmVhbCcgOiAnY292ZXInKTtcbiAgICAgIHJldHVybiBVdGlscy5leHRlbmQoXG4gICAgICAgIHtcbiAgICAgICAgICAncGFuZWwtYWN0aXZlJzogc2VsZi5vcGVuZWQsXG4gICAgICAgICAgW2BwYW5lbC0ke3NpZGV9YF06IHNpZGUsXG4gICAgICAgICAgW2BwYW5lbC0ke2VmZmVjdH1gXTogZWZmZWN0LFxuICAgICAgICB9LFxuICAgICAgICBNaXhpbnMuY29sb3JDbGFzc2VzKHNlbGYpXG4gICAgICApO1xuICAgIH0sXG4gIH0sXG4gIHdhdGNoOiB7XG4gICAgb3BlbmVkKG9wZW5lZCkge1xuICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICBpZiAoIXNlbGYuJGY3KSByZXR1cm47XG4gICAgICBjb25zdCBzaWRlID0gc2VsZi5zaWRlIHx8IChzZWxmLmxlZnQgPyAnbGVmdCcgOiAncmlnaHQnKTtcbiAgICAgIGlmIChvcGVuZWQpIHtcbiAgICAgICAgc2VsZi4kZjcucGFuZWwub3BlbihzaWRlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGYuJGY3LnBhbmVsLm9wZW4oc2lkZSk7XG4gICAgICB9XG4gICAgfSxcbiAgfSxcbiAgYmVmb3JlRGVzdHJveSgpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBpZiAoc2VsZi5mN1BhbmVsKSBzZWxmLmY3UGFuZWwuZGVzdHJveSgpO1xuICB9LFxuICBtb3VudGVkKCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIGlmIChzZWxmLm9wZW5lZCkge1xuICAgICAgc2VsZi4kZWwuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgfVxuICAgIGNvbnN0ICQgPSBzZWxmLiQ7XG4gICAgaWYgKCEkKSByZXR1cm47XG4gICAgY29uc3Qgc2lkZSA9IHNlbGYuc2lkZSB8fCAoc2VsZi5sZWZ0ID8gJ2xlZnQnIDogJ3JpZ2h0Jyk7XG4gICAgY29uc3QgZWZmZWN0ID0gc2VsZi5lZmZlY3QgfHwgKHNlbGYucmV2ZWFsID8gJ3JldmVhbCcgOiAnY292ZXInKTtcbiAgICBpZiAoc2VsZi5vcGVuZWQpIHtcbiAgICAgICQoJ2h0bWwnKS5hZGRDbGFzcyhgd2l0aC1wYW5lbC0ke3NpZGV9LSR7ZWZmZWN0fWApO1xuICAgIH1cbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIG9uT3BlbihldmVudCkge1xuICAgICAgdGhpcy4kZW1pdCgncGFuZWw6b3BlbicsIGV2ZW50KTtcbiAgICB9LFxuICAgIG9uT3BlbmVkKGV2ZW50KSB7XG4gICAgICB0aGlzLiRlbWl0KCdwYW5lbDpvcGVuZWQnLCBldmVudCk7XG4gICAgfSxcbiAgICBvbkNsb3NlKGV2ZW50KSB7XG4gICAgICB0aGlzLiRlbWl0KCdwYW5lbDpjbG9zZScsIGV2ZW50KTtcbiAgICB9LFxuICAgIG9uQ2xvc2VkKGV2ZW50KSB7XG4gICAgICB0aGlzLiRlbWl0KCdwYW5lbDpjbG9zZWQnLCBldmVudCk7XG4gICAgfSxcbiAgICBvbkJhY2tkcm9wQ2xpY2soZXZlbnQpIHtcbiAgICAgIHRoaXMuJGVtaXQoJ3BhbmVsOmJhY2tkcm9wLWNsaWNrJywgZXZlbnQpO1xuICAgIH0sXG4gICAgb25QYW5lbFN3aXBlKGV2ZW50KSB7XG4gICAgICB0aGlzLiRlbWl0KCdwYW5lbDpzd2lwZScsIGV2ZW50KTtcbiAgICB9LFxuICAgIG9uUGFuZWxTd2lwZU9wZW4oZXZlbnQpIHtcbiAgICAgIHRoaXMuJGVtaXQoJ3BhbmVsOnN3aXBlb3BlbicsIGV2ZW50KTtcbiAgICB9LFxuICAgIG9uQnJlYWtwb2ludChldmVudCkge1xuICAgICAgdGhpcy4kZW1pdCgncGFuZWw6YnJlYWtwb2ludCcsIGV2ZW50KTtcbiAgICB9LFxuICAgIG9uRjdSZWFkeSgpIHtcbiAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgY29uc3QgJCA9IHNlbGYuJCQ7XG4gICAgICBpZiAoISQpIHJldHVybjtcbiAgICAgIGlmICgkKCcucGFuZWwtYmFja2Ryb3AnKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgJCgnPGRpdiBjbGFzcz1cInBhbmVsLWJhY2tkcm9wXCI+PC9kaXY+JykuaW5zZXJ0QmVmb3JlKHNlbGYuJGVsKTtcbiAgICAgIH1cbiAgICAgIHNlbGYuZjdQYW5lbCA9IHNlbGYuJGY3LnBhbmVsLmNyZWF0ZSh7IGVsOiBzZWxmLiRlbCB9KTtcbiAgICB9LFxuICAgIG9wZW4oYW5pbWF0ZSkge1xuICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICBpZiAoIXNlbGYuJGY3KSByZXR1cm47XG4gICAgICBjb25zdCBzaWRlID0gc2VsZi5zaWRlIHx8IChzZWxmLmxlZnQgPyAnbGVmdCcgOiAncmlnaHQnKTtcbiAgICAgIHNlbGYuJGY3LnBhbmVsLm9wZW4oc2lkZSwgYW5pbWF0ZSk7XG4gICAgfSxcbiAgICBjbG9zZShhbmltYXRlKSB7XG4gICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgIGlmICghc2VsZi4kZjcpIHJldHVybjtcbiAgICAgIGNvbnN0IHNpZGUgPSBzZWxmLnNpZGUgfHwgKHNlbGYubGVmdCA/ICdsZWZ0JyA6ICdyaWdodCcpO1xuICAgICAgc2VsZi4kZjcucGFuZWwuY2xvc2Uoc2lkZSwgYW5pbWF0ZSk7XG4gICAgfSxcbiAgfSxcbn07XG5cbnZhciBmN1Bob3RvQnJvd3NlciA9IHtcbiAgbmFtZTogJ2Y3LXBob3RvLWJyb3dzZXInLFxuICByZW5kZXIoKSB7fSxcbiAgYmVmb3JlRGVzdHJveSgpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBpZiAoc2VsZi5mN1Bob3RvQnJvd3NlciAmJiBzZWxmLmY3UGhvdG9Ccm93c2VyLmRlc3Ryb3kpIHNlbGYuZjdQaG90b0Jyb3dzZXIuZGVzdHJveSgpO1xuICB9LFxuICB3YXRjaDoge1xuICAgIHBob3RvcyhuZXdWYWx1ZSkge1xuICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICBjb25zdCBwYiA9IHNlbGYuZjdQaG90b0Jyb3dzZXI7XG4gICAgICBpZiAoIXBiKSByZXR1cm47XG4gICAgICBzZWxmLmY3UGhvdG9Ccm93c2VyLnBob3RvcyA9IG5ld1ZhbHVlO1xuICAgICAgaWYgKHBiLm9wZW5lZCAmJiBwYi5zd2lwZXIpIHtcbiAgICAgICAgcGIuc3dpcGVyLnVwZGF0ZSgpO1xuICAgICAgfVxuICAgIH0sXG4gIH0sXG4gIHByb3BzOiB7XG4gICAgaW5pdDoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgfSxcbiAgICBwYXJhbXM6IE9iamVjdCxcbiAgICBwaG90b3M6IEFycmF5LFxuICAgIGV4cG9zaXRpb246IEJvb2xlYW4sXG4gICAgZXhwb3NpdGlvbkhpZGVDYXB0aW9uczogQm9vbGVhbixcbiAgICB0eXBlOiBTdHJpbmcsXG4gICAgbmF2YmFyOiBCb29sZWFuLFxuICAgIHRvb2xiYXI6IEJvb2xlYW4sXG4gICAgdGhlbWU6IFN0cmluZyxcbiAgICBjYXB0aW9uc1RoZW1lOiBTdHJpbmcsXG4gICAgc3dpcGVUb0Nsb3NlOiBCb29sZWFuLFxuICAgIGJhY2tMaW5rVGV4dDogU3RyaW5nLFxuICAgIG5hdmJhck9mVGV4dDogU3RyaW5nLFxuICAgIGljb25zQ29sb3I6IFN0cmluZyxcbiAgICBzd2lwZXI6IE9iamVjdCxcbiAgICB1cmw6IFN0cmluZyxcbiAgICB2aWV3OiBbU3RyaW5nLCBPYmplY3RdLFxuICAgIHJvdXRhYmxlTW9kYWxzOiBCb29sZWFuLFxuICAgIHJlbmRlck5hdmJhcjogRnVuY3Rpb24sXG4gICAgcmVuZGVyVG9vbGJhcjogRnVuY3Rpb24sXG4gICAgcmVuZGVyQ2FwdGlvbjogRnVuY3Rpb24sXG4gICAgcmVuZGVyT2JqZWN0OiBGdW5jdGlvbixcbiAgICByZW5kZXJMYXp5UGhvdG86IEZ1bmN0aW9uLFxuICAgIHJlbmRlclBob3RvOiBGdW5jdGlvbixcbiAgICByZW5kZXJQYWdlOiBGdW5jdGlvbixcbiAgICByZW5kZXJQb3B1cDogRnVuY3Rpb24sXG4gICAgcmVuZGVyU3RhbmRhbG9uZTogRnVuY3Rpb24sXG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBvcGVuKGluZGV4KSB7XG4gICAgICByZXR1cm4gdGhpcy5mN1Bob3RvQnJvd3Nlci5vcGVuKGluZGV4KTtcbiAgICB9LFxuICAgIGNsb3NlKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZjdQaG90b0Jyb3dzZXIuY2xvc2UoKTtcbiAgICB9LFxuICAgIGV4cG9zaXRpb25Ub2dnbGUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5mN1Bob3RvQnJvd3Nlci5leHBvc2l0aW9uVG9nZ2xlKCk7XG4gICAgfSxcbiAgICBleHBvc2l0aW9uRW5hYmxlKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZjdQaG90b0Jyb3dzZXIuZXhwb3NpdGlvbkVuYWJsZSgpO1xuICAgIH0sXG4gICAgZXhwb3NpdGlvbkRpc2FibGUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5mN1Bob3RvQnJvd3Nlci5leHBvc2l0aW9uRGlzYWJsZSgpO1xuICAgIH0sXG4gICAgb25GN0luaXQoZjcpIHtcbiAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgLy8gSW5pdCBWaXJ0dWFsIExpc3RcbiAgICAgIGlmICghc2VsZi5pbml0KSByZXR1cm47XG4gICAgICBsZXQgcGFyYW1zO1xuXG4gICAgICBpZiAodHlwZW9mIHNlbGYucGFyYW1zICE9PSAndW5kZWZpbmVkJykgcGFyYW1zID0gc2VsZi5wYXJhbXM7XG4gICAgICBlbHNlIHBhcmFtcyA9IHNlbGYuJG9wdGlvbnMucHJvcHNEYXRhO1xuXG4gICAgICBwYXJhbXMgPSBVdGlscy5leHRlbmQoe30sIHBhcmFtcywge1xuICAgICAgICBvbjoge1xuICAgICAgICAgIG9wZW4oKSB7XG4gICAgICAgICAgICBzZWxmLiRlbWl0KCdwaG90b2Jyb3dzZXI6b3BlbicpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgY2xvc2UoKSB7XG4gICAgICAgICAgICBzZWxmLiRlbWl0KCdwaG90b2Jyb3dzZXI6Y2xvc2UnKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIG9wZW5lZCgpIHtcbiAgICAgICAgICAgIHNlbGYuJGVtaXQoJ3Bob3RvYnJvd3NlcjpvcGVuZWQnKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNsb3NlZCgpIHtcbiAgICAgICAgICAgIHNlbGYuJGVtaXQoJ3Bob3RvYnJvd3NlcjpjbG9zZWQnKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHN3aXBlVG9DbG9zZSgpIHtcbiAgICAgICAgICAgIHNlbGYuJGVtaXQoJ3Bob3RvYnJvd3Nlcjpzd2lwZXRvY2xvc2UnKTtcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgfSk7XG5cbiAgICAgIHNlbGYuZjdQaG90b0Jyb3dzZXIgPSBmNy5waG90b0Jyb3dzZXIuY3JlYXRlKHBhcmFtcyk7XG4gICAgfSxcbiAgfSxcbn07XG5cbmNvbnN0IFBvcG92ZXJQcm9wcyA9IFV0aWxzLmV4dGVuZChcbiAge1xuICAgIG9wZW5lZDogQm9vbGVhbixcbiAgICB0YXJnZXQ6IFtTdHJpbmcsIE9iamVjdF0sXG4gIH0sXG4gIE1peGlucy5jb2xvclByb3BzXG4pO1xuXG52YXIgZjdQb3BvdmVyID0ge1xuICBuYW1lOiAnZjctcG9wb3ZlcicsXG4gIHJlbmRlcihjKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgY29uc3QgYW5nbGVFbCA9IGMoJ2RpdicsIHsgc3RhdGljQ2xhc3M6ICdwb3BvdmVyLWFuZ2xlJyB9KTtcbiAgICBjb25zdCBpbm5lckVsID0gYygnZGl2JywgeyBzdGF0aWNDbGFzczogJ3BvcG92ZXItaW5uZXInIH0sIHNlbGYuJHNsb3RzLmRlZmF1bHQpO1xuICAgIHJldHVybiBjKCdkaXYnLCB7XG4gICAgICBjbGFzczogc2VsZi5jbGFzc2VzLFxuICAgICAgc3RhdGljQ2xhc3M6ICdwb3BvdmVyJyxcbiAgICAgIG9uOiB7XG4gICAgICAgICdwb3BvdmVyOm9wZW4nOiBzZWxmLm9uT3BlbixcbiAgICAgICAgJ3BvcG92ZXI6b3BlbmVkJzogc2VsZi5vbk9wZW5lZCxcbiAgICAgICAgJ3BvcG92ZXI6Y2xvc2UnOiBzZWxmLm9uQ2xvc2UsXG4gICAgICAgICdwb3BvdmVyOmNsb3NlZCc6IHNlbGYub25DbG9zZWQsXG4gICAgICB9LFxuICAgIH0sIFthbmdsZUVsLCBpbm5lckVsXSk7XG4gIH0sXG4gIHdhdGNoOiB7XG4gICAgb3BlbmVkKG9wZW5lZCkge1xuICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICBpZiAoIXNlbGYuZjdQb3BvdmVyKSByZXR1cm47XG4gICAgICBpZiAob3BlbmVkKSB7XG4gICAgICAgIHNlbGYuZjdQb3BvdmVyLm9wZW4oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGYuZjdQb3BvdmVyLmNsb3NlKCk7XG4gICAgICB9XG4gICAgfSxcbiAgfSxcbiAgcHJvcHM6IFBvcG92ZXJQcm9wcyxcbiAgY29tcHV0ZWQ6IHtcbiAgICBjbGFzc2VzKCkge1xuICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICByZXR1cm4gTWl4aW5zLmNvbG9yQ2xhc3NlcyhzZWxmKTtcbiAgICB9LFxuICB9LFxuICBiZWZvcmVEZXN0cm95KCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIGlmIChzZWxmLmY3UG9wb3Zlcikgc2VsZi5mN1BvcG92ZXIuZGVzdHJveSgpO1xuICB9LFxuICBtZXRob2RzOiB7XG4gICAgb25PcGVuKGV2ZW50KSB7XG4gICAgICB0aGlzLiRlbWl0KCdwb3BvdmVyOm9wZW4nLCBldmVudCk7XG4gICAgfSxcbiAgICBvbk9wZW5lZChldmVudCkge1xuICAgICAgdGhpcy4kZW1pdCgncG9wb3ZlcjpvcGVuZWQnLCBldmVudCk7XG4gICAgfSxcbiAgICBvbkNsb3NlKGV2ZW50KSB7XG4gICAgICB0aGlzLiRlbWl0KCdwb3BvdmVyOmNsb3NlJywgZXZlbnQpO1xuICAgIH0sXG4gICAgb25DbG9zZWQoZXZlbnQpIHtcbiAgICAgIHRoaXMuJGVtaXQoJ3BvcG92ZXI6Y2xvc2VkJywgZXZlbnQpO1xuICAgIH0sXG4gICAgb3Blbih0YXJnZXQsIGFuaW1hdGUpIHtcbiAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgaWYgKCFzZWxmLiRmNykgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiBzZWxmLiRmNy5wb3BvdmVyLm9wZW4oc2VsZi4kZWwsIHRhcmdldCwgYW5pbWF0ZSk7XG4gICAgfSxcbiAgICBjbG9zZShhbmltYXRlKSB7XG4gICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgIGlmICghc2VsZi4kZjcpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gc2VsZi4kZjcuc2hlZXQuY2xvc2Uoc2VsZi4kZWwsIGFuaW1hdGUpO1xuICAgIH0sXG4gICAgb25GN1JlYWR5KCkge1xuICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICBjb25zdCBwb3BvdmVyUGFyYW1zID0ge1xuICAgICAgICBlbDogc2VsZi4kZWwsXG4gICAgICB9O1xuICAgICAgaWYgKHNlbGYudGFyZ2V0KSBwb3BvdmVyUGFyYW1zLnRhcmdldEVsID0gc2VsZi50YXJnZXQ7XG4gICAgICBzZWxmLmY3UG9wb3ZlciA9IHNlbGYuJGY3LnBvcG92ZXIuY3JlYXRlKHBvcG92ZXJQYXJhbXMpO1xuICAgICAgaWYgKHNlbGYub3BlbmVkICYmIHNlbGYudGFyZ2V0KSB7XG4gICAgICAgIHNlbGYuZjdQb3BvdmVyLm9wZW4oc2VsZi50YXJnZXQsIGZhbHNlKTtcbiAgICAgIH1cbiAgICB9LFxuICB9LFxufTtcblxuY29uc3QgUG9wdXBQcm9wcyA9IFV0aWxzLmV4dGVuZChcbiAge1xuICAgICd0YWJsZXQtZnVsbHNjcmVlbic6IEJvb2xlYW4sXG4gICAgb3BlbmVkOiBCb29sZWFuLFxuICB9LFxuICBNaXhpbnMuY29sb3JQcm9wc1xuKTtcblxudmFyIGY3UG9wdXAgPSB7XG4gIG5hbWU6ICdmNy1wb3B1cCcsXG4gIHJlbmRlcihjKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIGMoJ2RpdicsIHtcbiAgICAgIHN0YXRpY0NsYXNzOiAncG9wdXAnLFxuICAgICAgY2xhc3M6IHNlbGYuY2xhc3NlcyxcbiAgICAgIG9uOiB7XG4gICAgICAgICdwb3B1cDpvcGVuJzogc2VsZi5vbk9wZW4sXG4gICAgICAgICdwb3B1cDpvcGVuZWQnOiBzZWxmLm9uT3BlbmVkLFxuICAgICAgICAncG9wdXA6Y2xvc2UnOiBzZWxmLm9uQ2xvc2UsXG4gICAgICAgICdwb3B1cDpjbG9zZWQnOiBzZWxmLm9uQ2xvc2VkLFxuICAgICAgfSxcbiAgICB9LCBzZWxmLiRzbG90cy5kZWZhdWx0KTtcbiAgfSxcbiAgd2F0Y2g6IHtcbiAgICBvcGVuZWQob3BlbmVkKSB7XG4gICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgIGlmICghc2VsZi5mN1BvcHVwKSByZXR1cm47XG4gICAgICBpZiAob3BlbmVkKSB7XG4gICAgICAgIHNlbGYuZjdQb3B1cC5vcGVuKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxmLmY3UG9wdXAuY2xvc2UoKTtcbiAgICAgIH1cbiAgICB9LFxuICB9LFxuICBwcm9wczogUG9wdXBQcm9wcyxcbiAgY29tcHV0ZWQ6IHtcbiAgICBjbGFzc2VzKCkge1xuICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICByZXR1cm4gVXRpbHMuZXh0ZW5kKHtcbiAgICAgICAgJ3BvcHVwLXRhYmxldC1mdWxsc2NyZWVuJzogc2VsZi50YWJsZXRGdWxsc2NyZWVuLFxuICAgICAgfSwgTWl4aW5zLmNvbG9yQ2xhc3NlcyhzZWxmKSk7XG4gICAgfSxcbiAgfSxcbiAgYmVmb3JlRGVzdHJveSgpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBpZiAoc2VsZi5mN1BvcHVwKSBzZWxmLmY3UG9wdXAuZGVzdHJveSgpO1xuICB9LFxuICBtZXRob2RzOiB7XG4gICAgb25PcGVuKGV2ZW50KSB7XG4gICAgICB0aGlzLiRlbWl0KCdwb3B1cDpvcGVuJywgZXZlbnQpO1xuICAgIH0sXG4gICAgb25PcGVuZWQoZXZlbnQpIHtcbiAgICAgIHRoaXMuJGVtaXQoJ3BvcHVwOm9wZW5lZCcsIGV2ZW50KTtcbiAgICB9LFxuICAgIG9uQ2xvc2UoZXZlbnQpIHtcbiAgICAgIHRoaXMuJGVtaXQoJ3BvcHVwOmNsb3NlJywgZXZlbnQpO1xuICAgIH0sXG4gICAgb25DbG9zZWQoZXZlbnQpIHtcbiAgICAgIHRoaXMuJGVtaXQoJ3BvcHVwOmNsb3NlZCcsIGV2ZW50KTtcbiAgICB9LFxuICAgIG9wZW4oYW5pbWF0ZSkge1xuICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICBpZiAoIXNlbGYuJGY3KSByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIHNlbGYuJGY3LnBvcHVwLm9wZW4oc2VsZi4kZWwsIGFuaW1hdGUpO1xuICAgIH0sXG4gICAgY2xvc2UoYW5pbWF0ZSkge1xuICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICBpZiAoIXNlbGYuJGY3KSByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIHNlbGYuJGY3LnBvcHVwLmNsb3NlKHNlbGYuJGVsLCBhbmltYXRlKTtcbiAgICB9LFxuICAgIG9uRjdSZWFkeSgpIHtcbiAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgc2VsZi5mN1BvcHVwID0gc2VsZi4kZjcucG9wdXAuY3JlYXRlKHtcbiAgICAgICAgZWw6IHNlbGYuJGVsLFxuICAgICAgfSk7XG4gICAgICBpZiAoc2VsZi5vcGVuZWQpIHtcbiAgICAgICAgc2VsZi5mN1BvcHVwLm9wZW4oZmFsc2UpO1xuICAgICAgfVxuICAgIH0sXG4gIH0sXG59O1xuXG5jb25zdCBQcmVsb2FkZXJQcm9wcyA9IFV0aWxzLmV4dGVuZCh7XG4gIHNpemU6IFtOdW1iZXIsIFN0cmluZ10sXG59LCBNaXhpbnMuY29sb3JQcm9wcyk7XG5cbnZhciBmN1ByZWxvYWRlciA9IHtyZW5kZXI6IGZ1bmN0aW9uKCl7dmFyIF92bT10aGlzO3ZhciBfaD1fdm0uJGNyZWF0ZUVsZW1lbnQ7dmFyIF9jPV92bS5fc2VsZi5fY3x8X2g7cmV0dXJuIF9jKCdzcGFuJyx7c3RhdGljQ2xhc3M6XCJwcmVsb2FkZXJcIixjbGFzczpfdm0uY2xhc3NlcyxzdHlsZTooeyd3aWR0aCc6IChfdm0uc2l6ZUNvbXB1dGVkID8gYCR7X3ZtLnNpemVDb21wdXRlZH1weGAgOiAnJyksICdoZWlnaHQnOiAoX3ZtLnNpemVDb21wdXRlZCA/IGAke192bS5zaXplQ29tcHV0ZWR9cHhgIDogJycpfSl9LFsoX3ZtLiR0aGVtZS5tZCk/X2MoJ3NwYW4nLHtzdGF0aWNDbGFzczpcInByZWxvYWRlci1pbm5lclwifSxbX2MoJ3NwYW4nLHtzdGF0aWNDbGFzczpcInByZWxvYWRlci1pbm5lci1nYXBcIn0pLF92bS5fdihcIiBcIiksX3ZtLl9tKDApLF92bS5fdihcIiBcIiksX3ZtLl9tKDEpXSk6X3ZtLl9lKCldKX0sc3RhdGljUmVuZGVyRm5zOiBbZnVuY3Rpb24oKXt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtyZXR1cm4gX2MoJ3NwYW4nLHtzdGF0aWNDbGFzczpcInByZWxvYWRlci1pbm5lci1sZWZ0XCJ9LFtfYygnc3Bhbicse3N0YXRpY0NsYXNzOlwicHJlbG9hZGVyLWlubmVyLWhhbGYtY2lyY2xlXCJ9KV0pfSxmdW5jdGlvbigpe3ZhciBfdm09dGhpczt2YXIgX2g9X3ZtLiRjcmVhdGVFbGVtZW50O3ZhciBfYz1fdm0uX3NlbGYuX2N8fF9oO3JldHVybiBfYygnc3Bhbicse3N0YXRpY0NsYXNzOlwicHJlbG9hZGVyLWlubmVyLXJpZ2h0XCJ9LFtfYygnc3Bhbicse3N0YXRpY0NsYXNzOlwicHJlbG9hZGVyLWlubmVyLWhhbGYtY2lyY2xlXCJ9KV0pfV0sXG4gIG5hbWU6ICdmNy1wcmVsb2FkZXInLFxuICBwcm9wczogUHJlbG9hZGVyUHJvcHMsXG4gIGNvbXB1dGVkOiB7XG4gICAgY2xhc3NlcygpIHtcbiAgICAgIHJldHVybiBNaXhpbnMuY29sb3JDbGFzc2VzKHRoaXMpO1xuICAgIH0sXG4gICAgc2l6ZUNvbXB1dGVkKCkge1xuICAgICAgbGV0IHMgPSB0aGlzLnNpemU7XG4gICAgICBpZiAocyAmJiB0eXBlb2YgcyA9PT0gJ3N0cmluZycgJiYgcy5pbmRleE9mKCdweCcpID49IDApIHtcbiAgICAgICAgcyA9IHMucmVwbGFjZSgncHgnLCAnJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcztcbiAgICB9LFxuICB9LFxufTtcblxuY29uc3QgUHJvZ3Jlc3NiYXJQcm9wcyA9IFV0aWxzLmV4dGVuZCh7XG4gIHByb2dyZXNzOiBOdW1iZXIsXG4gIGluZmluaXRlOiBCb29sZWFuLFxufSwgTWl4aW5zLmNvbG9yUHJvcHMpO1xuXG52YXIgZjdQcm9ncmVzc2JhciA9IHtcbiAgbmFtZTogJ2Y3LXByb2dyZXNzYmFyJyxcbiAgcmVuZGVyKGMpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBjb25zdCB7IHByb2dyZXNzIH0gPSBzZWxmO1xuICAgIHJldHVybiBjKCdzcGFuJywge1xuICAgICAgc3RhdGljQ2xhc3M6ICdwcm9ncmVzc2JhcicsXG4gICAgICBjbGFzczogc2VsZi5jbGFzc2VzLFxuICAgICAgYXR0cnM6IHtcbiAgICAgICAgJ2RhdGEtcHJvZ3Jlc3MnOiBwcm9ncmVzcyxcbiAgICAgIH0sXG4gICAgfSwgW1xuICAgICAgYygnc3BhbicsIHtcbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICB0cmFuc2Zvcm06IHByb2dyZXNzID8gYHRyYW5zbGF0ZTNkKCR7LTEwMCArIHByb2dyZXNzfSUsIDAsIDApYCA6ICcnLFxuICAgICAgICAgICctd2Via2l0LXRyYW5zZm9ybSc6IHByb2dyZXNzID8gYHRyYW5zbGF0ZTNkKCR7LTEwMCArIHByb2dyZXNzfSUsIDAsIDApYCA6ICcnLFxuICAgICAgICB9LFxuICAgICAgfSksXG4gICAgXSk7XG4gIH0sXG4gIHByb3BzOiBQcm9ncmVzc2JhclByb3BzLFxuICBjb21wdXRlZDoge1xuICAgIGNsYXNzZXMoKSB7XG4gICAgICByZXR1cm4gVXRpbHMuZXh0ZW5kKHtcbiAgICAgICAgJ3Byb2dyZXNzYmFyLWluZmluaXRlJzogdGhpcy5pbmZpbml0ZSxcbiAgICAgIH0sIE1peGlucy5jb2xvckNsYXNzZXModGhpcykpO1xuICAgIH0sXG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBzZXQocHJvZ3Jlc3MsIHNwZWVkKSB7XG4gICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgIGlmICghc2VsZi4kZjcpIHJldHVybjtcbiAgICAgIHNlbGYuJGY3LnByb2dyZXNzYmFyLnNldChzZWxmLiRlbCwgcHJvZ3Jlc3MsIHNwZWVkKTtcbiAgICB9LFxuICB9LFxufTtcblxuY29uc3QgUmFkaW9Qcm9wcyA9IFV0aWxzLmV4dGVuZCh7XG4gIGNoZWNrZWQ6IEJvb2xlYW4sXG4gIG5hbWU6IFtOdW1iZXIsIFN0cmluZ10sXG4gIHZhbHVlOiBbTnVtYmVyLCBTdHJpbmcsIEJvb2xlYW5dLFxuICBkaXNhYmxlZDogQm9vbGVhbixcbiAgcmVhZG9ubHk6IEJvb2xlYW4sXG59LCBNaXhpbnMuY29sb3JQcm9wcyk7XG5cbnZhciBmN1JhZGlvID0ge1xuICBuYW1lOiAnZjctcmFkaW8nLFxuICBwcm9wczogUmFkaW9Qcm9wcyxcbiAgcmVuZGVyKGMpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcblxuICAgIGNvbnN0IGlucHV0RWwgPSBjKCdpbnB1dCcsIHtcbiAgICAgIGF0dHJzOiB7XG4gICAgICAgIHR5cGU6ICdyYWRpbycsXG4gICAgICAgIG5hbWU6IHNlbGYubmFtZSxcbiAgICAgIH0sXG4gICAgICBkb21Qcm9wczoge1xuICAgICAgICB2YWx1ZTogc2VsZi52YWx1ZSxcbiAgICAgICAgZGlzYWJsZWQ6IHNlbGYuZGlzYWJsZWQsXG4gICAgICAgIHJlYWRvbmx5OiBzZWxmLnJlYWRvbmx5LFxuICAgICAgICBjaGVja2VkOiBzZWxmLmNoZWNrZWQsXG4gICAgICB9LFxuICAgICAgb246IHtcbiAgICAgICAgY2hhbmdlOiBzZWxmLm9uQ2hhbmdlLFxuICAgICAgfSxcbiAgICB9KTtcblxuICAgIGNvbnN0IGljb25FbCA9IGMoJ2knLCB7IHN0YXRpY0NsYXNzOiAnaWNvbi1yYWRpbycgfSk7XG5cbiAgICByZXR1cm4gYygnbGFiZWwnLCB7XG4gICAgICBzdGF0aWNDbGFzczogJ3JhZGlvJyxcbiAgICAgIGNsYXNzOiBVdGlscy5leHRlbmQoe1xuICAgICAgICBkaXNhYmxlZDogc2VsZi5kaXNhYmxlZCxcbiAgICAgIH0sIE1peGlucy5jb2xvckNsYXNzZXMoc2VsZikpLFxuICAgIH0sIFtpbnB1dEVsLCBpY29uRWwsIHNlbGYuJHNsb3RzLmRlZmF1bHRdKTtcbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIG9uQ2hhbmdlKGV2ZW50KSB7XG4gICAgICB0aGlzLiRlbWl0KCdjaGFuZ2UnLCBldmVudCk7XG4gICAgfSxcbiAgfSxcbn07XG5cbnZhciBmN1JvdXRhYmxlTW9kYWxzID0ge1xuICBuYW1lOiAnZjctcm91dGFibGUtbW9kYWxzJyxcbiAgZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbW9kYWxzOiBbXSxcbiAgICB9O1xuICB9LFxuICByZW5kZXIoYykge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIGNvbnN0IG1vZGFscyA9IHNlbGYubW9kYWxzLm1hcChtb2RhbCA9PiBjKG1vZGFsLmNvbXBvbmVudCwge1xuICAgICAgdGFnOiAnY29tcG9uZW50JyxcbiAgICAgIHByb3BzOiBtb2RhbC5wYXJhbXMgPyBtb2RhbC5wYXJhbXMgfHwge30gOiB7fSxcbiAgICAgIGtleTogbW9kYWwuaWQsXG4gICAgfSkpO1xuICAgIHJldHVybiBjKFxuICAgICAgJ2RpdicsXG4gICAgICB7XG4gICAgICAgIHN0YXRpY0NsYXNzOiAnZnJhbWV3b3JrNy1tb2RhbHMnLFxuICAgICAgICByZWY6ICdyb3V0YWJsZU1vZGFscycsXG4gICAgICB9LFxuICAgICAgbW9kYWxzXG4gICAgKTtcbiAgfSxcbn07XG5cbmNvbnN0IFJvd1Byb3BzID0gVXRpbHMuZXh0ZW5kKFxuICB7XG4gICAgbm9HYXA6IEJvb2xlYW4sXG4gICAgdGFnOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiAnZGl2JyxcbiAgICB9LFxuICB9LFxuICBNaXhpbnMuY29sb3JQcm9wc1xuKTtcblxudmFyIGY3Um93ID0ge1xuICBuYW1lOiAnZjctcm93JyxcbiAgcHJvcHM6IFJvd1Byb3BzLFxuICByZW5kZXIoYykge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjKHNlbGYudGFnLCB7XG4gICAgICBzdGF0aWNDbGFzczogJ3JvdycsXG4gICAgICBjbGFzczogc2VsZi5jbGFzc2VzLFxuICAgIH0sIFtzZWxmLiRzbG90cy5kZWZhdWx0XSk7XG4gIH0sXG4gIGNvbXB1dGVkOiB7XG4gICAgY2xhc3NlcygpIHtcbiAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgcmV0dXJuIFV0aWxzLmV4dGVuZChcbiAgICAgICAge1xuICAgICAgICAgICduby1nYXAnOiBzZWxmLm5vR2FwLFxuICAgICAgICB9LFxuICAgICAgICBNaXhpbnMuY29sb3JDbGFzc2VzKHNlbGYpXG4gICAgICApO1xuICAgIH0sXG4gIH0sXG59O1xuXG5jb25zdCBTZWFyY2hiYXJQcm9wcyA9IFV0aWxzLmV4dGVuZChcbiAge1xuICAgIG5vU2hhZG93OiBCb29sZWFuLFxuICAgIG5vSGFpcmxpbmU6IEJvb2xlYW4sXG4gICAgZm9ybToge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgfSxcbiAgICBwbGFjZWhvbGRlcjoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogJ1NlYXJjaCcsXG4gICAgfSxcbiAgICBkaXNhYmxlQnV0dG9uOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogdHJ1ZSxcbiAgICB9LFxuICAgIGRpc2FibGVCdXR0b25UZXh0OiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiAnQ2FuY2VsJyxcbiAgICB9LFxuICAgIGNsZWFyQnV0dG9uOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogdHJ1ZSxcbiAgICB9LFxuXG4gICAgLy8gU0IgUGFyYW1zXG4gICAgZXhwYW5kYWJsZTogQm9vbGVhbixcbiAgICBzZWFyY2hDb250YWluZXI6IFtTdHJpbmcsIE9iamVjdF0sXG4gICAgc2VhcmNoSW46IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6ICcuaXRlbS10aXRsZScsXG4gICAgfSxcbiAgICBzZWFyY2hJdGVtOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiAnbGknLFxuICAgIH0sXG4gICAgZm91bmRFbDoge1xuICAgICAgdHlwZTogW1N0cmluZywgT2JqZWN0XSxcbiAgICAgIGRlZmF1bHQ6ICcuc2VhcmNoYmFyLWZvdW5kJyxcbiAgICB9LFxuICAgIG5vdEZvdW5kRWw6IHtcbiAgICAgIHR5cGU6IFtTdHJpbmcsIE9iamVjdF0sXG4gICAgICBkZWZhdWx0OiAnLnNlYXJjaGJhci1ub3QtZm91bmQnLFxuICAgIH0sXG4gICAgYmFja2Ryb3A6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiB0cnVlLFxuICAgIH0sXG4gICAgYmFja2Ryb3BFbDogW1N0cmluZywgT2JqZWN0XSxcbiAgICBoaWRlT25FbmFibGVFbDoge1xuICAgICAgdHlwZTogW1N0cmluZywgT2JqZWN0XSxcbiAgICAgIGRlZmF1bHQ6ICcuc2VhcmNoYmFyLWhpZGUtb24tZW5hYmxlJyxcbiAgICB9LFxuICAgIGhpZGVPblNlYXJjaEVsOiB7XG4gICAgICB0eXBlOiBbU3RyaW5nLCBPYmplY3RdLFxuICAgICAgZGVmYXVsdDogJy5zZWFyY2hiYXItaGlkZS1vbi1zZWFyY2gnLFxuICAgIH0sXG4gICAgaWdub3JlOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiAnLnNlYXJjaGJhci1pZ25vcmUnLFxuICAgIH0sXG4gICAgY3VzdG9tU2VhcmNoOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogZmFsc2UsXG4gICAgfSxcbiAgICByZW1vdmVEaWFjcml0aWNzOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogZmFsc2UsXG4gICAgfSxcbiAgICBoaWRlRGl2aWRlcnM6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiB0cnVlLFxuICAgIH0sXG4gICAgaGlkZUdyb3Vwczoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgfSxcbiAgICBpbml0OiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogdHJ1ZSxcbiAgICB9LFxuICB9LFxuICBNaXhpbnMuY29sb3JQcm9wc1xuKTtcblxudmFyIGY3U2VhcmNoYmFyID0ge1xuICBuYW1lOiAnZjctc2VhcmNoYmFyJyxcbiAgcmVuZGVyKGMpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBsZXQgY2xlYXJFbDtcbiAgICBsZXQgZGlzYWJsZUVsO1xuXG4gICAgY29uc3QgaW5wdXRFbCA9IGMoJ2lucHV0Jywge1xuICAgICAgYXR0cnM6IHtcbiAgICAgICAgcGxhY2Vob2xkZXI6IHNlbGYucGxhY2Vob2xkZXIsXG4gICAgICAgIHR5cGU6ICdzZWFyY2gnLFxuICAgICAgfSxcbiAgICAgIG9uOiB7XG4gICAgICAgIGlucHV0OiBzZWxmLm9uSW5wdXQsXG4gICAgICAgIGNoYW5nZTogc2VsZi5vbkNoYW5nZSxcbiAgICAgICAgZm9jdXM6IHNlbGYub25Gb2N1cyxcbiAgICAgICAgYmx1cjogc2VsZi5vbkJsdXIsXG4gICAgICB9LFxuICAgIH0pO1xuICAgIGlmIChzZWxmLmNsZWFyQnV0dG9uKSB7XG4gICAgICBjbGVhckVsID0gYygnc3BhbicsIHtcbiAgICAgICAgc3RhdGljQ2xhc3M6ICdpbnB1dC1jbGVhci1idXR0b24nLFxuICAgICAgICBvbjoge1xuICAgICAgICAgIGNsaWNrOiBzZWxmLm9uQ2xlYXJCdXR0b25DbGljayxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoc2VsZi5kaXNhYmxlQnV0dG9uKSB7XG4gICAgICBkaXNhYmxlRWwgPSBjKCdzcGFuJywge1xuICAgICAgICBzdGF0aWNDbGFzczogJ3NlYXJjaGJhci1kaXNhYmxlLWJ1dHRvbicsXG4gICAgICAgIG9uOiB7XG4gICAgICAgICAgY2xpY2s6IHNlbGYub25EaXNhYmxlQnV0dG9uQ2xpY2ssXG4gICAgICAgIH0sXG4gICAgICB9LCBbc2VsZi5kaXNhYmxlQnV0dG9uVGV4dF0pO1xuICAgIH1cbiAgICBjb25zdCBpY29uRWwgPSBjKCdpJywge1xuICAgICAgc3RhdGljQ2xhc3M6ICdzZWFyY2hiYXItaWNvbicsXG4gICAgfSk7XG5cbiAgICBjb25zdCBpbnB1dFdyYXBFbCA9IGMoJ2RpdicsIHsgc3RhdGljQ2xhc3M6ICdzZWFyY2hiYXItaW5wdXQtd3JhcCcgfSwgW3NlbGYuJHNsb3RzWydpbnB1dC13cmFwLXN0YXJ0J10sIGlucHV0RWwsIGljb25FbCwgY2xlYXJFbCwgc2VsZi4kc2xvdHNbJ2lucHV0LXdyYXAtZW5kJ11dKTtcblxuICAgIGNvbnN0IGlubmVyRWwgPSBjKCdkaXYnLCB7XG4gICAgICBzdGF0aWNDbGFzczogJ3NlYXJjaGJhci1pbm5lcicsXG4gICAgfSwgW3NlbGYuJHNsb3RzWydpbm5lci1zdGFydCddLCBpbnB1dFdyYXBFbCwgZGlzYWJsZUVsLCBzZWxmLiRzbG90c1snaW5uZXItZW5kJ10sIHNlbGYuJHNsb3RzLmRlZmF1bHRdKTtcblxuICAgIHJldHVybiBjKHNlbGYuZm9ybSA/ICdmb3JtJyA6ICdkaXYnLCB7XG4gICAgICBzdGF0aWNDbGFzczogJ3NlYXJjaGJhcicsXG4gICAgICBjbGFzczogVXRpbHMuZXh0ZW5kKHtcbiAgICAgICAgJ25vLXNoYWRvdyc6IHNlbGYubm9TaGFkb3csXG4gICAgICAgICduby1oYWlybGluZSc6IHNlbGYubm9IYWlybGluZSxcbiAgICAgICAgJ3NlYXJjaGJhci1leHBhbmRhYmxlJzogc2VsZi5leHBhbmRhYmxlLFxuICAgICAgfSwgTWl4aW5zLmNvbG9yQ2xhc3NlcyhzZWxmKSksXG4gICAgICBvbjoge1xuICAgICAgICBzdWJtaXQ6IHNlbGYub25TdWJtaXQsXG4gICAgICB9LFxuICAgIH0sIFtzZWxmLiRzbG90c1snYmVmb3JlLWlubmVyJ10sIGlubmVyRWwsIHNlbGYuJHNsb3RzWydhZnRlci1pbm5lciddXSk7XG4gIH0sXG4gIGJlZm9yZURlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMuZjdTZWFyY2hiYXIgJiYgdGhpcy5mN1NlYXJjaGJhci5kZXN0cm95KSB0aGlzLmY3U2VhcmNoYmFyLmRlc3Ryb3koKTtcbiAgfSxcbiAgcHJvcHM6IFNlYXJjaGJhclByb3BzLFxuICBtZXRob2RzOiB7XG4gICAgc2VhcmNoKHF1ZXJ5KSB7XG4gICAgICBpZiAoIXRoaXMuZjdTZWFyY2hiYXIpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gdGhpcy5mN1NlYXJjaGJhci5zZWFyY2gocXVlcnkpO1xuICAgIH0sXG4gICAgZW5hYmxlKCkge1xuICAgICAgaWYgKCF0aGlzLmY3U2VhcmNoYmFyKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIHRoaXMuZjdTZWFyY2hiYXIuZW5hYmxlKCk7XG4gICAgfSxcbiAgICBkaXNhYmxlKCkge1xuICAgICAgaWYgKCF0aGlzLmY3U2VhcmNoYmFyKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIHRoaXMuZjdTZWFyY2hiYXIuZGlzYWJsZSgpO1xuICAgIH0sXG4gICAgdG9nZ2xlKCkge1xuICAgICAgaWYgKCF0aGlzLmY3U2VhcmNoYmFyKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIHRoaXMudG9nZ2xlLmRpc2FibGUoKTtcbiAgICB9LFxuICAgIGNsZWFyKCkge1xuICAgICAgaWYgKCF0aGlzLmY3U2VhcmNoYmFyKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIHRoaXMuZjdTZWFyY2hiYXIuY2xlYXIoKTtcbiAgICB9LFxuICAgIG9uQ2hhbmdlKGV2ZW50KSB7XG4gICAgICB0aGlzLiRlbWl0KCdjaGFuZ2UnLCBldmVudCk7XG4gICAgfSxcbiAgICBvbklucHV0KGV2ZW50KSB7XG4gICAgICB0aGlzLiRlbWl0KCdpbnB1dCcsIGV2ZW50KTtcbiAgICB9LFxuICAgIG9uRm9jdXMoZXZlbnQpIHtcbiAgICAgIHRoaXMuJGVtaXQoJ2ZvY3VzJywgZXZlbnQpO1xuICAgIH0sXG4gICAgb25CbHVyKGV2ZW50KSB7XG4gICAgICB0aGlzLiRlbWl0KCdibHVyJywgZXZlbnQpO1xuICAgIH0sXG4gICAgb25TdWJtaXQoZXZlbnQpIHtcbiAgICAgIHRoaXMuJGVtaXQoJ3N1Ym1pdCcsIGV2ZW50KTtcbiAgICB9LFxuICAgIG9uQ2xlYXJCdXR0b25DbGljayhldmVudCkge1xuICAgICAgdGhpcy4kZW1pdCgnY2xpY2s6Y2xlYXInLCBldmVudCk7XG4gICAgfSxcbiAgICBvbkRpc2FibGVCdXR0b25DbGljayhldmVudCkge1xuICAgICAgdGhpcy4kZW1pdCgnY2xpY2s6ZGlzYWJsZScsIGV2ZW50KTtcbiAgICB9LFxuXG4gICAgb25GN1JlYWR5KCkge1xuICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICBpZiAoIXNlbGYuaW5pdCkgcmV0dXJuO1xuICAgICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgICBlbDogc2VsZi4kZWwsXG4gICAgICAgIHNlYXJjaENvbnRhaW5lcjogc2VsZi5zZWFyY2hDb250YWluZXIsXG4gICAgICAgIHNlYXJjaEluOiBzZWxmLnNlYXJjaEluLFxuICAgICAgICBzZWFyY2hJdGVtOiBzZWxmLnNlYXJjaEl0ZW0sXG4gICAgICAgIGhpZGVPbkVuYWJsZUVsOiBzZWxmLmhpZGVPbkVuYWJsZUVsLFxuICAgICAgICBoaWRlT25TZWFyY2hFbDogc2VsZi5oaWRlT25TZWFyY2hFbCxcbiAgICAgICAgZm91bmRFbDogc2VsZi5mb3VuZEVsLFxuICAgICAgICBub3RGb3VuZEVsOiBzZWxmLm5vdEZvdW5kRWwsXG4gICAgICAgIGJhY2tkcm9wOiBzZWxmLmJhY2tkcm9wLFxuICAgICAgICBiYWNrZHJvcEVsOiBzZWxmLmJhY2tkcm9wRWwsXG4gICAgICAgIGRpc2FibGVCdXR0b246IHNlbGYuZGlzYWJsZUJ1dHRvbixcbiAgICAgICAgaWdub3JlOiBzZWxmLmlnbm9yZSxcbiAgICAgICAgY3VzdG9tU2VhcmNoOiBzZWxmLmN1c3RvbVNlYXJjaCxcbiAgICAgICAgcmVtb3ZlRGlhY3JpdGljczogc2VsZi5yZW1vdmVEaWFjcml0aWNzLFxuICAgICAgICBoaWRlRGl2aWRlcnM6IHNlbGYuaGlkZURpdmlkZXJzLFxuICAgICAgICBoaWRlR3JvdXBzOiBzZWxmLmhpZGVHcm91cHMsXG4gICAgICAgIG9uOiB7XG4gICAgICAgICAgc2VhcmNoKHNlYXJjaGJhciwgcXVlcnksIHByZXZpb3VzUXVlcnkpIHtcbiAgICAgICAgICAgIHNlbGYuJGVtaXQoJ3NlYXJjaGJhcjpzZWFyY2gnLCBzZWFyY2hiYXIsIHF1ZXJ5LCBwcmV2aW91c1F1ZXJ5KTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNsZWFyKHNlYXJjaGJhciwgcHJldmlvdXNRdWVyeSkge1xuICAgICAgICAgICAgc2VsZi4kZW1pdCgnc2VhcmNoYmFyOmNsZWFyJywgc2VhcmNoYmFyLCBwcmV2aW91c1F1ZXJ5KTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGVuYWJsZShzZWFyY2hiYXIpIHtcbiAgICAgICAgICAgIHNlbGYuJGVtaXQoJ3NlYXJjaGJhcjplbmFibGUnLCBzZWFyY2hiYXIpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZGlzYWJsZShzZWFyY2hiYXIpIHtcbiAgICAgICAgICAgIHNlbGYuJGVtaXQoJ3NlYXJjaGJhcjpkaXNhYmxlJywgc2VhcmNoYmFyKTtcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgfTtcbiAgICAgIE9iamVjdC5rZXlzKHBhcmFtcykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgcGFyYW1zW2tleV0gPT09ICd1bmRlZmluZWQnIHx8IHBhcmFtc1trZXldID09PSAnJykge1xuICAgICAgICAgIGRlbGV0ZSBwYXJhbXNba2V5XTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBzZWxmLmY3U2VhcmNoYmFyID0gc2VsZi4kZjcuc2VhcmNoYmFyLmNyZWF0ZShwYXJhbXMpO1xuICAgIH0sXG4gIH0sXG59O1xuXG5jb25zdCBTZWdtZW50ZWRQcm9wcyA9IFV0aWxzLmV4dGVuZCh7XG4gIHJhaXNlZDogQm9vbGVhbixcbiAgcm91bmQ6IEJvb2xlYW4sXG4gIHRhZzoge1xuICAgIHR5cGU6IFN0cmluZyxcbiAgICBkZWZhdWx0OiAnZGl2JyxcbiAgfSxcbn0sIE1peGlucy5jb2xvclByb3BzKTtcblxudmFyIGY3U2VnbWVudGVkID0ge1xuICBuYW1lOiAnZjctc2VnbWVudGVkJyxcbiAgcHJvcHM6IFNlZ21lbnRlZFByb3BzLFxuICByZW5kZXIoYykge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjKHNlbGYudGFnLCB7XG4gICAgICBzdGF0aWNDbGFzczogJ3NlZ21lbnRlZCcsXG4gICAgICBjbGFzczogVXRpbHMuZXh0ZW5kKHtcbiAgICAgICAgJ3NlZ21lbnRlZC1yYWlzZWQnOiBzZWxmLnJhaXNlZCxcbiAgICAgICAgJ3NlZ21lbnRlZC1yb3VuZCc6IHNlbGYucm91bmQsXG4gICAgICB9LCBNaXhpbnMuY29sb3JDbGFzc2VzKHNlbGYpKSxcbiAgICB9LCBbc2VsZi4kc2xvdHMuZGVmYXVsdF0pO1xuICB9LFxufTtcblxuY29uc3QgU2hlZXRQcm9wcyA9IFV0aWxzLmV4dGVuZChcbiAge1xuICAgIG9wZW5lZDogQm9vbGVhbixcbiAgICBiYWNrZHJvcDogQm9vbGVhbixcbiAgfSxcbiAgTWl4aW5zLmNvbG9yUHJvcHNcbik7XG5cbnZhciBmN1NoZWV0ID0ge1xuICBuYW1lOiAnZjctc2hlZXQnLFxuICByZW5kZXIoYykge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIGNvbnN0IGZpeGVkTGlzdCA9IFtdO1xuICAgIGNvbnN0IHN0YXRpY0xpc3QgPSBbXTtcbiAgICBjb25zdCBmaXhlZFRhZ3MgPSAoJ25hdmJhciB0b29sYmFyIHRhYmJhciBzdWJuYXZiYXIgc2VhcmNoYmFyIG1lc3NhZ2ViYXIgZmFiJykuc3BsaXQoJyAnKTtcblxuICAgIGxldCB0YWc7XG4gICAgbGV0IGNoaWxkO1xuXG4gICAgaWYgKHNlbGYuJHNsb3RzLmRlZmF1bHQpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VsZi4kc2xvdHMuZGVmYXVsdC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBjaGlsZCA9IHNlbGYuJHNsb3RzLmRlZmF1bHRbaV07XG4gICAgICAgIHRhZyA9IGNoaWxkLnRhZztcbiAgICAgICAgaWYgKCF0YWcpIHtcbiAgICAgICAgICBzdGF0aWNMaXN0LnB1c2goY2hpbGQpO1xuICAgICAgICAgIGNvbnRpbnVlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICAgIH1cbiAgICAgICAgbGV0IGlzRml4ZWQgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBmaXhlZFRhZ3MubGVuZ3RoOyBqICs9IDEpIHtcbiAgICAgICAgICBpZiAodGFnLmluZGV4T2YoZml4ZWRUYWdzW2pdKSA+PSAwKSB7XG4gICAgICAgICAgICBpc0ZpeGVkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzRml4ZWQpIGZpeGVkTGlzdC5wdXNoKGNoaWxkKTtcbiAgICAgICAgZWxzZSBzdGF0aWNMaXN0LnB1c2goY2hpbGQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGlubmVyRWwgPSBjKCdkaXYnLCB7XG4gICAgICBzdGF0aWNDbGFzczogJ3NoZWV0LW1vZGFsLWlubmVyJyxcbiAgICB9LCBzdGF0aWNMaXN0KTtcblxuICAgIHJldHVybiBjKCdkaXYnLCB7XG4gICAgICBjbGFzczogc2VsZi5jbGFzc2VzLFxuICAgICAgc3RhdGljQ2xhc3M6ICdzaGVldC1tb2RhbCcsXG4gICAgICBvbjoge1xuICAgICAgICAnc2hlZXQ6b3Blbic6IHNlbGYub25PcGVuLFxuICAgICAgICAnc2hlZXQ6b3BlbmVkJzogc2VsZi5vbk9wZW5lZCxcbiAgICAgICAgJ3NoZWV0OmNsb3NlJzogc2VsZi5vbkNsb3NlLFxuICAgICAgICAnc2hlZXQ6Y2xvc2VkJzogc2VsZi5vbkNsb3NlZCxcbiAgICAgIH0sXG4gICAgfSwgW2ZpeGVkTGlzdCwgaW5uZXJFbF0pO1xuICB9LFxuICB3YXRjaDoge1xuICAgIG9wZW5lZChvcGVuZWQpIHtcbiAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgaWYgKCFzZWxmLmY3U2hlZXQpIHJldHVybjtcbiAgICAgIGlmIChvcGVuZWQpIHtcbiAgICAgICAgc2VsZi5mN1NoZWV0Lm9wZW4oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGYuZjdTaGVldC5jbG9zZSgpO1xuICAgICAgfVxuICAgIH0sXG4gIH0sXG4gIHByb3BzOiBTaGVldFByb3BzLFxuICBjb21wdXRlZDoge1xuICAgIGNsYXNzZXMoKSB7XG4gICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgIHJldHVybiBNaXhpbnMuY29sb3JDbGFzc2VzKHNlbGYpO1xuICAgIH0sXG4gIH0sXG4gIGJlZm9yZURlc3Ryb3koKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgaWYgKHNlbGYuZjdTaGVldCkgc2VsZi5mN1NoZWV0LmRlc3Ryb3koKTtcbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIG9uT3BlbihldmVudCkge1xuICAgICAgdGhpcy4kZW1pdCgnc2hlZXQ6b3BlbicsIGV2ZW50KTtcbiAgICB9LFxuICAgIG9uT3BlbmVkKGV2ZW50KSB7XG4gICAgICB0aGlzLiRlbWl0KCdzaGVldDpvcGVuZWQnLCBldmVudCk7XG4gICAgfSxcbiAgICBvbkNsb3NlKGV2ZW50KSB7XG4gICAgICB0aGlzLiRlbWl0KCdzaGVldDpjbG9zZScsIGV2ZW50KTtcbiAgICB9LFxuICAgIG9uQ2xvc2VkKGV2ZW50KSB7XG4gICAgICB0aGlzLiRlbWl0KCdzaGVldDpjbG9zZWQnLCBldmVudCk7XG4gICAgfSxcbiAgICBvcGVuKGFuaW1hdGUpIHtcbiAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgaWYgKCFzZWxmLiRmNykgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiBzZWxmLiRmNy5zaGVldC5vcGVuKHNlbGYuJGVsLCBhbmltYXRlKTtcbiAgICB9LFxuICAgIGNsb3NlKGFuaW1hdGUpIHtcbiAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgaWYgKCFzZWxmLiRmNykgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiBzZWxmLiRmNy5zaGVldC5jbG9zZShzZWxmLiRlbCwgYW5pbWF0ZSk7XG4gICAgfSxcbiAgICBvbkY3UmVhZHkoKSB7XG4gICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgIGxldCBiYWNrZHJvcCA9IHNlbGYuYmFja2Ryb3A7XG4gICAgICBpZiAoc2VsZi4kb3B0aW9ucy5wcm9wc0RhdGEuYmFja2Ryb3AgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBhcHAgPSBzZWxmLiRmNztcbiAgICAgICAgYmFja2Ryb3AgPSBhcHAucGFyYW1zLnNoZWV0ICYmIGFwcC5wYXJhbXMuc2hlZXQuYmFja2Ryb3AgIT09IHVuZGVmaW5lZCA/IGFwcC5wYXJhbXMuc2hlZXQuYmFja2Ryb3AgOiBzZWxmLiR0aGVtZS5tZDtcbiAgICAgIH1cbiAgICAgIHNlbGYuZjdTaGVldCA9IHNlbGYuJGY3LnNoZWV0LmNyZWF0ZSh7XG4gICAgICAgIGVsOiBzZWxmLiRlbCxcbiAgICAgICAgYmFja2Ryb3AsXG4gICAgICB9KTtcbiAgICAgIGlmIChzZWxmLm9wZW5lZCkge1xuICAgICAgICBzZWxmLmY3U2hlZXQub3BlbihmYWxzZSk7XG4gICAgICB9XG4gICAgfSxcbiAgfSxcbn07XG5cbnZhciBmN1N0YXR1c2JhciA9IHtyZW5kZXI6IGZ1bmN0aW9uKCl7dmFyIF92bT10aGlzO3ZhciBfaD1fdm0uJGNyZWF0ZUVsZW1lbnQ7dmFyIF9jPV92bS5fc2VsZi5fY3x8X2g7cmV0dXJuIF9jKCdkaXYnLHtzdGF0aWNDbGFzczpcInN0YXR1c2JhclwiLGNsYXNzOl92bS5jbGFzc2VzfSl9LHN0YXRpY1JlbmRlckZuczogW10sXG4gIG5hbWU6ICdmNy1zdGF0dXNiYXInLFxuICBwcm9wczogTWl4aW5zLmNvbG9yUHJvcHMsXG4gIGNvbXB1dGVkOiB7XG4gICAgY2xhc3NlcygpIHtcbiAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgcmV0dXJuIE1peGlucy5jb2xvckNsYXNzZXMoc2VsZik7XG4gICAgfSxcbiAgfSxcbn07XG5cbmNvbnN0IFN0ZXBwZXJQcm9wcyA9IFV0aWxzLmV4dGVuZCh7XG4gIGluaXQ6IHtcbiAgICB0eXBlOiBCb29sZWFuLFxuICAgIGRlZmF1bHQ6IHRydWUsXG4gIH0sXG4gIHZhbHVlOiB7XG4gICAgdHlwZTogTnVtYmVyLFxuICAgIGRlZmF1bHQ6IDAsXG4gIH0sXG4gIG1pbjoge1xuICAgIHR5cGU6IE51bWJlcixcbiAgICBkZWZhdWx0OiAwLFxuICB9LFxuICBtYXg6IHtcbiAgICB0eXBlOiBOdW1iZXIsXG4gICAgZGVmYXVsdDogMTAwLFxuICB9LFxuICBzdGVwOiB7XG4gICAgdHlwZTogTnVtYmVyLFxuICAgIGRlZmF1bHQ6IDEsXG4gIH0sXG4gIGZvcm1hdFZhbHVlOiBGdW5jdGlvbixcbiAgaW5wdXQ6IHtcbiAgICB0eXBlOiBCb29sZWFuLFxuICAgIGRlZmF1bHQ6IHRydWUsXG4gIH0sXG4gIGlucHV0VHlwZToge1xuICAgIHR5cGU6IFN0cmluZyxcbiAgICBkZWZhdWx0OiAndGV4dCcsXG4gIH0sXG4gIGlucHV0UmVhZG9ubHk6IHtcbiAgICB0eXBlOiBCb29sZWFuLFxuICAgIGRlZmF1bHQ6IHRydWUsXG4gIH0sXG4gIGF1dG9yZXBlYXQ6IHtcbiAgICB0eXBlOiBCb29sZWFuLFxuICAgIGRlZmF1bHQ6IGZhbHNlLFxuICB9LFxuICBhdXRvcmVwZWF0RHluYW1pYzoge1xuICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgZGVmYXVsdDogZmFsc2UsXG4gIH0sXG4gIHdyYXBzOiB7XG4gICAgdHlwZTogQm9vbGVhbixcbiAgICBkZWZhdWx0OiBmYWxzZSxcbiAgfSxcbiAgZGlzYWJsZWQ6IEJvb2xlYW4sXG4gIGJ1dHRvbnNPbmx5OiBCb29sZWFuLFxuXG4gIHJvdW5kOiBCb29sZWFuLFxuICByb3VuZE1kOiBCb29sZWFuLFxuICByb3VuZElvczogQm9vbGVhbixcbiAgZmlsbDogQm9vbGVhbixcbiAgZmlsbE1kOiBCb29sZWFuLFxuICBmaWxsSW9zOiBCb29sZWFuLFxuICBiaWc6IEJvb2xlYW4sXG4gIGJpZ01kOiBCb29sZWFuLFxuICBiaWdJb3M6IEJvb2xlYW4sXG4gIHNtYWxsOiBCb29sZWFuLFxuICBzbWFsbE1kOiBCb29sZWFuLFxuICBzbWFsbElvczogQm9vbGVhbixcbiAgcmFpc2VkOiBCb29sZWFuLFxufSwgTWl4aW5zLmNvbG9yUHJvcHMpO1xuXG52YXIgZjdTdGVwcGVyID0ge3JlbmRlcjogZnVuY3Rpb24oKXt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtyZXR1cm4gX2MoJ2Rpdicse3N0YXRpY0NsYXNzOlwic3RlcHBlclwiLGNsYXNzOl92bS5jbGFzc2VzfSxbX2MoJ2Rpdicse3N0YXRpY0NsYXNzOlwic3RlcHBlci1idXR0b24tbWludXNcIixvbjp7XCJjbGlja1wiOl92bS5vbk1pbnVzQ2xpY2t9fSksX3ZtLl92KFwiIFwiKSwoX3ZtLmlucHV0ICYmICFfdm0uYnV0dG9uc09ubHkpP19jKCdkaXYnLHtzdGF0aWNDbGFzczpcInN0ZXBwZXItaW5wdXQtd3JhcFwifSxbX2MoJ2lucHV0Jyx7YXR0cnM6e1widHlwZVwiOl92bS5pbnB1dFR5cGUsXCJtaW5cIjpfdm0uaW5wdXRUeXBlID09PSAnbnVtYmVyJyA/IF92bS5taW4gOiB1bmRlZmluZWQsXCJtYXhcIjpfdm0uaW5wdXRUeXBlID09PSAnbnVtYmVyJyA/IF92bS5tYXggOiB1bmRlZmluZWQsXCJzdGVwXCI6X3ZtLmlucHV0VHlwZSA9PT0gJ251bWJlcicgPyBfdm0uc3RlcCA6IHVuZGVmaW5lZCxcInJlYWRvbmx5XCI6X3ZtLmlucHV0UmVhZG9ubHl9LGRvbVByb3BzOntcInZhbHVlXCI6X3ZtLnZhbHVlfSxvbjp7XCJpbnB1dFwiOl92bS5vbklucHV0fX0pXSk6X3ZtLl9lKCksX3ZtLl92KFwiIFwiKSwoIV92bS5pbnB1dCAmJiAhX3ZtLmJ1dHRvbnNPbmx5KT9fYygnZGl2Jyx7c3RhdGljQ2xhc3M6XCJzdGVwcGVyLXZhbHVlXCJ9LFtfdm0uX3YoX3ZtLl9zKF92bS52YWx1ZSkpXSk6X3ZtLl9lKCksX3ZtLl92KFwiIFwiKSxfYygnZGl2Jyx7c3RhdGljQ2xhc3M6XCJzdGVwcGVyLWJ1dHRvbi1wbHVzXCIsb246e1wiY2xpY2tcIjpfdm0ub25QbHVzQ2xpY2t9fSldKX0sc3RhdGljUmVuZGVyRm5zOiBbXSxcbiAgcHJvcHM6IFN0ZXBwZXJQcm9wcyxcbiAgY29tcHV0ZWQ6IHtcbiAgICBjbGFzc2VzKCkge1xuICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHJvdW5kLFxuICAgICAgICByb3VuZElvcyxcbiAgICAgICAgcm91bmRNZCxcbiAgICAgICAgZmlsbCxcbiAgICAgICAgZmlsbElvcyxcbiAgICAgICAgZmlsbE1kLFxuICAgICAgICBiaWcsXG4gICAgICAgIGJpZ0lvcyxcbiAgICAgICAgYmlnTWQsXG4gICAgICAgIHNtYWxsLFxuICAgICAgICBzbWFsbElvcyxcbiAgICAgICAgc21hbGxNZCxcbiAgICAgICAgcmFpc2VkLFxuICAgICAgfSA9IHNlbGY7XG5cbiAgICAgIHJldHVybiBVdGlscy5leHRlbmQoe1xuICAgICAgICBkaXNhYmxlZDogc2VsZi5kaXNhYmxlZCxcbiAgICAgICAgJ3N0ZXBwZXItcm91bmQnOiByb3VuZCxcbiAgICAgICAgJ3N0ZXBwZXItcm91bmQtaW9zJzogcm91bmRJb3MsXG4gICAgICAgICdzdGVwcGVyLXJvdW5kLW1kJzogcm91bmRNZCxcbiAgICAgICAgJ3N0ZXBwZXItZmlsbCc6IGZpbGwsXG4gICAgICAgICdzdGVwcGVyLWZpbGwtaW9zJzogZmlsbElvcyxcbiAgICAgICAgJ3N0ZXBwZXItZmlsbC1tZCc6IGZpbGxNZCxcbiAgICAgICAgJ3N0ZXBwZXItYmlnJzogYmlnLFxuICAgICAgICAnc3RlcHBlci1iaWctaW9zJzogYmlnSW9zLFxuICAgICAgICAnc3RlcHBlci1iaWctbWQnOiBiaWdNZCxcbiAgICAgICAgJ3N0ZXBwZXItc21hbGwnOiBzbWFsbCxcbiAgICAgICAgJ3N0ZXBwZXItc21hbGwtaW9zJzogc21hbGxJb3MsXG4gICAgICAgICdzdGVwcGVyLXNtYWxsLW1kJzogc21hbGxNZCxcbiAgICAgICAgJ3N0ZXBwZXItcmFpc2VkJzogcmFpc2VkLFxuICAgICAgfSwgTWl4aW5zLmNvbG9yQ2xhc3NlcyhzZWxmKSk7XG4gICAgfSxcbiAgfSxcbiAgYmVmb3JlRGVzdHJveSgpIHtcbiAgICBpZiAoIXRoaXMuaW5pdCkgcmV0dXJuO1xuICAgIGlmICh0aGlzLmY3U3RlcHBlciAmJiB0aGlzLmY3U3RlcHBlci5kZXN0cm95KSB7XG4gICAgICB0aGlzLmY3U3RlcHBlci5kZXN0cm95KCk7XG4gICAgfVxuICB9LFxuICBtZXRob2RzOiB7XG4gICAgaW5jcmVtZW50KCkge1xuICAgICAgaWYgKCF0aGlzLmY3U3RlcHBlcikgcmV0dXJuO1xuICAgICAgdGhpcy5mN1N0ZXBwZXIuaW5jcmVtZW50KCk7XG4gICAgfSxcbiAgICBkZWNyZW1lbnQoKSB7XG4gICAgICBpZiAoIXRoaXMuZjdTdGVwcGVyKSByZXR1cm47XG4gICAgICB0aGlzLmY3U3RlcHBlci5kZWNyZW1lbnQoKTtcbiAgICB9LFxuICAgIHNldFZhbHVlKG5ld1ZhbHVlKSB7XG4gICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgIGlmIChzZWxmLmY3U3RlcHBlciAmJiBzZWxmLmY3U3RlcHBlci5zZXRWYWx1ZSkgc2VsZi5mN1N0ZXBwZXIuc2V0VmFsdWUobmV3VmFsdWUpO1xuICAgIH0sXG4gICAgZ2V0VmFsdWUoKSB7XG4gICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgIGlmIChzZWxmLmY3U3RlcHBlciAmJiBzZWxmLmY3U3RlcHBlci5nZXRWYWx1ZSkge1xuICAgICAgICByZXR1cm4gc2VsZi5mN1N0ZXBwZXIuZ2V0VmFsdWUoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSxcbiAgICBvbklucHV0KGUpIHtcbiAgICAgIHRoaXMuJGVtaXQoJ2lucHV0JywgZSwgdGhpcy5mN1N0ZXBwZXIpO1xuICAgIH0sXG4gICAgb25NaW51c0NsaWNrKGUpIHtcbiAgICAgIHRoaXMuJGVtaXQoJ3N0ZXBwZXI6bWludXNjbGljaycsIGUsIHRoaXMuZjdTdGVwcGVyKTtcbiAgICB9LFxuICAgIG9uUGx1c0NsaWNrKGUpIHtcbiAgICAgIHRoaXMuJGVtaXQoJ3N0ZXBwZXI6cGx1c2NsaWNrJywgZSwgdGhpcy5mN1N0ZXBwZXIpO1xuICAgIH0sXG4gICAgb25GN1JlYWR5KGY3KSB7XG4gICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgIGlmICghc2VsZi5pbml0KSByZXR1cm47XG4gICAgICBjb25zdCB7XG4gICAgICAgIG1pbiwgbWF4LCB2YWx1ZSwgc3RlcCwgZm9ybWF0VmFsdWUsICRlbCwgYXV0b3JlcGVhdCwgYXV0b3JlcGVhdER5bmFtaWMsIHdyYXBzLFxuICAgICAgfSA9IHNlbGY7XG4gICAgICBzZWxmLmY3U3RlcHBlciA9IGY3LnN0ZXBwZXIuY3JlYXRlKHtcbiAgICAgICAgZWw6ICRlbCxcbiAgICAgICAgbWluLFxuICAgICAgICBtYXgsXG4gICAgICAgIHZhbHVlLFxuICAgICAgICBzdGVwLFxuICAgICAgICBmb3JtYXRWYWx1ZSxcbiAgICAgICAgYXV0b3JlcGVhdCxcbiAgICAgICAgYXV0b3JlcGVhdER5bmFtaWMsXG4gICAgICAgIHdyYXBzLFxuICAgICAgICBvbjoge1xuICAgICAgICAgIGNoYW5nZShzdGVwcGVyLCBuZXdWYWx1ZSkge1xuICAgICAgICAgICAgc2VsZi4kZW1pdCgnc3RlcHBlcjpjaGFuZ2UnLCBuZXdWYWx1ZSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgIH0sXG4gIH0sXG59XG5cbmNvbnN0IFN1Ym5hdmJhclByb3BzID0gVXRpbHMuZXh0ZW5kKHtcbiAgc2xpZGluZzogQm9vbGVhbixcbiAgdGl0bGU6IFN0cmluZyxcbiAgaW5uZXI6IHtcbiAgICB0eXBlOiBCb29sZWFuLFxuICAgIGRlZmF1bHQ6IHRydWUsXG4gIH0sXG59LCBNaXhpbnMuY29sb3JQcm9wcyk7XG5cbnZhciBmN1N1Ym5hdmJhciA9IHtyZW5kZXI6IGZ1bmN0aW9uKCl7dmFyIF92bT10aGlzO3ZhciBfaD1fdm0uJGNyZWF0ZUVsZW1lbnQ7dmFyIF9jPV92bS5fc2VsZi5fY3x8X2g7cmV0dXJuIF9jKCdkaXYnLHtzdGF0aWNDbGFzczpcInN1Ym5hdmJhclwiLGNsYXNzOl92bS5jbGFzc2VzfSxbKF92bS5pbm5lcik/X2MoJ2Rpdicse3N0YXRpY0NsYXNzOlwic3VibmF2YmFyLWlubmVyXCJ9LFsoX3ZtLnRpdGxlKT9fYygnZGl2Jyx7c3RhdGljQ2xhc3M6XCJ0aXRsZVwifSxbX3ZtLl92KF92bS5fcyhfdm0udGl0bGUpKV0pOl92bS5fZSgpLF92bS5fdihcIiBcIiksX3ZtLl90KFwiZGVmYXVsdFwiKV0sMik6X3ZtLl90KFwiZGVmYXVsdFwiKV0sMil9LHN0YXRpY1JlbmRlckZuczogW10sXG4gIG5hbWU6ICdmNy1zdWJuYXZiYXInLFxuICBwcm9wczogU3VibmF2YmFyUHJvcHMsXG4gIGNvbXB1dGVkOiB7XG4gICAgY2xhc3NlcygpIHtcbiAgICAgIHJldHVybiBVdGlscy5leHRlbmQoe1xuICAgICAgICBzbGlkaW5nOiB0aGlzLnNsaWRpbmcsXG4gICAgICB9LCBNaXhpbnMuY29sb3JDbGFzc2VzKHRoaXMpKTtcbiAgICB9LFxuICB9LFxufTtcblxuY29uc3QgU3dpcGVvdXRBY3Rpb25zUHJvcHMgPSBVdGlscy5leHRlbmQoe1xuICBsZWZ0OiBCb29sZWFuLFxuICByaWdodDogQm9vbGVhbixcbiAgc2lkZTogU3RyaW5nLFxufSwgTWl4aW5zLmNvbG9yUHJvcHMpO1xuXG52YXIgZjdTd2lwZW91dEFjdGlvbnMgPSB7cmVuZGVyOiBmdW5jdGlvbigpe3ZhciBfdm09dGhpczt2YXIgX2g9X3ZtLiRjcmVhdGVFbGVtZW50O3ZhciBfYz1fdm0uX3NlbGYuX2N8fF9oO3JldHVybiBfYygnZGl2Jyx7Y2xhc3M6X3ZtLmNsYXNzZXN9LFtfdm0uX3QoXCJkZWZhdWx0XCIpXSwyKX0sc3RhdGljUmVuZGVyRm5zOiBbXSxcbiAgbmFtZTogJ2Y3LXN3aXBlb3V0LWFjdGlvbnMnLFxuICBwcm9wczogU3dpcGVvdXRBY3Rpb25zUHJvcHMsXG4gIGNvbXB1dGVkOiB7XG4gICAgY2xhc3NlcygpIHtcbiAgICAgIHJldHVybiBVdGlscy5leHRlbmQoe1xuICAgICAgICBbYHN3aXBlb3V0LWFjdGlvbnMtJHt0aGlzLnNpZGVDb21wdXRlZH1gXTogdHJ1ZSxcbiAgICAgIH0sIE1peGlucy5jb2xvckNsYXNzZXModGhpcykpO1xuICAgIH0sXG4gICAgc2lkZUNvbXB1dGVkKCkge1xuICAgICAgaWYgKCF0aGlzLnNpZGUpIHtcbiAgICAgICAgaWYgKHRoaXMubGVmdCkgcmV0dXJuICdsZWZ0JztcbiAgICAgICAgaWYgKHRoaXMucmlnaHQpIHJldHVybiAncmlnaHQnO1xuICAgICAgICByZXR1cm4gJ3JpZ2h0JztcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnNpZGU7XG4gICAgfSxcbiAgfSxcbiAgZGF0YSgpIHtcbiAgICByZXR1cm4ge307XG4gIH0sXG59O1xuXG5jb25zdCBTd2lwZW91dEJ1dHRvblByb3BzID0gVXRpbHMuZXh0ZW5kKHtcbiAgdGV4dDogU3RyaW5nLFxuICBjb25maXJtVGV4dDogU3RyaW5nLFxuICBvdmVyc3dpcGU6IEJvb2xlYW4sXG4gIGNsb3NlOiBCb29sZWFuLFxuICBkZWxldGU6IEJvb2xlYW4sXG59LCBNaXhpbnMuY29sb3JQcm9wcyk7XG5cbnZhciBmN1N3aXBlb3V0QnV0dG9uID0ge3JlbmRlcjogZnVuY3Rpb24oKXt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtyZXR1cm4gX2MoJ2EnLHtjbGFzczpfdm0uY2xhc3NlcyxhdHRyczp7XCJkYXRhLWNvbmZpcm1cIjpfdm0uY29uZmlybVRleHQgfHwgdW5kZWZpbmVkfSxvbjp7XCJjbGlja1wiOl92bS5vbkNsaWNrfX0sW192bS5fdChcImRlZmF1bHRcIixbX3ZtLl92KF92bS5fcyhfdm0udGV4dCkpXSldLDIpfSxzdGF0aWNSZW5kZXJGbnM6IFtdLFxuICBuYW1lOiAnZjctc3dpcGVvdXQtYnV0dG9uJyxcbiAgcHJvcHM6IFN3aXBlb3V0QnV0dG9uUHJvcHMsXG4gIGNvbXB1dGVkOiB7XG4gICAgY2xhc3NlcygpIHtcbiAgICAgIHJldHVybiBVdGlscy5leHRlbmQoe1xuICAgICAgICAnc3dpcGVvdXQtb3ZlcnN3aXBlJzogdGhpcy5vdmVyc3dpcGUsXG4gICAgICAgICdzd2lwZW91dC1kZWxldGUnOiB0aGlzLmRlbGV0ZSxcbiAgICAgICAgJ3N3aXBlb3V0LWNsb3NlJzogdGhpcy5jbG9zZSxcbiAgICAgIH0sIE1peGlucy5jb2xvckNsYXNzZXModGhpcykpO1xuICAgIH0sXG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBvbkNsaWNrKGV2ZW50KSB7XG4gICAgICB0aGlzLiRlbWl0KCdjbGljaycsIGV2ZW50KTtcbiAgICB9LFxuICB9LFxufTtcblxudmFyIGY3U3dpcGVyU2xpZGUgPSB7cmVuZGVyOiBmdW5jdGlvbigpe3ZhciBfdm09dGhpczt2YXIgX2g9X3ZtLiRjcmVhdGVFbGVtZW50O3ZhciBfYz1fdm0uX3NlbGYuX2N8fF9oO3JldHVybiBfYygnZGl2Jyx7c3RhdGljQ2xhc3M6XCJzd2lwZXItc2xpZGVcIn0sWyhfdm0uem9vbSk/X2MoJ2Rpdicse3N0YXRpY0NsYXNzOlwic3dpcGVyLXpvb20tY29udGFpbmVyXCJ9LFtfdm0uX3QoXCJkZWZhdWx0XCIpXSwyKTpfdm0uX3QoXCJkZWZhdWx0XCIpXSwyKX0sc3RhdGljUmVuZGVyRm5zOiBbXSxcbiAgbmFtZTogJ2Y3LXN3aXBlci1zbGlkZScsXG4gIHByb3BzOiB7XG4gICAgem9vbTogQm9vbGVhbixcbiAgfSxcbn07XG5cbmNvbnN0IFN3aXBlclByb3BzID0gVXRpbHMuZXh0ZW5kKHtcbiAgcGFyYW1zOiBPYmplY3QsXG4gIHBhZ2luYXRpb246IEJvb2xlYW4sXG4gIHNjcm9sbGJhcjogQm9vbGVhbixcbiAgbmF2aWdhdGlvbjogQm9vbGVhbixcbiAgaW5pdDoge1xuICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgZGVmYXVsdDogdHJ1ZSxcbiAgfSxcbn0sIE1peGlucy5jb2xvclByb3BzKTtcblxudmFyIGY3U3dpcGVyID0ge3JlbmRlcjogZnVuY3Rpb24oKXt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtyZXR1cm4gX2MoJ2Rpdicse3N0YXRpY0NsYXNzOlwic3dpcGVyLWNvbnRhaW5lclwiLGNsYXNzOl92bS5jbGFzc2VzfSxbX3ZtLl90KFwiYmVmb3JlLXdyYXBwZXJcIiksX3ZtLl92KFwiIFwiKSxfYygnZGl2Jyx7c3RhdGljQ2xhc3M6XCJzd2lwZXItd3JhcHBlclwifSxbX3ZtLl90KFwiZGVmYXVsdFwiKV0sMiksX3ZtLl92KFwiIFwiKSwoX3ZtLnBhZ2luYXRpb25Db21wdXRlZCA9PT0gdHJ1ZSk/X2MoJ2Rpdicse3N0YXRpY0NsYXNzOlwic3dpcGVyLXBhZ2luYXRpb25cIn0pOl92bS5fZSgpLF92bS5fdihcIiBcIiksKF92bS5zY3JvbGxiYXJDb21wdXRlZCA9PT0gdHJ1ZSk/X2MoJ2Rpdicse3N0YXRpY0NsYXNzOlwic3dpcGVyLXNjcm9sbGJhclwifSk6X3ZtLl9lKCksX3ZtLl92KFwiIFwiKSwoX3ZtLm5hdmlnYXRpb25Db21wdXRlZCA9PT0gdHJ1ZSk/X2MoJ2Rpdicse3N0YXRpY0NsYXNzOlwic3dpcGVyLWJ1dHRvbi1uZXh0XCJ9KTpfdm0uX2UoKSxfdm0uX3YoXCIgXCIpLChfdm0ubmF2aWdhdGlvbkNvbXB1dGVkID09PSB0cnVlKT9fYygnZGl2Jyx7c3RhdGljQ2xhc3M6XCJzd2lwZXItYnV0dG9uLXByZXZcIn0pOl92bS5fZSgpLF92bS5fdihcIiBcIiksX3ZtLl90KFwiYWZ0ZXItd3JhcHBlclwiKV0sMil9LHN0YXRpY1JlbmRlckZuczogW10sXG4gIG5hbWU6ICdmNy1zd2lwZXInLFxuICBiZWZvcmVEZXN0cm95KCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIGlmICghc2VsZi5pbml0KSByZXR1cm47XG4gICAgaWYgKHNlbGYuc3dpcGVyICYmIHNlbGYuc3dpcGVyLmRlc3Ryb3kpIHNlbGYuc3dpcGVyLmRlc3Ryb3koKTtcbiAgfSxcbiAgZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaW5pdGlhbFVwZGF0ZTogZmFsc2UsXG4gICAgfTtcbiAgfSxcbiAgdXBkYXRlZCgpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBpZiAoIXNlbGYuaW5pdGlhbFVwZGF0ZSkge1xuICAgICAgc2VsZi5pbml0aWFsVXBkYXRlID0gdHJ1ZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHNlbGYuc3dpcGVyICYmIHNlbGYuc3dpcGVyLnVwZGF0ZSkgc2VsZi5zd2lwZXIudXBkYXRlKCk7XG4gIH0sXG4gIHByb3BzOiBTd2lwZXJQcm9wcyxcbiAgY29tcHV0ZWQ6IHtcbiAgICBjbGFzc2VzKCkge1xuICAgICAgcmV0dXJuIE1peGlucy5jb2xvckNsYXNzZXModGhpcyk7XG4gICAgfSxcbiAgICBwYWdpbmF0aW9uQ29tcHV0ZWQoKSB7XG4gICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgIGlmIChzZWxmLnBhZ2luYXRpb24gPT09IHRydWUgfHwgKHNlbGYucGFyYW1zICYmIHNlbGYucGFyYW1zLnBhZ2luYXRpb24gJiYgIXNlbGYucGFyYW1zLnBhZ2luYXRpb24uZWwpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgc2Nyb2xsYmFyQ29tcHV0ZWQoKSB7XG4gICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgIGlmIChzZWxmLnNjcm9sbGJhciA9PT0gdHJ1ZSB8fCAoc2VsZi5wYXJhbXMgJiYgc2VsZi5wYXJhbXMuc2Nyb2xsYmFyICYmICFzZWxmLnBhcmFtcy5zY3JvbGxiYXIuZWwpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgbmF2aWdhdGlvbkNvbXB1dGVkKCkge1xuICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICBpZiAoc2VsZi5uYXZpZ2F0aW9uID09PSB0cnVlIHx8IChzZWxmLnBhcmFtcyAmJiBzZWxmLnBhcmFtcy5uYXZpZ2F0aW9uICYmICFzZWxmLnBhcmFtcy5uYXZpZ2F0aW9uLm5leHRFbCAmJiAhc2VsZi5wYXJhbXMubmF2aWdhdGlvbi5wcmV2RWwpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBvbkY3UmVhZHkoZjcpIHtcbiAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgaWYgKCFzZWxmLmluaXQpIHJldHVybjtcbiAgICAgIGNvbnN0IHBhcmFtcyA9IHtcbiAgICAgICAgcGFnaW5hdGlvbjoge30sXG4gICAgICAgIG5hdmlnYXRpb246IHt9LFxuICAgICAgICBzY3JvbGxiYXI6IHt9LFxuICAgICAgfTtcbiAgICAgIGlmIChzZWxmLnBhcmFtcykgVXRpbHMuZXh0ZW5kKHBhcmFtcywgc2VsZi5wYXJhbXMpO1xuICAgICAgaWYgKHNlbGYucGFnaW5hdGlvbiAmJiAhcGFyYW1zLnBhZ2luYXRpb24uZWwpIHBhcmFtcy5wYWdpbmF0aW9uLmVsID0gJy5zd2lwZXItcGFnaW5hdGlvbic7XG4gICAgICBpZiAoc2VsZi5uYXZpZ2F0aW9uICYmICFwYXJhbXMubmF2aWdhdGlvbi5uZXh0RWwgJiYgIXBhcmFtcy5uYXZpZ2F0aW9uLnByZXZFbCkge1xuICAgICAgICBwYXJhbXMubmF2aWdhdGlvbi5uZXh0RWwgPSAnLnN3aXBlci1idXR0b24tbmV4dCc7XG4gICAgICAgIHBhcmFtcy5uYXZpZ2F0aW9uLnByZXZFbCA9ICcuc3dpcGVyLWJ1dHRvbi1wcmV2JztcbiAgICAgIH1cbiAgICAgIGlmIChzZWxmLnNjcm9sbGJhciAmJiAhcGFyYW1zLnNjcm9sbGJhci5lbCkgcGFyYW1zLnNjcm9sbGJhci5lbCA9ICcuc3dpcGVyLXNjcm9sbGJhcic7XG5cbiAgICAgIHNlbGYuc3dpcGVyID0gZjcuc3dpcGVyLmNyZWF0ZSh0aGlzLiRlbCwgcGFyYW1zKTtcbiAgICB9LFxuICB9LFxufTtcblxuY29uc3QgVGFiUHJvcHMgPSBVdGlscy5leHRlbmQoe1xuICB0YWJBY3RpdmU6IEJvb2xlYW4sXG4gIGlkOiBTdHJpbmcsXG59LCBNaXhpbnMuY29sb3JQcm9wcyk7XG5cbnZhciBmN1RhYiA9IHtcbiAgbmFtZTogJ2Y3LXRhYicsXG4gIHByb3BzOiBUYWJQcm9wcyxcbiAgZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdGFiQ29udGVudDogbnVsbCxcbiAgICB9O1xuICB9LFxuICByZW5kZXIoYykge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuXG4gICAgcmV0dXJuIGMoXG4gICAgICAnZGl2Jywge1xuICAgICAgICBzdGF0aWNDbGFzczogJ3RhYicsXG4gICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgaWQ6IHNlbGYuaWQsXG4gICAgICAgIH0sXG4gICAgICAgIGNsYXNzOiBVdGlscy5leHRlbmQoe1xuICAgICAgICAgICd0YWItYWN0aXZlJzogc2VsZi50YWJBY3RpdmUsXG4gICAgICAgIH0sIE1peGlucy5jb2xvckNsYXNzZXMoc2VsZikpLFxuICAgICAgICBvbjoge1xuICAgICAgICAgICd0YWI6c2hvdyc6IHNlbGYub25UYWJTaG93LFxuICAgICAgICAgICd0YWI6aGlkZSc6IHNlbGYub25UYWJIaWRlLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICAgIFtzZWxmLnRhYkNvbnRlbnQgPyBjKHNlbGYudGFiQ29udGVudC5jb21wb25lbnQsIHsgdGFnOiAnY29tcG9uZW50JywgcHJvcHM6IHNlbGYudGFiQ29udGVudC5wYXJhbXMsIGtleTogc2VsZi50YWJDb250ZW50LmlkIH0pIDogc2VsZi4kc2xvdHMuZGVmYXVsdF1cbiAgICApO1xuICB9LFxuICBtZXRob2RzOiB7XG4gICAgc2hvdyhhbmltYXRlKSB7XG4gICAgICBpZiAoIXRoaXMuJGY3KSByZXR1cm47XG4gICAgICB0aGlzLiRmNy50YWIuc2hvdyh0aGlzLiRlbCwgYW5pbWF0ZSk7XG4gICAgfSxcbiAgICBvblRhYlNob3coZSkge1xuICAgICAgdGhpcy4kZW1pdCgndGFiOnNob3cnLCBlKTtcbiAgICB9LFxuICAgIG9uVGFiSGlkZShlKSB7XG4gICAgICB0aGlzLiRlbWl0KCd0YWI6aGlkZScsIGUpO1xuICAgIH0sXG4gIH0sXG59O1xuXG5jb25zdCBUYWJzUHJvcHMgPSBVdGlscy5leHRlbmQoe1xuICBhbmltYXRlZDogQm9vbGVhbixcbiAgc3dpcGVhYmxlOiBCb29sZWFuLFxuICByb3V0YWJsZTogQm9vbGVhbixcbn0sIE1peGlucy5jb2xvclByb3BzKTtcblxudmFyIGY3VGFicyA9IHtcbiAgbmFtZTogJ2Y3LXRhYnMnLFxuICByZW5kZXIoYykge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIGNvbnN0IHRhYnNFbCA9IGMoJ2RpdicsIHsgc3RhdGljQ2xhc3M6ICd0YWJzJyB9LCBbc2VsZi4kc2xvdHMuZGVmYXVsdF0pO1xuICAgIGlmIChzZWxmLmFuaW1hdGVkIHx8IHNlbGYuc3dpcGVhYmxlKSByZXR1cm4gYygnZGl2JywgeyBjbGFzczogc2VsZi5jbGFzc2VzIH0sIFt0YWJzRWxdKTtcbiAgICByZXR1cm4gdGFic0VsO1xuICB9LFxuICBwcm9wczogVGFic1Byb3BzLFxuICBjb21wdXRlZDoge1xuICAgIGNsYXNzZXMoKSB7XG4gICAgICByZXR1cm4gVXRpbHMuZXh0ZW5kKHtcbiAgICAgICAgJ3RhYnMtYW5pbWF0ZWQtd3JhcCc6IHRoaXMuYW5pbWF0ZWQsXG4gICAgICAgICd0YWJzLXN3aXBlYWJsZS13cmFwJzogdGhpcy5zd2lwZWFibGUsXG4gICAgICAgICd0YWJzLXJvdXRhYmxlJzogdGhpcy5yb3V0YWJsZSxcbiAgICAgIH0sIE1peGlucy5jb2xvckNsYXNzZXModGhpcykpO1xuICAgIH0sXG4gIH0sXG59O1xuXG5jb25zdCBUb29sYmFyUHJvcHMgPSBVdGlscy5leHRlbmQoe1xuICBib3R0b21NZDogQm9vbGVhbixcbiAgdGFiYmFyOiBCb29sZWFuLFxuICBsYWJlbHM6IEJvb2xlYW4sXG4gIHNjcm9sbGFibGU6IEJvb2xlYW4sXG4gIGhpZGRlbjogQm9vbGVhbixcbiAgbm9TaGFkb3c6IEJvb2xlYW4sXG4gIG5vSGFpcmxpbmU6IEJvb2xlYW4sXG4gIGlubmVyOiB7XG4gICAgdHlwZTogQm9vbGVhbixcbiAgICBkZWZhdWx0OiB0cnVlLFxuICB9LFxufSwgTWl4aW5zLmNvbG9yUHJvcHMpO1xuXG52YXIgZjdUb29sYmFyID0ge3JlbmRlcjogZnVuY3Rpb24oKXt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtyZXR1cm4gX2MoJ2Rpdicse3N0YXRpY0NsYXNzOlwidG9vbGJhclwiLGNsYXNzOl92bS5jbGFzc2VzfSxbX3ZtLl90KFwiYmVmb3JlLWlubmVyXCIpLF92bS5fdihcIiBcIiksKF92bS5pbm5lcik/X2MoJ2Rpdicse3N0YXRpY0NsYXNzOlwidG9vbGJhci1pbm5lclwifSxbX3ZtLl90KFwiZGVmYXVsdFwiKV0sMik6X3ZtLl90KFwiZGVmYXVsdFwiKSxfdm0uX3YoXCIgXCIpLF92bS5fdChcImFmdGVyLWlubmVyXCIpXSwyKX0sc3RhdGljUmVuZGVyRm5zOiBbXSxcbiAgbmFtZTogJ2Y3LXRvb2xiYXInLFxuICBwcm9wczogVG9vbGJhclByb3BzLFxuICB1cGRhdGVkKCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIGlmIChzZWxmLnRhYmJhciAmJiBzZWxmLiRmNykge1xuICAgICAgc2VsZi4kbmV4dFRpY2soKCkgPT4ge1xuICAgICAgICBzZWxmLiRmNy50b29sYmFyLnNldEhpZ2hsaWdodChzZWxmLiRlbCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG4gIGNvbXB1dGVkOiB7XG4gICAgY2xhc3NlcygpIHtcbiAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgcmV0dXJuIFV0aWxzLmV4dGVuZCh7XG4gICAgICAgICd0b29sYmFyLWJvdHRvbS1tZCc6IHNlbGYuYm90dG9tTWQsXG4gICAgICAgIHRhYmJhcjogc2VsZi50YWJiYXIsXG4gICAgICAgICd0YWJiYXItbGFiZWxzJzogc2VsZi5sYWJlbHMsXG4gICAgICAgICd0YWJiYXItc2Nyb2xsYWJsZSc6IHNlbGYuc2Nyb2xsYWJsZSxcbiAgICAgICAgJ3Rvb2xiYXItaGlkZGVuJzogc2VsZi5oaWRkZW4sXG4gICAgICAgICduby1zaGFkb3cnOiBzZWxmLm5vU2hhZG93LFxuICAgICAgICAnbm8taGFpcmxpbmUnOiBzZWxmLm5vSGFpcmxpbmUsXG4gICAgICB9LCBNaXhpbnMuY29sb3JDbGFzc2VzKHNlbGYpKTtcbiAgICB9LFxuICB9LFxuICBtZXRob2RzOiB7XG4gICAgaGlkZShhbmltYXRlKSB7XG4gICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgIGlmICghc2VsZi4kZjcpIHJldHVybjtcbiAgICAgIHNlbGYuJGY3LnRvb2xiYXIuaGlkZSh0aGlzLiRlbCwgYW5pbWF0ZSk7XG4gICAgfSxcbiAgICBzaG93KGFuaW1hdGUpIHtcbiAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgaWYgKCFzZWxmLiRmNykgcmV0dXJuO1xuICAgICAgc2VsZi4kZjcudG9vbGJhci5zaG93KHRoaXMuJGVsLCBhbmltYXRlKTtcbiAgICB9LFxuICAgIG9uRjdSZWFkeShmNykge1xuICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICBpZiAoc2VsZi50YWJiYXIpIGY3LnRvb2xiYXIuc2V0SGlnaGxpZ2h0KHNlbGYuJGVsKTtcbiAgICB9LFxuICB9LFxufTtcblxuY29uc3QgVmlld1Byb3BzID0gVXRpbHMuZXh0ZW5kKFxuICB7XG4gICAgdGFiOiBCb29sZWFuLFxuICAgIHRhYkFjdGl2ZTogQm9vbGVhbixcblxuICAgIG5hbWU6IFN0cmluZyxcbiAgICByb3V0ZXI6IEJvb2xlYW4sXG4gICAgbGlua3NWaWV3OiBbT2JqZWN0LCBTdHJpbmddLFxuICAgIHVybDogU3RyaW5nLFxuICAgIG1haW46IEJvb2xlYW4sXG4gICAgc3RhY2tQYWdlczogQm9vbGVhbixcbiAgICB4aHJDYWNoZTogU3RyaW5nLFxuICAgIHhockNhY2hlSWdub3JlOiBBcnJheSxcbiAgICB4aHJDYWNoZUlnbm9yZUdldFBhcmFtZXRlcnM6IEJvb2xlYW4sXG4gICAgeGhyQ2FjaGVEdXJhdGlvbjogTnVtYmVyLFxuICAgIHByZWxvYWRQcmV2aW91c1BhZ2U6IEJvb2xlYW4sXG4gICAgdW5pcXVlSGlzdG9yeTogQm9vbGVhbixcbiAgICB1bmlxdWVIaXN0b3J5SWdub3JlR2V0UGFyYW1ldGVyczogQm9vbGVhbixcbiAgICBhbGxvd0R1cGxpY2F0ZVVybHM6IEJvb2xlYW4sXG4gICAgcmVsb2FkUGFnZXM6IEJvb2xlYW4sXG4gICAgcmVtb3ZlRWxlbWVudHM6IEJvb2xlYW4sXG4gICAgcmVtb3ZlRWxlbWVudHNXaXRoVGltZW91dDogQm9vbGVhbixcbiAgICByZW1vdmVFbGVtZW50c1RpbWVvdXQ6IE51bWJlcixcbiAgICByZXN0b3JlU2Nyb2xsVG9wT25CYWNrOiBCb29sZWFuLFxuICAgIC8vIFN3aXBlIEJhY2tcbiAgICBpb3NTd2lwZUJhY2s6IEJvb2xlYW4sXG4gICAgaW9zU3dpcGVCYWNrQW5pbWF0ZVNoYWRvdzogQm9vbGVhbixcbiAgICBpb3NTd2lwZUJhY2tBbmltYXRlT3BhY2l0eTogQm9vbGVhbixcbiAgICBpb3NTd2lwZUJhY2tBY3RpdmVBcmVhOiBOdW1iZXIsXG4gICAgaW9zU3dpcGVCYWNrVGhyZXNob2xkOiBOdW1iZXIsXG4gICAgLy8gUHVzaCBTdGF0ZVxuICAgIHB1c2hTdGF0ZTogQm9vbGVhbixcbiAgICBwdXNoU3RhdGVSb290OiBTdHJpbmcsXG4gICAgcHVzaFN0YXRlQW5pbWF0ZTogQm9vbGVhbixcbiAgICBwdXNoU3RhdGVBbmltYXRlT25Mb2FkOiBCb29sZWFuLFxuICAgIHB1c2hTdGF0ZVNlcGFyYXRvcjogU3RyaW5nLFxuICAgIHB1c2hTdGF0ZU9uTG9hZDogQm9vbGVhbixcbiAgICAvLyBBbmltYXRlIFBhZ2VzXG4gICAgYW5pbWF0ZTogQm9vbGVhbixcbiAgICAvLyBpT1MgRHluYW1pYyBOYXZiYXJcbiAgICBpb3NEeW5hbWljTmF2YmFyOiBCb29sZWFuLFxuICAgIGlvc1NlcGFyYXRlRHluYW1pY05hdmJhcjogQm9vbGVhbixcbiAgICAvLyBBbmltYXRlIGlPUyBOYXZiYXIgQmFjayBJY29uXG4gICAgaW9zQW5pbWF0ZU5hdmJhckJhY2tJY29uOiBCb29sZWFuLFxuICAgIC8vIE1EIFRoZW1lIGRlbGF5XG4gICAgbWF0ZXJpYWxQYWdlTG9hZERlbGF5OiBOdW1iZXIsXG5cbiAgICBwYXNzUm91dGVRdWVyeVRvUmVxdWVzdDogQm9vbGVhbixcbiAgICBwYXNzUm91dGVQYXJhbXNUb1JlcXVlc3Q6IEJvb2xlYW4sXG4gICAgcm91dGVzOiBBcnJheSxcbiAgICByb3V0ZXNBZGQ6IEFycmF5LFxuXG4gICAgaW5pdDoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgfSxcbiAgfSxcbiAgTWl4aW5zLmNvbG9yUHJvcHNcbik7XG5cbnZhciBmN1ZpZXcgPSB7XG4gIG5hbWU6ICdmNy12aWV3JyxcbiAgcHJvcHM6IFZpZXdQcm9wcyxcbiAgcmVuZGVyKGMpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBjb25zdCBwYWdlcyA9IHNlbGYucGFnZXMubWFwKHBhZ2UgPT4gYyhwYWdlLmNvbXBvbmVudCwge1xuICAgICAgdGFnOiAnY29tcG9uZW50JyxcbiAgICAgIHByb3BzOiBwYWdlLnBhcmFtcyA/IHBhZ2UucGFyYW1zIHx8IHt9IDoge30sXG4gICAgICBrZXk6IHBhZ2UuaWQsXG4gICAgfSkpO1xuICAgIHJldHVybiBjKFxuICAgICAgJ2RpdicsXG4gICAgICB7XG4gICAgICAgIHN0YXRpY0NsYXNzOiAndmlldycsXG4gICAgICAgIHJlZjogJ3ZpZXcnLFxuICAgICAgICBjbGFzczogc2VsZi5jbGFzc2VzLFxuICAgICAgICBvbjoge1xuICAgICAgICAgICdzd2lwZWJhY2s6bW92ZSc6IHNlbGYub25Td2lwZUJhY2tNb3ZlLFxuICAgICAgICAgICdzd2lwZWJhY2s6YmVmb3JlY2hhbmdlJzogc2VsZi5vblN3aXBlQmFja0JlZm9yZUNoYW5nZSxcbiAgICAgICAgICAnc3dpcGViYWNrOmFmdGVyY2hhbmdlJzogc2VsZi5vblN3aXBlQmFja0FmdGVyQ2hhbmdlLFxuICAgICAgICAgICdzd2lwZWJhY2s6YmVmb3JlcmVzZXQnOiBzZWxmLm9uU3dpcGVCYWNrQmVmb3JlUmVzZXQsXG4gICAgICAgICAgJ3N3aXBlYmFjazphZnRlcnJlc2V0Jzogc2VsZi5vblN3aXBlQmFja0FmdGVyUmVzZXQsXG4gICAgICAgICAgJ3RhYjpzaG93Jzogc2VsZi5vblRhYlNob3csXG4gICAgICAgICAgJ3RhYjpoaWRlJzogc2VsZi5vblRhYkhpZGUsXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgICAgW1xuICAgICAgICBzZWxmLiRzbG90cy5kZWZhdWx0LFxuICAgICAgICBwYWdlcyxcbiAgICAgIF1cbiAgICApO1xuICB9LFxuICBiZWZvcmVEZXN0cm95KCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIGlmIChzZWxmLmY3VmlldyAmJiBzZWxmLmY3Vmlldy5kZXN0cm95KSBzZWxmLmY3Vmlldy5kZXN0cm95KCk7XG4gIH0sXG4gIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhZ2VzOiBbXSxcbiAgICB9O1xuICB9LFxuICBjb21wdXRlZDoge1xuICAgIGNsYXNzZXMoKSB7XG4gICAgICByZXR1cm4gVXRpbHMuZXh0ZW5kKFxuICAgICAgICB7XG4gICAgICAgICAgJ3ZpZXctbWFpbic6IHRoaXMubWFpbixcbiAgICAgICAgICAndGFiLWFjdGl2ZSc6IHRoaXMudGFiQWN0aXZlLFxuICAgICAgICAgIHRhYjogdGhpcy50YWIsXG4gICAgICAgIH0sXG4gICAgICAgIE1peGlucy5jb2xvckNsYXNzZXModGhpcylcbiAgICAgICk7XG4gICAgfSxcbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIG9uRjdSZWFkeShmNykge1xuICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICBpZiAoIXNlbGYuaW5pdCkgcmV0dXJuO1xuXG4gICAgICAvLyBJbml0IFZpZXdcbiAgICAgIHNlbGYuZjdWaWV3ID0gZjcudmlld3MuY3JlYXRlKHNlbGYuJGVsLCBzZWxmLiRvcHRpb25zLnByb3BzRGF0YSk7XG4gICAgfSxcbiAgICBvblN3aXBlQmFja01vdmUoZXZlbnQpIHtcbiAgICAgIHRoaXMuJGVtaXQoJ3N3aXBlYmFjazptb3ZlJywgZXZlbnQsIGV2ZW50LmRldGFpbCk7XG4gICAgfSxcbiAgICBvblN3aXBlQmFja0JlZm9yZUNoYW5nZShldmVudCkge1xuICAgICAgdGhpcy4kZW1pdCgnc3dpcGViYWNrOmJlZm9yZWNoYW5nZScsIGV2ZW50LCBldmVudC5kZXRhaWwpO1xuICAgIH0sXG4gICAgb25Td2lwZUJhY2tBZnRlckNoYW5nZShldmVudCkge1xuICAgICAgdGhpcy4kZW1pdCgnc3dpcGViYWNrOmFmdGVyY2hhbmdlJywgZXZlbnQsIGV2ZW50LmRldGFpbCk7XG4gICAgfSxcbiAgICBvblN3aXBlQmFja0JlZm9yZVJlc2V0KGV2ZW50KSB7XG4gICAgICB0aGlzLiRlbWl0KCdzd2lwZWJhY2s6YmVmb3JlcmVzZXQnLCBldmVudCwgZXZlbnQuZGV0YWlsKTtcbiAgICB9LFxuICAgIG9uU3dpcGVCYWNrQWZ0ZXJSZXNldChldmVudCkge1xuICAgICAgdGhpcy4kZW1pdCgnc3dpcGViYWNrOmFmdGVycmVzZXQnLCBldmVudCwgZXZlbnQuZGV0YWlsKTtcbiAgICB9LFxuICAgIG9uVGFiU2hvdyhlKSB7XG4gICAgICB0aGlzLiRlbWl0KCd0YWI6c2hvdycsIGUpO1xuICAgIH0sXG4gICAgb25UYWJIaWRlKGUpIHtcbiAgICAgIHRoaXMuJGVtaXQoJ3RhYjpoaWRlJywgZSk7XG4gICAgfSxcbiAgfSxcbn07XG5cbmNvbnN0IFZpZXdzUHJvcHMgPSBVdGlscy5leHRlbmQoXG4gIHtcbiAgICB0YWJzOiBCb29sZWFuLFxuICB9LFxuICBNaXhpbnMuY29sb3JQcm9wc1xuKTtcblxudmFyIGY3Vmlld3MgPSB7cmVuZGVyOiBmdW5jdGlvbigpe3ZhciBfdm09dGhpczt2YXIgX2g9X3ZtLiRjcmVhdGVFbGVtZW50O3ZhciBfYz1fdm0uX3NlbGYuX2N8fF9oO3JldHVybiBfYygnZGl2Jyx7c3RhdGljQ2xhc3M6XCJ2aWV3c1wiLGNsYXNzOl92bS5jbGFzc2VzfSxbX3ZtLl90KFwiZGVmYXVsdFwiKV0sMil9LHN0YXRpY1JlbmRlckZuczogW10sXG4gIG5hbWU6ICdmNy12aWV3cycsXG4gIHByb3BzOiBWaWV3c1Byb3BzLFxuICBjb21wdXRlZDoge1xuICAgIGNsYXNzZXMoKSB7XG4gICAgICByZXR1cm4gVXRpbHMuZXh0ZW5kKFxuICAgICAgICB7XG4gICAgICAgICAgdGFiczogdGhpcy50YWJzLFxuICAgICAgICB9LFxuICAgICAgICBNaXhpbnMuY29sb3JDbGFzc2VzKHRoaXMpXG4gICAgICApO1xuICAgIH0sXG4gIH0sXG59O1xuXG4vKiBlc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246IFwib2ZmXCIgKi9cblxudmFyIHZ1ZVBsdWdpbiA9IHtcbiAgaW5zdGFsbChWdWUsIEZyYW1ld29yazcgPSB3aW5kb3cuRnJhbWV3b3JrNykge1xuICAgIC8vIENoZWNrIGZvciBGN1xuICAgIGlmICh0eXBlb2YgRnJhbWV3b3JrNyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRnJhbWV3b3JrNyBpcyB1bmRlZmluZWQsIG1ha2Ugc3VyZSB5b3UgaGF2ZSBwYXNzZWQgaXQgYXMgYW4gYXJndW1lbnQ6IFZ1ZS51c2UoRnJhbWV3b3JrN1Z1ZSwgRnJhbWV3b3JrNyknKTtcbiAgICB9XG4gICAgLy8gRXZlbnQgSHViXG4gICAgY29uc3QgZXZlbnRIdWIgPSBuZXcgVnVlKCk7XG5cbiAgICAvLyBGbGFnc1xuICAgIGxldCBmN1JlYWR5ID0gZmFsc2U7XG4gICAgbGV0IGY3SW5zdGFuY2U7XG5cbiAgICAvLyBEZWZpbmUgcHJvdG9zXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZS5wcm90b3R5cGUsICckZjcnLCB7XG4gICAgICBnZXQoKSB7XG4gICAgICAgIHJldHVybiBmN0luc3RhbmNlO1xuICAgICAgfSxcbiAgICB9KTtcblxuICAgIGNvbnN0ICR0aGVtZSA9IHt9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJHRoZW1lJywge1xuICAgICAgZ2V0KCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGlvczogZjdJbnN0YW5jZSA/IGY3SW5zdGFuY2UudGhlbWUgPT09ICdpb3MnIDogJHRoZW1lLmlvcyxcbiAgICAgICAgICBtZDogZjdJbnN0YW5jZSA/IGY3SW5zdGFuY2UudGhlbWUgPT09ICdtZCcgOiAkdGhlbWUubWQsXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgIH0pO1xuICAgIFZ1ZS5wcm90b3R5cGUuRG9tNyA9IEZyYW1ld29yazcuJDtcbiAgICBWdWUucHJvdG90eXBlLiQkID0gRnJhbWV3b3JrNy4kO1xuICAgIFZ1ZS5wcm90b3R5cGUuJGRldmljZSA9IEZyYW1ld29yazcuZGV2aWNlO1xuICAgIFZ1ZS5wcm90b3R5cGUuJHJlcXVlc3QgPSBGcmFtZXdvcms3LnJlcXVlc3Q7XG4gICAgVnVlLnByb3RvdHlwZS4kdXRpbHMgPSBGcmFtZXdvcms3LnV0aWxzO1xuXG4gICAgLy8gSW5pdCBGN1xuICAgIGZ1bmN0aW9uIGluaXRGcmFtZXdvcms3KHJvb3RFbCwgcGFyYW1zLCByb3V0ZXMpIHtcbiAgICAgIGNvbnN0IGY3UGFyYW1zID0gVXRpbHMuZXh0ZW5kKHt9LCAocGFyYW1zIHx8IHt9KSwgeyByb290OiByb290RWwgfSk7XG4gICAgICBpZiAocm91dGVzICYmIHJvdXRlcy5sZW5ndGggJiYgIWY3UGFyYW1zLnJvdXRlcykgZjdQYXJhbXMucm91dGVzID0gcm91dGVzO1xuXG4gICAgICBmN0luc3RhbmNlID0gbmV3IEZyYW1ld29yazcoZjdQYXJhbXMpO1xuICAgICAgZjdSZWFkeSA9IHRydWU7XG4gICAgICBldmVudEh1Yi4kZW1pdCgnZjdSZWFkeScsIGY3SW5zdGFuY2UpO1xuICAgIH1cblxuICAgIC8vIEV4dGVuZCBGNyBSb3V0ZXJcbiAgICBGcmFtZXdvcms3LlJvdXRlclxuICAgICAgLnVzZShWdWVSb3V0ZXIpXG4gICAgICAudXNlKHtcbiAgICAgICAgb246IHtcbiAgICAgICAgICByb3V0ZUNoYW5nZSh0bywgZnJvbSwgcm91dGVyKSB7XG4gICAgICAgICAgICBldmVudEh1Yi4kZW1pdCgnZjdSb3V0ZUNoYW5nZScsIHRvLCBmcm9tLCByb3V0ZXIpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgcm91dGVDaGFuZ2VkKHRvLCBmcm9tLCByb3V0ZXIpIHtcbiAgICAgICAgICAgIGV2ZW50SHViLiRlbWl0KCdmN1JvdXRlQ2hhbmdlZCcsIHRvLCBmcm9tLCByb3V0ZXIpO1xuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICB9KTtcblxuICAgIC8vIE1peGluXG4gICAgVnVlLm1peGluKHtcbiAgICAgIGRpcmVjdGl2ZXM6IERpcmVjdGl2ZXMsXG4gICAgICBjb21wb25lbnRzOiB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICBmN0FjY29yZGlvbkNvbnRlbnQsXG4gICAgICAgIGY3QWNjb3JkaW9uSXRlbSxcbiAgICAgICAgZjdBY2NvcmRpb25Ub2dnbGUsXG4gICAgICAgIGY3QWNjb3JkaW9uLFxuICAgICAgICBmN0FjdGlvbnNCdXR0b24sXG4gICAgICAgIGY3QWN0aW9uc0dyb3VwLFxuICAgICAgICBmN0FjdGlvbnNMYWJlbCxcbiAgICAgICAgZjdBY3Rpb25zLFxuICAgICAgICBmN0JhZGdlLFxuICAgICAgICBmN0Jsb2NrRm9vdGVyLFxuICAgICAgICBmN0Jsb2NrSGVhZGVyLFxuICAgICAgICBmN0Jsb2NrVGl0bGUsXG4gICAgICAgIGY3QmxvY2ssXG4gICAgICAgIGY3QnV0dG9uLFxuICAgICAgICBmN0NhcmRDb250ZW50LFxuICAgICAgICBmN0NhcmRGb290ZXIsXG4gICAgICAgIGY3Q2FyZEhlYWRlcixcbiAgICAgICAgZjdDYXJkLFxuICAgICAgICBmN0NoZWNrYm94LFxuICAgICAgICBmN0NoaXAsXG4gICAgICAgIGY3Q29sLFxuICAgICAgICBmN0ZhYkJ1dHRvbixcbiAgICAgICAgZjdGYWJCdXR0b25zLFxuICAgICAgICBmN0ZhYixcbiAgICAgICAgZjdJY29uLFxuICAgICAgICBmN0lucHV0LFxuICAgICAgICBmN0xhYmVsLFxuICAgICAgICBmN0xpbmssXG4gICAgICAgIGY3TGlzdEJ1dHRvbixcbiAgICAgICAgZjdMaXN0R3JvdXAsXG4gICAgICAgIGY3TGlzdEluZGV4LFxuICAgICAgICBmN0xpc3RJdGVtQ2VsbCxcbiAgICAgICAgZjdMaXN0SXRlbUNvbnRlbnQsXG4gICAgICAgIGY3TGlzdEl0ZW1Sb3csXG4gICAgICAgIGY3TGlzdEl0ZW0sXG4gICAgICAgIGY3TGlzdCxcbiAgICAgICAgZjdMb2dpblNjcmVlblRpdGxlLFxuICAgICAgICBmN0xvZ2luU2NyZWVuLFxuICAgICAgICBmN01lc3NhZ2UsXG4gICAgICAgIGY3TWVzc2FnZWJhckF0dGFjaG1lbnQsXG4gICAgICAgIGY3TWVzc2FnZWJhckF0dGFjaG1lbnRzLFxuICAgICAgICBmN01lc3NhZ2ViYXJTaGVldEltYWdlLFxuICAgICAgICBmN01lc3NhZ2ViYXJTaGVldEl0ZW0sXG4gICAgICAgIGY3TWVzc2FnZWJhclNoZWV0LFxuICAgICAgICBmN01lc3NhZ2ViYXIsXG4gICAgICAgIGY3TWVzc2FnZXNUaXRsZSxcbiAgICAgICAgZjdNZXNzYWdlcyxcbiAgICAgICAgZjdOYXZMZWZ0LFxuICAgICAgICBmN05hdlJpZ2h0LFxuICAgICAgICBmN05hdlRpdGxlLFxuICAgICAgICBmN05hdmJhcixcbiAgICAgICAgZjdQYWdlQ29udGVudCxcbiAgICAgICAgZjdQYWdlLFxuICAgICAgICBmN1BhbmVsLFxuICAgICAgICBmN1Bob3RvQnJvd3NlcixcbiAgICAgICAgZjdQb3BvdmVyLFxuICAgICAgICBmN1BvcHVwLFxuICAgICAgICBmN1ByZWxvYWRlcixcbiAgICAgICAgZjdQcm9ncmVzc2JhcixcbiAgICAgICAgZjdSYWRpbyxcbiAgICAgICAgZjdSYW5nZSxcbiAgICAgICAgZjdSb3V0YWJsZU1vZGFscyxcbiAgICAgICAgZjdSb3csXG4gICAgICAgIGY3U2VhcmNoYmFyLFxuICAgICAgICBmN1NlZ21lbnRlZCxcbiAgICAgICAgZjdTaGVldCxcbiAgICAgICAgZjdTdGF0dXNiYXIsXG4gICAgICAgIGY3U3RlcHBlcixcbiAgICAgICAgZjdTdWJuYXZiYXIsXG4gICAgICAgIGY3U3dpcGVvdXRBY3Rpb25zLFxuICAgICAgICBmN1N3aXBlb3V0QnV0dG9uLFxuICAgICAgICBmN1N3aXBlclNsaWRlLFxuICAgICAgICBmN1N3aXBlcixcbiAgICAgICAgZjdUYWIsXG4gICAgICAgIGY3VGFicyxcbiAgICAgICAgZjdUb2dnbGUsXG4gICAgICAgIGY3VG9vbGJhcixcbiAgICAgICAgZjdWaWV3LFxuICAgICAgICBmN1ZpZXdzLFxuICAgICAgfSxcbiAgICAgIGJlZm9yZUNyZWF0ZSgpIHtcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgIGlmIChzZWxmID09PSBzZWxmLiRyb290KSB7XG4gICAgICAgICAgY29uc3QgeyB0aGVtZSB9ID0gKHNlbGYuJG9wdGlvbnMuZnJhbWV3b3JrNyB8fCB7fSk7XG4gICAgICAgICAgaWYgKHRoZW1lID09PSAnbWQnKSAkdGhlbWUubWQgPSB0cnVlO1xuICAgICAgICAgIGlmICh0aGVtZSA9PT0gJ2lvcycpICR0aGVtZS5pb3MgPSB0cnVlO1xuICAgICAgICAgIGlmICghdGhlbWUgfHwgdGhlbWUgPT09ICdhdXRvJykge1xuICAgICAgICAgICAgJHRoZW1lLmlvcyA9ICEhKEZyYW1ld29yazcuRGV2aWNlIHx8IEZyYW1ld29yazcuZGV2aWNlKS5pb3M7XG4gICAgICAgICAgICAkdGhlbWUubWQgPSAhKEZyYW1ld29yazcuRGV2aWNlIHx8IEZyYW1ld29yazcuZGV2aWNlKS5pb3M7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0ICRyb3V0ZTtcbiAgICAgICAgbGV0ICRyb3V0ZXI7XG4gICAgICAgIGxldCBwYXJlbnQgPSBzZWxmO1xuICAgICAgICB3aGlsZSAocGFyZW50ICYmICEkcm91dGVyICYmICEkcm91dGUpIHtcbiAgICAgICAgICBpZiAocGFyZW50LiRmN3JvdXRlKSAkcm91dGUgPSBwYXJlbnQuJGY3cm91dGU7XG4gICAgICAgICAgaWYgKHBhcmVudC4kZjdyb3V0ZXIpICRyb3V0ZXIgPSBwYXJlbnQuJGY3cm91dGVyO1xuICAgICAgICAgIGVsc2UgaWYgKHBhcmVudC5mN1ZpZXcpIHtcbiAgICAgICAgICAgICRyb3V0ZXIgPSBwYXJlbnQuZjdWaWV3LnJvdXRlcjtcbiAgICAgICAgICB9IGVsc2UgaWYgKHBhcmVudC4kZWwgJiYgcGFyZW50LiRlbC5mN1ZpZXcpIHtcbiAgICAgICAgICAgICRyb3V0ZXIgPSBwYXJlbnQuJGVsLmY3Vmlldy5yb3V0ZXI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBhcmVudCA9IHBhcmVudC4kcGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIGlmICgkcm91dGUgJiYgJHJvdXRlcikge1xuICAgICAgICAgIHNlbGYuJGY3cm91dGUgPSAkcm91dGU7XG4gICAgICAgICAgc2VsZi4kZjdyb3V0ZXIgPSAkcm91dGVyO1xuICAgICAgICAgIHNlbGYuJGY3Um91dGUgPSAkcm91dGU7XG4gICAgICAgICAgc2VsZi4kZjdSb3V0ZXIgPSAkcm91dGVyO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgYmVmb3JlRGVzdHJveSgpIHtcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgIGlmIChzZWxmLiRmN1JvdXRlQ2hhbmdlQ2FsbGJhY2spIGV2ZW50SHViLiRvZmYoJ2Y3Um91dGVDaGFuZ2UnLCBzZWxmLiRmN1JvdXRlQ2hhbmdlQ2FsbGJhY2spO1xuICAgICAgICBpZiAoc2VsZi4kZjdSb3V0ZUNoYW5nZWRDYWxsYmFjaykgZXZlbnRIdWIuJG9mZignZjdSb3V0ZUNoYW5nZWQnLCBzZWxmLiRmN1JvdXRlQ2hhbmdlZENhbGxiYWNrKTtcbiAgICAgIH0sXG4gICAgICBjcmVhdGVkKCkge1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcblxuICAgICAgICBjb25zdCByb3V0ZUNoYW5nZUNhbGxiYWNrID0gc2VsZi5vbkY3Um91dGVDaGFuZ2UgfHwgc2VsZi5GN1JvdXRlQ2hhbmdlIHx8IHNlbGYuZjdSb3V0ZUNoYW5nZSB8fCBzZWxmLmY3cm91dGVDaGFuZ2U7XG4gICAgICAgIGNvbnN0IHJvdXRlQ2hhbmdlZENhbGxiYWNrID0gc2VsZi5vbkY3Um91dGVDaGFuZ2VkIHx8IHNlbGYuRjdSb3V0ZUNoYW5nZWQgfHwgc2VsZi5mN1JvdXRlQ2hhbmdlZCB8fCBzZWxmLmY3cm91dGVDaGFuZ2VkO1xuICAgICAgICBpZiAoIXJvdXRlQ2hhbmdlQ2FsbGJhY2sgJiYgIXJvdXRlQ2hhbmdlZENhbGxiYWNrKSByZXR1cm47XG5cbiAgICAgICAgZnVuY3Rpb24gaGFzUm91dGVyKHJvdXRlcikge1xuICAgICAgICAgIHJldHVybiAoc2VsZi4kZjdyb3V0ZXIgJiYgcm91dGVyID09PSBzZWxmLiRmN3JvdXRlcikgfHxcbiAgICAgICAgICAgICAgICAgKCFzZWxmLiRmN3JvdXRlciAmJiBzZWxmLiRmNyAmJiBzZWxmLiRmNy5yb3V0ZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gYWRkUm91dGVzQ2FsbGJhY2tzKCkge1xuICAgICAgICAgIGlmIChyb3V0ZUNoYW5nZUNhbGxiYWNrKSB7XG4gICAgICAgICAgICBzZWxmLiRmN1JvdXRlQ2hhbmdlQ2FsbGJhY2sgPSBmdW5jdGlvbiBvblJvdXRlQ2hhbmdlKHRvLCBmcm9tLCByb3V0ZXIpIHtcbiAgICAgICAgICAgICAgaWYgKGhhc1JvdXRlcihyb3V0ZXIpKSB7XG4gICAgICAgICAgICAgICAgcm91dGVDaGFuZ2VDYWxsYmFjayh0bywgZnJvbSwgcm91dGVyKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGV2ZW50SHViLiRvbignZjdSb3V0ZUNoYW5nZScsIHNlbGYuJGY3Um91dGVDaGFuZ2VDYWxsYmFjayk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyb3V0ZUNoYW5nZWRDYWxsYmFjaykge1xuICAgICAgICAgICAgc2VsZi4kZjdSb3V0ZUNoYW5nZWRDYWxsYmFjayA9IGZ1bmN0aW9uIG9uUm91dGVDaGFuZ2VkKHRvLCBmcm9tLCByb3V0ZXIpIHtcbiAgICAgICAgICAgICAgaWYgKGhhc1JvdXRlcihyb3V0ZXIpKSB7XG4gICAgICAgICAgICAgICAgcm91dGVDaGFuZ2VkQ2FsbGJhY2sodG8sIGZyb20sIHJvdXRlcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBldmVudEh1Yi4kb24oJ2Y3Um91dGVDaGFuZ2VkJywgc2VsZi4kZjdSb3V0ZUNoYW5nZWRDYWxsYmFjayk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFzZWxmLiRmNykgZXZlbnRIdWIuJG9uKCdmN1JlYWR5JywgYWRkUm91dGVzQ2FsbGJhY2tzKTtcbiAgICAgICAgZWxzZSBhZGRSb3V0ZXNDYWxsYmFja3MoKTtcbiAgICAgIH0sXG4gICAgICBtb3VudGVkKCkge1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgaWYgKHNlbGYgPT09IHNlbGYuJHJvb3QpIHtcbiAgICAgICAgICBpbml0RnJhbWV3b3JrNyhzZWxmLiRyb290LiRlbCwgc2VsZi4kb3B0aW9ucy5mcmFtZXdvcms3LCBzZWxmLiRvcHRpb25zLnJvdXRlcyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2FsbGJhY2sgPSBzZWxmLm9uRjdSZWFkeSB8fCBzZWxmLm9uRjdyZWFkeSB8fCBzZWxmLm9uRjdJbml0IHx8IHNlbGYub25GN2luaXQgfHwgc2VsZi5mN1JlYWR5IHx8IHNlbGYuZjdJbml0IHx8IHNlbGYuZjdyZWFkeSB8fCBzZWxmLmY3aW5pdDtcbiAgICAgICAgaWYgKCFjYWxsYmFjaykgcmV0dXJuO1xuICAgICAgICBpZiAoZjdSZWFkeSkgY2FsbGJhY2soZjdJbnN0YW5jZSk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGV2ZW50SHViLiRvbignZjdSZWFkeScsIChmNykgPT4ge1xuICAgICAgICAgICAgY2FsbGJhY2soZjcpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgIH0pO1xuICB9LFxufTtcblxuZXhwb3J0IGRlZmF1bHQgdnVlUGx1Z2luO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZnJhbWV3b3JrNy12dWUvZGlzdC9mcmFtZXdvcms3LXZ1ZS5lc20uYnVuZGxlLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9mcmFtZXdvcms3LXZ1ZS9kaXN0L2ZyYW1ld29yazctdnVlLmVzbS5idW5kbGUuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIEZyYW1ld29yazcgMi4yLjVcbiAqIEZ1bGwgZmVhdHVyZWQgbW9iaWxlIEhUTUwgZnJhbWV3b3JrIGZvciBidWlsZGluZyBpT1MgJiBBbmRyb2lkIGFwcHNcbiAqIGh0dHA6Ly9mcmFtZXdvcms3LmlvL1xuICpcbiAqIENvcHlyaWdodCAyMDE0LTIwMTggVmxhZGltaXIgS2hhcmxhbXBpZGlcbiAqXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcbiAqXG4gKiBSZWxlYXNlZCBvbjogQXByaWwgMjksIDIwMThcbiAqL1xuXG5pbXBvcnQgeyB3aW5kb3cgYXMgd2luZG93JDEsIGRvY3VtZW50IH0gZnJvbSAnc3NyLXdpbmRvdyc7XG5pbXBvcnQgJCBmcm9tICdkb203JztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgRG9tNyB9IGZyb20gJ2RvbTcnO1xuaW1wb3J0IFRlbXBsYXRlNyBmcm9tICd0ZW1wbGF0ZTcnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBUZW1wbGF0ZTcgfSBmcm9tICd0ZW1wbGF0ZTcnO1xuaW1wb3J0IFBhdGhUb1JlZ2V4cCBmcm9tICdwYXRoLXRvLXJlZ2V4cCc7XG5cbi8qKlxuICogaHR0cHM6Ly9naXRodWIuY29tL2dyZS9iZXppZXItZWFzaW5nXG4gKiBCZXppZXJFYXNpbmcgLSB1c2UgYmV6aWVyIGN1cnZlIGZvciB0cmFuc2l0aW9uIGVhc2luZyBmdW5jdGlvblxuICogYnkgR2HDq3RhbiBSZW5hdWRlYXUgMjAxNCAtIDIwMTUg4oCTIE1JVCBMaWNlbnNlXG4gKi9cblxuLyogZXNsaW50LWRpc2FibGUgKi9cblxuLy8gVGhlc2UgdmFsdWVzIGFyZSBlc3RhYmxpc2hlZCBieSBlbXBpcmljaXNtIHdpdGggdGVzdHMgKHRyYWRlb2ZmOiBwZXJmb3JtYW5jZSBWUyBwcmVjaXNpb24pXG52YXIgTkVXVE9OX0lURVJBVElPTlMgPSA0O1xudmFyIE5FV1RPTl9NSU5fU0xPUEUgPSAwLjAwMTtcbnZhciBTVUJESVZJU0lPTl9QUkVDSVNJT04gPSAwLjAwMDAwMDE7XG52YXIgU1VCRElWSVNJT05fTUFYX0lURVJBVElPTlMgPSAxMDtcblxudmFyIGtTcGxpbmVUYWJsZVNpemUgPSAxMTtcbnZhciBrU2FtcGxlU3RlcFNpemUgPSAxLjAgLyAoa1NwbGluZVRhYmxlU2l6ZSAtIDEuMCk7XG5cbnZhciBmbG9hdDMyQXJyYXlTdXBwb3J0ZWQgPSB0eXBlb2YgRmxvYXQzMkFycmF5ID09PSAnZnVuY3Rpb24nO1xuXG5mdW5jdGlvbiBBIChhQTEsIGFBMikgeyByZXR1cm4gMS4wIC0gMy4wICogYUEyICsgMy4wICogYUExOyB9XG5mdW5jdGlvbiBCIChhQTEsIGFBMikgeyByZXR1cm4gMy4wICogYUEyIC0gNi4wICogYUExOyB9XG5mdW5jdGlvbiBDIChhQTEpICAgICAgeyByZXR1cm4gMy4wICogYUExOyB9XG5cbi8vIFJldHVybnMgeCh0KSBnaXZlbiB0LCB4MSwgYW5kIHgyLCBvciB5KHQpIGdpdmVuIHQsIHkxLCBhbmQgeTIuXG5mdW5jdGlvbiBjYWxjQmV6aWVyIChhVCwgYUExLCBhQTIpIHsgcmV0dXJuICgoQShhQTEsIGFBMikgKiBhVCArIEIoYUExLCBhQTIpKSAqIGFUICsgQyhhQTEpKSAqIGFUOyB9XG5cbi8vIFJldHVybnMgZHgvZHQgZ2l2ZW4gdCwgeDEsIGFuZCB4Miwgb3IgZHkvZHQgZ2l2ZW4gdCwgeTEsIGFuZCB5Mi5cbmZ1bmN0aW9uIGdldFNsb3BlIChhVCwgYUExLCBhQTIpIHsgcmV0dXJuIDMuMCAqIEEoYUExLCBhQTIpICogYVQgKiBhVCArIDIuMCAqIEIoYUExLCBhQTIpICogYVQgKyBDKGFBMSk7IH1cblxuZnVuY3Rpb24gYmluYXJ5U3ViZGl2aWRlIChhWCwgYUEsIGFCLCBtWDEsIG1YMikge1xuICB2YXIgY3VycmVudFgsIGN1cnJlbnRULCBpID0gMDtcbiAgZG8ge1xuICAgIGN1cnJlbnRUID0gYUEgKyAoYUIgLSBhQSkgLyAyLjA7XG4gICAgY3VycmVudFggPSBjYWxjQmV6aWVyKGN1cnJlbnRULCBtWDEsIG1YMikgLSBhWDtcbiAgICBpZiAoY3VycmVudFggPiAwLjApIHtcbiAgICAgIGFCID0gY3VycmVudFQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFBID0gY3VycmVudFQ7XG4gICAgfVxuICB9IHdoaWxlIChNYXRoLmFicyhjdXJyZW50WCkgPiBTVUJESVZJU0lPTl9QUkVDSVNJT04gJiYgKytpIDwgU1VCRElWSVNJT05fTUFYX0lURVJBVElPTlMpO1xuICByZXR1cm4gY3VycmVudFQ7XG59XG5cbmZ1bmN0aW9uIG5ld3RvblJhcGhzb25JdGVyYXRlIChhWCwgYUd1ZXNzVCwgbVgxLCBtWDIpIHtcbiBmb3IgKHZhciBpID0gMDsgaSA8IE5FV1RPTl9JVEVSQVRJT05TOyArK2kpIHtcbiAgIHZhciBjdXJyZW50U2xvcGUgPSBnZXRTbG9wZShhR3Vlc3NULCBtWDEsIG1YMik7XG4gICBpZiAoY3VycmVudFNsb3BlID09PSAwLjApIHtcbiAgICAgcmV0dXJuIGFHdWVzc1Q7XG4gICB9XG4gICB2YXIgY3VycmVudFggPSBjYWxjQmV6aWVyKGFHdWVzc1QsIG1YMSwgbVgyKSAtIGFYO1xuICAgYUd1ZXNzVCAtPSBjdXJyZW50WCAvIGN1cnJlbnRTbG9wZTtcbiB9XG4gcmV0dXJuIGFHdWVzc1Q7XG59XG5cbmZ1bmN0aW9uIGJlemllciAobVgxLCBtWTEsIG1YMiwgbVkyKSB7XG4gIGlmICghKDAgPD0gbVgxICYmIG1YMSA8PSAxICYmIDAgPD0gbVgyICYmIG1YMiA8PSAxKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignYmV6aWVyIHggdmFsdWVzIG11c3QgYmUgaW4gWzAsIDFdIHJhbmdlJyk7XG4gIH1cblxuICAvLyBQcmVjb21wdXRlIHNhbXBsZXMgdGFibGVcbiAgdmFyIHNhbXBsZVZhbHVlcyA9IGZsb2F0MzJBcnJheVN1cHBvcnRlZCA/IG5ldyBGbG9hdDMyQXJyYXkoa1NwbGluZVRhYmxlU2l6ZSkgOiBuZXcgQXJyYXkoa1NwbGluZVRhYmxlU2l6ZSk7XG4gIGlmIChtWDEgIT09IG1ZMSB8fCBtWDIgIT09IG1ZMikge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga1NwbGluZVRhYmxlU2l6ZTsgKytpKSB7XG4gICAgICBzYW1wbGVWYWx1ZXNbaV0gPSBjYWxjQmV6aWVyKGkgKiBrU2FtcGxlU3RlcFNpemUsIG1YMSwgbVgyKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZXRURm9yWCAoYVgpIHtcbiAgICB2YXIgaW50ZXJ2YWxTdGFydCA9IDAuMDtcbiAgICB2YXIgY3VycmVudFNhbXBsZSA9IDE7XG4gICAgdmFyIGxhc3RTYW1wbGUgPSBrU3BsaW5lVGFibGVTaXplIC0gMTtcblxuICAgIGZvciAoOyBjdXJyZW50U2FtcGxlICE9PSBsYXN0U2FtcGxlICYmIHNhbXBsZVZhbHVlc1tjdXJyZW50U2FtcGxlXSA8PSBhWDsgKytjdXJyZW50U2FtcGxlKSB7XG4gICAgICBpbnRlcnZhbFN0YXJ0ICs9IGtTYW1wbGVTdGVwU2l6ZTtcbiAgICB9XG4gICAgLS1jdXJyZW50U2FtcGxlO1xuXG4gICAgLy8gSW50ZXJwb2xhdGUgdG8gcHJvdmlkZSBhbiBpbml0aWFsIGd1ZXNzIGZvciB0XG4gICAgdmFyIGRpc3QgPSAoYVggLSBzYW1wbGVWYWx1ZXNbY3VycmVudFNhbXBsZV0pIC8gKHNhbXBsZVZhbHVlc1tjdXJyZW50U2FtcGxlICsgMV0gLSBzYW1wbGVWYWx1ZXNbY3VycmVudFNhbXBsZV0pO1xuICAgIHZhciBndWVzc0ZvclQgPSBpbnRlcnZhbFN0YXJ0ICsgZGlzdCAqIGtTYW1wbGVTdGVwU2l6ZTtcblxuICAgIHZhciBpbml0aWFsU2xvcGUgPSBnZXRTbG9wZShndWVzc0ZvclQsIG1YMSwgbVgyKTtcbiAgICBpZiAoaW5pdGlhbFNsb3BlID49IE5FV1RPTl9NSU5fU0xPUEUpIHtcbiAgICAgIHJldHVybiBuZXd0b25SYXBoc29uSXRlcmF0ZShhWCwgZ3Vlc3NGb3JULCBtWDEsIG1YMik7XG4gICAgfSBlbHNlIGlmIChpbml0aWFsU2xvcGUgPT09IDAuMCkge1xuICAgICAgcmV0dXJuIGd1ZXNzRm9yVDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGJpbmFyeVN1YmRpdmlkZShhWCwgaW50ZXJ2YWxTdGFydCwgaW50ZXJ2YWxTdGFydCArIGtTYW1wbGVTdGVwU2l6ZSwgbVgxLCBtWDIpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiBCZXppZXJFYXNpbmcgKHgpIHtcbiAgICBpZiAobVgxID09PSBtWTEgJiYgbVgyID09PSBtWTIpIHtcbiAgICAgIHJldHVybiB4OyAvLyBsaW5lYXJcbiAgICB9XG4gICAgLy8gQmVjYXVzZSBKYXZhU2NyaXB0IG51bWJlciBhcmUgaW1wcmVjaXNlLCB3ZSBzaG91bGQgZ3VhcmFudGVlIHRoZSBleHRyZW1lcyBhcmUgcmlnaHQuXG4gICAgaWYgKHggPT09IDApIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBpZiAoeCA9PT0gMSkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIHJldHVybiBjYWxjQmV6aWVyKGdldFRGb3JYKHgpLCBtWTEsIG1ZMik7XG4gIH07XG59XG5cbi8qIGVzbGludCBuby1jb250cm9sLXJlZ2V4OiBcIm9mZlwiICovXG5cbi8vIFJlbW92ZSBEaWFjcml0aWNzXG5jb25zdCBkZWZhdWx0RGlhY3JpdGljc1JlbW92YWxhcCA9IFtcbiAgeyBiYXNlOiAnQScsIGxldHRlcnM6ICdcXHUwMDQxXFx1MjRCNlxcdUZGMjFcXHUwMEMwXFx1MDBDMVxcdTAwQzJcXHUxRUE2XFx1MUVBNFxcdTFFQUFcXHUxRUE4XFx1MDBDM1xcdTAxMDBcXHUwMTAyXFx1MUVCMFxcdTFFQUVcXHUxRUI0XFx1MUVCMlxcdTAyMjZcXHUwMUUwXFx1MDBDNFxcdTAxREVcXHUxRUEyXFx1MDBDNVxcdTAxRkFcXHUwMUNEXFx1MDIwMFxcdTAyMDJcXHUxRUEwXFx1MUVBQ1xcdTFFQjZcXHUxRTAwXFx1MDEwNFxcdTAyM0FcXHUyQzZGJyB9LFxuICB7IGJhc2U6ICdBQScsIGxldHRlcnM6ICdcXHVBNzMyJyB9LFxuICB7IGJhc2U6ICdBRScsIGxldHRlcnM6ICdcXHUwMEM2XFx1MDFGQ1xcdTAxRTInIH0sXG4gIHsgYmFzZTogJ0FPJywgbGV0dGVyczogJ1xcdUE3MzQnIH0sXG4gIHsgYmFzZTogJ0FVJywgbGV0dGVyczogJ1xcdUE3MzYnIH0sXG4gIHsgYmFzZTogJ0FWJywgbGV0dGVyczogJ1xcdUE3MzhcXHVBNzNBJyB9LFxuICB7IGJhc2U6ICdBWScsIGxldHRlcnM6ICdcXHVBNzNDJyB9LFxuICB7IGJhc2U6ICdCJywgbGV0dGVyczogJ1xcdTAwNDJcXHUyNEI3XFx1RkYyMlxcdTFFMDJcXHUxRTA0XFx1MUUwNlxcdTAyNDNcXHUwMTgyXFx1MDE4MScgfSxcbiAgeyBiYXNlOiAnQycsIGxldHRlcnM6ICdcXHUwMDQzXFx1MjRCOFxcdUZGMjNcXHUwMTA2XFx1MDEwOFxcdTAxMEFcXHUwMTBDXFx1MDBDN1xcdTFFMDhcXHUwMTg3XFx1MDIzQlxcdUE3M0UnIH0sXG4gIHsgYmFzZTogJ0QnLCBsZXR0ZXJzOiAnXFx1MDA0NFxcdTI0QjlcXHVGRjI0XFx1MUUwQVxcdTAxMEVcXHUxRTBDXFx1MUUxMFxcdTFFMTJcXHUxRTBFXFx1MDExMFxcdTAxOEJcXHUwMThBXFx1MDE4OVxcdUE3NzknIH0sXG4gIHsgYmFzZTogJ0RaJywgbGV0dGVyczogJ1xcdTAxRjFcXHUwMUM0JyB9LFxuICB7IGJhc2U6ICdEeicsIGxldHRlcnM6ICdcXHUwMUYyXFx1MDFDNScgfSxcbiAgeyBiYXNlOiAnRScsIGxldHRlcnM6ICdcXHUwMDQ1XFx1MjRCQVxcdUZGMjVcXHUwMEM4XFx1MDBDOVxcdTAwQ0FcXHUxRUMwXFx1MUVCRVxcdTFFQzRcXHUxRUMyXFx1MUVCQ1xcdTAxMTJcXHUxRTE0XFx1MUUxNlxcdTAxMTRcXHUwMTE2XFx1MDBDQlxcdTFFQkFcXHUwMTFBXFx1MDIwNFxcdTAyMDZcXHUxRUI4XFx1MUVDNlxcdTAyMjhcXHUxRTFDXFx1MDExOFxcdTFFMThcXHUxRTFBXFx1MDE5MFxcdTAxOEUnIH0sXG4gIHsgYmFzZTogJ0YnLCBsZXR0ZXJzOiAnXFx1MDA0NlxcdTI0QkJcXHVGRjI2XFx1MUUxRVxcdTAxOTFcXHVBNzdCJyB9LFxuICB7IGJhc2U6ICdHJywgbGV0dGVyczogJ1xcdTAwNDdcXHUyNEJDXFx1RkYyN1xcdTAxRjRcXHUwMTFDXFx1MUUyMFxcdTAxMUVcXHUwMTIwXFx1MDFFNlxcdTAxMjJcXHUwMUU0XFx1MDE5M1xcdUE3QTBcXHVBNzdEXFx1QTc3RScgfSxcbiAgeyBiYXNlOiAnSCcsIGxldHRlcnM6ICdcXHUwMDQ4XFx1MjRCRFxcdUZGMjhcXHUwMTI0XFx1MUUyMlxcdTFFMjZcXHUwMjFFXFx1MUUyNFxcdTFFMjhcXHUxRTJBXFx1MDEyNlxcdTJDNjdcXHUyQzc1XFx1QTc4RCcgfSxcbiAgeyBiYXNlOiAnSScsIGxldHRlcnM6ICdcXHUwMDQ5XFx1MjRCRVxcdUZGMjlcXHUwMENDXFx1MDBDRFxcdTAwQ0VcXHUwMTI4XFx1MDEyQVxcdTAxMkNcXHUwMTMwXFx1MDBDRlxcdTFFMkVcXHUxRUM4XFx1MDFDRlxcdTAyMDhcXHUwMjBBXFx1MUVDQVxcdTAxMkVcXHUxRTJDXFx1MDE5NycgfSxcbiAgeyBiYXNlOiAnSicsIGxldHRlcnM6ICdcXHUwMDRBXFx1MjRCRlxcdUZGMkFcXHUwMTM0XFx1MDI0OCcgfSxcbiAgeyBiYXNlOiAnSycsIGxldHRlcnM6ICdcXHUwMDRCXFx1MjRDMFxcdUZGMkJcXHUxRTMwXFx1MDFFOFxcdTFFMzJcXHUwMTM2XFx1MUUzNFxcdTAxOThcXHUyQzY5XFx1QTc0MFxcdUE3NDJcXHVBNzQ0XFx1QTdBMicgfSxcbiAgeyBiYXNlOiAnTCcsIGxldHRlcnM6ICdcXHUwMDRDXFx1MjRDMVxcdUZGMkNcXHUwMTNGXFx1MDEzOVxcdTAxM0RcXHUxRTM2XFx1MUUzOFxcdTAxM0JcXHUxRTNDXFx1MUUzQVxcdTAxNDFcXHUwMjNEXFx1MkM2MlxcdTJDNjBcXHVBNzQ4XFx1QTc0NlxcdUE3ODAnIH0sXG4gIHsgYmFzZTogJ0xKJywgbGV0dGVyczogJ1xcdTAxQzcnIH0sXG4gIHsgYmFzZTogJ0xqJywgbGV0dGVyczogJ1xcdTAxQzgnIH0sXG4gIHsgYmFzZTogJ00nLCBsZXR0ZXJzOiAnXFx1MDA0RFxcdTI0QzJcXHVGRjJEXFx1MUUzRVxcdTFFNDBcXHUxRTQyXFx1MkM2RVxcdTAxOUMnIH0sXG4gIHsgYmFzZTogJ04nLCBsZXR0ZXJzOiAnXFx1MDA0RVxcdTI0QzNcXHVGRjJFXFx1MDFGOFxcdTAxNDNcXHUwMEQxXFx1MUU0NFxcdTAxNDdcXHUxRTQ2XFx1MDE0NVxcdTFFNEFcXHUxRTQ4XFx1MDIyMFxcdTAxOURcXHVBNzkwXFx1QTdBNCcgfSxcbiAgeyBiYXNlOiAnTkonLCBsZXR0ZXJzOiAnXFx1MDFDQScgfSxcbiAgeyBiYXNlOiAnTmonLCBsZXR0ZXJzOiAnXFx1MDFDQicgfSxcbiAgeyBiYXNlOiAnTycsIGxldHRlcnM6ICdcXHUwMDRGXFx1MjRDNFxcdUZGMkZcXHUwMEQyXFx1MDBEM1xcdTAwRDRcXHUxRUQyXFx1MUVEMFxcdTFFRDZcXHUxRUQ0XFx1MDBENVxcdTFFNENcXHUwMjJDXFx1MUU0RVxcdTAxNENcXHUxRTUwXFx1MUU1MlxcdTAxNEVcXHUwMjJFXFx1MDIzMFxcdTAwRDZcXHUwMjJBXFx1MUVDRVxcdTAxNTBcXHUwMUQxXFx1MDIwQ1xcdTAyMEVcXHUwMUEwXFx1MUVEQ1xcdTFFREFcXHUxRUUwXFx1MUVERVxcdTFFRTJcXHUxRUNDXFx1MUVEOFxcdTAxRUFcXHUwMUVDXFx1MDBEOFxcdTAxRkVcXHUwMTg2XFx1MDE5RlxcdUE3NEFcXHVBNzRDJyB9LFxuICB7IGJhc2U6ICdPSScsIGxldHRlcnM6ICdcXHUwMUEyJyB9LFxuICB7IGJhc2U6ICdPTycsIGxldHRlcnM6ICdcXHVBNzRFJyB9LFxuICB7IGJhc2U6ICdPVScsIGxldHRlcnM6ICdcXHUwMjIyJyB9LFxuICB7IGJhc2U6ICdPRScsIGxldHRlcnM6ICdcXHUwMDhDXFx1MDE1MicgfSxcbiAgeyBiYXNlOiAnb2UnLCBsZXR0ZXJzOiAnXFx1MDA5Q1xcdTAxNTMnIH0sXG4gIHsgYmFzZTogJ1AnLCBsZXR0ZXJzOiAnXFx1MDA1MFxcdTI0QzVcXHVGRjMwXFx1MUU1NFxcdTFFNTZcXHUwMUE0XFx1MkM2M1xcdUE3NTBcXHVBNzUyXFx1QTc1NCcgfSxcbiAgeyBiYXNlOiAnUScsIGxldHRlcnM6ICdcXHUwMDUxXFx1MjRDNlxcdUZGMzFcXHVBNzU2XFx1QTc1OFxcdTAyNEEnIH0sXG4gIHsgYmFzZTogJ1InLCBsZXR0ZXJzOiAnXFx1MDA1MlxcdTI0QzdcXHVGRjMyXFx1MDE1NFxcdTFFNThcXHUwMTU4XFx1MDIxMFxcdTAyMTJcXHUxRTVBXFx1MUU1Q1xcdTAxNTZcXHUxRTVFXFx1MDI0Q1xcdTJDNjRcXHVBNzVBXFx1QTdBNlxcdUE3ODInIH0sXG4gIHsgYmFzZTogJ1MnLCBsZXR0ZXJzOiAnXFx1MDA1M1xcdTI0QzhcXHVGRjMzXFx1MUU5RVxcdTAxNUFcXHUxRTY0XFx1MDE1Q1xcdTFFNjBcXHUwMTYwXFx1MUU2NlxcdTFFNjJcXHUxRTY4XFx1MDIxOFxcdTAxNUVcXHUyQzdFXFx1QTdBOFxcdUE3ODQnIH0sXG4gIHsgYmFzZTogJ1QnLCBsZXR0ZXJzOiAnXFx1MDA1NFxcdTI0QzlcXHVGRjM0XFx1MUU2QVxcdTAxNjRcXHUxRTZDXFx1MDIxQVxcdTAxNjJcXHUxRTcwXFx1MUU2RVxcdTAxNjZcXHUwMUFDXFx1MDFBRVxcdTAyM0VcXHVBNzg2JyB9LFxuICB7IGJhc2U6ICdUWicsIGxldHRlcnM6ICdcXHVBNzI4JyB9LFxuICB7IGJhc2U6ICdVJywgbGV0dGVyczogJ1xcdTAwNTVcXHUyNENBXFx1RkYzNVxcdTAwRDlcXHUwMERBXFx1MDBEQlxcdTAxNjhcXHUxRTc4XFx1MDE2QVxcdTFFN0FcXHUwMTZDXFx1MDBEQ1xcdTAxREJcXHUwMUQ3XFx1MDFENVxcdTAxRDlcXHUxRUU2XFx1MDE2RVxcdTAxNzBcXHUwMUQzXFx1MDIxNFxcdTAyMTZcXHUwMUFGXFx1MUVFQVxcdTFFRThcXHUxRUVFXFx1MUVFQ1xcdTFFRjBcXHUxRUU0XFx1MUU3MlxcdTAxNzJcXHUxRTc2XFx1MUU3NFxcdTAyNDQnIH0sXG4gIHsgYmFzZTogJ1YnLCBsZXR0ZXJzOiAnXFx1MDA1NlxcdTI0Q0JcXHVGRjM2XFx1MUU3Q1xcdTFFN0VcXHUwMUIyXFx1QTc1RVxcdTAyNDUnIH0sXG4gIHsgYmFzZTogJ1ZZJywgbGV0dGVyczogJ1xcdUE3NjAnIH0sXG4gIHsgYmFzZTogJ1cnLCBsZXR0ZXJzOiAnXFx1MDA1N1xcdTI0Q0NcXHVGRjM3XFx1MUU4MFxcdTFFODJcXHUwMTc0XFx1MUU4NlxcdTFFODRcXHUxRTg4XFx1MkM3MicgfSxcbiAgeyBiYXNlOiAnWCcsIGxldHRlcnM6ICdcXHUwMDU4XFx1MjRDRFxcdUZGMzhcXHUxRThBXFx1MUU4QycgfSxcbiAgeyBiYXNlOiAnWScsIGxldHRlcnM6ICdcXHUwMDU5XFx1MjRDRVxcdUZGMzlcXHUxRUYyXFx1MDBERFxcdTAxNzZcXHUxRUY4XFx1MDIzMlxcdTFFOEVcXHUwMTc4XFx1MUVGNlxcdTFFRjRcXHUwMUIzXFx1MDI0RVxcdTFFRkUnIH0sXG4gIHsgYmFzZTogJ1onLCBsZXR0ZXJzOiAnXFx1MDA1QVxcdTI0Q0ZcXHVGRjNBXFx1MDE3OVxcdTFFOTBcXHUwMTdCXFx1MDE3RFxcdTFFOTJcXHUxRTk0XFx1MDFCNVxcdTAyMjRcXHUyQzdGXFx1MkM2QlxcdUE3NjInIH0sXG4gIHsgYmFzZTogJ2EnLCBsZXR0ZXJzOiAnXFx1MDA2MVxcdTI0RDBcXHVGRjQxXFx1MUU5QVxcdTAwRTBcXHUwMEUxXFx1MDBFMlxcdTFFQTdcXHUxRUE1XFx1MUVBQlxcdTFFQTlcXHUwMEUzXFx1MDEwMVxcdTAxMDNcXHUxRUIxXFx1MUVBRlxcdTFFQjVcXHUxRUIzXFx1MDIyN1xcdTAxRTFcXHUwMEU0XFx1MDFERlxcdTFFQTNcXHUwMEU1XFx1MDFGQlxcdTAxQ0VcXHUwMjAxXFx1MDIwM1xcdTFFQTFcXHUxRUFEXFx1MUVCN1xcdTFFMDFcXHUwMTA1XFx1MkM2NVxcdTAyNTAnIH0sXG4gIHsgYmFzZTogJ2FhJywgbGV0dGVyczogJ1xcdUE3MzMnIH0sXG4gIHsgYmFzZTogJ2FlJywgbGV0dGVyczogJ1xcdTAwRTZcXHUwMUZEXFx1MDFFMycgfSxcbiAgeyBiYXNlOiAnYW8nLCBsZXR0ZXJzOiAnXFx1QTczNScgfSxcbiAgeyBiYXNlOiAnYXUnLCBsZXR0ZXJzOiAnXFx1QTczNycgfSxcbiAgeyBiYXNlOiAnYXYnLCBsZXR0ZXJzOiAnXFx1QTczOVxcdUE3M0InIH0sXG4gIHsgYmFzZTogJ2F5JywgbGV0dGVyczogJ1xcdUE3M0QnIH0sXG4gIHsgYmFzZTogJ2InLCBsZXR0ZXJzOiAnXFx1MDA2MlxcdTI0RDFcXHVGRjQyXFx1MUUwM1xcdTFFMDVcXHUxRTA3XFx1MDE4MFxcdTAxODNcXHUwMjUzJyB9LFxuICB7IGJhc2U6ICdjJywgbGV0dGVyczogJ1xcdTAwNjNcXHUyNEQyXFx1RkY0M1xcdTAxMDdcXHUwMTA5XFx1MDEwQlxcdTAxMERcXHUwMEU3XFx1MUUwOVxcdTAxODhcXHUwMjNDXFx1QTczRlxcdTIxODQnIH0sXG4gIHsgYmFzZTogJ2QnLCBsZXR0ZXJzOiAnXFx1MDA2NFxcdTI0RDNcXHVGRjQ0XFx1MUUwQlxcdTAxMEZcXHUxRTBEXFx1MUUxMVxcdTFFMTNcXHUxRTBGXFx1MDExMVxcdTAxOENcXHUwMjU2XFx1MDI1N1xcdUE3N0EnIH0sXG4gIHsgYmFzZTogJ2R6JywgbGV0dGVyczogJ1xcdTAxRjNcXHUwMUM2JyB9LFxuICB7IGJhc2U6ICdlJywgbGV0dGVyczogJ1xcdTAwNjVcXHUyNEQ0XFx1RkY0NVxcdTAwRThcXHUwMEU5XFx1MDBFQVxcdTFFQzFcXHUxRUJGXFx1MUVDNVxcdTFFQzNcXHUxRUJEXFx1MDExM1xcdTFFMTVcXHUxRTE3XFx1MDExNVxcdTAxMTdcXHUwMEVCXFx1MUVCQlxcdTAxMUJcXHUwMjA1XFx1MDIwN1xcdTFFQjlcXHUxRUM3XFx1MDIyOVxcdTFFMURcXHUwMTE5XFx1MUUxOVxcdTFFMUJcXHUwMjQ3XFx1MDI1QlxcdTAxREQnIH0sXG4gIHsgYmFzZTogJ2YnLCBsZXR0ZXJzOiAnXFx1MDA2NlxcdTI0RDVcXHVGRjQ2XFx1MUUxRlxcdTAxOTJcXHVBNzdDJyB9LFxuICB7IGJhc2U6ICdnJywgbGV0dGVyczogJ1xcdTAwNjdcXHUyNEQ2XFx1RkY0N1xcdTAxRjVcXHUwMTFEXFx1MUUyMVxcdTAxMUZcXHUwMTIxXFx1MDFFN1xcdTAxMjNcXHUwMUU1XFx1MDI2MFxcdUE3QTFcXHUxRDc5XFx1QTc3RicgfSxcbiAgeyBiYXNlOiAnaCcsIGxldHRlcnM6ICdcXHUwMDY4XFx1MjREN1xcdUZGNDhcXHUwMTI1XFx1MUUyM1xcdTFFMjdcXHUwMjFGXFx1MUUyNVxcdTFFMjlcXHUxRTJCXFx1MUU5NlxcdTAxMjdcXHUyQzY4XFx1MkM3NlxcdTAyNjUnIH0sXG4gIHsgYmFzZTogJ2h2JywgbGV0dGVyczogJ1xcdTAxOTUnIH0sXG4gIHsgYmFzZTogJ2knLCBsZXR0ZXJzOiAnXFx1MDA2OVxcdTI0RDhcXHVGRjQ5XFx1MDBFQ1xcdTAwRURcXHUwMEVFXFx1MDEyOVxcdTAxMkJcXHUwMTJEXFx1MDBFRlxcdTFFMkZcXHUxRUM5XFx1MDFEMFxcdTAyMDlcXHUwMjBCXFx1MUVDQlxcdTAxMkZcXHUxRTJEXFx1MDI2OFxcdTAxMzEnIH0sXG4gIHsgYmFzZTogJ2onLCBsZXR0ZXJzOiAnXFx1MDA2QVxcdTI0RDlcXHVGRjRBXFx1MDEzNVxcdTAxRjBcXHUwMjQ5JyB9LFxuICB7IGJhc2U6ICdrJywgbGV0dGVyczogJ1xcdTAwNkJcXHUyNERBXFx1RkY0QlxcdTFFMzFcXHUwMUU5XFx1MUUzM1xcdTAxMzdcXHUxRTM1XFx1MDE5OVxcdTJDNkFcXHVBNzQxXFx1QTc0M1xcdUE3NDVcXHVBN0EzJyB9LFxuICB7IGJhc2U6ICdsJywgbGV0dGVyczogJ1xcdTAwNkNcXHUyNERCXFx1RkY0Q1xcdTAxNDBcXHUwMTNBXFx1MDEzRVxcdTFFMzdcXHUxRTM5XFx1MDEzQ1xcdTFFM0RcXHUxRTNCXFx1MDE3RlxcdTAxNDJcXHUwMTlBXFx1MDI2QlxcdTJDNjFcXHVBNzQ5XFx1QTc4MVxcdUE3NDcnIH0sXG4gIHsgYmFzZTogJ2xqJywgbGV0dGVyczogJ1xcdTAxQzknIH0sXG4gIHsgYmFzZTogJ20nLCBsZXR0ZXJzOiAnXFx1MDA2RFxcdTI0RENcXHVGRjREXFx1MUUzRlxcdTFFNDFcXHUxRTQzXFx1MDI3MVxcdTAyNkYnIH0sXG4gIHsgYmFzZTogJ24nLCBsZXR0ZXJzOiAnXFx1MDA2RVxcdTI0RERcXHVGRjRFXFx1MDFGOVxcdTAxNDRcXHUwMEYxXFx1MUU0NVxcdTAxNDhcXHUxRTQ3XFx1MDE0NlxcdTFFNEJcXHUxRTQ5XFx1MDE5RVxcdTAyNzJcXHUwMTQ5XFx1QTc5MVxcdUE3QTUnIH0sXG4gIHsgYmFzZTogJ25qJywgbGV0dGVyczogJ1xcdTAxQ0MnIH0sXG4gIHsgYmFzZTogJ28nLCBsZXR0ZXJzOiAnXFx1MDA2RlxcdTI0REVcXHVGRjRGXFx1MDBGMlxcdTAwRjNcXHUwMEY0XFx1MUVEM1xcdTFFRDFcXHUxRUQ3XFx1MUVENVxcdTAwRjVcXHUxRTREXFx1MDIyRFxcdTFFNEZcXHUwMTREXFx1MUU1MVxcdTFFNTNcXHUwMTRGXFx1MDIyRlxcdTAyMzFcXHUwMEY2XFx1MDIyQlxcdTFFQ0ZcXHUwMTUxXFx1MDFEMlxcdTAyMERcXHUwMjBGXFx1MDFBMVxcdTFFRERcXHUxRURCXFx1MUVFMVxcdTFFREZcXHUxRUUzXFx1MUVDRFxcdTFFRDlcXHUwMUVCXFx1MDFFRFxcdTAwRjhcXHUwMUZGXFx1MDI1NFxcdUE3NEJcXHVBNzREXFx1MDI3NScgfSxcbiAgeyBiYXNlOiAnb2knLCBsZXR0ZXJzOiAnXFx1MDFBMycgfSxcbiAgeyBiYXNlOiAnb3UnLCBsZXR0ZXJzOiAnXFx1MDIyMycgfSxcbiAgeyBiYXNlOiAnb28nLCBsZXR0ZXJzOiAnXFx1QTc0RicgfSxcbiAgeyBiYXNlOiAncCcsIGxldHRlcnM6ICdcXHUwMDcwXFx1MjRERlxcdUZGNTBcXHUxRTU1XFx1MUU1N1xcdTAxQTVcXHUxRDdEXFx1QTc1MVxcdUE3NTNcXHVBNzU1JyB9LFxuICB7IGJhc2U6ICdxJywgbGV0dGVyczogJ1xcdTAwNzFcXHUyNEUwXFx1RkY1MVxcdTAyNEJcXHVBNzU3XFx1QTc1OScgfSxcbiAgeyBiYXNlOiAncicsIGxldHRlcnM6ICdcXHUwMDcyXFx1MjRFMVxcdUZGNTJcXHUwMTU1XFx1MUU1OVxcdTAxNTlcXHUwMjExXFx1MDIxM1xcdTFFNUJcXHUxRTVEXFx1MDE1N1xcdTFFNUZcXHUwMjREXFx1MDI3RFxcdUE3NUJcXHVBN0E3XFx1QTc4MycgfSxcbiAgeyBiYXNlOiAncycsIGxldHRlcnM6ICdcXHUwMDczXFx1MjRFMlxcdUZGNTNcXHUwMERGXFx1MDE1QlxcdTFFNjVcXHUwMTVEXFx1MUU2MVxcdTAxNjFcXHUxRTY3XFx1MUU2M1xcdTFFNjlcXHUwMjE5XFx1MDE1RlxcdTAyM0ZcXHVBN0E5XFx1QTc4NVxcdTFFOUInIH0sXG4gIHsgYmFzZTogJ3QnLCBsZXR0ZXJzOiAnXFx1MDA3NFxcdTI0RTNcXHVGRjU0XFx1MUU2QlxcdTFFOTdcXHUwMTY1XFx1MUU2RFxcdTAyMUJcXHUwMTYzXFx1MUU3MVxcdTFFNkZcXHUwMTY3XFx1MDFBRFxcdTAyODhcXHUyQzY2XFx1QTc4NycgfSxcbiAgeyBiYXNlOiAndHonLCBsZXR0ZXJzOiAnXFx1QTcyOScgfSxcbiAgeyBiYXNlOiAndScsIGxldHRlcnM6ICdcXHUwMDc1XFx1MjRFNFxcdUZGNTVcXHUwMEY5XFx1MDBGQVxcdTAwRkJcXHUwMTY5XFx1MUU3OVxcdTAxNkJcXHUxRTdCXFx1MDE2RFxcdTAwRkNcXHUwMURDXFx1MDFEOFxcdTAxRDZcXHUwMURBXFx1MUVFN1xcdTAxNkZcXHUwMTcxXFx1MDFENFxcdTAyMTVcXHUwMjE3XFx1MDFCMFxcdTFFRUJcXHUxRUU5XFx1MUVFRlxcdTFFRURcXHUxRUYxXFx1MUVFNVxcdTFFNzNcXHUwMTczXFx1MUU3N1xcdTFFNzVcXHUwMjg5JyB9LFxuICB7IGJhc2U6ICd2JywgbGV0dGVyczogJ1xcdTAwNzZcXHUyNEU1XFx1RkY1NlxcdTFFN0RcXHUxRTdGXFx1MDI4QlxcdUE3NUZcXHUwMjhDJyB9LFxuICB7IGJhc2U6ICd2eScsIGxldHRlcnM6ICdcXHVBNzYxJyB9LFxuICB7IGJhc2U6ICd3JywgbGV0dGVyczogJ1xcdTAwNzdcXHUyNEU2XFx1RkY1N1xcdTFFODFcXHUxRTgzXFx1MDE3NVxcdTFFODdcXHUxRTg1XFx1MUU5OFxcdTFFODlcXHUyQzczJyB9LFxuICB7IGJhc2U6ICd4JywgbGV0dGVyczogJ1xcdTAwNzhcXHUyNEU3XFx1RkY1OFxcdTFFOEJcXHUxRThEJyB9LFxuICB7IGJhc2U6ICd5JywgbGV0dGVyczogJ1xcdTAwNzlcXHUyNEU4XFx1RkY1OVxcdTFFRjNcXHUwMEZEXFx1MDE3N1xcdTFFRjlcXHUwMjMzXFx1MUU4RlxcdTAwRkZcXHUxRUY3XFx1MUU5OVxcdTFFRjVcXHUwMUI0XFx1MDI0RlxcdTFFRkYnIH0sXG4gIHsgYmFzZTogJ3onLCBsZXR0ZXJzOiAnXFx1MDA3QVxcdTI0RTlcXHVGRjVBXFx1MDE3QVxcdTFFOTFcXHUwMTdDXFx1MDE3RVxcdTFFOTNcXHUxRTk1XFx1MDFCNlxcdTAyMjVcXHUwMjQwXFx1MkM2Q1xcdUE3NjMnIH0sXG5dO1xuXG5jb25zdCBkaWFjcml0aWNzTWFwID0ge307XG5mb3IgKGxldCBpID0gMDsgaSA8IGRlZmF1bHREaWFjcml0aWNzUmVtb3ZhbGFwLmxlbmd0aDsgaSArPSAxKSB7XG4gIGNvbnN0IGxldHRlcnMgPSBkZWZhdWx0RGlhY3JpdGljc1JlbW92YWxhcFtpXS5sZXR0ZXJzO1xuICBmb3IgKGxldCBqID0gMDsgaiA8IGxldHRlcnMubGVuZ3RoOyBqICs9IDEpIHtcbiAgICBkaWFjcml0aWNzTWFwW2xldHRlcnNbal1dID0gZGVmYXVsdERpYWNyaXRpY3NSZW1vdmFsYXBbaV0uYmFzZTtcbiAgfVxufVxuXG5jb25zdCBjcmVhdGVQcm9taXNlID0gZnVuY3Rpb24gY3JlYXRlUHJvbWlzZShoYW5kbGVyKSB7XG4gIGxldCByZXNvbHZlZCA9IGZhbHNlO1xuICBsZXQgcmVqZWN0ZWQgPSBmYWxzZTtcbiAgbGV0IHJlc29sdmVBcmdzO1xuICBsZXQgcmVqZWN0QXJncztcbiAgY29uc3QgcHJvbWlzZUhhbmRsZXJzID0ge1xuICAgIHRoZW46IHVuZGVmaW5lZCxcbiAgICBjYXRjaDogdW5kZWZpbmVkLFxuICB9O1xuICBjb25zdCBwcm9taXNlID0ge1xuICAgIHRoZW4odGhlbkhhbmRsZXIpIHtcbiAgICAgIGlmIChyZXNvbHZlZCkge1xuICAgICAgICB0aGVuSGFuZGxlciguLi5yZXNvbHZlQXJncyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9taXNlSGFuZGxlcnMudGhlbiA9IHRoZW5IYW5kbGVyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfSxcbiAgICBjYXRjaChjYXRjaEhhbmRsZXIpIHtcbiAgICAgIGlmIChyZWplY3RlZCkge1xuICAgICAgICBjYXRjaEhhbmRsZXIoLi4ucmVqZWN0QXJncyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9taXNlSGFuZGxlcnMuY2F0Y2ggPSBjYXRjaEhhbmRsZXI7XG4gICAgICB9XG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9LFxuICB9O1xuXG4gIGZ1bmN0aW9uIHJlc29sdmUoLi4uYXJncykge1xuICAgIHJlc29sdmVkID0gdHJ1ZTtcbiAgICBpZiAocHJvbWlzZUhhbmRsZXJzLnRoZW4pIHByb21pc2VIYW5kbGVycy50aGVuKC4uLmFyZ3MpO1xuICAgIGVsc2UgcmVzb2x2ZUFyZ3MgPSBhcmdzO1xuICB9XG4gIGZ1bmN0aW9uIHJlamVjdCguLi5hcmdzKSB7XG4gICAgcmVqZWN0ZWQgPSB0cnVlO1xuICAgIGlmIChwcm9taXNlSGFuZGxlcnMuY2F0Y2gpIHByb21pc2VIYW5kbGVycy5jYXRjaCguLi5hcmdzKTtcbiAgICBlbHNlIHJlamVjdEFyZ3MgPSBhcmdzO1xuICB9XG4gIGhhbmRsZXIocmVzb2x2ZSwgcmVqZWN0KTtcblxuICByZXR1cm4gcHJvbWlzZTtcbn07XG5cbmNvbnN0IFV0aWxzID0ge1xuICBtZFByZWxvYWRlckNvbnRlbnQ6IGBcbiAgICA8c3BhbiBjbGFzcz1cInByZWxvYWRlci1pbm5lclwiPlxuICAgICAgPHNwYW4gY2xhc3M9XCJwcmVsb2FkZXItaW5uZXItZ2FwXCI+PC9zcGFuPlxuICAgICAgPHNwYW4gY2xhc3M9XCJwcmVsb2FkZXItaW5uZXItbGVmdFwiPlxuICAgICAgICAgIDxzcGFuIGNsYXNzPVwicHJlbG9hZGVyLWlubmVyLWhhbGYtY2lyY2xlXCI+PC9zcGFuPlxuICAgICAgPC9zcGFuPlxuICAgICAgPHNwYW4gY2xhc3M9XCJwcmVsb2FkZXItaW5uZXItcmlnaHRcIj5cbiAgICAgICAgICA8c3BhbiBjbGFzcz1cInByZWxvYWRlci1pbm5lci1oYWxmLWNpcmNsZVwiPjwvc3Bhbj5cbiAgICAgIDwvc3Bhbj5cbiAgICA8L3NwYW4+XG4gIGAudHJpbSgpLFxuICBldmVudE5hbWVUb0NvbG9uQ2FzZShldmVudE5hbWUpIHtcbiAgICBsZXQgaGFzQ29sb247XG4gICAgcmV0dXJuIGV2ZW50TmFtZS5zcGxpdCgnJykubWFwKChjaGFyLCBpbmRleCkgPT4ge1xuICAgICAgaWYgKGNoYXIubWF0Y2goL1tBLVpdLykgJiYgaW5kZXggIT09IDAgJiYgIWhhc0NvbG9uKSB7XG4gICAgICAgIGhhc0NvbG9uID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGA6JHtjaGFyLnRvTG93ZXJDYXNlKCl9YDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjaGFyLnRvTG93ZXJDYXNlKCk7XG4gICAgfSkuam9pbignJyk7XG4gIH0sXG4gIGRlbGV0ZVByb3BzKG9iaikge1xuICAgIGNvbnN0IG9iamVjdCA9IG9iajtcbiAgICBPYmplY3Qua2V5cyhvYmplY3QpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgb2JqZWN0W2tleV0gPSBudWxsO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBubyBnZXR0ZXIgZm9yIG9iamVjdFxuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgZGVsZXRlIG9iamVjdFtrZXldO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBzb21ldGhpbmcgZ290IHdyb25nXG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG4gIGJlemllciguLi5hcmdzKSB7XG4gICAgcmV0dXJuIGJlemllciguLi5hcmdzKTtcbiAgfSxcbiAgbmV4dFRpY2soY2FsbGJhY2ssIGRlbGF5ID0gMCkge1xuICAgIHJldHVybiBzZXRUaW1lb3V0KGNhbGxiYWNrLCBkZWxheSk7XG4gIH0sXG4gIG5leHRGcmFtZShjYWxsYmFjaykge1xuICAgIHJldHVybiBVdGlscy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoY2FsbGJhY2spO1xuICB9LFxuICBub3coKSB7XG4gICAgcmV0dXJuIERhdGUubm93KCk7XG4gIH0sXG4gIHByb21pc2UoaGFuZGxlcikge1xuICAgIHJldHVybiB3aW5kb3ckMS5Qcm9taXNlID8gbmV3IFByb21pc2UoaGFuZGxlcikgOiBjcmVhdGVQcm9taXNlKGhhbmRsZXIpO1xuICB9LFxuICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoY2FsbGJhY2spIHtcbiAgICBpZiAod2luZG93JDEucmVxdWVzdEFuaW1hdGlvbkZyYW1lKSByZXR1cm4gd2luZG93JDEucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGNhbGxiYWNrKTtcbiAgICBlbHNlIGlmICh3aW5kb3ckMS53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIHJldHVybiB3aW5kb3ckMS53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUoY2FsbGJhY2spO1xuICAgIHJldHVybiB3aW5kb3ckMS5zZXRUaW1lb3V0KGNhbGxiYWNrLCAxMDAwIC8gNjApO1xuICB9LFxuICBjYW5jZWxBbmltYXRpb25GcmFtZShpZCkge1xuICAgIGlmICh3aW5kb3ckMS5jYW5jZWxBbmltYXRpb25GcmFtZSkgcmV0dXJuIHdpbmRvdyQxLmNhbmNlbEFuaW1hdGlvbkZyYW1lKGlkKTtcbiAgICBlbHNlIGlmICh3aW5kb3ckMS53ZWJraXRDYW5jZWxBbmltYXRpb25GcmFtZSkgcmV0dXJuIHdpbmRvdyQxLndlYmtpdENhbmNlbEFuaW1hdGlvbkZyYW1lKGlkKTtcbiAgICByZXR1cm4gd2luZG93JDEuY2xlYXJUaW1lb3V0KGlkKTtcbiAgfSxcbiAgcmVtb3ZlRGlhY3JpdGljcyhzdHIpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoL1teXFx1MDAwMC1cXHUwMDdFXS9nLCBhID0+IGRpYWNyaXRpY3NNYXBbYV0gfHwgYSk7XG4gIH0sXG4gIHBhcnNlVXJsUXVlcnkodXJsKSB7XG4gICAgY29uc3QgcXVlcnkgPSB7fTtcbiAgICBsZXQgdXJsVG9QYXJzZSA9IHVybCB8fCB3aW5kb3ckMS5sb2NhdGlvbi5ocmVmO1xuICAgIGxldCBpO1xuICAgIGxldCBwYXJhbXM7XG4gICAgbGV0IHBhcmFtO1xuICAgIGxldCBsZW5ndGg7XG4gICAgaWYgKHR5cGVvZiB1cmxUb1BhcnNlID09PSAnc3RyaW5nJyAmJiB1cmxUb1BhcnNlLmxlbmd0aCkge1xuICAgICAgdXJsVG9QYXJzZSA9IHVybFRvUGFyc2UuaW5kZXhPZignPycpID4gLTEgPyB1cmxUb1BhcnNlLnJlcGxhY2UoL1xcUypcXD8vLCAnJykgOiAnJztcbiAgICAgIHBhcmFtcyA9IHVybFRvUGFyc2Uuc3BsaXQoJyYnKS5maWx0ZXIocGFyYW1zUGFydCA9PiBwYXJhbXNQYXJ0ICE9PSAnJyk7XG4gICAgICBsZW5ndGggPSBwYXJhbXMubGVuZ3RoO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgcGFyYW0gPSBwYXJhbXNbaV0ucmVwbGFjZSgvI1xcUysvZywgJycpLnNwbGl0KCc9Jyk7XG4gICAgICAgIHF1ZXJ5W2RlY29kZVVSSUNvbXBvbmVudChwYXJhbVswXSldID0gdHlwZW9mIHBhcmFtWzFdID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IGRlY29kZVVSSUNvbXBvbmVudChwYXJhbVsxXSkgfHwgJyc7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBxdWVyeTtcbiAgfSxcbiAgZ2V0VHJhbnNsYXRlKGVsLCBheGlzID0gJ3gnKSB7XG4gICAgbGV0IG1hdHJpeDtcbiAgICBsZXQgY3VyVHJhbnNmb3JtO1xuICAgIGxldCB0cmFuc2Zvcm1NYXRyaXg7XG5cbiAgICBjb25zdCBjdXJTdHlsZSA9IHdpbmRvdyQxLmdldENvbXB1dGVkU3R5bGUoZWwsIG51bGwpO1xuXG4gICAgaWYgKHdpbmRvdyQxLldlYktpdENTU01hdHJpeCkge1xuICAgICAgY3VyVHJhbnNmb3JtID0gY3VyU3R5bGUudHJhbnNmb3JtIHx8IGN1clN0eWxlLndlYmtpdFRyYW5zZm9ybTtcbiAgICAgIGlmIChjdXJUcmFuc2Zvcm0uc3BsaXQoJywnKS5sZW5ndGggPiA2KSB7XG4gICAgICAgIGN1clRyYW5zZm9ybSA9IGN1clRyYW5zZm9ybS5zcGxpdCgnLCAnKS5tYXAoYSA9PiBhLnJlcGxhY2UoJywnLCAnLicpKS5qb2luKCcsICcpO1xuICAgICAgfVxuICAgICAgLy8gU29tZSBvbGQgdmVyc2lvbnMgb2YgV2Via2l0IGNob2tlIHdoZW4gJ25vbmUnIGlzIHBhc3NlZDsgcGFzc1xuICAgICAgLy8gZW1wdHkgc3RyaW5nIGluc3RlYWQgaW4gdGhpcyBjYXNlXG4gICAgICB0cmFuc2Zvcm1NYXRyaXggPSBuZXcgd2luZG93JDEuV2ViS2l0Q1NTTWF0cml4KGN1clRyYW5zZm9ybSA9PT0gJ25vbmUnID8gJycgOiBjdXJUcmFuc2Zvcm0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cmFuc2Zvcm1NYXRyaXggPSBjdXJTdHlsZS5Nb3pUcmFuc2Zvcm0gfHwgY3VyU3R5bGUuT1RyYW5zZm9ybSB8fCBjdXJTdHlsZS5Nc1RyYW5zZm9ybSB8fCBjdXJTdHlsZS5tc1RyYW5zZm9ybSB8fCBjdXJTdHlsZS50cmFuc2Zvcm0gfHwgY3VyU3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgndHJhbnNmb3JtJykucmVwbGFjZSgndHJhbnNsYXRlKCcsICdtYXRyaXgoMSwgMCwgMCwgMSwnKTtcbiAgICAgIG1hdHJpeCA9IHRyYW5zZm9ybU1hdHJpeC50b1N0cmluZygpLnNwbGl0KCcsJyk7XG4gICAgfVxuXG4gICAgaWYgKGF4aXMgPT09ICd4Jykge1xuICAgICAgLy8gTGF0ZXN0IENocm9tZSBhbmQgd2Via2l0cyBGaXhcbiAgICAgIGlmICh3aW5kb3ckMS5XZWJLaXRDU1NNYXRyaXgpIGN1clRyYW5zZm9ybSA9IHRyYW5zZm9ybU1hdHJpeC5tNDE7XG4gICAgICAvLyBDcmF6eSBJRTEwIE1hdHJpeFxuICAgICAgZWxzZSBpZiAobWF0cml4Lmxlbmd0aCA9PT0gMTYpIGN1clRyYW5zZm9ybSA9IHBhcnNlRmxvYXQobWF0cml4WzEyXSk7XG4gICAgICAvLyBOb3JtYWwgQnJvd3NlcnNcbiAgICAgIGVsc2UgY3VyVHJhbnNmb3JtID0gcGFyc2VGbG9hdChtYXRyaXhbNF0pO1xuICAgIH1cbiAgICBpZiAoYXhpcyA9PT0gJ3knKSB7XG4gICAgICAvLyBMYXRlc3QgQ2hyb21lIGFuZCB3ZWJraXRzIEZpeFxuICAgICAgaWYgKHdpbmRvdyQxLldlYktpdENTU01hdHJpeCkgY3VyVHJhbnNmb3JtID0gdHJhbnNmb3JtTWF0cml4Lm00MjtcbiAgICAgIC8vIENyYXp5IElFMTAgTWF0cml4XG4gICAgICBlbHNlIGlmIChtYXRyaXgubGVuZ3RoID09PSAxNikgY3VyVHJhbnNmb3JtID0gcGFyc2VGbG9hdChtYXRyaXhbMTNdKTtcbiAgICAgIC8vIE5vcm1hbCBCcm93c2Vyc1xuICAgICAgZWxzZSBjdXJUcmFuc2Zvcm0gPSBwYXJzZUZsb2F0KG1hdHJpeFs1XSk7XG4gICAgfVxuICAgIHJldHVybiBjdXJUcmFuc2Zvcm0gfHwgMDtcbiAgfSxcbiAgc2VyaWFsaXplT2JqZWN0KG9iaiwgcGFyZW50cyA9IFtdKSB7XG4gICAgaWYgKHR5cGVvZiBvYmogPT09ICdzdHJpbmcnKSByZXR1cm4gb2JqO1xuICAgIGNvbnN0IHJlc3VsdEFycmF5ID0gW107XG4gICAgY29uc3Qgc2VwYXJhdG9yID0gJyYnO1xuICAgIGxldCBuZXdQYXJlbnRzO1xuICAgIGZ1bmN0aW9uIHZhck5hbWUobmFtZSkge1xuICAgICAgaWYgKHBhcmVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICBsZXQgcGFyZW50UGFydHMgPSAnJztcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBwYXJlbnRzLmxlbmd0aDsgaiArPSAxKSB7XG4gICAgICAgICAgaWYgKGogPT09IDApIHBhcmVudFBhcnRzICs9IHBhcmVudHNbal07XG4gICAgICAgICAgZWxzZSBwYXJlbnRQYXJ0cyArPSBgWyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmVudHNbal0pfV1gO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgJHtwYXJlbnRQYXJ0c31bJHtlbmNvZGVVUklDb21wb25lbnQobmFtZSl9XWA7XG4gICAgICB9XG4gICAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KG5hbWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB2YXJWYWx1ZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSk7XG4gICAgfVxuICAgIE9iamVjdC5rZXlzKG9iaikuZm9yRWFjaCgocHJvcCkgPT4ge1xuICAgICAgbGV0IHRvUHVzaDtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KG9ialtwcm9wXSkpIHtcbiAgICAgICAgdG9QdXNoID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb2JqW3Byb3BdLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9ialtwcm9wXVtpXSkgJiYgdHlwZW9mIG9ialtwcm9wXVtpXSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIG5ld1BhcmVudHMgPSBwYXJlbnRzLnNsaWNlKCk7XG4gICAgICAgICAgICBuZXdQYXJlbnRzLnB1c2gocHJvcCk7XG4gICAgICAgICAgICBuZXdQYXJlbnRzLnB1c2goU3RyaW5nKGkpKTtcbiAgICAgICAgICAgIHRvUHVzaC5wdXNoKFV0aWxzLnNlcmlhbGl6ZU9iamVjdChvYmpbcHJvcF1baV0sIG5ld1BhcmVudHMpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdG9QdXNoLnB1c2goYCR7dmFyTmFtZShwcm9wKX1bXT0ke3ZhclZhbHVlKG9ialtwcm9wXVtpXSl9YCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0b1B1c2gubGVuZ3RoID4gMCkgcmVzdWx0QXJyYXkucHVzaCh0b1B1c2guam9pbihzZXBhcmF0b3IpKTtcbiAgICAgIH0gZWxzZSBpZiAob2JqW3Byb3BdID09PSBudWxsIHx8IG9ialtwcm9wXSA9PT0gJycpIHtcbiAgICAgICAgcmVzdWx0QXJyYXkucHVzaChgJHt2YXJOYW1lKHByb3ApfT1gKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG9ialtwcm9wXSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgLy8gT2JqZWN0LCBjb252ZXJ0IHRvIG5hbWVkIGFycmF5XG4gICAgICAgIG5ld1BhcmVudHMgPSBwYXJlbnRzLnNsaWNlKCk7XG4gICAgICAgIG5ld1BhcmVudHMucHVzaChwcm9wKTtcbiAgICAgICAgdG9QdXNoID0gVXRpbHMuc2VyaWFsaXplT2JqZWN0KG9ialtwcm9wXSwgbmV3UGFyZW50cyk7XG4gICAgICAgIGlmICh0b1B1c2ggIT09ICcnKSByZXN1bHRBcnJheS5wdXNoKHRvUHVzaCk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBvYmpbcHJvcF0gIT09ICd1bmRlZmluZWQnICYmIG9ialtwcm9wXSAhPT0gJycpIHtcbiAgICAgICAgLy8gU2hvdWxkIGJlIHN0cmluZyBvciBwbGFpbiB2YWx1ZVxuICAgICAgICByZXN1bHRBcnJheS5wdXNoKGAke3Zhck5hbWUocHJvcCl9PSR7dmFyVmFsdWUob2JqW3Byb3BdKX1gKTtcbiAgICAgIH0gZWxzZSBpZiAob2JqW3Byb3BdID09PSAnJykgcmVzdWx0QXJyYXkucHVzaCh2YXJOYW1lKHByb3ApKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0QXJyYXkuam9pbihzZXBhcmF0b3IpO1xuICB9LFxuICBpc09iamVjdChvKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvID09PSAnb2JqZWN0JyAmJiBvICE9PSBudWxsICYmIG8uY29uc3RydWN0b3IgJiYgby5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0O1xuICB9LFxuICBtZXJnZSguLi5hcmdzKSB7XG4gICAgY29uc3QgdG8gPSBhcmdzWzBdO1xuICAgIGFyZ3Muc3BsaWNlKDAsIDEpO1xuICAgIGNvbnN0IGZyb20gPSBhcmdzO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmcm9tLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBjb25zdCBuZXh0U291cmNlID0gYXJnc1tpXTtcbiAgICAgIGlmIChuZXh0U291cmNlICE9PSB1bmRlZmluZWQgJiYgbmV4dFNvdXJjZSAhPT0gbnVsbCkge1xuICAgICAgICBjb25zdCBrZXlzQXJyYXkgPSBPYmplY3Qua2V5cyhPYmplY3QobmV4dFNvdXJjZSkpO1xuICAgICAgICBmb3IgKGxldCBuZXh0SW5kZXggPSAwLCBsZW4gPSBrZXlzQXJyYXkubGVuZ3RoOyBuZXh0SW5kZXggPCBsZW47IG5leHRJbmRleCArPSAxKSB7XG4gICAgICAgICAgY29uc3QgbmV4dEtleSA9IGtleXNBcnJheVtuZXh0SW5kZXhdO1xuICAgICAgICAgIGNvbnN0IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG5leHRTb3VyY2UsIG5leHRLZXkpO1xuICAgICAgICAgIGlmIChkZXNjICE9PSB1bmRlZmluZWQgJiYgZGVzYy5lbnVtZXJhYmxlKSB7XG4gICAgICAgICAgICB0b1tuZXh0S2V5XSA9IG5leHRTb3VyY2VbbmV4dEtleV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0bztcbiAgfSxcbiAgZXh0ZW5kKC4uLmFyZ3MpIHtcbiAgICBsZXQgZGVlcCA9IHRydWU7XG4gICAgbGV0IHRvO1xuICAgIGxldCBmcm9tO1xuICAgIGlmICh0eXBlb2YgYXJnc1swXSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICBkZWVwID0gYXJnc1swXTtcbiAgICAgIHRvID0gYXJnc1sxXTtcbiAgICAgIGFyZ3Muc3BsaWNlKDAsIDIpO1xuICAgICAgZnJvbSA9IGFyZ3M7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRvID0gYXJnc1swXTtcbiAgICAgIGFyZ3Muc3BsaWNlKDAsIDEpO1xuICAgICAgZnJvbSA9IGFyZ3M7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZnJvbS5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgY29uc3QgbmV4dFNvdXJjZSA9IGFyZ3NbaV07XG4gICAgICBpZiAobmV4dFNvdXJjZSAhPT0gdW5kZWZpbmVkICYmIG5leHRTb3VyY2UgIT09IG51bGwpIHtcbiAgICAgICAgY29uc3Qga2V5c0FycmF5ID0gT2JqZWN0LmtleXMoT2JqZWN0KG5leHRTb3VyY2UpKTtcbiAgICAgICAgZm9yIChsZXQgbmV4dEluZGV4ID0gMCwgbGVuID0ga2V5c0FycmF5Lmxlbmd0aDsgbmV4dEluZGV4IDwgbGVuOyBuZXh0SW5kZXggKz0gMSkge1xuICAgICAgICAgIGNvbnN0IG5leHRLZXkgPSBrZXlzQXJyYXlbbmV4dEluZGV4XTtcbiAgICAgICAgICBjb25zdCBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihuZXh0U291cmNlLCBuZXh0S2V5KTtcbiAgICAgICAgICBpZiAoZGVzYyAhPT0gdW5kZWZpbmVkICYmIGRlc2MuZW51bWVyYWJsZSkge1xuICAgICAgICAgICAgaWYgKCFkZWVwKSB7XG4gICAgICAgICAgICAgIHRvW25leHRLZXldID0gbmV4dFNvdXJjZVtuZXh0S2V5XTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoVXRpbHMuaXNPYmplY3QodG9bbmV4dEtleV0pICYmIFV0aWxzLmlzT2JqZWN0KG5leHRTb3VyY2VbbmV4dEtleV0pKSB7XG4gICAgICAgICAgICAgIFV0aWxzLmV4dGVuZCh0b1tuZXh0S2V5XSwgbmV4dFNvdXJjZVtuZXh0S2V5XSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFVdGlscy5pc09iamVjdCh0b1tuZXh0S2V5XSkgJiYgVXRpbHMuaXNPYmplY3QobmV4dFNvdXJjZVtuZXh0S2V5XSkpIHtcbiAgICAgICAgICAgICAgdG9bbmV4dEtleV0gPSB7fTtcbiAgICAgICAgICAgICAgVXRpbHMuZXh0ZW5kKHRvW25leHRLZXldLCBuZXh0U291cmNlW25leHRLZXldKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRvW25leHRLZXldID0gbmV4dFNvdXJjZVtuZXh0S2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRvO1xuICB9LFxufTtcblxuY29uc3QgRGV2aWNlID0gKGZ1bmN0aW9uIERldmljZSgpIHtcbiAgY29uc3QgdWEgPSB3aW5kb3ckMS5uYXZpZ2F0b3IudXNlckFnZW50O1xuXG4gIGNvbnN0IGRldmljZSA9IHtcbiAgICBpb3M6IGZhbHNlLFxuICAgIGFuZHJvaWQ6IGZhbHNlLFxuICAgIGFuZHJvaWRDaHJvbWU6IGZhbHNlLFxuICAgIGRlc2t0b3A6IGZhbHNlLFxuICAgIHdpbmRvd3M6IGZhbHNlLFxuICAgIGlwaG9uZTogZmFsc2UsXG4gICAgaXBob25lWDogZmFsc2UsXG4gICAgaXBvZDogZmFsc2UsXG4gICAgaXBhZDogZmFsc2UsXG4gICAgY29yZG92YTogd2luZG93JDEuY29yZG92YSB8fCB3aW5kb3ckMS5waG9uZWdhcCxcbiAgICBwaG9uZWdhcDogd2luZG93JDEuY29yZG92YSB8fCB3aW5kb3ckMS5waG9uZWdhcCxcbiAgfTtcblxuICBjb25zdCB3aW5kb3dzID0gdWEubWF0Y2goLyhXaW5kb3dzIFBob25lKTs/W1xcc1xcL10rKFtcXGQuXSspPy8pOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gIGNvbnN0IGFuZHJvaWQgPSB1YS5tYXRjaCgvKEFuZHJvaWQpOz9bXFxzXFwvXSsoW1xcZC5dKyk/Lyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgY29uc3QgaXBhZCA9IHVhLm1hdGNoKC8oaVBhZCkuKk9TXFxzKFtcXGRfXSspLyk7XG4gIGNvbnN0IGlwb2QgPSB1YS5tYXRjaCgvKGlQb2QpKC4qT1NcXHMoW1xcZF9dKykpPy8pO1xuICBjb25zdCBpcGhvbmUgPSAhaXBhZCAmJiB1YS5tYXRjaCgvKGlQaG9uZVxcc09TfGlPUylcXHMoW1xcZF9dKykvKTtcbiAgY29uc3QgaXBob25lWCA9IGlwaG9uZSAmJiB3aW5kb3ckMS5zY3JlZW4ud2lkdGggPT09IDM3NSAmJiB3aW5kb3ckMS5zY3JlZW4uaGVpZ2h0ID09PSA4MTI7XG5cblxuICAvLyBXaW5kb3dzXG4gIGlmICh3aW5kb3dzKSB7XG4gICAgZGV2aWNlLm9zID0gJ3dpbmRvd3MnO1xuICAgIGRldmljZS5vc1ZlcnNpb24gPSB3aW5kb3dzWzJdO1xuICAgIGRldmljZS53aW5kb3dzID0gdHJ1ZTtcbiAgfVxuICAvLyBBbmRyb2lkXG4gIGlmIChhbmRyb2lkICYmICF3aW5kb3dzKSB7XG4gICAgZGV2aWNlLm9zID0gJ2FuZHJvaWQnO1xuICAgIGRldmljZS5vc1ZlcnNpb24gPSBhbmRyb2lkWzJdO1xuICAgIGRldmljZS5hbmRyb2lkID0gdHJ1ZTtcbiAgICBkZXZpY2UuYW5kcm9pZENocm9tZSA9IHVhLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignY2hyb21lJykgPj0gMDtcbiAgfVxuICBpZiAoaXBhZCB8fCBpcGhvbmUgfHwgaXBvZCkge1xuICAgIGRldmljZS5vcyA9ICdpb3MnO1xuICAgIGRldmljZS5pb3MgPSB0cnVlO1xuICB9XG4gIC8vIGlPU1xuICBpZiAoaXBob25lICYmICFpcG9kKSB7XG4gICAgZGV2aWNlLm9zVmVyc2lvbiA9IGlwaG9uZVsyXS5yZXBsYWNlKC9fL2csICcuJyk7XG4gICAgZGV2aWNlLmlwaG9uZSA9IHRydWU7XG4gICAgZGV2aWNlLmlwaG9uZVggPSBpcGhvbmVYO1xuICB9XG4gIGlmIChpcGFkKSB7XG4gICAgZGV2aWNlLm9zVmVyc2lvbiA9IGlwYWRbMl0ucmVwbGFjZSgvXy9nLCAnLicpO1xuICAgIGRldmljZS5pcGFkID0gdHJ1ZTtcbiAgfVxuICBpZiAoaXBvZCkge1xuICAgIGRldmljZS5vc1ZlcnNpb24gPSBpcG9kWzNdID8gaXBvZFszXS5yZXBsYWNlKC9fL2csICcuJykgOiBudWxsO1xuICAgIGRldmljZS5pcGhvbmUgPSB0cnVlO1xuICB9XG4gIC8vIGlPUyA4KyBjaGFuZ2VkIFVBXG4gIGlmIChkZXZpY2UuaW9zICYmIGRldmljZS5vc1ZlcnNpb24gJiYgdWEuaW5kZXhPZignVmVyc2lvbi8nKSA+PSAwKSB7XG4gICAgaWYgKGRldmljZS5vc1ZlcnNpb24uc3BsaXQoJy4nKVswXSA9PT0gJzEwJykge1xuICAgICAgZGV2aWNlLm9zVmVyc2lvbiA9IHVhLnRvTG93ZXJDYXNlKCkuc3BsaXQoJ3ZlcnNpb24vJylbMV0uc3BsaXQoJyAnKVswXTtcbiAgICB9XG4gIH1cblxuICAvLyBXZWJ2aWV3XG4gIGRldmljZS53ZWJWaWV3ID0gKGlwaG9uZSB8fCBpcGFkIHx8IGlwb2QpICYmICh1YS5tYXRjaCgvLipBcHBsZVdlYktpdCg/IS4qU2FmYXJpKS9pKSB8fCB3aW5kb3ckMS5uYXZpZ2F0b3Iuc3RhbmRhbG9uZSk7XG4gIGRldmljZS53ZWJ2aWV3ID0gZGV2aWNlLndlYlZpZXc7XG5cblxuICAvLyBEZXNrdG9wXG4gIGRldmljZS5kZXNrdG9wID0gIShkZXZpY2Uub3MgfHwgZGV2aWNlLmFuZHJvaWQgfHwgZGV2aWNlLndlYlZpZXcpO1xuXG4gIC8vIE1pbmltYWwgVUlcbiAgaWYgKGRldmljZS5vcyAmJiBkZXZpY2Uub3MgPT09ICdpb3MnKSB7XG4gICAgY29uc3Qgb3NWZXJzaW9uQXJyID0gZGV2aWNlLm9zVmVyc2lvbi5zcGxpdCgnLicpO1xuICAgIGNvbnN0IG1ldGFWaWV3cG9ydCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ21ldGFbbmFtZT1cInZpZXdwb3J0XCJdJyk7XG4gICAgZGV2aWNlLm1pbmltYWxVaSA9XG4gICAgICAhZGV2aWNlLndlYlZpZXcgJiZcbiAgICAgIChpcG9kIHx8IGlwaG9uZSkgJiZcbiAgICAgIChvc1ZlcnNpb25BcnJbMF0gKiAxID09PSA3ID8gb3NWZXJzaW9uQXJyWzFdICogMSA+PSAxIDogb3NWZXJzaW9uQXJyWzBdICogMSA+IDcpICYmXG4gICAgICBtZXRhVmlld3BvcnQgJiYgbWV0YVZpZXdwb3J0LmdldEF0dHJpYnV0ZSgnY29udGVudCcpLmluZGV4T2YoJ21pbmltYWwtdWknKSA+PSAwO1xuICB9XG5cbiAgLy8gQ2hlY2sgZm9yIHN0YXR1cyBiYXIgYW5kIGZ1bGxzY3JlZW4gYXBwIG1vZGVcbiAgZGV2aWNlLm5lZWRzU3RhdHVzYmFyT3ZlcmxheSA9IGZ1bmN0aW9uIG5lZWRzU3RhdHVzYmFyT3ZlcmxheSgpIHtcbiAgICBpZiAoZGV2aWNlLndlYlZpZXcgJiYgKHdpbmRvdyQxLmlubmVyV2lkdGggKiB3aW5kb3ckMS5pbm5lckhlaWdodCA9PT0gd2luZG93JDEuc2NyZWVuLndpZHRoICogd2luZG93JDEuc2NyZWVuLmhlaWdodCkpIHtcbiAgICAgIGlmIChkZXZpY2UuaXBob25lWCAmJiAod2luZG93JDEub3JpZW50YXRpb24gPT09IDkwIHx8IHdpbmRvdyQxLm9yaWVudGF0aW9uID09PSAtOTApKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG4gIGRldmljZS5zdGF0dXNiYXIgPSBkZXZpY2UubmVlZHNTdGF0dXNiYXJPdmVybGF5KCk7XG5cbiAgLy8gUGl4ZWwgUmF0aW9cbiAgZGV2aWNlLnBpeGVsUmF0aW8gPSB3aW5kb3ckMS5kZXZpY2VQaXhlbFJhdGlvIHx8IDE7XG5cbiAgLy8gRXhwb3J0IG9iamVjdFxuICByZXR1cm4gZGV2aWNlO1xufSgpKTtcblxuY2xhc3MgRnJhbWV3b3JrN0NsYXNzIHtcbiAgY29uc3RydWN0b3IocGFyYW1zID0ge30sIHBhcmVudHMgPSBbXSkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHNlbGYucGFyYW1zID0gcGFyYW1zO1xuXG4gICAgLy8gRXZlbnRzXG4gICAgc2VsZi5ldmVudHNQYXJlbnRzID0gcGFyZW50cztcbiAgICBzZWxmLmV2ZW50c0xpc3RlbmVycyA9IHt9O1xuXG4gICAgaWYgKHNlbGYucGFyYW1zICYmIHNlbGYucGFyYW1zLm9uKSB7XG4gICAgICBPYmplY3Qua2V5cyhzZWxmLnBhcmFtcy5vbikuZm9yRWFjaCgoZXZlbnROYW1lKSA9PiB7XG4gICAgICAgIHNlbGYub24oZXZlbnROYW1lLCBzZWxmLnBhcmFtcy5vbltldmVudE5hbWVdKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBvbihldmVudHMsIGhhbmRsZXIsIHByaW9yaXR5KSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgaWYgKHR5cGVvZiBoYW5kbGVyICE9PSAnZnVuY3Rpb24nKSByZXR1cm4gc2VsZjtcbiAgICBjb25zdCBtZXRob2QgPSBwcmlvcml0eSA/ICd1bnNoaWZ0JyA6ICdwdXNoJztcbiAgICBldmVudHMuc3BsaXQoJyAnKS5mb3JFYWNoKChldmVudCkgPT4ge1xuICAgICAgaWYgKCFzZWxmLmV2ZW50c0xpc3RlbmVyc1tldmVudF0pIHNlbGYuZXZlbnRzTGlzdGVuZXJzW2V2ZW50XSA9IFtdO1xuICAgICAgc2VsZi5ldmVudHNMaXN0ZW5lcnNbZXZlbnRdW21ldGhvZF0oaGFuZGxlcik7XG4gICAgfSk7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cbiAgb25jZShldmVudHMsIGhhbmRsZXIsIHByaW9yaXR5KSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgaWYgKHR5cGVvZiBoYW5kbGVyICE9PSAnZnVuY3Rpb24nKSByZXR1cm4gc2VsZjtcbiAgICBmdW5jdGlvbiBvbmNlSGFuZGxlciguLi5hcmdzKSB7XG4gICAgICBoYW5kbGVyLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgICAgc2VsZi5vZmYoZXZlbnRzLCBvbmNlSGFuZGxlcik7XG4gICAgfVxuICAgIHJldHVybiBzZWxmLm9uKGV2ZW50cywgb25jZUhhbmRsZXIsIHByaW9yaXR5KTtcbiAgfVxuICBvZmYoZXZlbnRzLCBoYW5kbGVyKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgaWYgKCFzZWxmLmV2ZW50c0xpc3RlbmVycykgcmV0dXJuIHNlbGY7XG4gICAgZXZlbnRzLnNwbGl0KCcgJykuZm9yRWFjaCgoZXZlbnQpID0+IHtcbiAgICAgIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgc2VsZi5ldmVudHNMaXN0ZW5lcnNbZXZlbnRdID0gW107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxmLmV2ZW50c0xpc3RlbmVyc1tldmVudF0uZm9yRWFjaCgoZXZlbnRIYW5kbGVyLCBpbmRleCkgPT4ge1xuICAgICAgICAgIGlmIChldmVudEhhbmRsZXIgPT09IGhhbmRsZXIpIHtcbiAgICAgICAgICAgIHNlbGYuZXZlbnRzTGlzdGVuZXJzW2V2ZW50XS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cbiAgZW1pdCguLi5hcmdzKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgaWYgKCFzZWxmLmV2ZW50c0xpc3RlbmVycykgcmV0dXJuIHNlbGY7XG4gICAgbGV0IGV2ZW50cztcbiAgICBsZXQgZGF0YTtcbiAgICBsZXQgY29udGV4dDtcbiAgICBsZXQgZXZlbnRzUGFyZW50cztcbiAgICBpZiAodHlwZW9mIGFyZ3NbMF0gPT09ICdzdHJpbmcnIHx8IEFycmF5LmlzQXJyYXkoYXJnc1swXSkpIHtcbiAgICAgIGV2ZW50cyA9IGFyZ3NbMF07XG4gICAgICBkYXRhID0gYXJncy5zbGljZSgxLCBhcmdzLmxlbmd0aCk7XG4gICAgICBjb250ZXh0ID0gc2VsZjtcbiAgICAgIGV2ZW50c1BhcmVudHMgPSBzZWxmLmV2ZW50c1BhcmVudHM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV2ZW50cyA9IGFyZ3NbMF0uZXZlbnRzO1xuICAgICAgZGF0YSA9IGFyZ3NbMF0uZGF0YTtcbiAgICAgIGNvbnRleHQgPSBhcmdzWzBdLmNvbnRleHQgfHwgc2VsZjtcbiAgICAgIGV2ZW50c1BhcmVudHMgPSBhcmdzWzBdLmxvY2FsID8gW10gOiBhcmdzWzBdLnBhcmVudHMgfHwgc2VsZi5ldmVudHNQYXJlbnRzO1xuICAgIH1cbiAgICBjb25zdCBldmVudHNBcnJheSA9IEFycmF5LmlzQXJyYXkoZXZlbnRzKSA/IGV2ZW50cyA6IGV2ZW50cy5zcGxpdCgnICcpO1xuICAgIGNvbnN0IGxvY2FsRXZlbnRzID0gZXZlbnRzQXJyYXkubWFwKGV2ZW50TmFtZSA9PiBldmVudE5hbWUucmVwbGFjZSgnbG9jYWw6OicsICcnKSk7XG4gICAgY29uc3QgcGFyZW50RXZlbnRzID0gZXZlbnRzQXJyYXkuZmlsdGVyKGV2ZW50TmFtZSA9PiBldmVudE5hbWUuaW5kZXhPZignbG9jYWw6OicpIDwgMCk7XG5cbiAgICBsb2NhbEV2ZW50cy5mb3JFYWNoKChldmVudCkgPT4ge1xuICAgICAgaWYgKHNlbGYuZXZlbnRzTGlzdGVuZXJzICYmIHNlbGYuZXZlbnRzTGlzdGVuZXJzW2V2ZW50XSkge1xuICAgICAgICBjb25zdCBoYW5kbGVycyA9IFtdO1xuICAgICAgICBzZWxmLmV2ZW50c0xpc3RlbmVyc1tldmVudF0uZm9yRWFjaCgoZXZlbnRIYW5kbGVyKSA9PiB7XG4gICAgICAgICAgaGFuZGxlcnMucHVzaChldmVudEhhbmRsZXIpO1xuICAgICAgICB9KTtcbiAgICAgICAgaGFuZGxlcnMuZm9yRWFjaCgoZXZlbnRIYW5kbGVyKSA9PiB7XG4gICAgICAgICAgZXZlbnRIYW5kbGVyLmFwcGx5KGNvbnRleHQsIGRhdGEpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoZXZlbnRzUGFyZW50cyAmJiBldmVudHNQYXJlbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgIGV2ZW50c1BhcmVudHMuZm9yRWFjaCgoZXZlbnRzUGFyZW50KSA9PiB7XG4gICAgICAgIGV2ZW50c1BhcmVudC5lbWl0KHBhcmVudEV2ZW50cywgLi4uZGF0YSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cbiAgdXNlTW9kdWxlc1BhcmFtcyhpbnN0YW5jZVBhcmFtcykge1xuICAgIGNvbnN0IGluc3RhbmNlID0gdGhpcztcbiAgICBpZiAoIWluc3RhbmNlLm1vZHVsZXMpIHJldHVybjtcbiAgICBPYmplY3Qua2V5cyhpbnN0YW5jZS5tb2R1bGVzKS5mb3JFYWNoKChtb2R1bGVOYW1lKSA9PiB7XG4gICAgICBjb25zdCBtb2R1bGUgPSBpbnN0YW5jZS5tb2R1bGVzW21vZHVsZU5hbWVdO1xuICAgICAgLy8gRXh0ZW5kIHBhcmFtc1xuICAgICAgaWYgKG1vZHVsZS5wYXJhbXMpIHtcbiAgICAgICAgVXRpbHMuZXh0ZW5kKGluc3RhbmNlUGFyYW1zLCBtb2R1bGUucGFyYW1zKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICB1c2VNb2R1bGVzKG1vZHVsZXNQYXJhbXMgPSB7fSkge1xuICAgIGNvbnN0IGluc3RhbmNlID0gdGhpcztcbiAgICBpZiAoIWluc3RhbmNlLm1vZHVsZXMpIHJldHVybjtcbiAgICBPYmplY3Qua2V5cyhpbnN0YW5jZS5tb2R1bGVzKS5mb3JFYWNoKChtb2R1bGVOYW1lKSA9PiB7XG4gICAgICBjb25zdCBtb2R1bGUgPSBpbnN0YW5jZS5tb2R1bGVzW21vZHVsZU5hbWVdO1xuICAgICAgY29uc3QgbW9kdWxlUGFyYW1zID0gbW9kdWxlc1BhcmFtc1ttb2R1bGVOYW1lXSB8fCB7fTtcbiAgICAgIC8vIEV4dGVuZCBpbnN0YW5jZSBtZXRob2RzIGFuZCBwcm9wc1xuICAgICAgaWYgKG1vZHVsZS5pbnN0YW5jZSkge1xuICAgICAgICBPYmplY3Qua2V5cyhtb2R1bGUuaW5zdGFuY2UpLmZvckVhY2goKG1vZHVsZVByb3BOYW1lKSA9PiB7XG4gICAgICAgICAgY29uc3QgbW9kdWxlUHJvcCA9IG1vZHVsZS5pbnN0YW5jZVttb2R1bGVQcm9wTmFtZV07XG4gICAgICAgICAgaWYgKHR5cGVvZiBtb2R1bGVQcm9wID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBpbnN0YW5jZVttb2R1bGVQcm9wTmFtZV0gPSBtb2R1bGVQcm9wLmJpbmQoaW5zdGFuY2UpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbnN0YW5jZVttb2R1bGVQcm9wTmFtZV0gPSBtb2R1bGVQcm9wO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICAvLyBBZGQgZXZlbnQgbGlzdGVuZXJzXG4gICAgICBpZiAobW9kdWxlLm9uICYmIGluc3RhbmNlLm9uKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKG1vZHVsZS5vbikuZm9yRWFjaCgobW9kdWxlRXZlbnROYW1lKSA9PiB7XG4gICAgICAgICAgaW5zdGFuY2Uub24obW9kdWxlRXZlbnROYW1lLCBtb2R1bGUub25bbW9kdWxlRXZlbnROYW1lXSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyBNb2R1bGUgY3JlYXRlIGNhbGxiYWNrXG4gICAgICBpZiAobW9kdWxlLmNyZWF0ZSkge1xuICAgICAgICBtb2R1bGUuY3JlYXRlLmJpbmQoaW5zdGFuY2UpKG1vZHVsZVBhcmFtcyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIHNldCBjb21wb25lbnRzKGNvbXBvbmVudHMpIHtcbiAgICBjb25zdCBDbGFzcyA9IHRoaXM7XG4gICAgaWYgKCFDbGFzcy51c2UpIHJldHVybjtcbiAgICBDbGFzcy51c2UoY29tcG9uZW50cyk7XG4gIH1cbiAgc3RhdGljIGluc3RhbGxNb2R1bGUobW9kdWxlLCAuLi5wYXJhbXMpIHtcbiAgICBjb25zdCBDbGFzcyA9IHRoaXM7XG4gICAgaWYgKCFDbGFzcy5wcm90b3R5cGUubW9kdWxlcykgQ2xhc3MucHJvdG90eXBlLm1vZHVsZXMgPSB7fTtcbiAgICBjb25zdCBuYW1lID0gbW9kdWxlLm5hbWUgfHwgKGAke09iamVjdC5rZXlzKENsYXNzLnByb3RvdHlwZS5tb2R1bGVzKS5sZW5ndGh9XyR7VXRpbHMubm93KCl9YCk7XG4gICAgQ2xhc3MucHJvdG90eXBlLm1vZHVsZXNbbmFtZV0gPSBtb2R1bGU7XG4gICAgLy8gUHJvdG90eXBlXG4gICAgaWYgKG1vZHVsZS5wcm90bykge1xuICAgICAgT2JqZWN0LmtleXMobW9kdWxlLnByb3RvKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgQ2xhc3MucHJvdG90eXBlW2tleV0gPSBtb2R1bGUucHJvdG9ba2V5XTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBDbGFzc1xuICAgIGlmIChtb2R1bGUuc3RhdGljKSB7XG4gICAgICBPYmplY3Qua2V5cyhtb2R1bGUuc3RhdGljKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgQ2xhc3Nba2V5XSA9IG1vZHVsZS5zdGF0aWNba2V5XTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBDYWxsYmFja1xuICAgIGlmIChtb2R1bGUuaW5zdGFsbCkge1xuICAgICAgbW9kdWxlLmluc3RhbGwuYXBwbHkoQ2xhc3MsIHBhcmFtcyk7XG4gICAgfVxuICAgIHJldHVybiBDbGFzcztcbiAgfVxuICBzdGF0aWMgdXNlKG1vZHVsZSwgLi4ucGFyYW1zKSB7XG4gICAgY29uc3QgQ2xhc3MgPSB0aGlzO1xuICAgIGlmIChBcnJheS5pc0FycmF5KG1vZHVsZSkpIHtcbiAgICAgIG1vZHVsZS5mb3JFYWNoKG0gPT4gQ2xhc3MuaW5zdGFsbE1vZHVsZShtKSk7XG4gICAgICByZXR1cm4gQ2xhc3M7XG4gICAgfVxuICAgIHJldHVybiBDbGFzcy5pbnN0YWxsTW9kdWxlKG1vZHVsZSwgLi4ucGFyYW1zKTtcbiAgfVxufVxuXG5jbGFzcyBGcmFtZXdvcms3IGV4dGVuZHMgRnJhbWV3b3JrN0NsYXNzIHtcbiAgY29uc3RydWN0b3IocGFyYW1zKSB7XG4gICAgc3VwZXIocGFyYW1zKTtcblxuICAgIGNvbnN0IHBhc3NlZFBhcmFtcyA9IFV0aWxzLmV4dGVuZCh7fSwgcGFyYW1zKTtcblxuICAgIC8vIEFwcCBJbnN0YW5jZVxuICAgIGNvbnN0IGFwcCA9IHRoaXM7XG5cbiAgICAvLyBEZWZhdWx0XG4gICAgY29uc3QgZGVmYXVsdHMgPSB7XG4gICAgICB2ZXJzaW9uOiAnMS4wLjAnLFxuICAgICAgaWQ6ICdpby5mcmFtZXdvcms3LnRlc3RhcHAnLFxuICAgICAgcm9vdDogJ2JvZHknLFxuICAgICAgdGhlbWU6ICdhdXRvJyxcbiAgICAgIGxhbmd1YWdlOiB3aW5kb3ckMS5uYXZpZ2F0b3IubGFuZ3VhZ2UsXG4gICAgICByb3V0ZXM6IFtdLFxuICAgICAgbmFtZTogJ0ZyYW1ld29yazcnLFxuICAgICAgaW5pdE9uRGV2aWNlUmVhZHk6IHRydWUsXG4gICAgICBpbml0OiB0cnVlLFxuICAgIH07XG5cbiAgICAvLyBFeHRlbmQgZGVmYXVsdHMgd2l0aCBtb2R1bGVzIHBhcmFtc1xuICAgIGFwcC51c2VNb2R1bGVzUGFyYW1zKGRlZmF1bHRzKTtcblxuXG4gICAgLy8gRXh0ZW5kIGRlZmF1bHRzIHdpdGggcGFzc2VkIHBhcmFtc1xuICAgIGFwcC5wYXJhbXMgPSBVdGlscy5leHRlbmQoZGVmYXVsdHMsIHBhcmFtcyk7XG5cbiAgICBjb25zdCAkcm9vdEVsID0gJChhcHAucGFyYW1zLnJvb3QpO1xuXG4gICAgVXRpbHMuZXh0ZW5kKGFwcCwge1xuICAgICAgLy8gQXBwIElkXG4gICAgICBpZDogYXBwLnBhcmFtcy5pZCxcbiAgICAgIC8vIEFwcCBOYW1lXG4gICAgICBuYW1lOiBhcHAucGFyYW1zLm5hbWUsXG4gICAgICAvLyBBcHAgdmVyc2lvblxuICAgICAgdmVyc2lvbjogYXBwLnBhcmFtcy52ZXJzaW9uLFxuICAgICAgLy8gUm91dGVzXG4gICAgICByb3V0ZXM6IGFwcC5wYXJhbXMucm91dGVzLFxuICAgICAgLy8gTGFuZ1xuICAgICAgbGFuZ3VhZ2U6IGFwcC5wYXJhbXMubGFuZ3VhZ2UsXG4gICAgICAvLyBSb290XG4gICAgICByb290OiAkcm9vdEVsLFxuICAgICAgLy8gUlRMXG4gICAgICBydGw6ICRyb290RWwuY3NzKCdkaXJlY3Rpb24nKSA9PT0gJ3J0bCcsXG4gICAgICAvLyBUaGVtZVxuICAgICAgdGhlbWU6IChmdW5jdGlvbiBnZXRUaGVtZSgpIHtcbiAgICAgICAgaWYgKGFwcC5wYXJhbXMudGhlbWUgPT09ICdhdXRvJykge1xuICAgICAgICAgIHJldHVybiBEZXZpY2UuaW9zID8gJ2lvcycgOiAnbWQnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcHAucGFyYW1zLnRoZW1lO1xuICAgICAgfSgpKSxcbiAgICAgIC8vIEluaXRpYWxseSBwYXNzZWQgcGFyYW1ldGVyc1xuICAgICAgcGFzc2VkUGFyYW1zLFxuICAgIH0pO1xuXG4gICAgLy8gU2F2ZSBSb290XG4gICAgaWYgKGFwcC5yb290ICYmIGFwcC5yb290WzBdKSB7XG4gICAgICBhcHAucm9vdFswXS5mNyA9IGFwcDtcbiAgICB9XG5cbiAgICAvLyBJbnN0YWxsIE1vZHVsZXNcbiAgICBhcHAudXNlTW9kdWxlcygpO1xuXG4gICAgLy8gSW5pdFxuICAgIGlmIChhcHAucGFyYW1zLmluaXQpIHtcbiAgICAgIGlmIChEZXZpY2UuY29yZG92YSAmJiBhcHAucGFyYW1zLmluaXRPbkRldmljZVJlYWR5KSB7XG4gICAgICAgICQoZG9jdW1lbnQpLm9uKCdkZXZpY2VyZWFkeScsICgpID0+IHtcbiAgICAgICAgICBhcHAuaW5pdCgpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFwcC5pbml0KCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIGFwcCBpbnN0YW5jZVxuICAgIHJldHVybiBhcHA7XG4gIH1cbiAgaW5pdCgpIHtcbiAgICBjb25zdCBhcHAgPSB0aGlzO1xuICAgIGlmIChhcHAuaW5pdGlhbGl6ZWQpIHJldHVybjtcblxuICAgIGFwcC5yb290LmFkZENsYXNzKCdmcmFtZXdvcms3LWluaXRpYWxpemluZycpO1xuXG4gICAgLy8gUlRMIGF0dHJcbiAgICBpZiAoYXBwLnJ0bCkge1xuICAgICAgJCgnaHRtbCcpLmF0dHIoJ2RpcicsICdydGwnKTtcbiAgICB9XG5cbiAgICAvLyBSb290IGNsYXNzXG4gICAgYXBwLnJvb3QuYWRkQ2xhc3MoJ2ZyYW1ld29yazctcm9vdCcpO1xuXG4gICAgLy8gVGhlbWUgY2xhc3NcbiAgICAkKCdodG1sJykucmVtb3ZlQ2xhc3MoJ2lvcyBtZCcpLmFkZENsYXNzKGFwcC50aGVtZSk7XG5cbiAgICAvLyBEYXRhXG4gICAgYXBwLmRhdGEgPSB7fTtcbiAgICBpZiAoYXBwLnBhcmFtcy5kYXRhICYmIHR5cGVvZiBhcHAucGFyYW1zLmRhdGEgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIFV0aWxzLmV4dGVuZChhcHAuZGF0YSwgYXBwLnBhcmFtcy5kYXRhLmJpbmQoYXBwKSgpKTtcbiAgICB9IGVsc2UgaWYgKGFwcC5wYXJhbXMuZGF0YSkge1xuICAgICAgVXRpbHMuZXh0ZW5kKGFwcC5kYXRhLCBhcHAucGFyYW1zLmRhdGEpO1xuICAgIH1cbiAgICAvLyBNZXRob2RzXG4gICAgYXBwLm1ldGhvZHMgPSB7fTtcbiAgICBpZiAoYXBwLnBhcmFtcy5tZXRob2RzKSB7XG4gICAgICBVdGlscy5leHRlbmQoYXBwLm1ldGhvZHMsIGFwcC5wYXJhbXMubWV0aG9kcyk7XG4gICAgfVxuICAgIC8vIEluaXQgY2xhc3NcbiAgICBVdGlscy5uZXh0RnJhbWUoKCkgPT4ge1xuICAgICAgYXBwLnJvb3QucmVtb3ZlQ2xhc3MoJ2ZyYW1ld29yazctaW5pdGlhbGl6aW5nJyk7XG4gICAgfSk7XG4gICAgLy8gRW1pdCwgaW5pdCBvdGhlciBtb2R1bGVzXG4gICAgYXBwLmluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICBhcHAuZW1pdCgnaW5pdCcpO1xuICB9XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICBnZXQgJCgpIHtcbiAgICByZXR1cm4gJDtcbiAgfVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgZ2V0IHQ3KCkge1xuICAgIHJldHVybiBUZW1wbGF0ZTc7XG4gIH1cbiAgc3RhdGljIGdldCBEb203KCkge1xuICAgIHJldHVybiAkO1xuICB9XG4gIHN0YXRpYyBnZXQgJCgpIHtcbiAgICByZXR1cm4gJDtcbiAgfVxuICBzdGF0aWMgZ2V0IFRlbXBsYXRlNygpIHtcbiAgICByZXR1cm4gVGVtcGxhdGU3O1xuICB9XG4gIHN0YXRpYyBnZXQgQ2xhc3MoKSB7XG4gICAgcmV0dXJuIEZyYW1ld29yazdDbGFzcztcbiAgfVxufVxuXG5jb25zdCBnbG9iYWxzID0ge307XG5sZXQganNvbnBSZXF1ZXN0cyA9IDA7XG5cbmZ1bmN0aW9uIFJlcXVlc3QocmVxdWVzdE9wdGlvbnMpIHtcbiAgY29uc3QgZ2xvYmFsc05vQ2FsbGJhY2tzID0gVXRpbHMuZXh0ZW5kKHt9LCBnbG9iYWxzKTtcbiAgKCdiZWZvcmVDcmVhdGUgYmVmb3JlT3BlbiBiZWZvcmVTZW5kIGVycm9yIGNvbXBsZXRlIHN1Y2Nlc3Mgc3RhdHVzQ29kZScpLnNwbGl0KCcgJykuZm9yRWFjaCgoY2FsbGJhY2tOYW1lKSA9PiB7XG4gICAgZGVsZXRlIGdsb2JhbHNOb0NhbGxiYWNrc1tjYWxsYmFja05hbWVdO1xuICB9KTtcbiAgY29uc3QgZGVmYXVsdHMgPSBVdGlscy5leHRlbmQoe1xuICAgIHVybDogd2luZG93JDEubG9jYXRpb24udG9TdHJpbmcoKSxcbiAgICBtZXRob2Q6ICdHRVQnLFxuICAgIGRhdGE6IGZhbHNlLFxuICAgIGFzeW5jOiB0cnVlLFxuICAgIGNhY2hlOiB0cnVlLFxuICAgIHVzZXI6ICcnLFxuICAgIHBhc3N3b3JkOiAnJyxcbiAgICBoZWFkZXJzOiB7fSxcbiAgICB4aHJGaWVsZHM6IHt9LFxuICAgIHN0YXR1c0NvZGU6IHt9LFxuICAgIHByb2Nlc3NEYXRhOiB0cnVlLFxuICAgIGRhdGFUeXBlOiAndGV4dCcsXG4gICAgY29udGVudFR5cGU6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnLFxuICAgIHRpbWVvdXQ6IDAsXG4gIH0sIGdsb2JhbHNOb0NhbGxiYWNrcyk7XG5cbiAgY29uc3Qgb3B0aW9ucyA9IFV0aWxzLmV4dGVuZCh7fSwgZGVmYXVsdHMsIHJlcXVlc3RPcHRpb25zKTtcbiAgbGV0IHByb2NlZWRSZXF1ZXN0O1xuXG4gIC8vIEZ1bmN0aW9uIHRvIHJ1biBYSFIgY2FsbGJhY2tzIGFuZCBldmVudHNcbiAgZnVuY3Rpb24gZmlyZUNhbGxiYWNrKGNhbGxiYWNrTmFtZSwgLi4uZGF0YSkge1xuICAgIC8qXG4gICAgICBDYWxsYmFja3M6XG4gICAgICBiZWZvcmVDcmVhdGUgKG9wdGlvbnMpLFxuICAgICAgYmVmb3JlT3BlbiAoeGhyLCBvcHRpb25zKSxcbiAgICAgIGJlZm9yZVNlbmQgKHhociwgb3B0aW9ucyksXG4gICAgICBlcnJvciAoeGhyLCBzdGF0dXMpLFxuICAgICAgY29tcGxldGUgKHhociwgc3RhdXR1cyksXG4gICAgICBzdWNjZXNzIChyZXNwb25zZSwgc3RhdHVzLCB4aHIpLFxuICAgICAgc3RhdHVzQ29kZSAoKVxuICAgICovXG4gICAgbGV0IGdsb2JhbENhbGxiYWNrVmFsdWU7XG4gICAgbGV0IG9wdGlvbkNhbGxiYWNrVmFsdWU7XG4gICAgaWYgKGdsb2JhbHNbY2FsbGJhY2tOYW1lXSkge1xuICAgICAgZ2xvYmFsQ2FsbGJhY2tWYWx1ZSA9IGdsb2JhbHNbY2FsbGJhY2tOYW1lXSguLi5kYXRhKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnNbY2FsbGJhY2tOYW1lXSkge1xuICAgICAgb3B0aW9uQ2FsbGJhY2tWYWx1ZSA9IG9wdGlvbnNbY2FsbGJhY2tOYW1lXSguLi5kYXRhKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBnbG9iYWxDYWxsYmFja1ZhbHVlICE9PSAnYm9vbGVhbicpIGdsb2JhbENhbGxiYWNrVmFsdWUgPSB0cnVlO1xuICAgIGlmICh0eXBlb2Ygb3B0aW9uQ2FsbGJhY2tWYWx1ZSAhPT0gJ2Jvb2xlYW4nKSBvcHRpb25DYWxsYmFja1ZhbHVlID0gdHJ1ZTtcbiAgICByZXR1cm4gKGdsb2JhbENhbGxiYWNrVmFsdWUgJiYgb3B0aW9uQ2FsbGJhY2tWYWx1ZSk7XG4gIH1cblxuICAvLyBCZWZvcmUgY3JlYXRlIGNhbGxiYWNrXG4gIHByb2NlZWRSZXF1ZXN0ID0gZmlyZUNhbGxiYWNrKCdiZWZvcmVDcmVhdGUnLCBvcHRpb25zKTtcbiAgaWYgKHByb2NlZWRSZXF1ZXN0ID09PSBmYWxzZSkgcmV0dXJuIHVuZGVmaW5lZDtcblxuICAvLyBGb3IgalF1ZXJ5IGd1eXNcbiAgaWYgKG9wdGlvbnMudHlwZSkgb3B0aW9ucy5tZXRob2QgPSBvcHRpb25zLnR5cGU7XG5cbiAgLy8gUGFyYW1ldGVycyBQcmVmaXhcbiAgbGV0IHBhcmFtc1ByZWZpeCA9IG9wdGlvbnMudXJsLmluZGV4T2YoJz8nKSA+PSAwID8gJyYnIDogJz8nO1xuXG4gIC8vIFVDIG1ldGhvZFxuICBjb25zdCBtZXRob2QgPSBvcHRpb25zLm1ldGhvZC50b1VwcGVyQ2FzZSgpO1xuXG4gIC8vIERhdGEgdG8gbW9kaWZ5IEdFVCBVUkxcbiAgaWYgKChtZXRob2QgPT09ICdHRVQnIHx8IG1ldGhvZCA9PT0gJ0hFQUQnIHx8IG1ldGhvZCA9PT0gJ09QVElPTlMnIHx8IG1ldGhvZCA9PT0gJ0RFTEVURScpICYmIG9wdGlvbnMuZGF0YSkge1xuICAgIGxldCBzdHJpbmdEYXRhO1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5kYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gU2hvdWxkIGJlIGtleT12YWx1ZSBzdHJpbmdcbiAgICAgIGlmIChvcHRpb25zLmRhdGEuaW5kZXhPZignPycpID49IDApIHN0cmluZ0RhdGEgPSBvcHRpb25zLmRhdGEuc3BsaXQoJz8nKVsxXTtcbiAgICAgIGVsc2Ugc3RyaW5nRGF0YSA9IG9wdGlvbnMuZGF0YTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU2hvdWxkIGJlIGtleT12YWx1ZSBvYmplY3RcbiAgICAgIHN0cmluZ0RhdGEgPSBVdGlscy5zZXJpYWxpemVPYmplY3Qob3B0aW9ucy5kYXRhKTtcbiAgICB9XG4gICAgaWYgKHN0cmluZ0RhdGEubGVuZ3RoKSB7XG4gICAgICBvcHRpb25zLnVybCArPSBwYXJhbXNQcmVmaXggKyBzdHJpbmdEYXRhO1xuICAgICAgaWYgKHBhcmFtc1ByZWZpeCA9PT0gJz8nKSBwYXJhbXNQcmVmaXggPSAnJic7XG4gICAgfVxuICB9XG5cbiAgLy8gSlNPTlBcbiAgaWYgKG9wdGlvbnMuZGF0YVR5cGUgPT09ICdqc29uJyAmJiBvcHRpb25zLnVybC5pbmRleE9mKCdjYWxsYmFjaz0nKSA+PSAwKSB7XG4gICAgY29uc3QgY2FsbGJhY2tOYW1lID0gYGY3anNvbnBfJHtEYXRlLm5vdygpICsgKChqc29ucFJlcXVlc3RzICs9IDEpKX1gO1xuICAgIGxldCBhYm9ydFRpbWVvdXQ7XG4gICAgY29uc3QgY2FsbGJhY2tTcGxpdCA9IG9wdGlvbnMudXJsLnNwbGl0KCdjYWxsYmFjaz0nKTtcbiAgICBsZXQgcmVxdWVzdFVybCA9IGAke2NhbGxiYWNrU3BsaXRbMF19Y2FsbGJhY2s9JHtjYWxsYmFja05hbWV9YDtcbiAgICBpZiAoY2FsbGJhY2tTcGxpdFsxXS5pbmRleE9mKCcmJykgPj0gMCkge1xuICAgICAgY29uc3QgYWRkVmFycyA9IGNhbGxiYWNrU3BsaXRbMV0uc3BsaXQoJyYnKS5maWx0ZXIoZWwgPT4gZWwuaW5kZXhPZignPScpID4gMCkuam9pbignJicpO1xuICAgICAgaWYgKGFkZFZhcnMubGVuZ3RoID4gMCkgcmVxdWVzdFVybCArPSBgJiR7YWRkVmFyc31gO1xuICAgIH1cblxuICAgIC8vIENyZWF0ZSBzY3JpcHRcbiAgICBsZXQgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgc2NyaXB0LnR5cGUgPSAndGV4dC9qYXZhc2NyaXB0JztcbiAgICBzY3JpcHQub25lcnJvciA9IGZ1bmN0aW9uIG9uZXJyb3IoKSB7XG4gICAgICBjbGVhclRpbWVvdXQoYWJvcnRUaW1lb3V0KTtcbiAgICAgIGZpcmVDYWxsYmFjaygnZXJyb3InLCBudWxsLCAnc2NyaXB0ZXJyb3InKTtcbiAgICAgIGZpcmVDYWxsYmFjaygnY29tcGxldGUnLCBudWxsLCAnc2NyaXB0ZXJyb3InKTtcbiAgICB9O1xuICAgIHNjcmlwdC5zcmMgPSByZXF1ZXN0VXJsO1xuXG4gICAgLy8gSGFuZGxlclxuICAgIHdpbmRvdyQxW2NhbGxiYWNrTmFtZV0gPSBmdW5jdGlvbiBqc29ucENhbGxiYWNrKGRhdGEpIHtcbiAgICAgIGNsZWFyVGltZW91dChhYm9ydFRpbWVvdXQpO1xuICAgICAgZmlyZUNhbGxiYWNrKCdzdWNjZXNzJywgZGF0YSk7XG4gICAgICBzY3JpcHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzY3JpcHQpO1xuICAgICAgc2NyaXB0ID0gbnVsbDtcbiAgICAgIGRlbGV0ZSB3aW5kb3ckMVtjYWxsYmFja05hbWVdO1xuICAgIH07XG4gICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignaGVhZCcpLmFwcGVuZENoaWxkKHNjcmlwdCk7XG5cbiAgICBpZiAob3B0aW9ucy50aW1lb3V0ID4gMCkge1xuICAgICAgYWJvcnRUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHNjcmlwdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHNjcmlwdCk7XG4gICAgICAgIHNjcmlwdCA9IG51bGw7XG4gICAgICAgIGZpcmVDYWxsYmFjaygnZXJyb3InLCBudWxsLCAndGltZW91dCcpO1xuICAgICAgfSwgb3B0aW9ucy50aW1lb3V0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgLy8gQ2FjaGUgZm9yIEdFVC9IRUFEIHJlcXVlc3RzXG4gIGlmIChtZXRob2QgPT09ICdHRVQnIHx8IG1ldGhvZCA9PT0gJ0hFQUQnIHx8IG1ldGhvZCA9PT0gJ09QVElPTlMnIHx8IG1ldGhvZCA9PT0gJ0RFTEVURScpIHtcbiAgICBpZiAob3B0aW9ucy5jYWNoZSA9PT0gZmFsc2UpIHtcbiAgICAgIG9wdGlvbnMudXJsICs9IGAke3BhcmFtc1ByZWZpeH1fbm9jYWNoZSR7RGF0ZS5ub3coKX1gO1xuICAgIH1cbiAgfVxuXG4gIC8vIENyZWF0ZSBYSFJcbiAgY29uc3QgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cbiAgLy8gU2F2ZSBSZXF1ZXN0IFVSTFxuICB4aHIucmVxdWVzdFVybCA9IG9wdGlvbnMudXJsO1xuICB4aHIucmVxdWVzdFBhcmFtZXRlcnMgPSBvcHRpb25zO1xuXG4gIC8vIEJlZm9yZSBvcGVuIGNhbGxiYWNrXG4gIHByb2NlZWRSZXF1ZXN0ID0gZmlyZUNhbGxiYWNrKCdiZWZvcmVPcGVuJywgeGhyLCBvcHRpb25zKTtcbiAgaWYgKHByb2NlZWRSZXF1ZXN0ID09PSBmYWxzZSkgcmV0dXJuIHhocjtcblxuICAvLyBPcGVuIFhIUlxuICB4aHIub3BlbihtZXRob2QsIG9wdGlvbnMudXJsLCBvcHRpb25zLmFzeW5jLCBvcHRpb25zLnVzZXIsIG9wdGlvbnMucGFzc3dvcmQpO1xuXG4gIC8vIENyZWF0ZSBQT1NUIERhdGFcbiAgbGV0IHBvc3REYXRhID0gbnVsbDtcblxuICBpZiAoKG1ldGhvZCA9PT0gJ1BPU1QnIHx8IG1ldGhvZCA9PT0gJ1BVVCcgfHwgbWV0aG9kID09PSAnUEFUQ0gnKSAmJiBvcHRpb25zLmRhdGEpIHtcbiAgICBpZiAob3B0aW9ucy5wcm9jZXNzRGF0YSkge1xuICAgICAgY29uc3QgcG9zdERhdGFJbnN0YW5jZXMgPSBbQXJyYXlCdWZmZXIsIEJsb2IsIERvY3VtZW50LCBGb3JtRGF0YV07XG4gICAgICAvLyBQb3N0IERhdGFcbiAgICAgIGlmIChwb3N0RGF0YUluc3RhbmNlcy5pbmRleE9mKG9wdGlvbnMuZGF0YS5jb25zdHJ1Y3RvcikgPj0gMCkge1xuICAgICAgICBwb3N0RGF0YSA9IG9wdGlvbnMuZGF0YTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFBPU1QgSGVhZGVyc1xuICAgICAgICBjb25zdCBib3VuZGFyeSA9IGAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0ke0RhdGUubm93KCkudG9TdHJpbmcoMTYpfWA7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuY29udGVudFR5cGUgPT09ICdtdWx0aXBhcnQvZm9ybS1kYXRhJykge1xuICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdDb250ZW50LVR5cGUnLCBgbXVsdGlwYXJ0L2Zvcm0tZGF0YTsgYm91bmRhcnk9JHtib3VuZGFyeX1gKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignQ29udGVudC1UeXBlJywgb3B0aW9ucy5jb250ZW50VHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgcG9zdERhdGEgPSAnJztcbiAgICAgICAgbGV0IGRhdGEgPSBVdGlscy5zZXJpYWxpemVPYmplY3Qob3B0aW9ucy5kYXRhKTtcbiAgICAgICAgaWYgKG9wdGlvbnMuY29udGVudFR5cGUgPT09ICdtdWx0aXBhcnQvZm9ybS1kYXRhJykge1xuICAgICAgICAgIGRhdGEgPSBkYXRhLnNwbGl0KCcmJyk7XG4gICAgICAgICAgY29uc3QgbmV3RGF0YSA9IFtdO1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgbmV3RGF0YS5wdXNoKGBDb250ZW50LURpc3Bvc2l0aW9uOiBmb3JtLWRhdGE7IG5hbWU9XCIke2RhdGFbaV0uc3BsaXQoJz0nKVswXX1cIlxcclxcblxcclxcbiR7ZGF0YVtpXS5zcGxpdCgnPScpWzFdfVxcclxcbmApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwb3N0RGF0YSA9IGAtLSR7Ym91bmRhcnl9XFxyXFxuJHtuZXdEYXRhLmpvaW4oYC0tJHtib3VuZGFyeX1cXHJcXG5gKX0tLSR7Ym91bmRhcnl9LS1cXHJcXG5gO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBvc3REYXRhID0gZGF0YTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwb3N0RGF0YSA9IG9wdGlvbnMuZGF0YTtcbiAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdDb250ZW50LVR5cGUnLCBvcHRpb25zLmNvbnRlbnRUeXBlKTtcbiAgICB9XG4gIH1cblxuICAvLyBBZGRpdGlvbmFsIGhlYWRlcnNcbiAgaWYgKG9wdGlvbnMuaGVhZGVycykge1xuICAgIE9iamVjdC5rZXlzKG9wdGlvbnMuaGVhZGVycykuZm9yRWFjaCgoaGVhZGVyTmFtZSkgPT4ge1xuICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoaGVhZGVyTmFtZSwgb3B0aW9ucy5oZWFkZXJzW2hlYWRlck5hbWVdKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIENoZWNrIGZvciBjcm9zc0RvbWFpblxuICBpZiAodHlwZW9mIG9wdGlvbnMuY3Jvc3NEb21haW4gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgb3B0aW9ucy5jcm9zc0RvbWFpbiA9IC9eKFtcXHctXSs6KT9cXC9cXC8oW15cXC9dKykvLnRlc3Qob3B0aW9ucy51cmwpICYmIFJlZ0V4cC4kMiAhPT0gd2luZG93JDEubG9jYXRpb24uaG9zdDtcbiAgfVxuXG4gIGlmICghb3B0aW9ucy5jcm9zc0RvbWFpbikge1xuICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdYLVJlcXVlc3RlZC1XaXRoJywgJ1hNTEh0dHBSZXF1ZXN0Jyk7XG4gIH1cblxuICBpZiAob3B0aW9ucy54aHJGaWVsZHMpIHtcbiAgICBVdGlscy5leHRlbmQoeGhyLCBvcHRpb25zLnhockZpZWxkcyk7XG4gIH1cblxuICBsZXQgeGhyVGltZW91dDtcblxuICAvLyBIYW5kbGUgWEhSXG4gIHhoci5vbmxvYWQgPSBmdW5jdGlvbiBvbmxvYWQoKSB7XG4gICAgaWYgKHhoclRpbWVvdXQpIGNsZWFyVGltZW91dCh4aHJUaW1lb3V0KTtcbiAgICBpZiAoKHhoci5zdGF0dXMgPj0gMjAwICYmIHhoci5zdGF0dXMgPCAzMDApIHx8IHhoci5zdGF0dXMgPT09IDApIHtcbiAgICAgIGxldCByZXNwb25zZURhdGE7XG4gICAgICBpZiAob3B0aW9ucy5kYXRhVHlwZSA9PT0gJ2pzb24nKSB7XG4gICAgICAgIGxldCBwYXJzZUVycm9yO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJlc3BvbnNlRGF0YSA9IEpTT04ucGFyc2UoeGhyLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIHBhcnNlRXJyb3IgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcGFyc2VFcnJvcikge1xuICAgICAgICAgIGZpcmVDYWxsYmFjaygnc3VjY2VzcycsIHJlc3BvbnNlRGF0YSwgeGhyLnN0YXR1cywgeGhyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmaXJlQ2FsbGJhY2soJ2Vycm9yJywgeGhyLCAncGFyc2VlcnJvcicpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNwb25zZURhdGEgPSB4aHIucmVzcG9uc2VUeXBlID09PSAndGV4dCcgfHwgeGhyLnJlc3BvbnNlVHlwZSA9PT0gJycgPyB4aHIucmVzcG9uc2VUZXh0IDogeGhyLnJlc3BvbnNlO1xuICAgICAgICBmaXJlQ2FsbGJhY2soJ3N1Y2Nlc3MnLCByZXNwb25zZURhdGEsIHhoci5zdGF0dXMsIHhocik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZpcmVDYWxsYmFjaygnZXJyb3InLCB4aHIsIHhoci5zdGF0dXMpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5zdGF0dXNDb2RlKSB7XG4gICAgICBpZiAoZ2xvYmFscy5zdGF0dXNDb2RlICYmIGdsb2JhbHMuc3RhdHVzQ29kZVt4aHIuc3RhdHVzXSkgZ2xvYmFscy5zdGF0dXNDb2RlW3hoci5zdGF0dXNdKHhocik7XG4gICAgICBpZiAob3B0aW9ucy5zdGF0dXNDb2RlW3hoci5zdGF0dXNdKSBvcHRpb25zLnN0YXR1c0NvZGVbeGhyLnN0YXR1c10oeGhyKTtcbiAgICB9XG4gICAgZmlyZUNhbGxiYWNrKCdjb21wbGV0ZScsIHhociwgeGhyLnN0YXR1cyk7XG4gIH07XG5cbiAgeGhyLm9uZXJyb3IgPSBmdW5jdGlvbiBvbmVycm9yKCkge1xuICAgIGlmICh4aHJUaW1lb3V0KSBjbGVhclRpbWVvdXQoeGhyVGltZW91dCk7XG4gICAgZmlyZUNhbGxiYWNrKCdlcnJvcicsIHhociwgeGhyLnN0YXR1cyk7XG4gICAgZmlyZUNhbGxiYWNrKCdjb21wbGV0ZScsIHhociwgJ2Vycm9yJyk7XG4gIH07XG5cbiAgLy8gVGltZW91dFxuICBpZiAob3B0aW9ucy50aW1lb3V0ID4gMCkge1xuICAgIHhoci5vbmFib3J0ID0gZnVuY3Rpb24gb25hYm9ydCgpIHtcbiAgICAgIGlmICh4aHJUaW1lb3V0KSBjbGVhclRpbWVvdXQoeGhyVGltZW91dCk7XG4gICAgfTtcbiAgICB4aHJUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB4aHIuYWJvcnQoKTtcbiAgICAgIGZpcmVDYWxsYmFjaygnZXJyb3InLCB4aHIsICd0aW1lb3V0Jyk7XG4gICAgICBmaXJlQ2FsbGJhY2soJ2NvbXBsZXRlJywgeGhyLCAndGltZW91dCcpO1xuICAgIH0sIG9wdGlvbnMudGltZW91dCk7XG4gIH1cblxuICAvLyBBamF4IHN0YXJ0IGNhbGxiYWNrXG4gIHByb2NlZWRSZXF1ZXN0ID0gZmlyZUNhbGxiYWNrKCdiZWZvcmVTZW5kJywgeGhyLCBvcHRpb25zKTtcbiAgaWYgKHByb2NlZWRSZXF1ZXN0ID09PSBmYWxzZSkgcmV0dXJuIHhocjtcblxuICAvLyBTZW5kIFhIUlxuICB4aHIuc2VuZChwb3N0RGF0YSk7XG5cbiAgLy8gUmV0dXJuIFhIUiBvYmplY3RcbiAgcmV0dXJuIHhocjtcbn1cbmZ1bmN0aW9uIFJlcXVlc3RTaG9ydGN1dChtZXRob2QsIC4uLmFyZ3MpIHtcbiAgbGV0IFt1cmwsIGRhdGEsIHN1Y2Nlc3MsIGVycm9yLCBkYXRhVHlwZV0gPSBbXTtcbiAgaWYgKHR5cGVvZiBhcmdzWzFdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgW3VybCwgc3VjY2VzcywgZXJyb3IsIGRhdGFUeXBlXSA9IGFyZ3M7XG4gIH0gZWxzZSB7XG4gICAgW3VybCwgZGF0YSwgc3VjY2VzcywgZXJyb3IsIGRhdGFUeXBlXSA9IGFyZ3M7XG4gIH1cbiAgW3N1Y2Nlc3MsIGVycm9yXS5mb3JFYWNoKChjYWxsYmFjaykgPT4ge1xuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdzdHJpbmcnKSB7XG4gICAgICBkYXRhVHlwZSA9IGNhbGxiYWNrO1xuICAgICAgaWYgKGNhbGxiYWNrID09PSBzdWNjZXNzKSBzdWNjZXNzID0gdW5kZWZpbmVkO1xuICAgICAgZWxzZSBlcnJvciA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0pO1xuICBkYXRhVHlwZSA9IGRhdGFUeXBlIHx8IChtZXRob2QgPT09ICdqc29uJyB8fCBtZXRob2QgPT09ICdwb3N0SlNPTicgPyAnanNvbicgOiB1bmRlZmluZWQpO1xuICBjb25zdCByZXF1ZXN0T3B0aW9ucyA9IHtcbiAgICB1cmwsXG4gICAgbWV0aG9kOiBtZXRob2QgPT09ICdwb3N0JyB8fCBtZXRob2QgPT09ICdwb3N0SlNPTicgPyAnUE9TVCcgOiAnR0VUJyxcbiAgICBkYXRhLFxuICAgIHN1Y2Nlc3MsXG4gICAgZXJyb3IsXG4gICAgZGF0YVR5cGUsXG4gIH07XG4gIGlmIChtZXRob2QgPT09ICdwb3N0SlNPTicpIHtcbiAgICBVdGlscy5leHRlbmQocmVxdWVzdE9wdGlvbnMsIHtcbiAgICAgIGNvbnRlbnRUeXBlOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICBwcm9jZXNzRGF0YTogZmFsc2UsXG4gICAgICBjcm9zc0RvbWFpbjogdHJ1ZSxcbiAgICAgIGRhdGE6IHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJyA/IGRhdGEgOiBKU09OLnN0cmluZ2lmeShkYXRhKSxcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gUmVxdWVzdChyZXF1ZXN0T3B0aW9ucyk7XG59XG5SZXF1ZXN0LmdldCA9IGZ1bmN0aW9uIGdldCguLi5hcmdzKSB7XG4gIHJldHVybiBSZXF1ZXN0U2hvcnRjdXQoJ2dldCcsIC4uLmFyZ3MpO1xufTtcblJlcXVlc3QucG9zdCA9IGZ1bmN0aW9uIHBvc3QoLi4uYXJncykge1xuICByZXR1cm4gUmVxdWVzdFNob3J0Y3V0KCdwb3N0JywgLi4uYXJncyk7XG59O1xuUmVxdWVzdC5qc29uID0gZnVuY3Rpb24ganNvbiguLi5hcmdzKSB7XG4gIHJldHVybiBSZXF1ZXN0U2hvcnRjdXQoJ2pzb24nLCAuLi5hcmdzKTtcbn07XG5SZXF1ZXN0LmdldEpTT04gPSBSZXF1ZXN0Lmpzb247XG5SZXF1ZXN0LnBvc3RKU09OID0gZnVuY3Rpb24gcG9zdEpTT04oLi4uYXJncykge1xuICByZXR1cm4gUmVxdWVzdFNob3J0Y3V0KCdwb3N0SlNPTicsIC4uLmFyZ3MpO1xufTtcblJlcXVlc3Quc2V0dXAgPSBmdW5jdGlvbiBzZXR1cChvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zLnR5cGUgJiYgIW9wdGlvbnMubWV0aG9kKSB7XG4gICAgVXRpbHMuZXh0ZW5kKG9wdGlvbnMsIHsgbWV0aG9kOiBvcHRpb25zLnR5cGUgfSk7XG4gIH1cbiAgVXRpbHMuZXh0ZW5kKGdsb2JhbHMsIG9wdGlvbnMpO1xufTtcblxuY29uc3QgU3VwcG9ydCA9IChmdW5jdGlvbiBTdXBwb3J0KCkge1xuICBjb25zdCBwb3NpdGlvblN0aWNreSA9IChmdW5jdGlvbiBzdXBwb3J0UG9zaXRpb25TdGlja3koKSB7XG4gICAgbGV0IHN1cHBvcnQgPSBmYWxzZTtcbiAgICBjb25zdCBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAoJ3N0aWNreSAtd2Via2l0LXN0aWNreSAtbW96LXN0aWNreScpLnNwbGl0KCcgJykuZm9yRWFjaCgocHJvcCkgPT4ge1xuICAgICAgaWYgKHN1cHBvcnQpIHJldHVybjtcbiAgICAgIGRpdi5zdHlsZS5wb3NpdGlvbiA9IHByb3A7XG4gICAgICBpZiAoZGl2LnN0eWxlLnBvc2l0aW9uID09PSBwcm9wKSB7XG4gICAgICAgIHN1cHBvcnQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBzdXBwb3J0O1xuICB9KCkpO1xuXG4gIGNvbnN0IHRlc3REaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICByZXR1cm4ge1xuICAgIHBvc2l0aW9uU3RpY2t5LFxuICAgIHRvdWNoOiAoZnVuY3Rpb24gY2hlY2tUb3VjaCgpIHtcbiAgICAgIHJldHVybiAhISgoJ29udG91Y2hzdGFydCcgaW4gd2luZG93JDEpIHx8ICh3aW5kb3ckMS5Eb2N1bWVudFRvdWNoICYmIGRvY3VtZW50IGluc3RhbmNlb2Ygd2luZG93JDEuRG9jdW1lbnRUb3VjaCkpO1xuICAgIH0oKSksXG5cbiAgICBwb2ludGVyRXZlbnRzOiAhISh3aW5kb3ckMS5uYXZpZ2F0b3IucG9pbnRlckVuYWJsZWQgfHwgd2luZG93JDEuUG9pbnRlckV2ZW50KSxcbiAgICBwcmVmaXhlZFBvaW50ZXJFdmVudHM6ICEhd2luZG93JDEubmF2aWdhdG9yLm1zUG9pbnRlckVuYWJsZWQsXG5cbiAgICB0cmFuc2l0aW9uOiAoZnVuY3Rpb24gY2hlY2tUcmFuc2l0aW9uKCkge1xuICAgICAgY29uc3Qgc3R5bGUgPSB0ZXN0RGl2LnN0eWxlO1xuICAgICAgcmV0dXJuICgndHJhbnNpdGlvbicgaW4gc3R5bGUgfHwgJ3dlYmtpdFRyYW5zaXRpb24nIGluIHN0eWxlIHx8ICdNb3pUcmFuc2l0aW9uJyBpbiBzdHlsZSk7XG4gICAgfSgpKSxcbiAgICB0cmFuc2Zvcm1zM2Q6ICh3aW5kb3ckMS5Nb2Rlcm5penIgJiYgd2luZG93JDEuTW9kZXJuaXpyLmNzc3RyYW5zZm9ybXMzZCA9PT0gdHJ1ZSkgfHwgKGZ1bmN0aW9uIGNoZWNrVHJhbnNmb3JtczNkKCkge1xuICAgICAgY29uc3Qgc3R5bGUgPSB0ZXN0RGl2LnN0eWxlO1xuICAgICAgcmV0dXJuICgnd2Via2l0UGVyc3BlY3RpdmUnIGluIHN0eWxlIHx8ICdNb3pQZXJzcGVjdGl2ZScgaW4gc3R5bGUgfHwgJ09QZXJzcGVjdGl2ZScgaW4gc3R5bGUgfHwgJ01zUGVyc3BlY3RpdmUnIGluIHN0eWxlIHx8ICdwZXJzcGVjdGl2ZScgaW4gc3R5bGUpO1xuICAgIH0oKSksXG5cbiAgICBmbGV4Ym94OiAoZnVuY3Rpb24gY2hlY2tGbGV4Ym94KCkge1xuICAgICAgY29uc3QgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jykuc3R5bGU7XG4gICAgICBjb25zdCBzdHlsZXMgPSAoJ2FsaWduSXRlbXMgd2Via2l0QWxpZ25JdGVtcyB3ZWJraXRCb3hBbGlnbiBtc0ZsZXhBbGlnbiBtb3pCb3hBbGlnbiB3ZWJraXRGbGV4RGlyZWN0aW9uIG1zRmxleERpcmVjdGlvbiBtb3pCb3hEaXJlY3Rpb24gbW96Qm94T3JpZW50IHdlYmtpdEJveERpcmVjdGlvbiB3ZWJraXRCb3hPcmllbnQnKS5zcGxpdCgnICcpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKHN0eWxlc1tpXSBpbiBkaXYpIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0oKSksXG5cbiAgICBvYnNlcnZlcjogKGZ1bmN0aW9uIGNoZWNrT2JzZXJ2ZXIoKSB7XG4gICAgICByZXR1cm4gKCdNdXRhdGlvbk9ic2VydmVyJyBpbiB3aW5kb3ckMSB8fCAnV2Via2l0TXV0YXRpb25PYnNlcnZlcicgaW4gd2luZG93JDEpO1xuICAgIH0oKSksXG5cbiAgICBwYXNzaXZlTGlzdGVuZXI6IChmdW5jdGlvbiBjaGVja1Bhc3NpdmVMaXN0ZW5lcigpIHtcbiAgICAgIGxldCBzdXBwb3J0c1Bhc3NpdmUgPSBmYWxzZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IG9wdHMgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdwYXNzaXZlJywge1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgIHN1cHBvcnRzUGFzc2l2ZSA9IHRydWU7XG4gICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIHdpbmRvdyQxLmFkZEV2ZW50TGlzdGVuZXIoJ3Rlc3RQYXNzaXZlTGlzdGVuZXInLCBudWxsLCBvcHRzKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gTm8gc3VwcG9ydFxuICAgICAgfVxuICAgICAgcmV0dXJuIHN1cHBvcnRzUGFzc2l2ZTtcbiAgICB9KCkpLFxuXG4gICAgZ2VzdHVyZXM6IChmdW5jdGlvbiBjaGVja0dlc3R1cmVzKCkge1xuICAgICAgcmV0dXJuICdvbmdlc3R1cmVzdGFydCcgaW4gd2luZG93JDE7XG4gICAgfSgpKSxcbiAgfTtcbn0oKSk7XG5cbnZhciBEZXZpY2VNb2R1bGUgPSB7XG4gIG5hbWU6ICdkZXZpY2UnLFxuICBwcm90bzoge1xuICAgIGRldmljZTogRGV2aWNlLFxuICB9LFxuICBzdGF0aWM6IHtcbiAgICBkZXZpY2U6IERldmljZSxcbiAgfSxcbiAgb246IHtcbiAgICBpbml0KCkge1xuICAgICAgY29uc3QgY2xhc3NOYW1lcyA9IFtdO1xuICAgICAgY29uc3QgaHRtbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2h0bWwnKTtcbiAgICAgIGlmICghaHRtbCkgcmV0dXJuO1xuICAgICAgLy8gUGl4ZWwgUmF0aW9cbiAgICAgIGNsYXNzTmFtZXMucHVzaChgZGV2aWNlLXBpeGVsLXJhdGlvLSR7TWF0aC5mbG9vcihEZXZpY2UucGl4ZWxSYXRpbyl9YCk7XG4gICAgICBpZiAoRGV2aWNlLnBpeGVsUmF0aW8gPj0gMikge1xuICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2RldmljZS1yZXRpbmEnKTtcbiAgICAgIH1cbiAgICAgIC8vIE9TIGNsYXNzZXNcbiAgICAgIGlmIChEZXZpY2Uub3MpIHtcbiAgICAgICAgY2xhc3NOYW1lcy5wdXNoKFxuICAgICAgICAgIGBkZXZpY2UtJHtEZXZpY2Uub3N9YCxcbiAgICAgICAgICBgZGV2aWNlLSR7RGV2aWNlLm9zfS0ke0RldmljZS5vc1ZlcnNpb24uc3BsaXQoJy4nKVswXX1gLFxuICAgICAgICAgIGBkZXZpY2UtJHtEZXZpY2Uub3N9LSR7RGV2aWNlLm9zVmVyc2lvbi5yZXBsYWNlKC9cXC4vZywgJy0nKX1gXG4gICAgICAgICk7XG4gICAgICAgIGlmIChEZXZpY2Uub3MgPT09ICdpb3MnKSB7XG4gICAgICAgICAgY29uc3QgbWFqb3IgPSBwYXJzZUludChEZXZpY2Uub3NWZXJzaW9uLnNwbGl0KCcuJylbMF0sIDEwKTtcbiAgICAgICAgICBmb3IgKGxldCBpID0gbWFqb3IgLSAxOyBpID49IDY7IGkgLT0gMSkge1xuICAgICAgICAgICAgY2xhc3NOYW1lcy5wdXNoKGBkZXZpY2UtaW9zLWd0LSR7aX1gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKERldmljZS5pcGhvbmVYKSB7XG4gICAgICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2RldmljZS1pcGhvbmUteCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChEZXZpY2UuZGVza3RvcCkge1xuICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2RldmljZS1kZXNrdG9wJyk7XG4gICAgICB9XG4gICAgICAvLyBTdGF0dXMgYmFyIGNsYXNzZXNcbiAgICAgIGlmIChEZXZpY2Uuc3RhdHVzYmFyKSB7XG4gICAgICAgIGNsYXNzTmFtZXMucHVzaCgnd2l0aC1zdGF0dXNiYXInKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGh0bWwuY2xhc3NMaXN0LnJlbW92ZSgnd2l0aC1zdGF0dXNiYXInKTtcbiAgICAgIH1cblxuICAgICAgLy8gQWRkIGh0bWwgY2xhc3Nlc1xuICAgICAgY2xhc3NOYW1lcy5mb3JFYWNoKChjbGFzc05hbWUpID0+IHtcbiAgICAgICAgaHRtbC5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSk7XG4gICAgICB9KTtcbiAgICB9LFxuICB9LFxufTtcblxudmFyIFN1cHBvcnRNb2R1bGUgPSB7XG4gIG5hbWU6ICdzdXBwb3J0JyxcbiAgcHJvdG86IHtcbiAgICBzdXBwb3J0OiBTdXBwb3J0LFxuICB9LFxuICBzdGF0aWM6IHtcbiAgICBzdXBwb3J0OiBTdXBwb3J0LFxuICB9LFxuICBvbjoge1xuICAgIGluaXQoKSB7XG4gICAgICBjb25zdCBodG1sID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignaHRtbCcpO1xuICAgICAgaWYgKCFodG1sKSByZXR1cm47XG4gICAgICBjb25zdCBjbGFzc05hbWVzID0gW107XG4gICAgICBpZiAoU3VwcG9ydC5wb3NpdGlvblN0aWNreSkge1xuICAgICAgICBjbGFzc05hbWVzLnB1c2goJ3N1cHBvcnQtcG9zaXRpb24tc3RpY2t5Jyk7XG4gICAgICB9XG4gICAgICAvLyBBZGQgaHRtbCBjbGFzc2VzXG4gICAgICBjbGFzc05hbWVzLmZvckVhY2goKGNsYXNzTmFtZSkgPT4ge1xuICAgICAgICBodG1sLmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gIH0sXG59O1xuXG52YXIgVXRpbHNNb2R1bGUgPSB7XG4gIG5hbWU6ICd1dGlscycsXG4gIHByb3RvOiB7XG4gICAgdXRpbHM6IFV0aWxzLFxuICB9LFxuICBzdGF0aWM6IHtcbiAgICB1dGlsczogVXRpbHMsXG4gIH0sXG59O1xuXG52YXIgUmVzaXplTW9kdWxlID0ge1xuICBuYW1lOiAncmVzaXplJyxcbiAgaW5zdGFuY2U6IHtcbiAgICBnZXRTaXplKCkge1xuICAgICAgY29uc3QgYXBwID0gdGhpcztcbiAgICAgIGlmICghYXBwLnJvb3RbMF0pIHJldHVybiB7IHdpZHRoOiAwLCBoZWlnaHQ6IDAsIGxlZnQ6IDAsIHRvcDogMCB9O1xuICAgICAgY29uc3Qgb2Zmc2V0ID0gYXBwLnJvb3Qub2Zmc2V0KCk7XG4gICAgICBjb25zdCBbd2lkdGgsIGhlaWdodCwgbGVmdCwgdG9wXSA9IFthcHAucm9vdFswXS5vZmZzZXRXaWR0aCwgYXBwLnJvb3RbMF0ub2Zmc2V0SGVpZ2h0LCBvZmZzZXQubGVmdCwgb2Zmc2V0LnRvcF07XG4gICAgICBhcHAud2lkdGggPSB3aWR0aDtcbiAgICAgIGFwcC5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICBhcHAubGVmdCA9IGxlZnQ7XG4gICAgICBhcHAudG9wID0gdG9wO1xuICAgICAgcmV0dXJuIHsgd2lkdGgsIGhlaWdodCwgbGVmdCwgdG9wIH07XG4gICAgfSxcbiAgfSxcbiAgb246IHtcbiAgICBpbml0KCkge1xuICAgICAgY29uc3QgYXBwID0gdGhpcztcblxuICAgICAgLy8gR2V0IFNpemVcbiAgICAgIGFwcC5nZXRTaXplKCk7XG5cbiAgICAgIC8vIEVtaXQgcmVzaXplXG4gICAgICB3aW5kb3ckMS5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCAoKSA9PiB7XG4gICAgICAgIGFwcC5lbWl0KCdyZXNpemUnKTtcbiAgICAgIH0sIGZhbHNlKTtcblxuICAgICAgLy8gRW1pdCBvcmllbnRhdGlvbmNoYW5nZVxuICAgICAgd2luZG93JDEuYWRkRXZlbnRMaXN0ZW5lcignb3JpZW50YXRpb25jaGFuZ2UnLCAoKSA9PiB7XG4gICAgICAgIGFwcC5lbWl0KCdvcmllbnRhdGlvbmNoYW5nZScpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBvcmllbnRhdGlvbmNoYW5nZSgpIHtcbiAgICAgIGNvbnN0IGFwcCA9IHRoaXM7XG4gICAgICBpZiAoYXBwLmRldmljZSAmJiBhcHAuZGV2aWNlLm1pbmltYWxVaSkge1xuICAgICAgICBpZiAod2luZG93JDEub3JpZW50YXRpb24gPT09IDkwIHx8IHdpbmRvdyQxLm9yaWVudGF0aW9uID09PSAtOTApIHtcbiAgICAgICAgICBkb2N1bWVudC5ib2R5LnNjcm9sbFRvcCA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIEZpeCBpUGFkIHdlaXJkIGJvZHkgc2Nyb2xsXG4gICAgICBpZiAoYXBwLmRldmljZS5pcGFkKSB7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuc2Nyb2xsTGVmdCA9IDA7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIGRvY3VtZW50LmJvZHkuc2Nyb2xsTGVmdCA9IDA7XG4gICAgICAgIH0sIDApO1xuICAgICAgfVxuICAgIH0sXG4gICAgcmVzaXplKCkge1xuICAgICAgY29uc3QgYXBwID0gdGhpcztcbiAgICAgIGFwcC5nZXRTaXplKCk7XG4gICAgfSxcbiAgfSxcbn07XG5cbi8qIGVzbGludCBuby1wYXJhbS1yZWFzc2lnbjogXCJvZmZcIiAqL1xuXG52YXIgUmVxdWVzdE1vZHVsZSA9IHtcbiAgbmFtZTogJ3JlcXVlc3QnLFxuICBwcm90bzoge1xuICAgIHJlcXVlc3Q6IFJlcXVlc3QsXG4gIH0sXG4gIHN0YXRpYzoge1xuICAgIHJlcXVlc3Q6IFJlcXVlc3QsXG4gIH0sXG59O1xuXG5mdW5jdGlvbiBpbml0VG91Y2goKSB7XG4gIGNvbnN0IGFwcCA9IHRoaXM7XG4gIGNvbnN0IHBhcmFtcyA9IGFwcC5wYXJhbXMudG91Y2g7XG4gIGNvbnN0IHVzZVJpcHBsZSA9IGFwcC50aGVtZSA9PT0gJ21kJyAmJiBwYXJhbXMubWF0ZXJpYWxSaXBwbGU7XG5cbiAgaWYgKERldmljZS5pb3MgJiYgRGV2aWNlLndlYlZpZXcpIHtcbiAgICAvLyBTdHJhbmdlIGhhY2sgcmVxdWlyZWQgZm9yIGlPUyA4IHdlYnZpZXcgdG8gd29yayBvbiBpbnB1dHNcbiAgICB3aW5kb3ckMS5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgKCkgPT4ge30pO1xuICB9XG5cbiAgbGV0IHRvdWNoU3RhcnRYO1xuICBsZXQgdG91Y2hTdGFydFk7XG4gIGxldCB0b3VjaFN0YXJ0VGltZTtcbiAgbGV0IHRhcmdldEVsZW1lbnQ7XG4gIGxldCB0cmFja0NsaWNrO1xuICBsZXQgYWN0aXZlU2VsZWN0aW9uO1xuICBsZXQgc2Nyb2xsUGFyZW50O1xuICBsZXQgbGFzdENsaWNrVGltZTtcbiAgbGV0IGlzTW92ZWQ7XG4gIGxldCB0YXBIb2xkRmlyZWQ7XG4gIGxldCB0YXBIb2xkVGltZW91dDtcblxuICBsZXQgYWN0aXZhYmxlRWxlbWVudDtcbiAgbGV0IGFjdGl2ZVRpbWVvdXQ7XG5cbiAgbGV0IG5lZWRzRmFzdENsaWNrO1xuICBsZXQgbmVlZHNGYXN0Q2xpY2tUaW1lT3V0O1xuXG4gIGxldCByaXBwbGVXYXZlO1xuICBsZXQgcmlwcGxlVGFyZ2V0O1xuICBsZXQgcmlwcGxlVGltZW91dDtcblxuICBmdW5jdGlvbiBmaW5kQWN0aXZhYmxlRWxlbWVudChlbCkge1xuICAgIGNvbnN0IHRhcmdldCA9ICQoZWwpO1xuICAgIGNvbnN0IHBhcmVudHMgPSB0YXJnZXQucGFyZW50cyhwYXJhbXMuYWN0aXZlU3RhdGVFbGVtZW50cyk7XG4gICAgbGV0IGFjdGl2YWJsZTtcbiAgICBpZiAodGFyZ2V0LmlzKHBhcmFtcy5hY3RpdmVTdGF0ZUVsZW1lbnRzKSkge1xuICAgICAgYWN0aXZhYmxlID0gdGFyZ2V0O1xuICAgIH1cbiAgICBpZiAocGFyZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICBhY3RpdmFibGUgPSBhY3RpdmFibGUgPyBhY3RpdmFibGUuYWRkKHBhcmVudHMpIDogcGFyZW50cztcbiAgICB9XG4gICAgcmV0dXJuIGFjdGl2YWJsZSB8fCB0YXJnZXQ7XG4gIH1cblxuICBmdW5jdGlvbiBpc0luc2lkZVNjcm9sbGFibGVWaWV3KGVsKSB7XG4gICAgY29uc3QgcGFnZUNvbnRlbnQgPSBlbC5wYXJlbnRzKCcucGFnZS1jb250ZW50LCAucGFuZWwnKTtcblxuICAgIGlmIChwYWdlQ29udGVudC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBUaGlzIGV2ZW50IGhhbmRsZXIgY292ZXJzIHRoZSBcInRhcCB0byBzdG9wIHNjcm9sbGluZ1wiLlxuICAgIGlmIChwYWdlQ29udGVudC5wcm9wKCdzY3JvbGxIYW5kbGVyU2V0JykgIT09ICd5ZXMnKSB7XG4gICAgICBwYWdlQ29udGVudC5vbignc2Nyb2xsJywgKCkgPT4ge1xuICAgICAgICBjbGVhclRpbWVvdXQoYWN0aXZlVGltZW91dCk7XG4gICAgICAgIGNsZWFyVGltZW91dChyaXBwbGVUaW1lb3V0KTtcbiAgICAgIH0pO1xuICAgICAgcGFnZUNvbnRlbnQucHJvcCgnc2Nyb2xsSGFuZGxlclNldCcsICd5ZXMnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBmdW5jdGlvbiBhZGRBY3RpdmUoKSB7XG4gICAgaWYgKCFhY3RpdmFibGVFbGVtZW50KSByZXR1cm47XG4gICAgYWN0aXZhYmxlRWxlbWVudC5hZGRDbGFzcygnYWN0aXZlLXN0YXRlJyk7XG4gIH1cbiAgZnVuY3Rpb24gcmVtb3ZlQWN0aXZlKCkge1xuICAgIGlmICghYWN0aXZhYmxlRWxlbWVudCkgcmV0dXJuO1xuICAgIGFjdGl2YWJsZUVsZW1lbnQucmVtb3ZlQ2xhc3MoJ2FjdGl2ZS1zdGF0ZScpO1xuICAgIGFjdGl2YWJsZUVsZW1lbnQgPSBudWxsO1xuICB9XG4gIGZ1bmN0aW9uIGlzRm9ybUVsZW1lbnQoZWwpIHtcbiAgICBjb25zdCBub2RlcyA9ICgnaW5wdXQgc2VsZWN0IHRleHRhcmVhIGxhYmVsJykuc3BsaXQoJyAnKTtcbiAgICBpZiAoZWwubm9kZU5hbWUgJiYgbm9kZXMuaW5kZXhPZihlbC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKSA+PSAwKSByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZnVuY3Rpb24gYW5kcm9pZE5lZWRzQmx1cihlbCkge1xuICAgIGNvbnN0IG5vQmx1ciA9ICgnYnV0dG9uIGlucHV0IHRleHRhcmVhIHNlbGVjdCcpLnNwbGl0KCcgJyk7XG4gICAgaWYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgJiYgZWwgIT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgJiYgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAhPT0gZG9jdW1lbnQuYm9keSkge1xuICAgICAgaWYgKG5vQmx1ci5pbmRleE9mKGVsLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpID49IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmdW5jdGlvbiB0YXJnZXROZWVkc0Zhc3RDbGljayhlbCkge1xuICAgIC8qXG4gICAgaWYgKFxuICAgICAgRGV2aWNlLmlvc1xuICAgICAgJiZcbiAgICAgIChcbiAgICAgICAgRGV2aWNlLm9zVmVyc2lvbi5zcGxpdCgnLicpWzBdID4gOVxuICAgICAgICB8fFxuICAgICAgICAoRGV2aWNlLm9zVmVyc2lvbi5zcGxpdCgnLicpWzBdICogMSA9PT0gOSAmJiBEZXZpY2Uub3NWZXJzaW9uLnNwbGl0KCcuJylbMV0gPj0gMSlcbiAgICAgIClcbiAgICApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgKi9cbiAgICBjb25zdCAkZWwgPSAkKGVsKTtcbiAgICBpZiAoZWwubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2lucHV0JyAmJiAoZWwudHlwZSA9PT0gJ2ZpbGUnIHx8IGVsLnR5cGUgPT09ICdyYW5nZScpKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGVsLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdzZWxlY3QnICYmIERldmljZS5hbmRyb2lkKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKCRlbC5oYXNDbGFzcygnbm8tZmFzdGNsaWNrJykgfHwgJGVsLnBhcmVudHMoJy5uby1mYXN0Y2xpY2snKS5sZW5ndGggPiAwKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHBhcmFtcy5mYXN0Q2xpY2tzRXhjbHVkZSAmJiAkZWwuaXMocGFyYW1zLmZhc3RDbGlja3NFeGNsdWRlKSkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGZ1bmN0aW9uIHRhcmdldE5lZWRzRm9jdXMoZWwpIHtcbiAgICBpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gZWwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgdGFnID0gZWwubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICBjb25zdCBza2lwSW5wdXRzID0gKCdidXR0b24gY2hlY2tib3ggZmlsZSBpbWFnZSByYWRpbyBzdWJtaXQnKS5zcGxpdCgnICcpO1xuICAgIGlmIChlbC5kaXNhYmxlZCB8fCBlbC5yZWFkT25seSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh0YWcgPT09ICd0ZXh0YXJlYScpIHJldHVybiB0cnVlO1xuICAgIGlmICh0YWcgPT09ICdzZWxlY3QnKSB7XG4gICAgICBpZiAoRGV2aWNlLmFuZHJvaWQpIHJldHVybiBmYWxzZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAodGFnID09PSAnaW5wdXQnICYmIHNraXBJbnB1dHMuaW5kZXhPZihlbC50eXBlKSA8IDApIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmdW5jdGlvbiB0YXJnZXROZWVkc1ByZXZlbnQoZWwpIHtcbiAgICBjb25zdCAkZWwgPSAkKGVsKTtcbiAgICBsZXQgcHJldmVudCA9IHRydWU7XG4gICAgaWYgKCRlbC5pcygnbGFiZWwnKSB8fCAkZWwucGFyZW50cygnbGFiZWwnKS5sZW5ndGggPiAwKSB7XG4gICAgICBpZiAoRGV2aWNlLmFuZHJvaWQpIHtcbiAgICAgICAgcHJldmVudCA9IGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChEZXZpY2UuaW9zICYmICRlbC5pcygnaW5wdXQnKSkge1xuICAgICAgICBwcmV2ZW50ID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBwcmV2ZW50ID0gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBwcmV2ZW50O1xuICB9XG5cbiAgLy8gUmlwcGxlIGhhbmRsZXJzXG4gIGZ1bmN0aW9uIGZpbmRSaXBwbGVFbGVtZW50KGVsKSB7XG4gICAgY29uc3QgcmlwcGxlRWxlbWVudHMgPSBwYXJhbXMubWF0ZXJpYWxSaXBwbGVFbGVtZW50cztcbiAgICBjb25zdCAkZWwgPSAkKGVsKTtcbiAgICBpZiAoJGVsLmlzKHJpcHBsZUVsZW1lbnRzKSkge1xuICAgICAgaWYgKCRlbC5oYXNDbGFzcygnbm8tcmlwcGxlJykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuICRlbDtcbiAgICB9IGVsc2UgaWYgKCRlbC5wYXJlbnRzKHJpcHBsZUVsZW1lbnRzKS5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCByaXBwbGVQYXJlbnQgPSAkZWwucGFyZW50cyhyaXBwbGVFbGVtZW50cykuZXEoMCk7XG4gICAgICBpZiAocmlwcGxlUGFyZW50Lmhhc0NsYXNzKCduby1yaXBwbGUnKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmlwcGxlUGFyZW50O1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZnVuY3Rpb24gY3JlYXRlUmlwcGxlKCRlbCwgeCwgeSkge1xuICAgIGlmICghJGVsKSByZXR1cm47XG4gICAgcmlwcGxlV2F2ZSA9IGFwcC50b3VjaFJpcHBsZS5jcmVhdGUoJGVsLCB4LCB5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZVJpcHBsZSgpIHtcbiAgICBpZiAoIXJpcHBsZVdhdmUpIHJldHVybjtcbiAgICByaXBwbGVXYXZlLnJlbW92ZSgpO1xuICAgIHJpcHBsZVdhdmUgPSB1bmRlZmluZWQ7XG4gICAgcmlwcGxlVGFyZ2V0ID0gdW5kZWZpbmVkO1xuICB9XG4gIGZ1bmN0aW9uIHJpcHBsZVRvdWNoU3RhcnQoZWwpIHtcbiAgICByaXBwbGVUYXJnZXQgPSBmaW5kUmlwcGxlRWxlbWVudChlbCk7XG4gICAgaWYgKCFyaXBwbGVUYXJnZXQgfHwgcmlwcGxlVGFyZ2V0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmlwcGxlVGFyZ2V0ID0gdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWlzSW5zaWRlU2Nyb2xsYWJsZVZpZXcocmlwcGxlVGFyZ2V0KSkge1xuICAgICAgY3JlYXRlUmlwcGxlKHJpcHBsZVRhcmdldCwgdG91Y2hTdGFydFgsIHRvdWNoU3RhcnRZKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmlwcGxlVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBjcmVhdGVSaXBwbGUocmlwcGxlVGFyZ2V0LCB0b3VjaFN0YXJ0WCwgdG91Y2hTdGFydFkpO1xuICAgICAgfSwgODApO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiByaXBwbGVUb3VjaE1vdmUoKSB7XG4gICAgY2xlYXJUaW1lb3V0KHJpcHBsZVRpbWVvdXQpO1xuICAgIHJlbW92ZVJpcHBsZSgpO1xuICB9XG4gIGZ1bmN0aW9uIHJpcHBsZVRvdWNoRW5kKCkge1xuICAgIGlmIChyaXBwbGVXYXZlKSB7XG4gICAgICByZW1vdmVSaXBwbGUoKTtcbiAgICB9IGVsc2UgaWYgKHJpcHBsZVRhcmdldCAmJiAhaXNNb3ZlZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHJpcHBsZVRpbWVvdXQpO1xuICAgICAgY3JlYXRlUmlwcGxlKHJpcHBsZVRhcmdldCwgdG91Y2hTdGFydFgsIHRvdWNoU3RhcnRZKTtcbiAgICAgIHNldFRpbWVvdXQocmVtb3ZlUmlwcGxlLCAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVtb3ZlUmlwcGxlKCk7XG4gICAgfVxuICB9XG5cbiAgLy8gTW91c2UgSGFuZGxlcnNcbiAgZnVuY3Rpb24gaGFuZGxlTW91c2VEb3duKGUpIHtcbiAgICBmaW5kQWN0aXZhYmxlRWxlbWVudChlLnRhcmdldCkuYWRkQ2xhc3MoJ2FjdGl2ZS1zdGF0ZScpO1xuICAgIGlmICgnd2hpY2gnIGluIGUgJiYgZS53aGljaCA9PT0gMykge1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICQoJy5hY3RpdmUtc3RhdGUnKS5yZW1vdmVDbGFzcygnYWN0aXZlLXN0YXRlJyk7XG4gICAgICB9LCAwKTtcbiAgICB9XG4gICAgaWYgKHVzZVJpcHBsZSkge1xuICAgICAgdG91Y2hTdGFydFggPSBlLnBhZ2VYO1xuICAgICAgdG91Y2hTdGFydFkgPSBlLnBhZ2VZO1xuICAgICAgcmlwcGxlVG91Y2hTdGFydChlLnRhcmdldCwgZS5wYWdlWCwgZS5wYWdlWSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGhhbmRsZU1vdXNlTW92ZSgpIHtcbiAgICAkKCcuYWN0aXZlLXN0YXRlJykucmVtb3ZlQ2xhc3MoJ2FjdGl2ZS1zdGF0ZScpO1xuICAgIGlmICh1c2VSaXBwbGUpIHtcbiAgICAgIHJpcHBsZVRvdWNoTW92ZSgpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBoYW5kbGVNb3VzZVVwKCkge1xuICAgICQoJy5hY3RpdmUtc3RhdGUnKS5yZW1vdmVDbGFzcygnYWN0aXZlLXN0YXRlJyk7XG4gICAgaWYgKHVzZVJpcHBsZSkge1xuICAgICAgcmlwcGxlVG91Y2hFbmQoKTtcbiAgICB9XG4gIH1cblxuICAvLyBTZW5kIENsaWNrXG4gIGZ1bmN0aW9uIHNlbmRDbGljayhlKSB7XG4gICAgY29uc3QgdG91Y2ggPSBlLmNoYW5nZWRUb3VjaGVzWzBdO1xuICAgIGNvbnN0IGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdNb3VzZUV2ZW50cycpO1xuICAgIGxldCBldmVudFR5cGUgPSAnY2xpY2snO1xuICAgIGlmIChEZXZpY2UuYW5kcm9pZCAmJiB0YXJnZXRFbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdzZWxlY3QnKSB7XG4gICAgICBldmVudFR5cGUgPSAnbW91c2Vkb3duJztcbiAgICB9XG4gICAgZXZ0LmluaXRNb3VzZUV2ZW50KGV2ZW50VHlwZSwgdHJ1ZSwgdHJ1ZSwgd2luZG93JDEsIDEsIHRvdWNoLnNjcmVlblgsIHRvdWNoLnNjcmVlblksIHRvdWNoLmNsaWVudFgsIHRvdWNoLmNsaWVudFksIGZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCAwLCBudWxsKTtcbiAgICBldnQuZm9yd2FyZGVkVG91Y2hFdmVudCA9IHRydWU7XG5cbiAgICBpZiAoYXBwLmRldmljZS5pb3MgJiYgd2luZG93JDEubmF2aWdhdG9yLnN0YW5kYWxvbmUpIHtcbiAgICAgIC8vIEZpeCB0aGUgaXNzdWUgaGFwcGVucyBpbiBpT1MgaG9tZSBzY3JlZW4gYXBwcyB3aGVyZSB0aGUgd3JvbmcgZWxlbWVudCBpcyBzZWxlY3RlZCBkdXJpbmcgYSBtb21lbnR1bSBzY3JvbGwuXG4gICAgICAvLyBVcG9uIHRhcHBpbmcsIHdlIGdpdmUgdGhlIHNjcm9sbGluZyB0aW1lIHRvIHN0b3AsIHRoZW4gd2UgZ3JhYiB0aGUgZWxlbWVudCBiYXNlZCB3aGVyZSB0aGUgdXNlciB0YXBwZWQuXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGFyZ2V0RWxlbWVudCA9IGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQoZS5jaGFuZ2VkVG91Y2hlc1swXS5jbGllbnRYLCBlLmNoYW5nZWRUb3VjaGVzWzBdLmNsaWVudFkpO1xuICAgICAgICB0YXJnZXRFbGVtZW50LmRpc3BhdGNoRXZlbnQoZXZ0KTtcbiAgICAgIH0sIDEwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGFyZ2V0RWxlbWVudC5kaXNwYXRjaEV2ZW50KGV2dCk7XG4gICAgfVxuICB9XG5cbiAgLy8gVG91Y2ggSGFuZGxlcnNcbiAgZnVuY3Rpb24gaGFuZGxlVG91Y2hTdGFydChlKSB7XG4gICAgaXNNb3ZlZCA9IGZhbHNlO1xuICAgIHRhcEhvbGRGaXJlZCA9IGZhbHNlO1xuICAgIGlmIChlLnRhcmdldFRvdWNoZXMubGVuZ3RoID4gMSkge1xuICAgICAgaWYgKGFjdGl2YWJsZUVsZW1lbnQpIHJlbW92ZUFjdGl2ZSgpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChlLnRvdWNoZXMubGVuZ3RoID4gMSAmJiBhY3RpdmFibGVFbGVtZW50KSB7XG4gICAgICByZW1vdmVBY3RpdmUoKTtcbiAgICB9XG4gICAgaWYgKHBhcmFtcy50YXBIb2xkKSB7XG4gICAgICBpZiAodGFwSG9sZFRpbWVvdXQpIGNsZWFyVGltZW91dCh0YXBIb2xkVGltZW91dCk7XG4gICAgICB0YXBIb2xkVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpZiAoZSAmJiBlLnRvdWNoZXMgJiYgZS50b3VjaGVzLmxlbmd0aCA+IDEpIHJldHVybjtcbiAgICAgICAgdGFwSG9sZEZpcmVkID0gdHJ1ZTtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAkKGUudGFyZ2V0KS50cmlnZ2VyKCd0YXBob2xkJyk7XG4gICAgICB9LCBwYXJhbXMudGFwSG9sZERlbGF5KTtcbiAgICB9XG4gICAgaWYgKG5lZWRzRmFzdENsaWNrVGltZU91dCkgY2xlYXJUaW1lb3V0KG5lZWRzRmFzdENsaWNrVGltZU91dCk7XG4gICAgbmVlZHNGYXN0Q2xpY2sgPSB0YXJnZXROZWVkc0Zhc3RDbGljayhlLnRhcmdldCk7XG5cbiAgICBpZiAoIW5lZWRzRmFzdENsaWNrKSB7XG4gICAgICB0cmFja0NsaWNrID0gZmFsc2U7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKERldmljZS5pb3MgfHwgKERldmljZS5hbmRyb2lkICYmICdnZXRTZWxlY3Rpb24nIGluIHdpbmRvdyQxKSkge1xuICAgICAgY29uc3Qgc2VsZWN0aW9uID0gd2luZG93JDEuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICBpZiAoXG4gICAgICAgIHNlbGVjdGlvbi5yYW5nZUNvdW50ICYmXG4gICAgICAgIHNlbGVjdGlvbi5mb2N1c05vZGUgIT09IGRvY3VtZW50LmJvZHkgJiZcbiAgICAgICAgKCFzZWxlY3Rpb24uaXNDb2xsYXBzZWQgfHwgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gc2VsZWN0aW9uLmZvY3VzTm9kZSlcbiAgICAgICkge1xuICAgICAgICBhY3RpdmVTZWxlY3Rpb24gPSB0cnVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgYWN0aXZlU2VsZWN0aW9uID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChEZXZpY2UuYW5kcm9pZCkge1xuICAgICAgaWYgKGFuZHJvaWROZWVkc0JsdXIoZS50YXJnZXQpKSB7XG4gICAgICAgIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQuYmx1cigpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRyYWNrQ2xpY2sgPSB0cnVlO1xuICAgIHRhcmdldEVsZW1lbnQgPSBlLnRhcmdldDtcbiAgICB0b3VjaFN0YXJ0VGltZSA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG4gICAgdG91Y2hTdGFydFggPSBlLnRhcmdldFRvdWNoZXNbMF0ucGFnZVg7XG4gICAgdG91Y2hTdGFydFkgPSBlLnRhcmdldFRvdWNoZXNbMF0ucGFnZVk7XG5cbiAgICAvLyBEZXRlY3Qgc2Nyb2xsIHBhcmVudFxuICAgIGlmIChEZXZpY2UuaW9zKSB7XG4gICAgICBzY3JvbGxQYXJlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAkKHRhcmdldEVsZW1lbnQpLnBhcmVudHMoKS5lYWNoKCgpID0+IHtcbiAgICAgICAgY29uc3QgcGFyZW50ID0gdGhpcztcbiAgICAgICAgaWYgKHBhcmVudC5zY3JvbGxIZWlnaHQgPiBwYXJlbnQub2Zmc2V0SGVpZ2h0ICYmICFzY3JvbGxQYXJlbnQpIHtcbiAgICAgICAgICBzY3JvbGxQYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgICAgc2Nyb2xsUGFyZW50LmY3U2Nyb2xsVG9wID0gc2Nyb2xsUGFyZW50LnNjcm9sbFRvcDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICgodG91Y2hTdGFydFRpbWUgLSBsYXN0Q2xpY2tUaW1lKSA8IHBhcmFtcy5mYXN0Q2xpY2tzRGVsYXlCZXR3ZWVuQ2xpY2tzKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuXG4gICAgaWYgKHBhcmFtcy5hY3RpdmVTdGF0ZSkge1xuICAgICAgYWN0aXZhYmxlRWxlbWVudCA9IGZpbmRBY3RpdmFibGVFbGVtZW50KHRhcmdldEVsZW1lbnQpO1xuICAgICAgLy8gSWYgaXQncyBpbnNpZGUgYSBzY3JvbGxhYmxlIHZpZXcsIHdlIGRvbid0IHRyaWdnZXIgYWN0aXZlLXN0YXRlIHlldCxcbiAgICAgIC8vIGJlY2F1c2UgaXQgY2FuIGJlIGEgc2Nyb2xsIGluc3RlYWQuIEJhc2VkIG9uIHRoZSBsaW5rOlxuICAgICAgLy8gaHR0cDovL2xhYm5vdGUuYmVlZGVzay5jb20vY2xpY2stc2Nyb2xsLWFuZC1wc2V1ZG8tYWN0aXZlLW9uLW1vYmlsZS13ZWJrXG4gICAgICBpZiAoIWlzSW5zaWRlU2Nyb2xsYWJsZVZpZXcoYWN0aXZhYmxlRWxlbWVudCkpIHtcbiAgICAgICAgYWRkQWN0aXZlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhY3RpdmVUaW1lb3V0ID0gc2V0VGltZW91dChhZGRBY3RpdmUsIDgwKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHVzZVJpcHBsZSkge1xuICAgICAgcmlwcGxlVG91Y2hTdGFydCh0YXJnZXRFbGVtZW50LCB0b3VjaFN0YXJ0WCwgdG91Y2hTdGFydFkpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBmdW5jdGlvbiBoYW5kbGVUb3VjaE1vdmUoZSkge1xuICAgIGlmICghdHJhY2tDbGljaykgcmV0dXJuO1xuICAgIGNvbnN0IGRpc3RhbmNlID0gcGFyYW1zLmZhc3RDbGlja3NEaXN0YW5jZVRocmVzaG9sZDtcbiAgICBpZiAoZGlzdGFuY2UpIHtcbiAgICAgIGNvbnN0IHBhZ2VYID0gZS50YXJnZXRUb3VjaGVzWzBdLnBhZ2VYO1xuICAgICAgY29uc3QgcGFnZVkgPSBlLnRhcmdldFRvdWNoZXNbMF0ucGFnZVk7XG4gICAgICBpZiAoTWF0aC5hYnMocGFnZVggLSB0b3VjaFN0YXJ0WCkgPiBkaXN0YW5jZSB8fCBNYXRoLmFicyhwYWdlWSAtIHRvdWNoU3RhcnRZKSA+IGRpc3RhbmNlKSB7XG4gICAgICAgIGlzTW92ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpc01vdmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGlzTW92ZWQpIHtcbiAgICAgIHRyYWNrQ2xpY2sgPSBmYWxzZTtcbiAgICAgIHRhcmdldEVsZW1lbnQgPSBudWxsO1xuICAgICAgaXNNb3ZlZCA9IHRydWU7XG4gICAgICBpZiAocGFyYW1zLnRhcEhvbGQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRhcEhvbGRUaW1lb3V0KTtcbiAgICAgIH1cbiAgICAgIGlmIChwYXJhbXMuYWN0aXZlU3RhdGUpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KGFjdGl2ZVRpbWVvdXQpO1xuICAgICAgICByZW1vdmVBY3RpdmUoKTtcbiAgICAgIH1cbiAgICAgIGlmICh1c2VSaXBwbGUpIHtcbiAgICAgICAgcmlwcGxlVG91Y2hNb3ZlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGhhbmRsZVRvdWNoRW5kKGUpIHtcbiAgICBjbGVhclRpbWVvdXQoYWN0aXZlVGltZW91dCk7XG4gICAgY2xlYXJUaW1lb3V0KHRhcEhvbGRUaW1lb3V0KTtcblxuICAgIGNvbnN0IHRvdWNoRW5kVGltZSA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG5cbiAgICBpZiAoIXRyYWNrQ2xpY2spIHtcbiAgICAgIGlmICghYWN0aXZlU2VsZWN0aW9uICYmIG5lZWRzRmFzdENsaWNrKSB7XG4gICAgICAgIGlmICghKERldmljZS5hbmRyb2lkICYmICFlLmNhbmNlbGFibGUpICYmIGUuY2FuY2VsYWJsZSkge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IGUudGFyZ2V0KSB7XG4gICAgICBpZiAocGFyYW1zLmFjdGl2ZVN0YXRlKSByZW1vdmVBY3RpdmUoKTtcbiAgICAgIGlmICh1c2VSaXBwbGUpIHtcbiAgICAgICAgcmlwcGxlVG91Y2hFbmQoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmICghYWN0aXZlU2VsZWN0aW9uKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuXG4gICAgaWYgKCh0b3VjaEVuZFRpbWUgLSBsYXN0Q2xpY2tUaW1lKSA8IHBhcmFtcy5mYXN0Q2xpY2tzRGVsYXlCZXR3ZWVuQ2xpY2tzKSB7XG4gICAgICBzZXRUaW1lb3V0KHJlbW92ZUFjdGl2ZSwgMCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBsYXN0Q2xpY2tUaW1lID0gdG91Y2hFbmRUaW1lO1xuXG4gICAgdHJhY2tDbGljayA9IGZhbHNlO1xuXG4gICAgaWYgKERldmljZS5pb3MgJiYgc2Nyb2xsUGFyZW50KSB7XG4gICAgICBpZiAoc2Nyb2xsUGFyZW50LnNjcm9sbFRvcCAhPT0gc2Nyb2xsUGFyZW50LmY3U2Nyb2xsVG9wKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBZGQgYWN0aXZlLXN0YXRlIGhlcmUgYmVjYXVzZSwgaW4gYSB2ZXJ5IGZhc3QgdGFwLCB0aGUgdGltZW91dCBkaWRuJ3RcbiAgICAvLyBoYXZlIHRoZSBjaGFuY2UgdG8gZXhlY3V0ZS4gUmVtb3ZpbmcgYWN0aXZlLXN0YXRlIGluIGEgdGltZW91dCBnaXZlc1xuICAgIC8vIHRoZSBjaGFuY2UgdG8gdGhlIGFuaW1hdGlvbiBleGVjdXRlLlxuICAgIGlmIChwYXJhbXMuYWN0aXZlU3RhdGUpIHtcbiAgICAgIGFkZEFjdGl2ZSgpO1xuICAgICAgc2V0VGltZW91dChyZW1vdmVBY3RpdmUsIDApO1xuICAgIH1cbiAgICAvLyBSZW1vdmUgUmlwcGxlXG4gICAgaWYgKHVzZVJpcHBsZSkge1xuICAgICAgcmlwcGxlVG91Y2hFbmQoKTtcbiAgICB9XG5cbiAgICAvLyBUcmlnZ2VyIGZvY3VzIHdoZW4gcmVxdWlyZWRcbiAgICBpZiAodGFyZ2V0TmVlZHNGb2N1cyh0YXJnZXRFbGVtZW50KSkge1xuICAgICAgaWYgKERldmljZS5pb3MgJiYgRGV2aWNlLndlYlZpZXcpIHtcbiAgICAgICAgdGFyZ2V0RWxlbWVudC5mb2N1cygpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHRhcmdldEVsZW1lbnQuZm9jdXMoKTtcbiAgICB9XG5cbiAgICAvLyBCbHVyIGFjdGl2ZSBlbGVtZW50c1xuICAgIGlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50ICYmIHRhcmdldEVsZW1lbnQgIT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgJiYgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAhPT0gZG9jdW1lbnQuYm9keSAmJiB0YXJnZXRFbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgIT09ICdsYWJlbCcpIHtcbiAgICAgIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQuYmx1cigpO1xuICAgIH1cblxuICAgIC8vIFNlbmQgY2xpY2tcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgaWYgKHBhcmFtcy50YXBIb2xkUHJldmVudENsaWNrcyAmJiB0YXBIb2xkRmlyZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgc2VuZENsaWNrKGUpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmdW5jdGlvbiBoYW5kbGVUb3VjaENhbmNlbCgpIHtcbiAgICB0cmFja0NsaWNrID0gZmFsc2U7XG4gICAgdGFyZ2V0RWxlbWVudCA9IG51bGw7XG5cbiAgICAvLyBSZW1vdmUgQWN0aXZlIFN0YXRlXG4gICAgY2xlYXJUaW1lb3V0KGFjdGl2ZVRpbWVvdXQpO1xuICAgIGNsZWFyVGltZW91dCh0YXBIb2xkVGltZW91dCk7XG4gICAgaWYgKHBhcmFtcy5hY3RpdmVTdGF0ZSkge1xuICAgICAgcmVtb3ZlQWN0aXZlKCk7XG4gICAgfVxuXG4gICAgLy8gUmVtb3ZlIFJpcHBsZVxuICAgIGlmICh1c2VSaXBwbGUpIHtcbiAgICAgIHJpcHBsZVRvdWNoRW5kKCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlQ2xpY2soZSkge1xuICAgIGxldCBhbGxvd0NsaWNrID0gZmFsc2U7XG4gICAgaWYgKHRyYWNrQ2xpY2spIHtcbiAgICAgIHRhcmdldEVsZW1lbnQgPSBudWxsO1xuICAgICAgdHJhY2tDbGljayA9IGZhbHNlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICgoZS50YXJnZXQudHlwZSA9PT0gJ3N1Ym1pdCcgJiYgZS5kZXRhaWwgPT09IDApIHx8IGUudGFyZ2V0LnR5cGUgPT09ICdmaWxlJykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICghdGFyZ2V0RWxlbWVudCkge1xuICAgICAgaWYgKCFpc0Zvcm1FbGVtZW50KGUudGFyZ2V0KSkge1xuICAgICAgICBhbGxvd0NsaWNrID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFuZWVkc0Zhc3RDbGljaykge1xuICAgICAgYWxsb3dDbGljayA9IHRydWU7XG4gICAgfVxuICAgIGlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSB0YXJnZXRFbGVtZW50KSB7XG4gICAgICBhbGxvd0NsaWNrID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGUuZm9yd2FyZGVkVG91Y2hFdmVudCkge1xuICAgICAgYWxsb3dDbGljayA9IHRydWU7XG4gICAgfVxuICAgIGlmICghZS5jYW5jZWxhYmxlKSB7XG4gICAgICBhbGxvd0NsaWNrID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHBhcmFtcy50YXBIb2xkICYmIHBhcmFtcy50YXBIb2xkUHJldmVudENsaWNrcyAmJiB0YXBIb2xkRmlyZWQpIHtcbiAgICAgIGFsbG93Q2xpY2sgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFhbGxvd0NsaWNrKSB7XG4gICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIGlmICh0YXJnZXRFbGVtZW50KSB7XG4gICAgICAgIGlmICh0YXJnZXROZWVkc1ByZXZlbnQodGFyZ2V0RWxlbWVudCkgfHwgaXNNb3ZlZCkge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuICAgICAgdGFyZ2V0RWxlbWVudCA9IG51bGw7XG4gICAgfVxuICAgIG5lZWRzRmFzdENsaWNrVGltZU91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgbmVlZHNGYXN0Q2xpY2sgPSBmYWxzZTtcbiAgICB9LCAoRGV2aWNlLmlvcyB8fCBEZXZpY2UuYW5kcm9pZENocm9tZSA/IDEwMCA6IDQwMCkpO1xuXG4gICAgaWYgKHBhcmFtcy50YXBIb2xkKSB7XG4gICAgICB0YXBIb2xkVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0YXBIb2xkRmlyZWQgPSBmYWxzZTtcbiAgICAgIH0sIChEZXZpY2UuaW9zIHx8IERldmljZS5hbmRyb2lkQ2hyb21lID8gMTAwIDogNDAwKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFsbG93Q2xpY2s7XG4gIH1cblxuICBmdW5jdGlvbiBlbWl0QXBwVG91Y2hFdmVudChuYW1lLCBlKSB7XG4gICAgYXBwLmVtaXQoe1xuICAgICAgZXZlbnRzOiBuYW1lLFxuICAgICAgZGF0YTogW2VdLFxuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGFwcENsaWNrKGUpIHtcbiAgICBlbWl0QXBwVG91Y2hFdmVudCgnY2xpY2snLCBlKTtcbiAgfVxuICBmdW5jdGlvbiBhcHBUb3VjaFN0YXJ0QWN0aXZlKGUpIHtcbiAgICBlbWl0QXBwVG91Y2hFdmVudCgndG91Y2hzdGFydCB0b3VjaHN0YXJ0OmFjdGl2ZScsIGUpO1xuICB9XG4gIGZ1bmN0aW9uIGFwcFRvdWNoTW92ZUFjdGl2ZShlKSB7XG4gICAgZW1pdEFwcFRvdWNoRXZlbnQoJ3RvdWNobW92ZSB0b3VjaG1vdmU6YWN0aXZlJywgZSk7XG4gIH1cbiAgZnVuY3Rpb24gYXBwVG91Y2hFbmRBY3RpdmUoZSkge1xuICAgIGVtaXRBcHBUb3VjaEV2ZW50KCd0b3VjaGVuZCB0b3VjaGVuZDphY3RpdmUnLCBlKTtcbiAgfVxuICBmdW5jdGlvbiBhcHBUb3VjaFN0YXJ0UGFzc2l2ZShlKSB7XG4gICAgZW1pdEFwcFRvdWNoRXZlbnQoJ3RvdWNoc3RhcnQ6cGFzc2l2ZScsIGUpO1xuICB9XG4gIGZ1bmN0aW9uIGFwcFRvdWNoTW92ZVBhc3NpdmUoZSkge1xuICAgIGVtaXRBcHBUb3VjaEV2ZW50KCd0b3VjaG1vdmU6cGFzc2l2ZScsIGUpO1xuICB9XG4gIGZ1bmN0aW9uIGFwcFRvdWNoRW5kUGFzc2l2ZShlKSB7XG4gICAgZW1pdEFwcFRvdWNoRXZlbnQoJ3RvdWNoZW5kOnBhc3NpdmUnLCBlKTtcbiAgfVxuXG4gIGNvbnN0IHBhc3NpdmVMaXN0ZW5lciA9IFN1cHBvcnQucGFzc2l2ZUxpc3RlbmVyID8geyBwYXNzaXZlOiB0cnVlIH0gOiBmYWxzZTtcbiAgY29uc3QgYWN0aXZlTGlzdGVuZXIgPSBTdXBwb3J0LnBhc3NpdmVMaXN0ZW5lciA/IHsgcGFzc2l2ZTogZmFsc2UgfSA6IGZhbHNlO1xuXG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgYXBwQ2xpY2ssIHRydWUpO1xuXG4gIGlmIChTdXBwb3J0LnBhc3NpdmVMaXN0ZW5lcikge1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoYXBwLnRvdWNoRXZlbnRzLnN0YXJ0LCBhcHBUb3VjaFN0YXJ0QWN0aXZlLCBhY3RpdmVMaXN0ZW5lcik7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihhcHAudG91Y2hFdmVudHMubW92ZSwgYXBwVG91Y2hNb3ZlQWN0aXZlLCBhY3RpdmVMaXN0ZW5lcik7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihhcHAudG91Y2hFdmVudHMuZW5kLCBhcHBUb3VjaEVuZEFjdGl2ZSwgYWN0aXZlTGlzdGVuZXIpO1xuXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihhcHAudG91Y2hFdmVudHMuc3RhcnQsIGFwcFRvdWNoU3RhcnRQYXNzaXZlLCBwYXNzaXZlTGlzdGVuZXIpO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoYXBwLnRvdWNoRXZlbnRzLm1vdmUsIGFwcFRvdWNoTW92ZVBhc3NpdmUsIHBhc3NpdmVMaXN0ZW5lcik7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihhcHAudG91Y2hFdmVudHMuZW5kLCBhcHBUb3VjaEVuZFBhc3NpdmUsIHBhc3NpdmVMaXN0ZW5lcik7XG4gIH0gZWxzZSB7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihhcHAudG91Y2hFdmVudHMuc3RhcnQsIChlKSA9PiB7XG4gICAgICBhcHBUb3VjaFN0YXJ0QWN0aXZlKGUpO1xuICAgICAgYXBwVG91Y2hTdGFydFBhc3NpdmUoZSk7XG4gICAgfSwgZmFsc2UpO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoYXBwLnRvdWNoRXZlbnRzLm1vdmUsIChlKSA9PiB7XG4gICAgICBhcHBUb3VjaE1vdmVBY3RpdmUoZSk7XG4gICAgICBhcHBUb3VjaE1vdmVQYXNzaXZlKGUpO1xuICAgIH0sIGZhbHNlKTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKGFwcC50b3VjaEV2ZW50cy5lbmQsIChlKSA9PiB7XG4gICAgICBhcHBUb3VjaEVuZEFjdGl2ZShlKTtcbiAgICAgIGFwcFRvdWNoRW5kUGFzc2l2ZShlKTtcbiAgICB9LCBmYWxzZSk7XG4gIH1cblxuICBpZiAoU3VwcG9ydC50b3VjaCkge1xuICAgIGFwcC5vbignY2xpY2snLCBoYW5kbGVDbGljayk7XG4gICAgYXBwLm9uKCd0b3VjaHN0YXJ0JywgaGFuZGxlVG91Y2hTdGFydCk7XG4gICAgYXBwLm9uKCd0b3VjaG1vdmUnLCBoYW5kbGVUb3VjaE1vdmUpO1xuICAgIGFwcC5vbigndG91Y2hlbmQnLCBoYW5kbGVUb3VjaEVuZCk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hjYW5jZWwnLCBoYW5kbGVUb3VjaENhbmNlbCwgeyBwYXNzaXZlOiB0cnVlIH0pO1xuICB9IGVsc2UgaWYgKHBhcmFtcy5hY3RpdmVTdGF0ZSkge1xuICAgIGFwcC5vbigndG91Y2hzdGFydCcsIGhhbmRsZU1vdXNlRG93bik7XG4gICAgYXBwLm9uKCd0b3VjaG1vdmUnLCBoYW5kbGVNb3VzZU1vdmUpO1xuICAgIGFwcC5vbigndG91Y2hlbmQnLCBoYW5kbGVNb3VzZVVwKTtcbiAgfVxuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdjb250ZXh0bWVudScsIChlKSA9PiB7XG4gICAgaWYgKHBhcmFtcy5kaXNhYmxlQ29udGV4dE1lbnUgJiYgKERldmljZS5pb3MgfHwgRGV2aWNlLmFuZHJvaWQgfHwgRGV2aWNlLmNvcmRvdmEpKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICAgIGlmICh1c2VSaXBwbGUpIHtcbiAgICAgIGlmIChhY3RpdmFibGVFbGVtZW50KSByZW1vdmVBY3RpdmUoKTtcbiAgICAgIHJpcHBsZVRvdWNoRW5kKCk7XG4gICAgfVxuICB9KTtcbn1cblxudmFyIFRvdWNoTW9kdWxlID0ge1xuICBuYW1lOiAndG91Y2gnLFxuICBwYXJhbXM6IHtcbiAgICB0b3VjaDoge1xuICAgICAgLy8gRmFzdCBjbGlja3NcbiAgICAgIGZhc3RDbGlja3M6IHRydWUsXG4gICAgICBmYXN0Q2xpY2tzRGlzdGFuY2VUaHJlc2hvbGQ6IDEwLFxuICAgICAgZmFzdENsaWNrc0RlbGF5QmV0d2VlbkNsaWNrczogNTAsXG4gICAgICBmYXN0Q2xpY2tzRXhjbHVkZTogJycsIC8vIENTUyBzZWxlY3RvclxuICAgICAgLy8gQ29udGV4dE1lbnVcbiAgICAgIGRpc2FibGVDb250ZXh0TWVudTogdHJ1ZSxcbiAgICAgIC8vIFRhcCBIb2xkXG4gICAgICB0YXBIb2xkOiBmYWxzZSxcbiAgICAgIHRhcEhvbGREZWxheTogNzUwLFxuICAgICAgdGFwSG9sZFByZXZlbnRDbGlja3M6IHRydWUsXG4gICAgICAvLyBBY3RpdmUgU3RhdGVcbiAgICAgIGFjdGl2ZVN0YXRlOiB0cnVlLFxuICAgICAgYWN0aXZlU3RhdGVFbGVtZW50czogJ2EsIGJ1dHRvbiwgbGFiZWwsIHNwYW4sIC5hY3Rpb25zLWJ1dHRvbiwgLnN0ZXBwZXItYnV0dG9uLCAuc3RlcHBlci1idXR0b24tcGx1cywgLnN0ZXBwZXItYnV0dG9uLW1pbnVzJyxcbiAgICAgIG1hdGVyaWFsUmlwcGxlOiB0cnVlLFxuICAgICAgbWF0ZXJpYWxSaXBwbGVFbGVtZW50czogJy5yaXBwbGUsIC5saW5rLCAuaXRlbS1saW5rLCAubGlua3MtbGlzdCBhLCAuYnV0dG9uLCBidXR0b24sIC5pbnB1dC1jbGVhci1idXR0b24sIC5kaWFsb2ctYnV0dG9uLCAudGFiLWxpbmssIC5pdGVtLXJhZGlvLCAuaXRlbS1jaGVja2JveCwgLmFjdGlvbnMtYnV0dG9uLCAuc2VhcmNoYmFyLWRpc2FibGUtYnV0dG9uLCAuZmFiIGEsIC5jaGVja2JveCwgLnJhZGlvLCAuZGF0YS10YWJsZSAuc29ydGFibGUtY2VsbDpub3QoLmlucHV0LWNlbGwpLCAubm90aWZpY2F0aW9uLWNsb3NlLWJ1dHRvbiwgLnN0ZXBwZXItYnV0dG9uLCAuc3RlcHBlci1idXR0b24tbWludXMsIC5zdGVwcGVyLWJ1dHRvbi1wbHVzJyxcbiAgICB9LFxuICB9LFxuICBpbnN0YW5jZToge1xuICAgIHRvdWNoRXZlbnRzOiB7XG4gICAgICBzdGFydDogU3VwcG9ydC50b3VjaCA/ICd0b3VjaHN0YXJ0JyA6ICdtb3VzZWRvd24nLFxuICAgICAgbW92ZTogU3VwcG9ydC50b3VjaCA/ICd0b3VjaG1vdmUnIDogJ21vdXNlbW92ZScsXG4gICAgICBlbmQ6IFN1cHBvcnQudG91Y2ggPyAndG91Y2hlbmQnIDogJ21vdXNldXAnLFxuICAgIH0sXG4gIH0sXG4gIG9uOiB7XG4gICAgaW5pdDogaW5pdFRvdWNoLFxuICB9LFxufTtcblxuY29uc3QgdGVtcERvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG5jbGFzcyBGcmFtZXdvcms3Q29tcG9uZW50IHtcbiAgY29uc3RydWN0b3Iob3B0cywgZXh0ZW5kQ29udGV4dCA9IHt9KSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IFV0aWxzLmV4dGVuZCh7fSwgb3B0cyk7XG4gICAgbGV0IGNvbXBvbmVudCA9IFV0aWxzLm1lcmdlKHRoaXMsIGV4dGVuZENvbnRleHQsIHsgJG9wdGlvbnM6IG9wdGlvbnMgfSk7XG5cbiAgICAvLyBBcHBseSBjb250ZXh0XG4gICAgKCdiZWZvcmVDcmVhdGUgY3JlYXRlZCBiZWZvcmVNb3VudCBtb3VudGVkIGJlZm9yZURlc3Ryb3kgZGVzdHJveWVkJykuc3BsaXQoJyAnKS5mb3JFYWNoKChjeWNsZUtleSkgPT4ge1xuICAgICAgaWYgKG9wdGlvbnNbY3ljbGVLZXldKSBvcHRpb25zW2N5Y2xlS2V5XSA9IG9wdGlvbnNbY3ljbGVLZXldLmJpbmQoY29tcG9uZW50KTtcbiAgICB9KTtcblxuICAgIGlmIChvcHRpb25zLmRhdGEpIHtcbiAgICAgIG9wdGlvbnMuZGF0YSA9IG9wdGlvbnMuZGF0YS5iaW5kKGNvbXBvbmVudCk7XG4gICAgICAvLyBEYXRhXG4gICAgICBVdGlscy5leHRlbmQoY29tcG9uZW50LCBvcHRpb25zLmRhdGEoKSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnJlbmRlcikgb3B0aW9ucy5yZW5kZXIgPSBvcHRpb25zLnJlbmRlci5iaW5kKGNvbXBvbmVudCk7XG4gICAgaWYgKG9wdGlvbnMubWV0aG9kcykge1xuICAgICAgT2JqZWN0LmtleXMob3B0aW9ucy5tZXRob2RzKS5mb3JFYWNoKChtZXRob2ROYW1lKSA9PiB7XG4gICAgICAgIGNvbXBvbmVudFttZXRob2ROYW1lXSA9IG9wdGlvbnMubWV0aG9kc1ttZXRob2ROYW1lXS5iaW5kKGNvbXBvbmVudCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBCaW5kIEV2ZW50c1xuICAgIGlmIChvcHRpb25zLm9uKSB7XG4gICAgICBPYmplY3Qua2V5cyhvcHRpb25zLm9uKS5mb3JFYWNoKChldmVudE5hbWUpID0+IHtcbiAgICAgICAgb3B0aW9ucy5vbltldmVudE5hbWVdID0gb3B0aW9ucy5vbltldmVudE5hbWVdLmJpbmQoY29tcG9uZW50KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5vbmNlKSB7XG4gICAgICBPYmplY3Qua2V5cyhvcHRpb25zLm9uY2UpLmZvckVhY2goKGV2ZW50TmFtZSkgPT4ge1xuICAgICAgICBvcHRpb25zLm9uY2VbZXZlbnROYW1lXSA9IG9wdGlvbnMub25jZVtldmVudE5hbWVdLmJpbmQoY29tcG9uZW50KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmJlZm9yZUNyZWF0ZSkgb3B0aW9ucy5iZWZvcmVDcmVhdGUoKTtcblxuICAgIC8vIFdhdGNoZXJzXG4gICAgaWYgKG9wdGlvbnMud2F0Y2gpIHtcbiAgICAgIE9iamVjdC5rZXlzKG9wdGlvbnMud2F0Y2gpLmZvckVhY2goKHdhdGNoS2V5KSA9PiB7XG4gICAgICAgIGxldCBkYXRhS2V5VmFsdWUgPSBjb21wb25lbnRbd2F0Y2hLZXldO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29tcG9uZW50LCB3YXRjaEtleSwge1xuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgIHNldChuZXdWYWx1ZSkge1xuICAgICAgICAgICAgY29uc3QgcHJldmlvdXNWYWx1ZSA9IGRhdGFLZXlWYWx1ZTtcbiAgICAgICAgICAgIGRhdGFLZXlWYWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgICAgICAgaWYgKHByZXZpb3VzVmFsdWUgPT09IG5ld1ZhbHVlKSByZXR1cm47XG4gICAgICAgICAgICBvcHRpb25zLndhdGNoW3dhdGNoS2V5XS5jYWxsKGNvbXBvbmVudCwgbmV3VmFsdWUsIHByZXZpb3VzVmFsdWUpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGFLZXlWYWx1ZTtcbiAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIFJlbmRlciB0ZW1wbGF0ZVxuXG4gICAgZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgbGV0IGh0bWwgPSAnJztcbiAgICAgIGlmIChvcHRpb25zLnJlbmRlcikge1xuICAgICAgICBodG1sID0gb3B0aW9ucy5yZW5kZXIoKTtcbiAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy50ZW1wbGF0ZSkge1xuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMudGVtcGxhdGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGh0bWwgPSBUZW1wbGF0ZTcuY29tcGlsZShvcHRpb25zLnRlbXBsYXRlKShjb21wb25lbnQpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBTdXBwb3NlZCB0byBiZSBmdW5jdGlvblxuICAgICAgICAgIGh0bWwgPSBvcHRpb25zLnRlbXBsYXRlKGNvbXBvbmVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBodG1sO1xuICAgIH1cblxuICAgIGxldCBodG1sID0gcmVuZGVyKCk7XG5cbiAgICAvLyBNYWtlIERvbVxuICAgIGlmIChodG1sICYmIHR5cGVvZiBodG1sID09PSAnc3RyaW5nJykge1xuICAgICAgaHRtbCA9IGh0bWwudHJpbSgpO1xuICAgICAgdGVtcERvbS5pbm5lckhUTUwgPSBodG1sO1xuICAgIH0gZWxzZSBpZiAoaHRtbCkge1xuICAgICAgdGVtcERvbS5pbm5lckhUTUwgPSAnJztcbiAgICAgIHRlbXBEb20uYXBwZW5kQ2hpbGQoaHRtbCk7XG4gICAgfVxuXG4gICAgLy8gRXh0ZW5kIGNvbXBvbmVudCB3aXRoICRlbFxuICAgIGNvbnN0IGVsID0gdGVtcERvbS5jaGlsZHJlblswXTtcbiAgICBjb25zdCAkZWwgPSAkKGVsKTtcbiAgICBjb21wb25lbnQuJGVsID0gJGVsO1xuICAgIGNvbXBvbmVudC5lbCA9IGVsO1xuICAgIGNvbXBvbmVudC5lbCA9IGVsO1xuXG4gICAgLy8gRmluZCBFdmVudHNcbiAgICBjb25zdCBldmVudHMgPSBbXTtcbiAgICAkKHRlbXBEb20pLmZpbmQoJyonKS5lYWNoKChpbmRleCwgZWxlbWVudCkgPT4ge1xuICAgICAgY29uc3QgYXR0cnMgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZWxlbWVudC5hdHRyaWJ1dGVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGNvbnN0IGF0dHIgPSBlbGVtZW50LmF0dHJpYnV0ZXNbaV07XG4gICAgICAgIGlmIChhdHRyLm5hbWUuaW5kZXhPZignQCcpID09PSAwKSB7XG4gICAgICAgICAgYXR0cnMucHVzaCh7XG4gICAgICAgICAgICBuYW1lOiBhdHRyLm5hbWUsXG4gICAgICAgICAgICB2YWx1ZTogYXR0ci52YWx1ZSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYXR0cnMuZm9yRWFjaCgoYXR0cikgPT4ge1xuICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShhdHRyLm5hbWUpO1xuICAgICAgICBjb25zdCBldmVudCA9IGF0dHIubmFtZS5yZXBsYWNlKCdAJywgJycpO1xuICAgICAgICBsZXQgbmFtZSA9IGV2ZW50O1xuICAgICAgICBsZXQgc3RvcCA9IGZhbHNlO1xuICAgICAgICBsZXQgcHJldmVudCA9IGZhbHNlO1xuICAgICAgICBsZXQgb25jZSA9IGZhbHNlO1xuICAgICAgICBpZiAoZXZlbnQuaW5kZXhPZignLicpID49IDApIHtcbiAgICAgICAgICBldmVudC5zcGxpdCgnLicpLmZvckVhY2goKGV2ZW50TmFtZVBhcnQsIGV2ZW50TmFtZUluZGV4KSA9PiB7XG4gICAgICAgICAgICBpZiAoZXZlbnROYW1lSW5kZXggPT09IDApIG5hbWUgPSBldmVudE5hbWVQYXJ0O1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChldmVudE5hbWVQYXJ0ID09PSAnc3RvcCcpIHN0b3AgPSB0cnVlO1xuICAgICAgICAgICAgICBpZiAoZXZlbnROYW1lUGFydCA9PT0gJ3ByZXZlbnQnKSBwcmV2ZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgaWYgKGV2ZW50TmFtZVBhcnQgPT09ICdvbmNlJykgb25jZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFsdWUgPSBhdHRyLnZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgIGV2ZW50cy5wdXNoKHtcbiAgICAgICAgICBlbDogZWxlbWVudCxcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIG9uY2UsXG4gICAgICAgICAgaGFuZGxlciguLi5hcmdzKSB7XG4gICAgICAgICAgICBjb25zdCBlID0gYXJnc1swXTtcbiAgICAgICAgICAgIGlmIChzdG9wKSBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgaWYgKHByZXZlbnQpIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGxldCBtZXRob2ROYW1lO1xuICAgICAgICAgICAgbGV0IG1ldGhvZDtcbiAgICAgICAgICAgIGxldCBjdXN0b21BcmdzID0gW107XG4gICAgICAgICAgICBpZiAodmFsdWUuaW5kZXhPZignKCcpIDwgMCkge1xuICAgICAgICAgICAgICBjdXN0b21BcmdzID0gYXJncztcbiAgICAgICAgICAgICAgbWV0aG9kTmFtZSA9IHZhbHVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbWV0aG9kTmFtZSA9IHZhbHVlLnNwbGl0KCcoJylbMF07XG4gICAgICAgICAgICAgIHZhbHVlLnNwbGl0KCcoJylbMV0uc3BsaXQoJyknKVswXS5zcGxpdCgnLCcpLmZvckVhY2goKGFyZ3VtZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGFyZyA9IGFyZ3VtZW50LnRyaW0oKTtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgICAgICAgICBpZiAoIWlzTmFOKGFyZykpIGFyZyA9IHBhcnNlRmxvYXQoYXJnKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChhcmcgPT09ICd0cnVlJykgYXJnID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChhcmcgPT09ICdmYWxzZScpIGFyZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGFyZyA9PT0gJ251bGwnKSBhcmcgPSBudWxsO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGFyZyA9PT0gJ3VuZGVmaW5lZCcpIGFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChhcmdbMF0gPT09ICdcIicpIGFyZyA9IGFyZy5yZXBsYWNlKC9cIi9nLCAnJyk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYXJnWzBdID09PSAnXFwnJykgYXJnID0gYXJnLnJlcGxhY2UoLycvZywgJycpO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGFyZy5pbmRleE9mKCcuJykgPiAwKSB7XG4gICAgICAgICAgICAgICAgICBsZXQgZGVlcEFyZztcbiAgICAgICAgICAgICAgICAgIGFyZy5zcGxpdCgnLicpLmZvckVhY2goKHBhdGgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkZWVwQXJnKSBkZWVwQXJnID0gY29tcG9uZW50O1xuICAgICAgICAgICAgICAgICAgICBkZWVwQXJnID0gZGVlcEFyZ1twYXRoXTtcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgYXJnID0gZGVlcEFyZztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgYXJnID0gY29tcG9uZW50W2FyZ107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN1c3RvbUFyZ3MucHVzaChhcmcpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXRob2ROYW1lLmluZGV4T2YoJy4nKSA+PSAwKSB7XG4gICAgICAgICAgICAgIG1ldGhvZE5hbWUuc3BsaXQoJy4nKS5mb3JFYWNoKChwYXRoLCBwYXRoSW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIW1ldGhvZCkgbWV0aG9kID0gY29tcG9uZW50O1xuICAgICAgICAgICAgICAgIGlmIChtZXRob2RbcGF0aF0pIG1ldGhvZCA9IG1ldGhvZFtwYXRoXTtcbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29tcG9uZW50IGRvZXNuJ3QgaGF2ZSBtZXRob2QgXCIke21ldGhvZE5hbWUuc3BsaXQoJy4nKS5zbGljZSgwLCBwYXRoSW5kZXggKyAxKS5qb2luKCcuJyl9XCJgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKCFjb21wb25lbnRbbWV0aG9kTmFtZV0pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvbXBvbmVudCBkb2Vzbid0IGhhdmUgbWV0aG9kIFwiJHttZXRob2ROYW1lfVwiYCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbWV0aG9kID0gY29tcG9uZW50W21ldGhvZE5hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWV0aG9kKC4uLmN1c3RvbUFyZ3MpO1xuICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvLyBTZXQgc3R5bGVzIHNjb3BlIElEXG4gICAgbGV0IHN0eWxlRWw7XG4gICAgaWYgKG9wdGlvbnMuc3R5bGUpIHtcbiAgICAgIHN0eWxlRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgICAgc3R5bGVFbC5pbm5lckhUTUwgPSBvcHRpb25zLnN0eWxlO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5zdHlsZVNjb3BlSWQpIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZSgnZGF0YS1zY29wZScsIG9wdGlvbnMuc3R5bGVTY29wZUlkKTtcbiAgICB9XG5cbiAgICAvLyBBdHRhY2ggZXZlbnRzXG4gICAgZnVuY3Rpb24gYXR0YWNoRXZlbnRzKCkge1xuICAgICAgaWYgKG9wdGlvbnMub24pIHtcbiAgICAgICAgT2JqZWN0LmtleXMob3B0aW9ucy5vbikuZm9yRWFjaCgoZXZlbnROYW1lKSA9PiB7XG4gICAgICAgICAgJGVsLm9uKFV0aWxzLmV2ZW50TmFtZVRvQ29sb25DYXNlKGV2ZW50TmFtZSksIG9wdGlvbnMub25bZXZlbnROYW1lXSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMub25jZSkge1xuICAgICAgICBPYmplY3Qua2V5cyhvcHRpb25zLm9uY2UpLmZvckVhY2goKGV2ZW50TmFtZSkgPT4ge1xuICAgICAgICAgICRlbC5vbmNlKFV0aWxzLmV2ZW50TmFtZVRvQ29sb25DYXNlKGV2ZW50TmFtZSksIG9wdGlvbnMub25jZVtldmVudE5hbWVdKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBldmVudHMuZm9yRWFjaCgoZXZlbnQpID0+IHtcbiAgICAgICAgJChldmVudC5lbClbZXZlbnQub25jZSA/ICdvbmNlJyA6ICdvbiddKGV2ZW50Lm5hbWUsIGV2ZW50LmhhbmRsZXIpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGV0YWNoRXZlbnRzKCkge1xuICAgICAgaWYgKG9wdGlvbnMub24pIHtcbiAgICAgICAgT2JqZWN0LmtleXMob3B0aW9ucy5vbikuZm9yRWFjaCgoZXZlbnROYW1lKSA9PiB7XG4gICAgICAgICAgJGVsLm9mZihVdGlscy5ldmVudE5hbWVUb0NvbG9uQ2FzZShldmVudE5hbWUpLCBvcHRpb25zLm9uW2V2ZW50TmFtZV0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLm9uY2UpIHtcbiAgICAgICAgT2JqZWN0LmtleXMob3B0aW9ucy5vbmNlKS5mb3JFYWNoKChldmVudE5hbWUpID0+IHtcbiAgICAgICAgICAkZWwub2ZmKFV0aWxzLmV2ZW50TmFtZVRvQ29sb25DYXNlKGV2ZW50TmFtZSksIG9wdGlvbnMub25jZVtldmVudE5hbWVdKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBldmVudHMuZm9yRWFjaCgoZXZlbnQpID0+IHtcbiAgICAgICAgJChldmVudC5lbCkub2ZmKGV2ZW50Lm5hbWUsIGV2ZW50LmhhbmRsZXIpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgYXR0YWNoRXZlbnRzKCk7XG5cbiAgICAvLyBDcmVhdGVkIGNhbGxiYWNrXG4gICAgaWYgKG9wdGlvbnMuY3JlYXRlZCkgb3B0aW9ucy5jcmVhdGVkKCk7XG5cbiAgICAvLyBNb3VudFxuICAgIGNvbXBvbmVudC4kbW91bnQgPSBmdW5jdGlvbiBtb3VudChtb3VudE1ldGhvZCkge1xuICAgICAgaWYgKG9wdGlvbnMuYmVmb3JlTW91bnQpIG9wdGlvbnMuYmVmb3JlTW91bnQoKTtcbiAgICAgIGlmIChzdHlsZUVsKSAkKCdoZWFkJykuYXBwZW5kKHN0eWxlRWwpO1xuICAgICAgaWYgKG1vdW50TWV0aG9kKSBtb3VudE1ldGhvZChlbCk7XG4gICAgICBpZiAob3B0aW9ucy5tb3VudGVkKSBvcHRpb25zLm1vdW50ZWQoKTtcbiAgICB9O1xuXG4gICAgLy8gRGVzdHJveVxuICAgIGNvbXBvbmVudC4kZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICBpZiAob3B0aW9ucy5iZWZvcmVEZXN0cm95KSBvcHRpb25zLmJlZm9yZURlc3Ryb3koKTtcbiAgICAgIGlmIChzdHlsZUVsKSAkKHN0eWxlRWwpLnJlbW92ZSgpO1xuICAgICAgZGV0YWNoRXZlbnRzKCk7XG4gICAgICBpZiAob3B0aW9ucy5kZXN0cm95ZWQpIG9wdGlvbnMuZGVzdHJveWVkKCk7XG4gICAgICAvLyBEZWxldGUgY29tcG9uZW50IGluc3RhbmNlXG4gICAgICBpZiAoZWwgJiYgZWwuZjdDb21wb25lbnQpIHtcbiAgICAgICAgZWwuZjdDb21wb25lbnQgPSBudWxsO1xuICAgICAgICBkZWxldGUgZWwuZjdDb21wb25lbnQ7XG4gICAgICB9XG4gICAgICBVdGlscy5kZWxldGVQcm9wcyhjb21wb25lbnQpO1xuICAgICAgY29tcG9uZW50ID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLy8gU3RvcmUgY29tcG9uZW50IGluc3RhbmNlXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZW1wRG9tLmNoaWxkcmVuLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICB0ZW1wRG9tLmNoaWxkcmVuW2ldLmY3Q29tcG9uZW50ID0gY29tcG9uZW50O1xuICAgIH1cblxuICAgIHJldHVybiBjb21wb25lbnQ7XG4gIH1cbn1cblxuXG5jb25zdCBDb21wb25lbnQgPSB7XG4gIHBhcnNlKGNvbXBvbmVudFN0cmluZykge1xuICAgIGNvbnN0IGNhbGxiYWNrTmFtZSA9IGBmN19jb21wb25lbnRfY2FsbGJhY2tfJHtuZXcgRGF0ZSgpLmdldFRpbWUoKX1gO1xuXG4gICAgLy8gVGVtcGxhdGVcbiAgICBsZXQgdGVtcGxhdGU7XG4gICAgaWYgKGNvbXBvbmVudFN0cmluZy5pbmRleE9mKCc8dGVtcGxhdGU+JykgPj0gMCkge1xuICAgICAgdGVtcGxhdGUgPSBjb21wb25lbnRTdHJpbmdcbiAgICAgICAgLnNwbGl0KCc8dGVtcGxhdGU+JylcbiAgICAgICAgLmZpbHRlcigoaXRlbSwgaW5kZXgpID0+IGluZGV4ID4gMClcbiAgICAgICAgLmpvaW4oJzx0ZW1wbGF0ZT4nKVxuICAgICAgICAuc3BsaXQoJzwvdGVtcGxhdGU+JylcbiAgICAgICAgLmZpbHRlcigoaXRlbSwgaW5kZXgsIGFycikgPT4gaW5kZXggPCBhcnIubGVuZ3RoIC0gMSlcbiAgICAgICAgLmpvaW4oJzwvdGVtcGxhdGU+JylcbiAgICAgICAgLnJlcGxhY2UoL3t7I3Jhd319KFsgXFxuXSopPHRlbXBsYXRlL2csICd7eyNyYXd9fTx0ZW1wbGF0ZScpXG4gICAgICAgIC5yZXBsYWNlKC9cXC90ZW1wbGF0ZT4oWyBcXG5dKil7e1xcL3Jhd319L2csICcvdGVtcGxhdGU+e3svcmF3fX0nKVxuICAgICAgICAucmVwbGFjZSgvKFsgXFxuXSk8dGVtcGxhdGUvZywgJyQxe3sjcmF3fX08dGVtcGxhdGUnKVxuICAgICAgICAucmVwbGFjZSgvXFwvdGVtcGxhdGU+KFsgXFxuXSkvZywgJy90ZW1wbGF0ZT57ey9yYXd9fSQxJyk7XG4gICAgfVxuXG4gICAgLy8gU3R5bGVzXG4gICAgbGV0IHN0eWxlO1xuICAgIGNvbnN0IHN0eWxlU2NvcGVJZCA9IFV0aWxzLm5vdygpO1xuICAgIGlmIChjb21wb25lbnRTdHJpbmcuaW5kZXhPZignPHN0eWxlPicpID49IDApIHtcbiAgICAgIHN0eWxlID0gY29tcG9uZW50U3RyaW5nLnNwbGl0KCc8c3R5bGU+JylbMV0uc3BsaXQoJzwvc3R5bGU+JylbMF07XG4gICAgfSBlbHNlIGlmIChjb21wb25lbnRTdHJpbmcuaW5kZXhPZignPHN0eWxlIHNjb3BlZD4nKSA+PSAwKSB7XG4gICAgICBzdHlsZSA9IGNvbXBvbmVudFN0cmluZy5zcGxpdCgnPHN0eWxlIHNjb3BlZD4nKVsxXS5zcGxpdCgnPC9zdHlsZT4nKVswXTtcbiAgICAgIHN0eWxlID0gc3R5bGUuc3BsaXQoJ1xcbicpLm1hcCgobGluZSkgPT4ge1xuICAgICAgICBpZiAobGluZS5pbmRleE9mKCd7JykgPj0gMCkge1xuICAgICAgICAgIGlmIChsaW5lLmluZGV4T2YoJ3t7dGhpc319JykgPj0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGxpbmUucmVwbGFjZSgne3t0aGlzfX0nLCBgW2RhdGEtc2NvcGU9XCIke3N0eWxlU2NvcGVJZH1cIl1gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGBbZGF0YS1zY29wZT1cIiR7c3R5bGVTY29wZUlkfVwiXSAke2xpbmUudHJpbSgpfWA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxpbmU7XG4gICAgICB9KS5qb2luKCdcXG4nKTtcbiAgICB9XG5cbiAgICBsZXQgc2NyaXB0Q29udGVudDtcbiAgICBpZiAoY29tcG9uZW50U3RyaW5nLmluZGV4T2YoJzxzY3JpcHQ+JykgPj0gMCkge1xuICAgICAgY29uc3Qgc2NyaXB0cyA9IGNvbXBvbmVudFN0cmluZy5zcGxpdCgnPHNjcmlwdD4nKTtcbiAgICAgIHNjcmlwdENvbnRlbnQgPSBzY3JpcHRzW3NjcmlwdHMubGVuZ3RoIC0gMV0uc3BsaXQoJzwvc2NyaXB0PicpWzBdLnRyaW0oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2NyaXB0Q29udGVudCA9ICdyZXR1cm4ge30nO1xuICAgIH1cbiAgICBzY3JpcHRDb250ZW50ID0gYHdpbmRvdy4ke2NhbGxiYWNrTmFtZX0gPSBmdW5jdGlvbiAoKSB7JHtzY3JpcHRDb250ZW50fX1gO1xuXG4gICAgLy8gSW5zZXJ0IFNjcmlwdCBFbFxuICAgIGNvbnN0IHNjcmlwdEVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgc2NyaXB0RWwuaW5uZXJIVE1MID0gc2NyaXB0Q29udGVudDtcbiAgICAkKCdoZWFkJykuYXBwZW5kKHNjcmlwdEVsKTtcblxuICAgIGNvbnN0IGNvbXBvbmVudCA9IHdpbmRvdyQxW2NhbGxiYWNrTmFtZV0oKTtcblxuICAgIC8vIFJlbW92ZSBTY3JpcHQgRWxcbiAgICAkKHNjcmlwdEVsKS5yZW1vdmUoKTtcblxuICAgIGlmICghY29tcG9uZW50LnRlbXBsYXRlICYmICFjb21wb25lbnQucmVuZGVyKSB7XG4gICAgICBjb21wb25lbnQudGVtcGxhdGUgPSB0ZW1wbGF0ZTtcbiAgICB9XG4gICAgaWYgKHN0eWxlKSB7XG4gICAgICBjb21wb25lbnQuc3R5bGUgPSBzdHlsZTtcbiAgICAgIGNvbXBvbmVudC5zdHlsZVNjb3BlSWQgPSBzdHlsZVNjb3BlSWQ7XG4gICAgfVxuICAgIHJldHVybiBjb21wb25lbnQ7XG4gIH0sXG4gIGNyZWF0ZShjLCBleHRlbmRDb250ZXh0ID0ge30pIHtcbiAgICByZXR1cm4gbmV3IEZyYW1ld29yazdDb21wb25lbnQoYywgZXh0ZW5kQ29udGV4dCk7XG4gIH0sXG59O1xuXG5jb25zdCBIaXN0b3J5ID0ge1xuICBxdWV1ZTogW10sXG4gIGNsZWFyUXVldWUoKSB7XG4gICAgaWYgKEhpc3RvcnkucXVldWUubGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgY29uc3QgY3VycmVudFF1ZXVlID0gSGlzdG9yeS5xdWV1ZS5zaGlmdCgpO1xuICAgIGN1cnJlbnRRdWV1ZSgpO1xuICB9LFxuICByb3V0ZXJRdWV1ZTogW10sXG4gIGNsZWFyUm91dGVyUXVldWUoKSB7XG4gICAgaWYgKEhpc3Rvcnkucm91dGVyUXVldWUubGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgY29uc3QgY3VycmVudFF1ZXVlID0gSGlzdG9yeS5yb3V0ZXJRdWV1ZS5wb3AoKTtcbiAgICBjb25zdCB7IHJvdXRlciwgc3RhdGVVcmwsIGFjdGlvbiB9ID0gY3VycmVudFF1ZXVlO1xuXG4gICAgbGV0IGFuaW1hdGUgPSByb3V0ZXIucGFyYW1zLmFuaW1hdGU7XG4gICAgaWYgKHJvdXRlci5wYXJhbXMucHVzaFN0YXRlQW5pbWF0ZSA9PT0gZmFsc2UpIGFuaW1hdGUgPSBmYWxzZTtcblxuICAgIGlmIChhY3Rpb24gPT09ICdiYWNrJykge1xuICAgICAgcm91dGVyLmJhY2soeyBhbmltYXRlLCBwdXNoU3RhdGU6IGZhbHNlIH0pO1xuICAgIH1cbiAgICBpZiAoYWN0aW9uID09PSAnbG9hZCcpIHtcbiAgICAgIHJvdXRlci5uYXZpZ2F0ZShzdGF0ZVVybCwgeyBhbmltYXRlLCBwdXNoU3RhdGU6IGZhbHNlIH0pO1xuICAgIH1cbiAgfSxcbiAgaGFuZGxlKGUpIHtcbiAgICBpZiAoSGlzdG9yeS5ibG9ja1BvcHN0YXRlKSByZXR1cm47XG4gICAgY29uc3QgYXBwID0gdGhpcztcbiAgICAvLyBjb25zdCBtYWluVmlldyA9IGFwcC52aWV3cy5tYWluO1xuICAgIGxldCBzdGF0ZSA9IGUuc3RhdGU7XG4gICAgSGlzdG9yeS5wcmV2aW91c1N0YXRlID0gSGlzdG9yeS5zdGF0ZTtcbiAgICBIaXN0b3J5LnN0YXRlID0gc3RhdGU7XG5cbiAgICBIaXN0b3J5LmFsbG93Q2hhbmdlID0gdHJ1ZTtcbiAgICBIaXN0b3J5LmNsZWFyUXVldWUoKTtcblxuICAgIHN0YXRlID0gSGlzdG9yeS5zdGF0ZTtcbiAgICBpZiAoIXN0YXRlKSBzdGF0ZSA9IHt9O1xuXG4gICAgYXBwLnZpZXdzLmZvckVhY2goKHZpZXcpID0+IHtcbiAgICAgIGNvbnN0IHJvdXRlciA9IHZpZXcucm91dGVyO1xuICAgICAgbGV0IHZpZXdTdGF0ZSA9IHN0YXRlW3ZpZXcuaWRdO1xuICAgICAgaWYgKCF2aWV3U3RhdGUgJiYgdmlldy5wYXJhbXMucHVzaFN0YXRlKSB7XG4gICAgICAgIHZpZXdTdGF0ZSA9IHtcbiAgICAgICAgICB1cmw6IHZpZXcucm91dGVyLmhpc3RvcnlbMF0sXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBpZiAoIXZpZXdTdGF0ZSkgcmV0dXJuO1xuICAgICAgY29uc3Qgc3RhdGVVcmwgPSB2aWV3U3RhdGUudXJsIHx8IHVuZGVmaW5lZDtcblxuICAgICAgbGV0IGFuaW1hdGUgPSByb3V0ZXIucGFyYW1zLmFuaW1hdGU7XG4gICAgICBpZiAocm91dGVyLnBhcmFtcy5wdXNoU3RhdGVBbmltYXRlID09PSBmYWxzZSkgYW5pbWF0ZSA9IGZhbHNlO1xuXG4gICAgICBpZiAoc3RhdGVVcmwgIT09IHJvdXRlci51cmwpIHtcbiAgICAgICAgaWYgKHJvdXRlci5oaXN0b3J5LmluZGV4T2Yoc3RhdGVVcmwpID49IDApIHtcbiAgICAgICAgICAvLyBHbyBCYWNrXG4gICAgICAgICAgaWYgKHJvdXRlci5hbGxvd1BhZ2VDaGFuZ2UpIHtcbiAgICAgICAgICAgIHJvdXRlci5iYWNrKHsgYW5pbWF0ZSwgcHVzaFN0YXRlOiBmYWxzZSB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgSGlzdG9yeS5yb3V0ZXJRdWV1ZS5wdXNoKHtcbiAgICAgICAgICAgICAgYWN0aW9uOiAnYmFjaycsXG4gICAgICAgICAgICAgIHJvdXRlcixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChyb3V0ZXIuYWxsb3dQYWdlQ2hhbmdlKSB7XG4gICAgICAgICAgLy8gTG9hZCBwYWdlXG4gICAgICAgICAgcm91dGVyLm5hdmlnYXRlKHN0YXRlVXJsLCB7IGFuaW1hdGUsIHB1c2hTdGF0ZTogZmFsc2UgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgSGlzdG9yeS5yb3V0ZXJRdWV1ZS51bnNoaWZ0KHtcbiAgICAgICAgICAgIGFjdGlvbjogJ2xvYWQnLFxuICAgICAgICAgICAgc3RhdGVVcmwsXG4gICAgICAgICAgICByb3V0ZXIsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcbiAgaW5pdFZpZXdTdGF0ZSh2aWV3SWQsIHZpZXdTdGF0ZSkge1xuICAgIGNvbnN0IG5ld1N0YXRlID0gVXRpbHMuZXh0ZW5kKHt9LCAoSGlzdG9yeS5zdGF0ZSB8fCB7fSksIHtcbiAgICAgIFt2aWV3SWRdOiB2aWV3U3RhdGUsXG4gICAgfSk7XG4gICAgSGlzdG9yeS5zdGF0ZSA9IG5ld1N0YXRlO1xuICAgIHdpbmRvdyQxLmhpc3RvcnkucmVwbGFjZVN0YXRlKG5ld1N0YXRlLCAnJyk7XG4gIH0sXG4gIHB1c2godmlld0lkLCB2aWV3U3RhdGUsIHVybCkge1xuICAgIGlmICghSGlzdG9yeS5hbGxvd0NoYW5nZSkge1xuICAgICAgSGlzdG9yeS5xdWV1ZS5wdXNoKCgpID0+IHtcbiAgICAgICAgSGlzdG9yeS5wdXNoKHZpZXdJZCwgdmlld1N0YXRlLCB1cmwpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIEhpc3RvcnkucHJldmlvdXNTdGF0ZSA9IEhpc3Rvcnkuc3RhdGU7XG4gICAgY29uc3QgbmV3U3RhdGUgPSBVdGlscy5leHRlbmQoe30sIChIaXN0b3J5LnByZXZpb3VzU3RhdGUgfHwge30pLCB7XG4gICAgICBbdmlld0lkXTogdmlld1N0YXRlLFxuICAgIH0pO1xuICAgIEhpc3Rvcnkuc3RhdGUgPSBuZXdTdGF0ZTtcbiAgICB3aW5kb3ckMS5oaXN0b3J5LnB1c2hTdGF0ZShuZXdTdGF0ZSwgJycsIHVybCk7XG4gIH0sXG4gIHJlcGxhY2Uodmlld0lkLCB2aWV3U3RhdGUsIHVybCkge1xuICAgIGlmICghSGlzdG9yeS5hbGxvd0NoYW5nZSkge1xuICAgICAgSGlzdG9yeS5xdWV1ZS5wdXNoKCgpID0+IHtcbiAgICAgICAgSGlzdG9yeS5yZXBsYWNlKHZpZXdJZCwgdmlld1N0YXRlLCB1cmwpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIEhpc3RvcnkucHJldmlvdXNTdGF0ZSA9IEhpc3Rvcnkuc3RhdGU7XG4gICAgY29uc3QgbmV3U3RhdGUgPSBVdGlscy5leHRlbmQoe30sIChIaXN0b3J5LnByZXZpb3VzU3RhdGUgfHwge30pLCB7XG4gICAgICBbdmlld0lkXTogdmlld1N0YXRlLFxuICAgIH0pO1xuICAgIEhpc3Rvcnkuc3RhdGUgPSBuZXdTdGF0ZTtcbiAgICB3aW5kb3ckMS5oaXN0b3J5LnJlcGxhY2VTdGF0ZShuZXdTdGF0ZSwgJycsIHVybCk7XG4gIH0sXG4gIGdvKGluZGV4KSB7XG4gICAgSGlzdG9yeS5hbGxvd0NoYW5nZSA9IGZhbHNlO1xuICAgIHdpbmRvdyQxLmhpc3RvcnkuZ28oaW5kZXgpO1xuICB9LFxuICBiYWNrKCkge1xuICAgIEhpc3RvcnkuYWxsb3dDaGFuZ2UgPSBmYWxzZTtcbiAgICB3aW5kb3ckMS5oaXN0b3J5LmJhY2soKTtcbiAgfSxcbiAgYWxsb3dDaGFuZ2U6IHRydWUsXG4gIHByZXZpb3VzU3RhdGU6IHt9LFxuICBzdGF0ZTogd2luZG93JDEuaGlzdG9yeS5zdGF0ZSxcbiAgYmxvY2tQb3BzdGF0ZTogdHJ1ZSxcbiAgaW5pdChhcHApIHtcbiAgICAkKHdpbmRvdyQxKS5vbignbG9hZCcsICgpID0+IHtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBIaXN0b3J5LmJsb2NrUG9wc3RhdGUgPSBmYWxzZTtcbiAgICAgIH0sIDApO1xuICAgIH0pO1xuXG4gICAgaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgJiYgZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gJ2NvbXBsZXRlJykge1xuICAgICAgSGlzdG9yeS5ibG9ja1BvcHN0YXRlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgJCh3aW5kb3ckMSkub24oJ3BvcHN0YXRlJywgSGlzdG9yeS5oYW5kbGUuYmluZChhcHApKTtcbiAgfSxcbn07XG5cbmZ1bmN0aW9uIFN3aXBlQmFjayhyKSB7XG4gIGNvbnN0IHJvdXRlciA9IHI7XG4gIGNvbnN0IHsgJGVsLCAkbmF2YmFyRWwsIGFwcCwgcGFyYW1zIH0gPSByb3V0ZXI7XG4gIGxldCBpc1RvdWNoZWQgPSBmYWxzZTtcbiAgbGV0IGlzTW92ZWQgPSBmYWxzZTtcbiAgY29uc3QgdG91Y2hlc1N0YXJ0ID0ge307XG4gIGxldCBpc1Njcm9sbGluZztcbiAgbGV0IGN1cnJlbnRQYWdlID0gW107XG4gIGxldCBwcmV2aW91c1BhZ2UgPSBbXTtcbiAgbGV0IHZpZXdDb250YWluZXJXaWR0aDtcbiAgbGV0IHRvdWNoZXNEaWZmO1xuICBsZXQgYWxsb3dWaWV3VG91Y2hNb3ZlID0gdHJ1ZTtcbiAgbGV0IHRvdWNoU3RhcnRUaW1lO1xuICBsZXQgY3VycmVudE5hdmJhciA9IFtdO1xuICBsZXQgcHJldmlvdXNOYXZiYXIgPSBbXTtcbiAgbGV0IGN1cnJlbnROYXZFbGVtZW50cztcbiAgbGV0IHByZXZpb3VzTmF2RWxlbWVudHM7XG4gIGxldCBhY3RpdmVOYXZCYWNrSWNvbjtcbiAgbGV0IGFjdGl2ZU5hdkJhY2tJY29uVGV4dDtcbiAgbGV0IHByZXZpb3VzTmF2QmFja0ljb247XG4gIC8vIGxldCBwcmV2aW91c05hdkJhY2tJY29uVGV4dDtcbiAgbGV0IGR5bmFtaWNOYXZiYXI7XG4gIGxldCBzZXBhcmF0ZU5hdmJhcjtcbiAgbGV0IHBhZ2VTaGFkb3c7XG4gIGxldCBwYWdlT3BhY2l0eTtcbiAgbGV0IG5hdmJhcldpZHRoO1xuXG4gIGNvbnN0IHBhcmFtc1N3aXBlQmFja0FuaW1hdGVTaGFkb3cgPSBwYXJhbXNbYCR7YXBwLnRoZW1lfVN3aXBlQmFja0FuaW1hdGVTaGFkb3dgXTtcbiAgY29uc3QgcGFyYW1zU3dpcGVCYWNrQW5pbWF0ZU9wYWNpdHkgPSBwYXJhbXNbYCR7YXBwLnRoZW1lfVN3aXBlQmFja0FuaW1hdGVPcGFjaXR5YF07XG4gIGNvbnN0IHBhcmFtc1N3aXBlQmFja0FjdGl2ZUFyZWEgPSBwYXJhbXNbYCR7YXBwLnRoZW1lfVN3aXBlQmFja0FjdGl2ZUFyZWFgXTtcbiAgY29uc3QgcGFyYW1zU3dpcGVCYWNrVGhyZXNob2xkID0gcGFyYW1zW2Ake2FwcC50aGVtZX1Td2lwZUJhY2tUaHJlc2hvbGRgXTtcblxuICBmdW5jdGlvbiBoYW5kbGVUb3VjaFN0YXJ0KGUpIHtcbiAgICBjb25zdCBzd2lwZUJhY2tFbmFibGVkID0gcGFyYW1zW2Ake2FwcC50aGVtZX1Td2lwZUJhY2tgXTtcbiAgICBpZiAoIWFsbG93Vmlld1RvdWNoTW92ZSB8fCAhc3dpcGVCYWNrRW5hYmxlZCB8fCBpc1RvdWNoZWQgfHwgKGFwcC5zd2lwZW91dCAmJiBhcHAuc3dpcGVvdXQuZWwpIHx8ICFyb3V0ZXIuYWxsb3dQYWdlQ2hhbmdlKSByZXR1cm47XG4gICAgaWYgKCQoZS50YXJnZXQpLmNsb3Nlc3QoJy5yYW5nZS1zbGlkZXIsIC5jYWxlbmRhci1tb250aHMnKS5sZW5ndGggPiAwKSByZXR1cm47XG4gICAgaXNNb3ZlZCA9IGZhbHNlO1xuICAgIGlzVG91Y2hlZCA9IHRydWU7XG4gICAgaXNTY3JvbGxpbmcgPSB1bmRlZmluZWQ7XG4gICAgdG91Y2hlc1N0YXJ0LnggPSBlLnR5cGUgPT09ICd0b3VjaHN0YXJ0JyA/IGUudGFyZ2V0VG91Y2hlc1swXS5wYWdlWCA6IGUucGFnZVg7XG4gICAgdG91Y2hlc1N0YXJ0LnkgPSBlLnR5cGUgPT09ICd0b3VjaHN0YXJ0JyA/IGUudGFyZ2V0VG91Y2hlc1swXS5wYWdlWSA6IGUucGFnZVk7XG4gICAgdG91Y2hTdGFydFRpbWUgPSBVdGlscy5ub3coKTtcbiAgICBkeW5hbWljTmF2YmFyID0gcm91dGVyLmR5bmFtaWNOYXZiYXI7XG4gICAgc2VwYXJhdGVOYXZiYXIgPSByb3V0ZXIuc2VwYXJhdGVOYXZiYXI7XG4gIH1cbiAgZnVuY3Rpb24gaGFuZGxlVG91Y2hNb3ZlKGUpIHtcbiAgICBpZiAoIWlzVG91Y2hlZCkgcmV0dXJuO1xuICAgIGNvbnN0IHBhZ2VYID0gZS50eXBlID09PSAndG91Y2htb3ZlJyA/IGUudGFyZ2V0VG91Y2hlc1swXS5wYWdlWCA6IGUucGFnZVg7XG4gICAgY29uc3QgcGFnZVkgPSBlLnR5cGUgPT09ICd0b3VjaG1vdmUnID8gZS50YXJnZXRUb3VjaGVzWzBdLnBhZ2VZIDogZS5wYWdlWTtcbiAgICBpZiAodHlwZW9mIGlzU2Nyb2xsaW5nID09PSAndW5kZWZpbmVkJykge1xuICAgICAgaXNTY3JvbGxpbmcgPSAhIShpc1Njcm9sbGluZyB8fCBNYXRoLmFicyhwYWdlWSAtIHRvdWNoZXNTdGFydC55KSA+IE1hdGguYWJzKHBhZ2VYIC0gdG91Y2hlc1N0YXJ0LngpKSB8fCBwYWdlWCA8IHRvdWNoZXNTdGFydC54O1xuICAgIH1cbiAgICBpZiAoaXNTY3JvbGxpbmcgfHwgZS5mN1ByZXZlbnRTd2lwZUJhY2sgfHwgYXBwLnByZXZlbnRTd2lwZUJhY2spIHtcbiAgICAgIGlzVG91Y2hlZCA9IGZhbHNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWlzTW92ZWQpIHtcbiAgICAgIC8vIENhbGMgdmFsdWVzIGR1cmluZyBmaXJzdCBtb3ZlIGZpcmVkXG4gICAgICBsZXQgY2FuY2VsID0gZmFsc2U7XG4gICAgICBjb25zdCB0YXJnZXQgPSAkKGUudGFyZ2V0KTtcblxuICAgICAgY29uc3Qgc3dpcGVvdXQgPSB0YXJnZXQuY2xvc2VzdCgnLnN3aXBlb3V0Jyk7XG4gICAgICBpZiAoc3dpcGVvdXQubGVuZ3RoID4gMCkge1xuICAgICAgICBpZiAoIWFwcC5ydGwgJiYgc3dpcGVvdXQuZmluZCgnLnN3aXBlb3V0LWFjdGlvbnMtbGVmdCcpLmxlbmd0aCA+IDApIGNhbmNlbCA9IHRydWU7XG4gICAgICAgIGlmIChhcHAucnRsICYmIHN3aXBlb3V0LmZpbmQoJy5zd2lwZW91dC1hY3Rpb25zLXJpZ2h0JykubGVuZ3RoID4gMCkgY2FuY2VsID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgY3VycmVudFBhZ2UgPSB0YXJnZXQuY2xvc2VzdCgnLnBhZ2UnKTtcbiAgICAgIGlmIChjdXJyZW50UGFnZS5oYXNDbGFzcygnbm8tc3dpcGViYWNrJykgfHwgdGFyZ2V0LmNsb3Nlc3QoJy5uby1zd2lwZWJhY2snKS5sZW5ndGggPiAwKSBjYW5jZWwgPSB0cnVlO1xuICAgICAgcHJldmlvdXNQYWdlID0gJGVsLmZpbmQoJy5wYWdlLXByZXZpb3VzOm5vdCguc3RhY2tlZCknKTtcblxuICAgICAgbGV0IG5vdEZyb21Cb3JkZXIgPSB0b3VjaGVzU3RhcnQueCAtICRlbC5vZmZzZXQoKS5sZWZ0ID4gcGFyYW1zU3dpcGVCYWNrQWN0aXZlQXJlYTtcbiAgICAgIHZpZXdDb250YWluZXJXaWR0aCA9ICRlbC53aWR0aCgpO1xuICAgICAgaWYgKGFwcC5ydGwpIHtcbiAgICAgICAgbm90RnJvbUJvcmRlciA9IHRvdWNoZXNTdGFydC54IDwgKCRlbC5vZmZzZXQoKS5sZWZ0IC0gJGVsWzBdLnNjcm9sbExlZnQpICsgKHZpZXdDb250YWluZXJXaWR0aCAtIHBhcmFtc1N3aXBlQmFja0FjdGl2ZUFyZWEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm90RnJvbUJvcmRlciA9IHRvdWNoZXNTdGFydC54IC0gJGVsLm9mZnNldCgpLmxlZnQgPiBwYXJhbXNTd2lwZUJhY2tBY3RpdmVBcmVhO1xuICAgICAgfVxuICAgICAgaWYgKG5vdEZyb21Cb3JkZXIpIGNhbmNlbCA9IHRydWU7XG4gICAgICBpZiAocHJldmlvdXNQYWdlLmxlbmd0aCA9PT0gMCB8fCBjdXJyZW50UGFnZS5sZW5ndGggPT09IDApIGNhbmNlbCA9IHRydWU7XG4gICAgICBpZiAoY2FuY2VsKSB7XG4gICAgICAgIGlzVG91Y2hlZCA9IGZhbHNlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChwYXJhbXNTd2lwZUJhY2tBbmltYXRlU2hhZG93KSB7XG4gICAgICAgIHBhZ2VTaGFkb3cgPSBjdXJyZW50UGFnZS5maW5kKCcucGFnZS1zaGFkb3ctZWZmZWN0Jyk7XG4gICAgICAgIGlmIChwYWdlU2hhZG93Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHBhZ2VTaGFkb3cgPSAkKCc8ZGl2IGNsYXNzPVwicGFnZS1zaGFkb3ctZWZmZWN0XCI+PC9kaXY+Jyk7XG4gICAgICAgICAgY3VycmVudFBhZ2UuYXBwZW5kKHBhZ2VTaGFkb3cpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocGFyYW1zU3dpcGVCYWNrQW5pbWF0ZU9wYWNpdHkpIHtcbiAgICAgICAgcGFnZU9wYWNpdHkgPSBwcmV2aW91c1BhZ2UuZmluZCgnLnBhZ2Utb3BhY2l0eS1lZmZlY3QnKTtcbiAgICAgICAgaWYgKHBhZ2VPcGFjaXR5Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHBhZ2VPcGFjaXR5ID0gJCgnPGRpdiBjbGFzcz1cInBhZ2Utb3BhY2l0eS1lZmZlY3RcIj48L2Rpdj4nKTtcbiAgICAgICAgICBwcmV2aW91c1BhZ2UuYXBwZW5kKHBhZ2VPcGFjaXR5KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZHluYW1pY05hdmJhcikge1xuICAgICAgICBpZiAoc2VwYXJhdGVOYXZiYXIpIHtcbiAgICAgICAgICBjdXJyZW50TmF2YmFyID0gJG5hdmJhckVsLmZpbmQoJy5uYXZiYXItY3VycmVudDpub3QoLnN0YWNrZWQpJyk7XG4gICAgICAgICAgcHJldmlvdXNOYXZiYXIgPSAkbmF2YmFyRWwuZmluZCgnLm5hdmJhci1wcmV2aW91czpub3QoLnN0YWNrZWQpJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3VycmVudE5hdmJhciA9IGN1cnJlbnRQYWdlLmNoaWxkcmVuKCcubmF2YmFyJykuY2hpbGRyZW4oJy5uYXZiYXItaW5uZXInKTtcbiAgICAgICAgICBwcmV2aW91c05hdmJhciA9IHByZXZpb3VzUGFnZS5jaGlsZHJlbignLm5hdmJhcicpLmNoaWxkcmVuKCcubmF2YmFyLWlubmVyJyk7XG4gICAgICAgIH1cbiAgICAgICAgbmF2YmFyV2lkdGggPSAkbmF2YmFyRWxbMF0ub2Zmc2V0V2lkdGg7XG4gICAgICAgIGN1cnJlbnROYXZFbGVtZW50cyA9IGN1cnJlbnROYXZiYXIuY2hpbGRyZW4oJy5sZWZ0LCAudGl0bGUsIC5yaWdodCwgLnN1Ym5hdmJhciwgLmZhZGluZycpO1xuICAgICAgICBwcmV2aW91c05hdkVsZW1lbnRzID0gcHJldmlvdXNOYXZiYXIuY2hpbGRyZW4oJy5sZWZ0LCAudGl0bGUsIC5yaWdodCwgLnN1Ym5hdmJhciwgLmZhZGluZycpO1xuICAgICAgICBpZiAocGFyYW1zLmlvc0FuaW1hdGVOYXZiYXJCYWNrSWNvbikge1xuICAgICAgICAgIGlmIChjdXJyZW50TmF2YmFyLmhhc0NsYXNzKCdzbGlkaW5nJykpIHtcbiAgICAgICAgICAgIGFjdGl2ZU5hdkJhY2tJY29uID0gY3VycmVudE5hdmJhci5jaGlsZHJlbignLmxlZnQnKS5maW5kKCcuYmFjayAuaWNvbicpO1xuICAgICAgICAgICAgYWN0aXZlTmF2QmFja0ljb25UZXh0ID0gY3VycmVudE5hdmJhci5jaGlsZHJlbignLmxlZnQnKS5maW5kKCcuYmFjayBzcGFuJykuZXEoMCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFjdGl2ZU5hdkJhY2tJY29uID0gY3VycmVudE5hdmJhci5jaGlsZHJlbignLmxlZnQuc2xpZGluZycpLmZpbmQoJy5iYWNrIC5pY29uJyk7XG4gICAgICAgICAgICBhY3RpdmVOYXZCYWNrSWNvblRleHQgPSBjdXJyZW50TmF2YmFyLmNoaWxkcmVuKCcubGVmdC5zbGlkaW5nJykuZmluZCgnLmJhY2sgc3BhbicpLmVxKDApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocHJldmlvdXNOYXZiYXIuaGFzQ2xhc3MoJ3NsaWRpbmcnKSkge1xuICAgICAgICAgICAgcHJldmlvdXNOYXZCYWNrSWNvbiA9IHByZXZpb3VzTmF2YmFyLmNoaWxkcmVuKCcubGVmdCcpLmZpbmQoJy5iYWNrIC5pY29uJyk7XG4gICAgICAgICAgICAvLyBwcmV2aW91c05hdkJhY2tJY29uVGV4dCA9IHByZXZpb3VzTmF2YmFyLmNoaWxkcmVuKCdsZWZ0JykuZmluZCgnLmJhY2sgc3BhbicpLmVxKDApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcmV2aW91c05hdkJhY2tJY29uID0gcHJldmlvdXNOYXZiYXIuY2hpbGRyZW4oJy5sZWZ0LnNsaWRpbmcnKS5maW5kKCcuYmFjayAuaWNvbicpO1xuICAgICAgICAgICAgLy8gcHJldmlvdXNOYXZCYWNrSWNvblRleHQgPSBwcmV2aW91c05hdmJhci5jaGlsZHJlbignLmxlZnQuc2xpZGluZycpLmZpbmQoJy5iYWNrIHNwYW4nKS5lcSgwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQ2xvc2UvSGlkZSBBbnkgUGlja2VyXG4gICAgICBpZiAoJCgnLnNoZWV0Lm1vZGFsLWluJykubGVuZ3RoID4gMCAmJiBhcHAuc2hlZXQpIHtcbiAgICAgICAgYXBwLnNoZWV0LmNsb3NlKCQoJy5zaGVldC5tb2RhbC1pbicpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZS5mN1ByZXZlbnRQYW5lbFN3aXBlID0gdHJ1ZTtcbiAgICBpc01vdmVkID0gdHJ1ZTtcbiAgICBhcHAucHJldmVudFN3aXBlUGFuZWxCeVN3aXBlQmFjayA9IHRydWU7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgLy8gUlRMIGludmVydGVyXG4gICAgY29uc3QgaW52ZXJ0ZXIgPSBhcHAucnRsID8gLTEgOiAxO1xuXG4gICAgLy8gVG91Y2hlcyBkaWZmXG4gICAgdG91Y2hlc0RpZmYgPSAocGFnZVggLSB0b3VjaGVzU3RhcnQueCAtIHBhcmFtc1N3aXBlQmFja1RocmVzaG9sZCkgKiBpbnZlcnRlcjtcbiAgICBpZiAodG91Y2hlc0RpZmYgPCAwKSB0b3VjaGVzRGlmZiA9IDA7XG4gICAgY29uc3QgcGVyY2VudGFnZSA9IHRvdWNoZXNEaWZmIC8gdmlld0NvbnRhaW5lcldpZHRoO1xuXG4gICAgLy8gU3dpcGUgQmFjayBDYWxsYmFja1xuICAgIGNvbnN0IGNhbGxiYWNrRGF0YSA9IHtcbiAgICAgIHBlcmNlbnRhZ2UsXG4gICAgICBjdXJyZW50UGFnZUVsOiBjdXJyZW50UGFnZVswXSxcbiAgICAgIHByZXZpb3VzUGFnZUVsOiBwcmV2aW91c1BhZ2VbMF0sXG4gICAgICBjdXJyZW50TmF2YmFyRWw6IGN1cnJlbnROYXZiYXJbMF0sXG4gICAgICBwcmV2aW91c05hdmJhckVsOiBwcmV2aW91c05hdmJhclswXSxcbiAgICB9O1xuICAgICRlbC50cmlnZ2VyKCdzd2lwZWJhY2s6bW92ZScsIGNhbGxiYWNrRGF0YSk7XG4gICAgcm91dGVyLmVtaXQoJ3N3aXBlYmFja01vdmUnLCBjYWxsYmFja0RhdGEpO1xuXG4gICAgLy8gVHJhbnNmb3JtIHBhZ2VzXG4gICAgbGV0IGN1cnJlbnRQYWdlVHJhbnNsYXRlID0gdG91Y2hlc0RpZmYgKiBpbnZlcnRlcjtcbiAgICBsZXQgcHJldmlvdXNQYWdlVHJhbnNsYXRlID0gKCh0b3VjaGVzRGlmZiAvIDUpIC0gKHZpZXdDb250YWluZXJXaWR0aCAvIDUpKSAqIGludmVydGVyO1xuICAgIGlmIChEZXZpY2UucGl4ZWxSYXRpbyA9PT0gMSkge1xuICAgICAgY3VycmVudFBhZ2VUcmFuc2xhdGUgPSBNYXRoLnJvdW5kKGN1cnJlbnRQYWdlVHJhbnNsYXRlKTtcbiAgICAgIHByZXZpb3VzUGFnZVRyYW5zbGF0ZSA9IE1hdGgucm91bmQocHJldmlvdXNQYWdlVHJhbnNsYXRlKTtcbiAgICB9XG5cbiAgICBjdXJyZW50UGFnZS50cmFuc2Zvcm0oYHRyYW5zbGF0ZTNkKCR7Y3VycmVudFBhZ2VUcmFuc2xhdGV9cHgsMCwwKWApO1xuICAgIGlmIChwYXJhbXNTd2lwZUJhY2tBbmltYXRlU2hhZG93KSBwYWdlU2hhZG93WzBdLnN0eWxlLm9wYWNpdHkgPSAxIC0gKDEgKiBwZXJjZW50YWdlKTtcblxuICAgIGlmIChhcHAudGhlbWUgIT09ICdtZCcpIHtcbiAgICAgIHByZXZpb3VzUGFnZS50cmFuc2Zvcm0oYHRyYW5zbGF0ZTNkKCR7cHJldmlvdXNQYWdlVHJhbnNsYXRlfXB4LDAsMClgKTtcbiAgICB9XG4gICAgaWYgKHBhcmFtc1N3aXBlQmFja0FuaW1hdGVPcGFjaXR5KSBwYWdlT3BhY2l0eVswXS5zdHlsZS5vcGFjaXR5ID0gMSAtICgxICogcGVyY2VudGFnZSk7XG5cbiAgICAvLyBEeW5hbWljIE5hdmJhcnMgQW5pbWF0aW9uXG4gICAgaWYgKGR5bmFtaWNOYXZiYXIpIHtcbiAgICAgIGN1cnJlbnROYXZFbGVtZW50cy5lYWNoKChpbmRleCwgbmF2RWwpID0+IHtcbiAgICAgICAgY29uc3QgJG5hdkVsID0gJChuYXZFbCk7XG4gICAgICAgIGlmICghJG5hdkVsLmlzKCcuc3VibmF2YmFyJykpICRuYXZFbFswXS5zdHlsZS5vcGFjaXR5ID0gKDEgLSAocGVyY2VudGFnZSAqKiAwLjMzKSk7XG4gICAgICAgIGlmICgkbmF2RWxbMF0uY2xhc3NOYW1lLmluZGV4T2YoJ3NsaWRpbmcnKSA+PSAwIHx8IGN1cnJlbnROYXZiYXIuaGFzQ2xhc3MoJ3NsaWRpbmcnKSkge1xuICAgICAgICAgIGxldCBhY3RpdmVOYXZUcmFuc2xhdGUgPSBwZXJjZW50YWdlICogJG5hdkVsWzBdLmY3TmF2YmFyUmlnaHRPZmZzZXQ7XG4gICAgICAgICAgaWYgKERldmljZS5waXhlbFJhdGlvID09PSAxKSBhY3RpdmVOYXZUcmFuc2xhdGUgPSBNYXRoLnJvdW5kKGFjdGl2ZU5hdlRyYW5zbGF0ZSk7XG4gICAgICAgICAgJG5hdkVsLnRyYW5zZm9ybShgdHJhbnNsYXRlM2QoJHthY3RpdmVOYXZUcmFuc2xhdGV9cHgsMCwwKWApO1xuICAgICAgICAgIGlmIChwYXJhbXMuaW9zQW5pbWF0ZU5hdmJhckJhY2tJY29uKSB7XG4gICAgICAgICAgICBpZiAoJG5hdkVsWzBdLmNsYXNzTmFtZS5pbmRleE9mKCdsZWZ0JykgPj0gMCAmJiBhY3RpdmVOYXZCYWNrSWNvbi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIGxldCBpY29uVHJhbnNsYXRlID0gLWFjdGl2ZU5hdlRyYW5zbGF0ZTtcbiAgICAgICAgICAgICAgaWYgKCFzZXBhcmF0ZU5hdmJhcikge1xuICAgICAgICAgICAgICAgIGljb25UcmFuc2xhdGUgLT0gbmF2YmFyV2lkdGggKiBwZXJjZW50YWdlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGFjdGl2ZU5hdkJhY2tJY29uLnRyYW5zZm9ybShgdHJhbnNsYXRlM2QoJHtpY29uVHJhbnNsYXRlfXB4LDAsMClgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcHJldmlvdXNOYXZFbGVtZW50cy5lYWNoKChpbmRleCwgbmF2RWwpID0+IHtcbiAgICAgICAgY29uc3QgJG5hdkVsID0gJChuYXZFbCk7XG4gICAgICAgIGlmICghJG5hdkVsLmlzKCcuc3VibmF2YmFyJykpICRuYXZFbFswXS5zdHlsZS5vcGFjaXR5ID0gKHBlcmNlbnRhZ2UgKiogMyk7XG4gICAgICAgIGlmICgkbmF2RWxbMF0uY2xhc3NOYW1lLmluZGV4T2YoJ3NsaWRpbmcnKSA+PSAwIHx8IHByZXZpb3VzTmF2YmFyLmhhc0NsYXNzKCdzbGlkaW5nJykpIHtcbiAgICAgICAgICBsZXQgcHJldmlvdXNOYXZUcmFuc2xhdGUgPSAkbmF2RWxbMF0uZjdOYXZiYXJMZWZ0T2Zmc2V0ICogKDEgLSBwZXJjZW50YWdlKTtcbiAgICAgICAgICBpZiAoJG5hdkVsWzBdLmNsYXNzTmFtZS5pbmRleE9mKCd0aXRsZScpID49IDAgJiYgYWN0aXZlTmF2QmFja0ljb24gJiYgYWN0aXZlTmF2QmFja0ljb24ubGVuZ3RoICYmIGFjdGl2ZU5hdkJhY2tJY29uVGV4dC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHByZXZpb3VzTmF2VHJhbnNsYXRlID0gKCRuYXZFbFswXS5mN05hdmJhckxlZnRPZmZzZXQgKyBhY3RpdmVOYXZCYWNrSWNvblRleHRbMF0ub2Zmc2V0TGVmdCkgKiAoMSAtIHBlcmNlbnRhZ2UpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcmV2aW91c05hdlRyYW5zbGF0ZSA9ICRuYXZFbFswXS5mN05hdmJhckxlZnRPZmZzZXQgKiAoMSAtIHBlcmNlbnRhZ2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoRGV2aWNlLnBpeGVsUmF0aW8gPT09IDEpIHByZXZpb3VzTmF2VHJhbnNsYXRlID0gTWF0aC5yb3VuZChwcmV2aW91c05hdlRyYW5zbGF0ZSk7XG4gICAgICAgICAgJG5hdkVsLnRyYW5zZm9ybShgdHJhbnNsYXRlM2QoJHtwcmV2aW91c05hdlRyYW5zbGF0ZX1weCwwLDApYCk7XG4gICAgICAgICAgaWYgKHBhcmFtcy5pb3NBbmltYXRlTmF2YmFyQmFja0ljb24pIHtcbiAgICAgICAgICAgIGlmICgkbmF2RWxbMF0uY2xhc3NOYW1lLmluZGV4T2YoJ2xlZnQnKSA+PSAwICYmIHByZXZpb3VzTmF2QmFja0ljb24ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICBsZXQgaWNvblRyYW5zbGF0ZSA9IC1wcmV2aW91c05hdlRyYW5zbGF0ZTtcbiAgICAgICAgICAgICAgaWYgKCFzZXBhcmF0ZU5hdmJhcikge1xuICAgICAgICAgICAgICAgIGljb25UcmFuc2xhdGUgKz0gKG5hdmJhcldpZHRoIC8gNSkgKiAoMSAtIHBlcmNlbnRhZ2UpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHByZXZpb3VzTmF2QmFja0ljb24udHJhbnNmb3JtKGB0cmFuc2xhdGUzZCgke2ljb25UcmFuc2xhdGV9cHgsMCwwKWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGhhbmRsZVRvdWNoRW5kKCkge1xuICAgIGFwcC5wcmV2ZW50U3dpcGVQYW5lbEJ5U3dpcGVCYWNrID0gZmFsc2U7XG4gICAgaWYgKCFpc1RvdWNoZWQgfHwgIWlzTW92ZWQpIHtcbiAgICAgIGlzVG91Y2hlZCA9IGZhbHNlO1xuICAgICAgaXNNb3ZlZCA9IGZhbHNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpc1RvdWNoZWQgPSBmYWxzZTtcbiAgICBpc01vdmVkID0gZmFsc2U7XG4gICAgaWYgKHRvdWNoZXNEaWZmID09PSAwKSB7XG4gICAgICAkKFtjdXJyZW50UGFnZVswXSwgcHJldmlvdXNQYWdlWzBdXSkudHJhbnNmb3JtKCcnKTtcbiAgICAgIGlmIChwYWdlU2hhZG93ICYmIHBhZ2VTaGFkb3cubGVuZ3RoID4gMCkgcGFnZVNoYWRvdy5yZW1vdmUoKTtcbiAgICAgIGlmIChwYWdlT3BhY2l0eSAmJiBwYWdlT3BhY2l0eS5sZW5ndGggPiAwKSBwYWdlT3BhY2l0eS5yZW1vdmUoKTtcbiAgICAgIGlmIChkeW5hbWljTmF2YmFyKSB7XG4gICAgICAgIGN1cnJlbnROYXZFbGVtZW50cy50cmFuc2Zvcm0oJycpLmNzcyh7IG9wYWNpdHk6ICcnIH0pO1xuICAgICAgICBwcmV2aW91c05hdkVsZW1lbnRzLnRyYW5zZm9ybSgnJykuY3NzKHsgb3BhY2l0eTogJycgfSk7XG4gICAgICAgIGlmIChhY3RpdmVOYXZCYWNrSWNvbiAmJiBhY3RpdmVOYXZCYWNrSWNvbi5sZW5ndGggPiAwKSBhY3RpdmVOYXZCYWNrSWNvbi50cmFuc2Zvcm0oJycpO1xuICAgICAgICBpZiAocHJldmlvdXNOYXZCYWNrSWNvbiAmJiBhY3RpdmVOYXZCYWNrSWNvbi5sZW5ndGggPiAwKSBwcmV2aW91c05hdkJhY2tJY29uLnRyYW5zZm9ybSgnJyk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHRpbWVEaWZmID0gVXRpbHMubm93KCkgLSB0b3VjaFN0YXJ0VGltZTtcbiAgICBsZXQgcGFnZUNoYW5nZWQgPSBmYWxzZTtcbiAgICAvLyBTd2lwZSBiYWNrIHRvIHByZXZpb3VzIHBhZ2VcbiAgICBpZiAoXG4gICAgICAodGltZURpZmYgPCAzMDAgJiYgdG91Y2hlc0RpZmYgPiAxMCkgfHxcbiAgICAgICh0aW1lRGlmZiA+PSAzMDAgJiYgdG91Y2hlc0RpZmYgPiB2aWV3Q29udGFpbmVyV2lkdGggLyAyKVxuICAgICkge1xuICAgICAgY3VycmVudFBhZ2UucmVtb3ZlQ2xhc3MoJ3BhZ2UtY3VycmVudCcpLmFkZENsYXNzKGBwYWdlLW5leHQke2FwcC50aGVtZSA9PT0gJ21kJyA/ICcgcGFnZS1uZXh0LW9uLXJpZ2h0JyA6ICcnfWApO1xuICAgICAgcHJldmlvdXNQYWdlLnJlbW92ZUNsYXNzKCdwYWdlLXByZXZpb3VzJykuYWRkQ2xhc3MoJ3BhZ2UtY3VycmVudCcpLnJlbW92ZUF0dHIoJ2FyaWEtaGlkZGVuJyk7XG4gICAgICBpZiAocGFnZVNoYWRvdykgcGFnZVNoYWRvd1swXS5zdHlsZS5vcGFjaXR5ID0gJyc7XG4gICAgICBpZiAocGFnZU9wYWNpdHkpIHBhZ2VPcGFjaXR5WzBdLnN0eWxlLm9wYWNpdHkgPSAnJztcbiAgICAgIGlmIChkeW5hbWljTmF2YmFyKSB7XG4gICAgICAgIGN1cnJlbnROYXZiYXIucmVtb3ZlQ2xhc3MoJ25hdmJhci1jdXJyZW50JykuYWRkQ2xhc3MoJ25hdmJhci1uZXh0Jyk7XG4gICAgICAgIHByZXZpb3VzTmF2YmFyLnJlbW92ZUNsYXNzKCduYXZiYXItcHJldmlvdXMnKS5hZGRDbGFzcygnbmF2YmFyLWN1cnJlbnQnKS5yZW1vdmVBdHRyKCdhcmlhLWhpZGRlbicpO1xuICAgICAgfVxuICAgICAgcGFnZUNoYW5nZWQgPSB0cnVlO1xuICAgIH1cbiAgICAvLyBSZXNldCBjdXN0b20gc3R5bGVzXG4gICAgLy8gQWRkIHRyYW5zaXRpb25pbmcgY2xhc3MgZm9yIHRyYW5zaXRpb24tZHVyYXRpb25cbiAgICAkKFtjdXJyZW50UGFnZVswXSwgcHJldmlvdXNQYWdlWzBdXSkuYWRkQ2xhc3MoJ3BhZ2UtdHJhbnNpdGlvbmluZyBwYWdlLXRyYW5zaXRpb25pbmctc3dpcGViYWNrJykudHJhbnNmb3JtKCcnKTtcblxuICAgIGlmIChkeW5hbWljTmF2YmFyKSB7XG4gICAgICBjdXJyZW50TmF2RWxlbWVudHMuY3NzKHsgb3BhY2l0eTogJycgfSlcbiAgICAgICAgLmVhY2goKG5hdkVsSW5kZXgsIG5hdkVsKSA9PiB7XG4gICAgICAgICAgY29uc3QgdHJhbnNsYXRlID0gcGFnZUNoYW5nZWQgPyBuYXZFbC5mN05hdmJhclJpZ2h0T2Zmc2V0IDogMDtcbiAgICAgICAgICBjb25zdCBzbGlkaW5nID0gJChuYXZFbCk7XG4gICAgICAgICAgbGV0IGljb25UcmFuc2xhdGUgPSBwYWdlQ2hhbmdlZCA/IC10cmFuc2xhdGUgOiAwO1xuICAgICAgICAgIGlmICghc2VwYXJhdGVOYXZiYXIgJiYgcGFnZUNoYW5nZWQpIGljb25UcmFuc2xhdGUgLT0gbmF2YmFyV2lkdGg7XG4gICAgICAgICAgc2xpZGluZy50cmFuc2Zvcm0oYHRyYW5zbGF0ZTNkKCR7dHJhbnNsYXRlfXB4LDAsMClgKTtcbiAgICAgICAgICBpZiAocGFyYW1zLmlvc0FuaW1hdGVOYXZiYXJCYWNrSWNvbikge1xuICAgICAgICAgICAgaWYgKHNsaWRpbmcuaGFzQ2xhc3MoJ2xlZnQnKSAmJiBhY3RpdmVOYXZCYWNrSWNvbi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIGFjdGl2ZU5hdkJhY2tJY29uLmFkZENsYXNzKCduYXZiYXItdHJhbnNpdGlvbmluZycpLnRyYW5zZm9ybShgdHJhbnNsYXRlM2QoJHtpY29uVHJhbnNsYXRlfXB4LDAsMClgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pLmFkZENsYXNzKCduYXZiYXItdHJhbnNpdGlvbmluZycpO1xuXG4gICAgICBwcmV2aW91c05hdkVsZW1lbnRzLnRyYW5zZm9ybSgnJykuY3NzKHsgb3BhY2l0eTogJycgfSkuZWFjaCgobmF2RWxJbmRleCwgbmF2RWwpID0+IHtcbiAgICAgICAgY29uc3QgdHJhbnNsYXRlID0gcGFnZUNoYW5nZWQgPyAwIDogbmF2RWwuZjdOYXZiYXJMZWZ0T2Zmc2V0O1xuICAgICAgICBjb25zdCBzbGlkaW5nID0gJChuYXZFbCk7XG4gICAgICAgIGxldCBpY29uVHJhbnNsYXRlID0gcGFnZUNoYW5nZWQgPyAwIDogLXRyYW5zbGF0ZTtcbiAgICAgICAgaWYgKCFzZXBhcmF0ZU5hdmJhciAmJiAhcGFnZUNoYW5nZWQpIGljb25UcmFuc2xhdGUgKz0gbmF2YmFyV2lkdGggLyA1O1xuICAgICAgICBzbGlkaW5nLnRyYW5zZm9ybShgdHJhbnNsYXRlM2QoJHt0cmFuc2xhdGV9cHgsMCwwKWApO1xuICAgICAgICBpZiAocGFyYW1zLmlvc0FuaW1hdGVOYXZiYXJCYWNrSWNvbikge1xuICAgICAgICAgIGlmIChzbGlkaW5nLmhhc0NsYXNzKCdsZWZ0JykgJiYgcHJldmlvdXNOYXZCYWNrSWNvbi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBwcmV2aW91c05hdkJhY2tJY29uLmFkZENsYXNzKCduYXZiYXItdHJhbnNpdGlvbmluZycpLnRyYW5zZm9ybShgdHJhbnNsYXRlM2QoJHtpY29uVHJhbnNsYXRlfXB4LDAsMClgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pLmFkZENsYXNzKCduYXZiYXItdHJhbnNpdGlvbmluZycpO1xuICAgIH1cbiAgICBhbGxvd1ZpZXdUb3VjaE1vdmUgPSBmYWxzZTtcbiAgICByb3V0ZXIuYWxsb3dQYWdlQ2hhbmdlID0gZmFsc2U7XG5cbiAgICAvLyBTd2lwZSBCYWNrIENhbGxiYWNrXG4gICAgY29uc3QgY2FsbGJhY2tEYXRhID0ge1xuICAgICAgY3VycmVudFBhZ2U6IGN1cnJlbnRQYWdlWzBdLFxuICAgICAgcHJldmlvdXNQYWdlOiBwcmV2aW91c1BhZ2VbMF0sXG4gICAgICBjdXJyZW50TmF2YmFyOiBjdXJyZW50TmF2YmFyWzBdLFxuICAgICAgcHJldmlvdXNOYXZiYXI6IHByZXZpb3VzTmF2YmFyWzBdLFxuICAgIH07XG5cbiAgICBpZiAocGFnZUNoYW5nZWQpIHtcbiAgICAgIC8vIFVwZGF0ZSBSb3V0ZVxuICAgICAgcm91dGVyLmN1cnJlbnRSb3V0ZSA9IHByZXZpb3VzUGFnZVswXS5mN1BhZ2Uucm91dGU7XG4gICAgICByb3V0ZXIuY3VycmVudFBhZ2UgPSBwcmV2aW91c1BhZ2VbMF07XG5cbiAgICAgIC8vIFBhZ2UgYmVmb3JlIGFuaW1hdGlvbiBjYWxsYmFja1xuICAgICAgcm91dGVyLnBhZ2VDYWxsYmFjaygnYmVmb3JlT3V0JywgY3VycmVudFBhZ2UsIGN1cnJlbnROYXZiYXIsICdjdXJyZW50JywgJ25leHQnLCB7IHJvdXRlOiBjdXJyZW50UGFnZVswXS5mN1BhZ2Uucm91dGUsIHN3aXBlQmFjazogdHJ1ZSB9KTtcbiAgICAgIHJvdXRlci5wYWdlQ2FsbGJhY2soJ2JlZm9yZUluJywgcHJldmlvdXNQYWdlLCBwcmV2aW91c05hdmJhciwgJ3ByZXZpb3VzJywgJ2N1cnJlbnQnLCB7IHJvdXRlOiBwcmV2aW91c1BhZ2VbMF0uZjdQYWdlLnJvdXRlLCBzd2lwZUJhY2s6IHRydWUgfSk7XG5cbiAgICAgICRlbC50cmlnZ2VyKCdzd2lwZWJhY2s6YmVmb3JlY2hhbmdlJywgY2FsbGJhY2tEYXRhKTtcbiAgICAgIHJvdXRlci5lbWl0KCdzd2lwZWJhY2tCZWZvcmVDaGFuZ2UnLCBjYWxsYmFja0RhdGEpO1xuICAgIH0gZWxzZSB7XG4gICAgICAkZWwudHJpZ2dlcignc3dpcGViYWNrOmJlZm9yZXJlc2V0JywgY2FsbGJhY2tEYXRhKTtcbiAgICAgIHJvdXRlci5lbWl0KCdzd2lwZWJhY2tCZWZvcmVSZXNldCcsIGNhbGxiYWNrRGF0YSk7XG4gICAgfVxuXG4gICAgY3VycmVudFBhZ2UudHJhbnNpdGlvbkVuZCgoKSA9PiB7XG4gICAgICAkKFtjdXJyZW50UGFnZVswXSwgcHJldmlvdXNQYWdlWzBdXSkucmVtb3ZlQ2xhc3MoJ3BhZ2UtdHJhbnNpdGlvbmluZyBwYWdlLXRyYW5zaXRpb25pbmctc3dpcGViYWNrJyk7XG5cbiAgICAgIGlmIChkeW5hbWljTmF2YmFyKSB7XG4gICAgICAgIGN1cnJlbnROYXZFbGVtZW50cy5yZW1vdmVDbGFzcygnbmF2YmFyLXRyYW5zaXRpb25pbmcnKS5jc3MoeyBvcGFjaXR5OiAnJyB9KS50cmFuc2Zvcm0oJycpO1xuICAgICAgICBwcmV2aW91c05hdkVsZW1lbnRzLnJlbW92ZUNsYXNzKCduYXZiYXItdHJhbnNpdGlvbmluZycpLmNzcyh7IG9wYWNpdHk6ICcnIH0pLnRyYW5zZm9ybSgnJyk7XG4gICAgICAgIGlmIChhY3RpdmVOYXZCYWNrSWNvbiAmJiBhY3RpdmVOYXZCYWNrSWNvbi5sZW5ndGggPiAwKSBhY3RpdmVOYXZCYWNrSWNvbi5yZW1vdmVDbGFzcygnbmF2YmFyLXRyYW5zaXRpb25pbmcnKTtcbiAgICAgICAgaWYgKHByZXZpb3VzTmF2QmFja0ljb24gJiYgcHJldmlvdXNOYXZCYWNrSWNvbi5sZW5ndGggPiAwKSBwcmV2aW91c05hdkJhY2tJY29uLnJlbW92ZUNsYXNzKCduYXZiYXItdHJhbnNpdGlvbmluZycpO1xuICAgICAgfVxuICAgICAgYWxsb3dWaWV3VG91Y2hNb3ZlID0gdHJ1ZTtcbiAgICAgIHJvdXRlci5hbGxvd1BhZ2VDaGFuZ2UgPSB0cnVlO1xuICAgICAgaWYgKHBhZ2VDaGFuZ2VkKSB7XG4gICAgICAgIC8vIFVwZGF0ZSBIaXN0b3J5XG4gICAgICAgIGlmIChyb3V0ZXIuaGlzdG9yeS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICByb3V0ZXIuaGlzdG9yeS51bnNoaWZ0KHJvdXRlci51cmwpO1xuICAgICAgICB9XG4gICAgICAgIHJvdXRlci5oaXN0b3J5LnBvcCgpO1xuICAgICAgICByb3V0ZXIuc2F2ZUhpc3RvcnkoKTtcblxuICAgICAgICAvLyBVcGRhdGUgcHVzaCBzdGF0ZVxuICAgICAgICBpZiAocGFyYW1zLnB1c2hTdGF0ZSkge1xuICAgICAgICAgIEhpc3RvcnkuYmFjaygpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUGFnZSBhZnRlciBhbmltYXRpb24gY2FsbGJhY2tcbiAgICAgICAgcm91dGVyLnBhZ2VDYWxsYmFjaygnYWZ0ZXJPdXQnLCBjdXJyZW50UGFnZSwgY3VycmVudE5hdmJhciwgJ2N1cnJlbnQnLCAnbmV4dCcsIHsgcm91dGU6IGN1cnJlbnRQYWdlWzBdLmY3UGFnZS5yb3V0ZSwgc3dpcGVCYWNrOiB0cnVlIH0pO1xuICAgICAgICByb3V0ZXIucGFnZUNhbGxiYWNrKCdhZnRlckluJywgcHJldmlvdXNQYWdlLCBwcmV2aW91c05hdmJhciwgJ3ByZXZpb3VzJywgJ2N1cnJlbnQnLCB7IHJvdXRlOiBwcmV2aW91c1BhZ2VbMF0uZjdQYWdlLnJvdXRlLCBzd2lwZUJhY2s6IHRydWUgfSk7XG5cbiAgICAgICAgLy8gUmVtb3ZlIE9sZCBQYWdlXG4gICAgICAgIGlmIChwYXJhbXMuc3RhY2tQYWdlcyAmJiByb3V0ZXIuaW5pdGlhbFBhZ2VzLmluZGV4T2YoY3VycmVudFBhZ2VbMF0pID49IDApIHtcbiAgICAgICAgICBjdXJyZW50UGFnZS5hZGRDbGFzcygnc3RhY2tlZCcpO1xuICAgICAgICAgIGlmIChzZXBhcmF0ZU5hdmJhcikge1xuICAgICAgICAgICAgY3VycmVudE5hdmJhci5hZGRDbGFzcygnc3RhY2tlZCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByb3V0ZXIucGFnZUNhbGxiYWNrKCdiZWZvcmVSZW1vdmUnLCBjdXJyZW50UGFnZSwgY3VycmVudE5hdmJhciwgJ25leHQnLCB7IHN3aXBlQmFjazogdHJ1ZSB9KTtcbiAgICAgICAgICByb3V0ZXIucmVtb3ZlUGFnZShjdXJyZW50UGFnZSk7XG4gICAgICAgICAgaWYgKHNlcGFyYXRlTmF2YmFyKSB7XG4gICAgICAgICAgICByb3V0ZXIucmVtb3ZlTmF2YmFyKGN1cnJlbnROYXZiYXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgICRlbC50cmlnZ2VyKCdzd2lwZWJhY2s6YWZ0ZXJjaGFuZ2UnLCBjYWxsYmFja0RhdGEpO1xuICAgICAgICByb3V0ZXIuZW1pdCgnc3dpcGViYWNrQWZ0ZXJDaGFuZ2UnLCBjYWxsYmFja0RhdGEpO1xuXG4gICAgICAgIHJvdXRlci5lbWl0KCdyb3V0ZUNoYW5nZWQnLCByb3V0ZXIuY3VycmVudFJvdXRlLCByb3V0ZXIucHJldmlvdXNSb3V0ZSwgcm91dGVyKTtcblxuICAgICAgICBpZiAocGFyYW1zLnByZWxvYWRQcmV2aW91c1BhZ2UpIHtcbiAgICAgICAgICByb3V0ZXIuYmFjayhyb3V0ZXIuaGlzdG9yeVtyb3V0ZXIuaGlzdG9yeS5sZW5ndGggLSAyXSwgeyBwcmVsb2FkOiB0cnVlIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAkZWwudHJpZ2dlcignc3dpcGViYWNrOmFmdGVycmVzZXQnLCBjYWxsYmFja0RhdGEpO1xuICAgICAgICByb3V0ZXIuZW1pdCgnc3dpcGViYWNrQWZ0ZXJSZXNldCcsIGNhbGxiYWNrRGF0YSk7XG4gICAgICB9XG4gICAgICBpZiAocGFnZVNoYWRvdyAmJiBwYWdlU2hhZG93Lmxlbmd0aCA+IDApIHBhZ2VTaGFkb3cucmVtb3ZlKCk7XG4gICAgICBpZiAocGFnZU9wYWNpdHkgJiYgcGFnZU9wYWNpdHkubGVuZ3RoID4gMCkgcGFnZU9wYWNpdHkucmVtb3ZlKCk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBhdHRhY2hFdmVudHMoKSB7XG4gICAgY29uc3QgcGFzc2l2ZUxpc3RlbmVyID0gKGFwcC50b3VjaEV2ZW50cy5zdGFydCA9PT0gJ3RvdWNoc3RhcnQnICYmIFN1cHBvcnQucGFzc2l2ZUxpc3RlbmVyKSA/IHsgcGFzc2l2ZTogdHJ1ZSwgY2FwdHVyZTogZmFsc2UgfSA6IGZhbHNlO1xuICAgICRlbC5vbihhcHAudG91Y2hFdmVudHMuc3RhcnQsIGhhbmRsZVRvdWNoU3RhcnQsIHBhc3NpdmVMaXN0ZW5lcik7XG4gICAgYXBwLm9uKCd0b3VjaG1vdmU6YWN0aXZlJywgaGFuZGxlVG91Y2hNb3ZlKTtcbiAgICBhcHAub24oJ3RvdWNoZW5kOnBhc3NpdmUnLCBoYW5kbGVUb3VjaEVuZCk7XG4gIH1cbiAgZnVuY3Rpb24gZGV0YWNoRXZlbnRzKCkge1xuICAgIGNvbnN0IHBhc3NpdmVMaXN0ZW5lciA9IChhcHAudG91Y2hFdmVudHMuc3RhcnQgPT09ICd0b3VjaHN0YXJ0JyAmJiBTdXBwb3J0LnBhc3NpdmVMaXN0ZW5lcikgPyB7IHBhc3NpdmU6IHRydWUsIGNhcHR1cmU6IGZhbHNlIH0gOiBmYWxzZTtcbiAgICAkZWwub2ZmKGFwcC50b3VjaEV2ZW50cy5zdGFydCwgaGFuZGxlVG91Y2hTdGFydCwgcGFzc2l2ZUxpc3RlbmVyKTtcbiAgICBhcHAub2ZmKCd0b3VjaG1vdmU6YWN0aXZlJywgaGFuZGxlVG91Y2hNb3ZlKTtcbiAgICBhcHAub2ZmKCd0b3VjaGVuZDpwYXNzaXZlJywgaGFuZGxlVG91Y2hFbmQpO1xuICB9XG5cbiAgYXR0YWNoRXZlbnRzKCk7XG5cbiAgcm91dGVyLm9uKCdyb3V0ZXJEZXN0cm95JywgZGV0YWNoRXZlbnRzKTtcbn1cblxuZnVuY3Rpb24gcmVkaXJlY3QgKGRpcmVjdGlvbiwgcm91dGUsIG9wdGlvbnMpIHtcbiAgY29uc3Qgcm91dGVyID0gdGhpcztcbiAgY29uc3QgcmVkaXJlY3QgPSByb3V0ZS5yb3V0ZS5yZWRpcmVjdDtcbiAgaWYgKG9wdGlvbnMuaW5pdGlhbCAmJiByb3V0ZXIucGFyYW1zLnB1c2hTdGF0ZSkge1xuICAgIG9wdGlvbnMucmVwbGFjZVN0YXRlID0gdHJ1ZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIG9wdGlvbnMuaGlzdG9yeSA9IHRydWU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgfVxuICBmdW5jdGlvbiByZWRpcmVjdFJlc29sdmUocmVkaXJlY3RVcmwsIHJlZGlyZWN0T3B0aW9ucyA9IHt9KSB7XG4gICAgcm91dGVyLmFsbG93UGFnZUNoYW5nZSA9IHRydWU7XG4gICAgcm91dGVyW2RpcmVjdGlvbl0ocmVkaXJlY3RVcmwsIFV0aWxzLmV4dGVuZCh7fSwgb3B0aW9ucywgcmVkaXJlY3RPcHRpb25zKSk7XG4gIH1cbiAgZnVuY3Rpb24gcmVkaXJlY3RSZWplY3QoKSB7XG4gICAgcm91dGVyLmFsbG93UGFnZUNoYW5nZSA9IHRydWU7XG4gIH1cbiAgaWYgKHR5cGVvZiByZWRpcmVjdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJvdXRlci5hbGxvd1BhZ2VDaGFuZ2UgPSBmYWxzZTtcbiAgICBjb25zdCByZWRpcmVjdFVybCA9IHJlZGlyZWN0LmNhbGwocm91dGVyLCByb3V0ZSwgcmVkaXJlY3RSZXNvbHZlLCByZWRpcmVjdFJlamVjdCk7XG4gICAgaWYgKHJlZGlyZWN0VXJsICYmIHR5cGVvZiByZWRpcmVjdFVybCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJvdXRlci5hbGxvd1BhZ2VDaGFuZ2UgPSB0cnVlO1xuICAgICAgcmV0dXJuIHJvdXRlcltkaXJlY3Rpb25dKHJlZGlyZWN0VXJsLCBvcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIHJvdXRlcjtcbiAgfVxuICByZXR1cm4gcm91dGVyW2RpcmVjdGlvbl0ocmVkaXJlY3QsIG9wdGlvbnMpO1xufVxuXG5mdW5jdGlvbiByZWZyZXNoUGFnZSgpIHtcbiAgY29uc3Qgcm91dGVyID0gdGhpcztcbiAgcmV0dXJuIHJvdXRlci5uYXZpZ2F0ZShyb3V0ZXIuY3VycmVudFJvdXRlLnVybCwge1xuICAgIGlnbm9yZUNhY2hlOiB0cnVlLFxuICAgIHJlbG9hZEN1cnJlbnQ6IHRydWUsXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBmb3J3YXJkKGVsLCBmb3J3YXJkT3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHJvdXRlciA9IHRoaXM7XG4gIGNvbnN0IGFwcCA9IHJvdXRlci5hcHA7XG4gIGNvbnN0IHZpZXcgPSByb3V0ZXIudmlldztcblxuICBjb25zdCBvcHRpb25zID0gVXRpbHMuZXh0ZW5kKHtcbiAgICBhbmltYXRlOiByb3V0ZXIucGFyYW1zLmFuaW1hdGUsXG4gICAgcHVzaFN0YXRlOiB0cnVlLFxuICAgIHJlcGxhY2VTdGF0ZTogZmFsc2UsXG4gICAgaGlzdG9yeTogdHJ1ZSxcbiAgICByZWxvYWRDdXJyZW50OiByb3V0ZXIucGFyYW1zLnJlbG9hZFBhZ2VzLFxuICAgIHJlbG9hZFByZXZpb3VzOiBmYWxzZSxcbiAgICByZWxvYWRBbGw6IGZhbHNlLFxuICAgIGNsZWFyUHJldmlvdXNIaXN0b3J5OiBmYWxzZSxcbiAgICBvbjoge30sXG4gIH0sIGZvcndhcmRPcHRpb25zKTtcblxuICBjb25zdCBkeW5hbWljTmF2YmFyID0gcm91dGVyLmR5bmFtaWNOYXZiYXI7XG4gIGNvbnN0IHNlcGFyYXRlTmF2YmFyID0gcm91dGVyLnNlcGFyYXRlTmF2YmFyO1xuXG4gIGNvbnN0ICR2aWV3RWwgPSByb3V0ZXIuJGVsO1xuICBjb25zdCAkbmV3UGFnZSA9ICQoZWwpO1xuICBjb25zdCByZWxvYWQgPSBvcHRpb25zLnJlbG9hZFByZXZpb3VzIHx8IG9wdGlvbnMucmVsb2FkQ3VycmVudCB8fCBvcHRpb25zLnJlbG9hZEFsbDtcbiAgbGV0ICRvbGRQYWdlO1xuXG4gIGxldCAkbmF2YmFyRWw7XG4gIGxldCAkbmV3TmF2YmFySW5uZXI7XG4gIGxldCAkb2xkTmF2YmFySW5uZXI7XG5cbiAgaWYgKCRuZXdQYWdlLmxlbmd0aCkge1xuICAgIC8vIFJlbW92ZSB0aGVtZSBlbGVtZW50c1xuICAgIHJvdXRlci5yZW1vdmVUaGVtZUVsZW1lbnRzKCRuZXdQYWdlKTtcbiAgfVxuXG4gIGlmIChkeW5hbWljTmF2YmFyKSB7XG4gICAgJG5ld05hdmJhcklubmVyID0gJG5ld1BhZ2UuY2hpbGRyZW4oJy5uYXZiYXInKS5jaGlsZHJlbignLm5hdmJhci1pbm5lcicpO1xuICAgIGlmIChzZXBhcmF0ZU5hdmJhcikge1xuICAgICAgJG5hdmJhckVsID0gcm91dGVyLiRuYXZiYXJFbDtcbiAgICAgIGlmICgkbmV3TmF2YmFySW5uZXIubGVuZ3RoID4gMCkge1xuICAgICAgICAkbmV3UGFnZS5jaGlsZHJlbignLm5hdmJhcicpLnJlbW92ZSgpO1xuICAgICAgfVxuICAgICAgaWYgKCRuZXdOYXZiYXJJbm5lci5sZW5ndGggPT09IDAgJiYgJG5ld1BhZ2VbMF0uZjdQYWdlKSB7XG4gICAgICAgIC8vIFRyeSBmcm9tIHBhZ2VEYXRhXG4gICAgICAgICRuZXdOYXZiYXJJbm5lciA9ICRuZXdQYWdlWzBdLmY3UGFnZS4kbmF2YmFyRWw7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcm91dGVyLmFsbG93UGFnZUNoYW5nZSA9IGZhbHNlO1xuICBpZiAoJG5ld1BhZ2UubGVuZ3RoID09PSAwKSB7XG4gICAgcm91dGVyLmFsbG93UGFnZUNoYW5nZSA9IHRydWU7XG4gICAgcmV0dXJuIHJvdXRlcjtcbiAgfVxuXG4gIC8vIFBhZ2VzIEluIFZpZXdcbiAgY29uc3QgJHBhZ2VzSW5WaWV3ID0gJHZpZXdFbFxuICAgIC5jaGlsZHJlbignLnBhZ2U6bm90KC5zdGFja2VkKScpXG4gICAgLmZpbHRlcigoaW5kZXgsIHBhZ2VJblZpZXcpID0+IHBhZ2VJblZpZXcgIT09ICRuZXdQYWdlWzBdKTtcblxuICAvLyBOYXZiYXJzIEluIFZpZXdcbiAgbGV0ICRuYXZiYXJzSW5WaWV3O1xuICBpZiAoc2VwYXJhdGVOYXZiYXIpIHtcbiAgICAkbmF2YmFyc0luVmlldyA9ICRuYXZiYXJFbFxuICAgICAgLmNoaWxkcmVuKCcubmF2YmFyLWlubmVyOm5vdCguc3RhY2tlZCknKVxuICAgICAgLmZpbHRlcigoaW5kZXgsIG5hdmJhckluVmlldykgPT4gbmF2YmFySW5WaWV3ICE9PSAkbmV3TmF2YmFySW5uZXJbMF0pO1xuICB9XG5cbiAgLy8gRXhpdCB3aGVuIHJlbG9hZCBwcmV2aW91cyBhbmQgb25seSAxIHBhZ2UgaW4gdmlldyBzbyBub3RoaW5nIHJvIHJlbG9hZFxuICBpZiAob3B0aW9ucy5yZWxvYWRQcmV2aW91cyAmJiAkcGFnZXNJblZpZXcubGVuZ3RoIDwgMikge1xuICAgIHJvdXRlci5hbGxvd1BhZ2VDaGFuZ2UgPSB0cnVlO1xuICAgIHJldHVybiByb3V0ZXI7XG4gIH1cblxuICAvLyBOZXcgUGFnZVxuICBsZXQgbmV3UGFnZVBvc2l0aW9uID0gJ25leHQnO1xuICBpZiAob3B0aW9ucy5yZWxvYWRDdXJyZW50IHx8IG9wdGlvbnMucmVsb2FkQWxsKSB7XG4gICAgbmV3UGFnZVBvc2l0aW9uID0gJ2N1cnJlbnQnO1xuICB9IGVsc2UgaWYgKG9wdGlvbnMucmVsb2FkUHJldmlvdXMpIHtcbiAgICBuZXdQYWdlUG9zaXRpb24gPSAncHJldmlvdXMnO1xuICB9XG4gICRuZXdQYWdlXG4gICAgLmFkZENsYXNzKGBwYWdlLSR7bmV3UGFnZVBvc2l0aW9ufWApXG4gICAgLnJlbW92ZUNsYXNzKCdzdGFja2VkJyk7XG5cbiAgaWYgKGR5bmFtaWNOYXZiYXIgJiYgJG5ld05hdmJhcklubmVyLmxlbmd0aCkge1xuICAgICRuZXdOYXZiYXJJbm5lclxuICAgICAgLmFkZENsYXNzKGBuYXZiYXItJHtuZXdQYWdlUG9zaXRpb259YClcbiAgICAgIC5yZW1vdmVDbGFzcygnc3RhY2tlZCcpO1xuICB9XG5cbiAgLy8gRmluZCBPbGQgUGFnZVxuICBpZiAob3B0aW9ucy5yZWxvYWRDdXJyZW50KSB7XG4gICAgJG9sZFBhZ2UgPSAkcGFnZXNJblZpZXcuZXEoJHBhZ2VzSW5WaWV3Lmxlbmd0aCAtIDEpO1xuICAgIGlmIChzZXBhcmF0ZU5hdmJhcikge1xuICAgICAgLy8gJG9sZE5hdmJhcklubmVyID0gJG5hdmJhcnNJblZpZXcuZXEoJHBhZ2VzSW5WaWV3Lmxlbmd0aCAtIDEpO1xuICAgICAgJG9sZE5hdmJhcklubmVyID0gJChhcHAubmF2YmFyLmdldEVsQnlQYWdlKCRvbGRQYWdlKSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKG9wdGlvbnMucmVsb2FkUHJldmlvdXMpIHtcbiAgICAkb2xkUGFnZSA9ICRwYWdlc0luVmlldy5lcSgkcGFnZXNJblZpZXcubGVuZ3RoIC0gMik7XG4gICAgaWYgKHNlcGFyYXRlTmF2YmFyKSB7XG4gICAgICAvLyAkb2xkTmF2YmFySW5uZXIgPSAkbmF2YmFyc0luVmlldy5lcSgkcGFnZXNJblZpZXcubGVuZ3RoIC0gMik7XG4gICAgICAkb2xkTmF2YmFySW5uZXIgPSAkKGFwcC5uYXZiYXIuZ2V0RWxCeVBhZ2UoJG9sZFBhZ2UpKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAob3B0aW9ucy5yZWxvYWRBbGwpIHtcbiAgICAkb2xkUGFnZSA9ICRwYWdlc0luVmlldy5maWx0ZXIoKGluZGV4LCBwYWdlRWwpID0+IHBhZ2VFbCAhPT0gJG5ld1BhZ2VbMF0pO1xuICAgIGlmIChzZXBhcmF0ZU5hdmJhcikge1xuICAgICAgJG9sZE5hdmJhcklubmVyID0gJG5hdmJhcnNJblZpZXcuZmlsdGVyKChpbmRleCwgbmF2YmFyRWwpID0+IG5hdmJhckVsICE9PSAkbmV3TmF2YmFySW5uZXJbMF0pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoJHBhZ2VzSW5WaWV3Lmxlbmd0aCA+IDEpIHtcbiAgICAgIGxldCBpID0gMDtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCAkcGFnZXNJblZpZXcubGVuZ3RoIC0gMTsgaSArPSAxKSB7XG4gICAgICAgIGNvbnN0IG9sZE5hdmJhcklubmVyRWwgPSBhcHAubmF2YmFyLmdldEVsQnlQYWdlKCRwYWdlc0luVmlldy5lcShpKSk7XG4gICAgICAgIGlmIChyb3V0ZXIucGFyYW1zLnN0YWNrUGFnZXMpIHtcbiAgICAgICAgICAkcGFnZXNJblZpZXcuZXEoaSkuYWRkQ2xhc3MoJ3N0YWNrZWQnKTtcbiAgICAgICAgICBpZiAoc2VwYXJhdGVOYXZiYXIpIHtcbiAgICAgICAgICAgIC8vICRuYXZiYXJzSW5WaWV3LmVxKGkpLmFkZENsYXNzKCdzdGFja2VkJyk7XG4gICAgICAgICAgICAkKG9sZE5hdmJhcklubmVyRWwpLmFkZENsYXNzKCdzdGFja2VkJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFBhZ2UgcmVtb3ZlIGV2ZW50XG4gICAgICAgICAgcm91dGVyLnBhZ2VDYWxsYmFjaygnYmVmb3JlUmVtb3ZlJywgJHBhZ2VzSW5WaWV3W2ldLCAkbmF2YmFyc0luVmlldyAmJiAkbmF2YmFyc0luVmlld1tpXSwgJ3ByZXZpb3VzJywgdW5kZWZpbmVkLCBvcHRpb25zKTtcbiAgICAgICAgICByb3V0ZXIucmVtb3ZlUGFnZSgkcGFnZXNJblZpZXdbaV0pO1xuICAgICAgICAgIGlmIChzZXBhcmF0ZU5hdmJhciAmJiBvbGROYXZiYXJJbm5lckVsKSB7XG4gICAgICAgICAgICByb3V0ZXIucmVtb3ZlTmF2YmFyKG9sZE5hdmJhcklubmVyRWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAkb2xkUGFnZSA9ICR2aWV3RWxcbiAgICAgIC5jaGlsZHJlbignLnBhZ2U6bm90KC5zdGFja2VkKScpXG4gICAgICAuZmlsdGVyKChpbmRleCwgcGFnZSkgPT4gcGFnZSAhPT0gJG5ld1BhZ2VbMF0pO1xuICAgIGlmIChzZXBhcmF0ZU5hdmJhcikge1xuICAgICAgJG9sZE5hdmJhcklubmVyID0gJG5hdmJhckVsXG4gICAgICAgIC5jaGlsZHJlbignLm5hdmJhci1pbm5lcjpub3QoLnN0YWNrZWQpJylcbiAgICAgICAgLmZpbHRlcigoaW5kZXgsIG5hdmJhcklubmVyKSA9PiBuYXZiYXJJbm5lciAhPT0gJG5ld05hdmJhcklubmVyWzBdKTtcbiAgICB9XG4gIH1cbiAgaWYgKGR5bmFtaWNOYXZiYXIgJiYgIXNlcGFyYXRlTmF2YmFyKSB7XG4gICAgJG9sZE5hdmJhcklubmVyID0gJG9sZFBhZ2UuY2hpbGRyZW4oJy5uYXZiYXInKS5jaGlsZHJlbignLm5hdmJhci1pbm5lcicpO1xuICB9XG5cbiAgLy8gUHVzaCBTdGF0ZVxuICBpZiAocm91dGVyLnBhcmFtcy5wdXNoU3RhdGUgJiYgKG9wdGlvbnMucHVzaFN0YXRlIHx8IG9wdGlvbnMucmVwbGFjZVN0YXRlKSAmJiAhb3B0aW9ucy5yZWxvYWRQcmV2aW91cykge1xuICAgIGNvbnN0IHB1c2hTdGF0ZVJvb3QgPSByb3V0ZXIucGFyYW1zLnB1c2hTdGF0ZVJvb3QgfHwgJyc7XG4gICAgSGlzdG9yeVtvcHRpb25zLnJlbG9hZEN1cnJlbnQgfHwgb3B0aW9ucy5yZWxvYWRBbGwgfHwgb3B0aW9ucy5yZXBsYWNlU3RhdGUgPyAncmVwbGFjZScgOiAncHVzaCddKFxuICAgICAgdmlldy5pZCxcbiAgICAgIHtcbiAgICAgICAgdXJsOiBvcHRpb25zLnJvdXRlLnVybCxcbiAgICAgIH0sXG4gICAgICBwdXNoU3RhdGVSb290ICsgcm91dGVyLnBhcmFtcy5wdXNoU3RhdGVTZXBhcmF0b3IgKyBvcHRpb25zLnJvdXRlLnVybFxuICAgICk7XG4gIH1cblxuICBpZiAoIW9wdGlvbnMucmVsb2FkUHJldmlvdXMpIHtcbiAgICAvLyBDdXJyZW50IFBhZ2UgJiBOYXZiYXJcbiAgICByb3V0ZXIuY3VycmVudFBhZ2VFbCA9ICRuZXdQYWdlWzBdO1xuICAgIGlmIChkeW5hbWljTmF2YmFyICYmICRuZXdOYXZiYXJJbm5lci5sZW5ndGgpIHtcbiAgICAgIHJvdXRlci5jdXJyZW50TmF2YmFyRWwgPSAkbmV3TmF2YmFySW5uZXJbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSByb3V0ZXIuY3VycmVudE5hdmJhckVsO1xuICAgIH1cblxuICAgIC8vIEN1cnJlbnQgUm91dGVcbiAgICByb3V0ZXIuY3VycmVudFJvdXRlID0gb3B0aW9ucy5yb3V0ZTtcbiAgfVxuXG4gIC8vIFVwZGF0ZSByb3V0ZXIgaGlzdG9yeVxuICBjb25zdCB1cmwgPSBvcHRpb25zLnJvdXRlLnVybDtcblxuICBpZiAob3B0aW9ucy5oaXN0b3J5KSB7XG4gICAgaWYgKChvcHRpb25zLnJlbG9hZEN1cnJlbnQgJiYgcm91dGVyLmhpc3RvcnkubGVuZ3RoKSA+IDAgfHwgb3B0aW9ucy5yZXBsYWNlU3RhdGUpIHtcbiAgICAgIHJvdXRlci5oaXN0b3J5W3JvdXRlci5oaXN0b3J5Lmxlbmd0aCAtIChvcHRpb25zLnJlbG9hZFByZXZpb3VzID8gMiA6IDEpXSA9IHVybDtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMucmVsb2FkUHJldmlvdXMpIHtcbiAgICAgIHJvdXRlci5oaXN0b3J5W3JvdXRlci5oaXN0b3J5Lmxlbmd0aCAtIDJdID0gdXJsO1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5yZWxvYWRBbGwpIHtcbiAgICAgIHJvdXRlci5oaXN0b3J5ID0gW3VybF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJvdXRlci5oaXN0b3J5LnB1c2godXJsKTtcbiAgICB9XG4gIH1cbiAgcm91dGVyLnNhdmVIaXN0b3J5KCk7XG5cbiAgLy8gSW5zZXJ0IG5ldyBwYWdlIGFuZCBuYXZiYXJcbiAgY29uc3QgbmV3UGFnZUluRG9tID0gJG5ld1BhZ2UucGFyZW50cyhkb2N1bWVudCkubGVuZ3RoID4gMDtcbiAgY29uc3QgZjdDb21wb25lbnQgPSAkbmV3UGFnZVswXS5mN0NvbXBvbmVudDtcbiAgaWYgKG9wdGlvbnMucmVsb2FkUHJldmlvdXMpIHtcbiAgICBpZiAoZjdDb21wb25lbnQgJiYgIW5ld1BhZ2VJbkRvbSkge1xuICAgICAgZjdDb21wb25lbnQuJG1vdW50KChjb21wb25lbnRFbCkgPT4ge1xuICAgICAgICAkKGNvbXBvbmVudEVsKS5pbnNlcnRCZWZvcmUoJG9sZFBhZ2UpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICRuZXdQYWdlLmluc2VydEJlZm9yZSgkb2xkUGFnZSk7XG4gICAgfVxuICAgIGlmIChzZXBhcmF0ZU5hdmJhciAmJiAkbmV3TmF2YmFySW5uZXIubGVuZ3RoKSB7XG4gICAgICBpZiAoJG9sZE5hdmJhcklubmVyLmxlbmd0aCkge1xuICAgICAgICAkbmV3TmF2YmFySW5uZXIuaW5zZXJ0QmVmb3JlKCRvbGROYXZiYXJJbm5lcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIXJvdXRlci4kbmF2YmFyRWwucGFyZW50cyhkb2N1bWVudCkubGVuZ3RoKSB7XG4gICAgICAgICAgcm91dGVyLiRlbC5wcmVwZW5kKHJvdXRlci4kbmF2YmFyRWwpO1xuICAgICAgICB9XG4gICAgICAgICRuYXZiYXJFbC5hcHBlbmQoJG5ld05hdmJhcklubmVyKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKCRvbGRQYWdlLm5leHQoJy5wYWdlJylbMF0gIT09ICRuZXdQYWdlWzBdKSB7XG4gICAgICBpZiAoZjdDb21wb25lbnQgJiYgIW5ld1BhZ2VJbkRvbSkge1xuICAgICAgICBmN0NvbXBvbmVudC4kbW91bnQoKGNvbXBvbmVudEVsKSA9PiB7XG4gICAgICAgICAgJHZpZXdFbC5hcHBlbmQoY29tcG9uZW50RWwpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICR2aWV3RWwuYXBwZW5kKCRuZXdQYWdlWzBdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNlcGFyYXRlTmF2YmFyICYmICRuZXdOYXZiYXJJbm5lci5sZW5ndGgpIHtcbiAgICAgIGlmICghcm91dGVyLiRuYXZiYXJFbC5wYXJlbnRzKGRvY3VtZW50KS5sZW5ndGgpIHtcbiAgICAgICAgcm91dGVyLiRlbC5wcmVwZW5kKHJvdXRlci4kbmF2YmFyRWwpO1xuICAgICAgfVxuICAgICAgJG5hdmJhckVsLmFwcGVuZCgkbmV3TmF2YmFySW5uZXJbMF0pO1xuICAgIH1cbiAgfVxuICBpZiAoIW5ld1BhZ2VJbkRvbSkge1xuICAgIHJvdXRlci5wYWdlQ2FsbGJhY2soJ21vdW50ZWQnLCAkbmV3UGFnZSwgJG5ld05hdmJhcklubmVyLCBuZXdQYWdlUG9zaXRpb24sIHJlbG9hZCA/IG5ld1BhZ2VQb3NpdGlvbiA6ICdjdXJyZW50Jywgb3B0aW9ucywgJG9sZFBhZ2UpO1xuICB9XG5cbiAgLy8gUmVtb3ZlIG9sZCBwYWdlXG4gIGlmIChvcHRpb25zLnJlbG9hZEN1cnJlbnQgJiYgJG9sZFBhZ2UubGVuZ3RoID4gMCkge1xuICAgIGlmIChyb3V0ZXIucGFyYW1zLnN0YWNrUGFnZXMgJiYgcm91dGVyLmluaXRpYWxQYWdlcy5pbmRleE9mKCRvbGRQYWdlWzBdKSA+PSAwKSB7XG4gICAgICAkb2xkUGFnZS5hZGRDbGFzcygnc3RhY2tlZCcpO1xuICAgICAgaWYgKHNlcGFyYXRlTmF2YmFyKSB7XG4gICAgICAgICRvbGROYXZiYXJJbm5lci5hZGRDbGFzcygnc3RhY2tlZCcpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBQYWdlIHJlbW92ZSBldmVudFxuICAgICAgcm91dGVyLnBhZ2VDYWxsYmFjaygnYmVmb3JlUmVtb3ZlJywgJG9sZFBhZ2UsICRvbGROYXZiYXJJbm5lciwgJ3ByZXZpb3VzJywgdW5kZWZpbmVkLCBvcHRpb25zKTtcbiAgICAgIHJvdXRlci5yZW1vdmVQYWdlKCRvbGRQYWdlKTtcbiAgICAgIGlmIChzZXBhcmF0ZU5hdmJhciAmJiAkb2xkTmF2YmFySW5uZXIgJiYgJG9sZE5hdmJhcklubmVyLmxlbmd0aCkge1xuICAgICAgICByb3V0ZXIucmVtb3ZlTmF2YmFyKCRvbGROYXZiYXJJbm5lcik7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKG9wdGlvbnMucmVsb2FkQWxsKSB7XG4gICAgJG9sZFBhZ2UuZWFjaCgoaW5kZXgsIHBhZ2VFbCkgPT4ge1xuICAgICAgY29uc3QgJG9sZFBhZ2VFbCA9ICQocGFnZUVsKTtcbiAgICAgIGNvbnN0ICRvbGROYXZiYXJJbm5lckVsID0gJChhcHAubmF2YmFyLmdldEVsQnlQYWdlKCRvbGRQYWdlRWwpKTtcbiAgICAgIGlmIChyb3V0ZXIucGFyYW1zLnN0YWNrUGFnZXMgJiYgcm91dGVyLmluaXRpYWxQYWdlcy5pbmRleE9mKCRvbGRQYWdlRWxbMF0pID49IDApIHtcbiAgICAgICAgJG9sZFBhZ2VFbC5hZGRDbGFzcygnc3RhY2tlZCcpO1xuICAgICAgICBpZiAoc2VwYXJhdGVOYXZiYXIpIHtcbiAgICAgICAgICAkb2xkTmF2YmFySW5uZXJFbC5hZGRDbGFzcygnc3RhY2tlZCcpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBQYWdlIHJlbW92ZSBldmVudFxuICAgICAgICByb3V0ZXIucGFnZUNhbGxiYWNrKCdiZWZvcmVSZW1vdmUnLCAkb2xkUGFnZUVsLCAkb2xkTmF2YmFySW5uZXIgJiYgJG9sZE5hdmJhcklubmVyLmVxKGluZGV4KSwgJ3ByZXZpb3VzJywgdW5kZWZpbmVkLCBvcHRpb25zKTtcbiAgICAgICAgcm91dGVyLnJlbW92ZVBhZ2UoJG9sZFBhZ2VFbCk7XG4gICAgICAgIGlmIChzZXBhcmF0ZU5hdmJhciAmJiAkb2xkTmF2YmFySW5uZXJFbC5sZW5ndGgpIHtcbiAgICAgICAgICByb3V0ZXIucmVtb3ZlTmF2YmFyKCRvbGROYXZiYXJJbm5lckVsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9IGVsc2UgaWYgKG9wdGlvbnMucmVsb2FkUHJldmlvdXMpIHtcbiAgICBpZiAocm91dGVyLnBhcmFtcy5zdGFja1BhZ2VzICYmIHJvdXRlci5pbml0aWFsUGFnZXMuaW5kZXhPZigkb2xkUGFnZVswXSkgPj0gMCkge1xuICAgICAgJG9sZFBhZ2UuYWRkQ2xhc3MoJ3N0YWNrZWQnKTtcbiAgICAgIGlmIChzZXBhcmF0ZU5hdmJhcikge1xuICAgICAgICAkb2xkTmF2YmFySW5uZXIuYWRkQ2xhc3MoJ3N0YWNrZWQnKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUGFnZSByZW1vdmUgZXZlbnRcbiAgICAgIHJvdXRlci5wYWdlQ2FsbGJhY2soJ2JlZm9yZVJlbW92ZScsICRvbGRQYWdlLCAkb2xkTmF2YmFySW5uZXIsICdwcmV2aW91cycsIHVuZGVmaW5lZCwgb3B0aW9ucyk7XG4gICAgICByb3V0ZXIucmVtb3ZlUGFnZSgkb2xkUGFnZSk7XG4gICAgICBpZiAoc2VwYXJhdGVOYXZiYXIgJiYgJG9sZE5hdmJhcklubmVyICYmICRvbGROYXZiYXJJbm5lci5sZW5ndGgpIHtcbiAgICAgICAgcm91dGVyLnJlbW92ZU5hdmJhcigkb2xkTmF2YmFySW5uZXIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIExvYWQgVGFiXG4gIGlmIChvcHRpb25zLnJvdXRlLnJvdXRlLnRhYikge1xuICAgIHJvdXRlci50YWJMb2FkKG9wdGlvbnMucm91dGUucm91dGUudGFiLCBVdGlscy5leHRlbmQoe30sIG9wdGlvbnMsIHtcbiAgICAgIGhpc3Rvcnk6IGZhbHNlLFxuICAgICAgcHVzaFN0YXRlOiBmYWxzZSxcbiAgICB9KSk7XG4gIH1cblxuICAvLyBQYWdlIGluaXQgYW5kIGJlZm9yZSBpbml0IGV2ZW50c1xuICByb3V0ZXIucGFnZUNhbGxiYWNrKCdpbml0JywgJG5ld1BhZ2UsICRuZXdOYXZiYXJJbm5lciwgbmV3UGFnZVBvc2l0aW9uLCByZWxvYWQgPyBuZXdQYWdlUG9zaXRpb24gOiAnY3VycmVudCcsIG9wdGlvbnMsICRvbGRQYWdlKTtcblxuICBpZiAob3B0aW9ucy5yZWxvYWRDdXJyZW50IHx8IG9wdGlvbnMucmVsb2FkQWxsKSB7XG4gICAgcm91dGVyLmFsbG93UGFnZUNoYW5nZSA9IHRydWU7XG4gICAgcm91dGVyLnBhZ2VDYWxsYmFjaygnYmVmb3JlSW4nLCAkbmV3UGFnZSwgJG5ld05hdmJhcklubmVyLCBuZXdQYWdlUG9zaXRpb24sICdjdXJyZW50Jywgb3B0aW9ucyk7XG4gICAgcm91dGVyLnBhZ2VDYWxsYmFjaygnYWZ0ZXJJbicsICRuZXdQYWdlLCAkbmV3TmF2YmFySW5uZXIsIG5ld1BhZ2VQb3NpdGlvbiwgJ2N1cnJlbnQnLCBvcHRpb25zKTtcbiAgICBpZiAob3B0aW9ucy5yZWxvYWRDdXJyZW50ICYmIG9wdGlvbnMuY2xlYXJQcmV2aW91c0hpc3RvcnkpIHJvdXRlci5jbGVhclByZXZpb3VzSGlzdG9yeSgpO1xuICAgIHJldHVybiByb3V0ZXI7XG4gIH1cbiAgaWYgKG9wdGlvbnMucmVsb2FkUHJldmlvdXMpIHtcbiAgICByb3V0ZXIuYWxsb3dQYWdlQ2hhbmdlID0gdHJ1ZTtcbiAgICByZXR1cm4gcm91dGVyO1xuICB9XG5cbiAgLy8gQmVmb3JlIGFuaW1hdGlvbiBldmVudFxuICByb3V0ZXIucGFnZUNhbGxiYWNrKCdiZWZvcmVJbicsICRuZXdQYWdlLCAkbmV3TmF2YmFySW5uZXIsICduZXh0JywgJ2N1cnJlbnQnLCBvcHRpb25zKTtcbiAgcm91dGVyLnBhZ2VDYWxsYmFjaygnYmVmb3JlT3V0JywgJG9sZFBhZ2UsICRvbGROYXZiYXJJbm5lciwgJ2N1cnJlbnQnLCAncHJldmlvdXMnLCBvcHRpb25zKTtcblxuICAvLyBBbmltYXRpb25cbiAgZnVuY3Rpb24gYWZ0ZXJBbmltYXRpb24oKSB7XG4gICAgY29uc3QgcGFnZUNsYXNzZXMgPSAncGFnZS1wcmV2aW91cyBwYWdlLWN1cnJlbnQgcGFnZS1uZXh0JztcbiAgICBjb25zdCBuYXZiYXJDbGFzc2VzID0gJ25hdmJhci1wcmV2aW91cyBuYXZiYXItY3VycmVudCBuYXZiYXItbmV4dCc7XG4gICAgJG5ld1BhZ2UucmVtb3ZlQ2xhc3MocGFnZUNsYXNzZXMpLmFkZENsYXNzKCdwYWdlLWN1cnJlbnQnKS5yZW1vdmVBdHRyKCdhcmlhLWhpZGRlbicpO1xuICAgICRvbGRQYWdlLnJlbW92ZUNsYXNzKHBhZ2VDbGFzc2VzKS5hZGRDbGFzcygncGFnZS1wcmV2aW91cycpLmF0dHIoJ2FyaWEtaGlkZGVuJywgJ3RydWUnKTtcbiAgICBpZiAoZHluYW1pY05hdmJhcikge1xuICAgICAgJG5ld05hdmJhcklubmVyLnJlbW92ZUNsYXNzKG5hdmJhckNsYXNzZXMpLmFkZENsYXNzKCduYXZiYXItY3VycmVudCcpLnJlbW92ZUF0dHIoJ2FyaWEtaGlkZGVuJyk7XG4gICAgICAkb2xkTmF2YmFySW5uZXIucmVtb3ZlQ2xhc3MobmF2YmFyQ2xhc3NlcykuYWRkQ2xhc3MoJ25hdmJhci1wcmV2aW91cycpLmF0dHIoJ2FyaWEtaGlkZGVuJywgJ3RydWUnKTtcbiAgICB9XG4gICAgLy8gQWZ0ZXIgYW5pbWF0aW9uIGV2ZW50XG4gICAgcm91dGVyLmFsbG93UGFnZUNoYW5nZSA9IHRydWU7XG4gICAgcm91dGVyLnBhZ2VDYWxsYmFjaygnYWZ0ZXJJbicsICRuZXdQYWdlLCAkbmV3TmF2YmFySW5uZXIsICduZXh0JywgJ2N1cnJlbnQnLCBvcHRpb25zKTtcbiAgICByb3V0ZXIucGFnZUNhbGxiYWNrKCdhZnRlck91dCcsICRvbGRQYWdlLCAkb2xkTmF2YmFySW5uZXIsICdjdXJyZW50JywgJ3ByZXZpb3VzJywgb3B0aW9ucyk7XG5cbiAgICBsZXQga2VlcE9sZFBhZ2UgPSBhcHAudGhlbWUgPT09ICdpb3MnID8gKHJvdXRlci5wYXJhbXMucHJlbG9hZFByZXZpb3VzUGFnZSB8fCByb3V0ZXIucGFyYW1zLmlvc1N3aXBlQmFjaykgOiByb3V0ZXIucGFyYW1zLnByZWxvYWRQcmV2aW91c1BhZ2U7XG4gICAgaWYgKCFrZWVwT2xkUGFnZSkge1xuICAgICAgaWYgKCRuZXdQYWdlLmhhc0NsYXNzKCdzbWFydC1zZWxlY3QtcGFnZScpIHx8ICRuZXdQYWdlLmhhc0NsYXNzKCdwaG90by1icm93c2VyLXBhZ2UnKSB8fCAkbmV3UGFnZS5oYXNDbGFzcygnYXV0b2NvbXBsZXRlLXBhZ2UnKSkge1xuICAgICAgICBrZWVwT2xkUGFnZSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICgha2VlcE9sZFBhZ2UpIHtcbiAgICAgIGlmIChyb3V0ZXIucGFyYW1zLnN0YWNrUGFnZXMpIHtcbiAgICAgICAgJG9sZFBhZ2UuYWRkQ2xhc3MoJ3N0YWNrZWQnKTtcbiAgICAgICAgaWYgKHNlcGFyYXRlTmF2YmFyKSB7XG4gICAgICAgICAgJG9sZE5hdmJhcklubmVyLmFkZENsYXNzKCdzdGFja2VkJyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoISgkbmV3UGFnZS5hdHRyKCdkYXRhLW5hbWUnKSAmJiAkbmV3UGFnZS5hdHRyKCdkYXRhLW5hbWUnKSA9PT0gJ3NtYXJ0LXNlbGVjdC1wYWdlJykpIHtcbiAgICAgICAgLy8gUmVtb3ZlIGV2ZW50XG4gICAgICAgIHJvdXRlci5wYWdlQ2FsbGJhY2soJ2JlZm9yZVJlbW92ZScsICRvbGRQYWdlLCAkb2xkTmF2YmFySW5uZXIsICdwcmV2aW91cycsIHVuZGVmaW5lZCwgb3B0aW9ucyk7XG4gICAgICAgIHJvdXRlci5yZW1vdmVQYWdlKCRvbGRQYWdlKTtcbiAgICAgICAgaWYgKHNlcGFyYXRlTmF2YmFyICYmICRvbGROYXZiYXJJbm5lci5sZW5ndGgpIHtcbiAgICAgICAgICByb3V0ZXIucmVtb3ZlTmF2YmFyKCRvbGROYXZiYXJJbm5lcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuY2xlYXJQcmV2aW91c0hpc3RvcnkpIHJvdXRlci5jbGVhclByZXZpb3VzSGlzdG9yeSgpO1xuICAgIHJvdXRlci5lbWl0KCdyb3V0ZUNoYW5nZWQnLCByb3V0ZXIuY3VycmVudFJvdXRlLCByb3V0ZXIucHJldmlvdXNSb3V0ZSwgcm91dGVyKTtcblxuICAgIGlmIChyb3V0ZXIucGFyYW1zLnB1c2hTdGF0ZSkge1xuICAgICAgSGlzdG9yeS5jbGVhclJvdXRlclF1ZXVlKCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHNldFBvc2l0aW9uQ2xhc3NlcygpIHtcbiAgICBjb25zdCBwYWdlQ2xhc3NlcyA9ICdwYWdlLXByZXZpb3VzIHBhZ2UtY3VycmVudCBwYWdlLW5leHQnO1xuICAgIGNvbnN0IG5hdmJhckNsYXNzZXMgPSAnbmF2YmFyLXByZXZpb3VzIG5hdmJhci1jdXJyZW50IG5hdmJhci1uZXh0JztcbiAgICAkb2xkUGFnZS5yZW1vdmVDbGFzcyhwYWdlQ2xhc3NlcykuYWRkQ2xhc3MoJ3BhZ2UtY3VycmVudCcpLnJlbW92ZUF0dHIoJ2FyaWEtaGlkZGVuJyk7XG4gICAgJG5ld1BhZ2UucmVtb3ZlQ2xhc3MocGFnZUNsYXNzZXMpLmFkZENsYXNzKCdwYWdlLW5leHQnKS5yZW1vdmVBdHRyKCdhcmlhLWhpZGRlbicpO1xuICAgIGlmIChkeW5hbWljTmF2YmFyKSB7XG4gICAgICAkb2xkTmF2YmFySW5uZXIucmVtb3ZlQ2xhc3MobmF2YmFyQ2xhc3NlcykuYWRkQ2xhc3MoJ25hdmJhci1jdXJyZW50JykucmVtb3ZlQXR0cignYXJpYS1oaWRkZW4nKTtcbiAgICAgICRuZXdOYXZiYXJJbm5lci5yZW1vdmVDbGFzcyhuYXZiYXJDbGFzc2VzKS5hZGRDbGFzcygnbmF2YmFyLW5leHQnKS5yZW1vdmVBdHRyKCdhcmlhLWhpZGRlbicpO1xuICAgIH1cbiAgfVxuICBpZiAob3B0aW9ucy5hbmltYXRlKSB7XG4gICAgY29uc3QgZGVsYXkgPSByb3V0ZXIuYXBwLnRoZW1lID09PSAnbWQnID8gcm91dGVyLnBhcmFtcy5tYXRlcmlhbFBhZ2VMb2FkRGVsYXkgOiByb3V0ZXIucGFyYW1zLmlvc1BhZ2VMb2FkRGVsYXk7XG4gICAgaWYgKGRlbGF5KSB7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgc2V0UG9zaXRpb25DbGFzc2VzKCk7XG4gICAgICAgIHJvdXRlci5hbmltYXRlKCRvbGRQYWdlLCAkbmV3UGFnZSwgJG9sZE5hdmJhcklubmVyLCAkbmV3TmF2YmFySW5uZXIsICdmb3J3YXJkJywgKCkgPT4ge1xuICAgICAgICAgIGFmdGVyQW5pbWF0aW9uKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSwgZGVsYXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXRQb3NpdGlvbkNsYXNzZXMoKTtcbiAgICAgIHJvdXRlci5hbmltYXRlKCRvbGRQYWdlLCAkbmV3UGFnZSwgJG9sZE5hdmJhcklubmVyLCAkbmV3TmF2YmFySW5uZXIsICdmb3J3YXJkJywgKCkgPT4ge1xuICAgICAgICBhZnRlckFuaW1hdGlvbigpO1xuICAgICAgfSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGFmdGVyQW5pbWF0aW9uKCk7XG4gIH1cbiAgcmV0dXJuIHJvdXRlcjtcbn1cbmZ1bmN0aW9uIGxvYWQobG9hZFBhcmFtcyA9IHt9LCBsb2FkT3B0aW9ucyA9IHt9LCBpZ25vcmVQYWdlQ2hhbmdlKSB7XG4gIGNvbnN0IHJvdXRlciA9IHRoaXM7XG4gIGlmICghcm91dGVyLmFsbG93UGFnZUNoYW5nZSAmJiAhaWdub3JlUGFnZUNoYW5nZSkgcmV0dXJuIHJvdXRlcjtcbiAgY29uc3QgcGFyYW1zID0gbG9hZFBhcmFtcztcbiAgY29uc3Qgb3B0aW9ucyA9IGxvYWRPcHRpb25zO1xuICBjb25zdCB7IHVybCwgY29udGVudCwgZWwsIHBhZ2VOYW1lLCB0ZW1wbGF0ZSwgdGVtcGxhdGVVcmwsIGNvbXBvbmVudCwgY29tcG9uZW50VXJsIH0gPSBwYXJhbXM7XG5cbiAgaWYgKCFvcHRpb25zLnJlbG9hZEN1cnJlbnQgJiZcbiAgICBvcHRpb25zLnJvdXRlICYmXG4gICAgb3B0aW9ucy5yb3V0ZS5yb3V0ZSAmJlxuICAgIG9wdGlvbnMucm91dGUucm91dGUucGFyZW50UGF0aCAmJlxuICAgIHJvdXRlci5jdXJyZW50Um91dGUucm91dGUgJiZcbiAgICByb3V0ZXIuY3VycmVudFJvdXRlLnJvdXRlLnBhcmVudFBhdGggPT09IG9wdGlvbnMucm91dGUucm91dGUucGFyZW50UGF0aCkge1xuICAgIC8vIERvIHNvbWV0aGluZyBuZXN0ZWRcbiAgICBpZiAob3B0aW9ucy5yb3V0ZS51cmwgPT09IHJvdXRlci51cmwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gQ2hlY2sgZm9yIHNhbWUgcGFyYW1zXG4gICAgbGV0IHNhbWVQYXJhbXMgPSBPYmplY3Qua2V5cyhvcHRpb25zLnJvdXRlLnBhcmFtcykubGVuZ3RoID09PSBPYmplY3Qua2V5cyhyb3V0ZXIuY3VycmVudFJvdXRlLnBhcmFtcykubGVuZ3RoO1xuICAgIGlmIChzYW1lUGFyYW1zKSB7XG4gICAgICAvLyBDaGVjayBmb3IgZXF1YWwgcGFyYW1zIG5hbWVcbiAgICAgIE9iamVjdC5rZXlzKG9wdGlvbnMucm91dGUucGFyYW1zKS5mb3JFYWNoKChwYXJhbU5hbWUpID0+IHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICEocGFyYW1OYW1lIGluIHJvdXRlci5jdXJyZW50Um91dGUucGFyYW1zKSB8fFxuICAgICAgICAgIChyb3V0ZXIuY3VycmVudFJvdXRlLnBhcmFtc1twYXJhbU5hbWVdICE9PSBvcHRpb25zLnJvdXRlLnBhcmFtc1twYXJhbU5hbWVdKVxuICAgICAgICApIHtcbiAgICAgICAgICBzYW1lUGFyYW1zID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoc2FtZVBhcmFtcykge1xuICAgICAgaWYgKG9wdGlvbnMucm91dGUucm91dGUudGFiKSB7XG4gICAgICAgIHJldHVybiByb3V0ZXIudGFiTG9hZChvcHRpb25zLnJvdXRlLnJvdXRlLnRhYiwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgaWYgKFxuICAgIG9wdGlvbnMucm91dGUgJiZcbiAgICBvcHRpb25zLnJvdXRlLnVybCAmJlxuICAgIHJvdXRlci51cmwgPT09IG9wdGlvbnMucm91dGUudXJsICYmXG4gICAgIShvcHRpb25zLnJlbG9hZEN1cnJlbnQgfHwgb3B0aW9ucy5yZWxvYWRQcmV2aW91cykgJiZcbiAgICAhcm91dGVyLnBhcmFtcy5hbGxvd0R1cGxpY2F0ZVVybHNcbiAgKSB7XG4gICAgcm91dGVyLmFsbG93UGFnZUNoYW5nZSA9IHRydWU7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKCFvcHRpb25zLnJvdXRlICYmIHVybCkge1xuICAgIG9wdGlvbnMucm91dGUgPSByb3V0ZXIucGFyc2VSb3V0ZVVybCh1cmwpO1xuICAgIFV0aWxzLmV4dGVuZChvcHRpb25zLnJvdXRlLCB7IHJvdXRlOiB7IHVybCwgcGF0aDogdXJsIH0gfSk7XG4gIH1cblxuICAvLyBDb21wb25lbnQgQ2FsbGJhY2tzXG4gIGZ1bmN0aW9uIHJlc29sdmUocGFnZUVsLCBuZXdPcHRpb25zKSB7XG4gICAgcmV0dXJuIHJvdXRlci5mb3J3YXJkKHBhZ2VFbCwgVXRpbHMuZXh0ZW5kKG9wdGlvbnMsIG5ld09wdGlvbnMpKTtcbiAgfVxuICBmdW5jdGlvbiByZWplY3QoKSB7XG4gICAgcm91dGVyLmFsbG93UGFnZUNoYW5nZSA9IHRydWU7XG4gICAgcmV0dXJuIHJvdXRlcjtcbiAgfVxuXG4gIGlmICh1cmwgfHwgdGVtcGxhdGVVcmwgfHwgY29tcG9uZW50VXJsKSB7XG4gICAgcm91dGVyLmFsbG93UGFnZUNoYW5nZSA9IGZhbHNlO1xuICB9XG5cbiAgLy8gUHJvY2VlZFxuICBpZiAoY29udGVudCkge1xuICAgIHJvdXRlci5mb3J3YXJkKHJvdXRlci5nZXRQYWdlRWwoY29udGVudCksIG9wdGlvbnMpO1xuICB9IGVsc2UgaWYgKHRlbXBsYXRlIHx8IHRlbXBsYXRlVXJsKSB7XG4gICAgLy8gUGFyc2UgdGVtcGxhdGUgYW5kIHNlbmQgcGFnZSBlbGVtZW50XG4gICAgdHJ5IHtcbiAgICAgIHJvdXRlci5wYWdlVGVtcGxhdGVMb2FkZXIodGVtcGxhdGUsIHRlbXBsYXRlVXJsLCBvcHRpb25zLCByZXNvbHZlLCByZWplY3QpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcm91dGVyLmFsbG93UGFnZUNoYW5nZSA9IHRydWU7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICB9IGVsc2UgaWYgKGVsKSB7XG4gICAgLy8gTG9hZCBwYWdlIGZyb20gc3BlY2lmaWVkIEhUTUxFbGVtZW50IG9yIGJ5IHBhZ2UgbmFtZSBpbiBwYWdlcyBjb250YWluZXJcbiAgICByb3V0ZXIuZm9yd2FyZChyb3V0ZXIuZ2V0UGFnZUVsKGVsKSwgb3B0aW9ucyk7XG4gIH0gZWxzZSBpZiAocGFnZU5hbWUpIHtcbiAgICAvLyBMb2FkIHBhZ2UgYnkgcGFnZSBuYW1lIGluIHBhZ2VzIGNvbnRhaW5lclxuICAgIHJvdXRlci5mb3J3YXJkKHJvdXRlci4kZWwuY2hpbGRyZW4oYC5wYWdlW2RhdGEtbmFtZT1cIiR7cGFnZU5hbWV9XCJdYCkuZXEoMCksIG9wdGlvbnMpO1xuICB9IGVsc2UgaWYgKGNvbXBvbmVudCB8fCBjb21wb25lbnRVcmwpIHtcbiAgICAvLyBMb2FkIGZyb20gY29tcG9uZW50IChGNy9WdWUvUmVhY3QvLi4uKVxuICAgIHRyeSB7XG4gICAgICByb3V0ZXIucGFnZUNvbXBvbmVudExvYWRlcihyb3V0ZXIuZWwsIGNvbXBvbmVudCwgY29tcG9uZW50VXJsLCBvcHRpb25zLCByZXNvbHZlLCByZWplY3QpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcm91dGVyLmFsbG93UGFnZUNoYW5nZSA9IHRydWU7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICB9IGVsc2UgaWYgKHVybCkge1xuICAgIC8vIExvYWQgdXNpbmcgWEhSXG4gICAgaWYgKHJvdXRlci54aHIpIHtcbiAgICAgIHJvdXRlci54aHIuYWJvcnQoKTtcbiAgICAgIHJvdXRlci54aHIgPSBmYWxzZTtcbiAgICB9XG4gICAgcm91dGVyLnhoclJlcXVlc3QodXJsLCBvcHRpb25zKVxuICAgICAgLnRoZW4oKHBhZ2VDb250ZW50KSA9PiB7XG4gICAgICAgIHJvdXRlci5mb3J3YXJkKHJvdXRlci5nZXRQYWdlRWwocGFnZUNvbnRlbnQpLCBvcHRpb25zKTtcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goKCkgPT4ge1xuICAgICAgICByb3V0ZXIuYWxsb3dQYWdlQ2hhbmdlID0gdHJ1ZTtcbiAgICAgIH0pO1xuICB9XG4gIHJldHVybiByb3V0ZXI7XG59XG5mdW5jdGlvbiBuYXZpZ2F0ZShuYXZpZ2F0ZVBhcmFtcywgbmF2aWdhdGVPcHRpb25zID0ge30pIHtcbiAgY29uc3Qgcm91dGVyID0gdGhpcztcbiAgbGV0IHVybDtcbiAgbGV0IGNyZWF0ZVJvdXRlO1xuICBpZiAodHlwZW9mIG5hdmlnYXRlUGFyYW1zID09PSAnc3RyaW5nJykge1xuICAgIHVybCA9IG5hdmlnYXRlUGFyYW1zO1xuICB9IGVsc2Uge1xuICAgIHVybCA9IG5hdmlnYXRlUGFyYW1zLnVybDtcbiAgICBjcmVhdGVSb3V0ZSA9IG5hdmlnYXRlUGFyYW1zLnJvdXRlO1xuICB9XG4gIGNvbnN0IGFwcCA9IHJvdXRlci5hcHA7XG4gIGlmICghcm91dGVyLnZpZXcpIHtcbiAgICBpZiAoYXBwLnZpZXdzLm1haW4pIHtcbiAgICAgIGFwcC52aWV3cy5tYWluLnJvdXRlci5uYXZpZ2F0ZSh1cmwsIG5hdmlnYXRlT3B0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiByb3V0ZXI7XG4gIH1cbiAgaWYgKHVybCA9PT0gJyMnIHx8IHVybCA9PT0gJycpIHtcbiAgICByZXR1cm4gcm91dGVyO1xuICB9XG5cbiAgbGV0IG5hdmlnYXRlVXJsID0gdXJsLnJlcGxhY2UoJy4vJywgJycpO1xuICBpZiAobmF2aWdhdGVVcmxbMF0gIT09ICcvJyAmJiBuYXZpZ2F0ZVVybC5pbmRleE9mKCcjJykgIT09IDApIHtcbiAgICBjb25zdCBjdXJyZW50UGF0aCA9IHJvdXRlci5jdXJyZW50Um91dGUucGFyZW50UGF0aCB8fCByb3V0ZXIuY3VycmVudFJvdXRlLnBhdGg7XG4gICAgbmF2aWdhdGVVcmwgPSAoKGN1cnJlbnRQYXRoID8gYCR7Y3VycmVudFBhdGh9L2AgOiAnLycpICsgbmF2aWdhdGVVcmwpXG4gICAgICAucmVwbGFjZSgnLy8vJywgJy8nKVxuICAgICAgLnJlcGxhY2UoJy8vJywgJy8nKTtcbiAgfVxuICBsZXQgcm91dGU7XG4gIGlmIChjcmVhdGVSb3V0ZSkge1xuICAgIHJvdXRlID0gVXRpbHMuZXh0ZW5kKHJvdXRlci5wYXJzZVJvdXRlVXJsKG5hdmlnYXRlVXJsKSwge1xuICAgICAgcm91dGU6IFV0aWxzLmV4dGVuZCh7fSwgY3JlYXRlUm91dGUpLFxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHJvdXRlID0gcm91dGVyLmZpbmRNYXRjaGluZ1JvdXRlKG5hdmlnYXRlVXJsKTtcbiAgfVxuXG4gIGlmICghcm91dGUpIHtcbiAgICByZXR1cm4gcm91dGVyO1xuICB9XG5cbiAgaWYgKHJvdXRlLnJvdXRlLnJlZGlyZWN0KSB7XG4gICAgcmV0dXJuIHJlZGlyZWN0LmNhbGwocm91dGVyLCAnbmF2aWdhdGUnLCByb3V0ZSwgbmF2aWdhdGVPcHRpb25zKTtcbiAgfVxuXG4gIGNvbnN0IG9wdGlvbnMgPSB7fTtcbiAgaWYgKHJvdXRlLnJvdXRlLm9wdGlvbnMpIHtcbiAgICBVdGlscy5leHRlbmQob3B0aW9ucywgcm91dGUucm91dGUub3B0aW9ucywgbmF2aWdhdGVPcHRpb25zLCB7IHJvdXRlIH0pO1xuICB9IGVsc2Uge1xuICAgIFV0aWxzLmV4dGVuZChvcHRpb25zLCBuYXZpZ2F0ZU9wdGlvbnMsIHsgcm91dGUgfSk7XG4gIH1cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5jb250ZXh0KSB7XG4gICAgcm91dGUuY29udGV4dCA9IG9wdGlvbnMuY29udGV4dDtcbiAgICBvcHRpb25zLnJvdXRlLmNvbnRleHQgPSBvcHRpb25zLmNvbnRleHQ7XG4gIH1cbiAgKCdwb3B1cCBwb3BvdmVyIHNoZWV0IGxvZ2luU2NyZWVuIGFjdGlvbnMgY3VzdG9tTW9kYWwnKS5zcGxpdCgnICcpLmZvckVhY2goKG1vZGFsTG9hZFByb3ApID0+IHtcbiAgICBpZiAocm91dGUucm91dGVbbW9kYWxMb2FkUHJvcF0pIHtcbiAgICAgIHJvdXRlci5tb2RhbExvYWQobW9kYWxMb2FkUHJvcCwgcm91dGUsIG9wdGlvbnMpO1xuICAgIH1cbiAgfSk7XG4gICgndXJsIGNvbnRlbnQgY29tcG9uZW50IHBhZ2VOYW1lIGVsIGNvbXBvbmVudFVybCB0ZW1wbGF0ZSB0ZW1wbGF0ZVVybCcpLnNwbGl0KCcgJykuZm9yRWFjaCgocGFnZUxvYWRQcm9wKSA9PiB7XG4gICAgaWYgKHJvdXRlLnJvdXRlW3BhZ2VMb2FkUHJvcF0pIHtcbiAgICAgIHJvdXRlci5sb2FkKHsgW3BhZ2VMb2FkUHJvcF06IHJvdXRlLnJvdXRlW3BhZ2VMb2FkUHJvcF0gfSwgb3B0aW9ucyk7XG4gICAgfVxuICB9KTtcbiAgLy8gQXN5bmNcbiAgZnVuY3Rpb24gYXN5bmNSZXNvbHZlKHJlc29sdmVQYXJhbXMsIHJlc29sdmVPcHRpb25zKSB7XG4gICAgcm91dGVyLmFsbG93UGFnZUNoYW5nZSA9IGZhbHNlO1xuICAgIGxldCByZXNvbHZlZEFzTW9kYWwgPSBmYWxzZTtcbiAgICBpZiAocmVzb2x2ZU9wdGlvbnMgJiYgcmVzb2x2ZU9wdGlvbnMuY29udGV4dCkge1xuICAgICAgaWYgKCFyb3V0ZS5jb250ZXh0KSByb3V0ZS5jb250ZXh0ID0gcmVzb2x2ZU9wdGlvbnMuY29udGV4dDtcbiAgICAgIGVsc2Ugcm91dGUuY29udGV4dCA9IFV0aWxzLmV4dGVuZCh7fSwgcm91dGUuY29udGV4dCwgcmVzb2x2ZU9wdGlvbnMuY29udGV4dCk7XG4gICAgICBvcHRpb25zLnJvdXRlLmNvbnRleHQgPSByb3V0ZS5jb250ZXh0O1xuICAgIH1cbiAgICAoJ3BvcHVwIHBvcG92ZXIgc2hlZXQgbG9naW5TY3JlZW4gYWN0aW9ucyBjdXN0b21Nb2RhbCcpLnNwbGl0KCcgJykuZm9yRWFjaCgobW9kYWxMb2FkUHJvcCkgPT4ge1xuICAgICAgaWYgKHJlc29sdmVQYXJhbXNbbW9kYWxMb2FkUHJvcF0pIHtcbiAgICAgICAgcmVzb2x2ZWRBc01vZGFsID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgbW9kYWxSb3V0ZSA9IFV0aWxzLmV4dGVuZCh7fSwgcm91dGUsIHsgcm91dGU6IHJlc29sdmVQYXJhbXMgfSk7XG4gICAgICAgIHJvdXRlci5hbGxvd1BhZ2VDaGFuZ2UgPSB0cnVlO1xuICAgICAgICByb3V0ZXIubW9kYWxMb2FkKG1vZGFsTG9hZFByb3AsIG1vZGFsUm91dGUsIFV0aWxzLmV4dGVuZChvcHRpb25zLCByZXNvbHZlT3B0aW9ucykpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChyZXNvbHZlZEFzTW9kYWwpIHJldHVybjtcbiAgICByb3V0ZXIubG9hZChyZXNvbHZlUGFyYW1zLCBVdGlscy5leHRlbmQob3B0aW9ucywgcmVzb2x2ZU9wdGlvbnMpLCB0cnVlKTtcbiAgfVxuICBmdW5jdGlvbiBhc3luY1JlamVjdCgpIHtcbiAgICByb3V0ZXIuYWxsb3dQYWdlQ2hhbmdlID0gdHJ1ZTtcbiAgfVxuICBpZiAocm91dGUucm91dGUuYXN5bmMpIHtcbiAgICByb3V0ZXIuYWxsb3dQYWdlQ2hhbmdlID0gZmFsc2U7XG5cbiAgICByb3V0ZS5yb3V0ZS5hc3luYy5jYWxsKHJvdXRlciwgcm91dGUsIHJvdXRlci5jdXJyZW50Um91dGUsIGFzeW5jUmVzb2x2ZSwgYXN5bmNSZWplY3QpO1xuICB9XG4gIC8vIFJldHVybiBSb3V0ZXJcbiAgcmV0dXJuIHJvdXRlcjtcbn1cblxuZnVuY3Rpb24gdGFiTG9hZCh0YWJSb3V0ZSwgbG9hZE9wdGlvbnMgPSB7fSkge1xuICBjb25zdCByb3V0ZXIgPSB0aGlzO1xuICBjb25zdCBvcHRpb25zID0gVXRpbHMuZXh0ZW5kKHtcbiAgICBhbmltYXRlOiByb3V0ZXIucGFyYW1zLmFuaW1hdGUsXG4gICAgcHVzaFN0YXRlOiB0cnVlLFxuICAgIGhpc3Rvcnk6IHRydWUsXG4gICAgcGFyZW50UGFnZUVsOiBudWxsLFxuICAgIHByZWxvYWQ6IGZhbHNlLFxuICAgIG9uOiB7fSxcbiAgfSwgbG9hZE9wdGlvbnMpO1xuXG4gIGxldCBjdXJyZW50Um91dGU7XG4gIGxldCBwcmV2aW91c1JvdXRlO1xuICBpZiAob3B0aW9ucy5yb3V0ZSkge1xuICAgIC8vIFNldCBSb3V0ZVxuICAgIGlmICghb3B0aW9ucy5wcmVsb2FkICYmIG9wdGlvbnMucm91dGUgIT09IHJvdXRlci5jdXJyZW50Um91dGUpIHtcbiAgICAgIHByZXZpb3VzUm91dGUgPSByb3V0ZXIucHJldmlvdXNSb3V0ZTtcbiAgICAgIHJvdXRlci5jdXJyZW50Um91dGUgPSBvcHRpb25zLnJvdXRlO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5wcmVsb2FkKSB7XG4gICAgICBjdXJyZW50Um91dGUgPSBvcHRpb25zLnJvdXRlO1xuICAgICAgcHJldmlvdXNSb3V0ZSA9IHJvdXRlci5jdXJyZW50Um91dGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnRSb3V0ZSA9IHJvdXRlci5jdXJyZW50Um91dGU7XG4gICAgICBpZiAoIXByZXZpb3VzUm91dGUpIHByZXZpb3VzUm91dGUgPSByb3V0ZXIucHJldmlvdXNSb3V0ZTtcbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgQnJvd3NlciBIaXN0b3J5XG4gICAgaWYgKHJvdXRlci5wYXJhbXMucHVzaFN0YXRlICYmIG9wdGlvbnMucHVzaFN0YXRlICYmICFvcHRpb25zLnJlbG9hZFByZXZpb3VzKSB7XG4gICAgICBIaXN0b3J5LnJlcGxhY2UoXG4gICAgICAgIHJvdXRlci52aWV3LmlkLFxuICAgICAgICB7XG4gICAgICAgICAgdXJsOiBvcHRpb25zLnJvdXRlLnVybCxcbiAgICAgICAgfSxcbiAgICAgICAgKHJvdXRlci5wYXJhbXMucHVzaFN0YXRlUm9vdCB8fCAnJykgKyByb3V0ZXIucGFyYW1zLnB1c2hTdGF0ZVNlcGFyYXRvciArIG9wdGlvbnMucm91dGUudXJsXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIFVwZGF0ZSBSb3V0ZXIgSGlzdG9yeVxuICAgIGlmIChvcHRpb25zLmhpc3RvcnkpIHtcbiAgICAgIHJvdXRlci5oaXN0b3J5W01hdGgubWF4KHJvdXRlci5oaXN0b3J5Lmxlbmd0aCAtIDEsIDApXSA9IG9wdGlvbnMucm91dGUudXJsO1xuICAgICAgcm91dGVyLnNhdmVIaXN0b3J5KCk7XG4gICAgfVxuICB9XG5cbiAgLy8gU2hvdyBUYWJcbiAgY29uc3QgJHBhcmVudFBhZ2VFbCA9ICQob3B0aW9ucy5wYXJlbnRQYWdlRWwgfHwgcm91dGVyLmN1cnJlbnRQYWdlRWwpO1xuICBsZXQgdGFiRWw7XG4gIGlmICgkcGFyZW50UGFnZUVsLmxlbmd0aCAmJiAkcGFyZW50UGFnZUVsLmZpbmQoYCMke3RhYlJvdXRlLmlkfWApLmxlbmd0aCkge1xuICAgIHRhYkVsID0gJHBhcmVudFBhZ2VFbC5maW5kKGAjJHt0YWJSb3V0ZS5pZH1gKS5lcSgwKTtcbiAgfSBlbHNlIGlmIChyb3V0ZXIudmlldy5zZWxlY3Rvcikge1xuICAgIHRhYkVsID0gYCR7cm91dGVyLnZpZXcuc2VsZWN0b3J9ICMke3RhYlJvdXRlLmlkfWA7XG4gIH0gZWxzZSB7XG4gICAgdGFiRWwgPSBgIyR7dGFiUm91dGUuaWR9YDtcbiAgfVxuICBjb25zdCB0YWJTaG93UmVzdWx0ID0gcm91dGVyLmFwcC50YWIuc2hvdyh7XG4gICAgdGFiRWwsXG4gICAgYW5pbWF0ZTogb3B0aW9ucy5hbmltYXRlLFxuICAgIHRhYlJvdXRlOiBvcHRpb25zLnJvdXRlLFxuICB9KTtcblxuICBjb25zdCB7ICRuZXdUYWJFbCwgJG9sZFRhYkVsLCBhbmltYXRlZCwgb25UYWJzQ2hhbmdlZCB9ID0gdGFiU2hvd1Jlc3VsdDtcblxuICBpZiAoJG5ld1RhYkVsICYmICRuZXdUYWJFbC5wYXJlbnRzKCcucGFnZScpLmxlbmd0aCA+IDAgJiYgb3B0aW9ucy5yb3V0ZSkge1xuICAgIGNvbnN0IHRhYlBhcmVudFBhZ2VEYXRhID0gJG5ld1RhYkVsLnBhcmVudHMoJy5wYWdlJylbMF0uZjdQYWdlO1xuICAgIGlmICh0YWJQYXJlbnRQYWdlRGF0YSAmJiBvcHRpb25zLnJvdXRlKSB7XG4gICAgICB0YWJQYXJlbnRQYWdlRGF0YS5yb3V0ZSA9IG9wdGlvbnMucm91dGU7XG4gICAgfVxuICB9XG5cbiAgLy8gVGFiIENvbnRlbnQgTG9hZGVkXG4gIGZ1bmN0aW9uIG9uVGFiTG9hZGVkKGNvbnRlbnRFbCkge1xuICAgIC8vIFJlbW92ZSB0aGVtZSBlbGVtZW50c1xuICAgIHJvdXRlci5yZW1vdmVUaGVtZUVsZW1lbnRzKCRuZXdUYWJFbCk7XG5cbiAgICBsZXQgdGFiRXZlbnRUYXJnZXQgPSAkbmV3VGFiRWw7XG4gICAgaWYgKHR5cGVvZiBjb250ZW50RWwgIT09ICdzdHJpbmcnKSB0YWJFdmVudFRhcmdldCA9ICQoY29udGVudEVsKTtcblxuICAgIHRhYkV2ZW50VGFyZ2V0LnRyaWdnZXIoJ3RhYjppbml0IHRhYjptb3VudGVkJywgdGFiUm91dGUpO1xuICAgIHJvdXRlci5lbWl0KCd0YWJJbml0IHRhYk1vdW50ZWQnLCAkbmV3VGFiRWxbMF0sIHRhYlJvdXRlKTtcblxuICAgIGlmICgkb2xkVGFiRWwgJiYgcm91dGVyLnBhcmFtcy51bmxvYWRUYWJDb250ZW50KSB7XG4gICAgICBpZiAoYW5pbWF0ZWQpIHtcbiAgICAgICAgb25UYWJzQ2hhbmdlZCgoKSA9PiB7XG4gICAgICAgICAgcm91dGVyLnRhYlJlbW92ZSgkb2xkVGFiRWwsICRuZXdUYWJFbCwgdGFiUm91dGUpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJvdXRlci50YWJSZW1vdmUoJG9sZFRhYkVsLCAkbmV3VGFiRWwsIHRhYlJvdXRlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKCFyb3V0ZXIucGFyYW1zLnVubG9hZFRhYkNvbnRlbnQpIHtcbiAgICBpZiAoJG5ld1RhYkVsWzBdLmY3Um91dGVyVGFiTG9hZGVkKSByZXR1cm4gcm91dGVyO1xuICB9XG5cbiAgLy8gTG9hZCBUYWIgQ29udGVudFxuICBmdW5jdGlvbiBsb2FkVGFiKGxvYWRUYWJQYXJhbXMsIGxvYWRUYWJPcHRpb25zKSB7XG4gICAgLy8gTG9hZCBUYWIgUHJvcHNcbiAgICBjb25zdCB7IHVybCwgY29udGVudCwgZWwsIHRlbXBsYXRlLCB0ZW1wbGF0ZVVybCwgY29tcG9uZW50LCBjb21wb25lbnRVcmwgfSA9IGxvYWRUYWJQYXJhbXM7XG4gICAgLy8gQ29tcG9uZW50L1RlbXBsYXRlIENhbGxiYWNrc1xuICAgIGZ1bmN0aW9uIHJlc29sdmUoY29udGVudEVsKSB7XG4gICAgICByb3V0ZXIuYWxsb3dQYWdlQ2hhbmdlID0gdHJ1ZTtcbiAgICAgIGlmICghY29udGVudEVsKSByZXR1cm47XG4gICAgICBpZiAodHlwZW9mIGNvbnRlbnRFbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgJG5ld1RhYkVsLmh0bWwoY29udGVudEVsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICRuZXdUYWJFbC5odG1sKCcnKTtcbiAgICAgICAgaWYgKGNvbnRlbnRFbC5mN0NvbXBvbmVudCkge1xuICAgICAgICAgIGNvbnRlbnRFbC5mN0NvbXBvbmVudC4kbW91bnQoKGNvbXBvbmVudEVsKSA9PiB7XG4gICAgICAgICAgICAkbmV3VGFiRWwuYXBwZW5kKGNvbXBvbmVudEVsKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAkbmV3VGFiRWwuYXBwZW5kKGNvbnRlbnRFbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghcm91dGVyLnBhcmFtcy51bmxvYWRUYWJDb250ZW50KSB7XG4gICAgICAgICRuZXdUYWJFbFswXS5mN1JvdXRlclRhYkxvYWRlZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBvblRhYkxvYWRlZChjb250ZW50RWwpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZWplY3QoKSB7XG4gICAgICByb3V0ZXIuYWxsb3dQYWdlQ2hhbmdlID0gdHJ1ZTtcbiAgICAgIHJldHVybiByb3V0ZXI7XG4gICAgfVxuXG4gICAgaWYgKGNvbnRlbnQpIHtcbiAgICAgIHJlc29sdmUoY29udGVudCk7XG4gICAgfSBlbHNlIGlmICh0ZW1wbGF0ZSB8fCB0ZW1wbGF0ZVVybCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcm91dGVyLnRhYlRlbXBsYXRlTG9hZGVyKHRlbXBsYXRlLCB0ZW1wbGF0ZVVybCwgbG9hZFRhYk9wdGlvbnMsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgcm91dGVyLmFsbG93UGFnZUNoYW5nZSA9IHRydWU7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGVsKSB7XG4gICAgICByZXNvbHZlKGVsKTtcbiAgICB9IGVsc2UgaWYgKGNvbXBvbmVudCB8fCBjb21wb25lbnRVcmwpIHtcbiAgICAgIC8vIExvYWQgZnJvbSBjb21wb25lbnQgKEY3L1Z1ZS9SZWFjdC8uLi4pXG4gICAgICB0cnkge1xuICAgICAgICByb3V0ZXIudGFiQ29tcG9uZW50TG9hZGVyKCRuZXdUYWJFbFswXSwgY29tcG9uZW50LCBjb21wb25lbnRVcmwsIGxvYWRUYWJPcHRpb25zLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJvdXRlci5hbGxvd1BhZ2VDaGFuZ2UgPSB0cnVlO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh1cmwpIHtcbiAgICAgIC8vIExvYWQgdXNpbmcgWEhSXG4gICAgICBpZiAocm91dGVyLnhocikge1xuICAgICAgICByb3V0ZXIueGhyLmFib3J0KCk7XG4gICAgICAgIHJvdXRlci54aHIgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJvdXRlci54aHJSZXF1ZXN0KHVybCwgbG9hZFRhYk9wdGlvbnMpXG4gICAgICAgIC50aGVuKCh0YWJDb250ZW50KSA9PiB7XG4gICAgICAgICAgcmVzb2x2ZSh0YWJDb250ZW50KTtcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKCgpID0+IHtcbiAgICAgICAgICByb3V0ZXIuYWxsb3dQYWdlQ2hhbmdlID0gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgKCd1cmwgY29udGVudCBjb21wb25lbnQgZWwgY29tcG9uZW50VXJsIHRlbXBsYXRlIHRlbXBsYXRlVXJsJykuc3BsaXQoJyAnKS5mb3JFYWNoKCh0YWJMb2FkUHJvcCkgPT4ge1xuICAgIGlmICh0YWJSb3V0ZVt0YWJMb2FkUHJvcF0pIHtcbiAgICAgIGxvYWRUYWIoeyBbdGFiTG9hZFByb3BdOiB0YWJSb3V0ZVt0YWJMb2FkUHJvcF0gfSwgb3B0aW9ucyk7XG4gICAgfVxuICB9KTtcblxuICAvLyBBc3luY1xuICBmdW5jdGlvbiBhc3luY1Jlc29sdmUocmVzb2x2ZVBhcmFtcywgcmVzb2x2ZU9wdGlvbnMpIHtcbiAgICBsb2FkVGFiKHJlc29sdmVQYXJhbXMsIFV0aWxzLmV4dGVuZChvcHRpb25zLCByZXNvbHZlT3B0aW9ucykpO1xuICB9XG4gIGZ1bmN0aW9uIGFzeW5jUmVqZWN0KCkge1xuICAgIHJvdXRlci5hbGxvd1BhZ2VDaGFuZ2UgPSB0cnVlO1xuICB9XG4gIGlmICh0YWJSb3V0ZS5hc3luYykge1xuICAgIHRhYlJvdXRlLmFzeW5jLmNhbGwocm91dGVyLCBjdXJyZW50Um91dGUsIHByZXZpb3VzUm91dGUsIGFzeW5jUmVzb2x2ZSwgYXN5bmNSZWplY3QpO1xuICB9XG4gIHJldHVybiByb3V0ZXI7XG59XG5mdW5jdGlvbiB0YWJSZW1vdmUoJG9sZFRhYkVsLCAkbmV3VGFiRWwsIHRhYlJvdXRlKSB7XG4gIGNvbnN0IHJvdXRlciA9IHRoaXM7XG4gIGxldCBoYXNUYWJDb21wb25lbnRDaGlsZDtcbiAgJG9sZFRhYkVsLmNoaWxkcmVuKCkuZWFjaCgoaW5kZXgsIHRhYkNoaWxkKSA9PiB7XG4gICAgaWYgKHRhYkNoaWxkLmY3Q29tcG9uZW50KSB7XG4gICAgICBoYXNUYWJDb21wb25lbnRDaGlsZCA9IHRydWU7XG4gICAgICAkKHRhYkNoaWxkKS50cmlnZ2VyKCd0YWI6YmVmb3JlcmVtb3ZlJywgdGFiUm91dGUpO1xuICAgICAgdGFiQ2hpbGQuZjdDb21wb25lbnQuJGRlc3Ryb3koKTtcbiAgICB9XG4gIH0pO1xuICBpZiAoIWhhc1RhYkNvbXBvbmVudENoaWxkKSB7XG4gICAgJG9sZFRhYkVsLnRyaWdnZXIoJ3RhYjpiZWZvcmVyZW1vdmUnLCB0YWJSb3V0ZSk7XG4gIH1cbiAgcm91dGVyLmVtaXQoJ3RhYkJlZm9yZVJlbW92ZScsICRvbGRUYWJFbFswXSwgJG5ld1RhYkVsWzBdLCB0YWJSb3V0ZSk7XG4gIHJvdXRlci5yZW1vdmVUYWJDb250ZW50KCRvbGRUYWJFbFswXSwgdGFiUm91dGUpO1xufVxuXG5mdW5jdGlvbiBtb2RhbExvYWQobW9kYWxUeXBlLCByb3V0ZSwgbG9hZE9wdGlvbnMgPSB7fSkge1xuICBjb25zdCByb3V0ZXIgPSB0aGlzO1xuICBjb25zdCBhcHAgPSByb3V0ZXIuYXBwO1xuXG4gIGNvbnN0IG9wdGlvbnMgPSBVdGlscy5leHRlbmQoe1xuICAgIGFuaW1hdGU6IHJvdXRlci5wYXJhbXMuYW5pbWF0ZSxcbiAgICBwdXNoU3RhdGU6IHRydWUsXG4gICAgaGlzdG9yeTogdHJ1ZSxcbiAgICBvbjoge30sXG4gIH0sIGxvYWRPcHRpb25zKTtcblxuICBjb25zdCBtb2RhbFBhcmFtcyA9IFV0aWxzLmV4dGVuZCh7fSwgcm91dGUucm91dGVbbW9kYWxUeXBlXSk7XG4gIGNvbnN0IG1vZGFsUm91dGUgPSByb3V0ZS5yb3V0ZTtcblxuICBmdW5jdGlvbiBvbk1vZGFsTG9hZGVkKCkge1xuICAgIC8vIENyZWF0ZSBNb2RhbFxuICAgIGNvbnN0IG1vZGFsID0gYXBwW21vZGFsVHlwZV0uY3JlYXRlKG1vZGFsUGFyYW1zKTtcbiAgICBtb2RhbFJvdXRlLm1vZGFsSW5zdGFuY2UgPSBtb2RhbDtcblxuICAgIGZ1bmN0aW9uIGNsb3NlT25Td2lwZUJhY2soKSB7XG4gICAgICBtb2RhbC5jbG9zZSgpO1xuICAgIH1cbiAgICBtb2RhbC5vbignbW9kYWxPcGVuJywgKCkgPT4ge1xuICAgICAgcm91dGVyLm9uY2UoJ3N3aXBlQmFja01vdmUnLCBjbG9zZU9uU3dpcGVCYWNrKTtcbiAgICB9KTtcbiAgICBtb2RhbC5vbignbW9kYWxDbG9zZScsICgpID0+IHtcbiAgICAgIHJvdXRlci5vZmYoJ3N3aXBlQmFja01vdmUnLCBjbG9zZU9uU3dpcGVCYWNrKTtcbiAgICAgIGlmICghbW9kYWwuY2xvc2VCeVJvdXRlcikge1xuICAgICAgICByb3V0ZXIuYmFjaygpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgbW9kYWwub24oJ21vZGFsQ2xvc2VkJywgKCkgPT4ge1xuICAgICAgbW9kYWwuJGVsLnRyaWdnZXIoYCR7bW9kYWxUeXBlLnRvTG93ZXJDYXNlKCl9OmJlZm9yZXJlbW92ZWAsIHJvdXRlLCBtb2RhbCk7XG4gICAgICBtb2RhbC5lbWl0KGBtb2RhbEJlZm9yZVJlbW92ZSAke21vZGFsVHlwZX1CZWZvcmVSZW1vdmVgLCBtb2RhbC5lbCwgcm91dGUsIG1vZGFsKTtcbiAgICAgIGNvbnN0IG1vZGFsQ29tcG9uZW50ID0gbW9kYWwuZWwuZjdDb21wb25lbnQ7XG4gICAgICBpZiAobW9kYWxDb21wb25lbnQpIHtcbiAgICAgICAgbW9kYWxDb21wb25lbnQuJGRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICAgIFV0aWxzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgaWYgKG1vZGFsQ29tcG9uZW50KSB7XG4gICAgICAgICAgcm91dGVyLnJlbW92ZU1vZGFsKG1vZGFsLmVsKTtcbiAgICAgICAgfVxuICAgICAgICBtb2RhbC5kZXN0cm95KCk7XG4gICAgICAgIGRlbGV0ZSBtb2RhbFJvdXRlLm1vZGFsSW5zdGFuY2U7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGlmIChvcHRpb25zLnJvdXRlKSB7XG4gICAgICAvLyBVcGRhdGUgQnJvd3NlciBIaXN0b3J5XG4gICAgICBpZiAocm91dGVyLnBhcmFtcy5wdXNoU3RhdGUgJiYgb3B0aW9ucy5wdXNoU3RhdGUpIHtcbiAgICAgICAgSGlzdG9yeS5wdXNoKFxuICAgICAgICAgIHJvdXRlci52aWV3LmlkLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHVybDogb3B0aW9ucy5yb3V0ZS51cmwsXG4gICAgICAgICAgICBtb2RhbDogbW9kYWxUeXBlLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgKHJvdXRlci5wYXJhbXMucHVzaFN0YXRlUm9vdCB8fCAnJykgKyByb3V0ZXIucGFyYW1zLnB1c2hTdGF0ZVNlcGFyYXRvciArIG9wdGlvbnMucm91dGUudXJsXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIC8vIFNldCBSb3V0ZVxuICAgICAgaWYgKG9wdGlvbnMucm91dGUgIT09IHJvdXRlci5jdXJyZW50Um91dGUpIHtcbiAgICAgICAgcm91dGVyLmN1cnJlbnRSb3V0ZSA9IFV0aWxzLmV4dGVuZChvcHRpb25zLnJvdXRlLCB7IG1vZGFsIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyBVcGRhdGUgUm91dGVyIEhpc3RvcnlcbiAgICAgIGlmIChvcHRpb25zLmhpc3RvcnkpIHtcbiAgICAgICAgcm91dGVyLmhpc3RvcnkucHVzaChvcHRpb25zLnJvdXRlLnVybCk7XG4gICAgICAgIHJvdXRlci5zYXZlSGlzdG9yeSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJlbW92ZSB0aGVtZSBlbGVtZW50c1xuICAgIHJvdXRlci5yZW1vdmVUaGVtZUVsZW1lbnRzKG1vZGFsLmVsKTtcblxuICAgIC8vIEVtaXQgZXZlbnRzXG4gICAgbW9kYWwuJGVsLnRyaWdnZXIoYCR7bW9kYWxUeXBlLnRvTG93ZXJDYXNlKCl9OmluaXQgJHttb2RhbFR5cGUudG9Mb3dlckNhc2UoKX06bW91bnRlZGAsIHJvdXRlLCBtb2RhbCk7XG4gICAgcm91dGVyLmVtaXQoYG1vZGFsSW5pdCAke21vZGFsVHlwZX1Jbml0ICR7bW9kYWxUeXBlfU1vdW50ZWRgLCBtb2RhbC5lbCwgcm91dGUsIG1vZGFsKTtcbiAgICAvLyBPcGVuXG4gICAgbW9kYWwub3BlbigpO1xuICB9XG5cbiAgLy8gTG9hZCBNb2RhbCBDb250ZW50XG4gIGZ1bmN0aW9uIGxvYWRNb2RhbChsb2FkTW9kYWxQYXJhbXMsIGxvYWRNb2RhbE9wdGlvbnMpIHtcbiAgICAvLyBMb2FkIE1vZGFsIFByb3BzXG4gICAgY29uc3QgeyB1cmwsIGNvbnRlbnQsIHRlbXBsYXRlLCB0ZW1wbGF0ZVVybCwgY29tcG9uZW50LCBjb21wb25lbnRVcmwgfSA9IGxvYWRNb2RhbFBhcmFtcztcblxuICAgIC8vIENvbXBvbmVudC9UZW1wbGF0ZSBDYWxsYmFja3NcbiAgICBmdW5jdGlvbiByZXNvbHZlKGNvbnRlbnRFbCkge1xuICAgICAgaWYgKGNvbnRlbnRFbCkge1xuICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnRFbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBtb2RhbFBhcmFtcy5jb250ZW50ID0gY29udGVudEVsO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbnRlbnRFbC5mN0NvbXBvbmVudCkge1xuICAgICAgICAgIGNvbnRlbnRFbC5mN0NvbXBvbmVudC4kbW91bnQoKGNvbXBvbmVudEVsKSA9PiB7XG4gICAgICAgICAgICBtb2RhbFBhcmFtcy5lbCA9IGNvbXBvbmVudEVsO1xuICAgICAgICAgICAgYXBwLnJvb3QuYXBwZW5kKGNvbXBvbmVudEVsKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtb2RhbFBhcmFtcy5lbCA9IGNvbnRlbnRFbDtcbiAgICAgICAgfVxuICAgICAgICBvbk1vZGFsTG9hZGVkKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlamVjdCgpIHtcbiAgICAgIHJvdXRlci5hbGxvd1BhZ2VDaGFuZ2UgPSB0cnVlO1xuICAgICAgcmV0dXJuIHJvdXRlcjtcbiAgICB9XG5cbiAgICBpZiAoY29udGVudCkge1xuICAgICAgcmVzb2x2ZShjb250ZW50KTtcbiAgICB9IGVsc2UgaWYgKHRlbXBsYXRlIHx8IHRlbXBsYXRlVXJsKSB7XG4gICAgICB0cnkge1xuICAgICAgICByb3V0ZXIubW9kYWxUZW1wbGF0ZUxvYWRlcih0ZW1wbGF0ZSwgdGVtcGxhdGVVcmwsIGxvYWRNb2RhbE9wdGlvbnMsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgcm91dGVyLmFsbG93UGFnZUNoYW5nZSA9IHRydWU7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNvbXBvbmVudCB8fCBjb21wb25lbnRVcmwpIHtcbiAgICAgIC8vIExvYWQgZnJvbSBjb21wb25lbnQgKEY3L1Z1ZS9SZWFjdC8uLi4pXG4gICAgICB0cnkge1xuICAgICAgICByb3V0ZXIubW9kYWxDb21wb25lbnRMb2FkZXIoYXBwLnJvb3RbMF0sIGNvbXBvbmVudCwgY29tcG9uZW50VXJsLCBsb2FkTW9kYWxPcHRpb25zLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJvdXRlci5hbGxvd1BhZ2VDaGFuZ2UgPSB0cnVlO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh1cmwpIHtcbiAgICAgIC8vIExvYWQgdXNpbmcgWEhSXG4gICAgICBpZiAocm91dGVyLnhocikge1xuICAgICAgICByb3V0ZXIueGhyLmFib3J0KCk7XG4gICAgICAgIHJvdXRlci54aHIgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJvdXRlci54aHJSZXF1ZXN0KHVybCwgbG9hZE1vZGFsT3B0aW9ucylcbiAgICAgICAgLnRoZW4oKG1vZGFsQ29udGVudCkgPT4ge1xuICAgICAgICAgIG1vZGFsUGFyYW1zLmNvbnRlbnQgPSBtb2RhbENvbnRlbnQ7XG4gICAgICAgICAgb25Nb2RhbExvYWRlZCgpO1xuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2goKCkgPT4ge1xuICAgICAgICAgIHJvdXRlci5hbGxvd1BhZ2VDaGFuZ2UgPSB0cnVlO1xuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgb25Nb2RhbExvYWRlZCgpO1xuICAgIH1cbiAgfVxuXG4gICgndXJsIGNvbnRlbnQgY29tcG9uZW50IGVsIGNvbXBvbmVudFVybCB0ZW1wbGF0ZSB0ZW1wbGF0ZVVybCcpLnNwbGl0KCcgJykuZm9yRWFjaCgobW9kYWxMb2FkUHJvcCkgPT4ge1xuICAgIGlmIChtb2RhbFBhcmFtc1ttb2RhbExvYWRQcm9wXSkge1xuICAgICAgbG9hZE1vZGFsKHsgW21vZGFsTG9hZFByb3BdOiBtb2RhbFBhcmFtc1ttb2RhbExvYWRQcm9wXSB9LCBvcHRpb25zKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIEFzeW5jXG4gIGZ1bmN0aW9uIGFzeW5jUmVzb2x2ZShyZXNvbHZlUGFyYW1zLCByZXNvbHZlT3B0aW9ucykge1xuICAgIGxvYWRNb2RhbChyZXNvbHZlUGFyYW1zLCBVdGlscy5leHRlbmQob3B0aW9ucywgcmVzb2x2ZU9wdGlvbnMpKTtcbiAgfVxuICBmdW5jdGlvbiBhc3luY1JlamVjdCgpIHtcbiAgICByb3V0ZXIuYWxsb3dQYWdlQ2hhbmdlID0gdHJ1ZTtcbiAgfVxuICBpZiAobW9kYWxQYXJhbXMuYXN5bmMpIHtcbiAgICBtb2RhbFBhcmFtcy5hc3luYy5jYWxsKHJvdXRlciwgb3B0aW9ucy5yb3V0ZSwgcm91dGVyLmN1cnJlbnRSb3V0ZSwgYXN5bmNSZXNvbHZlLCBhc3luY1JlamVjdCk7XG4gIH1cbiAgcmV0dXJuIHJvdXRlcjtcbn1cbmZ1bmN0aW9uIG1vZGFsUmVtb3ZlKG1vZGFsKSB7XG4gIFV0aWxzLmV4dGVuZChtb2RhbCwgeyBjbG9zZUJ5Um91dGVyOiB0cnVlIH0pO1xuICBtb2RhbC5jbG9zZSgpO1xufVxuXG5mdW5jdGlvbiBiYWNrd2FyZChlbCwgYmFja3dhcmRPcHRpb25zKSB7XG4gIGNvbnN0IHJvdXRlciA9IHRoaXM7XG4gIGNvbnN0IGFwcCA9IHJvdXRlci5hcHA7XG4gIGNvbnN0IHZpZXcgPSByb3V0ZXIudmlldztcblxuICBjb25zdCBvcHRpb25zID0gVXRpbHMuZXh0ZW5kKHtcbiAgICBhbmltYXRlOiByb3V0ZXIucGFyYW1zLmFuaW1hdGUsXG4gICAgcHVzaFN0YXRlOiB0cnVlLFxuICB9LCBiYWNrd2FyZE9wdGlvbnMpO1xuXG4gIGNvbnN0IGR5bmFtaWNOYXZiYXIgPSByb3V0ZXIuZHluYW1pY05hdmJhcjtcbiAgY29uc3Qgc2VwYXJhdGVOYXZiYXIgPSByb3V0ZXIuc2VwYXJhdGVOYXZiYXI7XG5cbiAgY29uc3QgJG5ld1BhZ2UgPSAkKGVsKTtcbiAgY29uc3QgJG9sZFBhZ2UgPSByb3V0ZXIuJGVsLmNoaWxkcmVuKCcucGFnZS1jdXJyZW50Jyk7XG5cbiAgaWYgKCRuZXdQYWdlLmxlbmd0aCkge1xuICAgIC8vIFJlbW92ZSB0aGVtZSBlbGVtZW50c1xuICAgIHJvdXRlci5yZW1vdmVUaGVtZUVsZW1lbnRzKCRuZXdQYWdlKTtcbiAgfVxuXG4gIGxldCAkbmF2YmFyRWw7XG4gIGxldCAkbmV3TmF2YmFySW5uZXI7XG4gIGxldCAkb2xkTmF2YmFySW5uZXI7XG5cbiAgaWYgKGR5bmFtaWNOYXZiYXIpIHtcbiAgICAkbmV3TmF2YmFySW5uZXIgPSAkbmV3UGFnZS5jaGlsZHJlbignLm5hdmJhcicpLmNoaWxkcmVuKCcubmF2YmFyLWlubmVyJyk7XG4gICAgaWYgKHNlcGFyYXRlTmF2YmFyKSB7XG4gICAgICAkbmF2YmFyRWwgPSByb3V0ZXIuJG5hdmJhckVsO1xuICAgICAgaWYgKCRuZXdOYXZiYXJJbm5lci5sZW5ndGggPiAwKSB7XG4gICAgICAgICRuZXdQYWdlLmNoaWxkcmVuKCcubmF2YmFyJykucmVtb3ZlKCk7XG4gICAgICB9XG4gICAgICBpZiAoJG5ld05hdmJhcklubmVyLmxlbmd0aCA9PT0gMCAmJiAkbmV3UGFnZVswXS5mN1BhZ2UpIHtcbiAgICAgICAgLy8gVHJ5IGZyb20gcGFnZURhdGFcbiAgICAgICAgJG5ld05hdmJhcklubmVyID0gJG5ld1BhZ2VbMF0uZjdQYWdlLiRuYXZiYXJFbDtcbiAgICAgIH1cbiAgICAgICRvbGROYXZiYXJJbm5lciA9ICRuYXZiYXJFbC5maW5kKCcubmF2YmFyLWN1cnJlbnQnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgJG9sZE5hdmJhcklubmVyID0gJG9sZFBhZ2UuY2hpbGRyZW4oJy5uYXZiYXInKS5jaGlsZHJlbignLm5hdmJhci1pbm5lcicpO1xuICAgIH1cbiAgfVxuXG4gIHJvdXRlci5hbGxvd1BhZ2VDaGFuZ2UgPSBmYWxzZTtcbiAgaWYgKCRuZXdQYWdlLmxlbmd0aCA9PT0gMCB8fCAkb2xkUGFnZS5sZW5ndGggPT09IDApIHtcbiAgICByb3V0ZXIuYWxsb3dQYWdlQ2hhbmdlID0gdHJ1ZTtcbiAgICByZXR1cm4gcm91dGVyO1xuICB9XG5cbiAgLy8gUmVtb3ZlIHRoZW1lIGVsZW1lbnRzXG4gIHJvdXRlci5yZW1vdmVUaGVtZUVsZW1lbnRzKCRuZXdQYWdlKTtcblxuICAvLyBOZXcgUGFnZVxuICAkbmV3UGFnZVxuICAgIC5hZGRDbGFzcygncGFnZS1wcmV2aW91cycpXG4gICAgLnJlbW92ZUNsYXNzKCdzdGFja2VkJylcbiAgICAucmVtb3ZlQXR0cignYXJpYS1oaWRkZW4nKTtcblxuICBpZiAoZHluYW1pY05hdmJhciAmJiAkbmV3TmF2YmFySW5uZXIubGVuZ3RoID4gMCkge1xuICAgICRuZXdOYXZiYXJJbm5lclxuICAgICAgLmFkZENsYXNzKCduYXZiYXItcHJldmlvdXMnKVxuICAgICAgLnJlbW92ZUNsYXNzKCdzdGFja2VkJylcbiAgICAgIC5yZW1vdmVBdHRyKCdhcmlhLWhpZGRlbicpO1xuICB9XG5cblxuICAvLyBSZW1vdmUgcHJldmlvdXMgcGFnZSBpbiBjYXNlIG9mIFwiZm9yY2VkXCJcbiAgbGV0IGJhY2tJbmRleDtcbiAgaWYgKG9wdGlvbnMuZm9yY2UpIHtcbiAgICBpZiAoJG9sZFBhZ2UucHJldignLnBhZ2UtcHJldmlvdXM6bm90KC5zdGFja2VkKScpLmxlbmd0aCA+IDAgfHwgJG9sZFBhZ2UucHJldignLnBhZ2UtcHJldmlvdXMnKS5sZW5ndGggPT09IDApIHtcbiAgICAgIGlmIChyb3V0ZXIuaGlzdG9yeS5pbmRleE9mKG9wdGlvbnMucm91dGUudXJsKSA+PSAwKSB7XG4gICAgICAgIGJhY2tJbmRleCA9IHJvdXRlci5oaXN0b3J5Lmxlbmd0aCAtIHJvdXRlci5oaXN0b3J5LmluZGV4T2Yob3B0aW9ucy5yb3V0ZS51cmwpIC0gMTtcbiAgICAgICAgcm91dGVyLmhpc3RvcnkgPSByb3V0ZXIuaGlzdG9yeS5zbGljZSgwLCByb3V0ZXIuaGlzdG9yeS5pbmRleE9mKG9wdGlvbnMucm91dGUudXJsKSArIDIpO1xuICAgICAgICB2aWV3Lmhpc3RvcnkgPSByb3V0ZXIuaGlzdG9yeTtcbiAgICAgIH0gZWxzZSBpZiAocm91dGVyLmhpc3RvcnlbW3JvdXRlci5oaXN0b3J5Lmxlbmd0aCAtIDJdXSkge1xuICAgICAgICByb3V0ZXIuaGlzdG9yeVtyb3V0ZXIuaGlzdG9yeS5sZW5ndGggLSAyXSA9IG9wdGlvbnMucm91dGUudXJsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcm91dGVyLmhpc3RvcnkudW5zaGlmdChyb3V0ZXIudXJsKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGJhY2tJbmRleCAmJiByb3V0ZXIucGFyYW1zLnN0YWNrUGFnZXMpIHtcbiAgICAgICAgJG9sZFBhZ2UucHJldkFsbCgnLnBhZ2UtcHJldmlvdXMnKS5lYWNoKChpbmRleCwgcGFnZVRvUmVtb3ZlKSA9PiB7XG4gICAgICAgICAgY29uc3QgJHBhZ2VUb1JlbW92ZSA9ICQocGFnZVRvUmVtb3ZlKTtcbiAgICAgICAgICBsZXQgJG5hdmJhclRvUmVtb3ZlO1xuICAgICAgICAgIGlmIChzZXBhcmF0ZU5hdmJhcikge1xuICAgICAgICAgICAgLy8gJG5hdmJhclRvUmVtb3ZlID0gJG9sZE5hdmJhcklubmVyLnByZXZBbGwoJy5uYXZiYXItcHJldmlvdXMnKS5lcShpbmRleCk7XG4gICAgICAgICAgICAkbmF2YmFyVG9SZW1vdmUgPSAkKGFwcC5uYXZiYXIuZ2V0RWxCeVBhZ2UoJHBhZ2VUb1JlbW92ZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoJHBhZ2VUb1JlbW92ZVswXSAhPT0gJG5ld1BhZ2VbMF0gJiYgJHBhZ2VUb1JlbW92ZS5pbmRleCgpID4gJG5ld1BhZ2UuaW5kZXgoKSkge1xuICAgICAgICAgICAgaWYgKHJvdXRlci5pbml0aWFsUGFnZXMuaW5kZXhPZigkcGFnZVRvUmVtb3ZlWzBdKSA+PSAwKSB7XG4gICAgICAgICAgICAgICRwYWdlVG9SZW1vdmUuYWRkQ2xhc3MoJ3N0YWNrZWQnKTtcbiAgICAgICAgICAgICAgaWYgKHNlcGFyYXRlTmF2YmFyKSB7XG4gICAgICAgICAgICAgICAgJG5hdmJhclRvUmVtb3ZlLmFkZENsYXNzKCdzdGFja2VkJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJvdXRlci5wYWdlQ2FsbGJhY2soJ2JlZm9yZVJlbW92ZScsICRwYWdlVG9SZW1vdmUsICRuYXZiYXJUb1JlbW92ZSwgJ3ByZXZpb3VzJywgdW5kZWZpbmVkLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgcm91dGVyLnJlbW92ZVBhZ2UoJHBhZ2VUb1JlbW92ZSk7XG4gICAgICAgICAgICAgIGlmIChzZXBhcmF0ZU5hdmJhciAmJiAkbmF2YmFyVG9SZW1vdmUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHJvdXRlci5yZW1vdmVOYXZiYXIoJG5hdmJhclRvUmVtb3ZlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCAkcGFnZVRvUmVtb3ZlID0gJG9sZFBhZ2UucHJldignLnBhZ2UtcHJldmlvdXM6bm90KC5zdGFja2VkKScpO1xuICAgICAgICBsZXQgJG5hdmJhclRvUmVtb3ZlO1xuICAgICAgICBpZiAoc2VwYXJhdGVOYXZiYXIpIHtcbiAgICAgICAgICAvLyAkbmF2YmFyVG9SZW1vdmUgPSAkb2xkTmF2YmFySW5uZXIucHJldignLm5hdmJhci1pbm5lcjpub3QoLnN0YWNrZWQpJyk7XG4gICAgICAgICAgJG5hdmJhclRvUmVtb3ZlID0gJChhcHAubmF2YmFyLmdldEVsQnlQYWdlKCRwYWdlVG9SZW1vdmUpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocm91dGVyLnBhcmFtcy5zdGFja1BhZ2VzICYmIHJvdXRlci5pbml0aWFsUGFnZXMuaW5kZXhPZigkcGFnZVRvUmVtb3ZlWzBdKSA+PSAwKSB7XG4gICAgICAgICAgJHBhZ2VUb1JlbW92ZS5hZGRDbGFzcygnc3RhY2tlZCcpO1xuICAgICAgICAgICRuYXZiYXJUb1JlbW92ZS5hZGRDbGFzcygnc3RhY2tlZCcpO1xuICAgICAgICB9IGVsc2UgaWYgKCRwYWdlVG9SZW1vdmUubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHJvdXRlci5wYWdlQ2FsbGJhY2soJ2JlZm9yZVJlbW92ZScsICRwYWdlVG9SZW1vdmUsICRuYXZiYXJUb1JlbW92ZSwgJ3ByZXZpb3VzJywgdW5kZWZpbmVkLCBvcHRpb25zKTtcbiAgICAgICAgICByb3V0ZXIucmVtb3ZlUGFnZSgkcGFnZVRvUmVtb3ZlKTtcbiAgICAgICAgICBpZiAoc2VwYXJhdGVOYXZiYXIgJiYgJG5hdmJhclRvUmVtb3ZlLmxlbmd0aCkge1xuICAgICAgICAgICAgcm91dGVyLnJlbW92ZU5hdmJhcigkbmF2YmFyVG9SZW1vdmUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIEluc2VydCBuZXcgcGFnZVxuICBjb25zdCBuZXdQYWdlSW5Eb20gPSAkbmV3UGFnZS5wYXJlbnRzKGRvY3VtZW50KS5sZW5ndGggPiAwO1xuICBjb25zdCBmN0NvbXBvbmVudCA9ICRuZXdQYWdlWzBdLmY3Q29tcG9uZW50O1xuXG4gIGZ1bmN0aW9uIGluc2VydFBhZ2UoKSB7XG4gICAgaWYgKCRuZXdQYWdlLm5leHQoJG9sZFBhZ2UpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgaWYgKCFuZXdQYWdlSW5Eb20gJiYgZjdDb21wb25lbnQpIHtcbiAgICAgICAgZjdDb21wb25lbnQuJG1vdW50KChjb21wb25lbnRFbCkgPT4ge1xuICAgICAgICAgICQoY29tcG9uZW50RWwpLmluc2VydEJlZm9yZSgkb2xkUGFnZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJG5ld1BhZ2UuaW5zZXJ0QmVmb3JlKCRvbGRQYWdlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNlcGFyYXRlTmF2YmFyICYmICRuZXdOYXZiYXJJbm5lci5sZW5ndGgpIHtcbiAgICAgICRuZXdOYXZiYXJJbm5lci5pbnNlcnRCZWZvcmUoJG9sZE5hdmJhcklubmVyKTtcbiAgICAgIGlmICgkb2xkTmF2YmFySW5uZXIubGVuZ3RoID4gMCkge1xuICAgICAgICAkbmV3TmF2YmFySW5uZXIuaW5zZXJ0QmVmb3JlKCRvbGROYXZiYXJJbm5lcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIXJvdXRlci4kbmF2YmFyRWwucGFyZW50cyhkb2N1bWVudCkubGVuZ3RoKSB7XG4gICAgICAgICAgcm91dGVyLiRlbC5wcmVwZW5kKHJvdXRlci4kbmF2YmFyRWwpO1xuICAgICAgICB9XG4gICAgICAgICRuYXZiYXJFbC5hcHBlbmQoJG5ld05hdmJhcklubmVyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFuZXdQYWdlSW5Eb20pIHtcbiAgICAgIHJvdXRlci5wYWdlQ2FsbGJhY2soJ21vdW50ZWQnLCAkbmV3UGFnZSwgJG5ld05hdmJhcklubmVyLCAncHJldmlvdXMnLCAnY3VycmVudCcsIG9wdGlvbnMsICRvbGRQYWdlKTtcbiAgICB9XG4gIH1cblxuICBpZiAob3B0aW9ucy5wcmVsb2FkKSB7XG4gICAgLy8gSW5zZXJ0IFBhZ2VcbiAgICBpbnNlcnRQYWdlKCk7XG4gICAgLy8gVGFiIHJvdXRlXG4gICAgaWYgKG9wdGlvbnMucm91dGUucm91dGUudGFiKSB7XG4gICAgICByb3V0ZXIudGFiTG9hZChvcHRpb25zLnJvdXRlLnJvdXRlLnRhYiwgVXRpbHMuZXh0ZW5kKHt9LCBvcHRpb25zLCB7XG4gICAgICAgIGhpc3Rvcnk6IGZhbHNlLFxuICAgICAgICBwdXNoU3RhdGU6IGZhbHNlLFxuICAgICAgICBwcmVsb2FkOiB0cnVlLFxuICAgICAgfSkpO1xuICAgIH1cbiAgICAvLyBQYWdlIGluaXQgYW5kIGJlZm9yZSBpbml0IGV2ZW50c1xuICAgIHJvdXRlci5wYWdlQ2FsbGJhY2soJ2luaXQnLCAkbmV3UGFnZSwgJG5ld05hdmJhcklubmVyLCAncHJldmlvdXMnLCAnY3VycmVudCcsIG9wdGlvbnMsICRvbGRQYWdlKTtcbiAgICBpZiAoJG5ld1BhZ2UucHJldkFsbCgnLnBhZ2UtcHJldmlvdXM6bm90KC5zdGFja2VkKScpLmxlbmd0aCA+IDApIHtcbiAgICAgICRuZXdQYWdlLnByZXZBbGwoJy5wYWdlLXByZXZpb3VzOm5vdCguc3RhY2tlZCknKS5lYWNoKChpbmRleCwgcGFnZVRvUmVtb3ZlKSA9PiB7XG4gICAgICAgIGNvbnN0ICRwYWdlVG9SZW1vdmUgPSAkKHBhZ2VUb1JlbW92ZSk7XG4gICAgICAgIGxldCAkbmF2YmFyVG9SZW1vdmU7XG4gICAgICAgIGlmIChzZXBhcmF0ZU5hdmJhcikge1xuICAgICAgICAgIC8vICRuYXZiYXJUb1JlbW92ZSA9ICRuZXdOYXZiYXJJbm5lci5wcmV2QWxsKCcubmF2YmFyLXByZXZpb3VzOm5vdCguc3RhY2tlZCknKS5lcShpbmRleCk7XG4gICAgICAgICAgJG5hdmJhclRvUmVtb3ZlID0gJChhcHAubmF2YmFyLmdldEVsQnlQYWdlKCRwYWdlVG9SZW1vdmUpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocm91dGVyLnBhcmFtcy5zdGFja1BhZ2VzICYmIHJvdXRlci5pbml0aWFsUGFnZXMuaW5kZXhPZihwYWdlVG9SZW1vdmUpID49IDApIHtcbiAgICAgICAgICAkcGFnZVRvUmVtb3ZlLmFkZENsYXNzKCdzdGFja2VkJyk7XG4gICAgICAgICAgaWYgKHNlcGFyYXRlTmF2YmFyKSB7XG4gICAgICAgICAgICAkbmF2YmFyVG9SZW1vdmUuYWRkQ2xhc3MoJ3N0YWNrZWQnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcm91dGVyLnBhZ2VDYWxsYmFjaygnYmVmb3JlUmVtb3ZlJywgJHBhZ2VUb1JlbW92ZSwgJG5hdmJhclRvUmVtb3ZlLCAncHJldmlvdXMnLCB1bmRlZmluZWQpO1xuICAgICAgICAgIHJvdXRlci5yZW1vdmVQYWdlKCRwYWdlVG9SZW1vdmUpO1xuICAgICAgICAgIGlmIChzZXBhcmF0ZU5hdmJhciAmJiAkbmF2YmFyVG9SZW1vdmUubGVuZ3RoKSB7XG4gICAgICAgICAgICByb3V0ZXIucmVtb3ZlTmF2YmFyKCRuYXZiYXJUb1JlbW92ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgcm91dGVyLmFsbG93UGFnZUNoYW5nZSA9IHRydWU7XG4gICAgcmV0dXJuIHJvdXRlcjtcbiAgfVxuXG4gIC8vIEhpc3RvcnkgU3RhdGVcbiAgaWYgKHJvdXRlci5wYXJhbXMucHVzaFN0YXRlICYmIG9wdGlvbnMucHVzaFN0YXRlKSB7XG4gICAgaWYgKGJhY2tJbmRleCkgSGlzdG9yeS5nbygtYmFja0luZGV4KTtcbiAgICBlbHNlIEhpc3RvcnkuYmFjaygpO1xuICB9XG5cbiAgLy8gVXBkYXRlIEhpc3RvcnlcbiAgaWYgKHJvdXRlci5oaXN0b3J5Lmxlbmd0aCA9PT0gMSkge1xuICAgIHJvdXRlci5oaXN0b3J5LnVuc2hpZnQocm91dGVyLnVybCk7XG4gIH1cbiAgcm91dGVyLmhpc3RvcnkucG9wKCk7XG4gIHJvdXRlci5zYXZlSGlzdG9yeSgpO1xuXG4gIC8vIEN1cnJlbnQgUGFnZSAmIE5hdmJhclxuICByb3V0ZXIuY3VycmVudFBhZ2VFbCA9ICRuZXdQYWdlWzBdO1xuICBpZiAoZHluYW1pY05hdmJhciAmJiAkbmV3TmF2YmFySW5uZXIubGVuZ3RoKSB7XG4gICAgcm91dGVyLmN1cnJlbnROYXZiYXJFbCA9ICRuZXdOYXZiYXJJbm5lclswXTtcbiAgfSBlbHNlIHtcbiAgICBkZWxldGUgcm91dGVyLmN1cnJlbnROYXZiYXJFbDtcbiAgfVxuXG4gIC8vIEN1cnJlbnQgUm91dGVcbiAgcm91dGVyLmN1cnJlbnRSb3V0ZSA9IG9wdGlvbnMucm91dGU7XG5cbiAgLy8gSW5zZXJ0IFBhZ2VcbiAgaW5zZXJ0UGFnZSgpO1xuXG4gIC8vIExvYWQgVGFiXG4gIGlmIChvcHRpb25zLnJvdXRlLnJvdXRlLnRhYikge1xuICAgIHJvdXRlci50YWJMb2FkKG9wdGlvbnMucm91dGUucm91dGUudGFiLCBVdGlscy5leHRlbmQoe30sIG9wdGlvbnMsIHtcbiAgICAgIGhpc3Rvcnk6IGZhbHNlLFxuICAgICAgcHVzaFN0YXRlOiBmYWxzZSxcbiAgICB9KSk7XG4gIH1cblxuICAvLyBQYWdlIGluaXQgYW5kIGJlZm9yZSBpbml0IGV2ZW50c1xuICByb3V0ZXIucGFnZUNhbGxiYWNrKCdpbml0JywgJG5ld1BhZ2UsICRuZXdOYXZiYXJJbm5lciwgJ3ByZXZpb3VzJywgJ2N1cnJlbnQnLCBvcHRpb25zLCAkb2xkUGFnZSk7XG5cbiAgLy8gQmVmb3JlIGFuaW1hdGlvbiBjYWxsYmFja1xuICByb3V0ZXIucGFnZUNhbGxiYWNrKCdiZWZvcmVJbicsICRuZXdQYWdlLCAkbmV3TmF2YmFySW5uZXIsICdwcmV2aW91cycsICdjdXJyZW50Jywgb3B0aW9ucyk7XG4gIHJvdXRlci5wYWdlQ2FsbGJhY2soJ2JlZm9yZU91dCcsICRvbGRQYWdlLCAkb2xkTmF2YmFySW5uZXIsICdjdXJyZW50JywgJ25leHQnLCBvcHRpb25zKTtcblxuICAvLyBBbmltYXRpb25cbiAgZnVuY3Rpb24gYWZ0ZXJBbmltYXRpb24oKSB7XG4gICAgLy8gU2V0IGNsYXNzZXNcbiAgICBjb25zdCBwYWdlQ2xhc3NlcyA9ICdwYWdlLXByZXZpb3VzIHBhZ2UtY3VycmVudCBwYWdlLW5leHQnO1xuICAgIGNvbnN0IG5hdmJhckNsYXNzZXMgPSAnbmF2YmFyLXByZXZpb3VzIG5hdmJhci1jdXJyZW50IG5hdmJhci1uZXh0JztcbiAgICAkbmV3UGFnZS5yZW1vdmVDbGFzcyhwYWdlQ2xhc3NlcykuYWRkQ2xhc3MoJ3BhZ2UtY3VycmVudCcpLnJlbW92ZUF0dHIoJ2FyaWEtaGlkZGVuJyk7XG4gICAgJG9sZFBhZ2UucmVtb3ZlQ2xhc3MocGFnZUNsYXNzZXMpLmFkZENsYXNzKCdwYWdlLW5leHQnKS5hdHRyKCdhcmlhLWhpZGRlbicsICd0cnVlJyk7XG4gICAgaWYgKGR5bmFtaWNOYXZiYXIpIHtcbiAgICAgICRuZXdOYXZiYXJJbm5lci5yZW1vdmVDbGFzcyhuYXZiYXJDbGFzc2VzKS5hZGRDbGFzcygnbmF2YmFyLWN1cnJlbnQnKS5yZW1vdmVBdHRyKCdhcmlhLWhpZGRlbicpO1xuICAgICAgJG9sZE5hdmJhcklubmVyLnJlbW92ZUNsYXNzKG5hdmJhckNsYXNzZXMpLmFkZENsYXNzKCduYXZiYXItbmV4dCcpLmF0dHIoJ2FyaWEtaGlkZGVuJywgJ3RydWUnKTtcbiAgICB9XG5cbiAgICAvLyBBZnRlciBhbmltYXRpb24gZXZlbnRcbiAgICByb3V0ZXIucGFnZUNhbGxiYWNrKCdhZnRlckluJywgJG5ld1BhZ2UsICRuZXdOYXZiYXJJbm5lciwgJ3ByZXZpb3VzJywgJ2N1cnJlbnQnLCBvcHRpb25zKTtcbiAgICByb3V0ZXIucGFnZUNhbGxiYWNrKCdhZnRlck91dCcsICRvbGRQYWdlLCAkb2xkTmF2YmFySW5uZXIsICdjdXJyZW50JywgJ25leHQnLCBvcHRpb25zKTtcblxuICAgIC8vIFJlbW92ZSBPbGQgUGFnZVxuICAgIGlmIChyb3V0ZXIucGFyYW1zLnN0YWNrUGFnZXMgJiYgcm91dGVyLmluaXRpYWxQYWdlcy5pbmRleE9mKCRvbGRQYWdlWzBdKSA+PSAwKSB7XG4gICAgICAkb2xkUGFnZS5hZGRDbGFzcygnc3RhY2tlZCcpO1xuICAgICAgaWYgKHNlcGFyYXRlTmF2YmFyKSB7XG4gICAgICAgICRvbGROYXZiYXJJbm5lci5hZGRDbGFzcygnc3RhY2tlZCcpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByb3V0ZXIucGFnZUNhbGxiYWNrKCdiZWZvcmVSZW1vdmUnLCAkb2xkUGFnZSwgJG9sZE5hdmJhcklubmVyLCAnbmV4dCcsIHVuZGVmaW5lZCwgb3B0aW9ucyk7XG4gICAgICByb3V0ZXIucmVtb3ZlUGFnZSgkb2xkUGFnZSk7XG4gICAgICBpZiAoc2VwYXJhdGVOYXZiYXIgJiYgJG9sZE5hdmJhcklubmVyLmxlbmd0aCkge1xuICAgICAgICByb3V0ZXIucmVtb3ZlTmF2YmFyKCRvbGROYXZiYXJJbm5lcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcm91dGVyLmFsbG93UGFnZUNoYW5nZSA9IHRydWU7XG4gICAgcm91dGVyLmVtaXQoJ3JvdXRlQ2hhbmdlZCcsIHJvdXRlci5jdXJyZW50Um91dGUsIHJvdXRlci5wcmV2aW91c1JvdXRlLCByb3V0ZXIpO1xuXG4gICAgLy8gUHJlbG9hZCBwcmV2aW91cyBwYWdlXG4gICAgY29uc3QgcHJlbG9hZFByZXZpb3VzUGFnZSA9IGFwcC50aGVtZSA9PT0gJ2lvcycgPyAocm91dGVyLnBhcmFtcy5wcmVsb2FkUHJldmlvdXNQYWdlIHx8IHJvdXRlci5wYXJhbXMuaW9zU3dpcGVCYWNrKSA6IHJvdXRlci5wYXJhbXMucHJlbG9hZFByZXZpb3VzUGFnZTtcbiAgICBpZiAocHJlbG9hZFByZXZpb3VzUGFnZSkge1xuICAgICAgcm91dGVyLmJhY2socm91dGVyLmhpc3Rvcnlbcm91dGVyLmhpc3RvcnkubGVuZ3RoIC0gMl0sIHsgcHJlbG9hZDogdHJ1ZSB9KTtcbiAgICB9XG4gICAgaWYgKHJvdXRlci5wYXJhbXMucHVzaFN0YXRlKSB7XG4gICAgICBIaXN0b3J5LmNsZWFyUm91dGVyUXVldWUoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzZXRQb3NpdGlvbkNsYXNzZXMoKSB7XG4gICAgY29uc3QgcGFnZUNsYXNzZXMgPSAncGFnZS1wcmV2aW91cyBwYWdlLWN1cnJlbnQgcGFnZS1uZXh0JztcbiAgICBjb25zdCBuYXZiYXJDbGFzc2VzID0gJ25hdmJhci1wcmV2aW91cyBuYXZiYXItY3VycmVudCBuYXZiYXItbmV4dCc7XG4gICAgJG9sZFBhZ2UucmVtb3ZlQ2xhc3MocGFnZUNsYXNzZXMpLmFkZENsYXNzKCdwYWdlLWN1cnJlbnQnKTtcbiAgICAkbmV3UGFnZS5yZW1vdmVDbGFzcyhwYWdlQ2xhc3NlcykuYWRkQ2xhc3MoJ3BhZ2UtcHJldmlvdXMnKS5yZW1vdmVBdHRyKCdhcmlhLWhpZGRlbicpO1xuICAgIGlmIChkeW5hbWljTmF2YmFyKSB7XG4gICAgICAkb2xkTmF2YmFySW5uZXIucmVtb3ZlQ2xhc3MobmF2YmFyQ2xhc3NlcykuYWRkQ2xhc3MoJ25hdmJhci1jdXJyZW50Jyk7XG4gICAgICAkbmV3TmF2YmFySW5uZXIucmVtb3ZlQ2xhc3MobmF2YmFyQ2xhc3NlcykuYWRkQ2xhc3MoJ25hdmJhci1wcmV2aW91cycpLnJlbW92ZUF0dHIoJ2FyaWEtaGlkZGVuJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKG9wdGlvbnMuYW5pbWF0ZSkge1xuICAgIHNldFBvc2l0aW9uQ2xhc3NlcygpO1xuICAgIHJvdXRlci5hbmltYXRlKCRvbGRQYWdlLCAkbmV3UGFnZSwgJG9sZE5hdmJhcklubmVyLCAkbmV3TmF2YmFySW5uZXIsICdiYWNrd2FyZCcsICgpID0+IHtcbiAgICAgIGFmdGVyQW5pbWF0aW9uKCk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgYWZ0ZXJBbmltYXRpb24oKTtcbiAgfVxuXG4gIHJldHVybiByb3V0ZXI7XG59XG5mdW5jdGlvbiBsb2FkQmFjayhiYWNrUGFyYW1zLCBiYWNrT3B0aW9ucywgaWdub3JlUGFnZUNoYW5nZSkge1xuICBjb25zdCByb3V0ZXIgPSB0aGlzO1xuXG4gIGlmICghcm91dGVyLmFsbG93UGFnZUNoYW5nZSAmJiAhaWdub3JlUGFnZUNoYW5nZSkgcmV0dXJuIHJvdXRlcjtcbiAgY29uc3QgcGFyYW1zID0gYmFja1BhcmFtcztcbiAgY29uc3Qgb3B0aW9ucyA9IGJhY2tPcHRpb25zO1xuICBjb25zdCB7IHVybCwgY29udGVudCwgZWwsIHBhZ2VOYW1lLCB0ZW1wbGF0ZSwgdGVtcGxhdGVVcmwsIGNvbXBvbmVudCwgY29tcG9uZW50VXJsIH0gPSBwYXJhbXM7XG5cbiAgaWYgKFxuICAgIG9wdGlvbnMucm91dGUudXJsICYmXG4gICAgcm91dGVyLnVybCA9PT0gb3B0aW9ucy5yb3V0ZS51cmwgJiZcbiAgICAhKG9wdGlvbnMucmVsb2FkQ3VycmVudCB8fCBvcHRpb25zLnJlbG9hZFByZXZpb3VzKSAmJlxuICAgICFyb3V0ZXIucGFyYW1zLmFsbG93RHVwbGljYXRlVXJsc1xuICApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoIW9wdGlvbnMucm91dGUgJiYgdXJsKSB7XG4gICAgb3B0aW9ucy5yb3V0ZSA9IHJvdXRlci5wYXJzZVJvdXRlVXJsKHVybCk7XG4gIH1cblxuICAvLyBDb21wb25lbnQgQ2FsbGJhY2tzXG4gIGZ1bmN0aW9uIHJlc29sdmUocGFnZUVsLCBuZXdPcHRpb25zKSB7XG4gICAgcmV0dXJuIHJvdXRlci5iYWNrd2FyZChwYWdlRWwsIFV0aWxzLmV4dGVuZChvcHRpb25zLCBuZXdPcHRpb25zKSk7XG4gIH1cbiAgZnVuY3Rpb24gcmVqZWN0KCkge1xuICAgIHJvdXRlci5hbGxvd1BhZ2VDaGFuZ2UgPSB0cnVlO1xuICAgIHJldHVybiByb3V0ZXI7XG4gIH1cblxuICBpZiAodXJsIHx8IHRlbXBsYXRlVXJsIHx8IGNvbXBvbmVudFVybCkge1xuICAgIHJvdXRlci5hbGxvd1BhZ2VDaGFuZ2UgPSBmYWxzZTtcbiAgfVxuXG4gIC8vIFByb2NlZWRcbiAgaWYgKGNvbnRlbnQpIHtcbiAgICByb3V0ZXIuYmFja3dhcmQocm91dGVyLmdldFBhZ2VFbChjb250ZW50KSwgb3B0aW9ucyk7XG4gIH0gZWxzZSBpZiAodGVtcGxhdGUgfHwgdGVtcGxhdGVVcmwpIHtcbiAgICAvLyBQYXJzZSB0ZW1wbGF0ZSBhbmQgc2VuZCBwYWdlIGVsZW1lbnRcbiAgICB0cnkge1xuICAgICAgcm91dGVyLnBhZ2VUZW1wbGF0ZUxvYWRlcih0ZW1wbGF0ZSwgdGVtcGxhdGVVcmwsIG9wdGlvbnMsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByb3V0ZXIuYWxsb3dQYWdlQ2hhbmdlID0gdHJ1ZTtcbiAgICAgIHRocm93IGVycjtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZWwpIHtcbiAgICAvLyBMb2FkIHBhZ2UgZnJvbSBzcGVjaWZpZWQgSFRNTEVsZW1lbnQgb3IgYnkgcGFnZSBuYW1lIGluIHBhZ2VzIGNvbnRhaW5lclxuICAgIHJvdXRlci5iYWNrd2FyZChyb3V0ZXIuZ2V0UGFnZUVsKGVsKSwgb3B0aW9ucyk7XG4gIH0gZWxzZSBpZiAocGFnZU5hbWUpIHtcbiAgICAvLyBMb2FkIHBhZ2UgYnkgcGFnZSBuYW1lIGluIHBhZ2VzIGNvbnRhaW5lclxuICAgIHJvdXRlci5iYWNrd2FyZChyb3V0ZXIuJGVsLmNoaWxkcmVuKGAucGFnZVtkYXRhLW5hbWU9XCIke3BhZ2VOYW1lfVwiXWApLmVxKDApLCBvcHRpb25zKTtcbiAgfSBlbHNlIGlmIChjb21wb25lbnQgfHwgY29tcG9uZW50VXJsKSB7XG4gICAgLy8gTG9hZCBmcm9tIGNvbXBvbmVudCAoRjcvVnVlL1JlYWN0Ly4uLilcbiAgICB0cnkge1xuICAgICAgcm91dGVyLnBhZ2VDb21wb25lbnRMb2FkZXIocm91dGVyLmVsLCBjb21wb25lbnQsIGNvbXBvbmVudFVybCwgb3B0aW9ucywgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJvdXRlci5hbGxvd1BhZ2VDaGFuZ2UgPSB0cnVlO1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgfSBlbHNlIGlmICh1cmwpIHtcbiAgICAvLyBMb2FkIHVzaW5nIFhIUlxuICAgIGlmIChyb3V0ZXIueGhyKSB7XG4gICAgICByb3V0ZXIueGhyLmFib3J0KCk7XG4gICAgICByb3V0ZXIueGhyID0gZmFsc2U7XG4gICAgfVxuICAgIHJvdXRlci54aHJSZXF1ZXN0KHVybCwgb3B0aW9ucylcbiAgICAgIC50aGVuKChwYWdlQ29udGVudCkgPT4ge1xuICAgICAgICByb3V0ZXIuYmFja3dhcmQocm91dGVyLmdldFBhZ2VFbChwYWdlQ29udGVudCksIG9wdGlvbnMpO1xuICAgICAgfSlcbiAgICAgIC5jYXRjaCgoKSA9PiB7XG4gICAgICAgIHJvdXRlci5hbGxvd1BhZ2VDaGFuZ2UgPSB0cnVlO1xuICAgICAgfSk7XG4gIH1cbiAgcmV0dXJuIHJvdXRlcjtcbn1cbmZ1bmN0aW9uIGJhY2soLi4uYXJncykge1xuICBsZXQgbmF2aWdhdGVVcmw7XG4gIGxldCBuYXZpZ2F0ZU9wdGlvbnM7XG4gIGlmICh0eXBlb2YgYXJnc1swXSA9PT0gJ29iamVjdCcpIHtcbiAgICBuYXZpZ2F0ZU9wdGlvbnMgPSBhcmdzWzBdIHx8IHt9O1xuICB9IGVsc2Uge1xuICAgIG5hdmlnYXRlVXJsID0gYXJnc1swXTtcbiAgICBuYXZpZ2F0ZU9wdGlvbnMgPSBhcmdzWzFdIHx8IHt9O1xuICB9XG5cbiAgY29uc3Qgcm91dGVyID0gdGhpcztcbiAgY29uc3QgYXBwID0gcm91dGVyLmFwcDtcbiAgaWYgKCFyb3V0ZXIudmlldykge1xuICAgIGFwcC52aWV3cy5tYWluLnJvdXRlci5iYWNrKG5hdmlnYXRlVXJsLCBuYXZpZ2F0ZU9wdGlvbnMpO1xuICAgIHJldHVybiByb3V0ZXI7XG4gIH1cblxuICBsZXQgY3VycmVudFJvdXRlSXNNb2RhbCA9IHJvdXRlci5jdXJyZW50Um91dGUubW9kYWw7XG4gIGxldCBtb2RhbFR5cGU7XG4gIGlmICghY3VycmVudFJvdXRlSXNNb2RhbCkge1xuICAgICgncG9wdXAgcG9wb3ZlciBzaGVldCBsb2dpblNjcmVlbiBhY3Rpb25zIGN1c3RvbU1vZGFsJykuc3BsaXQoJyAnKS5mb3JFYWNoKChtb2RhbExvYWRQcm9wKSA9PiB7XG4gICAgICBpZiAocm91dGVyLmN1cnJlbnRSb3V0ZS5yb3V0ZVttb2RhbExvYWRQcm9wXSkge1xuICAgICAgICBjdXJyZW50Um91dGVJc01vZGFsID0gdHJ1ZTtcbiAgICAgICAgbW9kYWxUeXBlID0gbW9kYWxMb2FkUHJvcDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBpZiAoY3VycmVudFJvdXRlSXNNb2RhbCkge1xuICAgIGNvbnN0IG1vZGFsVG9DbG9zZSA9IHJvdXRlci5jdXJyZW50Um91dGUubW9kYWwgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICByb3V0ZXIuY3VycmVudFJvdXRlLnJvdXRlLm1vZGFsSW5zdGFuY2UgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICBhcHBbbW9kYWxUeXBlXS5nZXQoKTtcbiAgICBjb25zdCBwcmV2aW91c1VybCA9IHJvdXRlci5oaXN0b3J5W3JvdXRlci5oaXN0b3J5Lmxlbmd0aCAtIDJdO1xuICAgIGxldCBwcmV2aW91c1JvdXRlID0gcm91dGVyLmZpbmRNYXRjaGluZ1JvdXRlKHByZXZpb3VzVXJsKTtcbiAgICBpZiAoIXByZXZpb3VzUm91dGUgJiYgcHJldmlvdXNVcmwpIHtcbiAgICAgIHByZXZpb3VzUm91dGUgPSB7XG4gICAgICAgIHVybDogcHJldmlvdXNVcmwsXG4gICAgICAgIHBhdGg6IHByZXZpb3VzVXJsLnNwbGl0KCc/JylbMF0sXG4gICAgICAgIHF1ZXJ5OiBVdGlscy5wYXJzZVVybFF1ZXJ5KHByZXZpb3VzVXJsKSxcbiAgICAgICAgcm91dGU6IHtcbiAgICAgICAgICBwYXRoOiBwcmV2aW91c1VybC5zcGxpdCgnPycpWzBdLFxuICAgICAgICAgIHVybDogcHJldmlvdXNVcmwsXG4gICAgICAgIH0sXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoIXByZXZpb3VzUm91dGUgfHwgIW1vZGFsVG9DbG9zZSkge1xuICAgICAgcmV0dXJuIHJvdXRlcjtcbiAgICB9XG4gICAgaWYgKHJvdXRlci5wYXJhbXMucHVzaFN0YXRlICYmIG5hdmlnYXRlT3B0aW9ucy5wdXNoU3RhdGUgIT09IGZhbHNlKSB7XG4gICAgICBIaXN0b3J5LmJhY2soKTtcbiAgICB9XG4gICAgcm91dGVyLmN1cnJlbnRSb3V0ZSA9IHByZXZpb3VzUm91dGU7XG4gICAgcm91dGVyLmhpc3RvcnkucG9wKCk7XG4gICAgcm91dGVyLnNhdmVIaXN0b3J5KCk7XG4gICAgcm91dGVyLm1vZGFsUmVtb3ZlKG1vZGFsVG9DbG9zZSk7XG4gICAgcmV0dXJuIHJvdXRlcjtcbiAgfVxuICBjb25zdCAkcHJldmlvdXNQYWdlID0gcm91dGVyLiRlbC5jaGlsZHJlbignLnBhZ2UtY3VycmVudCcpLnByZXZBbGwoJy5wYWdlLXByZXZpb3VzJykuZXEoMCk7XG4gIGlmICghbmF2aWdhdGVPcHRpb25zLmZvcmNlICYmICRwcmV2aW91c1BhZ2UubGVuZ3RoID4gMCkge1xuICAgIGlmIChyb3V0ZXIucGFyYW1zLnB1c2hTdGF0ZSAmJiAkcHJldmlvdXNQYWdlWzBdLmY3UGFnZSAmJiByb3V0ZXIuaGlzdG9yeVtyb3V0ZXIuaGlzdG9yeS5sZW5ndGggLSAyXSAhPT0gJHByZXZpb3VzUGFnZVswXS5mN1BhZ2Uucm91dGUudXJsKSB7XG4gICAgICByb3V0ZXIuYmFjayhyb3V0ZXIuaGlzdG9yeVtyb3V0ZXIuaGlzdG9yeS5sZW5ndGggLSAyXSwgVXRpbHMuZXh0ZW5kKG5hdmlnYXRlT3B0aW9ucywgeyBmb3JjZTogdHJ1ZSB9KSk7XG4gICAgICByZXR1cm4gcm91dGVyO1xuICAgIH1cbiAgICByb3V0ZXIubG9hZEJhY2soeyBlbDogJHByZXZpb3VzUGFnZSB9LCBVdGlscy5leHRlbmQobmF2aWdhdGVPcHRpb25zLCB7XG4gICAgICByb3V0ZTogJHByZXZpb3VzUGFnZVswXS5mN1BhZ2Uucm91dGUsXG4gICAgfSkpO1xuICAgIHJldHVybiByb3V0ZXI7XG4gIH1cblxuICAvLyBOYXZpZ2F0ZSBVUkxcbiAgaWYgKG5hdmlnYXRlVXJsID09PSAnIycpIHtcbiAgICBuYXZpZ2F0ZVVybCA9IHVuZGVmaW5lZDtcbiAgfVxuICBpZiAobmF2aWdhdGVVcmwgJiYgbmF2aWdhdGVVcmxbMF0gIT09ICcvJyAmJiBuYXZpZ2F0ZVVybC5pbmRleE9mKCcjJykgIT09IDApIHtcbiAgICBuYXZpZ2F0ZVVybCA9ICgocm91dGVyLnBhdGggfHwgJy8nKSArIG5hdmlnYXRlVXJsKS5yZXBsYWNlKCcvLycsICcvJyk7XG4gIH1cbiAgaWYgKCFuYXZpZ2F0ZVVybCAmJiByb3V0ZXIuaGlzdG9yeS5sZW5ndGggPiAxKSB7XG4gICAgbmF2aWdhdGVVcmwgPSByb3V0ZXIuaGlzdG9yeVtyb3V0ZXIuaGlzdG9yeS5sZW5ndGggLSAyXTtcbiAgfVxuXG4gIC8vIEZpbmQgcm91dGUgdG8gbG9hZFxuICBsZXQgcm91dGUgPSByb3V0ZXIuZmluZE1hdGNoaW5nUm91dGUobmF2aWdhdGVVcmwpO1xuICBpZiAoIXJvdXRlKSB7XG4gICAgaWYgKG5hdmlnYXRlVXJsKSB7XG4gICAgICByb3V0ZSA9IHtcbiAgICAgICAgdXJsOiBuYXZpZ2F0ZVVybCxcbiAgICAgICAgcGF0aDogbmF2aWdhdGVVcmwuc3BsaXQoJz8nKVswXSxcbiAgICAgICAgcXVlcnk6IFV0aWxzLnBhcnNlVXJsUXVlcnkobmF2aWdhdGVVcmwpLFxuICAgICAgICByb3V0ZToge1xuICAgICAgICAgIHBhdGg6IG5hdmlnYXRlVXJsLnNwbGl0KCc/JylbMF0sXG4gICAgICAgICAgdXJsOiBuYXZpZ2F0ZVVybCxcbiAgICAgICAgfSxcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIGlmICghcm91dGUpIHtcbiAgICByZXR1cm4gcm91dGVyO1xuICB9XG5cbiAgaWYgKHJvdXRlLnJvdXRlLnJlZGlyZWN0KSB7XG4gICAgcmV0dXJuIHJlZGlyZWN0LmNhbGwocm91dGVyLCAnYmFjaycsIHJvdXRlLCBuYXZpZ2F0ZU9wdGlvbnMpO1xuICB9XG5cbiAgY29uc3Qgb3B0aW9ucyA9IHt9O1xuICBpZiAocm91dGUucm91dGUub3B0aW9ucykge1xuICAgIFV0aWxzLmV4dGVuZChvcHRpb25zLCByb3V0ZS5yb3V0ZS5vcHRpb25zLCBuYXZpZ2F0ZU9wdGlvbnMsIHsgcm91dGUgfSk7XG4gIH0gZWxzZSB7XG4gICAgVXRpbHMuZXh0ZW5kKG9wdGlvbnMsIG5hdmlnYXRlT3B0aW9ucywgeyByb3V0ZSB9KTtcbiAgfVxuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuY29udGV4dCkge1xuICAgIHJvdXRlLmNvbnRleHQgPSBvcHRpb25zLmNvbnRleHQ7XG4gICAgb3B0aW9ucy5yb3V0ZS5jb250ZXh0ID0gb3B0aW9ucy5jb250ZXh0O1xuICB9XG5cbiAgaWYgKG9wdGlvbnMuZm9yY2UgJiYgcm91dGVyLnBhcmFtcy5zdGFja1BhZ2VzKSB7XG4gICAgcm91dGVyLiRlbC5jaGlsZHJlbignLnBhZ2UtcHJldmlvdXMuc3RhY2tlZCcpLmVhY2goKGluZGV4LCBwYWdlRWwpID0+IHtcbiAgICAgIGlmIChwYWdlRWwuZjdQYWdlICYmIHBhZ2VFbC5mN1BhZ2Uucm91dGUgJiYgcGFnZUVsLmY3UGFnZS5yb3V0ZS51cmwgPT09IHJvdXRlLnVybCkge1xuICAgICAgICByb3V0ZXIubG9hZEJhY2soeyBlbDogcGFnZUVsIH0sIG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgKCd1cmwgY29udGVudCBjb21wb25lbnQgcGFnZU5hbWUgZWwgY29tcG9uZW50VXJsIHRlbXBsYXRlIHRlbXBsYXRlVXJsJykuc3BsaXQoJyAnKS5mb3JFYWNoKChwYWdlTG9hZFByb3ApID0+IHtcbiAgICBpZiAocm91dGUucm91dGVbcGFnZUxvYWRQcm9wXSkge1xuICAgICAgcm91dGVyLmxvYWRCYWNrKHsgW3BhZ2VMb2FkUHJvcF06IHJvdXRlLnJvdXRlW3BhZ2VMb2FkUHJvcF0gfSwgb3B0aW9ucyk7XG4gICAgfVxuICB9KTtcbiAgLy8gQXN5bmNcbiAgZnVuY3Rpb24gYXN5bmNSZXNvbHZlKHJlc29sdmVQYXJhbXMsIHJlc29sdmVPcHRpb25zKSB7XG4gICAgcm91dGVyLmFsbG93UGFnZUNoYW5nZSA9IGZhbHNlO1xuICAgIGlmIChyZXNvbHZlT3B0aW9ucyAmJiByZXNvbHZlT3B0aW9ucy5jb250ZXh0KSB7XG4gICAgICBpZiAoIXJvdXRlLmNvbnRleHQpIHJvdXRlLmNvbnRleHQgPSByZXNvbHZlT3B0aW9ucy5jb250ZXh0O1xuICAgICAgZWxzZSByb3V0ZS5jb250ZXh0ID0gVXRpbHMuZXh0ZW5kKHt9LCByb3V0ZS5jb250ZXh0LCByZXNvbHZlT3B0aW9ucy5jb250ZXh0KTtcbiAgICAgIG9wdGlvbnMucm91dGUuY29udGV4dCA9IHJvdXRlLmNvbnRleHQ7XG4gICAgfVxuICAgIHJvdXRlci5sb2FkQmFjayhyZXNvbHZlUGFyYW1zLCBVdGlscy5leHRlbmQob3B0aW9ucywgcmVzb2x2ZU9wdGlvbnMpLCB0cnVlKTtcbiAgfVxuICBmdW5jdGlvbiBhc3luY1JlamVjdCgpIHtcbiAgICByb3V0ZXIuYWxsb3dQYWdlQ2hhbmdlID0gdHJ1ZTtcbiAgfVxuICBpZiAocm91dGUucm91dGUuYXN5bmMpIHtcbiAgICByb3V0ZXIuYWxsb3dQYWdlQ2hhbmdlID0gZmFsc2U7XG5cbiAgICByb3V0ZS5yb3V0ZS5hc3luYy5jYWxsKHJvdXRlciwgcm91dGUsIHJvdXRlci5jdXJyZW50Um91dGUsIGFzeW5jUmVzb2x2ZSwgYXN5bmNSZWplY3QpO1xuICB9XG4gIC8vIFJldHVybiBSb3V0ZXJcbiAgcmV0dXJuIHJvdXRlcjtcbn1cblxuZnVuY3Rpb24gY2xlYXJQcmV2aW91c0hpc3RvcnkoKSB7XG4gIGNvbnN0IHJvdXRlciA9IHRoaXM7XG4gIGNvbnN0IGFwcCA9IHJvdXRlci5hcHA7XG4gIGNvbnN0IHNlcGFyYXRlTmF2YmFyID0gcm91dGVyLnNlcGFyYXRlTmF2YmFyO1xuICBjb25zdCB1cmwgPSByb3V0ZXIuaGlzdG9yeVtyb3V0ZXIuaGlzdG9yeS5sZW5ndGggLSAxXTtcblxuICBjb25zdCAkY3VycmVudFBhZ2VFbCA9ICQocm91dGVyLmN1cnJlbnRQYWdlRWwpO1xuXG4gIGNvbnN0ICRwYWdlc1RvUmVtb3ZlID0gcm91dGVyLiRlbFxuICAgIC5jaGlsZHJlbignLnBhZ2U6bm90KC5zdGFja2VkKScpXG4gICAgLmZpbHRlcigoaW5kZXgsIHBhZ2VJblZpZXcpID0+IHBhZ2VJblZpZXcgIT09ICRjdXJyZW50UGFnZUVsWzBdKTtcblxuICAkcGFnZXNUb1JlbW92ZS5lYWNoKChpbmRleCwgcGFnZUVsKSA9PiB7XG4gICAgY29uc3QgJG9sZFBhZ2VFbCA9ICQocGFnZUVsKTtcbiAgICBjb25zdCAkb2xkTmF2YmFySW5uZXJFbCA9ICQoYXBwLm5hdmJhci5nZXRFbEJ5UGFnZSgkb2xkUGFnZUVsKSk7XG4gICAgaWYgKHJvdXRlci5wYXJhbXMuc3RhY2tQYWdlcyAmJiByb3V0ZXIuaW5pdGlhbFBhZ2VzLmluZGV4T2YoJG9sZFBhZ2VFbFswXSkgPj0gMCkge1xuICAgICAgJG9sZFBhZ2VFbC5hZGRDbGFzcygnc3RhY2tlZCcpO1xuICAgICAgaWYgKHNlcGFyYXRlTmF2YmFyKSB7XG4gICAgICAgICRvbGROYXZiYXJJbm5lckVsLmFkZENsYXNzKCdzdGFja2VkJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFBhZ2UgcmVtb3ZlIGV2ZW50XG4gICAgICByb3V0ZXIucGFnZUNhbGxiYWNrKCdiZWZvcmVSZW1vdmUnLCAkb2xkUGFnZUVsLCAkb2xkTmF2YmFySW5uZXJFbCwgJ3ByZXZpb3VzJywgdW5kZWZpbmVkLCB7fSk7XG4gICAgICByb3V0ZXIucmVtb3ZlUGFnZSgkb2xkUGFnZUVsKTtcbiAgICAgIGlmIChzZXBhcmF0ZU5hdmJhciAmJiAkb2xkTmF2YmFySW5uZXJFbC5sZW5ndGgpIHtcbiAgICAgICAgcm91dGVyLnJlbW92ZU5hdmJhcigkb2xkTmF2YmFySW5uZXJFbCk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICByb3V0ZXIuaGlzdG9yeSA9IFt1cmxdO1xuICByb3V0ZXIudmlldy5oaXN0b3J5ID0gW3VybF07XG4gIHJvdXRlci5zYXZlSGlzdG9yeSgpO1xufVxuXG5jbGFzcyBSb3V0ZXIgZXh0ZW5kcyBGcmFtZXdvcms3Q2xhc3Mge1xuICBjb25zdHJ1Y3RvcihhcHAsIHZpZXcpIHtcbiAgICBzdXBlcih7fSwgW3R5cGVvZiB2aWV3ID09PSAndW5kZWZpbmVkJyA/IGFwcCA6IHZpZXddKTtcbiAgICBjb25zdCByb3V0ZXIgPSB0aGlzO1xuXG4gICAgLy8gSXMgQXBwIFJvdXRlclxuICAgIHJvdXRlci5pc0FwcFJvdXRlciA9IHR5cGVvZiB2aWV3ID09PSAndW5kZWZpbmVkJztcblxuICAgIGlmIChyb3V0ZXIuaXNBcHBSb3V0ZXIpIHtcbiAgICAgIC8vIEFwcCBSb3V0ZXJcbiAgICAgIFV0aWxzLmV4dGVuZChmYWxzZSwgcm91dGVyLCB7XG4gICAgICAgIGFwcCxcbiAgICAgICAgcGFyYW1zOiBhcHAucGFyYW1zLnZpZXcsXG4gICAgICAgIHJvdXRlczogYXBwLnJvdXRlcyB8fCBbXSxcbiAgICAgICAgY2FjaGU6IGFwcC5jYWNoZSxcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBWaWV3IFJvdXRlclxuICAgICAgVXRpbHMuZXh0ZW5kKGZhbHNlLCByb3V0ZXIsIHtcbiAgICAgICAgYXBwLFxuICAgICAgICB2aWV3LFxuICAgICAgICB2aWV3SWQ6IHZpZXcuaWQsXG4gICAgICAgIHBhcmFtczogdmlldy5wYXJhbXMsXG4gICAgICAgIHJvdXRlczogdmlldy5yb3V0ZXMsXG4gICAgICAgICRlbDogdmlldy4kZWwsXG4gICAgICAgIGVsOiB2aWV3LmVsLFxuICAgICAgICAkbmF2YmFyRWw6IHZpZXcuJG5hdmJhckVsLFxuICAgICAgICBuYXZiYXJFbDogdmlldy5uYXZiYXJFbCxcbiAgICAgICAgaGlzdG9yeTogdmlldy5oaXN0b3J5LFxuICAgICAgICBzY3JvbGxIaXN0b3J5OiB2aWV3LnNjcm9sbEhpc3RvcnksXG4gICAgICAgIGNhY2hlOiBhcHAuY2FjaGUsXG4gICAgICAgIGR5bmFtaWNOYXZiYXI6IGFwcC50aGVtZSA9PT0gJ2lvcycgJiYgdmlldy5wYXJhbXMuaW9zRHluYW1pY05hdmJhcixcbiAgICAgICAgc2VwYXJhdGVOYXZiYXI6IGFwcC50aGVtZSA9PT0gJ2lvcycgJiYgdmlldy5wYXJhbXMuaW9zRHluYW1pY05hdmJhciAmJiB2aWV3LnBhcmFtcy5pb3NTZXBhcmF0ZUR5bmFtaWNOYXZiYXIsXG4gICAgICAgIGluaXRpYWxQYWdlczogW10sXG4gICAgICAgIGluaXRpYWxOYXZiYXJzOiBbXSxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIEluc3RhbGwgTW9kdWxlc1xuICAgIHJvdXRlci51c2VNb2R1bGVzKCk7XG5cbiAgICAvLyBUZW1wb3JhcnkgRG9tXG4gICAgcm91dGVyLnRlbXBEb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICAgIC8vIEFsbG93UGFnZUNoYWdlXG4gICAgcm91dGVyLmFsbG93UGFnZUNoYW5nZSA9IHRydWU7XG5cbiAgICAvLyBDdXJyZW50IFJvdXRlXG4gICAgbGV0IGN1cnJlbnRSb3V0ZSA9IHt9O1xuICAgIGxldCBwcmV2aW91c1JvdXRlID0ge307XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJvdXRlciwgJ2N1cnJlbnRSb3V0ZScsIHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBzZXQobmV3Um91dGUgPSB7fSkge1xuICAgICAgICBwcmV2aW91c1JvdXRlID0gVXRpbHMuZXh0ZW5kKHt9LCBjdXJyZW50Um91dGUpO1xuICAgICAgICBjdXJyZW50Um91dGUgPSBuZXdSb3V0ZTtcbiAgICAgICAgaWYgKCFjdXJyZW50Um91dGUpIHJldHVybjtcbiAgICAgICAgcm91dGVyLnVybCA9IGN1cnJlbnRSb3V0ZS51cmw7XG4gICAgICAgIHJvdXRlci5lbWl0KCdyb3V0ZUNoYW5nZScsIG5ld1JvdXRlLCBwcmV2aW91c1JvdXRlLCByb3V0ZXIpO1xuICAgICAgfSxcbiAgICAgIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRSb3V0ZTtcbiAgICAgIH0sXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJvdXRlciwgJ3ByZXZpb3VzUm91dGUnLCB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0KCkge1xuICAgICAgICByZXR1cm4gcHJldmlvdXNSb3V0ZTtcbiAgICAgIH0sXG4gICAgICBzZXQobmV3Um91dGUpIHtcbiAgICAgICAgcHJldmlvdXNSb3V0ZSA9IG5ld1JvdXRlO1xuICAgICAgfSxcbiAgICB9KTtcblxuICAgIFV0aWxzLmV4dGVuZChyb3V0ZXIsIHtcbiAgICAgIC8vIExvYWRcbiAgICAgIGZvcndhcmQsXG4gICAgICBsb2FkLFxuICAgICAgbmF2aWdhdGUsXG4gICAgICByZWZyZXNoUGFnZSxcbiAgICAgIC8vIFRhYlxuICAgICAgdGFiTG9hZCxcbiAgICAgIHRhYlJlbW92ZSxcbiAgICAgIC8vIE1vZGFsXG4gICAgICBtb2RhbExvYWQsXG4gICAgICBtb2RhbFJlbW92ZSxcbiAgICAgIC8vIEJhY2tcbiAgICAgIGJhY2t3YXJkLFxuICAgICAgbG9hZEJhY2ssXG4gICAgICBiYWNrLFxuICAgICAgLy8gQ2xlYXIgaGlzdG9yeVxuICAgICAgY2xlYXJQcmV2aW91c0hpc3RvcnksXG4gICAgfSk7XG5cbiAgICByZXR1cm4gcm91dGVyO1xuICB9XG4gIGFuaW1hdGFibGVOYXZFbGVtZW50cyhuZXdOYXZiYXJJbm5lciwgb2xkTmF2YmFySW5uZXIpIHtcbiAgICBjb25zdCByb3V0ZXIgPSB0aGlzO1xuICAgIGNvbnN0IGR5bmFtaWNOYXZiYXIgPSByb3V0ZXIuZHluYW1pY05hdmJhcjtcbiAgICBjb25zdCBhbmltYXRlSWNvbiA9IHJvdXRlci5wYXJhbXMuaW9zQW5pbWF0ZU5hdmJhckJhY2tJY29uO1xuXG4gICAgbGV0IG5ld05hdkVscztcbiAgICBsZXQgb2xkTmF2RWxzO1xuICAgIGZ1bmN0aW9uIGFuaW1hdGFibGVOYXZFbChlbCwgbmF2YmFySW5uZXIpIHtcbiAgICAgIGNvbnN0ICRlbCA9ICQoZWwpO1xuICAgICAgY29uc3QgaXNTbGlkaW5nID0gJGVsLmhhc0NsYXNzKCdzbGlkaW5nJykgfHwgbmF2YmFySW5uZXIuaGFzQ2xhc3MoJ3NsaWRpbmcnKTtcbiAgICAgIGNvbnN0IGlzU3VibmF2YmFyID0gJGVsLmhhc0NsYXNzKCdzdWJuYXZiYXInKTtcbiAgICAgIGNvbnN0IG5lZWRzT3BhY2l0eVRyYW5zaXRpb24gPSBpc1NsaWRpbmcgPyAhaXNTdWJuYXZiYXIgOiB0cnVlO1xuICAgICAgY29uc3QgaGFzSWNvbiA9IGlzU2xpZGluZyAmJiBhbmltYXRlSWNvbiAmJiAkZWwuaGFzQ2xhc3MoJ2xlZnQnKSAmJiAkZWwuZmluZCgnLmJhY2sgLmljb24nKS5sZW5ndGggPiAwO1xuICAgICAgbGV0ICRpY29uRWw7XG4gICAgICBpZiAoaGFzSWNvbikgJGljb25FbCA9ICRlbC5maW5kKCcuYmFjayAuaWNvbicpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgJGVsLFxuICAgICAgICAkaWNvbkVsLFxuICAgICAgICBoYXNJY29uLFxuICAgICAgICBsZWZ0T2Zmc2V0OiAkZWxbMF0uZjdOYXZiYXJMZWZ0T2Zmc2V0LFxuICAgICAgICByaWdodE9mZnNldDogJGVsWzBdLmY3TmF2YmFyUmlnaHRPZmZzZXQsXG4gICAgICAgIGlzU2xpZGluZyxcbiAgICAgICAgaXNTdWJuYXZiYXIsXG4gICAgICAgIG5lZWRzT3BhY2l0eVRyYW5zaXRpb24sXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoZHluYW1pY05hdmJhcikge1xuICAgICAgbmV3TmF2RWxzID0gW107XG4gICAgICBvbGROYXZFbHMgPSBbXTtcbiAgICAgIG5ld05hdmJhcklubmVyLmNoaWxkcmVuKCcubGVmdCwgLnJpZ2h0LCAudGl0bGUsIC5zdWJuYXZiYXInKS5lYWNoKChpbmRleCwgbmF2RWwpID0+IHtcbiAgICAgICAgbmV3TmF2RWxzLnB1c2goYW5pbWF0YWJsZU5hdkVsKG5hdkVsLCBuZXdOYXZiYXJJbm5lcikpO1xuICAgICAgfSk7XG4gICAgICBvbGROYXZiYXJJbm5lci5jaGlsZHJlbignLmxlZnQsIC5yaWdodCwgLnRpdGxlLCAuc3VibmF2YmFyJykuZWFjaCgoaW5kZXgsIG5hdkVsKSA9PiB7XG4gICAgICAgIG9sZE5hdkVscy5wdXNoKGFuaW1hdGFibGVOYXZFbChuYXZFbCwgb2xkTmF2YmFySW5uZXIpKTtcbiAgICAgIH0pO1xuICAgICAgW29sZE5hdkVscywgbmV3TmF2RWxzXS5mb3JFYWNoKChuYXZFbHMpID0+IHtcbiAgICAgICAgbmF2RWxzLmZvckVhY2goKG5hdkVsKSA9PiB7XG4gICAgICAgICAgY29uc3QgbiA9IG5hdkVsO1xuICAgICAgICAgIGNvbnN0IHsgaXNTbGlkaW5nLCAkZWwgfSA9IG5hdkVsO1xuICAgICAgICAgIGNvbnN0IG90aGVyRWxzID0gbmF2RWxzID09PSBvbGROYXZFbHMgPyBuZXdOYXZFbHMgOiBvbGROYXZFbHM7XG4gICAgICAgICAgaWYgKCEoaXNTbGlkaW5nICYmICRlbC5oYXNDbGFzcygndGl0bGUnKSAmJiBvdGhlckVscykpIHJldHVybjtcbiAgICAgICAgICBvdGhlckVscy5mb3JFYWNoKChvdGhlck5hdkVsKSA9PiB7XG4gICAgICAgICAgICBpZiAob3RoZXJOYXZFbC4kZWwuaGFzQ2xhc3MoJ2xlZnQnKSAmJiBvdGhlck5hdkVsLmhhc0ljb24pIHtcbiAgICAgICAgICAgICAgY29uc3QgaWNvblRleHRFbCA9IG90aGVyTmF2RWwuJGVsLmZpbmQoJy5iYWNrIHNwYW4nKVswXTtcbiAgICAgICAgICAgICAgbi5sZWZ0T2Zmc2V0ICs9IGljb25UZXh0RWwgPyBpY29uVGV4dEVsLm9mZnNldExlZnQgOiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB7IG5ld05hdkVscywgb2xkTmF2RWxzIH07XG4gIH1cbiAgYW5pbWF0ZVdpdGhDU1Mob2xkUGFnZSwgbmV3UGFnZSwgb2xkTmF2YmFySW5uZXIsIG5ld05hdmJhcklubmVyLCBkaXJlY3Rpb24sIGNhbGxiYWNrKSB7XG4gICAgY29uc3Qgcm91dGVyID0gdGhpcztcbiAgICBjb25zdCBkeW5hbWljTmF2YmFyID0gcm91dGVyLmR5bmFtaWNOYXZiYXI7XG4gICAgY29uc3Qgc2VwYXJhdGVOYXZiYXIgPSByb3V0ZXIuc2VwYXJhdGVOYXZiYXI7XG4gICAgY29uc3QgaW9zID0gcm91dGVyLmFwcC50aGVtZSA9PT0gJ2lvcyc7XG4gICAgLy8gUm91dGVyIEFuaW1hdGlvbiBjbGFzc1xuICAgIGNvbnN0IHJvdXRlclRyYW5zaXRpb25DbGFzcyA9IGByb3V0ZXItdHJhbnNpdGlvbi0ke2RpcmVjdGlvbn0gcm91dGVyLXRyYW5zaXRpb24tY3NzLSR7ZGlyZWN0aW9ufWA7XG5cbiAgICBsZXQgbmV3TmF2RWxzO1xuICAgIGxldCBvbGROYXZFbHM7XG4gICAgbGV0IG5hdmJhcldpZHRoID0gMDtcblxuICAgIGlmIChpb3MgJiYgZHluYW1pY05hdmJhcikge1xuICAgICAgaWYgKCFzZXBhcmF0ZU5hdmJhcikge1xuICAgICAgICBuYXZiYXJXaWR0aCA9IG5ld05hdmJhcklubmVyWzBdLm9mZnNldFdpZHRoO1xuICAgICAgfVxuICAgICAgY29uc3QgbmF2RWxzID0gcm91dGVyLmFuaW1hdGFibGVOYXZFbGVtZW50cyhuZXdOYXZiYXJJbm5lciwgb2xkTmF2YmFySW5uZXIpO1xuICAgICAgbmV3TmF2RWxzID0gbmF2RWxzLm5ld05hdkVscztcbiAgICAgIG9sZE5hdkVscyA9IG5hdkVscy5vbGROYXZFbHM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYW5pbWF0ZU5hdmJhcnMocHJvZ3Jlc3MpIHtcbiAgICAgIGlmIChpb3MgJiYgZHluYW1pY05hdmJhcikge1xuICAgICAgICBuZXdOYXZFbHMuZm9yRWFjaCgobmF2RWwpID0+IHtcbiAgICAgICAgICBjb25zdCAkZWwgPSBuYXZFbC4kZWw7XG4gICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gZGlyZWN0aW9uID09PSAnZm9yd2FyZCcgPyBuYXZFbC5yaWdodE9mZnNldCA6IG5hdkVsLmxlZnRPZmZzZXQ7XG4gICAgICAgICAgaWYgKG5hdkVsLmlzU2xpZGluZykge1xuICAgICAgICAgICAgJGVsLnRyYW5zZm9ybShgdHJhbnNsYXRlM2QoJHtvZmZzZXQgKiAoMSAtIHByb2dyZXNzKX1weCwwLDApYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChuYXZFbC5oYXNJY29uKSB7XG4gICAgICAgICAgICBpZiAoZGlyZWN0aW9uID09PSAnZm9yd2FyZCcpIHtcbiAgICAgICAgICAgICAgbmF2RWwuJGljb25FbC50cmFuc2Zvcm0oYHRyYW5zbGF0ZTNkKCR7KC1vZmZzZXQgLSBuYXZiYXJXaWR0aCkgKiAoMSAtIHByb2dyZXNzKX1weCwwLDApYCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBuYXZFbC4kaWNvbkVsLnRyYW5zZm9ybShgdHJhbnNsYXRlM2QoJHsoLW9mZnNldCArIChuYXZiYXJXaWR0aCAvIDUpKSAqICgxIC0gcHJvZ3Jlc3MpfXB4LDAsMClgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBvbGROYXZFbHMuZm9yRWFjaCgobmF2RWwpID0+IHtcbiAgICAgICAgICBjb25zdCAkZWwgPSBuYXZFbC4kZWw7XG4gICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gZGlyZWN0aW9uID09PSAnZm9yd2FyZCcgPyBuYXZFbC5sZWZ0T2Zmc2V0IDogbmF2RWwucmlnaHRPZmZzZXQ7XG4gICAgICAgICAgaWYgKG5hdkVsLmlzU2xpZGluZykge1xuICAgICAgICAgICAgJGVsLnRyYW5zZm9ybShgdHJhbnNsYXRlM2QoJHtvZmZzZXQgKiAocHJvZ3Jlc3MpfXB4LDAsMClgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG5hdkVsLmhhc0ljb24pIHtcbiAgICAgICAgICAgIGlmIChkaXJlY3Rpb24gPT09ICdmb3J3YXJkJykge1xuICAgICAgICAgICAgICBuYXZFbC4kaWNvbkVsLnRyYW5zZm9ybShgdHJhbnNsYXRlM2QoJHsoLW9mZnNldCArIChuYXZiYXJXaWR0aCAvIDUpKSAqIChwcm9ncmVzcyl9cHgsMCwwKWApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbmF2RWwuJGljb25FbC50cmFuc2Zvcm0oYHRyYW5zbGF0ZTNkKCR7KC1vZmZzZXQgLSBuYXZiYXJXaWR0aCkgKiAocHJvZ3Jlc3MpfXB4LDAsMClgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFuaW1hdGlvbkVuZCBDYWxsYmFja1xuICAgIGZ1bmN0aW9uIG9uRG9uZSgpIHtcbiAgICAgIGlmIChyb3V0ZXIuZHluYW1pY05hdmJhcikge1xuICAgICAgICBpZiAobmV3TmF2YmFySW5uZXIuaGFzQ2xhc3MoJ3NsaWRpbmcnKSkge1xuICAgICAgICAgIG5ld05hdmJhcklubmVyLmZpbmQoJy50aXRsZSwgLmxlZnQsIC5yaWdodCwgLmxlZnQgLmljb24sIC5zdWJuYXZiYXInKS50cmFuc2Zvcm0oJycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld05hdmJhcklubmVyLmZpbmQoJy5zbGlkaW5nJykudHJhbnNmb3JtKCcnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2xkTmF2YmFySW5uZXIuaGFzQ2xhc3MoJ3NsaWRpbmcnKSkge1xuICAgICAgICAgIG9sZE5hdmJhcklubmVyLmZpbmQoJy50aXRsZSwgLmxlZnQsIC5yaWdodCwgLmxlZnQgLmljb24sIC5zdWJuYXZiYXInKS50cmFuc2Zvcm0oJycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9sZE5hdmJhcklubmVyLmZpbmQoJy5zbGlkaW5nJykudHJhbnNmb3JtKCcnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcm91dGVyLiRlbC5yZW1vdmVDbGFzcyhyb3V0ZXJUcmFuc2l0aW9uQ2xhc3MpO1xuICAgICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjaygpO1xuICAgIH1cblxuICAgIChkaXJlY3Rpb24gPT09ICdmb3J3YXJkJyA/IG5ld1BhZ2UgOiBvbGRQYWdlKS5hbmltYXRpb25FbmQoKCkgPT4ge1xuICAgICAgb25Eb25lKCk7XG4gICAgfSk7XG5cbiAgICAvLyBBbmltYXRlXG4gICAgaWYgKGR5bmFtaWNOYXZiYXIpIHtcbiAgICAgIC8vIFByZXBhcmUgTmF2YmFyc1xuICAgICAgYW5pbWF0ZU5hdmJhcnMoMCk7XG4gICAgICBVdGlscy5uZXh0VGljaygoKSA9PiB7XG4gICAgICAgIC8vIEFkZCBjbGFzcywgc3RhcnQgYW5pbWF0aW9uXG4gICAgICAgIGFuaW1hdGVOYXZiYXJzKDEpO1xuICAgICAgICByb3V0ZXIuJGVsLmFkZENsYXNzKHJvdXRlclRyYW5zaXRpb25DbGFzcyk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQWRkIGNsYXNzLCBzdGFydCBhbmltYXRpb25cbiAgICAgIHJvdXRlci4kZWwuYWRkQ2xhc3Mocm91dGVyVHJhbnNpdGlvbkNsYXNzKTtcbiAgICB9XG4gIH1cbiAgYW5pbWF0ZVdpdGhKUyhvbGRQYWdlLCBuZXdQYWdlLCBvbGROYXZiYXJJbm5lciwgbmV3TmF2YmFySW5uZXIsIGRpcmVjdGlvbiwgY2FsbGJhY2spIHtcbiAgICBjb25zdCByb3V0ZXIgPSB0aGlzO1xuICAgIGNvbnN0IGR5bmFtaWNOYXZiYXIgPSByb3V0ZXIuZHluYW1pY05hdmJhcjtcbiAgICBjb25zdCBzZXBhcmF0ZU5hdmJhciA9IHJvdXRlci5zZXBhcmF0ZU5hdmJhcjtcbiAgICBjb25zdCBpb3MgPSByb3V0ZXIuYXBwLnRoZW1lID09PSAnaW9zJztcbiAgICBjb25zdCBkdXJhdGlvbiA9IGlvcyA/IDQwMCA6IDI1MDtcbiAgICBjb25zdCByb3V0ZXJUcmFuc2l0aW9uQ2xhc3MgPSBgcm91dGVyLXRyYW5zaXRpb24tJHtkaXJlY3Rpb259IHJvdXRlci10cmFuc2l0aW9uLWpzLSR7ZGlyZWN0aW9ufWA7XG5cbiAgICBsZXQgc3RhcnRUaW1lID0gbnVsbDtcbiAgICBsZXQgZG9uZSA9IGZhbHNlO1xuXG4gICAgbGV0IG5ld05hdkVscztcbiAgICBsZXQgb2xkTmF2RWxzO1xuICAgIGxldCBuYXZiYXJXaWR0aCA9IDA7XG5cbiAgICBpZiAoaW9zICYmIGR5bmFtaWNOYXZiYXIpIHtcbiAgICAgIGlmICghc2VwYXJhdGVOYXZiYXIpIHtcbiAgICAgICAgbmF2YmFyV2lkdGggPSBuZXdOYXZiYXJJbm5lclswXS5vZmZzZXRXaWR0aDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG5hdkVscyA9IHJvdXRlci5hbmltYXRhYmxlTmF2RWxlbWVudHMobmV3TmF2YmFySW5uZXIsIG9sZE5hdmJhcklubmVyKTtcbiAgICAgIG5ld05hdkVscyA9IG5hdkVscy5uZXdOYXZFbHM7XG4gICAgICBvbGROYXZFbHMgPSBuYXZFbHMub2xkTmF2RWxzO1xuICAgIH1cblxuICAgIGxldCAkc2hhZG93RWw7XG4gICAgbGV0ICRvcGFjaXR5RWw7XG5cbiAgICBpZiAoaW9zKSB7XG4gICAgICAkc2hhZG93RWwgPSAkKCc8ZGl2IGNsYXNzPVwicGFnZS1zaGFkb3ctZWZmZWN0XCI+PC9kaXY+Jyk7XG4gICAgICAkb3BhY2l0eUVsID0gJCgnPGRpdiBjbGFzcz1cInBhZ2Utb3BhY2l0eS1lZmZlY3RcIj48L2Rpdj4nKTtcblxuICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gJ2ZvcndhcmQnKSB7XG4gICAgICAgIG5ld1BhZ2UuYXBwZW5kKCRzaGFkb3dFbCk7XG4gICAgICAgIG9sZFBhZ2UuYXBwZW5kKCRvcGFjaXR5RWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV3UGFnZS5hcHBlbmQoJG9wYWNpdHlFbCk7XG4gICAgICAgIG9sZFBhZ2UuYXBwZW5kKCRzaGFkb3dFbCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGVhc2luZyA9IFV0aWxzLmJlemllcigwLjI1LCAwLjEsIDAuMjUsIDEpO1xuXG4gICAgZnVuY3Rpb24gb25Eb25lKCkge1xuICAgICAgbmV3UGFnZS50cmFuc2Zvcm0oJycpLmNzcygnb3BhY2l0eScsICcnKTtcbiAgICAgIG9sZFBhZ2UudHJhbnNmb3JtKCcnKS5jc3MoJ29wYWNpdHknLCAnJyk7XG4gICAgICBpZiAoaW9zKSB7XG4gICAgICAgICRzaGFkb3dFbC5yZW1vdmUoKTtcbiAgICAgICAgJG9wYWNpdHlFbC5yZW1vdmUoKTtcbiAgICAgICAgaWYgKGR5bmFtaWNOYXZiYXIpIHtcbiAgICAgICAgICBuZXdOYXZFbHMuZm9yRWFjaCgobmF2RWwpID0+IHtcbiAgICAgICAgICAgIG5hdkVsLiRlbC50cmFuc2Zvcm0oJycpO1xuICAgICAgICAgICAgbmF2RWwuJGVsLmNzcygnb3BhY2l0eScsICcnKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBvbGROYXZFbHMuZm9yRWFjaCgobmF2RWwpID0+IHtcbiAgICAgICAgICAgIG5hdkVsLiRlbC50cmFuc2Zvcm0oJycpO1xuICAgICAgICAgICAgbmF2RWwuJGVsLmNzcygnb3BhY2l0eScsICcnKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBuZXdOYXZFbHMgPSBbXTtcbiAgICAgICAgICBvbGROYXZFbHMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByb3V0ZXIuJGVsLnJlbW92ZUNsYXNzKHJvdXRlclRyYW5zaXRpb25DbGFzcyk7XG5cbiAgICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2soKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICBjb25zdCB0aW1lID0gVXRpbHMubm93KCk7XG4gICAgICBpZiAoIXN0YXJ0VGltZSkgc3RhcnRUaW1lID0gdGltZTtcbiAgICAgIGNvbnN0IHByb2dyZXNzID0gTWF0aC5tYXgoTWF0aC5taW4oKHRpbWUgLSBzdGFydFRpbWUpIC8gZHVyYXRpb24sIDEpLCAwKTtcbiAgICAgIGNvbnN0IGVhc2VQcm9ncmVzcyA9IGVhc2luZyhwcm9ncmVzcyk7XG5cbiAgICAgIGlmIChwcm9ncmVzcyA+PSAxKSB7XG4gICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgaW52ZXJ0ZXIgPSByb3V0ZXIuYXBwLnJ0bCA/IC0xIDogMTtcbiAgICAgIGlmIChpb3MpIHtcbiAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gJ2ZvcndhcmQnKSB7XG4gICAgICAgICAgbmV3UGFnZS50cmFuc2Zvcm0oYHRyYW5zbGF0ZTNkKCR7KDEgLSBlYXNlUHJvZ3Jlc3MpICogMTAwICogaW52ZXJ0ZXJ9JSwwLDApYCk7XG4gICAgICAgICAgb2xkUGFnZS50cmFuc2Zvcm0oYHRyYW5zbGF0ZTNkKCR7LWVhc2VQcm9ncmVzcyAqIDIwICogaW52ZXJ0ZXJ9JSwwLDApYCk7XG4gICAgICAgICAgJHNoYWRvd0VsWzBdLnN0eWxlLm9wYWNpdHkgPSBlYXNlUHJvZ3Jlc3M7XG4gICAgICAgICAgJG9wYWNpdHlFbFswXS5zdHlsZS5vcGFjaXR5ID0gZWFzZVByb2dyZXNzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld1BhZ2UudHJhbnNmb3JtKGB0cmFuc2xhdGUzZCgkey0oMSAtIGVhc2VQcm9ncmVzcykgKiAyMCAqIGludmVydGVyfSUsMCwwKWApO1xuICAgICAgICAgIG9sZFBhZ2UudHJhbnNmb3JtKGB0cmFuc2xhdGUzZCgke2Vhc2VQcm9ncmVzcyAqIDEwMCAqIGludmVydGVyfSUsMCwwKWApO1xuICAgICAgICAgICRzaGFkb3dFbFswXS5zdHlsZS5vcGFjaXR5ID0gMSAtIGVhc2VQcm9ncmVzcztcbiAgICAgICAgICAkb3BhY2l0eUVsWzBdLnN0eWxlLm9wYWNpdHkgPSAxIC0gZWFzZVByb2dyZXNzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkeW5hbWljTmF2YmFyKSB7XG4gICAgICAgICAgbmV3TmF2RWxzLmZvckVhY2goKG5hdkVsKSA9PiB7XG4gICAgICAgICAgICBjb25zdCAkZWwgPSBuYXZFbC4kZWw7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXQgPSBkaXJlY3Rpb24gPT09ICdmb3J3YXJkJyA/IG5hdkVsLnJpZ2h0T2Zmc2V0IDogbmF2RWwubGVmdE9mZnNldDtcbiAgICAgICAgICAgIGlmIChuYXZFbC5uZWVkc09wYWNpdHlUcmFuc2l0aW9uKSB7XG4gICAgICAgICAgICAgICRlbFswXS5zdHlsZS5vcGFjaXR5ID0gZWFzZVByb2dyZXNzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5hdkVsLmlzU2xpZGluZykge1xuICAgICAgICAgICAgICAkZWwudHJhbnNmb3JtKGB0cmFuc2xhdGUzZCgke29mZnNldCAqICgxIC0gZWFzZVByb2dyZXNzKX1weCwwLDApYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmF2RWwuaGFzSWNvbikge1xuICAgICAgICAgICAgICBpZiAoZGlyZWN0aW9uID09PSAnZm9yd2FyZCcpIHtcbiAgICAgICAgICAgICAgICBuYXZFbC4kaWNvbkVsLnRyYW5zZm9ybShgdHJhbnNsYXRlM2QoJHsoLW9mZnNldCAtIG5hdmJhcldpZHRoKSAqICgxIC0gZWFzZVByb2dyZXNzKX1weCwwLDApYCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbmF2RWwuJGljb25FbC50cmFuc2Zvcm0oYHRyYW5zbGF0ZTNkKCR7KC1vZmZzZXQgKyAobmF2YmFyV2lkdGggLyA1KSkgKiAoMSAtIGVhc2VQcm9ncmVzcyl9cHgsMCwwKWApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgb2xkTmF2RWxzLmZvckVhY2goKG5hdkVsKSA9PiB7XG4gICAgICAgICAgICBjb25zdCAkZWwgPSBuYXZFbC4kZWw7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXQgPSBkaXJlY3Rpb24gPT09ICdmb3J3YXJkJyA/IG5hdkVsLmxlZnRPZmZzZXQgOiBuYXZFbC5yaWdodE9mZnNldDtcbiAgICAgICAgICAgIGlmIChuYXZFbC5uZWVkc09wYWNpdHlUcmFuc2l0aW9uKSB7XG4gICAgICAgICAgICAgICRlbFswXS5zdHlsZS5vcGFjaXR5ID0gKDEgLSBlYXNlUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5hdkVsLmlzU2xpZGluZykge1xuICAgICAgICAgICAgICAkZWwudHJhbnNmb3JtKGB0cmFuc2xhdGUzZCgke29mZnNldCAqIChlYXNlUHJvZ3Jlc3MpfXB4LDAsMClgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuYXZFbC5oYXNJY29uKSB7XG4gICAgICAgICAgICAgIGlmIChkaXJlY3Rpb24gPT09ICdmb3J3YXJkJykge1xuICAgICAgICAgICAgICAgIG5hdkVsLiRpY29uRWwudHJhbnNmb3JtKGB0cmFuc2xhdGUzZCgkeygtb2Zmc2V0ICsgKG5hdmJhcldpZHRoIC8gNSkpICogKGVhc2VQcm9ncmVzcyl9cHgsMCwwKWApO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG5hdkVsLiRpY29uRWwudHJhbnNmb3JtKGB0cmFuc2xhdGUzZCgkeygtb2Zmc2V0IC0gbmF2YmFyV2lkdGgpICogKGVhc2VQcm9ncmVzcyl9cHgsMCwwKWApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSAnZm9yd2FyZCcpIHtcbiAgICAgICAgbmV3UGFnZS50cmFuc2Zvcm0oYHRyYW5zbGF0ZTNkKDAsICR7KDEgLSBlYXNlUHJvZ3Jlc3MpICogNTZ9cHgsMClgKTtcbiAgICAgICAgbmV3UGFnZS5jc3MoJ29wYWNpdHknLCBlYXNlUHJvZ3Jlc3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2xkUGFnZS50cmFuc2Zvcm0oYHRyYW5zbGF0ZTNkKDAsICR7ZWFzZVByb2dyZXNzICogNTZ9cHgsMClgKTtcbiAgICAgICAgb2xkUGFnZS5jc3MoJ29wYWNpdHknLCAxIC0gZWFzZVByb2dyZXNzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgb25Eb25lKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIFV0aWxzLm5leHRGcmFtZShyZW5kZXIpO1xuICAgIH1cblxuICAgIHJvdXRlci4kZWwuYWRkQ2xhc3Mocm91dGVyVHJhbnNpdGlvbkNsYXNzKTtcblxuICAgIFV0aWxzLm5leHRGcmFtZShyZW5kZXIpO1xuICB9XG4gIGFuaW1hdGUoLi4uYXJncykge1xuICAgIC8vIEFyZ3M6IG9sZFBhZ2UsIG5ld1BhZ2UsIG9sZE5hdmJhcklubmVyLCBuZXdOYXZiYXJJbm5lciwgZGlyZWN0aW9uLCBjYWxsYmFja1xuICAgIGNvbnN0IHJvdXRlciA9IHRoaXM7XG4gICAgaWYgKHJvdXRlci5wYXJhbXMuYW5pbWF0ZUN1c3RvbSkge1xuICAgICAgcm91dGVyLnBhcmFtcy5hbmltYXRlQ3VzdG9tLmFwcGx5KHJvdXRlciwgYXJncyk7XG4gICAgfSBlbHNlIGlmIChyb3V0ZXIucGFyYW1zLmFuaW1hdGVXaXRoSlMpIHtcbiAgICAgIHJvdXRlci5hbmltYXRlV2l0aEpTKC4uLmFyZ3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICByb3V0ZXIuYW5pbWF0ZVdpdGhDU1MoLi4uYXJncyk7XG4gICAgfVxuICB9XG4gIHJlbW92ZU1vZGFsKG1vZGFsRWwpIHtcbiAgICBjb25zdCByb3V0ZXIgPSB0aGlzO1xuICAgIHJvdXRlci5yZW1vdmVFbChtb2RhbEVsKTtcbiAgfVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgcmVtb3ZlVGFiQ29udGVudCh0YWJFbCkge1xuICAgIGNvbnN0ICR0YWJFbCA9ICQodGFiRWwpO1xuICAgICR0YWJFbC5odG1sKCcnKTtcbiAgfVxuICByZW1vdmVOYXZiYXIoZWwpIHtcbiAgICBjb25zdCByb3V0ZXIgPSB0aGlzO1xuICAgIHJvdXRlci5yZW1vdmVFbChlbCk7XG4gIH1cbiAgcmVtb3ZlUGFnZShlbCkge1xuICAgIGNvbnN0IHJvdXRlciA9IHRoaXM7XG4gICAgcm91dGVyLnJlbW92ZUVsKGVsKTtcbiAgfVxuICByZW1vdmVFbChlbCkge1xuICAgIGlmICghZWwpIHJldHVybjtcbiAgICBjb25zdCByb3V0ZXIgPSB0aGlzO1xuICAgIGNvbnN0ICRlbCA9ICQoZWwpO1xuICAgIGlmICgkZWwubGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgaWYgKCRlbFswXS5mN0NvbXBvbmVudCAmJiAkZWxbMF0uZjdDb21wb25lbnQuJGRlc3Ryb3kpIHtcbiAgICAgICRlbFswXS5mN0NvbXBvbmVudC4kZGVzdHJveSgpO1xuICAgIH1cbiAgICAkZWwuZmluZCgnLnRhYicpLmVhY2goKHRhYkluZGV4LCB0YWJFbCkgPT4ge1xuICAgICAgJCh0YWJFbCkuY2hpbGRyZW4oKS5lYWNoKChpbmRleCwgdGFiQ2hpbGQpID0+IHtcbiAgICAgICAgaWYgKHRhYkNoaWxkLmY3Q29tcG9uZW50KSB7XG4gICAgICAgICAgJCh0YWJDaGlsZCkudHJpZ2dlcigndGFiOmJlZm9yZXJlbW92ZScpO1xuICAgICAgICAgIHRhYkNoaWxkLmY3Q29tcG9uZW50LiRkZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGlmICghcm91dGVyLnBhcmFtcy5yZW1vdmVFbGVtZW50cykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAocm91dGVyLnBhcmFtcy5yZW1vdmVFbGVtZW50c1dpdGhUaW1lb3V0KSB7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgJGVsLnJlbW92ZSgpO1xuICAgICAgfSwgcm91dGVyLnBhcmFtcy5yZW1vdmVFbGVtZW50c1RpbWVvdXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAkZWwucmVtb3ZlKCk7XG4gICAgfVxuICB9XG4gIGdldFBhZ2VFbChjb250ZW50KSB7XG4gICAgY29uc3Qgcm91dGVyID0gdGhpcztcbiAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICByb3V0ZXIudGVtcERvbS5pbm5lckhUTUwgPSBjb250ZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoJChjb250ZW50KS5oYXNDbGFzcygncGFnZScpKSB7XG4gICAgICAgIHJldHVybiBjb250ZW50O1xuICAgICAgfVxuICAgICAgcm91dGVyLnRlbXBEb20uaW5uZXJIVE1MID0gJyc7XG4gICAgICAkKHJvdXRlci50ZW1wRG9tKS5hcHBlbmQoY29udGVudCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJvdXRlci5maW5kRWxlbWVudCgnLnBhZ2UnLCByb3V0ZXIudGVtcERvbSk7XG4gIH1cbiAgZmluZEVsZW1lbnQoc3RyaW5nU2VsZWN0b3IsIGNvbnRhaW5lciwgbm90U3RhY2tlZCkge1xuICAgIGNvbnN0IHJvdXRlciA9IHRoaXM7XG4gICAgY29uc3QgdmlldyA9IHJvdXRlci52aWV3O1xuICAgIGNvbnN0IGFwcCA9IHJvdXRlci5hcHA7XG5cbiAgICAvLyBNb2RhbHMgU2VsZWN0b3JcbiAgICBjb25zdCBtb2RhbHNTZWxlY3RvciA9ICcucG9wdXAsIC5kaWFsb2csIC5wb3BvdmVyLCAuYWN0aW9ucy1tb2RhbCwgLnNoZWV0LW1vZGFsLCAubG9naW4tc2NyZWVuLCAucGFnZSc7XG5cbiAgICBjb25zdCAkY29udGFpbmVyID0gJChjb250YWluZXIpO1xuICAgIGxldCBzZWxlY3RvciA9IHN0cmluZ1NlbGVjdG9yO1xuICAgIGlmIChub3RTdGFja2VkKSBzZWxlY3RvciArPSAnOm5vdCguc3RhY2tlZCknO1xuXG4gICAgbGV0IGZvdW5kID0gJGNvbnRhaW5lclxuICAgICAgLmZpbmQoc2VsZWN0b3IpXG4gICAgICAuZmlsdGVyKChpbmRleCwgZWwpID0+ICQoZWwpLnBhcmVudHMobW9kYWxzU2VsZWN0b3IpLmxlbmd0aCA9PT0gMCk7XG5cbiAgICBpZiAoZm91bmQubGVuZ3RoID4gMSkge1xuICAgICAgaWYgKHR5cGVvZiB2aWV3LnNlbGVjdG9yID09PSAnc3RyaW5nJykge1xuICAgICAgICAvLyBTZWFyY2ggaW4gcmVsYXRlZCB2aWV3XG4gICAgICAgIGZvdW5kID0gJGNvbnRhaW5lci5maW5kKGAke3ZpZXcuc2VsZWN0b3J9ICR7c2VsZWN0b3J9YCk7XG4gICAgICB9XG4gICAgICBpZiAoZm91bmQubGVuZ3RoID4gMSkge1xuICAgICAgICAvLyBTZWFyY2ggaW4gbWFpbiB2aWV3XG4gICAgICAgIGZvdW5kID0gJGNvbnRhaW5lci5maW5kKGAuJHthcHAucGFyYW1zLnZpZXdNYWluQ2xhc3N9ICR7c2VsZWN0b3J9YCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChmb3VuZC5sZW5ndGggPT09IDEpIHJldHVybiBmb3VuZDtcblxuICAgIC8vIFRyeSB0byBmaW5kIG5vdCBzdGFja2VkXG4gICAgaWYgKCFub3RTdGFja2VkKSBmb3VuZCA9IHJvdXRlci5maW5kRWxlbWVudChzZWxlY3RvciwgJGNvbnRhaW5lciwgdHJ1ZSk7XG4gICAgaWYgKGZvdW5kICYmIGZvdW5kLmxlbmd0aCA9PT0gMSkgcmV0dXJuIGZvdW5kO1xuICAgIGlmIChmb3VuZCAmJiBmb3VuZC5sZW5ndGggPiAxKSByZXR1cm4gJChmb3VuZFswXSk7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBmbGF0dGVuUm91dGVzKHJvdXRlcyA9IHRoaXMucm91dGVzKSB7XG4gICAgbGV0IGZsYXR0ZW5lZFJvdXRlcyA9IFtdO1xuICAgIHJvdXRlcy5mb3JFYWNoKChyb3V0ZSkgPT4ge1xuICAgICAgaWYgKCdyb3V0ZXMnIGluIHJvdXRlKSB7XG4gICAgICAgIGNvbnN0IG1lcmdlZFBhdGhzUm91dGVzID0gcm91dGUucm91dGVzLm1hcCgoY2hpbGRSb3V0ZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGNSb3V0ZSA9IFV0aWxzLmV4dGVuZCh7fSwgY2hpbGRSb3V0ZSk7XG4gICAgICAgICAgY1JvdXRlLnBhdGggPSAoYCR7cm91dGUucGF0aH0vJHtjUm91dGUucGF0aH1gKS5yZXBsYWNlKCcvLy8nLCAnLycpLnJlcGxhY2UoJy8vJywgJy8nKTtcbiAgICAgICAgICByZXR1cm4gY1JvdXRlO1xuICAgICAgICB9KTtcbiAgICAgICAgZmxhdHRlbmVkUm91dGVzID0gZmxhdHRlbmVkUm91dGVzLmNvbmNhdChyb3V0ZSwgdGhpcy5mbGF0dGVuUm91dGVzKG1lcmdlZFBhdGhzUm91dGVzKSk7XG4gICAgICB9IGVsc2UgaWYgKCd0YWJzJyBpbiByb3V0ZSAmJiByb3V0ZS50YWJzKSB7XG4gICAgICAgIGNvbnN0IG1lcmdlZFBhdGhzUm91dGVzID0gcm91dGUudGFicy5tYXAoKHRhYlJvdXRlKSA9PiB7XG4gICAgICAgICAgY29uc3QgdFJvdXRlID0gVXRpbHMuZXh0ZW5kKHt9LCByb3V0ZSwge1xuICAgICAgICAgICAgcGF0aDogKGAke3JvdXRlLnBhdGh9LyR7dGFiUm91dGUucGF0aH1gKS5yZXBsYWNlKCcvLy8nLCAnLycpLnJlcGxhY2UoJy8vJywgJy8nKSxcbiAgICAgICAgICAgIHBhcmVudFBhdGg6IHJvdXRlLnBhdGgsXG4gICAgICAgICAgICB0YWI6IHRhYlJvdXRlLFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGRlbGV0ZSB0Um91dGUudGFicztcbiAgICAgICAgICByZXR1cm4gdFJvdXRlO1xuICAgICAgICB9KTtcbiAgICAgICAgZmxhdHRlbmVkUm91dGVzID0gZmxhdHRlbmVkUm91dGVzLmNvbmNhdCh0aGlzLmZsYXR0ZW5Sb3V0ZXMobWVyZ2VkUGF0aHNSb3V0ZXMpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZsYXR0ZW5lZFJvdXRlcy5wdXNoKHJvdXRlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZmxhdHRlbmVkUm91dGVzO1xuICB9XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICBwYXJzZVJvdXRlVXJsKHVybCkge1xuICAgIGlmICghdXJsKSByZXR1cm4ge307XG4gICAgY29uc3QgcXVlcnkgPSBVdGlscy5wYXJzZVVybFF1ZXJ5KHVybCk7XG4gICAgY29uc3QgaGFzaCA9IHVybC5zcGxpdCgnIycpWzFdO1xuICAgIGNvbnN0IHBhcmFtcyA9IHt9O1xuICAgIGNvbnN0IHBhdGggPSB1cmwuc3BsaXQoJyMnKVswXS5zcGxpdCgnPycpWzBdO1xuICAgIHJldHVybiB7XG4gICAgICBxdWVyeSxcbiAgICAgIGhhc2gsXG4gICAgICBwYXJhbXMsXG4gICAgICB1cmwsXG4gICAgICBwYXRoLFxuICAgIH07XG4gIH1cbiAgZmluZFRhYlJvdXRlKHRhYkVsKSB7XG4gICAgY29uc3Qgcm91dGVyID0gdGhpcztcbiAgICBjb25zdCAkdGFiRWwgPSAkKHRhYkVsKTtcbiAgICBjb25zdCBwYXJlbnRQYXRoID0gcm91dGVyLmN1cnJlbnRSb3V0ZS5yb3V0ZS5wYXJlbnRQYXRoO1xuICAgIGNvbnN0IHRhYklkID0gJHRhYkVsLmF0dHIoJ2lkJyk7XG4gICAgY29uc3QgZmxhdHRlbmVkUm91dGVzID0gcm91dGVyLmZsYXR0ZW5Sb3V0ZXMocm91dGVyLnJvdXRlcyk7XG4gICAgbGV0IGZvdW5kVGFiUm91dGU7XG4gICAgZmxhdHRlbmVkUm91dGVzLmZvckVhY2goKHJvdXRlKSA9PiB7XG4gICAgICBpZiAoXG4gICAgICAgIHJvdXRlLnBhcmVudFBhdGggPT09IHBhcmVudFBhdGggJiZcbiAgICAgICAgcm91dGUudGFiICYmXG4gICAgICAgIHJvdXRlLnRhYi5pZCA9PT0gdGFiSWRcbiAgICAgICkge1xuICAgICAgICBmb3VuZFRhYlJvdXRlID0gcm91dGU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGZvdW5kVGFiUm91dGU7XG4gIH1cbiAgZmluZFJvdXRlQnlLZXkoa2V5LCB2YWx1ZSkge1xuICAgIGNvbnN0IHJvdXRlciA9IHRoaXM7XG4gICAgY29uc3Qgcm91dGVzID0gcm91dGVyLnJvdXRlcztcbiAgICBjb25zdCBmbGF0dGVuZWRSb3V0ZXMgPSByb3V0ZXIuZmxhdHRlblJvdXRlcyhyb3V0ZXMpO1xuICAgIGxldCBtYXRjaGluZ1JvdXRlO1xuXG4gICAgZmxhdHRlbmVkUm91dGVzLmZvckVhY2goKHJvdXRlKSA9PiB7XG4gICAgICBpZiAobWF0Y2hpbmdSb3V0ZSkgcmV0dXJuO1xuICAgICAgaWYgKHJvdXRlW2tleV0gPT09IHZhbHVlKSB7XG4gICAgICAgIG1hdGNoaW5nUm91dGUgPSByb3V0ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbWF0Y2hpbmdSb3V0ZTtcbiAgfVxuICBmaW5kTWF0Y2hpbmdSb3V0ZSh1cmwpIHtcbiAgICBpZiAoIXVybCkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBjb25zdCByb3V0ZXIgPSB0aGlzO1xuICAgIGNvbnN0IHJvdXRlcyA9IHJvdXRlci5yb3V0ZXM7XG4gICAgY29uc3QgZmxhdHRlbmVkUm91dGVzID0gcm91dGVyLmZsYXR0ZW5Sb3V0ZXMocm91dGVzKTtcbiAgICBjb25zdCB7IHBhdGgsIHF1ZXJ5LCBoYXNoLCBwYXJhbXMgfSA9IHJvdXRlci5wYXJzZVJvdXRlVXJsKHVybCk7XG4gICAgbGV0IG1hdGNoaW5nUm91dGU7XG4gICAgZmxhdHRlbmVkUm91dGVzLmZvckVhY2goKHJvdXRlKSA9PiB7XG4gICAgICBpZiAobWF0Y2hpbmdSb3V0ZSkgcmV0dXJuO1xuICAgICAgY29uc3Qga2V5cyA9IFtdO1xuXG4gICAgICBjb25zdCBwYXRoc1RvTWF0Y2ggPSBbcm91dGUucGF0aF07XG4gICAgICBpZiAocm91dGUuYWxpYXMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiByb3V0ZS5hbGlhcyA9PT0gJ3N0cmluZycpIHBhdGhzVG9NYXRjaC5wdXNoKHJvdXRlLmFsaWFzKTtcbiAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShyb3V0ZS5hbGlhcykpIHtcbiAgICAgICAgICByb3V0ZS5hbGlhcy5mb3JFYWNoKChhbGlhc1BhdGgpID0+IHtcbiAgICAgICAgICAgIHBhdGhzVG9NYXRjaC5wdXNoKGFsaWFzUGF0aCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbGV0IG1hdGNoZWQ7XG4gICAgICBwYXRoc1RvTWF0Y2guZm9yRWFjaCgocGF0aFRvTWF0Y2gpID0+IHtcbiAgICAgICAgaWYgKG1hdGNoZWQpIHJldHVybjtcbiAgICAgICAgbWF0Y2hlZCA9IFBhdGhUb1JlZ2V4cChwYXRoVG9NYXRjaCwga2V5cykuZXhlYyhwYXRoKTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAobWF0Y2hlZCkge1xuICAgICAgICBrZXlzLmZvckVhY2goKGtleU9iaiwgaW5kZXgpID0+IHtcbiAgICAgICAgICBjb25zdCBwYXJhbVZhbHVlID0gbWF0Y2hlZFtpbmRleCArIDFdO1xuICAgICAgICAgIHBhcmFtc1trZXlPYmoubmFtZV0gPSBwYXJhbVZhbHVlO1xuICAgICAgICB9KTtcblxuICAgICAgICBsZXQgcGFyZW50UGF0aDtcbiAgICAgICAgaWYgKHJvdXRlLnBhcmVudFBhdGgpIHtcbiAgICAgICAgICBwYXJlbnRQYXRoID0gcGF0aC5zcGxpdCgnLycpLnNsaWNlKDAsIHJvdXRlLnBhcmVudFBhdGguc3BsaXQoJy8nKS5sZW5ndGggLSAxKS5qb2luKCcvJyk7XG4gICAgICAgIH1cblxuICAgICAgICBtYXRjaGluZ1JvdXRlID0ge1xuICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgIGhhc2gsXG4gICAgICAgICAgcGFyYW1zLFxuICAgICAgICAgIHVybCxcbiAgICAgICAgICBwYXRoLFxuICAgICAgICAgIHBhcmVudFBhdGgsXG4gICAgICAgICAgcm91dGUsXG4gICAgICAgICAgbmFtZTogcm91dGUubmFtZSxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbWF0Y2hpbmdSb3V0ZTtcbiAgfVxuICByZW1vdmVGcm9tWGhyQ2FjaGUodXJsKSB7XG4gICAgY29uc3Qgcm91dGVyID0gdGhpcztcbiAgICBjb25zdCB4aHJDYWNoZSA9IHJvdXRlci5jYWNoZS54aHI7XG4gICAgbGV0IGluZGV4ID0gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB4aHJDYWNoZS5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgaWYgKHhockNhY2hlW2ldLnVybCA9PT0gdXJsKSBpbmRleCA9IGk7XG4gICAgfVxuICAgIGlmIChpbmRleCAhPT0gZmFsc2UpIHhockNhY2hlLnNwbGljZShpbmRleCwgMSk7XG4gIH1cbiAgeGhyUmVxdWVzdChyZXF1ZXN0VXJsLCBvcHRpb25zKSB7XG4gICAgY29uc3Qgcm91dGVyID0gdGhpcztcbiAgICBjb25zdCBwYXJhbXMgPSByb3V0ZXIucGFyYW1zO1xuICAgIGNvbnN0IHsgaWdub3JlQ2FjaGUgfSA9IG9wdGlvbnM7XG4gICAgbGV0IHVybCA9IHJlcXVlc3RVcmw7XG5cbiAgICBsZXQgaGFzUXVlcnkgPSB1cmwuaW5kZXhPZignPycpID49IDA7XG4gICAgaWYgKHBhcmFtcy5wYXNzUm91dGVRdWVyeVRvUmVxdWVzdCAmJlxuICAgICAgb3B0aW9ucyAmJlxuICAgICAgb3B0aW9ucy5yb3V0ZSAmJlxuICAgICAgb3B0aW9ucy5yb3V0ZS5xdWVyeSAmJlxuICAgICAgT2JqZWN0LmtleXMob3B0aW9ucy5yb3V0ZS5xdWVyeSkubGVuZ3RoXG4gICAgKSB7XG4gICAgICB1cmwgKz0gYCR7aGFzUXVlcnkgPyAnJicgOiAnPyd9JHtVdGlscy5zZXJpYWxpemVPYmplY3Qob3B0aW9ucy5yb3V0ZS5xdWVyeSl9YDtcbiAgICAgIGhhc1F1ZXJ5ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAocGFyYW1zLnBhc3NSb3V0ZVBhcmFtc1RvUmVxdWVzdCAmJlxuICAgICAgb3B0aW9ucyAmJlxuICAgICAgb3B0aW9ucy5yb3V0ZSAmJlxuICAgICAgb3B0aW9ucy5yb3V0ZS5wYXJhbXMgJiZcbiAgICAgIE9iamVjdC5rZXlzKG9wdGlvbnMucm91dGUucGFyYW1zKS5sZW5ndGhcbiAgICApIHtcbiAgICAgIHVybCArPSBgJHtoYXNRdWVyeSA/ICcmJyA6ICc/J30ke1V0aWxzLnNlcmlhbGl6ZU9iamVjdChvcHRpb25zLnJvdXRlLnBhcmFtcyl9YDtcbiAgICAgIGhhc1F1ZXJ5ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodXJsLmluZGV4T2YoJ3t7JykgPj0gMCAmJlxuICAgICAgb3B0aW9ucyAmJlxuICAgICAgb3B0aW9ucy5yb3V0ZSAmJlxuICAgICAgb3B0aW9ucy5yb3V0ZS5wYXJhbXMgJiZcbiAgICAgIE9iamVjdC5rZXlzKG9wdGlvbnMucm91dGUucGFyYW1zKS5sZW5ndGhcbiAgICApIHtcbiAgICAgIE9iamVjdC5rZXlzKG9wdGlvbnMucm91dGUucGFyYW1zKS5mb3JFYWNoKChwYXJhbU5hbWUpID0+IHtcbiAgICAgICAgY29uc3QgcmVnRXhwID0gbmV3IFJlZ0V4cChge3ske3BhcmFtTmFtZX19fWAsICdnJyk7XG4gICAgICAgIHVybCA9IHVybC5yZXBsYWNlKHJlZ0V4cCwgb3B0aW9ucy5yb3V0ZS5wYXJhbXNbcGFyYW1OYW1lXSB8fCAnJyk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLy8gc2hvdWxkIHdlIGlnbm9yZSBnZXQgcGFyYW1zIG9yIG5vdFxuICAgIGlmIChwYXJhbXMueGhyQ2FjaGVJZ25vcmVHZXRQYXJhbWV0ZXJzICYmIHVybC5pbmRleE9mKCc/JykgPj0gMCkge1xuICAgICAgdXJsID0gdXJsLnNwbGl0KCc/JylbMF07XG4gICAgfVxuICAgIHJldHVybiBVdGlscy5wcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGlmIChwYXJhbXMueGhyQ2FjaGUgJiYgIWlnbm9yZUNhY2hlICYmIHVybC5pbmRleE9mKCdub2NhY2hlJykgPCAwICYmIHBhcmFtcy54aHJDYWNoZUlnbm9yZS5pbmRleE9mKHVybCkgPCAwKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcm91dGVyLmNhY2hlLnhoci5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgIGNvbnN0IGNhY2hlZFVybCA9IHJvdXRlci5jYWNoZS54aHJbaV07XG4gICAgICAgICAgaWYgKGNhY2hlZFVybC51cmwgPT09IHVybCkge1xuICAgICAgICAgICAgLy8gQ2hlY2sgZXhwaXJhdGlvblxuICAgICAgICAgICAgaWYgKFV0aWxzLm5vdygpIC0gY2FjaGVkVXJsLnRpbWUgPCBwYXJhbXMueGhyQ2FjaGVEdXJhdGlvbikge1xuICAgICAgICAgICAgICAvLyBMb2FkIGZyb20gY2FjaGVcbiAgICAgICAgICAgICAgcmVzb2x2ZShjYWNoZWRVcmwuY29udGVudCk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJvdXRlci54aHIgPSByb3V0ZXIuYXBwLnJlcXVlc3Qoe1xuICAgICAgICB1cmwsXG4gICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgIGJlZm9yZVNlbmQoeGhyKSB7XG4gICAgICAgICAgcm91dGVyLmVtaXQoJ3JvdXRlckFqYXhTdGFydCcsIHhociwgb3B0aW9ucyk7XG4gICAgICAgIH0sXG4gICAgICAgIGNvbXBsZXRlKHhociwgc3RhdHVzKSB7XG4gICAgICAgICAgcm91dGVyLmVtaXQoJ3JvdXRlckFqYXhDb21wbGV0ZScsIHhocik7XG4gICAgICAgICAgaWYgKChzdGF0dXMgIT09ICdlcnJvcicgJiYgc3RhdHVzICE9PSAndGltZW91dCcgJiYgKHhoci5zdGF0dXMgPj0gMjAwICYmIHhoci5zdGF0dXMgPCAzMDApKSB8fCB4aHIuc3RhdHVzID09PSAwKSB7XG4gICAgICAgICAgICBpZiAocGFyYW1zLnhockNhY2hlICYmIHhoci5yZXNwb25zZVRleHQgIT09ICcnKSB7XG4gICAgICAgICAgICAgIHJvdXRlci5yZW1vdmVGcm9tWGhyQ2FjaGUodXJsKTtcbiAgICAgICAgICAgICAgcm91dGVyLmNhY2hlLnhoci5wdXNoKHtcbiAgICAgICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICAgICAgdGltZTogVXRpbHMubm93KCksXG4gICAgICAgICAgICAgICAgY29udGVudDogeGhyLnJlc3BvbnNlVGV4dCxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByb3V0ZXIuZW1pdCgncm91dGVyQWpheFN1Y2Nlc3MnLCB4aHIsIG9wdGlvbnMpO1xuICAgICAgICAgICAgcmVzb2x2ZSh4aHIucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcm91dGVyLmVtaXQoJ3JvdXRlckFqYXhFcnJvcicsIHhociwgb3B0aW9ucyk7XG4gICAgICAgICAgICByZWplY3QoeGhyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yKHhocikge1xuICAgICAgICAgIHJvdXRlci5lbWl0KCdyb3V0ZXJBamF4RXJyb3InLCB4aHIsIG9wdGlvbnMpO1xuICAgICAgICAgIHJlamVjdCh4aHIpO1xuICAgICAgICB9LFxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgLy8gUmVtb3ZlIHRoZW1lIGVsZW1lbnRzXG4gIHJlbW92ZVRoZW1lRWxlbWVudHMoZWwpIHtcbiAgICBjb25zdCByb3V0ZXIgPSB0aGlzO1xuICAgIGNvbnN0IHRoZW1lID0gcm91dGVyLmFwcC50aGVtZTtcbiAgICAkKGVsKS5maW5kKGAuJHt0aGVtZSA9PT0gJ21kJyA/ICdpb3MnIDogJ21kJ30tb25seSwgLmlmLSR7dGhlbWUgPT09ICdtZCcgPyAnaW9zJyA6ICdtZCd9YCkucmVtb3ZlKCk7XG4gIH1cbiAgdGVtcGxhdGVMb2FkZXIodGVtcGxhdGUsIHRlbXBsYXRlVXJsLCBvcHRpb25zLCByZXNvbHZlLCByZWplY3QpIHtcbiAgICBjb25zdCByb3V0ZXIgPSB0aGlzO1xuICAgIGZ1bmN0aW9uIGNvbXBpbGUodCkge1xuICAgICAgbGV0IGNvbXBpbGVkSHRtbDtcbiAgICAgIGxldCBjb250ZXh0O1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29udGV4dCA9IG9wdGlvbnMuY29udGV4dCB8fCB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBjb250ZXh0ID09PSAnZnVuY3Rpb24nKSBjb250ZXh0ID0gY29udGV4dC5jYWxsKHJvdXRlcik7XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBjb250ZXh0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb250ZXh0ID0gSlNPTi5wYXJzZShjb250ZXh0KTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHJlamVjdCgpO1xuICAgICAgICAgICAgdGhyb3cgKGVycik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGNvbXBpbGVkSHRtbCA9IHQoY29udGV4dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29tcGlsZWRIdG1sID0gVGVtcGxhdGU3LmNvbXBpbGUodCkoVXRpbHMuZXh0ZW5kKHt9LCBjb250ZXh0IHx8IHt9LCB7XG4gICAgICAgICAgICAkYXBwOiByb3V0ZXIuYXBwLFxuICAgICAgICAgICAgJHJvb3Q6IFV0aWxzLmV4dGVuZCh7fSwgcm91dGVyLmFwcC5kYXRhLCByb3V0ZXIuYXBwLm1ldGhvZHMpLFxuICAgICAgICAgICAgJHJvdXRlOiBvcHRpb25zLnJvdXRlLFxuICAgICAgICAgICAgJHJvdXRlcjogcm91dGVyLFxuICAgICAgICAgICAgJHRoZW1lOiB7XG4gICAgICAgICAgICAgIGlvczogcm91dGVyLmFwcC50aGVtZSA9PT0gJ2lvcycsXG4gICAgICAgICAgICAgIG1kOiByb3V0ZXIuYXBwLnRoZW1lID09PSAnbWQnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICByZWplY3QoKTtcbiAgICAgICAgdGhyb3cgKGVycik7XG4gICAgICB9XG4gICAgICByZXNvbHZlKGNvbXBpbGVkSHRtbCwgeyBjb250ZXh0IH0pO1xuICAgIH1cbiAgICBpZiAodGVtcGxhdGVVcmwpIHtcbiAgICAgIC8vIExvYWQgdmlhIFhIUlxuICAgICAgaWYgKHJvdXRlci54aHIpIHtcbiAgICAgICAgcm91dGVyLnhoci5hYm9ydCgpO1xuICAgICAgICByb3V0ZXIueGhyID0gZmFsc2U7XG4gICAgICB9XG4gICAgICByb3V0ZXJcbiAgICAgICAgLnhoclJlcXVlc3QodGVtcGxhdGVVcmwsIG9wdGlvbnMpXG4gICAgICAgIC50aGVuKCh0ZW1wbGF0ZUNvbnRlbnQpID0+IHtcbiAgICAgICAgICBjb21waWxlKHRlbXBsYXRlQ29udGVudCk7XG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaCgoKSA9PiB7XG4gICAgICAgICAgcmVqZWN0KCk7XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb21waWxlKHRlbXBsYXRlKTtcbiAgICB9XG4gIH1cbiAgbW9kYWxUZW1wbGF0ZUxvYWRlcih0ZW1wbGF0ZSwgdGVtcGxhdGVVcmwsIG9wdGlvbnMsIHJlc29sdmUsIHJlamVjdCkge1xuICAgIGNvbnN0IHJvdXRlciA9IHRoaXM7XG4gICAgcmV0dXJuIHJvdXRlci50ZW1wbGF0ZUxvYWRlcih0ZW1wbGF0ZSwgdGVtcGxhdGVVcmwsIG9wdGlvbnMsIChodG1sKSA9PiB7XG4gICAgICByZXNvbHZlKGh0bWwpO1xuICAgIH0sIHJlamVjdCk7XG4gIH1cbiAgdGFiVGVtcGxhdGVMb2FkZXIodGVtcGxhdGUsIHRlbXBsYXRlVXJsLCBvcHRpb25zLCByZXNvbHZlLCByZWplY3QpIHtcbiAgICBjb25zdCByb3V0ZXIgPSB0aGlzO1xuICAgIHJldHVybiByb3V0ZXIudGVtcGxhdGVMb2FkZXIodGVtcGxhdGUsIHRlbXBsYXRlVXJsLCBvcHRpb25zLCAoaHRtbCkgPT4ge1xuICAgICAgcmVzb2x2ZShodG1sKTtcbiAgICB9LCByZWplY3QpO1xuICB9XG4gIHBhZ2VUZW1wbGF0ZUxvYWRlcih0ZW1wbGF0ZSwgdGVtcGxhdGVVcmwsIG9wdGlvbnMsIHJlc29sdmUsIHJlamVjdCkge1xuICAgIGNvbnN0IHJvdXRlciA9IHRoaXM7XG4gICAgcmV0dXJuIHJvdXRlci50ZW1wbGF0ZUxvYWRlcih0ZW1wbGF0ZSwgdGVtcGxhdGVVcmwsIG9wdGlvbnMsIChodG1sLCBuZXdPcHRpb25zID0ge30pID0+IHtcbiAgICAgIHJlc29sdmUocm91dGVyLmdldFBhZ2VFbChodG1sKSwgbmV3T3B0aW9ucyk7XG4gICAgfSwgcmVqZWN0KTtcbiAgfVxuICBjb21wb25lbnRMb2FkZXIoY29tcG9uZW50LCBjb21wb25lbnRVcmwsIG9wdGlvbnMgPSB7fSwgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgY29uc3Qgcm91dGVyID0gdGhpcztcbiAgICBjb25zdCB1cmwgPSB0eXBlb2YgY29tcG9uZW50ID09PSAnc3RyaW5nJyA/IGNvbXBvbmVudCA6IGNvbXBvbmVudFVybDtcbiAgICBmdW5jdGlvbiBjb21waWxlKGMpIHtcbiAgICAgIGxldCBjb250ZXh0ID0gb3B0aW9ucy5jb250ZXh0IHx8IHt9O1xuICAgICAgaWYgKHR5cGVvZiBjb250ZXh0ID09PSAnZnVuY3Rpb24nKSBjb250ZXh0ID0gY29udGV4dC5jYWxsKHJvdXRlcik7XG4gICAgICBlbHNlIGlmICh0eXBlb2YgY29udGV4dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb250ZXh0ID0gSlNPTi5wYXJzZShjb250ZXh0KTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgcmVqZWN0KCk7XG4gICAgICAgICAgdGhyb3cgKGVycik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IGV4dGVuZENvbnRleHQgPSBVdGlscy5tZXJnZShcbiAgICAgICAge30sXG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIHtcbiAgICAgICAgICAkLFxuICAgICAgICAgICQkOiAkLFxuICAgICAgICAgICRhcHA6IHJvdXRlci5hcHAsXG4gICAgICAgICAgJHJvb3Q6IFV0aWxzLm1lcmdlKHt9LCByb3V0ZXIuYXBwLmRhdGEsIHJvdXRlci5hcHAubWV0aG9kcyksXG4gICAgICAgICAgJHJvdXRlOiBvcHRpb25zLnJvdXRlLFxuICAgICAgICAgICRyb3V0ZXI6IHJvdXRlcixcbiAgICAgICAgICAkZG9tNzogJCxcbiAgICAgICAgICAkdGhlbWU6IHtcbiAgICAgICAgICAgIGlvczogcm91dGVyLmFwcC50aGVtZSA9PT0gJ2lvcycsXG4gICAgICAgICAgICBtZDogcm91dGVyLmFwcC50aGVtZSA9PT0gJ21kJyxcbiAgICAgICAgICB9LFxuICAgICAgICB9XG4gICAgICApO1xuICAgICAgY29uc3QgY3JlYXRlZENvbXBvbmVudCA9IENvbXBvbmVudC5jcmVhdGUoYywgZXh0ZW5kQ29udGV4dCk7XG4gICAgICByZXNvbHZlKGNyZWF0ZWRDb21wb25lbnQuZWwpO1xuICAgIH1cbiAgICBpZiAodXJsKSB7XG4gICAgICAvLyBMb2FkIHZpYSBYSFJcbiAgICAgIGlmIChyb3V0ZXIueGhyKSB7XG4gICAgICAgIHJvdXRlci54aHIuYWJvcnQoKTtcbiAgICAgICAgcm91dGVyLnhociA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgcm91dGVyXG4gICAgICAgIC54aHJSZXF1ZXN0KHVybCwgb3B0aW9ucylcbiAgICAgICAgLnRoZW4oKGxvYWRlZENvbXBvbmVudCkgPT4ge1xuICAgICAgICAgIGNvbXBpbGUoQ29tcG9uZW50LnBhcnNlKGxvYWRlZENvbXBvbmVudCkpO1xuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgIHJlamVjdCgpO1xuICAgICAgICAgIHRocm93IChlcnIpO1xuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29tcGlsZShjb21wb25lbnQpO1xuICAgIH1cbiAgfVxuICBtb2RhbENvbXBvbmVudExvYWRlcihyb290RWwsIGNvbXBvbmVudCwgY29tcG9uZW50VXJsLCBvcHRpb25zLCByZXNvbHZlLCByZWplY3QpIHtcbiAgICBjb25zdCByb3V0ZXIgPSB0aGlzO1xuICAgIHJvdXRlci5jb21wb25lbnRMb2FkZXIoY29tcG9uZW50LCBjb21wb25lbnRVcmwsIG9wdGlvbnMsIChlbCkgPT4ge1xuICAgICAgcmVzb2x2ZShlbCk7XG4gICAgfSwgcmVqZWN0KTtcbiAgfVxuICB0YWJDb21wb25lbnRMb2FkZXIodGFiRWwsIGNvbXBvbmVudCwgY29tcG9uZW50VXJsLCBvcHRpb25zLCByZXNvbHZlLCByZWplY3QpIHtcbiAgICBjb25zdCByb3V0ZXIgPSB0aGlzO1xuICAgIHJvdXRlci5jb21wb25lbnRMb2FkZXIoY29tcG9uZW50LCBjb21wb25lbnRVcmwsIG9wdGlvbnMsIChlbCkgPT4ge1xuICAgICAgcmVzb2x2ZShlbCk7XG4gICAgfSwgcmVqZWN0KTtcbiAgfVxuICBwYWdlQ29tcG9uZW50TG9hZGVyKHJvdXRlckVsLCBjb21wb25lbnQsIGNvbXBvbmVudFVybCwgb3B0aW9ucywgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgY29uc3Qgcm91dGVyID0gdGhpcztcbiAgICByb3V0ZXIuY29tcG9uZW50TG9hZGVyKGNvbXBvbmVudCwgY29tcG9uZW50VXJsLCBvcHRpb25zLCAoZWwsIG5ld09wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgcmVzb2x2ZShlbCwgbmV3T3B0aW9ucyk7XG4gICAgfSwgcmVqZWN0KTtcbiAgfVxuICBnZXRQYWdlRGF0YShwYWdlRWwsIG5hdmJhckVsLCBmcm9tLCB0bywgcm91dGUgPSB7fSwgcGFnZUZyb21FbCkge1xuICAgIGNvbnN0IHJvdXRlciA9IHRoaXM7XG4gICAgY29uc3QgJHBhZ2VFbCA9ICQocGFnZUVsKTtcbiAgICBjb25zdCAkbmF2YmFyRWwgPSAkKG5hdmJhckVsKTtcbiAgICBjb25zdCBjdXJyZW50UGFnZSA9ICRwYWdlRWxbMF0uZjdQYWdlIHx8IHt9O1xuICAgIGxldCBkaXJlY3Rpb247XG4gICAgbGV0IHBhZ2VGcm9tO1xuICAgIGlmICgoZnJvbSA9PT0gJ25leHQnICYmIHRvID09PSAnY3VycmVudCcpIHx8IChmcm9tID09PSAnY3VycmVudCcgJiYgdG8gPT09ICdwcmV2aW91cycpKSBkaXJlY3Rpb24gPSAnZm9yd2FyZCc7XG4gICAgaWYgKChmcm9tID09PSAnY3VycmVudCcgJiYgdG8gPT09ICduZXh0JykgfHwgKGZyb20gPT09ICdwcmV2aW91cycgJiYgdG8gPT09ICdjdXJyZW50JykpIGRpcmVjdGlvbiA9ICdiYWNrd2FyZCc7XG4gICAgaWYgKGN1cnJlbnRQYWdlICYmICFjdXJyZW50UGFnZS5mcm9tUGFnZSkge1xuICAgICAgY29uc3QgJHBhZ2VGcm9tRWwgPSAkKHBhZ2VGcm9tRWwpO1xuICAgICAgaWYgKCRwYWdlRnJvbUVsLmxlbmd0aCkge1xuICAgICAgICBwYWdlRnJvbSA9ICRwYWdlRnJvbUVsWzBdLmY3UGFnZTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcGFnZSA9IHtcbiAgICAgIGFwcDogcm91dGVyLmFwcCxcbiAgICAgIHZpZXc6IHJvdXRlci52aWV3LFxuICAgICAgcm91dGVyLFxuICAgICAgJGVsOiAkcGFnZUVsLFxuICAgICAgZWw6ICRwYWdlRWxbMF0sXG4gICAgICAkcGFnZUVsLFxuICAgICAgcGFnZUVsOiAkcGFnZUVsWzBdLFxuICAgICAgJG5hdmJhckVsLFxuICAgICAgbmF2YmFyRWw6ICRuYXZiYXJFbFswXSxcbiAgICAgIG5hbWU6ICRwYWdlRWwuYXR0cignZGF0YS1uYW1lJyksXG4gICAgICBwb3NpdGlvbjogZnJvbSxcbiAgICAgIGZyb20sXG4gICAgICB0byxcbiAgICAgIGRpcmVjdGlvbixcbiAgICAgIHJvdXRlOiBjdXJyZW50UGFnZS5yb3V0ZSA/IGN1cnJlbnRQYWdlLnJvdXRlIDogcm91dGUsXG4gICAgICBwYWdlRnJvbTogY3VycmVudFBhZ2UucGFnZUZyb20gfHwgcGFnZUZyb20sXG4gICAgfTtcblxuICAgIGlmICgkbmF2YmFyRWwgJiYgJG5hdmJhckVsWzBdKSB7XG4gICAgICAkbmF2YmFyRWxbMF0uZjdQYWdlID0gcGFnZTtcbiAgICB9XG4gICAgJHBhZ2VFbFswXS5mN1BhZ2UgPSBwYWdlO1xuICAgIHJldHVybiBwYWdlO1xuICB9XG4gIC8vIENhbGxiYWNrc1xuICBwYWdlQ2FsbGJhY2soY2FsbGJhY2ssIHBhZ2VFbCwgbmF2YmFyRWwsIGZyb20sIHRvLCBvcHRpb25zID0ge30sIHBhZ2VGcm9tRWwpIHtcbiAgICBpZiAoIXBhZ2VFbCkgcmV0dXJuO1xuICAgIGNvbnN0IHJvdXRlciA9IHRoaXM7XG4gICAgY29uc3QgJHBhZ2VFbCA9ICQocGFnZUVsKTtcbiAgICBpZiAoISRwYWdlRWwubGVuZ3RoKSByZXR1cm47XG4gICAgY29uc3QgeyByb3V0ZSB9ID0gb3B0aW9ucztcbiAgICBjb25zdCByZXN0b3JlU2Nyb2xsVG9wT25CYWNrID0gcm91dGVyLnBhcmFtcy5yZXN0b3JlU2Nyb2xsVG9wT25CYWNrO1xuXG4gICAgY29uc3QgY2FtZWxOYW1lID0gYHBhZ2Uke2NhbGxiYWNrWzBdLnRvVXBwZXJDYXNlKCkgKyBjYWxsYmFjay5zbGljZSgxLCBjYWxsYmFjay5sZW5ndGgpfWA7XG4gICAgY29uc3QgY29sb25OYW1lID0gYHBhZ2U6JHtjYWxsYmFjay50b0xvd2VyQ2FzZSgpfWA7XG5cbiAgICBsZXQgcGFnZSA9IHt9O1xuICAgIGlmIChjYWxsYmFjayA9PT0gJ2JlZm9yZVJlbW92ZScgJiYgJHBhZ2VFbFswXS5mN1BhZ2UpIHtcbiAgICAgIHBhZ2UgPSBVdGlscy5leHRlbmQoJHBhZ2VFbFswXS5mN1BhZ2UsIHsgZnJvbSwgdG8sIHBvc2l0aW9uOiBmcm9tIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYWdlID0gcm91dGVyLmdldFBhZ2VEYXRhKHBhZ2VFbCwgbmF2YmFyRWwsIGZyb20sIHRvLCByb3V0ZSwgcGFnZUZyb21FbCk7XG4gICAgfVxuICAgIHBhZ2Uuc3dpcGVCYWNrID0gISFvcHRpb25zLnN3aXBlQmFjaztcblxuICAgIGNvbnN0IHsgb24gPSB7fSwgb25jZSA9IHt9IH0gPSBvcHRpb25zLnJvdXRlID8gb3B0aW9ucy5yb3V0ZS5yb3V0ZSA6IHt9O1xuICAgIGlmIChvcHRpb25zLm9uKSB7XG4gICAgICBVdGlscy5leHRlbmQob24sIG9wdGlvbnMub24pO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5vbmNlKSB7XG4gICAgICBVdGlscy5leHRlbmQob25jZSwgb3B0aW9ucy5vbmNlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhdHRhY2hFdmVudHMoKSB7XG4gICAgICBpZiAoJHBhZ2VFbFswXS5mN1JvdXRlRXZlbnRzQXR0YWNoZWQpIHJldHVybjtcbiAgICAgICRwYWdlRWxbMF0uZjdSb3V0ZUV2ZW50c0F0dGFjaGVkID0gdHJ1ZTtcbiAgICAgIGlmIChvbiAmJiBPYmplY3Qua2V5cyhvbikubGVuZ3RoID4gMCkge1xuICAgICAgICAkcGFnZUVsWzBdLmY3Um91dGVFdmVudHNPbiA9IG9uO1xuICAgICAgICBPYmplY3Qua2V5cyhvbikuZm9yRWFjaCgoZXZlbnROYW1lKSA9PiB7XG4gICAgICAgICAgb25bZXZlbnROYW1lXSA9IG9uW2V2ZW50TmFtZV0uYmluZChyb3V0ZXIpO1xuICAgICAgICAgICRwYWdlRWwub24oVXRpbHMuZXZlbnROYW1lVG9Db2xvbkNhc2UoZXZlbnROYW1lKSwgb25bZXZlbnROYW1lXSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKG9uY2UgJiYgT2JqZWN0LmtleXMob25jZSkubGVuZ3RoID4gMCkge1xuICAgICAgICAkcGFnZUVsWzBdLmY3Um91dGVFdmVudHNPbmNlID0gb25jZTtcbiAgICAgICAgT2JqZWN0LmtleXMob25jZSkuZm9yRWFjaCgoZXZlbnROYW1lKSA9PiB7XG4gICAgICAgICAgb25jZVtldmVudE5hbWVdID0gb25jZVtldmVudE5hbWVdLmJpbmQocm91dGVyKTtcbiAgICAgICAgICAkcGFnZUVsLm9uY2UoVXRpbHMuZXZlbnROYW1lVG9Db2xvbkNhc2UoZXZlbnROYW1lKSwgb25jZVtldmVudE5hbWVdKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGV0YWNoRXZlbnRzKCkge1xuICAgICAgaWYgKCEkcGFnZUVsWzBdLmY3Um91dGVFdmVudHNBdHRhY2hlZCkgcmV0dXJuO1xuICAgICAgaWYgKCRwYWdlRWxbMF0uZjdSb3V0ZUV2ZW50c09uKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKCRwYWdlRWxbMF0uZjdSb3V0ZUV2ZW50c09uKS5mb3JFYWNoKChldmVudE5hbWUpID0+IHtcbiAgICAgICAgICAkcGFnZUVsLm9mZihVdGlscy5ldmVudE5hbWVUb0NvbG9uQ2FzZShldmVudE5hbWUpLCAkcGFnZUVsWzBdLmY3Um91dGVFdmVudHNPbltldmVudE5hbWVdKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoJHBhZ2VFbFswXS5mN1JvdXRlRXZlbnRzT25jZSkge1xuICAgICAgICBPYmplY3Qua2V5cygkcGFnZUVsWzBdLmY3Um91dGVFdmVudHNPbmNlKS5mb3JFYWNoKChldmVudE5hbWUpID0+IHtcbiAgICAgICAgICAkcGFnZUVsLm9mZihVdGlscy5ldmVudE5hbWVUb0NvbG9uQ2FzZShldmVudE5hbWUpLCAkcGFnZUVsWzBdLmY3Um91dGVFdmVudHNPbmNlW2V2ZW50TmFtZV0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgICRwYWdlRWxbMF0uZjdSb3V0ZUV2ZW50c0F0dGFjaGVkID0gbnVsbDtcbiAgICAgICRwYWdlRWxbMF0uZjdSb3V0ZUV2ZW50c09uID0gbnVsbDtcbiAgICAgICRwYWdlRWxbMF0uZjdSb3V0ZUV2ZW50c09uY2UgPSBudWxsO1xuICAgICAgZGVsZXRlICRwYWdlRWxbMF0uZjdSb3V0ZUV2ZW50c0F0dGFjaGVkO1xuICAgICAgZGVsZXRlICRwYWdlRWxbMF0uZjdSb3V0ZUV2ZW50c09uO1xuICAgICAgZGVsZXRlICRwYWdlRWxbMF0uZjdSb3V0ZUV2ZW50c09uY2U7XG4gICAgfVxuXG4gICAgaWYgKGNhbGxiYWNrID09PSAnbW91bnRlZCcpIHtcbiAgICAgIGF0dGFjaEV2ZW50cygpO1xuICAgIH1cbiAgICBpZiAoY2FsbGJhY2sgPT09ICdpbml0Jykge1xuICAgICAgaWYgKHJlc3RvcmVTY3JvbGxUb3BPbkJhY2sgJiYgKGZyb20gPT09ICdwcmV2aW91cycgfHwgIWZyb20pICYmIHRvID09PSAnY3VycmVudCcgJiYgcm91dGVyLnNjcm9sbEhpc3RvcnlbcGFnZS5yb3V0ZS51cmxdICYmICEkcGFnZUVsLmhhc0NsYXNzKCduby1yZXN0b3JlLXNjcm9sbCcpKSB7XG4gICAgICAgIGxldCAkcGFnZUNvbnRlbnQgPSAkcGFnZUVsLmZpbmQoJy5wYWdlLWNvbnRlbnQnKTtcbiAgICAgICAgaWYgKCRwYWdlQ29udGVudC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgICAgJHBhZ2VDb250ZW50ID0gJHBhZ2VDb250ZW50LmZpbHRlcigocGFnZUNvbnRlbnRJbmRleCwgcGFnZUNvbnRlbnRFbCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgJChwYWdlQ29udGVudEVsKS5wYXJlbnRzKCcudGFiOm5vdCgudGFiLWFjdGl2ZSknKS5sZW5ndGggPT09IDAgJiZcbiAgICAgICAgICAgICAgISQocGFnZUNvbnRlbnRFbCkuaXMoJy50YWI6bm90KC50YWItYWN0aXZlKScpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgICRwYWdlQ29udGVudC5zY3JvbGxUb3Aocm91dGVyLnNjcm9sbEhpc3RvcnlbcGFnZS5yb3V0ZS51cmxdKTtcbiAgICAgIH1cbiAgICAgIGF0dGFjaEV2ZW50cygpO1xuICAgICAgaWYgKCRwYWdlRWxbMF0uZjdQYWdlSW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgJHBhZ2VFbC50cmlnZ2VyKCdwYWdlOnJlaW5pdCcsIHBhZ2UpO1xuICAgICAgICByb3V0ZXIuZW1pdCgncGFnZVJlaW5pdCcsIHBhZ2UpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAkcGFnZUVsWzBdLmY3UGFnZUluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHJlc3RvcmVTY3JvbGxUb3BPbkJhY2sgJiYgY2FsbGJhY2sgPT09ICdiZWZvcmVPdXQnICYmIGZyb20gPT09ICdjdXJyZW50JyAmJiB0byA9PT0gJ3ByZXZpb3VzJykge1xuICAgICAgLy8gU2F2ZSBzY3JvbGwgcG9zaXRpb25cbiAgICAgIGxldCAkcGFnZUNvbnRlbnQgPSAkcGFnZUVsLmZpbmQoJy5wYWdlLWNvbnRlbnQnKTtcbiAgICAgIGlmICgkcGFnZUNvbnRlbnQubGVuZ3RoID4gMCkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgJHBhZ2VDb250ZW50ID0gJHBhZ2VDb250ZW50LmZpbHRlcigocGFnZUNvbnRlbnRJbmRleCwgcGFnZUNvbnRlbnRFbCkgPT4ge1xuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAkKHBhZ2VDb250ZW50RWwpLnBhcmVudHMoJy50YWI6bm90KC50YWItYWN0aXZlKScpLmxlbmd0aCA9PT0gMCAmJlxuICAgICAgICAgICAgISQocGFnZUNvbnRlbnRFbCkuaXMoJy50YWI6bm90KC50YWItYWN0aXZlKScpXG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByb3V0ZXIuc2Nyb2xsSGlzdG9yeVtwYWdlLnJvdXRlLnVybF0gPSAkcGFnZUNvbnRlbnQuc2Nyb2xsVG9wKCk7XG4gICAgfVxuICAgIGlmIChyZXN0b3JlU2Nyb2xsVG9wT25CYWNrICYmIGNhbGxiYWNrID09PSAnYmVmb3JlT3V0JyAmJiBmcm9tID09PSAnY3VycmVudCcgJiYgdG8gPT09ICduZXh0Jykge1xuICAgICAgLy8gRGVsZXRlIHNjcm9sbCBwb3NpdGlvblxuICAgICAgZGVsZXRlIHJvdXRlci5zY3JvbGxIaXN0b3J5W3BhZ2Uucm91dGUudXJsXTtcbiAgICB9XG5cbiAgICAkcGFnZUVsLnRyaWdnZXIoY29sb25OYW1lLCBwYWdlKTtcbiAgICByb3V0ZXIuZW1pdChjYW1lbE5hbWUsIHBhZ2UpO1xuXG4gICAgaWYgKGNhbGxiYWNrID09PSAnYmVmb3JlUmVtb3ZlJykge1xuICAgICAgZGV0YWNoRXZlbnRzKCk7XG4gICAgICAkcGFnZUVsWzBdLmY3UGFnZSA9IG51bGw7XG4gICAgfVxuICB9XG4gIHNhdmVIaXN0b3J5KCkge1xuICAgIGNvbnN0IHJvdXRlciA9IHRoaXM7XG4gICAgcm91dGVyLnZpZXcuaGlzdG9yeSA9IHJvdXRlci5oaXN0b3J5O1xuICAgIGlmIChyb3V0ZXIucGFyYW1zLnB1c2hTdGF0ZSkge1xuICAgICAgd2luZG93JDEubG9jYWxTdG9yYWdlW2BmN3JvdXRlci0ke3JvdXRlci52aWV3LmlkfS1oaXN0b3J5YF0gPSBKU09OLnN0cmluZ2lmeShyb3V0ZXIuaGlzdG9yeSk7XG4gICAgfVxuICB9XG4gIHJlc3RvcmVIaXN0b3J5KCkge1xuICAgIGNvbnN0IHJvdXRlciA9IHRoaXM7XG4gICAgaWYgKHJvdXRlci5wYXJhbXMucHVzaFN0YXRlICYmIHdpbmRvdyQxLmxvY2FsU3RvcmFnZVtgZjdyb3V0ZXItJHtyb3V0ZXIudmlldy5pZH0taGlzdG9yeWBdKSB7XG4gICAgICByb3V0ZXIuaGlzdG9yeSA9IEpTT04ucGFyc2Uod2luZG93JDEubG9jYWxTdG9yYWdlW2BmN3JvdXRlci0ke3JvdXRlci52aWV3LmlkfS1oaXN0b3J5YF0pO1xuICAgICAgcm91dGVyLnZpZXcuaGlzdG9yeSA9IHJvdXRlci5oaXN0b3J5O1xuICAgIH1cbiAgfVxuICBjbGVhckhpc3RvcnkoKSB7XG4gICAgY29uc3Qgcm91dGVyID0gdGhpcztcbiAgICByb3V0ZXIuaGlzdG9yeSA9IFtdO1xuICAgIGlmIChyb3V0ZXIudmlldykgcm91dGVyLnZpZXcuaGlzdG9yeSA9IFtdO1xuICAgIHJvdXRlci5zYXZlSGlzdG9yeSgpO1xuICB9XG4gIGluaXQoKSB7XG4gICAgY29uc3Qgcm91dGVyID0gdGhpcztcbiAgICBjb25zdCB7IGFwcCwgdmlldyB9ID0gcm91dGVyO1xuXG4gICAgLy8gSW5pdCBTd2lwZWJhY2tcbiAgICB7XG4gICAgICBpZiAoXG4gICAgICAgICh2aWV3ICYmIHJvdXRlci5wYXJhbXMuaW9zU3dpcGVCYWNrICYmIGFwcC50aGVtZSA9PT0gJ2lvcycpIHx8XG4gICAgICAgICh2aWV3ICYmIHJvdXRlci5wYXJhbXMubWRTd2lwZUJhY2sgJiYgYXBwLnRoZW1lID09PSAnbWQnKVxuICAgICAgKSB7XG4gICAgICAgIFN3aXBlQmFjayhyb3V0ZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIER5bmFtaWMgbm90IHNlcGFyYXRlZCBuYXZiYmFyXG4gICAgaWYgKHJvdXRlci5keW5hbWljTmF2YmFyICYmICFyb3V0ZXIuc2VwYXJhdGVOYXZiYXIpIHtcbiAgICAgIHJvdXRlci4kZWwuYWRkQ2xhc3MoJ3JvdXRlci1keW5hbWljLW5hdmJhci1pbnNpZGUnKTtcbiAgICB9XG5cbiAgICBsZXQgaW5pdFVybCA9IHJvdXRlci5wYXJhbXMudXJsO1xuICAgIGxldCBkb2N1bWVudFVybCA9IGRvY3VtZW50LmxvY2F0aW9uLmhyZWYuc3BsaXQoZG9jdW1lbnQubG9jYXRpb24ub3JpZ2luKVsxXTtcbiAgICBsZXQgaGlzdG9yeVJlc3RvcmVkO1xuICAgIGlmICghcm91dGVyLnBhcmFtcy5wdXNoU3RhdGUpIHtcbiAgICAgIGlmICghaW5pdFVybCkge1xuICAgICAgICBpbml0VXJsID0gZG9jdW1lbnRVcmw7XG4gICAgICB9XG4gICAgICBpZiAoZG9jdW1lbnQubG9jYXRpb24uc2VhcmNoICYmIGluaXRVcmwuaW5kZXhPZignPycpIDwgMCkge1xuICAgICAgICBpbml0VXJsICs9IGRvY3VtZW50LmxvY2F0aW9uLnNlYXJjaDtcbiAgICAgIH1cbiAgICAgIGlmIChkb2N1bWVudC5sb2NhdGlvbi5oYXNoICYmIGluaXRVcmwuaW5kZXhPZignIycpIDwgMCkge1xuICAgICAgICBpbml0VXJsICs9IGRvY3VtZW50LmxvY2F0aW9uLmhhc2g7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChyb3V0ZXIucGFyYW1zLnB1c2hTdGF0ZVJvb3QgJiYgZG9jdW1lbnRVcmwuaW5kZXhPZihyb3V0ZXIucGFyYW1zLnB1c2hTdGF0ZVJvb3QpID49IDApIHtcbiAgICAgICAgZG9jdW1lbnRVcmwgPSBkb2N1bWVudFVybC5zcGxpdChyb3V0ZXIucGFyYW1zLnB1c2hTdGF0ZVJvb3QpWzFdO1xuICAgICAgICBpZiAoZG9jdW1lbnRVcmwgPT09ICcnKSBkb2N1bWVudFVybCA9ICcvJztcbiAgICAgIH1cbiAgICAgIGlmIChyb3V0ZXIucGFyYW1zLnB1c2hTdGF0ZVNlcGFyYXRvci5sZW5ndGggPiAwICYmIGRvY3VtZW50VXJsLmluZGV4T2Yocm91dGVyLnBhcmFtcy5wdXNoU3RhdGVTZXBhcmF0b3IpID49IDApIHtcbiAgICAgICAgaW5pdFVybCA9IGRvY3VtZW50VXJsLnNwbGl0KHJvdXRlci5wYXJhbXMucHVzaFN0YXRlU2VwYXJhdG9yKVsxXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluaXRVcmwgPSBkb2N1bWVudFVybDtcbiAgICAgIH1cbiAgICAgIHJvdXRlci5yZXN0b3JlSGlzdG9yeSgpO1xuICAgICAgaWYgKHJvdXRlci5oaXN0b3J5LmluZGV4T2YoaW5pdFVybCkgPj0gMCkge1xuICAgICAgICByb3V0ZXIuaGlzdG9yeSA9IHJvdXRlci5oaXN0b3J5LnNsaWNlKDAsIHJvdXRlci5oaXN0b3J5LmluZGV4T2YoaW5pdFVybCkgKyAxKTtcbiAgICAgIH0gZWxzZSBpZiAocm91dGVyLnBhcmFtcy51cmwgPT09IGluaXRVcmwpIHtcbiAgICAgICAgcm91dGVyLmhpc3RvcnkgPSBbaW5pdFVybF07XG4gICAgICB9IGVsc2UgaWYgKEhpc3Rvcnkuc3RhdGUgJiYgSGlzdG9yeS5zdGF0ZVt2aWV3LmlkXSAmJiBIaXN0b3J5LnN0YXRlW3ZpZXcuaWRdLnVybCA9PT0gcm91dGVyLmhpc3Rvcnlbcm91dGVyLmhpc3RvcnkubGVuZ3RoIC0gMV0pIHtcbiAgICAgICAgaW5pdFVybCA9IHJvdXRlci5oaXN0b3J5W3JvdXRlci5oaXN0b3J5Lmxlbmd0aCAtIDFdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcm91dGVyLmhpc3RvcnkgPSBbZG9jdW1lbnRVcmwuc3BsaXQocm91dGVyLnBhcmFtcy5wdXNoU3RhdGVTZXBhcmF0b3IpWzBdIHx8ICcvJywgaW5pdFVybF07XG4gICAgICB9XG4gICAgICBpZiAocm91dGVyLmhpc3RvcnkubGVuZ3RoID4gMSkge1xuICAgICAgICBoaXN0b3J5UmVzdG9yZWQgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcm91dGVyLmhpc3RvcnkgPSBbXTtcbiAgICAgIH1cbiAgICAgIHJvdXRlci5zYXZlSGlzdG9yeSgpO1xuICAgIH1cbiAgICBsZXQgY3VycmVudFJvdXRlO1xuICAgIGlmIChyb3V0ZXIuaGlzdG9yeS5sZW5ndGggPiAxKSB7XG4gICAgICAvLyBXaWxsIGxvYWQgcGFnZVxuICAgICAgY3VycmVudFJvdXRlID0gcm91dGVyLmZpbmRNYXRjaGluZ1JvdXRlKHJvdXRlci5oaXN0b3J5WzBdKTtcbiAgICAgIGlmICghY3VycmVudFJvdXRlKSB7XG4gICAgICAgIGN1cnJlbnRSb3V0ZSA9IFV0aWxzLmV4dGVuZChyb3V0ZXIucGFyc2VSb3V0ZVVybChyb3V0ZXIuaGlzdG9yeVswXSksIHtcbiAgICAgICAgICByb3V0ZToge1xuICAgICAgICAgICAgdXJsOiByb3V0ZXIuaGlzdG9yeVswXSxcbiAgICAgICAgICAgIHBhdGg6IHJvdXRlci5oaXN0b3J5WzBdLnNwbGl0KCc/JylbMF0sXG4gICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIERvbid0IGxvYWQgcGFnZVxuICAgICAgY3VycmVudFJvdXRlID0gcm91dGVyLmZpbmRNYXRjaGluZ1JvdXRlKGluaXRVcmwpO1xuICAgICAgaWYgKCFjdXJyZW50Um91dGUpIHtcbiAgICAgICAgY3VycmVudFJvdXRlID0gVXRpbHMuZXh0ZW5kKHJvdXRlci5wYXJzZVJvdXRlVXJsKGluaXRVcmwpLCB7XG4gICAgICAgICAgcm91dGU6IHtcbiAgICAgICAgICAgIHVybDogaW5pdFVybCxcbiAgICAgICAgICAgIHBhdGg6IGluaXRVcmwuc3BsaXQoJz8nKVswXSxcbiAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocm91dGVyLnBhcmFtcy5zdGFja1BhZ2VzKSB7XG4gICAgICByb3V0ZXIuJGVsLmNoaWxkcmVuKCcucGFnZScpLmVhY2goKGluZGV4LCBwYWdlRWwpID0+IHtcbiAgICAgICAgY29uc3QgJHBhZ2VFbCA9ICQocGFnZUVsKTtcbiAgICAgICAgcm91dGVyLmluaXRpYWxQYWdlcy5wdXNoKCRwYWdlRWxbMF0pO1xuICAgICAgICBpZiAocm91dGVyLnNlcGFyYXRlTmF2YmFyICYmICRwYWdlRWwuY2hpbGRyZW4oJy5uYXZiYXInKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgcm91dGVyLmluaXRpYWxOYXZiYXJzLnB1c2goJHBhZ2VFbC5jaGlsZHJlbignLm5hdmJhcicpLmZpbmQoJy5uYXZiYXItaW5uZXInKVswXSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChyb3V0ZXIuJGVsLmNoaWxkcmVuKCcucGFnZTpub3QoLnN0YWNrZWQpJykubGVuZ3RoID09PSAwICYmIGluaXRVcmwpIHtcbiAgICAgIC8vIE5vIHBhZ2VzIHByZXNlbnRlZCBpbiBET00sIHJlbG9hZCBuZXcgcGFnZVxuICAgICAgcm91dGVyLm5hdmlnYXRlKGluaXRVcmwsIHtcbiAgICAgICAgaW5pdGlhbDogdHJ1ZSxcbiAgICAgICAgcmVsb2FkQ3VycmVudDogdHJ1ZSxcbiAgICAgICAgcHVzaFN0YXRlOiBmYWxzZSxcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJbml0IGN1cnJlbnQgRE9NIHBhZ2VcbiAgICAgIGxldCBoYXNUYWJSb3V0ZTtcbiAgICAgIHJvdXRlci5jdXJyZW50Um91dGUgPSBjdXJyZW50Um91dGU7XG4gICAgICByb3V0ZXIuJGVsLmNoaWxkcmVuKCcucGFnZTpub3QoLnN0YWNrZWQpJykuZWFjaCgoaW5kZXgsIHBhZ2VFbCkgPT4ge1xuICAgICAgICBjb25zdCAkcGFnZUVsID0gJChwYWdlRWwpO1xuICAgICAgICBsZXQgJG5hdmJhcklubmVyRWw7XG4gICAgICAgICRwYWdlRWwuYWRkQ2xhc3MoJ3BhZ2UtY3VycmVudCcpO1xuICAgICAgICBpZiAocm91dGVyLnNlcGFyYXRlTmF2YmFyKSB7XG4gICAgICAgICAgJG5hdmJhcklubmVyRWwgPSAkcGFnZUVsLmNoaWxkcmVuKCcubmF2YmFyJykuY2hpbGRyZW4oJy5uYXZiYXItaW5uZXInKTtcbiAgICAgICAgICBpZiAoJG5hdmJhcklubmVyRWwubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgaWYgKCFyb3V0ZXIuJG5hdmJhckVsLnBhcmVudHMoZG9jdW1lbnQpLmxlbmd0aCkge1xuICAgICAgICAgICAgICByb3V0ZXIuJGVsLnByZXBlbmQocm91dGVyLiRuYXZiYXJFbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByb3V0ZXIuJG5hdmJhckVsLmFwcGVuZCgkbmF2YmFySW5uZXJFbCk7XG4gICAgICAgICAgICAkcGFnZUVsLmNoaWxkcmVuKCcubmF2YmFyJykucmVtb3ZlKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJvdXRlci4kbmF2YmFyRWwuYWRkQ2xhc3MoJ25hdmJhci1oaWRkZW4nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW5pdE9wdGlvbnMgPSB7XG4gICAgICAgICAgcm91dGU6IHJvdXRlci5jdXJyZW50Um91dGUsXG4gICAgICAgIH07XG4gICAgICAgIGlmIChyb3V0ZXIuY3VycmVudFJvdXRlICYmIHJvdXRlci5jdXJyZW50Um91dGUucm91dGUgJiYgcm91dGVyLmN1cnJlbnRSb3V0ZS5yb3V0ZS5vcHRpb25zKSB7XG4gICAgICAgICAgVXRpbHMuZXh0ZW5kKGluaXRPcHRpb25zLCByb3V0ZXIuY3VycmVudFJvdXRlLnJvdXRlLm9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIHJvdXRlci5jdXJyZW50UGFnZUVsID0gJHBhZ2VFbFswXTtcbiAgICAgICAgaWYgKHJvdXRlci5keW5hbWljTmF2YmFyICYmICRuYXZiYXJJbm5lckVsLmxlbmd0aCkge1xuICAgICAgICAgIHJvdXRlci5jdXJyZW50TmF2YmFyRWwgPSAkbmF2YmFySW5uZXJFbFswXTtcbiAgICAgICAgfVxuICAgICAgICByb3V0ZXIucmVtb3ZlVGhlbWVFbGVtZW50cygkcGFnZUVsKTtcbiAgICAgICAgaWYgKHJvdXRlci5keW5hbWljTmF2YmFyICYmICRuYXZiYXJJbm5lckVsLmxlbmd0aCkge1xuICAgICAgICAgIHJvdXRlci5yZW1vdmVUaGVtZUVsZW1lbnRzKCRuYXZiYXJJbm5lckVsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5pdE9wdGlvbnMucm91dGUucm91dGUudGFiKSB7XG4gICAgICAgICAgaGFzVGFiUm91dGUgPSB0cnVlO1xuICAgICAgICAgIHJvdXRlci50YWJMb2FkKGluaXRPcHRpb25zLnJvdXRlLnJvdXRlLnRhYiwgVXRpbHMuZXh0ZW5kKHt9LCBpbml0T3B0aW9ucykpO1xuICAgICAgICB9XG4gICAgICAgIHJvdXRlci5wYWdlQ2FsbGJhY2soJ2luaXQnLCAkcGFnZUVsLCAkbmF2YmFySW5uZXJFbCwgJ2N1cnJlbnQnLCB1bmRlZmluZWQsIGluaXRPcHRpb25zKTtcbiAgICAgIH0pO1xuICAgICAgaWYgKGhpc3RvcnlSZXN0b3JlZCkge1xuICAgICAgICByb3V0ZXIubmF2aWdhdGUoaW5pdFVybCwge1xuICAgICAgICAgIGluaXRpYWw6IHRydWUsXG4gICAgICAgICAgcHVzaFN0YXRlOiBmYWxzZSxcbiAgICAgICAgICBoaXN0b3J5OiBmYWxzZSxcbiAgICAgICAgICBhbmltYXRlOiByb3V0ZXIucGFyYW1zLnB1c2hTdGF0ZUFuaW1hdGVPbkxvYWQsXG4gICAgICAgICAgb25jZToge1xuICAgICAgICAgICAgcGFnZUFmdGVySW4oKSB7XG4gICAgICAgICAgICAgIGlmIChyb3V0ZXIuaGlzdG9yeS5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICAgICAgcm91dGVyLmJhY2soeyBwcmVsb2FkOiB0cnVlIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKCFoaXN0b3J5UmVzdG9yZWQgJiYgIWhhc1RhYlJvdXRlKSB7XG4gICAgICAgIHJvdXRlci5oaXN0b3J5LnB1c2goaW5pdFVybCk7XG4gICAgICAgIHJvdXRlci5zYXZlSGlzdG9yeSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaW5pdFVybCAmJiByb3V0ZXIucGFyYW1zLnB1c2hTdGF0ZSAmJiAoIUhpc3Rvcnkuc3RhdGUgfHwgIUhpc3Rvcnkuc3RhdGVbdmlldy5pZF0pKSB7XG4gICAgICBIaXN0b3J5LmluaXRWaWV3U3RhdGUodmlldy5pZCwge1xuICAgICAgICB1cmw6IGluaXRVcmwsXG4gICAgICB9KTtcbiAgICB9XG4gICAgcm91dGVyLmVtaXQoJ2xvY2FsOjppbml0IHJvdXRlckluaXQnLCByb3V0ZXIpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgbGV0IHJvdXRlciA9IHRoaXM7XG5cbiAgICByb3V0ZXIuZW1pdCgnbG9jYWw6OmRlc3Ryb3kgcm91dGVyRGVzdHJveScsIHJvdXRlcik7XG5cbiAgICAvLyBEZWxldGUgcHJvcHMgJiBtZXRob2RzXG4gICAgT2JqZWN0LmtleXMocm91dGVyKS5mb3JFYWNoKChyb3V0ZXJQcm9wKSA9PiB7XG4gICAgICByb3V0ZXJbcm91dGVyUHJvcF0gPSBudWxsO1xuICAgICAgZGVsZXRlIHJvdXRlcltyb3V0ZXJQcm9wXTtcbiAgICB9KTtcblxuICAgIHJvdXRlciA9IG51bGw7XG4gIH1cbn1cblxudmFyIFJvdXRlciQxID0ge1xuICBuYW1lOiAncm91dGVyJyxcbiAgc3RhdGljOiB7XG4gICAgUm91dGVyLFxuICB9LFxuICBpbnN0YW5jZToge1xuICAgIGNhY2hlOiB7XG4gICAgICB4aHI6IFtdLFxuICAgICAgdGVtcGxhdGVzOiBbXSxcbiAgICAgIGNvbXBvbmVudHM6IFtdLFxuICAgIH0sXG4gIH0sXG4gIGNyZWF0ZSgpIHtcbiAgICBjb25zdCBpbnN0YW5jZSA9IHRoaXM7XG4gICAgaWYgKGluc3RhbmNlLmFwcCkge1xuICAgICAgLy8gVmlldyBSb3V0ZXJcbiAgICAgIGlmIChpbnN0YW5jZS5wYXJhbXMucm91dGVyKSB7XG4gICAgICAgIGluc3RhbmNlLnJvdXRlciA9IG5ldyBSb3V0ZXIoaW5zdGFuY2UuYXBwLCBpbnN0YW5jZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEFwcCBSb3V0ZXJcbiAgICAgIGluc3RhbmNlLnJvdXRlciA9IG5ldyBSb3V0ZXIoaW5zdGFuY2UpO1xuICAgIH1cbiAgfSxcbn07XG5cbmNsYXNzIFZpZXcgZXh0ZW5kcyBGcmFtZXdvcms3Q2xhc3Mge1xuICBjb25zdHJ1Y3RvcihhcHBJbnN0YW5jZSwgZWwsIHZpZXdQYXJhbXMgPSB7fSkge1xuICAgIHN1cGVyKHZpZXdQYXJhbXMsIFthcHBJbnN0YW5jZV0pO1xuXG4gICAgY29uc3QgYXBwID0gYXBwSW5zdGFuY2U7XG4gICAgY29uc3QgJGVsID0gJChlbCk7XG4gICAgY29uc3QgdmlldyA9IHRoaXM7XG5cbiAgICBjb25zdCBkZWZhdWx0cyA9IHtcbiAgICAgIHJvdXRlczogW10sXG4gICAgICByb3V0ZXNBZGQ6IFtdLFxuICAgIH07XG5cbiAgICAvLyBEZWZhdWx0IFZpZXcgcGFyYW1zXG4gICAgdmlldy5wYXJhbXMgPSBVdGlscy5leHRlbmQoZGVmYXVsdHMsIGFwcC5wYXJhbXMudmlldywgdmlld1BhcmFtcyk7XG5cbiAgICAvLyBSb3V0ZXNcbiAgICBpZiAodmlldy5wYXJhbXMucm91dGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIHZpZXcucm91dGVzID0gdmlldy5wYXJhbXMucm91dGVzO1xuICAgIH0gZWxzZSB7XG4gICAgICB2aWV3LnJvdXRlcyA9IFtdLmNvbmNhdChhcHAucm91dGVzLCB2aWV3LnBhcmFtcy5yb3V0ZXNBZGQpO1xuICAgIH1cblxuICAgIC8vIFNlbGVjdG9yXG4gICAgbGV0IHNlbGVjdG9yO1xuICAgIGlmICh0eXBlb2YgZWwgPT09ICdzdHJpbmcnKSBzZWxlY3RvciA9IGVsO1xuICAgIGVsc2Uge1xuICAgICAgLy8gU3VwcG9zZWQgdG8gYmUgSFRNTEVsZW1lbnQgb3IgRG9tN1xuICAgICAgc2VsZWN0b3IgPSAoJGVsLmF0dHIoJ2lkJykgPyBgIyR7JGVsLmF0dHIoJ2lkJyl9YCA6ICcnKSArICgkZWwuYXR0cignY2xhc3MnKSA/IGAuJHskZWwuYXR0cignY2xhc3MnKS5yZXBsYWNlKC8gL2csICcuJykucmVwbGFjZSgnLmFjdGl2ZScsICcnKX1gIDogJycpO1xuICAgIH1cblxuICAgIC8vIER5bmFtaWNOYXZiYXJcbiAgICBsZXQgJG5hdmJhckVsO1xuICAgIGlmIChhcHAudGhlbWUgPT09ICdpb3MnICYmIHZpZXcucGFyYW1zLmlvc0R5bmFtaWNOYXZiYXIgJiYgdmlldy5wYXJhbXMuaW9zU2VwYXJhdGVEeW5hbWljTmF2YmFyKSB7XG4gICAgICAkbmF2YmFyRWwgPSAkZWwuY2hpbGRyZW4oJy5uYXZiYXInKS5lcSgwKTtcbiAgICAgIGlmICgkbmF2YmFyRWwubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICRuYXZiYXJFbCA9ICQoJzxkaXYgY2xhc3M9XCJuYXZiYXJcIj48L2Rpdj4nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBWaWV3IFByb3BzXG4gICAgVXRpbHMuZXh0ZW5kKGZhbHNlLCB2aWV3LCB7XG4gICAgICBhcHAsXG4gICAgICAkZWwsXG4gICAgICBlbDogJGVsWzBdLFxuICAgICAgbmFtZTogdmlldy5wYXJhbXMubmFtZSxcbiAgICAgIG1haW46IHZpZXcucGFyYW1zLm1haW4gfHwgJGVsLmhhc0NsYXNzKCd2aWV3LW1haW4nKSxcbiAgICAgICRuYXZiYXJFbCxcbiAgICAgIG5hdmJhckVsOiAkbmF2YmFyRWwgPyAkbmF2YmFyRWxbMF0gOiB1bmRlZmluZWQsXG4gICAgICBzZWxlY3RvcixcbiAgICAgIGhpc3Rvcnk6IFtdLFxuICAgICAgc2Nyb2xsSGlzdG9yeToge30sXG4gICAgfSk7XG5cbiAgICAvLyBTYXZlIGluIERPTVxuICAgICRlbFswXS5mN1ZpZXcgPSB2aWV3O1xuXG4gICAgLy8gSW5zdGFsbCBNb2R1bGVzXG4gICAgdmlldy51c2VNb2R1bGVzKCk7XG5cbiAgICAvLyBBZGQgdG8gYXBwXG4gICAgYXBwLnZpZXdzLnB1c2godmlldyk7XG4gICAgaWYgKHZpZXcubWFpbikge1xuICAgICAgYXBwLnZpZXdzLm1haW4gPSB2aWV3O1xuICAgIH1cbiAgICBpZiAodmlldy5uYW1lKSB7XG4gICAgICBhcHAudmlld3Nbdmlldy5uYW1lXSA9IHZpZXc7XG4gICAgfVxuXG4gICAgLy8gSW5kZXhcbiAgICB2aWV3LmluZGV4ID0gYXBwLnZpZXdzLmluZGV4T2Yodmlldyk7XG5cbiAgICAvLyBWaWV3IElEXG4gICAgbGV0IHZpZXdJZDtcbiAgICBpZiAodmlldy5uYW1lKSB7XG4gICAgICB2aWV3SWQgPSBgdmlld18ke3ZpZXcubmFtZX1gO1xuICAgIH0gZWxzZSBpZiAodmlldy5tYWluKSB7XG4gICAgICB2aWV3SWQgPSAndmlld19tYWluJztcbiAgICB9IGVsc2Uge1xuICAgICAgdmlld0lkID0gYHZpZXdfJHt2aWV3LmluZGV4fWA7XG4gICAgfVxuICAgIHZpZXcuaWQgPSB2aWV3SWQ7XG5cbiAgICAvLyBJbml0IFZpZXdcbiAgICBpZiAoYXBwLmluaXRpYWxpemVkKSB7XG4gICAgICB2aWV3LmluaXQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXBwLm9uKCdpbml0JywgKCkgPT4ge1xuICAgICAgICB2aWV3LmluaXQoKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB2aWV3O1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgbGV0IHZpZXcgPSB0aGlzO1xuICAgIGNvbnN0IGFwcCA9IHZpZXcuYXBwO1xuXG4gICAgdmlldy4kZWwudHJpZ2dlcigndmlldzpiZWZvcmVkZXN0cm95Jywgdmlldyk7XG4gICAgdmlldy5lbWl0KCdsb2NhbDo6YmVmb3JlRGVzdHJveSB2aWV3QmVmb3JlRGVzdHJveScsIHZpZXcpO1xuXG4gICAgaWYgKHZpZXcubWFpbikge1xuICAgICAgYXBwLnZpZXdzLm1haW4gPSBudWxsO1xuICAgICAgZGVsZXRlIGFwcC52aWV3cy5tYWluO1xuICAgIH0gZWxzZSBpZiAodmlldy5uYW1lKSB7XG4gICAgICBhcHAudmlld3Nbdmlldy5uYW1lXSA9IG51bGw7XG4gICAgICBkZWxldGUgYXBwLnZpZXdzW3ZpZXcubmFtZV07XG4gICAgfVxuICAgIHZpZXcuJGVsWzBdLmY3VmlldyA9IG51bGw7XG4gICAgZGVsZXRlIHZpZXcuJGVsWzBdLmY3VmlldztcblxuICAgIGFwcC52aWV3cy5zcGxpY2UoYXBwLnZpZXdzLmluZGV4T2YodmlldyksIDEpO1xuXG4gICAgLy8gRGVzdHJveSBSb3V0ZXJcbiAgICBpZiAodmlldy5wYXJhbXMucm91dGVyICYmIHZpZXcucm91dGVyKSB7XG4gICAgICB2aWV3LnJvdXRlci5kZXN0cm95KCk7XG4gICAgfVxuXG4gICAgdmlldy5lbWl0KCdsb2NhbDo6ZGVzdHJveSB2aWV3RGVzdHJveScsIHZpZXcpO1xuXG4gICAgLy8gRGVsZXRlIHByb3BzICYgbWV0aG9kc1xuICAgIE9iamVjdC5rZXlzKHZpZXcpLmZvckVhY2goKHZpZXdQcm9wKSA9PiB7XG4gICAgICB2aWV3W3ZpZXdQcm9wXSA9IG51bGw7XG4gICAgICBkZWxldGUgdmlld1t2aWV3UHJvcF07XG4gICAgfSk7XG5cbiAgICB2aWV3ID0gbnVsbDtcbiAgfVxuICBpbml0KCkge1xuICAgIGNvbnN0IHZpZXcgPSB0aGlzO1xuICAgIGlmICh2aWV3LnBhcmFtcy5yb3V0ZXIpIHtcbiAgICAgIHZpZXcucm91dGVyLmluaXQoKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gVXNlIFJvdXRlclxuVmlldy51c2UoUm91dGVyJDEpO1xuXG5mdW5jdGlvbiBpbml0Q2xpY2tzKGFwcCkge1xuICBmdW5jdGlvbiBoYW5kbGVDbGlja3MoZSkge1xuICAgIGNvbnN0IGNsaWNrZWQgPSAkKGUudGFyZ2V0KTtcbiAgICBjb25zdCBjbGlja2VkTGluayA9IGNsaWNrZWQuY2xvc2VzdCgnYScpO1xuICAgIGNvbnN0IGlzTGluayA9IGNsaWNrZWRMaW5rLmxlbmd0aCA+IDA7XG4gICAgY29uc3QgdXJsID0gaXNMaW5rICYmIGNsaWNrZWRMaW5rLmF0dHIoJ2hyZWYnKTtcbiAgICBjb25zdCBpc1RhYkxpbmsgPSBpc0xpbmsgJiYgY2xpY2tlZExpbmsuaGFzQ2xhc3MoJ3RhYi1saW5rJykgJiYgKGNsaWNrZWRMaW5rLmF0dHIoJ2RhdGEtdGFiJykgfHwgKHVybCAmJiB1cmwuaW5kZXhPZignIycpID09PSAwKSk7XG5cbiAgICAvLyBDaGVjayBpZiBsaW5rIGlzIGV4dGVybmFsXG4gICAgaWYgKGlzTGluaykge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICBpZiAoY2xpY2tlZExpbmsuaXMoYXBwLnBhcmFtcy5jbGlja3MuZXh0ZXJuYWxMaW5rcykgfHwgKHVybCAmJiB1cmwuaW5kZXhPZignamF2YXNjcmlwdDonKSA+PSAwKSkge1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBjbGlja2VkTGluay5hdHRyKCd0YXJnZXQnKTtcbiAgICAgICAgaWYgKHVybCAmJiAodGFyZ2V0ID09PSAnX3N5c3RlbScgfHwgdGFyZ2V0ID09PSAnX2JsYW5rJyB8fCB0YXJnZXQgPT09ICdfYnJvd3NlcicpKSB7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIGlmICh0YXJnZXQgIT09ICdfYnJvd3NlcicgJiYgd2luZG93JDEuY29yZG92YSAmJiB3aW5kb3ckMS5jb3Jkb3ZhLkluQXBwQnJvd3Nlcikge1xuICAgICAgICAgICAgd2luZG93JDEuY29yZG92YS5JbkFwcEJyb3dzZXIub3Blbih1cmwsIHRhcmdldCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdpbmRvdyQxLm9wZW4odXJsLCB0YXJnZXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gTW9kdWxlcyBDbGlja3NcbiAgICBPYmplY3Qua2V5cyhhcHAubW9kdWxlcykuZm9yRWFjaCgobW9kdWxlTmFtZSkgPT4ge1xuICAgICAgY29uc3QgbW9kdWxlQ2xpY2tzID0gYXBwLm1vZHVsZXNbbW9kdWxlTmFtZV0uY2xpY2tzO1xuICAgICAgaWYgKCFtb2R1bGVDbGlja3MpIHJldHVybjtcbiAgICAgIE9iamVjdC5rZXlzKG1vZHVsZUNsaWNrcykuZm9yRWFjaCgoY2xpY2tTZWxlY3RvcikgPT4ge1xuICAgICAgICBjb25zdCBtYXRjaGluZ0NsaWNrZWRFbGVtZW50ID0gY2xpY2tlZC5jbG9zZXN0KGNsaWNrU2VsZWN0b3IpLmVxKDApO1xuICAgICAgICBpZiAobWF0Y2hpbmdDbGlja2VkRWxlbWVudC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgbW9kdWxlQ2xpY2tzW2NsaWNrU2VsZWN0b3JdLmNhbGwoYXBwLCBtYXRjaGluZ0NsaWNrZWRFbGVtZW50LCBtYXRjaGluZ0NsaWNrZWRFbGVtZW50LmRhdGFzZXQoKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLy8gTG9hZCBQYWdlXG4gICAgbGV0IGNsaWNrZWRMaW5rRGF0YSA9IHt9O1xuICAgIGlmIChpc0xpbmspIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGNsaWNrZWRMaW5rRGF0YSA9IGNsaWNrZWRMaW5rLmRhdGFzZXQoKTtcbiAgICB9XG4gICAgY29uc3QgdmFsaWRVcmwgPSB1cmwgJiYgdXJsLmxlbmd0aCA+IDAgJiYgdXJsICE9PSAnIycgJiYgIWlzVGFiTGluaztcbiAgICBjb25zdCB0ZW1wbGF0ZSA9IGNsaWNrZWRMaW5rRGF0YS50ZW1wbGF0ZTtcbiAgICBpZiAodmFsaWRVcmwgfHwgY2xpY2tlZExpbmsuaGFzQ2xhc3MoJ2JhY2snKSB8fCB0ZW1wbGF0ZSkge1xuICAgICAgbGV0IHZpZXc7XG4gICAgICBpZiAoY2xpY2tlZExpbmtEYXRhLnZpZXcpIHtcbiAgICAgICAgdmlldyA9ICQoY2xpY2tlZExpbmtEYXRhLnZpZXcpWzBdLmY3VmlldztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZpZXcgPSBjbGlja2VkLnBhcmVudHMoJy52aWV3JylbMF0gJiYgY2xpY2tlZC5wYXJlbnRzKCcudmlldycpWzBdLmY3VmlldztcbiAgICAgICAgaWYgKCFjbGlja2VkTGluay5oYXNDbGFzcygnYmFjaycpICYmIHZpZXcgJiYgdmlldy5wYXJhbXMubGlua3NWaWV3KSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB2aWV3LnBhcmFtcy5saW5rc1ZpZXcgPT09ICdzdHJpbmcnKSB2aWV3ID0gJCh2aWV3LnBhcmFtcy5saW5rc1ZpZXcpWzBdLmY3VmlldztcbiAgICAgICAgICBlbHNlIGlmICh2aWV3LnBhcmFtcy5saW5rc1ZpZXcgaW5zdGFuY2VvZiBWaWV3KSB2aWV3ID0gdmlldy5wYXJhbXMubGlua3NWaWV3O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIXZpZXcpIHtcbiAgICAgICAgaWYgKGFwcC52aWV3cy5tYWluKSB2aWV3ID0gYXBwLnZpZXdzLm1haW47XG4gICAgICB9XG4gICAgICBpZiAoIXZpZXcgfHwgIXZpZXcucm91dGVyKSByZXR1cm47XG4gICAgICBpZiAoY2xpY2tlZExpbmtEYXRhLmNvbnRleHQgJiYgdHlwZW9mIGNsaWNrZWRMaW5rRGF0YS5jb250ZXh0ID09PSAnc3RyaW5nJykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNsaWNrZWRMaW5rRGF0YS5jb250ZXh0ID0gSlNPTi5wYXJzZShjbGlja2VkTGlua0RhdGEuY29udGV4dCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIC8vIHNvbWV0aGluZyB3cm9uZyB0aGVyZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY2xpY2tlZExpbmsuaGFzQ2xhc3MoJ2JhY2snKSkgdmlldy5yb3V0ZXIuYmFjayh1cmwsIGNsaWNrZWRMaW5rRGF0YSk7XG4gICAgICBlbHNlIHZpZXcucm91dGVyLm5hdmlnYXRlKHVybCwgY2xpY2tlZExpbmtEYXRhKTtcbiAgICB9XG4gIH1cblxuICBhcHAub24oJ2NsaWNrJywgaGFuZGxlQ2xpY2tzKTtcblxuICAvLyBQcmV2ZW50IHNjcm9sbGluZyBvbiBvdmVybGF5c1xuICBmdW5jdGlvbiBwcmV2ZW50U2Nyb2xsaW5nKGUpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gIH1cbiAgaWYgKFN1cHBvcnQudG91Y2ggJiYgIURldmljZS5hbmRyb2lkKSB7XG4gICAgY29uc3QgYWN0aXZlTGlzdGVuZXIgPSBTdXBwb3J0LnBhc3NpdmVMaXN0ZW5lciA/IHsgcGFzc2l2ZTogZmFsc2UsIGNhcHR1cmU6IGZhbHNlIH0gOiBmYWxzZTtcbiAgICAkKGRvY3VtZW50KS5vbigoYXBwLnBhcmFtcy5mYXN0Q2xpY2tzID8gJ3RvdWNoc3RhcnQnIDogJ3RvdWNobW92ZScpLCAnLnBhbmVsLWJhY2tkcm9wLCAuZGlhbG9nLWJhY2tkcm9wLCAucHJlbG9hZGVyLWJhY2tkcm9wLCAucG9wdXAtYmFja2Ryb3AsIC5zZWFyY2hiYXItYmFja2Ryb3AnLCBwcmV2ZW50U2Nyb2xsaW5nLCBhY3RpdmVMaXN0ZW5lcik7XG4gIH1cbn1cbnZhciBDbGlja3NNb2R1bGUgPSB7XG4gIG5hbWU6ICdjbGlja3MnLFxuICBwYXJhbXM6IHtcbiAgICBjbGlja3M6IHtcbiAgICAgIC8vIEV4dGVybmFsIExpbmtzXG4gICAgICBleHRlcm5hbExpbmtzOiAnLmV4dGVybmFsJyxcbiAgICB9LFxuICB9LFxuICBvbjoge1xuICAgIGluaXQoKSB7XG4gICAgICBjb25zdCBhcHAgPSB0aGlzO1xuICAgICAgaW5pdENsaWNrcyhhcHApO1xuICAgIH0sXG4gIH0sXG59O1xuXG52YXIgSGlzdG9yeU1vZHVsZSA9IHtcbiAgbmFtZTogJ2hpc3RvcnknLFxuICBzdGF0aWM6IHtcbiAgICBoaXN0b3J5OiBIaXN0b3J5LFxuICB9LFxuICBvbjoge1xuICAgIGluaXQoKSB7XG4gICAgICBIaXN0b3J5LmluaXQodGhpcyk7XG4gICAgfSxcbiAgfSxcbn07XG5cbmNvbnN0IGtleVByZWZpeCA9ICdmN3N0b3JhZ2UtJztcbmNvbnN0IFN0b3JhZ2UgPSB7XG4gIGdldChrZXkpIHtcbiAgICByZXR1cm4gVXRpbHMucHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IEpTT04ucGFyc2Uod2luZG93JDEubG9jYWxTdG9yYWdlLmdldEl0ZW0oYCR7a2V5UHJlZml4fSR7a2V5fWApKTtcbiAgICAgICAgcmVzb2x2ZSh2YWx1ZSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJlamVjdChlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcbiAgc2V0KGtleSwgdmFsdWUpIHtcbiAgICByZXR1cm4gVXRpbHMucHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICB3aW5kb3ckMS5sb2NhbFN0b3JhZ2Uuc2V0SXRlbShgJHtrZXlQcmVmaXh9JHtrZXl9YCwgSlNPTi5zdHJpbmdpZnkodmFsdWUpKTtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZWplY3QoZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG4gIHJlbW92ZShrZXkpIHtcbiAgICByZXR1cm4gVXRpbHMucHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICB3aW5kb3ckMS5sb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShgJHtrZXlQcmVmaXh9JHtrZXl9YCk7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuICBjbGVhcigpIHtcblxuICB9LFxuICBsZW5ndGgoKSB7XG5cbiAgfSxcbiAga2V5cygpIHtcbiAgICByZXR1cm4gVXRpbHMucHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMod2luZG93JDEubG9jYWxTdG9yYWdlKVxuICAgICAgICAgIC5maWx0ZXIoa2V5TmFtZSA9PiBrZXlOYW1lLmluZGV4T2Yoa2V5UHJlZml4KSA9PT0gMClcbiAgICAgICAgICAubWFwKGtleU5hbWUgPT4ga2V5TmFtZS5yZXBsYWNlKGtleVByZWZpeCwgJycpKTtcbiAgICAgICAgcmVzb2x2ZShrZXlzKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuICBmb3JFYWNoKGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIFV0aWxzLnByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgT2JqZWN0LmtleXMod2luZG93JDEubG9jYWxTdG9yYWdlKVxuICAgICAgICAgIC5maWx0ZXIoa2V5TmFtZSA9PiBrZXlOYW1lLmluZGV4T2Yoa2V5UHJlZml4KSA9PT0gMClcbiAgICAgICAgICAuZm9yRWFjaCgoa2V5TmFtZSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGtleU5hbWUucmVwbGFjZShrZXlQcmVmaXgsICcnKTtcbiAgICAgICAgICAgIFN0b3JhZ2UuZ2V0KGtleSkudGhlbigodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgY2FsbGJhY2soa2V5LCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxufTtcblxudmFyIFN0b3JhZ2VNb2R1bGUgPSB7XG4gIG5hbWU6ICdzdG9yYWdlJyxcbiAgc3RhdGljOiB7XG4gICAgU3RvcmFnZSxcbiAgICBzdG9yYWdlOiBTdG9yYWdlLFxuICB9LFxufTtcblxuY29uc3QgU3RhdHVzYmFyID0ge1xuICBoaWRlKCkge1xuICAgICQoJ2h0bWwnKS5yZW1vdmVDbGFzcygnd2l0aC1zdGF0dXNiYXInKTtcbiAgICBpZiAoRGV2aWNlLmNvcmRvdmEgJiYgd2luZG93JDEuU3RhdHVzQmFyKSB7XG4gICAgICB3aW5kb3ckMS5TdGF0dXNCYXIuaGlkZSgpO1xuICAgIH1cbiAgfSxcbiAgc2hvdygpIHtcbiAgICBpZiAoRGV2aWNlLmNvcmRvdmEgJiYgd2luZG93JDEuU3RhdHVzQmFyKSB7XG4gICAgICB3aW5kb3ckMS5TdGF0dXNCYXIuc2hvdygpO1xuICAgICAgVXRpbHMubmV4dFRpY2soKCkgPT4ge1xuICAgICAgICBpZiAoRGV2aWNlLm5lZWRzU3RhdHVzYmFyT3ZlcmxheSgpKSB7XG4gICAgICAgICAgJCgnaHRtbCcpLmFkZENsYXNzKCd3aXRoLXN0YXR1c2JhcicpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgJCgnaHRtbCcpLmFkZENsYXNzKCd3aXRoLXN0YXR1c2JhcicpO1xuICB9LFxuICBvbkNsaWNrKCkge1xuICAgIGNvbnN0IGFwcCA9IHRoaXM7XG4gICAgbGV0IHBhZ2VDb250ZW50O1xuICAgIGlmICgkKCcucG9wdXAubW9kYWwtaW4nKS5sZW5ndGggPiAwKSB7XG4gICAgICAvLyBDaGVjayBmb3Igb3BlbmVkIHBvcHVwXG4gICAgICBwYWdlQ29udGVudCA9ICQoJy5wb3B1cC5tb2RhbC1pbicpLmZpbmQoJy5wYWdlOm5vdCgucGFnZS1wcmV2aW91cyk6bm90KC5wYWdlLW5leHQpOm5vdCguY2FjaGVkKScpLmZpbmQoJy5wYWdlLWNvbnRlbnQnKTtcbiAgICB9IGVsc2UgaWYgKCQoJy5wYW5lbC5wYW5lbC1hY3RpdmUnKS5sZW5ndGggPiAwKSB7XG4gICAgICAvLyBDaGVjayBmb3Igb3BlbmVkIHBhbmVsXG4gICAgICBwYWdlQ29udGVudCA9ICQoJy5wYW5lbC5wYW5lbC1hY3RpdmUnKS5maW5kKCcucGFnZTpub3QoLnBhZ2UtcHJldmlvdXMpOm5vdCgucGFnZS1uZXh0KTpub3QoLmNhY2hlZCknKS5maW5kKCcucGFnZS1jb250ZW50Jyk7XG4gICAgfSBlbHNlIGlmICgkKCcudmlld3MgPiAudmlldy50YWItYWN0aXZlJykubGVuZ3RoID4gMCkge1xuICAgICAgLy8gVmlldyBpbiB0YWIgYmFyIGFwcCBsYXlvdXRcbiAgICAgIHBhZ2VDb250ZW50ID0gJCgnLnZpZXdzID4gLnZpZXcudGFiLWFjdGl2ZScpLmZpbmQoJy5wYWdlOm5vdCgucGFnZS1wcmV2aW91cyk6bm90KC5wYWdlLW5leHQpOm5vdCguY2FjaGVkKScpLmZpbmQoJy5wYWdlLWNvbnRlbnQnKTtcbiAgICB9IGVsc2UgaWYgKCQoJy52aWV3cycpLmxlbmd0aCA+IDApIHtcbiAgICAgIHBhZ2VDb250ZW50ID0gJCgnLnZpZXdzJykuZmluZCgnLnBhZ2U6bm90KC5wYWdlLXByZXZpb3VzKTpub3QoLnBhZ2UtbmV4dCk6bm90KC5jYWNoZWQpJykuZmluZCgnLnBhZ2UtY29udGVudCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYWdlQ29udGVudCA9IGFwcC5yb290LmNoaWxkcmVuKCcudmlldycpLmZpbmQoJy5wYWdlOm5vdCgucGFnZS1wcmV2aW91cyk6bm90KC5wYWdlLW5leHQpOm5vdCguY2FjaGVkKScpLmZpbmQoJy5wYWdlLWNvbnRlbnQnKTtcbiAgICB9XG5cbiAgICBpZiAocGFnZUNvbnRlbnQgJiYgcGFnZUNvbnRlbnQubGVuZ3RoID4gMCkge1xuICAgICAgLy8gQ2hlY2sgZm9yIHRhYlxuICAgICAgaWYgKHBhZ2VDb250ZW50Lmhhc0NsYXNzKCd0YWInKSkge1xuICAgICAgICBwYWdlQ29udGVudCA9IHBhZ2VDb250ZW50LnBhcmVudCgnLnRhYnMnKS5jaGlsZHJlbignLnBhZ2UtY29udGVudC50YWItYWN0aXZlJyk7XG4gICAgICB9XG4gICAgICBpZiAocGFnZUNvbnRlbnQubGVuZ3RoID4gMCkgcGFnZUNvbnRlbnQuc2Nyb2xsVG9wKDAsIDMwMCk7XG4gICAgfVxuICB9LFxuICBzZXRJb3NUZXh0Q29sb3IoY29sb3IpIHtcbiAgICBpZiAoRGV2aWNlLmNvcmRvdmEgJiYgd2luZG93JDEuU3RhdHVzQmFyKSB7XG4gICAgICBpZiAoY29sb3IgPT09ICd3aGl0ZScpIHtcbiAgICAgICAgd2luZG93JDEuU3RhdHVzQmFyLnN0eWxlTGlnaHRDb250ZW50KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aW5kb3ckMS5TdGF0dXNCYXIuc3R5bGVEZWZhdWx0KCk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBzZXRCYWNrZ3JvdW5kQ29sb3IoY29sb3IpIHtcbiAgICAkKCcuc3RhdHVzYmFyJykuY3NzKCdiYWNrZ3JvdW5kLWNvbG9yJywgY29sb3IpO1xuICAgIGlmIChEZXZpY2UuY29yZG92YSAmJiB3aW5kb3ckMS5TdGF0dXNCYXIpIHtcbiAgICAgIHdpbmRvdyQxLlN0YXR1c0Jhci5iYWNrZ3JvdW5kQ29sb3JCeUhleFN0cmluZyhjb2xvcik7XG4gICAgfVxuICB9LFxuICBpc1Zpc2libGUoKSB7XG4gICAgaWYgKERldmljZS5jb3Jkb3ZhICYmIHdpbmRvdyQxLlN0YXR1c0Jhcikge1xuICAgICAgcmV0dXJuIHdpbmRvdyQxLlN0YXR1c0Jhci5pc1Zpc2libGU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcbiAgaW9zT3ZlcmxheXNXZWJWaWV3KG92ZXJsYXlzID0gdHJ1ZSkge1xuICAgIGlmICghRGV2aWNlLmlvcykgcmV0dXJuO1xuICAgIGlmIChEZXZpY2UuY29yZG92YSAmJiB3aW5kb3ckMS5TdGF0dXNCYXIpIHtcbiAgICAgIHdpbmRvdyQxLlN0YXR1c0Jhci5vdmVybGF5c1dlYlZpZXcob3ZlcmxheXMpO1xuICAgICAgaWYgKG92ZXJsYXlzKSB7XG4gICAgICAgICQoJ2h0bWwnKS5hZGRDbGFzcygnd2l0aC1zdGF0dXNiYXInKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICQoJ2h0bWwnKS5yZW1vdmVDbGFzcygnd2l0aC1zdGF0dXNiYXInKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGNoZWNrT3ZlcmxheSgpIHtcbiAgICBpZiAoRGV2aWNlLm5lZWRzU3RhdHVzYmFyT3ZlcmxheSgpKSB7XG4gICAgICAkKCdodG1sJykuYWRkQ2xhc3MoJ3dpdGgtc3RhdHVzYmFyJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICQoJ2h0bWwnKS5yZW1vdmVDbGFzcygnd2l0aC1zdGF0dXNiYXInKTtcbiAgICB9XG4gIH0sXG4gIGluaXQoKSB7XG4gICAgY29uc3QgYXBwID0gdGhpcztcbiAgICBjb25zdCBwYXJhbXMgPSBhcHAucGFyYW1zLnN0YXR1c2JhcjtcbiAgICBpZiAoIXBhcmFtcy5lbmFibGVkKSByZXR1cm47XG5cbiAgICBpZiAocGFyYW1zLm92ZXJsYXkgPT09ICdhdXRvJykge1xuICAgICAgaWYgKERldmljZS5uZWVkc1N0YXR1c2Jhck92ZXJsYXkoKSkge1xuICAgICAgICAkKCdodG1sJykuYWRkQ2xhc3MoJ3dpdGgtc3RhdHVzYmFyJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChEZXZpY2UuaW9zICYmIChEZXZpY2UuY29yZG92YSB8fCBEZXZpY2Uud2ViVmlldykpIHtcbiAgICAgICAgaWYgKHdpbmRvdyQxLm9yaWVudGF0aW9uID09PSAwKSB7XG4gICAgICAgICAgYXBwLm9uY2UoJ3Jlc2l6ZScsICgpID0+IHtcbiAgICAgICAgICAgIFN0YXR1c2Jhci5jaGVja092ZXJsYXkoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgICQoZG9jdW1lbnQpLm9uKCdyZXN1bWUnLCAoKSA9PiB7XG4gICAgICAgICAgU3RhdHVzYmFyLmNoZWNrT3ZlcmxheSgpO1xuICAgICAgICB9LCBmYWxzZSk7XG5cbiAgICAgICAgYXBwLm9uKCdvcmllbnRhdGlvbmNoYW5nZSByZXNpemUnLCAoKSA9PiB7XG4gICAgICAgICAgU3RhdHVzYmFyLmNoZWNrT3ZlcmxheSgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHBhcmFtcy5vdmVybGF5ID09PSB0cnVlKSB7XG4gICAgICAkKCdodG1sJykuYWRkQ2xhc3MoJ3dpdGgtc3RhdHVzYmFyJyk7XG4gICAgfSBlbHNlIGlmIChwYXJhbXMub3ZlcmxheSA9PT0gZmFsc2UpIHtcbiAgICAgICQoJ2h0bWwnKS5yZW1vdmVDbGFzcygnd2l0aC1zdGF0dXNiYXInKTtcbiAgICB9XG5cbiAgICBpZiAoRGV2aWNlLmNvcmRvdmEgJiYgd2luZG93JDEuU3RhdHVzQmFyKSB7XG4gICAgICBpZiAocGFyYW1zLnNjcm9sbFRvcE9uQ2xpY2spIHtcbiAgICAgICAgJCh3aW5kb3ckMSkub24oJ3N0YXR1c1RhcCcsIFN0YXR1c2Jhci5vbkNsaWNrLmJpbmQoYXBwKSk7XG4gICAgICB9XG4gICAgICBpZiAocGFyYW1zLmlvc092ZXJsYXlzV2ViVmlldykge1xuICAgICAgICB3aW5kb3ckMS5TdGF0dXNCYXIub3ZlcmxheXNXZWJWaWV3KHRydWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2luZG93JDEuU3RhdHVzQmFyLm92ZXJsYXlzV2ViVmlldyhmYWxzZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwYXJhbXMuaW9zVGV4dENvbG9yID09PSAnd2hpdGUnKSB7XG4gICAgICAgIHdpbmRvdyQxLlN0YXR1c0Jhci5zdHlsZUxpZ2h0Q29udGVudCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2luZG93JDEuU3RhdHVzQmFyLnN0eWxlRGVmYXVsdCgpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocGFyYW1zLmlvc0JhY2tncm91bmRDb2xvciAmJiBhcHAudGhlbWUgPT09ICdpb3MnKSB7XG4gICAgICBTdGF0dXNiYXIuc2V0QmFja2dyb3VuZENvbG9yKHBhcmFtcy5pb3NCYWNrZ3JvdW5kQ29sb3IpO1xuICAgIH1cbiAgICBpZiAocGFyYW1zLm1hdGVyaWFsQmFja2dyb3VuZENvbG9yICYmIGFwcC50aGVtZSA9PT0gJ21kJykge1xuICAgICAgU3RhdHVzYmFyLnNldEJhY2tncm91bmRDb2xvcihwYXJhbXMubWF0ZXJpYWxCYWNrZ3JvdW5kQ29sb3IpO1xuICAgIH1cbiAgfSxcbn07XG5cbnZhciBTdGF0dXNiYXIkMSA9IHtcbiAgbmFtZTogJ3N0YXR1c2JhcicsXG4gIHBhcmFtczoge1xuICAgIHN0YXR1c2Jhcjoge1xuICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgIG92ZXJsYXk6ICdhdXRvJyxcbiAgICAgIHNjcm9sbFRvcE9uQ2xpY2s6IHRydWUsXG4gICAgICBpb3NPdmVybGF5c1dlYlZpZXc6IHRydWUsXG4gICAgICBpb3NUZXh0Q29sb3I6ICdibGFjaycsXG4gICAgICBpb3NCYWNrZ3JvdW5kQ29sb3I6IG51bGwsXG4gICAgICBtYXRlcmlhbEJhY2tncm91bmRDb2xvcjogbnVsbCxcbiAgICB9LFxuICB9LFxuICBjcmVhdGUoKSB7XG4gICAgY29uc3QgYXBwID0gdGhpcztcbiAgICBVdGlscy5leHRlbmQoYXBwLCB7XG4gICAgICBzdGF0dXNiYXI6IHtcbiAgICAgICAgY2hlY2tPdmVybGF5OiBTdGF0dXNiYXIuY2hlY2tPdmVybGF5LFxuICAgICAgICBoaWRlOiBTdGF0dXNiYXIuaGlkZSxcbiAgICAgICAgc2hvdzogU3RhdHVzYmFyLnNob3csXG4gICAgICAgIGlvc092ZXJsYXlzV2ViVmlldzogU3RhdHVzYmFyLmlvc092ZXJsYXlzV2ViVmlldyxcbiAgICAgICAgc2V0SW9zVGV4dENvbG9yOiBTdGF0dXNiYXIuc2V0SW9zVGV4dENvbG9yLFxuICAgICAgICBzZXRCYWNrZ3JvdW5kQ29sb3I6IFN0YXR1c2Jhci5zZXRCYWNrZ3JvdW5kQ29sb3IsXG4gICAgICAgIGlzVmlzaWJsZTogU3RhdHVzYmFyLmlzVmlzaWJsZSxcbiAgICAgICAgaW5pdDogU3RhdHVzYmFyLmluaXQuYmluZChhcHApLFxuICAgICAgfSxcbiAgICB9KTtcbiAgfSxcbiAgb246IHtcbiAgICBpbml0KCkge1xuICAgICAgY29uc3QgYXBwID0gdGhpcztcbiAgICAgIFN0YXR1c2Jhci5pbml0LmNhbGwoYXBwKTtcbiAgICB9LFxuICB9LFxuICBjbGlja3M6IHtcbiAgICAnLnN0YXR1c2Jhcic6IGZ1bmN0aW9uIG9uU3RhdHVzYmFyQ2xpY2soKSB7XG4gICAgICBjb25zdCBhcHAgPSB0aGlzO1xuICAgICAgaWYgKCFhcHAucGFyYW1zLnN0YXR1c2Jhci5lbmFibGVkKSByZXR1cm47XG4gICAgICBpZiAoIWFwcC5wYXJhbXMuc3RhdHVzYmFyLnNjcm9sbFRvcE9uQ2xpY2spIHJldHVybjtcbiAgICAgIFN0YXR1c2Jhci5vbkNsaWNrLmNhbGwoYXBwKTtcbiAgICB9LFxuICB9LFxufTtcblxuZnVuY3Rpb24gZ2V0Q3VycmVudFZpZXcoYXBwKSB7XG4gIGNvbnN0IHBvcG92ZXJWaWV3ID0gJCgnLnBvcG92ZXIubW9kYWwtaW4gLnZpZXcnKTtcbiAgY29uc3QgcG9wdXBWaWV3ID0gJCgnLnBvcHVwLm1vZGFsLWluIC52aWV3Jyk7XG4gIGNvbnN0IHBhbmVsVmlldyA9ICQoJy5wYW5lbC5wYW5lbC1hY3RpdmUgLnZpZXcnKTtcbiAgbGV0IGFwcFZpZXdzID0gJCgnLnZpZXdzJyk7XG4gIGlmIChhcHBWaWV3cy5sZW5ndGggPT09IDApIGFwcFZpZXdzID0gYXBwLnJvb3Q7XG4gIC8vIEZpbmQgYWN0aXZlIHZpZXcgYXMgdGFiXG4gIGxldCBhcHBWaWV3ID0gYXBwVmlld3MuY2hpbGRyZW4oJy52aWV3Jyk7XG4gIC8vIFByb3BhYmx5IGluIHRhYnMgb3Igc3BsaXQgdmlld1xuICBpZiAoYXBwVmlldy5sZW5ndGggPiAxKSB7XG4gICAgaWYgKGFwcFZpZXcuaGFzQ2xhc3MoJ3RhYicpKSB7XG4gICAgICAvLyBUYWJzXG4gICAgICBhcHBWaWV3ID0gYXBwVmlld3MuY2hpbGRyZW4oJy52aWV3LnRhYi1hY3RpdmUnKTtcbiAgICB9XG4gIH1cbiAgaWYgKHBvcG92ZXJWaWV3Lmxlbmd0aCA+IDAgJiYgcG9wb3ZlclZpZXdbMF0uZjdWaWV3KSByZXR1cm4gcG9wb3ZlclZpZXdbMF0uZjdWaWV3O1xuICBpZiAocG9wdXBWaWV3Lmxlbmd0aCA+IDAgJiYgcG9wdXBWaWV3WzBdLmY3VmlldykgcmV0dXJuIHBvcHVwVmlld1swXS5mN1ZpZXc7XG4gIGlmIChwYW5lbFZpZXcubGVuZ3RoID4gMCAmJiBwYW5lbFZpZXdbMF0uZjdWaWV3KSByZXR1cm4gcGFuZWxWaWV3WzBdLmY3VmlldztcbiAgaWYgKGFwcFZpZXcubGVuZ3RoID4gMCkge1xuICAgIGlmIChhcHBWaWV3Lmxlbmd0aCA9PT0gMSAmJiBhcHBWaWV3WzBdLmY3VmlldykgcmV0dXJuIGFwcFZpZXdbMF0uZjdWaWV3O1xuICAgIGlmIChhcHBWaWV3Lmxlbmd0aCA+IDEpIHtcbiAgICAgIHJldHVybiBhcHAudmlld3MubWFpbjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxudmFyIFZpZXckMSA9IHtcbiAgbmFtZTogJ3ZpZXcnLFxuICBwYXJhbXM6IHtcbiAgICB2aWV3OiB7XG4gICAgICBuYW1lOiB1bmRlZmluZWQsXG4gICAgICBtYWluOiBmYWxzZSxcbiAgICAgIHJvdXRlcjogdHJ1ZSxcbiAgICAgIGxpbmtzVmlldzogbnVsbCxcbiAgICAgIHN0YWNrUGFnZXM6IGZhbHNlLFxuICAgICAgeGhyQ2FjaGU6IHRydWUsXG4gICAgICB4aHJDYWNoZUlnbm9yZTogW10sXG4gICAgICB4aHJDYWNoZUlnbm9yZUdldFBhcmFtZXRlcnM6IGZhbHNlLFxuICAgICAgeGhyQ2FjaGVEdXJhdGlvbjogMTAwMCAqIDYwICogMTAsIC8vIFRlbiBtaW51dGVzXG4gICAgICBwcmVsb2FkUHJldmlvdXNQYWdlOiB0cnVlLFxuICAgICAgdW5pcXVlSGlzdG9yeTogZmFsc2UsXG4gICAgICB1bmlxdWVIaXN0b3J5SWdub3JlR2V0UGFyYW1ldGVyczogZmFsc2UsXG4gICAgICBhbGxvd0R1cGxpY2F0ZVVybHM6IGZhbHNlLFxuICAgICAgcmVsb2FkUGFnZXM6IGZhbHNlLFxuICAgICAgcmVtb3ZlRWxlbWVudHM6IHRydWUsXG4gICAgICByZW1vdmVFbGVtZW50c1dpdGhUaW1lb3V0OiBmYWxzZSxcbiAgICAgIHJlbW92ZUVsZW1lbnRzVGltZW91dDogMCxcbiAgICAgIHJlc3RvcmVTY3JvbGxUb3BPbkJhY2s6IHRydWUsXG4gICAgICB1bmxvYWRUYWJDb250ZW50OiB0cnVlLFxuICAgICAgcGFzc1JvdXRlUXVlcnlUb1JlcXVlc3Q6IHRydWUsXG4gICAgICBwYXNzUm91dGVQYXJhbXNUb1JlcXVlc3Q6IGZhbHNlLFxuICAgICAgLy8gU3dpcGUgQmFja1xuICAgICAgaW9zU3dpcGVCYWNrOiB0cnVlLFxuICAgICAgaW9zU3dpcGVCYWNrQW5pbWF0ZVNoYWRvdzogdHJ1ZSxcbiAgICAgIGlvc1N3aXBlQmFja0FuaW1hdGVPcGFjaXR5OiB0cnVlLFxuICAgICAgaW9zU3dpcGVCYWNrQWN0aXZlQXJlYTogMzAsXG4gICAgICBpb3NTd2lwZUJhY2tUaHJlc2hvbGQ6IDAsXG4gICAgICBtZFN3aXBlQmFjazogZmFsc2UsXG4gICAgICBtZFN3aXBlQmFja0FuaW1hdGVTaGFkb3c6IHRydWUsXG4gICAgICBtZFN3aXBlQmFja0FuaW1hdGVPcGFjaXR5OiBmYWxzZSxcbiAgICAgIG1kU3dpcGVCYWNrQWN0aXZlQXJlYTogMzAsXG4gICAgICBtZFN3aXBlQmFja1RocmVzaG9sZDogMCxcbiAgICAgIC8vIFB1c2ggU3RhdGVcbiAgICAgIHB1c2hTdGF0ZTogZmFsc2UsXG4gICAgICBwdXNoU3RhdGVSb290OiB1bmRlZmluZWQsXG4gICAgICBwdXNoU3RhdGVBbmltYXRlOiB0cnVlLFxuICAgICAgcHVzaFN0YXRlQW5pbWF0ZU9uTG9hZDogZmFsc2UsXG4gICAgICBwdXNoU3RhdGVTZXBhcmF0b3I6ICcjIScsXG4gICAgICBwdXNoU3RhdGVPbkxvYWQ6IHRydWUsXG4gICAgICAvLyBBbmltYXRlIFBhZ2VzXG4gICAgICBhbmltYXRlOiB0cnVlLFxuICAgICAgYW5pbWF0ZVdpdGhKUzogZmFsc2UsXG4gICAgICAvLyBpT1MgRHluYW1pYyBOYXZiYXJcbiAgICAgIGlvc0R5bmFtaWNOYXZiYXI6IHRydWUsXG4gICAgICBpb3NTZXBhcmF0ZUR5bmFtaWNOYXZiYXI6IHRydWUsXG4gICAgICAvLyBBbmltYXRlIGlPUyBOYXZiYXIgQmFjayBJY29uXG4gICAgICBpb3NBbmltYXRlTmF2YmFyQmFja0ljb246IHRydWUsXG4gICAgICAvLyBEZWxheXNcbiAgICAgIGlvc1BhZ2VMb2FkRGVsYXk6IDAsXG4gICAgICBtYXRlcmlhbFBhZ2VMb2FkRGVsYXk6IDAsXG4gICAgfSxcbiAgfSxcbiAgc3RhdGljOiB7XG4gICAgVmlldyxcbiAgfSxcbiAgY3JlYXRlKCkge1xuICAgIGNvbnN0IGFwcCA9IHRoaXM7XG4gICAgVXRpbHMuZXh0ZW5kKGFwcCwge1xuICAgICAgdmlld3M6IFV0aWxzLmV4dGVuZChbXSwge1xuICAgICAgICBjcmVhdGUoZWwsIHBhcmFtcykge1xuICAgICAgICAgIHJldHVybiBuZXcgVmlldyhhcHAsIGVsLCBwYXJhbXMpO1xuICAgICAgICB9LFxuICAgICAgICBnZXQodmlld0VsKSB7XG4gICAgICAgICAgY29uc3QgJHZpZXdFbCA9ICQodmlld0VsKTtcbiAgICAgICAgICBpZiAoJHZpZXdFbC5sZW5ndGggJiYgJHZpZXdFbFswXS5mN1ZpZXcpIHJldHVybiAkdmlld0VsWzBdLmY3VmlldztcbiAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9LFxuICAgICAgfSksXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFwcC52aWV3cywgJ2N1cnJlbnQnLCB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0KCkge1xuICAgICAgICByZXR1cm4gZ2V0Q3VycmVudFZpZXcoYXBwKTtcbiAgICAgIH0sXG4gICAgfSk7XG4gICAgLy8gQWxpYXNcbiAgICBhcHAudmlldyA9IGFwcC52aWV3cztcbiAgfSxcbiAgb246IHtcbiAgICBpbml0KCkge1xuICAgICAgY29uc3QgYXBwID0gdGhpcztcbiAgICAgICQoJy52aWV3LWluaXQnKS5lYWNoKChpbmRleCwgdmlld0VsKSA9PiB7XG4gICAgICAgIGlmICh2aWV3RWwuZjdWaWV3KSByZXR1cm47XG4gICAgICAgIGNvbnN0IHZpZXdQYXJhbXMgPSAkKHZpZXdFbCkuZGF0YXNldCgpO1xuICAgICAgICBhcHAudmlld3MuY3JlYXRlKHZpZXdFbCwgdmlld1BhcmFtcyk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIG1vZGFsT3Blbihtb2RhbCkge1xuICAgICAgY29uc3QgYXBwID0gdGhpcztcbiAgICAgIG1vZGFsLiRlbC5maW5kKCcudmlldy1pbml0JykuZWFjaCgoaW5kZXgsIHZpZXdFbCkgPT4ge1xuICAgICAgICBpZiAodmlld0VsLmY3VmlldykgcmV0dXJuO1xuICAgICAgICBjb25zdCB2aWV3UGFyYW1zID0gJCh2aWV3RWwpLmRhdGFzZXQoKTtcbiAgICAgICAgYXBwLnZpZXdzLmNyZWF0ZSh2aWV3RWwsIHZpZXdQYXJhbXMpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBtb2RhbEJlZm9yZURlc3Ryb3kobW9kYWwpIHtcbiAgICAgIGlmICghbW9kYWwgfHwgIW1vZGFsLiRlbCkgcmV0dXJuO1xuICAgICAgbW9kYWwuJGVsLmZpbmQoJy52aWV3LWluaXQnKS5lYWNoKChpbmRleCwgdmlld0VsKSA9PiB7XG4gICAgICAgIGNvbnN0IHZpZXcgPSB2aWV3RWwuZjdWaWV3O1xuICAgICAgICBpZiAoIXZpZXcpIHJldHVybjtcbiAgICAgICAgdmlldy5kZXN0cm95KCk7XG4gICAgICB9KTtcbiAgICB9LFxuICB9LFxufTtcblxuY29uc3QgTmF2YmFyID0ge1xuICBzaXplKGVsKSB7XG4gICAgY29uc3QgYXBwID0gdGhpcztcbiAgICBpZiAoYXBwLnRoZW1lICE9PSAnaW9zJykgcmV0dXJuO1xuICAgIGxldCAkZWwgPSAkKGVsKTtcbiAgICBpZiAoJGVsLmhhc0NsYXNzKCduYXZiYXInKSkge1xuICAgICAgJGVsID0gJGVsLmNoaWxkcmVuKCcubmF2YmFyLWlubmVyJykuZWFjaCgoaW5kZXgsIG5hdmJhckVsKSA9PiB7XG4gICAgICAgIGFwcC5uYXZiYXIuc2l6ZShuYXZiYXJFbCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKFxuICAgICAgJGVsLmhhc0NsYXNzKCdzdGFja2VkJykgfHxcbiAgICAgICRlbC5wYXJlbnRzKCcuc3RhY2tlZCcpLmxlbmd0aCA+IDAgfHxcbiAgICAgICRlbC5wYXJlbnRzKCcudGFiOm5vdCgudGFiLWFjdGl2ZSknKS5sZW5ndGggPiAwIHx8XG4gICAgICAkZWwucGFyZW50cygnLnBvcHVwOm5vdCgubW9kYWwtaW4pJykubGVuZ3RoID4gMFxuICAgICkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCAkdmlld0VsID0gJGVsLnBhcmVudHMoJy52aWV3JykuZXEoMCk7XG4gICAgY29uc3QgbGVmdCA9IGFwcC5ydGwgPyAkZWwuY2hpbGRyZW4oJy5yaWdodCcpIDogJGVsLmNoaWxkcmVuKCcubGVmdCcpO1xuICAgIGNvbnN0IHJpZ2h0ID0gYXBwLnJ0bCA/ICRlbC5jaGlsZHJlbignLmxlZnQnKSA6ICRlbC5jaGlsZHJlbignLnJpZ2h0Jyk7XG4gICAgY29uc3QgdGl0bGUgPSAkZWwuY2hpbGRyZW4oJy50aXRsZScpO1xuICAgIGNvbnN0IHN1Ym5hdmJhciA9ICRlbC5jaGlsZHJlbignLnN1Ym5hdmJhcicpO1xuICAgIGNvbnN0IG5vTGVmdCA9IGxlZnQubGVuZ3RoID09PSAwO1xuICAgIGNvbnN0IG5vUmlnaHQgPSByaWdodC5sZW5ndGggPT09IDA7XG4gICAgY29uc3QgbGVmdFdpZHRoID0gbm9MZWZ0ID8gMCA6IGxlZnQub3V0ZXJXaWR0aCh0cnVlKTtcbiAgICBjb25zdCByaWdodFdpZHRoID0gbm9SaWdodCA/IDAgOiByaWdodC5vdXRlcldpZHRoKHRydWUpO1xuICAgIGNvbnN0IHRpdGxlV2lkdGggPSB0aXRsZS5vdXRlcldpZHRoKHRydWUpO1xuICAgIGNvbnN0IG5hdmJhclN0eWxlcyA9ICRlbC5zdHlsZXMoKTtcbiAgICBjb25zdCBuYXZiYXJXaWR0aCA9ICRlbFswXS5vZmZzZXRXaWR0aDtcbiAgICBjb25zdCBuYXZiYXJJbm5lcldpZHRoID0gbmF2YmFyV2lkdGggLSBwYXJzZUludChuYXZiYXJTdHlsZXMucGFkZGluZ0xlZnQsIDEwKSAtIHBhcnNlSW50KG5hdmJhclN0eWxlcy5wYWRkaW5nUmlnaHQsIDEwKTtcbiAgICBjb25zdCBpc1ByZXZpb3VzID0gJGVsLmhhc0NsYXNzKCduYXZiYXItcHJldmlvdXMnKTtcbiAgICBjb25zdCBzbGlkaW5nID0gJGVsLmhhc0NsYXNzKCdzbGlkaW5nJyk7XG5cbiAgICBsZXQgcm91dGVyO1xuICAgIGxldCBkeW5hbWljTmF2YmFyO1xuICAgIGxldCBzZXBhcmF0ZU5hdmJhcjtcbiAgICBsZXQgc2VwYXJhdGVOYXZiYXJSaWdodE9mZnNldCA9IDA7XG4gICAgbGV0IHNlcGFyYXRlTmF2YmFyTGVmdE9mZnNldCA9IDA7XG5cbiAgICBpZiAoJHZpZXdFbC5sZW5ndGggPiAwICYmICR2aWV3RWxbMF0uZjdWaWV3KSB7XG4gICAgICByb3V0ZXIgPSAkdmlld0VsWzBdLmY3Vmlldy5yb3V0ZXI7XG4gICAgICBkeW5hbWljTmF2YmFyID0gcm91dGVyICYmIHJvdXRlci5keW5hbWljTmF2YmFyO1xuICAgICAgc2VwYXJhdGVOYXZiYXIgPSByb3V0ZXIgJiYgcm91dGVyLnNlcGFyYXRlTmF2YmFyO1xuICAgICAgaWYgKCFzZXBhcmF0ZU5hdmJhcikge1xuICAgICAgICBzZXBhcmF0ZU5hdmJhclJpZ2h0T2Zmc2V0ID0gbmF2YmFyV2lkdGg7XG4gICAgICAgIHNlcGFyYXRlTmF2YmFyTGVmdE9mZnNldCA9IG5hdmJhcldpZHRoIC8gNTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgY3VyckxlZnQ7XG4gICAgbGV0IGRpZmY7XG4gICAgaWYgKG5vUmlnaHQpIHtcbiAgICAgIGN1cnJMZWZ0ID0gbmF2YmFySW5uZXJXaWR0aCAtIHRpdGxlV2lkdGg7XG4gICAgfVxuICAgIGlmIChub0xlZnQpIHtcbiAgICAgIGN1cnJMZWZ0ID0gMDtcbiAgICB9XG4gICAgaWYgKCFub0xlZnQgJiYgIW5vUmlnaHQpIHtcbiAgICAgIGN1cnJMZWZ0ID0gKChuYXZiYXJJbm5lcldpZHRoIC0gcmlnaHRXaWR0aCAtIHRpdGxlV2lkdGgpICsgbGVmdFdpZHRoKSAvIDI7XG4gICAgfVxuICAgIGxldCByZXF1aXJlZExlZnQgPSAobmF2YmFySW5uZXJXaWR0aCAtIHRpdGxlV2lkdGgpIC8gMjtcbiAgICBpZiAobmF2YmFySW5uZXJXaWR0aCAtIGxlZnRXaWR0aCAtIHJpZ2h0V2lkdGggPiB0aXRsZVdpZHRoKSB7XG4gICAgICBpZiAocmVxdWlyZWRMZWZ0IDwgbGVmdFdpZHRoKSB7XG4gICAgICAgIHJlcXVpcmVkTGVmdCA9IGxlZnRXaWR0aDtcbiAgICAgIH1cbiAgICAgIGlmIChyZXF1aXJlZExlZnQgKyB0aXRsZVdpZHRoID4gbmF2YmFySW5uZXJXaWR0aCAtIHJpZ2h0V2lkdGgpIHtcbiAgICAgICAgcmVxdWlyZWRMZWZ0ID0gbmF2YmFySW5uZXJXaWR0aCAtIHJpZ2h0V2lkdGggLSB0aXRsZVdpZHRoO1xuICAgICAgfVxuICAgICAgZGlmZiA9IHJlcXVpcmVkTGVmdCAtIGN1cnJMZWZ0O1xuICAgIH0gZWxzZSB7XG4gICAgICBkaWZmID0gMDtcbiAgICB9XG5cbiAgICAvLyBSVEwgaW52ZXJ0ZXJcbiAgICBjb25zdCBpbnZlcnRlciA9IGFwcC5ydGwgPyAtMSA6IDE7XG5cbiAgICBpZiAoZHluYW1pY05hdmJhcikge1xuICAgICAgaWYgKHRpdGxlLmhhc0NsYXNzKCdzbGlkaW5nJykgfHwgKHRpdGxlLmxlbmd0aCA+IDAgJiYgc2xpZGluZykpIHtcbiAgICAgICAgbGV0IHRpdGxlTGVmdE9mZnNldCA9ICgtKGN1cnJMZWZ0ICsgZGlmZikgKiBpbnZlcnRlcikgKyBzZXBhcmF0ZU5hdmJhckxlZnRPZmZzZXQ7XG4gICAgICAgIGNvbnN0IHRpdGxlUmlnaHRPZmZzZXQgPSAoKG5hdmJhcklubmVyV2lkdGggLSBjdXJyTGVmdCAtIGRpZmYgLSB0aXRsZVdpZHRoKSAqIGludmVydGVyKSAtIHNlcGFyYXRlTmF2YmFyUmlnaHRPZmZzZXQ7XG5cbiAgICAgICAgaWYgKGlzUHJldmlvdXMpIHtcbiAgICAgICAgICBpZiAocm91dGVyICYmIHJvdXRlci5wYXJhbXMuaW9zQW5pbWF0ZU5hdmJhckJhY2tJY29uKSB7XG4gICAgICAgICAgICBjb25zdCBhY3RpdmVOYXZiYXJCYWNrTGluayA9ICRlbC5wYXJlbnQoKS5maW5kKCcubmF2YmFyLWN1cnJlbnQnKS5jaGlsZHJlbignLmxlZnQuc2xpZGluZycpLmZpbmQoJy5iYWNrIC5pY29uIH4gc3BhbicpO1xuICAgICAgICAgICAgaWYgKGFjdGl2ZU5hdmJhckJhY2tMaW5rLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgdGl0bGVMZWZ0T2Zmc2V0ICs9IGFjdGl2ZU5hdmJhckJhY2tMaW5rWzBdLm9mZnNldExlZnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRpdGxlWzBdLmY3TmF2YmFyTGVmdE9mZnNldCA9IHRpdGxlTGVmdE9mZnNldDtcbiAgICAgICAgdGl0bGVbMF0uZjdOYXZiYXJSaWdodE9mZnNldCA9IHRpdGxlUmlnaHRPZmZzZXQ7XG4gICAgICB9XG4gICAgICBpZiAoIW5vTGVmdCAmJiAobGVmdC5oYXNDbGFzcygnc2xpZGluZycpIHx8IHNsaWRpbmcpKSB7XG4gICAgICAgIGlmIChhcHAucnRsKSB7XG4gICAgICAgICAgbGVmdFswXS5mN05hdmJhckxlZnRPZmZzZXQgPSAoLShuYXZiYXJJbm5lcldpZHRoIC0gbGVmdFswXS5vZmZzZXRXaWR0aCkgLyAyKSAqIGludmVydGVyO1xuICAgICAgICAgIGxlZnRbMF0uZjdOYXZiYXJSaWdodE9mZnNldCA9IGxlZnRXaWR0aCAqIGludmVydGVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxlZnRbMF0uZjdOYXZiYXJMZWZ0T2Zmc2V0ID0gLWxlZnRXaWR0aCArIHNlcGFyYXRlTmF2YmFyTGVmdE9mZnNldDtcbiAgICAgICAgICBsZWZ0WzBdLmY3TmF2YmFyUmlnaHRPZmZzZXQgPSAoKG5hdmJhcklubmVyV2lkdGggLSBsZWZ0WzBdLm9mZnNldFdpZHRoKSAvIDIpIC0gc2VwYXJhdGVOYXZiYXJSaWdodE9mZnNldDtcbiAgICAgICAgICBpZiAocm91dGVyICYmIHJvdXRlci5wYXJhbXMuaW9zQW5pbWF0ZU5hdmJhckJhY2tJY29uICYmIGxlZnQuZmluZCgnLmJhY2sgLmljb24nKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBsZWZ0WzBdLmY3TmF2YmFyUmlnaHRPZmZzZXQgLT0gbGVmdC5maW5kKCcuYmFjayAuaWNvbicpWzBdLm9mZnNldFdpZHRoO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFub1JpZ2h0ICYmIChyaWdodC5oYXNDbGFzcygnc2xpZGluZycpIHx8IHNsaWRpbmcpKSB7XG4gICAgICAgIGlmIChhcHAucnRsKSB7XG4gICAgICAgICAgcmlnaHRbMF0uZjdOYXZiYXJMZWZ0T2Zmc2V0ID0gLXJpZ2h0V2lkdGggKiBpbnZlcnRlcjtcbiAgICAgICAgICByaWdodFswXS5mN05hdmJhclJpZ2h0T2Zmc2V0ID0gKChuYXZiYXJJbm5lcldpZHRoIC0gcmlnaHRbMF0ub2Zmc2V0V2lkdGgpIC8gMikgKiBpbnZlcnRlcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByaWdodFswXS5mN05hdmJhckxlZnRPZmZzZXQgPSAoLShuYXZiYXJJbm5lcldpZHRoIC0gcmlnaHRbMF0ub2Zmc2V0V2lkdGgpIC8gMikgKyBzZXBhcmF0ZU5hdmJhckxlZnRPZmZzZXQ7XG4gICAgICAgICAgcmlnaHRbMF0uZjdOYXZiYXJSaWdodE9mZnNldCA9IHJpZ2h0V2lkdGggLSBzZXBhcmF0ZU5hdmJhclJpZ2h0T2Zmc2V0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoc3VibmF2YmFyLmxlbmd0aCAmJiAoc3VibmF2YmFyLmhhc0NsYXNzKCdzbGlkaW5nJykgfHwgc2xpZGluZykpIHtcbiAgICAgICAgc3VibmF2YmFyWzBdLmY3TmF2YmFyTGVmdE9mZnNldCA9IGFwcC5ydGwgPyBzdWJuYXZiYXJbMF0ub2Zmc2V0V2lkdGggOiAoLXN1Ym5hdmJhclswXS5vZmZzZXRXaWR0aCArIHNlcGFyYXRlTmF2YmFyTGVmdE9mZnNldCk7XG4gICAgICAgIHN1Ym5hdmJhclswXS5mN05hdmJhclJpZ2h0T2Zmc2V0ID0gKC1zdWJuYXZiYXJbMF0uZjdOYXZiYXJMZWZ0T2Zmc2V0IC0gc2VwYXJhdGVOYXZiYXJSaWdodE9mZnNldCkgKyBzZXBhcmF0ZU5hdmJhckxlZnRPZmZzZXQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVGl0bGUgbGVmdFxuICAgIGlmIChhcHAucGFyYW1zLm5hdmJhci5pb3NDZW50ZXJUaXRsZSkge1xuICAgICAgbGV0IHRpdGxlTGVmdCA9IGRpZmY7XG4gICAgICBpZiAoYXBwLnJ0bCAmJiBub0xlZnQgJiYgbm9SaWdodCAmJiB0aXRsZS5sZW5ndGggPiAwKSB0aXRsZUxlZnQgPSAtdGl0bGVMZWZ0O1xuICAgICAgdGl0bGUuY3NzKHsgbGVmdDogYCR7dGl0bGVMZWZ0fXB4YCB9KTtcbiAgICB9XG4gIH0sXG4gIGhpZGUoZWwsIGFuaW1hdGUgPSB0cnVlKSB7XG4gICAgbGV0ICRlbCA9ICQoZWwpO1xuICAgIGlmICgkZWwuaGFzQ2xhc3MoJ25hdmJhci1pbm5lcicpKSAkZWwgPSAkZWwucGFyZW50cygnLm5hdmJhcicpO1xuICAgIGlmICghJGVsLmxlbmd0aCkgcmV0dXJuO1xuICAgIGlmICgkZWwuaGFzQ2xhc3MoJ25hdmJhci1oaWRkZW4nKSkgcmV0dXJuO1xuICAgIGNvbnN0IGNsYXNzTmFtZSA9IGBuYXZiYXItaGlkZGVuJHthbmltYXRlID8gJyBuYXZiYXItdHJhbnNpdGlvbmluZycgOiAnJ31gO1xuICAgICRlbC50cmFuc2l0aW9uRW5kKCgpID0+IHtcbiAgICAgICRlbC5yZW1vdmVDbGFzcygnbmF2YmFyLXRyYW5zaXRpb25pbmcnKTtcbiAgICB9KTtcbiAgICAkZWwuYWRkQ2xhc3MoY2xhc3NOYW1lKTtcbiAgfSxcbiAgc2hvdyhlbCA9ICcubmF2YmFyLWhpZGRlbicsIGFuaW1hdGUgPSB0cnVlKSB7XG4gICAgbGV0ICRlbCA9ICQoZWwpO1xuICAgIGlmICgkZWwuaGFzQ2xhc3MoJ25hdmJhci1pbm5lcicpKSAkZWwgPSAkZWwucGFyZW50cygnLm5hdmJhcicpO1xuICAgIGlmICghJGVsLmxlbmd0aCkgcmV0dXJuO1xuICAgIGlmICghJGVsLmhhc0NsYXNzKCduYXZiYXItaGlkZGVuJykpIHJldHVybjtcbiAgICBpZiAoYW5pbWF0ZSkge1xuICAgICAgJGVsLmFkZENsYXNzKCduYXZiYXItdHJhbnNpdGlvbmluZycpO1xuICAgICAgJGVsLnRyYW5zaXRpb25FbmQoKCkgPT4ge1xuICAgICAgICAkZWwucmVtb3ZlQ2xhc3MoJ25hdmJhci10cmFuc2l0aW9uaW5nJyk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgJGVsLnJlbW92ZUNsYXNzKCduYXZiYXItaGlkZGVuJyk7XG4gIH0sXG4gIGdldEVsQnlQYWdlKHBhZ2UpIHtcbiAgICBsZXQgJHBhZ2VFbDtcbiAgICBsZXQgJG5hdmJhckVsO1xuICAgIGxldCBwYWdlRGF0YTtcbiAgICBpZiAocGFnZS4kbmF2YmFyRWwgfHwgcGFnZS4kZWwpIHtcbiAgICAgIHBhZ2VEYXRhID0gcGFnZTtcbiAgICAgICRwYWdlRWwgPSBwYWdlLiRlbDtcbiAgICB9IGVsc2Uge1xuICAgICAgJHBhZ2VFbCA9ICQocGFnZSk7XG4gICAgICBpZiAoJHBhZ2VFbC5sZW5ndGggPiAwKSBwYWdlRGF0YSA9ICRwYWdlRWxbMF0uZjdQYWdlO1xuICAgIH1cbiAgICBpZiAocGFnZURhdGEgJiYgcGFnZURhdGEuJG5hdmJhckVsICYmIHBhZ2VEYXRhLiRuYXZiYXJFbC5sZW5ndGggPiAwKSB7XG4gICAgICAkbmF2YmFyRWwgPSBwYWdlRGF0YS4kbmF2YmFyRWw7XG4gICAgfSBlbHNlIGlmICgkcGFnZUVsKSB7XG4gICAgICAkbmF2YmFyRWwgPSAkcGFnZUVsLmNoaWxkcmVuKCcubmF2YmFyJykuY2hpbGRyZW4oJy5uYXZiYXItaW5uZXInKTtcbiAgICB9XG4gICAgaWYgKCEkbmF2YmFyRWwgfHwgKCRuYXZiYXJFbCAmJiAkbmF2YmFyRWwubGVuZ3RoID09PSAwKSkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICByZXR1cm4gJG5hdmJhckVsWzBdO1xuICB9LFxuICBnZXRQYWdlQnlFbChuYXZiYXJJbm5lckVsKSB7XG4gICAgbGV0ICRuYXZiYXJJbm5lckVsID0gJChuYXZiYXJJbm5lckVsKTtcbiAgICBpZiAoJG5hdmJhcklubmVyRWwuaGFzQ2xhc3MoJ25hdmJhcicpKSB7XG4gICAgICAkbmF2YmFySW5uZXJFbCA9ICRuYXZiYXJJbm5lckVsLmZpbmQoJy5uYXZiYXItaW5uZXInKTtcbiAgICAgIGlmICgkbmF2YmFySW5uZXJFbC5sZW5ndGggPiAxKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gJG5hdmJhcklubmVyRWxbMF0uZjdQYWdlO1xuICB9LFxuICBpbml0SGlkZU5hdmJhck9uU2Nyb2xsKHBhZ2VFbCwgbmF2YmFySW5uZXJFbCkge1xuICAgIGNvbnN0IGFwcCA9IHRoaXM7XG4gICAgY29uc3QgJHBhZ2VFbCA9ICQocGFnZUVsKTtcbiAgICBjb25zdCAkbmF2YmFyRWwgPSAkKG5hdmJhcklubmVyRWwgfHwgYXBwLm5hdmJhci5nZXRFbEJ5UGFnZShwYWdlRWwpKS5jbG9zZXN0KCcubmF2YmFyJyk7XG5cbiAgICBsZXQgcHJldmlvdXNTY3JvbGxUb3A7XG4gICAgbGV0IGN1cnJlbnRTY3JvbGxUb3A7XG5cbiAgICBsZXQgc2Nyb2xsSGVpZ2h0O1xuICAgIGxldCBvZmZzZXRIZWlnaHQ7XG4gICAgbGV0IHJlYWNoRW5kO1xuICAgIGxldCBhY3Rpb247XG4gICAgbGV0IG5hdmJhckhpZGRlbjtcbiAgICBmdW5jdGlvbiBoYW5kbGVTY3JvbGwoKSB7XG4gICAgICBjb25zdCBzY3JvbGxDb250ZW50ID0gdGhpcztcbiAgICAgIGlmICgkcGFnZUVsLmhhc0NsYXNzKCdwYWdlLXByZXZpb3VzJykpIHJldHVybjtcbiAgICAgIGN1cnJlbnRTY3JvbGxUb3AgPSBzY3JvbGxDb250ZW50LnNjcm9sbFRvcDtcbiAgICAgIHNjcm9sbEhlaWdodCA9IHNjcm9sbENvbnRlbnQuc2Nyb2xsSGVpZ2h0O1xuICAgICAgb2Zmc2V0SGVpZ2h0ID0gc2Nyb2xsQ29udGVudC5vZmZzZXRIZWlnaHQ7XG4gICAgICByZWFjaEVuZCA9IGN1cnJlbnRTY3JvbGxUb3AgKyBvZmZzZXRIZWlnaHQgPj0gc2Nyb2xsSGVpZ2h0O1xuICAgICAgbmF2YmFySGlkZGVuID0gJG5hdmJhckVsLmhhc0NsYXNzKCduYXZiYXItaGlkZGVuJyk7XG5cbiAgICAgIGlmIChyZWFjaEVuZCkge1xuICAgICAgICBpZiAoYXBwLnBhcmFtcy5uYXZiYXIuc2hvd09uUGFnZVNjcm9sbEVuZCkge1xuICAgICAgICAgIGFjdGlvbiA9ICdzaG93JztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwcmV2aW91c1Njcm9sbFRvcCA+IGN1cnJlbnRTY3JvbGxUb3ApIHtcbiAgICAgICAgaWYgKGFwcC5wYXJhbXMubmF2YmFyLnNob3dPblBhZ2VTY3JvbGxUb3AgfHwgY3VycmVudFNjcm9sbFRvcCA8PSA0NCkge1xuICAgICAgICAgIGFjdGlvbiA9ICdzaG93JztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhY3Rpb24gPSAnaGlkZSc7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY3VycmVudFNjcm9sbFRvcCA+IDQ0KSB7XG4gICAgICAgIGFjdGlvbiA9ICdoaWRlJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFjdGlvbiA9ICdzaG93JztcbiAgICAgIH1cblxuICAgICAgaWYgKGFjdGlvbiA9PT0gJ3Nob3cnICYmIG5hdmJhckhpZGRlbikge1xuICAgICAgICBhcHAubmF2YmFyLnNob3coJG5hdmJhckVsKTtcbiAgICAgICAgbmF2YmFySGlkZGVuID0gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKGFjdGlvbiA9PT0gJ2hpZGUnICYmICFuYXZiYXJIaWRkZW4pIHtcbiAgICAgICAgYXBwLm5hdmJhci5oaWRlKCRuYXZiYXJFbCk7XG4gICAgICAgIG5hdmJhckhpZGRlbiA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHByZXZpb3VzU2Nyb2xsVG9wID0gY3VycmVudFNjcm9sbFRvcDtcbiAgICB9XG4gICAgJHBhZ2VFbC5vbignc2Nyb2xsJywgJy5wYWdlLWNvbnRlbnQnLCBoYW5kbGVTY3JvbGwsIHRydWUpO1xuICAgICRwYWdlRWxbMF0uZjdTY3JvbGxOYXZiYXJIYW5kbGVyID0gaGFuZGxlU2Nyb2xsO1xuICB9LFxufTtcbnZhciBOYXZiYXIkMSA9IHtcbiAgbmFtZTogJ25hdmJhcicsXG4gIGNyZWF0ZSgpIHtcbiAgICBjb25zdCBhcHAgPSB0aGlzO1xuICAgIFV0aWxzLmV4dGVuZChhcHAsIHtcbiAgICAgIG5hdmJhcjoge1xuICAgICAgICBzaXplOiBOYXZiYXIuc2l6ZS5iaW5kKGFwcCksXG4gICAgICAgIGhpZGU6IE5hdmJhci5oaWRlLmJpbmQoYXBwKSxcbiAgICAgICAgc2hvdzogTmF2YmFyLnNob3cuYmluZChhcHApLFxuICAgICAgICBnZXRFbEJ5UGFnZTogTmF2YmFyLmdldEVsQnlQYWdlLmJpbmQoYXBwKSxcbiAgICAgICAgaW5pdEhpZGVOYXZiYXJPblNjcm9sbDogTmF2YmFyLmluaXRIaWRlTmF2YmFyT25TY3JvbGwuYmluZChhcHApLFxuICAgICAgfSxcbiAgICB9KTtcbiAgfSxcbiAgcGFyYW1zOiB7XG4gICAgbmF2YmFyOiB7XG4gICAgICBzY3JvbGxUb3BPblRpdGxlQ2xpY2s6IHRydWUsXG4gICAgICBpb3NDZW50ZXJUaXRsZTogdHJ1ZSxcbiAgICAgIGhpZGVPblBhZ2VTY3JvbGw6IGZhbHNlLFxuICAgICAgc2hvd09uUGFnZVNjcm9sbEVuZDogdHJ1ZSxcbiAgICAgIHNob3dPblBhZ2VTY3JvbGxUb3A6IHRydWUsXG4gICAgfSxcbiAgfSxcbiAgb246IHtcbiAgICAncGFuZWxCcmVha3BvaW50IHJlc2l6ZSc6IGZ1bmN0aW9uIG9uUmVzaXplKCkge1xuICAgICAgY29uc3QgYXBwID0gdGhpcztcbiAgICAgIGlmIChhcHAudGhlbWUgIT09ICdpb3MnKSByZXR1cm47XG4gICAgICAkKCcubmF2YmFyJykuZWFjaCgoaW5kZXgsIG5hdmJhckVsKSA9PiB7XG4gICAgICAgIGFwcC5uYXZiYXIuc2l6ZShuYXZiYXJFbCk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIHBhZ2VCZWZvcmVSZW1vdmUocGFnZSkge1xuICAgICAgaWYgKHBhZ2UuJGVsWzBdLmY3U2Nyb2xsTmF2YmFySGFuZGxlcikge1xuICAgICAgICBwYWdlLiRlbC5vZmYoJ3Njcm9sbCcsICcucGFnZS1jb250ZW50JywgcGFnZS4kZWxbMF0uZjdTY3JvbGxOYXZiYXJIYW5kbGVyLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHBhZ2VCZWZvcmVJbihwYWdlKSB7XG4gICAgICBjb25zdCBhcHAgPSB0aGlzO1xuICAgICAgaWYgKGFwcC50aGVtZSAhPT0gJ2lvcycpIHJldHVybjtcbiAgICAgIGxldCAkbmF2YmFyRWw7XG4gICAgICBjb25zdCB2aWV3ID0gcGFnZS4kZWwucGFyZW50cygnLnZpZXcnKVswXS5mN1ZpZXc7XG4gICAgICBjb25zdCBuYXZiYXJJbm5lckVsID0gYXBwLm5hdmJhci5nZXRFbEJ5UGFnZShwYWdlKTtcbiAgICAgIGlmICghbmF2YmFySW5uZXJFbCkge1xuICAgICAgICAkbmF2YmFyRWwgPSBwYWdlLiRlbC5wYXJlbnRzKCcudmlldycpLmNoaWxkcmVuKCcubmF2YmFyJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAkbmF2YmFyRWwgPSAkKG5hdmJhcklubmVyRWwpLnBhcmVudHMoJy5uYXZiYXInKTtcbiAgICAgIH1cbiAgICAgIGlmIChwYWdlLiRlbC5oYXNDbGFzcygnbm8tbmF2YmFyJykgfHwgKHZpZXcucm91dGVyLmR5bmFtaWNOYXZiYXIgJiYgIW5hdmJhcklubmVyRWwpKSB7XG4gICAgICAgIGNvbnN0IGFuaW1hdGUgPSAhIShwYWdlLnBhZ2VGcm9tICYmIHBhZ2Uucm91dGVyLmhpc3RvcnkubGVuZ3RoID4gMCk7XG4gICAgICAgIGFwcC5uYXZiYXIuaGlkZSgkbmF2YmFyRWwsIGFuaW1hdGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXBwLm5hdmJhci5zaG93KCRuYXZiYXJFbCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBwYWdlUmVpbml0KHBhZ2UpIHtcbiAgICAgIGNvbnN0IGFwcCA9IHRoaXM7XG4gICAgICBpZiAoYXBwLnRoZW1lICE9PSAnaW9zJykgcmV0dXJuO1xuICAgICAgY29uc3QgJG5hdmJhckVsID0gJChhcHAubmF2YmFyLmdldEVsQnlQYWdlKHBhZ2UpKTtcbiAgICAgIGlmICghJG5hdmJhckVsIHx8ICRuYXZiYXJFbC5sZW5ndGggPT09IDApIHJldHVybjtcbiAgICAgIGFwcC5uYXZiYXIuc2l6ZSgkbmF2YmFyRWwpO1xuICAgIH0sXG4gICAgcGFnZUluaXQocGFnZSkge1xuICAgICAgY29uc3QgYXBwID0gdGhpcztcbiAgICAgIGNvbnN0ICRuYXZiYXJFbCA9ICQoYXBwLm5hdmJhci5nZXRFbEJ5UGFnZShwYWdlKSk7XG4gICAgICBpZiAoISRuYXZiYXJFbCB8fCAkbmF2YmFyRWwubGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgICBpZiAoYXBwLnRoZW1lID09PSAnaW9zJykge1xuICAgICAgICBhcHAubmF2YmFyLnNpemUoJG5hdmJhckVsKTtcbiAgICAgIH1cbiAgICAgIGlmIChcbiAgICAgICAgYXBwLnBhcmFtcy5uYXZiYXIuaGlkZU9uUGFnZVNjcm9sbCB8fFxuICAgICAgICBwYWdlLiRlbC5maW5kKCcuaGlkZS1uYXZiYXItb24tc2Nyb2xsJykubGVuZ3RoIHx8XG4gICAgICAgIHBhZ2UuJGVsLmhhc0NsYXNzKCdoaWRlLW5hdmJhci1vbi1zY3JvbGwnKSB8fFxuICAgICAgICBwYWdlLiRlbC5maW5kKCcuaGlkZS1iYXJzLW9uLXNjcm9sbCcpLmxlbmd0aCB8fFxuICAgICAgICBwYWdlLiRlbC5oYXNDbGFzcygnaGlkZS1iYXJzLW9uLXNjcm9sbCcpXG4gICAgICApIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHBhZ2UuJGVsLmZpbmQoJy5rZWVwLW5hdmJhci1vbi1zY3JvbGwnKS5sZW5ndGggfHxcbiAgICAgICAgICBwYWdlLiRlbC5oYXNDbGFzcygna2VlcC1uYXZiYXItb24tc2Nyb2xsJykgfHxcbiAgICAgICAgICBwYWdlLiRlbC5maW5kKCcua2VlcC1iYXJzLW9uLXNjcm9sbCcpLmxlbmd0aCB8fFxuICAgICAgICAgIHBhZ2UuJGVsLmhhc0NsYXNzKCdrZWVwLWJhcnMtb24tc2Nyb2xsJylcbiAgICAgICAgKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGFwcC5uYXZiYXIuaW5pdEhpZGVOYXZiYXJPblNjcm9sbChwYWdlLmVsLCAkbmF2YmFyRWxbMF0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgbW9kYWxPcGVuKG1vZGFsKSB7XG4gICAgICBjb25zdCBhcHAgPSB0aGlzO1xuICAgICAgaWYgKGFwcC50aGVtZSAhPT0gJ2lvcycpIHJldHVybjtcbiAgICAgIG1vZGFsLiRlbC5maW5kKCcubmF2YmFyOm5vdCgubmF2YmFyLXByZXZpb3VzKTpub3QoLnN0YWNrZWQpJykuZWFjaCgoaW5kZXgsIG5hdmJhckVsKSA9PiB7XG4gICAgICAgIGFwcC5uYXZiYXIuc2l6ZShuYXZiYXJFbCk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIHBhbmVsT3BlbihwYW5lbCkge1xuICAgICAgY29uc3QgYXBwID0gdGhpcztcbiAgICAgIGlmIChhcHAudGhlbWUgIT09ICdpb3MnKSByZXR1cm47XG4gICAgICBwYW5lbC4kZWwuZmluZCgnLm5hdmJhcjpub3QoLm5hdmJhci1wcmV2aW91cyk6bm90KC5zdGFja2VkKScpLmVhY2goKGluZGV4LCBuYXZiYXJFbCkgPT4ge1xuICAgICAgICBhcHAubmF2YmFyLnNpemUobmF2YmFyRWwpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBwYW5lbFN3aXBlT3BlbihwYW5lbCkge1xuICAgICAgY29uc3QgYXBwID0gdGhpcztcbiAgICAgIGlmIChhcHAudGhlbWUgIT09ICdpb3MnKSByZXR1cm47XG4gICAgICBwYW5lbC4kZWwuZmluZCgnLm5hdmJhcjpub3QoLm5hdmJhci1wcmV2aW91cyk6bm90KC5zdGFja2VkKScpLmVhY2goKGluZGV4LCBuYXZiYXJFbCkgPT4ge1xuICAgICAgICBhcHAubmF2YmFyLnNpemUobmF2YmFyRWwpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICB0YWJTaG93KHRhYkVsKSB7XG4gICAgICBjb25zdCBhcHAgPSB0aGlzO1xuICAgICAgJCh0YWJFbCkuZmluZCgnLm5hdmJhcjpub3QoLm5hdmJhci1wcmV2aW91cyk6bm90KC5zdGFja2VkKScpLmVhY2goKGluZGV4LCBuYXZiYXJFbCkgPT4ge1xuICAgICAgICBhcHAubmF2YmFyLnNpemUobmF2YmFyRWwpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgfSxcbiAgY2xpY2tzOiB7XG4gICAgJy5uYXZiYXIgLnRpdGxlJzogZnVuY3Rpb24gb25UaXRsZUNsaWNrKCRjbGlja2VkRWwpIHtcbiAgICAgIGNvbnN0IGFwcCA9IHRoaXM7XG4gICAgICBpZiAoIWFwcC5wYXJhbXMubmF2YmFyLnNjcm9sbFRvcE9uVGl0bGVDbGljaykgcmV0dXJuO1xuICAgICAgaWYgKCRjbGlja2VkRWwuY2xvc2VzdCgnYScpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGV0IHBhZ2VDb250ZW50O1xuICAgICAgLy8gRmluZCBhY3RpdmUgcGFnZVxuICAgICAgY29uc3QgbmF2YmFyID0gJGNsaWNrZWRFbC5wYXJlbnRzKCcubmF2YmFyJyk7XG5cbiAgICAgIC8vIFN0YXRpYyBMYXlvdXRcbiAgICAgIHBhZ2VDb250ZW50ID0gbmF2YmFyLnBhcmVudHMoJy5wYWdlLWNvbnRlbnQnKTtcblxuICAgICAgaWYgKHBhZ2VDb250ZW50Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAvLyBGaXhlZCBMYXlvdXRcbiAgICAgICAgaWYgKG5hdmJhci5wYXJlbnRzKCcucGFnZScpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBwYWdlQ29udGVudCA9IG5hdmJhci5wYXJlbnRzKCcucGFnZScpLmZpbmQoJy5wYWdlLWNvbnRlbnQnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaHJvdWdoIExheW91dFxuICAgICAgICBpZiAocGFnZUNvbnRlbnQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgaWYgKG5hdmJhci5uZXh0QWxsKCcucGFnZS1jdXJyZW50Om5vdCguc3RhY2tlZCknKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBwYWdlQ29udGVudCA9IG5hdmJhci5uZXh0QWxsKCcucGFnZS1jdXJyZW50Om5vdCguc3RhY2tlZCknKS5maW5kKCcucGFnZS1jb250ZW50Jyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocGFnZUNvbnRlbnQgJiYgcGFnZUNvbnRlbnQubGVuZ3RoID4gMCkge1xuICAgICAgICAvLyBDaGVjayBmb3IgdGFiXG4gICAgICAgIGlmIChwYWdlQ29udGVudC5oYXNDbGFzcygndGFiJykpIHtcbiAgICAgICAgICBwYWdlQ29udGVudCA9IHBhZ2VDb250ZW50LnBhcmVudCgnLnRhYnMnKS5jaGlsZHJlbignLnBhZ2UtY29udGVudC50YWItYWN0aXZlJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhZ2VDb250ZW50Lmxlbmd0aCA+IDApIHBhZ2VDb250ZW50LnNjcm9sbFRvcCgwLCAzMDApO1xuICAgICAgfVxuICAgIH0sXG4gIH0sXG59O1xuXG5jb25zdCBUb29sYmFyID0ge1xuICBzZXRIaWdobGlnaHQodGFiYmFyRWwpIHtcbiAgICBjb25zdCBhcHAgPSB0aGlzO1xuICAgIGlmIChhcHAudGhlbWUgIT09ICdtZCcpIHJldHVybjtcblxuICAgIGNvbnN0ICR0YWJiYXJFbCA9ICQodGFiYmFyRWwpO1xuXG4gICAgaWYgKCR0YWJiYXJFbC5sZW5ndGggPT09IDAgfHwgISgkdGFiYmFyRWwuaGFzQ2xhc3MoJ3RhYmJhcicpIHx8ICR0YWJiYXJFbC5oYXNDbGFzcygndGFiYmFyLWxhYmVscycpKSkgcmV0dXJuO1xuXG4gICAgaWYgKCR0YWJiYXJFbC5maW5kKCcudGFiLWxpbmstaGlnaGxpZ2h0JykubGVuZ3RoID09PSAwKSB7XG4gICAgICAkdGFiYmFyRWwuY2hpbGRyZW4oJy50b29sYmFyLWlubmVyJykuYXBwZW5kKCc8c3BhbiBjbGFzcz1cInRhYi1saW5rLWhpZ2hsaWdodFwiPjwvc3Bhbj4nKTtcbiAgICB9XG5cbiAgICBjb25zdCAkaGlnaGxpZ2h0RWwgPSAkdGFiYmFyRWwuZmluZCgnLnRhYi1saW5rLWhpZ2hsaWdodCcpO1xuICAgIGNvbnN0ICRhY3RpdmVMaW5rID0gJHRhYmJhckVsLmZpbmQoJy50YWItbGluay1hY3RpdmUnKTtcbiAgICBsZXQgaGlnaGxpZ2h0V2lkdGg7XG4gICAgbGV0IGhpZ2hsaWdodFRyYW5zbGF0ZTtcblxuICAgIGlmICgkdGFiYmFyRWwuaGFzQ2xhc3MoJ3RhYmJhci1zY3JvbGxhYmxlJykgJiYgJGFjdGl2ZUxpbmsgJiYgJGFjdGl2ZUxpbmtbMF0pIHtcbiAgICAgIGhpZ2hsaWdodFdpZHRoID0gYCR7JGFjdGl2ZUxpbmtbMF0ub2Zmc2V0V2lkdGh9cHhgO1xuICAgICAgaGlnaGxpZ2h0VHJhbnNsYXRlID0gYCR7JGFjdGl2ZUxpbmtbMF0ub2Zmc2V0TGVmdH1weGA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGFjdGl2ZUluZGV4ID0gJGFjdGl2ZUxpbmsuaW5kZXgoKTtcbiAgICAgIGNvbnN0IHRhYkxpbmtzQ291bnQgPSAkdGFiYmFyRWwuZmluZCgnLnRhYi1saW5rJykubGVuZ3RoO1xuICAgICAgaGlnaGxpZ2h0V2lkdGggPSBgJHsxMDAgLyB0YWJMaW5rc0NvdW50fSVgO1xuICAgICAgaGlnaGxpZ2h0VHJhbnNsYXRlID0gYCR7KGFwcC5ydGwgPyAtYWN0aXZlSW5kZXggOiBhY3RpdmVJbmRleCkgKiAxMDB9JWA7XG4gICAgfVxuXG4gICAgJGhpZ2hsaWdodEVsXG4gICAgICAuY3NzKCd3aWR0aCcsIGhpZ2hsaWdodFdpZHRoKVxuICAgICAgLnRyYW5zZm9ybShgdHJhbnNsYXRlM2QoJHtoaWdobGlnaHRUcmFuc2xhdGV9LDAsMClgKTtcbiAgfSxcbiAgaW5pdCh0YWJiYXJFbCkge1xuICAgIGNvbnN0IGFwcCA9IHRoaXM7XG4gICAgYXBwLnRvb2xiYXIuc2V0SGlnaGxpZ2h0KHRhYmJhckVsKTtcbiAgfSxcbiAgaGlkZShlbCwgYW5pbWF0ZSA9IHRydWUpIHtcbiAgICBjb25zdCAkZWwgPSAkKGVsKTtcbiAgICBpZiAoJGVsLmhhc0NsYXNzKCd0b29sYmFyLWhpZGRlbicpKSByZXR1cm47XG4gICAgY29uc3QgY2xhc3NOYW1lID0gYHRvb2xiYXItaGlkZGVuJHthbmltYXRlID8gJyB0b29sYmFyLXRyYW5zaXRpb25pbmcnIDogJyd9YDtcbiAgICAkZWwudHJhbnNpdGlvbkVuZCgoKSA9PiB7XG4gICAgICAkZWwucmVtb3ZlQ2xhc3MoJ3Rvb2xiYXItdHJhbnNpdGlvbmluZycpO1xuICAgIH0pO1xuICAgICRlbC5hZGRDbGFzcyhjbGFzc05hbWUpO1xuICB9LFxuICBzaG93KGVsLCBhbmltYXRlID0gdHJ1ZSkge1xuICAgIGNvbnN0ICRlbCA9ICQoZWwpO1xuICAgIGlmICghJGVsLmhhc0NsYXNzKCd0b29sYmFyLWhpZGRlbicpKSByZXR1cm47XG4gICAgaWYgKGFuaW1hdGUpIHtcbiAgICAgICRlbC5hZGRDbGFzcygndG9vbGJhci10cmFuc2l0aW9uaW5nJyk7XG4gICAgICAkZWwudHJhbnNpdGlvbkVuZCgoKSA9PiB7XG4gICAgICAgICRlbC5yZW1vdmVDbGFzcygndG9vbGJhci10cmFuc2l0aW9uaW5nJyk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgJGVsLnJlbW92ZUNsYXNzKCd0b29sYmFyLWhpZGRlbicpO1xuICB9LFxuICBpbml0SGlkZVRvb2xiYXJPblNjcm9sbChwYWdlRWwpIHtcbiAgICBjb25zdCBhcHAgPSB0aGlzO1xuICAgIGNvbnN0ICRwYWdlRWwgPSAkKHBhZ2VFbCk7XG4gICAgbGV0ICR0b29sYmFyRWwgPSAkcGFnZUVsLnBhcmVudHMoJy52aWV3JykuY2hpbGRyZW4oJy50b29sYmFyJyk7XG4gICAgaWYgKCR0b29sYmFyRWwubGVuZ3RoID09PSAwKSB7XG4gICAgICAkdG9vbGJhckVsID0gJHBhZ2VFbC5maW5kKCcudG9vbGJhcicpO1xuICAgIH1cbiAgICBpZiAoJHRvb2xiYXJFbC5sZW5ndGggPT09IDApIHtcbiAgICAgICR0b29sYmFyRWwgPSAkcGFnZUVsLnBhcmVudHMoJy52aWV3cycpLmNoaWxkcmVuKCcudGFiYmFyLCAudGFiYmFyLWxhYmVscycpO1xuICAgIH1cbiAgICBpZiAoJHRvb2xiYXJFbC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgcHJldmlvdXNTY3JvbGxUb3A7XG4gICAgbGV0IGN1cnJlbnRTY3JvbGxUb3A7XG5cbiAgICBsZXQgc2Nyb2xsSGVpZ2h0O1xuICAgIGxldCBvZmZzZXRIZWlnaHQ7XG4gICAgbGV0IHJlYWNoRW5kO1xuICAgIGxldCBhY3Rpb247XG4gICAgbGV0IHRvb2xiYXJIaWRkZW47XG4gICAgZnVuY3Rpb24gaGFuZGxlU2Nyb2xsKCkge1xuICAgICAgY29uc3Qgc2Nyb2xsQ29udGVudCA9IHRoaXM7XG4gICAgICBpZiAoJHBhZ2VFbC5oYXNDbGFzcygncGFnZS1wcmV2aW91cycpKSByZXR1cm47XG4gICAgICBjdXJyZW50U2Nyb2xsVG9wID0gc2Nyb2xsQ29udGVudC5zY3JvbGxUb3A7XG4gICAgICBzY3JvbGxIZWlnaHQgPSBzY3JvbGxDb250ZW50LnNjcm9sbEhlaWdodDtcbiAgICAgIG9mZnNldEhlaWdodCA9IHNjcm9sbENvbnRlbnQub2Zmc2V0SGVpZ2h0O1xuICAgICAgcmVhY2hFbmQgPSBjdXJyZW50U2Nyb2xsVG9wICsgb2Zmc2V0SGVpZ2h0ID49IHNjcm9sbEhlaWdodDtcbiAgICAgIHRvb2xiYXJIaWRkZW4gPSAkdG9vbGJhckVsLmhhc0NsYXNzKCd0b29sYmFyLWhpZGRlbicpO1xuXG4gICAgICBpZiAocmVhY2hFbmQpIHtcbiAgICAgICAgaWYgKGFwcC5wYXJhbXMudG9vbGJhci5zaG93T25QYWdlU2Nyb2xsRW5kKSB7XG4gICAgICAgICAgYWN0aW9uID0gJ3Nob3cnO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHByZXZpb3VzU2Nyb2xsVG9wID4gY3VycmVudFNjcm9sbFRvcCkge1xuICAgICAgICBpZiAoYXBwLnBhcmFtcy50b29sYmFyLnNob3dPblBhZ2VTY3JvbGxUb3AgfHwgY3VycmVudFNjcm9sbFRvcCA8PSA0NCkge1xuICAgICAgICAgIGFjdGlvbiA9ICdzaG93JztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhY3Rpb24gPSAnaGlkZSc7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY3VycmVudFNjcm9sbFRvcCA+IDQ0KSB7XG4gICAgICAgIGFjdGlvbiA9ICdoaWRlJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFjdGlvbiA9ICdzaG93JztcbiAgICAgIH1cblxuICAgICAgaWYgKGFjdGlvbiA9PT0gJ3Nob3cnICYmIHRvb2xiYXJIaWRkZW4pIHtcbiAgICAgICAgYXBwLnRvb2xiYXIuc2hvdygkdG9vbGJhckVsKTtcbiAgICAgICAgdG9vbGJhckhpZGRlbiA9IGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChhY3Rpb24gPT09ICdoaWRlJyAmJiAhdG9vbGJhckhpZGRlbikge1xuICAgICAgICBhcHAudG9vbGJhci5oaWRlKCR0b29sYmFyRWwpO1xuICAgICAgICB0b29sYmFySGlkZGVuID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcHJldmlvdXNTY3JvbGxUb3AgPSBjdXJyZW50U2Nyb2xsVG9wO1xuICAgIH1cbiAgICAkcGFnZUVsLm9uKCdzY3JvbGwnLCAnLnBhZ2UtY29udGVudCcsIGhhbmRsZVNjcm9sbCwgdHJ1ZSk7XG4gICAgJHBhZ2VFbFswXS5mN1Njcm9sbFRvb2xiYXJIYW5kbGVyID0gaGFuZGxlU2Nyb2xsO1xuICB9LFxufTtcbnZhciBUb29sYmFyJDEgPSB7XG4gIG5hbWU6ICd0b29sYmFyJyxcbiAgY3JlYXRlKCkge1xuICAgIGNvbnN0IGFwcCA9IHRoaXM7XG4gICAgVXRpbHMuZXh0ZW5kKGFwcCwge1xuICAgICAgdG9vbGJhcjoge1xuICAgICAgICBoaWRlOiBUb29sYmFyLmhpZGUuYmluZChhcHApLFxuICAgICAgICBzaG93OiBUb29sYmFyLnNob3cuYmluZChhcHApLFxuICAgICAgICBzZXRIaWdobGlnaHQ6IFRvb2xiYXIuc2V0SGlnaGxpZ2h0LmJpbmQoYXBwKSxcbiAgICAgICAgaW5pdEhpZGVUb29sYmFyT25TY3JvbGw6IFRvb2xiYXIuaW5pdEhpZGVUb29sYmFyT25TY3JvbGwuYmluZChhcHApLFxuICAgICAgICBpbml0OiBUb29sYmFyLmluaXQuYmluZChhcHApLFxuICAgICAgfSxcbiAgICB9KTtcbiAgfSxcbiAgcGFyYW1zOiB7XG4gICAgdG9vbGJhcjoge1xuICAgICAgaGlkZU9uUGFnZVNjcm9sbDogZmFsc2UsXG4gICAgICBzaG93T25QYWdlU2Nyb2xsRW5kOiB0cnVlLFxuICAgICAgc2hvd09uUGFnZVNjcm9sbFRvcDogdHJ1ZSxcbiAgICB9LFxuICB9LFxuICBvbjoge1xuICAgIHBhZ2VCZWZvcmVSZW1vdmUocGFnZSkge1xuICAgICAgaWYgKHBhZ2UuJGVsWzBdLmY3U2Nyb2xsVG9vbGJhckhhbmRsZXIpIHtcbiAgICAgICAgcGFnZS4kZWwub2ZmKCdzY3JvbGwnLCAnLnBhZ2UtY29udGVudCcsIHBhZ2UuJGVsWzBdLmY3U2Nyb2xsVG9vbGJhckhhbmRsZXIsIHRydWUpO1xuICAgICAgfVxuICAgIH0sXG4gICAgcGFnZUJlZm9yZUluKHBhZ2UpIHtcbiAgICAgIGNvbnN0IGFwcCA9IHRoaXM7XG4gICAgICBsZXQgJHRvb2xiYXJFbCA9IHBhZ2UuJGVsLnBhcmVudHMoJy52aWV3JykuY2hpbGRyZW4oJy50b29sYmFyJyk7XG4gICAgICBpZiAoJHRvb2xiYXJFbC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgJHRvb2xiYXJFbCA9IHBhZ2UuJGVsLmZpbmQoJy50b29sYmFyJyk7XG4gICAgICB9XG4gICAgICBpZiAoJHRvb2xiYXJFbC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgJHRvb2xiYXJFbCA9IHBhZ2UuJGVsLnBhcmVudHMoJy52aWV3cycpLmNoaWxkcmVuKCcudGFiYmFyLCAudGFiYmFyLWxhYmVscycpO1xuICAgICAgfVxuICAgICAgaWYgKCR0b29sYmFyRWwubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChwYWdlLiRlbC5oYXNDbGFzcygnbm8tdG9vbGJhcicpKSB7XG4gICAgICAgIGFwcC50b29sYmFyLmhpZGUoJHRvb2xiYXJFbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhcHAudG9vbGJhci5zaG93KCR0b29sYmFyRWwpO1xuICAgICAgfVxuICAgIH0sXG4gICAgcGFnZUluaXQocGFnZSkge1xuICAgICAgY29uc3QgYXBwID0gdGhpcztcbiAgICAgIHBhZ2UuJGVsLmZpbmQoJy50YWJiYXIsIC50YWJiYXItbGFiZWxzJykuZWFjaCgoaW5kZXgsIHRhYmJhckVsKSA9PiB7XG4gICAgICAgIGFwcC50b29sYmFyLmluaXQodGFiYmFyRWwpO1xuICAgICAgfSk7XG4gICAgICBpZiAoXG4gICAgICAgIGFwcC5wYXJhbXMudG9vbGJhci5oaWRlT25QYWdlU2Nyb2xsIHx8XG4gICAgICAgIHBhZ2UuJGVsLmZpbmQoJy5oaWRlLXRvb2xiYXItb24tc2Nyb2xsJykubGVuZ3RoIHx8XG4gICAgICAgIHBhZ2UuJGVsLmhhc0NsYXNzKCdoaWRlLXRvb2xiYXItb24tc2Nyb2xsJykgfHxcbiAgICAgICAgcGFnZS4kZWwuZmluZCgnLmhpZGUtYmFycy1vbi1zY3JvbGwnKS5sZW5ndGggfHxcbiAgICAgICAgcGFnZS4kZWwuaGFzQ2xhc3MoJ2hpZGUtYmFycy1vbi1zY3JvbGwnKVxuICAgICAgKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBwYWdlLiRlbC5maW5kKCcua2VlcC10b29sYmFyLW9uLXNjcm9sbCcpLmxlbmd0aCB8fFxuICAgICAgICAgIHBhZ2UuJGVsLmhhc0NsYXNzKCdrZWVwLXRvb2xiYXItb24tc2Nyb2xsJykgfHxcbiAgICAgICAgICBwYWdlLiRlbC5maW5kKCcua2VlcC1iYXJzLW9uLXNjcm9sbCcpLmxlbmd0aCB8fFxuICAgICAgICAgIHBhZ2UuJGVsLmhhc0NsYXNzKCdrZWVwLWJhcnMtb24tc2Nyb2xsJylcbiAgICAgICAgKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGFwcC50b29sYmFyLmluaXRIaWRlVG9vbGJhck9uU2Nyb2xsKHBhZ2UuZWwpO1xuICAgICAgfVxuICAgIH0sXG4gICAgaW5pdCgpIHtcbiAgICAgIGNvbnN0IGFwcCA9IHRoaXM7XG4gICAgICBhcHAucm9vdC5maW5kKCcudGFiYmFyLCAudGFiYmFyLWxhYmVscycpLmVhY2goKGluZGV4LCB0YWJiYXJFbCkgPT4ge1xuICAgICAgICBhcHAudG9vbGJhci5pbml0KHRhYmJhckVsKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gIH0sXG59O1xuXG52YXIgU3VibmF2YmFyID0ge1xuICBuYW1lOiAnc3VibmF2YmFyJyxcbiAgb246IHtcbiAgICBwYWdlSW5pdChwYWdlKSB7XG4gICAgICBpZiAocGFnZS4kbmF2YmFyRWwgJiYgcGFnZS4kbmF2YmFyRWwubGVuZ3RoICYmIHBhZ2UuJG5hdmJhckVsLmZpbmQoJy5zdWJuYXZiYXInKS5sZW5ndGgpIHtcbiAgICAgICAgcGFnZS4kZWwuYWRkQ2xhc3MoJ3BhZ2Utd2l0aC1zdWJuYXZiYXInKTtcbiAgICAgIH1cbiAgICAgIGlmIChwYWdlLiRlbC5maW5kKCcuc3VibmF2YmFyJykubGVuZ3RoKSB7XG4gICAgICAgIHBhZ2UuJGVsLmFkZENsYXNzKCdwYWdlLXdpdGgtc3VibmF2YmFyJyk7XG4gICAgICB9XG4gICAgfSxcbiAgfSxcbn07XG5cbmNsYXNzIFRvdWNoUmlwcGxlIHtcbiAgY29uc3RydWN0b3IoJGVsLCB4LCB5KSB7XG4gICAgY29uc3QgcmlwcGxlID0gdGhpcztcbiAgICBpZiAoISRlbCkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBjb25zdCBib3ggPSAkZWxbMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgY29uc3QgY2VudGVyID0ge1xuICAgICAgeDogeCAtIGJveC5sZWZ0LFxuICAgICAgeTogeSAtIGJveC50b3AsXG4gICAgfTtcbiAgICBjb25zdCB3aWR0aCA9IGJveC53aWR0aDtcbiAgICBjb25zdCBoZWlnaHQgPSBib3guaGVpZ2h0O1xuICAgIGNvbnN0IGRpYW1ldGVyID0gTWF0aC5tYXgoKCgoaGVpZ2h0ICoqIDIpICsgKHdpZHRoICoqIDIpKSAqKiAwLjUpLCA0OCk7XG5cbiAgICByaXBwbGUuJHJpcHBsZVdhdmVFbCA9ICQoYDxkaXYgY2xhc3M9XCJyaXBwbGUtd2F2ZVwiIHN0eWxlPVwid2lkdGg6ICR7ZGlhbWV0ZXJ9cHg7IGhlaWdodDogJHtkaWFtZXRlcn1weDsgbWFyZ2luLXRvcDotJHtkaWFtZXRlciAvIDJ9cHg7IG1hcmdpbi1sZWZ0Oi0ke2RpYW1ldGVyIC8gMn1weDsgbGVmdDoke2NlbnRlci54fXB4OyB0b3A6JHtjZW50ZXIueX1weDtcIj48L2Rpdj5gKTtcblxuICAgICRlbC5wcmVwZW5kKHJpcHBsZS4kcmlwcGxlV2F2ZUVsKTtcblxuICAgIC8qIGVzbGludCBuby11bmRlcnNjb3JlLWRhbmdsZTogW1wiZXJyb3JcIiwgeyBcImFsbG93XCI6IFtcIl9jbGllbnRMZWZ0XCJdIH1dICovXG4gICAgcmlwcGxlLl9jbGllbnRMZWZ0ID0gcmlwcGxlLiRyaXBwbGVXYXZlRWxbMF0uY2xpZW50TGVmdDtcblxuICAgIHJpcHBsZS5yaXBwbGVUcmFuc2Zvcm0gPSBgdHJhbnNsYXRlM2QoJHstY2VudGVyLnggKyAod2lkdGggLyAyKX1weCwgJHstY2VudGVyLnkgKyAoaGVpZ2h0IC8gMil9cHgsIDApIHNjYWxlKDEpYDtcblxuICAgIHJpcHBsZS4kcmlwcGxlV2F2ZUVsLnRyYW5zZm9ybShyaXBwbGUucmlwcGxlVHJhbnNmb3JtKTtcblxuICAgIHJldHVybiByaXBwbGU7XG4gIH1cbiAgb25SZW1vdmUoKSB7XG4gICAgbGV0IHJpcHBsZSA9IHRoaXM7XG4gICAgcmlwcGxlLiRyaXBwbGVXYXZlRWwucmVtb3ZlKCk7XG4gICAgT2JqZWN0LmtleXMocmlwcGxlKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIHJpcHBsZVtrZXldID0gbnVsbDtcbiAgICAgIGRlbGV0ZSByaXBwbGVba2V5XTtcbiAgICB9KTtcbiAgICByaXBwbGUgPSBudWxsO1xuICB9XG4gIHJlbW92ZSgpIHtcbiAgICBjb25zdCByaXBwbGUgPSB0aGlzO1xuICAgIGlmIChyaXBwbGUucmVtb3ZpbmcpIHJldHVybjtcbiAgICBjb25zdCAkcmlwcGxlV2F2ZUVsID0gdGhpcy4kcmlwcGxlV2F2ZUVsO1xuICAgIGNvbnN0IHJpcHBsZVRyYW5zZm9ybSA9IHRoaXMucmlwcGxlVHJhbnNmb3JtO1xuICAgIGxldCByZW1vdmVUaW1lb3V0ID0gVXRpbHMubmV4dFRpY2soKCkgPT4ge1xuICAgICAgcmlwcGxlLm9uUmVtb3ZlKCk7XG4gICAgfSwgNDAwKTtcbiAgICByaXBwbGUucmVtb3ZpbmcgPSB0cnVlO1xuICAgICRyaXBwbGVXYXZlRWxcbiAgICAgIC5hZGRDbGFzcygncmlwcGxlLXdhdmUtZmlsbCcpXG4gICAgICAudHJhbnNmb3JtKHJpcHBsZVRyYW5zZm9ybS5yZXBsYWNlKCdzY2FsZSgxKScsICdzY2FsZSgxLjAxKScpKVxuICAgICAgLnRyYW5zaXRpb25FbmQoKCkgPT4ge1xuICAgICAgICBjbGVhclRpbWVvdXQocmVtb3ZlVGltZW91dCk7XG4gICAgICAgIFV0aWxzLm5leHRGcmFtZSgoKSA9PiB7XG4gICAgICAgICAgJHJpcHBsZVdhdmVFbFxuICAgICAgICAgICAgLmFkZENsYXNzKCdyaXBwbGUtd2F2ZS1vdXQnKVxuICAgICAgICAgICAgLnRyYW5zZm9ybShyaXBwbGVUcmFuc2Zvcm0ucmVwbGFjZSgnc2NhbGUoMSknLCAnc2NhbGUoMS4wMSknKSk7XG5cbiAgICAgICAgICByZW1vdmVUaW1lb3V0ID0gVXRpbHMubmV4dFRpY2soKCkgPT4ge1xuICAgICAgICAgICAgcmlwcGxlLm9uUmVtb3ZlKCk7XG4gICAgICAgICAgfSwgNzAwKTtcblxuICAgICAgICAgICRyaXBwbGVXYXZlRWwudHJhbnNpdGlvbkVuZCgoKSA9PiB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQocmVtb3ZlVGltZW91dCk7XG4gICAgICAgICAgICByaXBwbGUub25SZW1vdmUoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgfVxufVxuXG52YXIgVG91Y2hSaXBwbGUkMSA9IHtcbiAgbmFtZTogJ3RvdWNoLXJpcHBsZScsXG4gIHN0YXRpYzoge1xuICAgIFRvdWNoUmlwcGxlLFxuICB9LFxuICBjcmVhdGUoKSB7XG4gICAgY29uc3QgYXBwID0gdGhpcztcbiAgICBhcHAudG91Y2hSaXBwbGUgPSB7XG4gICAgICBjcmVhdGUoLi4uYXJncykge1xuICAgICAgICByZXR1cm4gbmV3IFRvdWNoUmlwcGxlKC4uLmFyZ3MpO1xuICAgICAgfSxcbiAgICB9O1xuICB9LFxufTtcblxuY29uc3Qgb3BlbmVkTW9kYWxzID0gW107XG5jb25zdCBkaWFsb2dzUXVldWUgPSBbXTtcbmZ1bmN0aW9uIGNsZWFyRGlhbG9nc1F1ZXVlKCkge1xuICBpZiAoZGlhbG9nc1F1ZXVlLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICBjb25zdCBkaWFsb2cgPSBkaWFsb2dzUXVldWUuc2hpZnQoKTtcbiAgZGlhbG9nLm9wZW4oKTtcbn1cbmNsYXNzIE1vZGFsIGV4dGVuZHMgRnJhbWV3b3JrN0NsYXNzIHtcbiAgY29uc3RydWN0b3IoYXBwLCBwYXJhbXMpIHtcbiAgICBzdXBlcihwYXJhbXMsIFthcHBdKTtcblxuICAgIGNvbnN0IG1vZGFsID0gdGhpcztcblxuICAgIGNvbnN0IGRlZmF1bHRzID0ge307XG5cbiAgICAvLyBFeHRlbmQgZGVmYXVsdHMgd2l0aCBtb2R1bGVzIHBhcmFtc1xuICAgIG1vZGFsLnVzZU1vZHVsZXNQYXJhbXMoZGVmYXVsdHMpO1xuXG4gICAgbW9kYWwucGFyYW1zID0gVXRpbHMuZXh0ZW5kKGRlZmF1bHRzLCBwYXJhbXMpO1xuXG4gICAgLy8gSW5zdGFsbCBNb2R1bGVzXG4gICAgbW9kYWwudXNlTW9kdWxlcygpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgb25PcGVuKCkge1xuICAgIGNvbnN0IG1vZGFsID0gdGhpcztcbiAgICBvcGVuZWRNb2RhbHMucHVzaChtb2RhbCk7XG4gICAgJCgnaHRtbCcpLmFkZENsYXNzKGB3aXRoLW1vZGFsLSR7bW9kYWwudHlwZS50b0xvd2VyQ2FzZSgpfWApO1xuICAgIG1vZGFsLiRlbC50cmlnZ2VyKGBtb2RhbDpvcGVuICR7bW9kYWwudHlwZS50b0xvd2VyQ2FzZSgpfTpvcGVuYCwgbW9kYWwpO1xuICAgIG1vZGFsLmVtaXQoYGxvY2FsOjpvcGVuIG1vZGFsT3BlbiAke21vZGFsLnR5cGV9T3BlbmAsIG1vZGFsKTtcbiAgfVxuICBvbk9wZW5lZCgpIHtcbiAgICBjb25zdCBtb2RhbCA9IHRoaXM7XG4gICAgbW9kYWwuJGVsLnRyaWdnZXIoYG1vZGFsOm9wZW5lZCAke21vZGFsLnR5cGUudG9Mb3dlckNhc2UoKX06b3BlbmVkYCwgbW9kYWwpO1xuICAgIG1vZGFsLmVtaXQoYGxvY2FsOjpvcGVuZWQgbW9kYWxPcGVuZWQgJHttb2RhbC50eXBlfU9wZW5lZGAsIG1vZGFsKTtcbiAgfVxuICBvbkNsb3NlKCkge1xuICAgIGNvbnN0IG1vZGFsID0gdGhpcztcbiAgICBpZiAoIW1vZGFsLnR5cGUgfHwgIW1vZGFsLiRlbCkgcmV0dXJuO1xuICAgIG9wZW5lZE1vZGFscy5zcGxpY2Uob3BlbmVkTW9kYWxzLmluZGV4T2YobW9kYWwpLCAxKTtcbiAgICAkKCdodG1sJykucmVtb3ZlQ2xhc3MoYHdpdGgtbW9kYWwtJHttb2RhbC50eXBlLnRvTG93ZXJDYXNlKCl9YCk7XG4gICAgbW9kYWwuJGVsLnRyaWdnZXIoYG1vZGFsOmNsb3NlICR7bW9kYWwudHlwZS50b0xvd2VyQ2FzZSgpfTpjbG9zZWAsIG1vZGFsKTtcbiAgICBtb2RhbC5lbWl0KGBsb2NhbDo6Y2xvc2UgbW9kYWxDbG9zZSAke21vZGFsLnR5cGV9Q2xvc2VgLCBtb2RhbCk7XG4gIH1cbiAgb25DbG9zZWQoKSB7XG4gICAgY29uc3QgbW9kYWwgPSB0aGlzO1xuICAgIGlmICghbW9kYWwudHlwZSB8fCAhbW9kYWwuJGVsKSByZXR1cm47XG4gICAgbW9kYWwuJGVsLnJlbW92ZUNsYXNzKCdtb2RhbC1vdXQnKTtcbiAgICBtb2RhbC4kZWwuaGlkZSgpO1xuICAgIG1vZGFsLiRlbC50cmlnZ2VyKGBtb2RhbDpjbG9zZWQgJHttb2RhbC50eXBlLnRvTG93ZXJDYXNlKCl9OmNsb3NlZGAsIG1vZGFsKTtcbiAgICBtb2RhbC5lbWl0KGBsb2NhbDo6Y2xvc2VkIG1vZGFsQ2xvc2VkICR7bW9kYWwudHlwZX1DbG9zZWRgLCBtb2RhbCk7XG4gIH1cbiAgb3BlbihhbmltYXRlTW9kYWwpIHtcbiAgICBjb25zdCBtb2RhbCA9IHRoaXM7XG4gICAgY29uc3QgYXBwID0gbW9kYWwuYXBwO1xuICAgIGNvbnN0ICRlbCA9IG1vZGFsLiRlbDtcbiAgICBjb25zdCAkYmFja2Ryb3BFbCA9IG1vZGFsLiRiYWNrZHJvcEVsO1xuICAgIGNvbnN0IHR5cGUgPSBtb2RhbC50eXBlO1xuICAgIGxldCBhbmltYXRlID0gdHJ1ZTtcbiAgICBpZiAodHlwZW9mIGFuaW1hdGVNb2RhbCAhPT0gJ3VuZGVmaW5lZCcpIGFuaW1hdGUgPSBhbmltYXRlTW9kYWw7XG4gICAgZWxzZSBpZiAodHlwZW9mIG1vZGFsLnBhcmFtcy5hbmltYXRlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgYW5pbWF0ZSA9IG1vZGFsLnBhcmFtcy5hbmltYXRlO1xuICAgIH1cblxuICAgIGlmICghJGVsIHx8ICRlbC5oYXNDbGFzcygnbW9kYWwtaW4nKSkge1xuICAgICAgcmV0dXJuIG1vZGFsO1xuICAgIH1cblxuICAgIGlmICh0eXBlID09PSAnZGlhbG9nJyAmJiBhcHAucGFyYW1zLm1vZGFsLnF1ZXVlRGlhbG9ncykge1xuICAgICAgbGV0IHB1c2hUb1F1ZXVlO1xuICAgICAgaWYgKCQoJy5kaWFsb2cubW9kYWwtaW4nKS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHB1c2hUb1F1ZXVlID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAob3BlbmVkTW9kYWxzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgb3BlbmVkTW9kYWxzLmZvckVhY2goKG9wZW5lZE1vZGFsKSA9PiB7XG4gICAgICAgICAgaWYgKG9wZW5lZE1vZGFsLnR5cGUgPT09ICdkaWFsb2cnKSBwdXNoVG9RdWV1ZSA9IHRydWU7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKHB1c2hUb1F1ZXVlKSB7XG4gICAgICAgIGRpYWxvZ3NRdWV1ZS5wdXNoKG1vZGFsKTtcbiAgICAgICAgcmV0dXJuIG1vZGFsO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0ICRtb2RhbFBhcmVudEVsID0gJGVsLnBhcmVudCgpO1xuICAgIGNvbnN0IHdhc0luRG9tID0gJGVsLnBhcmVudHMoZG9jdW1lbnQpLmxlbmd0aCA+IDA7XG4gICAgaWYgKGFwcC5wYXJhbXMubW9kYWwubW92ZVRvUm9vdCAmJiAhJG1vZGFsUGFyZW50RWwuaXMoYXBwLnJvb3QpKSB7XG4gICAgICBhcHAucm9vdC5hcHBlbmQoJGVsKTtcbiAgICAgIG1vZGFsLm9uY2UoYCR7dHlwZX1DbG9zZWRgLCAoKSA9PiB7XG4gICAgICAgIGlmICh3YXNJbkRvbSkge1xuICAgICAgICAgICRtb2RhbFBhcmVudEVsLmFwcGVuZCgkZWwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICRlbC5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIC8vIFNob3cgTW9kYWxcbiAgICAkZWwuc2hvdygpO1xuXG4gICAgLy8gU2V0IERpYWxvZyBvZmZzZXRcbiAgICBpZiAodHlwZSA9PT0gJ2RpYWxvZycpIHtcbiAgICAgICRlbC5jc3Moe1xuICAgICAgICBtYXJnaW5Ub3A6IGAkey1NYXRoLnJvdW5kKCRlbC5vdXRlckhlaWdodCgpIC8gMil9cHhgLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gRW1pdCBvcGVuXG4gICAgLyogZXNsaW50IG5vLXVuZGVyc2NvcmUtZGFuZ2xlOiBbXCJlcnJvclwiLCB7IFwiYWxsb3dcIjogW1wiX2NsaWVudExlZnRcIl0gfV0gKi9cbiAgICBtb2RhbC5fY2xpZW50TGVmdCA9ICRlbFswXS5jbGllbnRMZWZ0O1xuXG4gICAgLy8gQmFja2Ryb3BcbiAgICBpZiAoJGJhY2tkcm9wRWwpIHtcbiAgICAgICRiYWNrZHJvcEVsW2FuaW1hdGUgPyAncmVtb3ZlQ2xhc3MnIDogJ2FkZENsYXNzJ10oJ25vdC1hbmltYXRlZCcpO1xuICAgICAgJGJhY2tkcm9wRWwuYWRkQ2xhc3MoJ2JhY2tkcm9wLWluJyk7XG4gICAgfVxuICAgIC8vIE1vZGFsXG4gICAgZnVuY3Rpb24gdHJhbnNpdGlvbkVuZCgpIHtcbiAgICAgIGlmICgkZWwuaGFzQ2xhc3MoJ21vZGFsLW91dCcpKSB7XG4gICAgICAgIG1vZGFsLm9uQ2xvc2VkKCk7XG4gICAgICB9IGVsc2UgaWYgKCRlbC5oYXNDbGFzcygnbW9kYWwtaW4nKSkge1xuICAgICAgICBtb2RhbC5vbk9wZW5lZCgpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYW5pbWF0ZSkge1xuICAgICAgJGVsXG4gICAgICAgIC5hbmltYXRpb25FbmQoKCkgPT4ge1xuICAgICAgICAgIHRyYW5zaXRpb25FbmQoKTtcbiAgICAgICAgfSk7XG4gICAgICAkZWxcbiAgICAgICAgLnRyYW5zaXRpb25FbmQoKCkgPT4ge1xuICAgICAgICAgIHRyYW5zaXRpb25FbmQoKTtcbiAgICAgICAgfSk7XG4gICAgICAkZWxcbiAgICAgICAgLnJlbW92ZUNsYXNzKCdtb2RhbC1vdXQgbm90LWFuaW1hdGVkJylcbiAgICAgICAgLmFkZENsYXNzKCdtb2RhbC1pbicpO1xuICAgICAgbW9kYWwub25PcGVuKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICRlbC5yZW1vdmVDbGFzcygnbW9kYWwtb3V0JykuYWRkQ2xhc3MoJ21vZGFsLWluIG5vdC1hbmltYXRlZCcpO1xuICAgICAgbW9kYWwub25PcGVuKCk7XG4gICAgICBtb2RhbC5vbk9wZW5lZCgpO1xuICAgIH1cblxuICAgIHJldHVybiBtb2RhbDtcbiAgfVxuICBjbG9zZShhbmltYXRlTW9kYWwpIHtcbiAgICBjb25zdCBtb2RhbCA9IHRoaXM7XG4gICAgY29uc3QgJGVsID0gbW9kYWwuJGVsO1xuICAgIGNvbnN0ICRiYWNrZHJvcEVsID0gbW9kYWwuJGJhY2tkcm9wRWw7XG5cbiAgICBsZXQgYW5pbWF0ZSA9IHRydWU7XG4gICAgaWYgKHR5cGVvZiBhbmltYXRlTW9kYWwgIT09ICd1bmRlZmluZWQnKSBhbmltYXRlID0gYW5pbWF0ZU1vZGFsO1xuICAgIGVsc2UgaWYgKHR5cGVvZiBtb2RhbC5wYXJhbXMuYW5pbWF0ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGFuaW1hdGUgPSBtb2RhbC5wYXJhbXMuYW5pbWF0ZTtcbiAgICB9XG5cbiAgICBpZiAoISRlbCB8fCAhJGVsLmhhc0NsYXNzKCdtb2RhbC1pbicpKSB7XG4gICAgICByZXR1cm4gbW9kYWw7XG4gICAgfVxuXG4gICAgLy8gYmFja2Ryb3BcbiAgICBpZiAoJGJhY2tkcm9wRWwpIHtcbiAgICAgICRiYWNrZHJvcEVsW2FuaW1hdGUgPyAncmVtb3ZlQ2xhc3MnIDogJ2FkZENsYXNzJ10oJ25vdC1hbmltYXRlZCcpO1xuICAgICAgJGJhY2tkcm9wRWwucmVtb3ZlQ2xhc3MoJ2JhY2tkcm9wLWluJyk7XG4gICAgfVxuXG4gICAgLy8gTW9kYWxcbiAgICAkZWxbYW5pbWF0ZSA/ICdyZW1vdmVDbGFzcycgOiAnYWRkQ2xhc3MnXSgnbm90LWFuaW1hdGVkJyk7XG4gICAgZnVuY3Rpb24gdHJhbnNpdGlvbkVuZCgpIHtcbiAgICAgIGlmICgkZWwuaGFzQ2xhc3MoJ21vZGFsLW91dCcpKSB7XG4gICAgICAgIG1vZGFsLm9uQ2xvc2VkKCk7XG4gICAgICB9IGVsc2UgaWYgKCRlbC5oYXNDbGFzcygnbW9kYWwtaW4nKSkge1xuICAgICAgICBtb2RhbC5vbk9wZW5lZCgpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYW5pbWF0ZSkge1xuICAgICAgJGVsXG4gICAgICAgIC5hbmltYXRpb25FbmQoKCkgPT4ge1xuICAgICAgICAgIHRyYW5zaXRpb25FbmQoKTtcbiAgICAgICAgfSk7XG4gICAgICAkZWxcbiAgICAgICAgLnRyYW5zaXRpb25FbmQoKCkgPT4ge1xuICAgICAgICAgIHRyYW5zaXRpb25FbmQoKTtcbiAgICAgICAgfSk7XG4gICAgICAkZWxcbiAgICAgICAgLnJlbW92ZUNsYXNzKCdtb2RhbC1pbicpXG4gICAgICAgIC5hZGRDbGFzcygnbW9kYWwtb3V0Jyk7XG4gICAgICAvLyBFbWl0IGNsb3NlXG4gICAgICBtb2RhbC5vbkNsb3NlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICRlbFxuICAgICAgICAuYWRkQ2xhc3MoJ25vdC1hbmltYXRlZCcpXG4gICAgICAgIC5yZW1vdmVDbGFzcygnbW9kYWwtaW4nKVxuICAgICAgICAuYWRkQ2xhc3MoJ21vZGFsLW91dCcpO1xuICAgICAgLy8gRW1pdCBjbG9zZVxuICAgICAgbW9kYWwub25DbG9zZSgpO1xuICAgICAgbW9kYWwub25DbG9zZWQoKTtcbiAgICB9XG5cbiAgICBpZiAobW9kYWwudHlwZSA9PT0gJ2RpYWxvZycpIHtcbiAgICAgIGNsZWFyRGlhbG9nc1F1ZXVlKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1vZGFsO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgY29uc3QgbW9kYWwgPSB0aGlzO1xuICAgIGlmIChtb2RhbC5kZXN0cm95ZWQpIHJldHVybjtcbiAgICBtb2RhbC5lbWl0KGBsb2NhbDo6YmVmb3JlRGVzdHJveSBtb2RhbEJlZm9yZURlc3Ryb3kgJHttb2RhbC50eXBlfUJlZm9yZURlc3Ryb3lgLCBtb2RhbCk7XG4gICAgaWYgKG1vZGFsLiRlbCkge1xuICAgICAgbW9kYWwuJGVsLnRyaWdnZXIoYG1vZGFsOmJlZm9yZWRlc3Ryb3kgJHttb2RhbC50eXBlLnRvTG93ZXJDYXNlKCl9OmJlZm9yZWRlc3Ryb3lgLCBtb2RhbCk7XG4gICAgICBpZiAobW9kYWwuJGVsLmxlbmd0aCAmJiBtb2RhbC4kZWxbMF0uZjdNb2RhbCkge1xuICAgICAgICBkZWxldGUgbW9kYWwuJGVsWzBdLmY3TW9kYWw7XG4gICAgICB9XG4gICAgfVxuICAgIFV0aWxzLmRlbGV0ZVByb3BzKG1vZGFsKTtcbiAgICBtb2RhbC5kZXN0cm95ZWQgPSB0cnVlO1xuICB9XG59XG5cbmNsYXNzIEN1c3RvbU1vZGFsIGV4dGVuZHMgTW9kYWwge1xuICBjb25zdHJ1Y3RvcihhcHAsIHBhcmFtcykge1xuICAgIGNvbnN0IGV4dGVuZGVkUGFyYW1zID0gVXRpbHMuZXh0ZW5kKHtcbiAgICAgIGJhY2tkcm9wOiB0cnVlLFxuICAgICAgY2xvc2VCeUJhY2tkcm9wQ2xpY2s6IHRydWUsXG4gICAgICBvbjoge30sXG4gICAgfSwgcGFyYW1zKTtcblxuICAgIC8vIEV4dGVuZHMgd2l0aCBvcGVuL2Nsb3NlIE1vZGFsIG1ldGhvZHM7XG4gICAgc3VwZXIoYXBwLCBleHRlbmRlZFBhcmFtcyk7XG5cbiAgICBjb25zdCBjdXN0b21Nb2RhbCA9IHRoaXM7XG5cbiAgICBjdXN0b21Nb2RhbC5wYXJhbXMgPSBleHRlbmRlZFBhcmFtcztcblxuICAgIC8vIEZpbmQgRWxlbWVudFxuICAgIGxldCAkZWw7XG4gICAgaWYgKCFjdXN0b21Nb2RhbC5wYXJhbXMuZWwpIHtcbiAgICAgICRlbCA9ICQoY3VzdG9tTW9kYWwucGFyYW1zLmNvbnRlbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAkZWwgPSAkKGN1c3RvbU1vZGFsLnBhcmFtcy5lbCk7XG4gICAgfVxuXG4gICAgaWYgKCRlbCAmJiAkZWwubGVuZ3RoID4gMCAmJiAkZWxbMF0uZjdNb2RhbCkge1xuICAgICAgcmV0dXJuICRlbFswXS5mN01vZGFsO1xuICAgIH1cblxuICAgIGlmICgkZWwubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gY3VzdG9tTW9kYWwuZGVzdHJveSgpO1xuICAgIH1cbiAgICBsZXQgJGJhY2tkcm9wRWw7XG4gICAgaWYgKGN1c3RvbU1vZGFsLnBhcmFtcy5iYWNrZHJvcCkge1xuICAgICAgJGJhY2tkcm9wRWwgPSBhcHAucm9vdC5jaGlsZHJlbignLmN1c3RvbS1tb2RhbC1iYWNrZHJvcCcpO1xuICAgICAgaWYgKCRiYWNrZHJvcEVsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAkYmFja2Ryb3BFbCA9ICQoJzxkaXYgY2xhc3M9XCJjdXN0b20tbW9kYWwtYmFja2Ryb3BcIj48L2Rpdj4nKTtcbiAgICAgICAgYXBwLnJvb3QuYXBwZW5kKCRiYWNrZHJvcEVsKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVDbGljayhlKSB7XG4gICAgICBpZiAoIWN1c3RvbU1vZGFsIHx8IGN1c3RvbU1vZGFsLmRlc3Ryb3llZCkgcmV0dXJuO1xuICAgICAgaWYgKCRiYWNrZHJvcEVsICYmIGUudGFyZ2V0ID09PSAkYmFja2Ryb3BFbFswXSkge1xuICAgICAgICBjdXN0b21Nb2RhbC5jbG9zZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGN1c3RvbU1vZGFsLm9uKCdjdXN0b21Nb2RhbE9wZW5lZCcsICgpID0+IHtcbiAgICAgIGlmIChjdXN0b21Nb2RhbC5wYXJhbXMuY2xvc2VCeUJhY2tkcm9wQ2xpY2sgJiYgY3VzdG9tTW9kYWwucGFyYW1zLmJhY2tkcm9wKSB7XG4gICAgICAgIGFwcC5vbignY2xpY2snLCBoYW5kbGVDbGljayk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgY3VzdG9tTW9kYWwub24oJ2N1c3RvbU1vZGFsQ2xvc2UnLCAoKSA9PiB7XG4gICAgICBpZiAoY3VzdG9tTW9kYWwucGFyYW1zLmNsb3NlQnlCYWNrZHJvcENsaWNrICYmIGN1c3RvbU1vZGFsLnBhcmFtcy5iYWNrZHJvcCkge1xuICAgICAgICBhcHAub2ZmKCdjbGljaycsIGhhbmRsZUNsaWNrKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIFV0aWxzLmV4dGVuZChjdXN0b21Nb2RhbCwge1xuICAgICAgYXBwLFxuICAgICAgJGVsLFxuICAgICAgZWw6ICRlbFswXSxcbiAgICAgICRiYWNrZHJvcEVsLFxuICAgICAgYmFja2Ryb3BFbDogJGJhY2tkcm9wRWwgJiYgJGJhY2tkcm9wRWxbMF0sXG4gICAgICB0eXBlOiAnY3VzdG9tTW9kYWwnLFxuICAgIH0pO1xuXG4gICAgJGVsWzBdLmY3TW9kYWwgPSBjdXN0b21Nb2RhbDtcblxuICAgIHJldHVybiBjdXN0b21Nb2RhbDtcbiAgfVxufVxuXG52YXIgTW9kYWwkMSA9IHtcbiAgbmFtZTogJ21vZGFsJyxcbiAgc3RhdGljOiB7XG4gICAgTW9kYWwsXG4gICAgQ3VzdG9tTW9kYWwsXG4gIH0sXG4gIGNyZWF0ZSgpIHtcbiAgICBjb25zdCBhcHAgPSB0aGlzO1xuICAgIGFwcC5jdXN0b21Nb2RhbCA9IHtcbiAgICAgIGNyZWF0ZShwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDdXN0b21Nb2RhbChhcHAsIHBhcmFtcyk7XG4gICAgICB9LFxuICAgIH07XG4gIH0sXG4gIHBhcmFtczoge1xuICAgIG1vZGFsOiB7XG4gICAgICBtb3ZlVG9Sb290OiB0cnVlLFxuICAgICAgcXVldWVEaWFsb2dzOiB0cnVlLFxuICAgIH0sXG4gIH0sXG59O1xuXG5jbGFzcyBEaWFsb2cgZXh0ZW5kcyBNb2RhbCB7XG4gIGNvbnN0cnVjdG9yKGFwcCwgcGFyYW1zKSB7XG4gICAgY29uc3QgZXh0ZW5kZWRQYXJhbXMgPSBVdGlscy5leHRlbmQoe1xuICAgICAgdGl0bGU6IGFwcC5wYXJhbXMuZGlhbG9nLnRpdGxlLFxuICAgICAgdGV4dDogdW5kZWZpbmVkLFxuICAgICAgY29udGVudDogJycsXG4gICAgICBidXR0b25zOiBbXSxcbiAgICAgIHZlcnRpY2FsQnV0dG9uczogZmFsc2UsXG4gICAgICBvbkNsaWNrOiB1bmRlZmluZWQsXG4gICAgICBjc3NDbGFzczogdW5kZWZpbmVkLFxuICAgICAgZGVzdHJveU9uQ2xvc2U6IGZhbHNlLFxuICAgICAgb246IHt9LFxuICAgIH0sIHBhcmFtcyk7XG4gICAgaWYgKHR5cGVvZiBleHRlbmRlZFBhcmFtcy5jbG9zZUJ5QmFja2Ryb3BDbGljayA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGV4dGVuZGVkUGFyYW1zLmNsb3NlQnlCYWNrZHJvcENsaWNrID0gYXBwLnBhcmFtcy5kaWFsb2cuY2xvc2VCeUJhY2tkcm9wQ2xpY2s7XG4gICAgfVxuXG4gICAgLy8gRXh0ZW5kcyB3aXRoIG9wZW4vY2xvc2UgTW9kYWwgbWV0aG9kcztcbiAgICBzdXBlcihhcHAsIGV4dGVuZGVkUGFyYW1zKTtcblxuICAgIGNvbnN0IGRpYWxvZyA9IHRoaXM7XG5cbiAgICBjb25zdCB7IHRpdGxlLCB0ZXh0LCBjb250ZW50LCBidXR0b25zLCB2ZXJ0aWNhbEJ1dHRvbnMsIGNzc0NsYXNzIH0gPSBleHRlbmRlZFBhcmFtcztcblxuICAgIGRpYWxvZy5wYXJhbXMgPSBleHRlbmRlZFBhcmFtcztcblxuICAgIC8vIEZpbmQgRWxlbWVudFxuICAgIGxldCAkZWw7XG4gICAgaWYgKCFkaWFsb2cucGFyYW1zLmVsKSB7XG4gICAgICBjb25zdCBkaWFsb2dDbGFzc2VzID0gWydkaWFsb2cnXTtcbiAgICAgIGlmIChidXR0b25zLmxlbmd0aCA9PT0gMCkgZGlhbG9nQ2xhc3Nlcy5wdXNoKCdkaWFsb2ctbm8tYnV0dG9ucycpO1xuICAgICAgaWYgKGJ1dHRvbnMubGVuZ3RoID4gMCkgZGlhbG9nQ2xhc3Nlcy5wdXNoKGBkaWFsb2ctYnV0dG9ucy0ke2J1dHRvbnMubGVuZ3RofWApO1xuICAgICAgaWYgKHZlcnRpY2FsQnV0dG9ucykgZGlhbG9nQ2xhc3Nlcy5wdXNoKCdkaWFsb2ctYnV0dG9ucy12ZXJ0aWNhbCcpO1xuICAgICAgaWYgKGNzc0NsYXNzKSBkaWFsb2dDbGFzc2VzLnB1c2goY3NzQ2xhc3MpO1xuXG4gICAgICBsZXQgYnV0dG9uc0hUTUwgPSAnJztcbiAgICAgIGlmIChidXR0b25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgYnV0dG9uc0hUTUwgPSBgXG4gICAgICAgICAgPGRpdiBjbGFzcz1cImRpYWxvZy1idXR0b25zXCI+XG4gICAgICAgICAgICAke2J1dHRvbnMubWFwKGJ1dHRvbiA9PiBgXG4gICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiZGlhbG9nLWJ1dHRvbiR7YnV0dG9uLmJvbGQgPyAnIGRpYWxvZy1idXR0b24tYm9sZCcgOiAnJ30ke2J1dHRvbi5jb2xvciA/IGAgY29sb3ItJHtidXR0b24uY29sb3J9YCA6ICcnfSR7YnV0dG9uLmNzc0NsYXNzID8gYCAke2J1dHRvbi5jc3NDbGFzc31gIDogJyd9XCI+JHtidXR0b24udGV4dH08L3NwYW4+XG4gICAgICAgICAgICBgKS5qb2luKCcnKX1cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgYDtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZGlhbG9nSHRtbCA9IGBcbiAgICAgICAgPGRpdiBjbGFzcz1cIiR7ZGlhbG9nQ2xhc3Nlcy5qb2luKCcgJyl9XCI+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cImRpYWxvZy1pbm5lclwiPlxuICAgICAgICAgICAgJHt0aXRsZSA/IGA8ZGl2IGNsYXNzPVwiZGlhbG9nLXRpdGxlXCI+JHt0aXRsZX08L2Rpdj5gIDogJyd9XG4gICAgICAgICAgICAke3RleHQgPyBgPGRpdiBjbGFzcz1cImRpYWxvZy10ZXh0XCI+JHt0ZXh0fTwvZGl2PmAgOiAnJ31cbiAgICAgICAgICAgICR7Y29udGVudH1cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAke2J1dHRvbnNIVE1MfVxuICAgICAgICA8L2Rpdj5cbiAgICAgIGA7XG4gICAgICAkZWwgPSAkKGRpYWxvZ0h0bWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICAkZWwgPSAkKGRpYWxvZy5wYXJhbXMuZWwpO1xuICAgIH1cblxuICAgIGlmICgkZWwgJiYgJGVsLmxlbmd0aCA+IDAgJiYgJGVsWzBdLmY3TW9kYWwpIHtcbiAgICAgIHJldHVybiAkZWxbMF0uZjdNb2RhbDtcbiAgICB9XG5cbiAgICBpZiAoJGVsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGRpYWxvZy5kZXN0cm95KCk7XG4gICAgfVxuXG4gICAgbGV0ICRiYWNrZHJvcEVsID0gYXBwLnJvb3QuY2hpbGRyZW4oJy5kaWFsb2ctYmFja2Ryb3AnKTtcbiAgICBpZiAoJGJhY2tkcm9wRWwubGVuZ3RoID09PSAwKSB7XG4gICAgICAkYmFja2Ryb3BFbCA9ICQoJzxkaXYgY2xhc3M9XCJkaWFsb2ctYmFja2Ryb3BcIj48L2Rpdj4nKTtcbiAgICAgIGFwcC5yb290LmFwcGVuZCgkYmFja2Ryb3BFbCk7XG4gICAgfVxuXG4gICAgLy8gQXNzaWduIGV2ZW50c1xuICAgIGZ1bmN0aW9uIGJ1dHRvbk9uQ2xpY2soZSkge1xuICAgICAgY29uc3QgYnV0dG9uRWwgPSB0aGlzO1xuICAgICAgY29uc3QgaW5kZXggPSAkKGJ1dHRvbkVsKS5pbmRleCgpO1xuICAgICAgY29uc3QgYnV0dG9uID0gYnV0dG9uc1tpbmRleF07XG4gICAgICBpZiAoYnV0dG9uLm9uQ2xpY2spIGJ1dHRvbi5vbkNsaWNrKGRpYWxvZywgZSk7XG4gICAgICBpZiAoZGlhbG9nLnBhcmFtcy5vbkNsaWNrKSBkaWFsb2cucGFyYW1zLm9uQ2xpY2soZGlhbG9nLCBpbmRleCk7XG4gICAgICBpZiAoYnV0dG9uLmNsb3NlICE9PSBmYWxzZSkgZGlhbG9nLmNsb3NlKCk7XG4gICAgfVxuICAgIGxldCBhZGRLZXlib2FyZEhhbmRlcjtcbiAgICBmdW5jdGlvbiBvbktleVByZXNzKGUpIHtcbiAgICAgIGNvbnN0IGtleUNvZGUgPSBlLmtleUNvZGU7XG4gICAgICBidXR0b25zLmZvckVhY2goKGJ1dHRvbiwgaW5kZXgpID0+IHtcbiAgICAgICAgaWYgKGJ1dHRvbi5rZXlDb2RlcyAmJiBidXR0b24ua2V5Q29kZXMuaW5kZXhPZihrZXlDb2RlKSA+PSAwKSB7XG4gICAgICAgICAgaWYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQuYmx1cigpO1xuICAgICAgICAgIGlmIChidXR0b24ub25DbGljaykgYnV0dG9uLm9uQ2xpY2soZGlhbG9nLCBlKTtcbiAgICAgICAgICBpZiAoZGlhbG9nLnBhcmFtcy5vbkNsaWNrKSBkaWFsb2cucGFyYW1zLm9uQ2xpY2soZGlhbG9nLCBpbmRleCk7XG4gICAgICAgICAgaWYgKGJ1dHRvbi5jbG9zZSAhPT0gZmFsc2UpIGRpYWxvZy5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGJ1dHRvbnMgJiYgYnV0dG9ucy5sZW5ndGggPiAwKSB7XG4gICAgICBkaWFsb2cub24oJ29wZW4nLCAoKSA9PiB7XG4gICAgICAgICRlbC5maW5kKCcuZGlhbG9nLWJ1dHRvbicpLmVhY2goKGluZGV4LCBidXR0b25FbCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGJ1dHRvbiA9IGJ1dHRvbnNbaW5kZXhdO1xuICAgICAgICAgIGlmIChidXR0b24ua2V5Q29kZXMpIGFkZEtleWJvYXJkSGFuZGVyID0gdHJ1ZTtcbiAgICAgICAgICAkKGJ1dHRvbkVsKS5vbignY2xpY2snLCBidXR0b25PbkNsaWNrKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBhZGRLZXlib2FyZEhhbmRlciAmJlxuICAgICAgICAgICFhcHAuZGV2aWNlLmlvcyAmJlxuICAgICAgICAgICFhcHAuZGV2aWNlLmFuZHJvaWQgJiZcbiAgICAgICAgICAhYXBwLmRldmljZS5jb3Jkb3ZhXG4gICAgICAgICkge1xuICAgICAgICAgICQoZG9jdW1lbnQpLm9uKCdrZXlkb3duJywgb25LZXlQcmVzcyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgZGlhbG9nLm9uKCdjbG9zZScsICgpID0+IHtcbiAgICAgICAgJGVsLmZpbmQoJy5kaWFsb2ctYnV0dG9uJykuZWFjaCgoaW5kZXgsIGJ1dHRvbkVsKSA9PiB7XG4gICAgICAgICAgJChidXR0b25FbCkub2ZmKCdjbGljaycsIGJ1dHRvbk9uQ2xpY2spO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGFkZEtleWJvYXJkSGFuZGVyICYmXG4gICAgICAgICAgIWFwcC5kZXZpY2UuaW9zICYmXG4gICAgICAgICAgIWFwcC5kZXZpY2UuYW5kcm9pZCAmJlxuICAgICAgICAgICFhcHAuZGV2aWNlLmNvcmRvdmFcbiAgICAgICAgKSB7XG4gICAgICAgICAgJChkb2N1bWVudCkub2ZmKCdrZXlkb3duJywgb25LZXlQcmVzcyk7XG4gICAgICAgIH1cbiAgICAgICAgYWRkS2V5Ym9hcmRIYW5kZXIgPSBmYWxzZTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBVdGlscy5leHRlbmQoZGlhbG9nLCB7XG4gICAgICBhcHAsXG4gICAgICAkZWwsXG4gICAgICBlbDogJGVsWzBdLFxuICAgICAgJGJhY2tkcm9wRWwsXG4gICAgICBiYWNrZHJvcEVsOiAkYmFja2Ryb3BFbFswXSxcbiAgICAgIHR5cGU6ICdkaWFsb2cnLFxuICAgICAgc2V0UHJvZ3Jlc3MocHJvZ3Jlc3MsIGR1cmF0aW9uKSB7XG4gICAgICAgIGFwcC5wcm9ncmVzc2Jhci5zZXQoJGVsLmZpbmQoJy5wcm9ncmVzc2JhcicpLCBwcm9ncmVzcywgZHVyYXRpb24pO1xuICAgICAgICByZXR1cm4gZGlhbG9nO1xuICAgICAgfSxcbiAgICAgIHNldFRleHQobmV3VGV4dCkge1xuICAgICAgICBsZXQgJHRleHRFbCA9ICRlbC5maW5kKCcuZGlhbG9nLXRleHQnKTtcbiAgICAgICAgaWYgKCR0ZXh0RWwubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgJHRleHRFbCA9ICQoJzxkaXYgY2xhc3M9XCJkaWFsb2ctdGV4dFwiPjwvZGl2PicpO1xuICAgICAgICAgIGlmICh0eXBlb2YgdGl0bGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAkdGV4dEVsLmluc2VydEFmdGVyKCRlbC5maW5kKCcuZGlhbG9nLXRpdGxlJykpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAkZWwuZmluZCgnLmRpYWxvZy1pbm5lcicpLnByZXBlbmQoJHRleHRFbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgICR0ZXh0RWwuaHRtbChuZXdUZXh0KTtcbiAgICAgICAgZGlhbG9nLnBhcmFtcy50ZXh0ID0gbmV3VGV4dDtcbiAgICAgICAgcmV0dXJuIGRpYWxvZztcbiAgICAgIH0sXG4gICAgICBzZXRUaXRsZShuZXdUaXRsZSkge1xuICAgICAgICBsZXQgJHRpdGxlRWwgPSAkZWwuZmluZCgnLmRpYWxvZy10aXRsZScpO1xuICAgICAgICBpZiAoJHRpdGxlRWwubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgJHRpdGxlRWwgPSAkKCc8ZGl2IGNsYXNzPVwiZGlhbG9nLXRpdGxlXCI+PC9kaXY+Jyk7XG4gICAgICAgICAgJGVsLmZpbmQoJy5kaWFsb2ctaW5uZXInKS5wcmVwZW5kKCR0aXRsZUVsKTtcbiAgICAgICAgfVxuICAgICAgICAkdGl0bGVFbC5odG1sKG5ld1RpdGxlKTtcbiAgICAgICAgZGlhbG9nLnBhcmFtcy50aXRsZSA9IG5ld1RpdGxlO1xuICAgICAgICByZXR1cm4gZGlhbG9nO1xuICAgICAgfSxcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIGhhbmRsZUNsaWNrKGUpIHtcbiAgICAgIGNvbnN0IHRhcmdldCA9IGUudGFyZ2V0O1xuICAgICAgY29uc3QgJHRhcmdldCA9ICQodGFyZ2V0KTtcbiAgICAgIGlmICgkdGFyZ2V0LmNsb3Nlc3QoZGlhbG9nLmVsKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGRpYWxvZy5wYXJhbXMuY2xvc2VCeUJhY2tkcm9wQ2xpY2sgJiZcbiAgICAgICAgICBkaWFsb2cuYmFja2Ryb3BFbCAmJlxuICAgICAgICAgIGRpYWxvZy5iYWNrZHJvcEVsID09PSB0YXJnZXRcbiAgICAgICAgKSB7XG4gICAgICAgICAgZGlhbG9nLmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBkaWFsb2cub24oJ29wZW5lZCcsICgpID0+IHtcbiAgICAgIGlmIChkaWFsb2cucGFyYW1zLmNsb3NlQnlCYWNrZHJvcENsaWNrKSB7XG4gICAgICAgIGFwcC5vbignY2xpY2snLCBoYW5kbGVDbGljayk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgZGlhbG9nLm9uKCdjbG9zZScsICgpID0+IHtcbiAgICAgIGlmIChkaWFsb2cucGFyYW1zLmNsb3NlQnlCYWNrZHJvcENsaWNrKSB7XG4gICAgICAgIGFwcC5vZmYoJ2NsaWNrJywgaGFuZGxlQ2xpY2spO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgJGVsWzBdLmY3TW9kYWwgPSBkaWFsb2c7XG5cbiAgICBpZiAoZGlhbG9nLnBhcmFtcy5kZXN0cm95T25DbG9zZSkge1xuICAgICAgZGlhbG9nLm9uY2UoJ2Nsb3NlZCcsICgpID0+IHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgZGlhbG9nLmRlc3Ryb3koKTtcbiAgICAgICAgfSwgMCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGlhbG9nO1xuICB9XG59XG5cbmZ1bmN0aW9uIENvbnN0cnVjdG9yTWV0aG9kcyAocGFyYW1ldGVycyA9IHt9KSB7XG4gIGNvbnN0IHtcbiAgICBkZWZhdWx0U2VsZWN0b3IsXG4gICAgY29uc3RydWN0b3IsXG4gICAgZG9tUHJvcCxcbiAgICBhcHAsXG4gICAgYWRkTWV0aG9kcyxcbiAgfSA9IHBhcmFtZXRlcnM7XG4gIGNvbnN0IG1ldGhvZHMgPSB7XG4gICAgY3JlYXRlKC4uLmFyZ3MpIHtcbiAgICAgIGlmIChhcHApIHJldHVybiBuZXcgY29uc3RydWN0b3IoYXBwLCAuLi5hcmdzKTtcbiAgICAgIHJldHVybiBuZXcgY29uc3RydWN0b3IoLi4uYXJncyk7XG4gICAgfSxcbiAgICBnZXQoZWwgPSBkZWZhdWx0U2VsZWN0b3IpIHtcbiAgICAgIGlmIChlbCBpbnN0YW5jZW9mIGNvbnN0cnVjdG9yKSByZXR1cm4gZWw7XG4gICAgICBjb25zdCAkZWwgPSAkKGVsKTtcbiAgICAgIGlmICgkZWwubGVuZ3RoID09PSAwKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuICRlbFswXVtkb21Qcm9wXTtcbiAgICB9LFxuICAgIGRlc3Ryb3koZWwpIHtcbiAgICAgIGNvbnN0IGluc3RhbmNlID0gbWV0aG9kcy5nZXQoZWwpO1xuICAgICAgaWYgKGluc3RhbmNlICYmIGluc3RhbmNlLmRlc3Ryb3kpIHJldHVybiBpbnN0YW5jZS5kZXN0cm95KCk7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0sXG4gIH07XG4gIGlmIChhZGRNZXRob2RzICYmIEFycmF5LmlzQXJyYXkoYWRkTWV0aG9kcykpIHtcbiAgICBhZGRNZXRob2RzLmZvckVhY2goKG1ldGhvZE5hbWUpID0+IHtcbiAgICAgIG1ldGhvZHNbbWV0aG9kTmFtZV0gPSAoZWwgPSBkZWZhdWx0U2VsZWN0b3IsIC4uLmFyZ3MpID0+IHtcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBtZXRob2RzLmdldChlbCk7XG4gICAgICAgIGlmIChpbnN0YW5jZSAmJiBpbnN0YW5jZVttZXRob2ROYW1lXSkgcmV0dXJuIGluc3RhbmNlW21ldGhvZE5hbWVdKC4uLmFyZ3MpO1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gbWV0aG9kcztcbn1cblxuZnVuY3Rpb24gTW9kYWxNZXRob2RzIChwYXJhbWV0ZXJzID0ge30pIHtcbiAgY29uc3QgeyBkZWZhdWx0U2VsZWN0b3IsIGNvbnN0cnVjdG9yLCBhcHAgfSA9IHBhcmFtZXRlcnM7XG4gIGNvbnN0IG1ldGhvZHMgPSBVdGlscy5leHRlbmQoXG4gICAgQ29uc3RydWN0b3JNZXRob2RzKHtcbiAgICAgIGRlZmF1bHRTZWxlY3RvcixcbiAgICAgIGNvbnN0cnVjdG9yLFxuICAgICAgYXBwLFxuICAgICAgZG9tUHJvcDogJ2Y3TW9kYWwnLFxuICAgIH0pLFxuICAgIHtcbiAgICAgIG9wZW4oZWwsIGFuaW1hdGUpIHtcbiAgICAgICAgY29uc3QgJGVsID0gJChlbCk7XG4gICAgICAgIGxldCBpbnN0YW5jZSA9ICRlbFswXS5mN01vZGFsO1xuICAgICAgICBpZiAoIWluc3RhbmNlKSBpbnN0YW5jZSA9IG5ldyBjb25zdHJ1Y3RvcihhcHAsIHsgZWw6ICRlbCB9KTtcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlLm9wZW4oYW5pbWF0ZSk7XG4gICAgICB9LFxuICAgICAgY2xvc2UoZWwgPSBkZWZhdWx0U2VsZWN0b3IsIGFuaW1hdGUpIHtcbiAgICAgICAgY29uc3QgJGVsID0gJChlbCk7XG4gICAgICAgIGlmICgkZWwubGVuZ3RoID09PSAwKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgaW5zdGFuY2UgPSAkZWxbMF0uZjdNb2RhbDtcbiAgICAgICAgaWYgKCFpbnN0YW5jZSkgaW5zdGFuY2UgPSBuZXcgY29uc3RydWN0b3IoYXBwLCB7IGVsOiAkZWwgfSk7XG4gICAgICAgIHJldHVybiBpbnN0YW5jZS5jbG9zZShhbmltYXRlKTtcbiAgICAgIH0sXG4gICAgfVxuICApO1xuICByZXR1cm4gbWV0aG9kcztcbn1cblxudmFyIERpYWxvZyQxID0ge1xuICBuYW1lOiAnZGlhbG9nJyxcbiAgcGFyYW1zOiB7XG4gICAgZGlhbG9nOiB7XG4gICAgICB0aXRsZTogdW5kZWZpbmVkLFxuICAgICAgYnV0dG9uT2s6ICdPSycsXG4gICAgICBidXR0b25DYW5jZWw6ICdDYW5jZWwnLFxuICAgICAgdXNlcm5hbWVQbGFjZWhvbGRlcjogJ1VzZXJuYW1lJyxcbiAgICAgIHBhc3N3b3JkUGxhY2Vob2xkZXI6ICdQYXNzd29yZCcsXG4gICAgICBwcmVsb2FkZXJUaXRsZTogJ0xvYWRpbmcuLi4gJyxcbiAgICAgIHByb2dyZXNzVGl0bGU6ICdMb2FkaW5nLi4uICcsXG4gICAgICBjbG9zZUJ5QmFja2Ryb3BDbGljazogZmFsc2UsXG4gICAgICBkZXN0cm95UHJlZGVmaW5lZERpYWxvZ3M6IHRydWUsXG4gICAgICBrZXlib2FyZEFjdGlvbnM6IHRydWUsXG4gICAgfSxcbiAgfSxcbiAgc3RhdGljOiB7XG4gICAgRGlhbG9nLFxuICB9LFxuICBjcmVhdGUoKSB7XG4gICAgY29uc3QgYXBwID0gdGhpcztcbiAgICBjb25zdCBkZWZhdWx0RGlhbG9nVGl0bGUgPSBhcHAucGFyYW1zLmRpYWxvZy50aXRsZSB8fCBhcHAubmFtZTtcbiAgICBjb25zdCBkZXN0cm95T25DbG9zZSA9IGFwcC5wYXJhbXMuZGlhbG9nLmRlc3Ryb3lQcmVkZWZpbmVkRGlhbG9ncztcbiAgICBjb25zdCBrZXlib2FyZEFjdGlvbnMgPSBhcHAucGFyYW1zLmRpYWxvZy5rZXlib2FyZEFjdGlvbnM7XG4gICAgYXBwLmRpYWxvZyA9IFV0aWxzLmV4dGVuZChcbiAgICAgIE1vZGFsTWV0aG9kcyh7XG4gICAgICAgIGFwcCxcbiAgICAgICAgY29uc3RydWN0b3I6IERpYWxvZyxcbiAgICAgICAgZGVmYXVsdFNlbGVjdG9yOiAnLmRpYWxvZy5tb2RhbC1pbicsXG4gICAgICB9KSxcbiAgICAgIHtcbiAgICAgICAgLy8gU2hvcnRjdXRzXG4gICAgICAgIGFsZXJ0KC4uLmFyZ3MpIHtcbiAgICAgICAgICBsZXQgW3RleHQsIHRpdGxlLCBjYWxsYmFja09rXSA9IGFyZ3M7XG4gICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID09PSAyICYmIHR5cGVvZiBhcmdzWzFdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBbdGV4dCwgY2FsbGJhY2tPaywgdGl0bGVdID0gYXJncztcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5ldyBEaWFsb2coYXBwLCB7XG4gICAgICAgICAgICB0aXRsZTogdHlwZW9mIHRpdGxlID09PSAndW5kZWZpbmVkJyA/IGRlZmF1bHREaWFsb2dUaXRsZSA6IHRpdGxlLFxuICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgIGJ1dHRvbnM6IFt7XG4gICAgICAgICAgICAgIHRleHQ6IGFwcC5wYXJhbXMuZGlhbG9nLmJ1dHRvbk9rLFxuICAgICAgICAgICAgICBib2xkOiB0cnVlLFxuICAgICAgICAgICAgICBvbkNsaWNrOiBjYWxsYmFja09rLFxuICAgICAgICAgICAgICBrZXlDb2Rlczoga2V5Ym9hcmRBY3Rpb25zID8gWzEzLCAyN10gOiBudWxsLFxuICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICBkZXN0cm95T25DbG9zZSxcbiAgICAgICAgICB9KS5vcGVuKCk7XG4gICAgICAgIH0sXG4gICAgICAgIHByb21wdCguLi5hcmdzKSB7XG4gICAgICAgICAgbGV0IFt0ZXh0LCB0aXRsZSwgY2FsbGJhY2tPaywgY2FsbGJhY2tDYW5jZWxdID0gYXJncztcbiAgICAgICAgICBpZiAodHlwZW9mIGFyZ3NbMV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIFt0ZXh0LCBjYWxsYmFja09rLCBjYWxsYmFja0NhbmNlbCwgdGl0bGVdID0gYXJncztcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5ldyBEaWFsb2coYXBwLCB7XG4gICAgICAgICAgICB0aXRsZTogdHlwZW9mIHRpdGxlID09PSAndW5kZWZpbmVkJyA/IGRlZmF1bHREaWFsb2dUaXRsZSA6IHRpdGxlLFxuICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgIGNvbnRlbnQ6ICc8ZGl2IGNsYXNzPVwiZGlhbG9nLWlucHV0LWZpZWxkIGl0ZW0taW5wdXRcIj48ZGl2IGNsYXNzPVwiaXRlbS1pbnB1dC13cmFwXCI+PGlucHV0IHR5cGU9XCJ0ZXh0XCIgY2xhc3M9XCJkaWFsb2ctaW5wdXRcIj48L2Rpdj48L2Rpdj4nLFxuICAgICAgICAgICAgYnV0dG9uczogW1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGV4dDogYXBwLnBhcmFtcy5kaWFsb2cuYnV0dG9uQ2FuY2VsLFxuICAgICAgICAgICAgICAgIGtleUNvZGVzOiBrZXlib2FyZEFjdGlvbnMgPyBbMjddIDogbnVsbCxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRleHQ6IGFwcC5wYXJhbXMuZGlhbG9nLmJ1dHRvbk9rLFxuICAgICAgICAgICAgICAgIGJvbGQ6IHRydWUsXG4gICAgICAgICAgICAgICAga2V5Q29kZXM6IGtleWJvYXJkQWN0aW9ucyA/IFsxM10gOiBudWxsLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIG9uQ2xpY2soZGlhbG9nLCBpbmRleCkge1xuICAgICAgICAgICAgICBjb25zdCBpbnB1dFZhbHVlID0gZGlhbG9nLiRlbC5maW5kKCcuZGlhbG9nLWlucHV0JykudmFsKCk7XG4gICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gMCAmJiBjYWxsYmFja0NhbmNlbCkgY2FsbGJhY2tDYW5jZWwoaW5wdXRWYWx1ZSk7XG4gICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gMSAmJiBjYWxsYmFja09rKSBjYWxsYmFja09rKGlucHV0VmFsdWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRlc3Ryb3lPbkNsb3NlLFxuICAgICAgICAgIH0pLm9wZW4oKTtcbiAgICAgICAgfSxcbiAgICAgICAgY29uZmlybSguLi5hcmdzKSB7XG4gICAgICAgICAgbGV0IFt0ZXh0LCB0aXRsZSwgY2FsbGJhY2tPaywgY2FsbGJhY2tDYW5jZWxdID0gYXJncztcbiAgICAgICAgICBpZiAodHlwZW9mIGFyZ3NbMV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIFt0ZXh0LCBjYWxsYmFja09rLCBjYWxsYmFja0NhbmNlbCwgdGl0bGVdID0gYXJncztcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5ldyBEaWFsb2coYXBwLCB7XG4gICAgICAgICAgICB0aXRsZTogdHlwZW9mIHRpdGxlID09PSAndW5kZWZpbmVkJyA/IGRlZmF1bHREaWFsb2dUaXRsZSA6IHRpdGxlLFxuICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgIGJ1dHRvbnM6IFtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRleHQ6IGFwcC5wYXJhbXMuZGlhbG9nLmJ1dHRvbkNhbmNlbCxcbiAgICAgICAgICAgICAgICBvbkNsaWNrOiBjYWxsYmFja0NhbmNlbCxcbiAgICAgICAgICAgICAgICBrZXlDb2Rlczoga2V5Ym9hcmRBY3Rpb25zID8gWzI3XSA6IG51bGwsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0ZXh0OiBhcHAucGFyYW1zLmRpYWxvZy5idXR0b25PayxcbiAgICAgICAgICAgICAgICBib2xkOiB0cnVlLFxuICAgICAgICAgICAgICAgIG9uQ2xpY2s6IGNhbGxiYWNrT2ssXG4gICAgICAgICAgICAgICAga2V5Q29kZXM6IGtleWJvYXJkQWN0aW9ucyA/IFsxM10gOiBudWxsLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGRlc3Ryb3lPbkNsb3NlLFxuICAgICAgICAgIH0pLm9wZW4oKTtcbiAgICAgICAgfSxcbiAgICAgICAgbG9naW4oLi4uYXJncykge1xuICAgICAgICAgIGxldCBbdGV4dCwgdGl0bGUsIGNhbGxiYWNrT2ssIGNhbGxiYWNrQ2FuY2VsXSA9IGFyZ3M7XG4gICAgICAgICAgaWYgKHR5cGVvZiBhcmdzWzFdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBbdGV4dCwgY2FsbGJhY2tPaywgY2FsbGJhY2tDYW5jZWwsIHRpdGxlXSA9IGFyZ3M7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuZXcgRGlhbG9nKGFwcCwge1xuICAgICAgICAgICAgdGl0bGU6IHR5cGVvZiB0aXRsZSA9PT0gJ3VuZGVmaW5lZCcgPyBkZWZhdWx0RGlhbG9nVGl0bGUgOiB0aXRsZSxcbiAgICAgICAgICAgIHRleHQsXG4gICAgICAgICAgICBjb250ZW50OiBgXG4gICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJkaWFsb2ctaW5wdXQtZmllbGQgZGlhbG9nLWlucHV0LWRvdWJsZSBpdGVtLWlucHV0XCI+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIml0ZW0taW5wdXQtd3JhcFwiPlxuICAgICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgbmFtZT1cImRpYWxvZy11c2VybmFtZVwiIHBsYWNlaG9sZGVyPVwiJHthcHAucGFyYW1zLmRpYWxvZy51c2VybmFtZVBsYWNlaG9sZGVyfVwiIGNsYXNzPVwiZGlhbG9nLWlucHV0XCI+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZGlhbG9nLWlucHV0LWZpZWxkIGRpYWxvZy1pbnB1dC1kb3VibGUgaXRlbS1pbnB1dFwiPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJpdGVtLWlucHV0LXdyYXBcIj5cbiAgICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwicGFzc3dvcmRcIiBuYW1lPVwiZGlhbG9nLXBhc3N3b3JkXCIgcGxhY2Vob2xkZXI9XCIke2FwcC5wYXJhbXMuZGlhbG9nLnBhc3N3b3JkUGxhY2Vob2xkZXJ9XCIgY2xhc3M9XCJkaWFsb2ctaW5wdXRcIj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgPC9kaXY+YCxcbiAgICAgICAgICAgIGJ1dHRvbnM6IFtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRleHQ6IGFwcC5wYXJhbXMuZGlhbG9nLmJ1dHRvbkNhbmNlbCxcbiAgICAgICAgICAgICAgICBrZXlDb2Rlczoga2V5Ym9hcmRBY3Rpb25zID8gWzI3XSA6IG51bGwsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0ZXh0OiBhcHAucGFyYW1zLmRpYWxvZy5idXR0b25PayxcbiAgICAgICAgICAgICAgICBib2xkOiB0cnVlLFxuICAgICAgICAgICAgICAgIGtleUNvZGVzOiBrZXlib2FyZEFjdGlvbnMgPyBbMTNdIDogbnVsbCxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBvbkNsaWNrKGRpYWxvZywgaW5kZXgpIHtcbiAgICAgICAgICAgICAgY29uc3QgdXNlcm5hbWUgPSBkaWFsb2cuJGVsLmZpbmQoJ1tuYW1lPVwiZGlhbG9nLXVzZXJuYW1lXCJdJykudmFsKCk7XG4gICAgICAgICAgICAgIGNvbnN0IHBhc3N3b3JkID0gZGlhbG9nLiRlbC5maW5kKCdbbmFtZT1cImRpYWxvZy1wYXNzd29yZFwiXScpLnZhbCgpO1xuICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IDAgJiYgY2FsbGJhY2tDYW5jZWwpIGNhbGxiYWNrQ2FuY2VsKHVzZXJuYW1lLCBwYXNzd29yZCk7XG4gICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gMSAmJiBjYWxsYmFja09rKSBjYWxsYmFja09rKHVzZXJuYW1lLCBwYXNzd29yZCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGVzdHJveU9uQ2xvc2UsXG4gICAgICAgICAgfSkub3BlbigpO1xuICAgICAgICB9LFxuICAgICAgICBwYXNzd29yZCguLi5hcmdzKSB7XG4gICAgICAgICAgbGV0IFt0ZXh0LCB0aXRsZSwgY2FsbGJhY2tPaywgY2FsbGJhY2tDYW5jZWxdID0gYXJncztcbiAgICAgICAgICBpZiAodHlwZW9mIGFyZ3NbMV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIFt0ZXh0LCBjYWxsYmFja09rLCBjYWxsYmFja0NhbmNlbCwgdGl0bGVdID0gYXJncztcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5ldyBEaWFsb2coYXBwLCB7XG4gICAgICAgICAgICB0aXRsZTogdHlwZW9mIHRpdGxlID09PSAndW5kZWZpbmVkJyA/IGRlZmF1bHREaWFsb2dUaXRsZSA6IHRpdGxlLFxuICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgIGNvbnRlbnQ6IGBcbiAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImRpYWxvZy1pbnB1dC1maWVsZCBpdGVtLWlucHV0XCI+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIml0ZW0taW5wdXQtd3JhcFwiPlxuICAgICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJwYXNzd29yZFwiIG5hbWU9XCJkaWFsb2ctcGFzc3dvcmRcIiBwbGFjZWhvbGRlcj1cIiR7YXBwLnBhcmFtcy5kaWFsb2cucGFzc3dvcmRQbGFjZWhvbGRlcn1cIiBjbGFzcz1cImRpYWxvZy1pbnB1dFwiPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICA8L2Rpdj5gLFxuICAgICAgICAgICAgYnV0dG9uczogW1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGV4dDogYXBwLnBhcmFtcy5kaWFsb2cuYnV0dG9uQ2FuY2VsLFxuICAgICAgICAgICAgICAgIGtleUNvZGVzOiBrZXlib2FyZEFjdGlvbnMgPyBbMjddIDogbnVsbCxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRleHQ6IGFwcC5wYXJhbXMuZGlhbG9nLmJ1dHRvbk9rLFxuICAgICAgICAgICAgICAgIGJvbGQ6IHRydWUsXG4gICAgICAgICAgICAgICAga2V5Q29kZXM6IGtleWJvYXJkQWN0aW9ucyA/IFsxM10gOiBudWxsLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIG9uQ2xpY2soZGlhbG9nLCBpbmRleCkge1xuICAgICAgICAgICAgICBjb25zdCBwYXNzd29yZCA9IGRpYWxvZy4kZWwuZmluZCgnW25hbWU9XCJkaWFsb2ctcGFzc3dvcmRcIl0nKS52YWwoKTtcbiAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSAwICYmIGNhbGxiYWNrQ2FuY2VsKSBjYWxsYmFja0NhbmNlbChwYXNzd29yZCk7XG4gICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gMSAmJiBjYWxsYmFja09rKSBjYWxsYmFja09rKHBhc3N3b3JkKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZXN0cm95T25DbG9zZSxcbiAgICAgICAgICB9KS5vcGVuKCk7XG4gICAgICAgIH0sXG4gICAgICAgIHByZWxvYWRlcih0aXRsZSkge1xuICAgICAgICAgIGNvbnN0IHByZWxvYWRlcklubmVyID0gYXBwLnRoZW1lICE9PSAnbWQnID8gJycgOiBVdGlscy5tZFByZWxvYWRlckNvbnRlbnQ7XG4gICAgICAgICAgcmV0dXJuIG5ldyBEaWFsb2coYXBwLCB7XG4gICAgICAgICAgICB0aXRsZTogdHlwZW9mIHRpdGxlID09PSAndW5kZWZpbmVkJyA/IGFwcC5wYXJhbXMuZGlhbG9nLnByZWxvYWRlclRpdGxlIDogdGl0bGUsXG4gICAgICAgICAgICBjb250ZW50OiBgPGRpdiBjbGFzcz1cInByZWxvYWRlclwiPiR7cHJlbG9hZGVySW5uZXJ9PC9kaXY+YCxcbiAgICAgICAgICAgIGNzc0NsYXNzOiAnZGlhbG9nLXByZWxvYWRlcicsXG4gICAgICAgICAgICBkZXN0cm95T25DbG9zZSxcbiAgICAgICAgICB9KS5vcGVuKCk7XG4gICAgICAgIH0sXG4gICAgICAgIHByb2dyZXNzKC4uLmFyZ3MpIHtcbiAgICAgICAgICBsZXQgW3RpdGxlLCBwcm9ncmVzcywgY29sb3JdID0gYXJncztcbiAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYXJnc1swXSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgW3Byb2dyZXNzLCBjb2xvciwgdGl0bGVdID0gYXJncztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZ3NbMF0gPT09ICdzdHJpbmcnICYmIHR5cGVvZiBhcmdzWzFdID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICBbdGl0bGUsIGNvbG9yLCBwcm9ncmVzc10gPSBhcmdzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoYXJncy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYXJnc1swXSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgW3Byb2dyZXNzLCB0aXRsZSwgY29sb3JdID0gYXJncztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgaW5maW5pdGUgPSB0eXBlb2YgcHJvZ3Jlc3MgPT09ICd1bmRlZmluZWQnO1xuICAgICAgICAgIGNvbnN0IGRpYWxvZyA9IG5ldyBEaWFsb2coYXBwLCB7XG4gICAgICAgICAgICB0aXRsZTogdHlwZW9mIHRpdGxlID09PSAndW5kZWZpbmVkJyA/IGFwcC5wYXJhbXMuZGlhbG9nLnByb2dyZXNzVGl0bGUgOiB0aXRsZSxcbiAgICAgICAgICAgIGNzc0NsYXNzOiAnZGlhbG9nLXByb2dyZXNzJyxcbiAgICAgICAgICAgIGNvbnRlbnQ6IGBcbiAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInByb2dyZXNzYmFyJHtpbmZpbml0ZSA/ICctaW5maW5pdGUnIDogJyd9JHtjb2xvciA/IGAgY29sb3ItJHtjb2xvcn1gIDogJyd9XCI+XG4gICAgICAgICAgICAgICAgJHshaW5maW5pdGUgPyAnPHNwYW4+PC9zcGFuPicgOiAnJ31cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICBgLFxuICAgICAgICAgICAgZGVzdHJveU9uQ2xvc2UsXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKCFpbmZpbml0ZSkgZGlhbG9nLnNldFByb2dyZXNzKHByb2dyZXNzKTtcbiAgICAgICAgICByZXR1cm4gZGlhbG9nLm9wZW4oKTtcbiAgICAgICAgfSxcbiAgICAgIH1cbiAgICApO1xuICB9LFxufTtcblxuY2xhc3MgUG9wdXAgZXh0ZW5kcyBNb2RhbCB7XG4gIGNvbnN0cnVjdG9yKGFwcCwgcGFyYW1zKSB7XG4gICAgY29uc3QgZXh0ZW5kZWRQYXJhbXMgPSBVdGlscy5leHRlbmQoXG4gICAgICB7IG9uOiB7fSB9LFxuICAgICAgYXBwLnBhcmFtcy5wb3B1cCxcbiAgICAgIHBhcmFtc1xuICAgICk7XG5cbiAgICAvLyBFeHRlbmRzIHdpdGggb3Blbi9jbG9zZSBNb2RhbCBtZXRob2RzO1xuICAgIHN1cGVyKGFwcCwgZXh0ZW5kZWRQYXJhbXMpO1xuXG4gICAgY29uc3QgcG9wdXAgPSB0aGlzO1xuXG4gICAgcG9wdXAucGFyYW1zID0gZXh0ZW5kZWRQYXJhbXM7XG5cbiAgICAvLyBGaW5kIEVsZW1lbnRcbiAgICBsZXQgJGVsO1xuICAgIGlmICghcG9wdXAucGFyYW1zLmVsKSB7XG4gICAgICAkZWwgPSAkKHBvcHVwLnBhcmFtcy5jb250ZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgJGVsID0gJChwb3B1cC5wYXJhbXMuZWwpO1xuICAgIH1cblxuICAgIGlmICgkZWwgJiYgJGVsLmxlbmd0aCA+IDAgJiYgJGVsWzBdLmY3TW9kYWwpIHtcbiAgICAgIHJldHVybiAkZWxbMF0uZjdNb2RhbDtcbiAgICB9XG5cbiAgICBpZiAoJGVsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHBvcHVwLmRlc3Ryb3koKTtcbiAgICB9XG5cbiAgICBsZXQgJGJhY2tkcm9wRWw7XG4gICAgaWYgKHBvcHVwLnBhcmFtcy5iYWNrZHJvcCkge1xuICAgICAgJGJhY2tkcm9wRWwgPSBhcHAucm9vdC5jaGlsZHJlbignLnBvcHVwLWJhY2tkcm9wJyk7XG4gICAgICBpZiAoJGJhY2tkcm9wRWwubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICRiYWNrZHJvcEVsID0gJCgnPGRpdiBjbGFzcz1cInBvcHVwLWJhY2tkcm9wXCI+PC9kaXY+Jyk7XG4gICAgICAgIGFwcC5yb290LmFwcGVuZCgkYmFja2Ryb3BFbCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgVXRpbHMuZXh0ZW5kKHBvcHVwLCB7XG4gICAgICBhcHAsXG4gICAgICAkZWwsXG4gICAgICBlbDogJGVsWzBdLFxuICAgICAgJGJhY2tkcm9wRWwsXG4gICAgICBiYWNrZHJvcEVsOiAkYmFja2Ryb3BFbCAmJiAkYmFja2Ryb3BFbFswXSxcbiAgICAgIHR5cGU6ICdwb3B1cCcsXG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVDbGljayhlKSB7XG4gICAgICBjb25zdCB0YXJnZXQgPSBlLnRhcmdldDtcbiAgICAgIGNvbnN0ICR0YXJnZXQgPSAkKHRhcmdldCk7XG4gICAgICBpZiAoJHRhcmdldC5jbG9zZXN0KHBvcHVwLmVsKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHBvcHVwLnBhcmFtcyAmJlxuICAgICAgICAgIHBvcHVwLnBhcmFtcy5jbG9zZUJ5QmFja2Ryb3BDbGljayAmJlxuICAgICAgICAgIHBvcHVwLnBhcmFtcy5iYWNrZHJvcCAmJlxuICAgICAgICAgIHBvcHVwLmJhY2tkcm9wRWwgJiZcbiAgICAgICAgICBwb3B1cC5iYWNrZHJvcEVsID09PSB0YXJnZXRcbiAgICAgICAgKSB7XG4gICAgICAgICAgcG9wdXAuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHBvcHVwLm9uKCdwb3B1cE9wZW5lZCcsICgpID0+IHtcbiAgICAgIGlmIChwb3B1cC5wYXJhbXMuY2xvc2VCeUJhY2tkcm9wQ2xpY2spIHtcbiAgICAgICAgYXBwLm9uKCdjbGljaycsIGhhbmRsZUNsaWNrKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBwb3B1cC5vbigncG9wdXBDbG9zZScsICgpID0+IHtcbiAgICAgIGlmIChwb3B1cC5wYXJhbXMuY2xvc2VCeUJhY2tkcm9wQ2xpY2spIHtcbiAgICAgICAgYXBwLm9mZignY2xpY2snLCBoYW5kbGVDbGljayk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAkZWxbMF0uZjdNb2RhbCA9IHBvcHVwO1xuXG4gICAgcmV0dXJuIHBvcHVwO1xuICB9XG59XG5cbnZhciBQb3B1cCQxID0ge1xuICBuYW1lOiAncG9wdXAnLFxuICBwYXJhbXM6IHtcbiAgICBwb3B1cDoge1xuICAgICAgYmFja2Ryb3A6IHRydWUsXG4gICAgICBjbG9zZUJ5QmFja2Ryb3BDbGljazogdHJ1ZSxcbiAgICB9LFxuICB9LFxuICBzdGF0aWM6IHtcbiAgICBQb3B1cCxcbiAgfSxcbiAgY3JlYXRlKCkge1xuICAgIGNvbnN0IGFwcCA9IHRoaXM7XG4gICAgYXBwLnBvcHVwID0gTW9kYWxNZXRob2RzKHtcbiAgICAgIGFwcCxcbiAgICAgIGNvbnN0cnVjdG9yOiBQb3B1cCxcbiAgICAgIGRlZmF1bHRTZWxlY3RvcjogJy5wb3B1cC5tb2RhbC1pbicsXG4gICAgfSk7XG4gIH0sXG4gIGNsaWNrczoge1xuICAgICcucG9wdXAtb3Blbic6IGZ1bmN0aW9uIG9wZW5Qb3B1cCgkY2xpY2tlZEVsLCBkYXRhID0ge30pIHtcbiAgICAgIGNvbnN0IGFwcCA9IHRoaXM7XG4gICAgICBhcHAucG9wdXAub3BlbihkYXRhLnBvcHVwLCBkYXRhLmFuaW1hdGUpO1xuICAgIH0sXG4gICAgJy5wb3B1cC1jbG9zZSc6IGZ1bmN0aW9uIGNsb3NlUG9wdXAoJGNsaWNrZWRFbCwgZGF0YSA9IHt9KSB7XG4gICAgICBjb25zdCBhcHAgPSB0aGlzO1xuICAgICAgYXBwLnBvcHVwLmNsb3NlKGRhdGEucG9wdXAsIGRhdGEuYW5pbWF0ZSk7XG4gICAgfSxcbiAgfSxcbn07XG5cbmNsYXNzIExvZ2luU2NyZWVuIGV4dGVuZHMgTW9kYWwge1xuICBjb25zdHJ1Y3RvcihhcHAsIHBhcmFtcykge1xuICAgIGNvbnN0IGV4dGVuZGVkUGFyYW1zID0gVXRpbHMuZXh0ZW5kKHtcbiAgICAgIG9uOiB7fSxcbiAgICB9LCBwYXJhbXMpO1xuXG4gICAgLy8gRXh0ZW5kcyB3aXRoIG9wZW4vY2xvc2UgTW9kYWwgbWV0aG9kcztcbiAgICBzdXBlcihhcHAsIGV4dGVuZGVkUGFyYW1zKTtcblxuICAgIGNvbnN0IGxvZ2luU2NyZWVuID0gdGhpcztcblxuICAgIGxvZ2luU2NyZWVuLnBhcmFtcyA9IGV4dGVuZGVkUGFyYW1zO1xuXG4gICAgLy8gRmluZCBFbGVtZW50XG4gICAgbGV0ICRlbDtcbiAgICBpZiAoIWxvZ2luU2NyZWVuLnBhcmFtcy5lbCkge1xuICAgICAgJGVsID0gJChsb2dpblNjcmVlbi5wYXJhbXMuY29udGVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICRlbCA9ICQobG9naW5TY3JlZW4ucGFyYW1zLmVsKTtcbiAgICB9XG5cbiAgICBpZiAoJGVsICYmICRlbC5sZW5ndGggPiAwICYmICRlbFswXS5mN01vZGFsKSB7XG4gICAgICByZXR1cm4gJGVsWzBdLmY3TW9kYWw7XG4gICAgfVxuXG4gICAgaWYgKCRlbC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBsb2dpblNjcmVlbi5kZXN0cm95KCk7XG4gICAgfVxuXG4gICAgVXRpbHMuZXh0ZW5kKGxvZ2luU2NyZWVuLCB7XG4gICAgICBhcHAsXG4gICAgICAkZWwsXG4gICAgICBlbDogJGVsWzBdLFxuICAgICAgdHlwZTogJ2xvZ2luU2NyZWVuJyxcbiAgICB9KTtcblxuICAgICRlbFswXS5mN01vZGFsID0gbG9naW5TY3JlZW47XG5cbiAgICByZXR1cm4gbG9naW5TY3JlZW47XG4gIH1cbn1cblxudmFyIExvZ2luU2NyZWVuJDEgPSB7XG4gIG5hbWU6ICdsb2dpblNjcmVlbicsXG4gIHN0YXRpYzoge1xuICAgIExvZ2luU2NyZWVuLFxuICB9LFxuICBjcmVhdGUoKSB7XG4gICAgY29uc3QgYXBwID0gdGhpcztcbiAgICBhcHAubG9naW5TY3JlZW4gPSBNb2RhbE1ldGhvZHMoe1xuICAgICAgYXBwLFxuICAgICAgY29uc3RydWN0b3I6IExvZ2luU2NyZWVuLFxuICAgICAgZGVmYXVsdFNlbGVjdG9yOiAnLmxvZ2luLXNjcmVlbi5tb2RhbC1pbicsXG4gICAgfSk7XG4gIH0sXG4gIGNsaWNrczoge1xuICAgICcubG9naW4tc2NyZWVuLW9wZW4nOiBmdW5jdGlvbiBvcGVuTG9naW5TY3JlZW4oJGNsaWNrZWRFbCwgZGF0YSA9IHt9KSB7XG4gICAgICBjb25zdCBhcHAgPSB0aGlzO1xuICAgICAgYXBwLmxvZ2luU2NyZWVuLm9wZW4oZGF0YS5sb2dpblNjcmVlbiwgZGF0YS5hbmltYXRlKTtcbiAgICB9LFxuICAgICcubG9naW4tc2NyZWVuLWNsb3NlJzogZnVuY3Rpb24gY2xvc2VMb2dpblNjcmVlbigkY2xpY2tlZEVsLCBkYXRhID0ge30pIHtcbiAgICAgIGNvbnN0IGFwcCA9IHRoaXM7XG4gICAgICBhcHAubG9naW5TY3JlZW4uY2xvc2UoZGF0YS5sb2dpblNjcmVlbiwgZGF0YS5hbmltYXRlKTtcbiAgICB9LFxuICB9LFxufTtcblxuY2xhc3MgUG9wb3ZlciBleHRlbmRzIE1vZGFsIHtcbiAgY29uc3RydWN0b3IoYXBwLCBwYXJhbXMpIHtcbiAgICBjb25zdCBleHRlbmRlZFBhcmFtcyA9IFV0aWxzLmV4dGVuZChcbiAgICAgIHsgb246IHt9IH0sXG4gICAgICBhcHAucGFyYW1zLnBvcG92ZXIsXG4gICAgICBwYXJhbXNcbiAgICApO1xuXG4gICAgLy8gRXh0ZW5kcyB3aXRoIG9wZW4vY2xvc2UgTW9kYWwgbWV0aG9kcztcbiAgICBzdXBlcihhcHAsIGV4dGVuZGVkUGFyYW1zKTtcblxuICAgIGNvbnN0IHBvcG92ZXIgPSB0aGlzO1xuXG4gICAgcG9wb3Zlci5wYXJhbXMgPSBleHRlbmRlZFBhcmFtcztcblxuICAgIC8vIEZpbmQgRWxlbWVudFxuICAgIGxldCAkZWw7XG4gICAgaWYgKCFwb3BvdmVyLnBhcmFtcy5lbCkge1xuICAgICAgJGVsID0gJChwb3BvdmVyLnBhcmFtcy5jb250ZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgJGVsID0gJChwb3BvdmVyLnBhcmFtcy5lbCk7XG4gICAgfVxuXG4gICAgaWYgKCRlbCAmJiAkZWwubGVuZ3RoID4gMCAmJiAkZWxbMF0uZjdNb2RhbCkge1xuICAgICAgcmV0dXJuICRlbFswXS5mN01vZGFsO1xuICAgIH1cblxuICAgIC8vIEZpbmQgVGFyZ2V0XG4gICAgY29uc3QgJHRhcmdldEVsID0gJChwb3BvdmVyLnBhcmFtcy50YXJnZXRFbCkuZXEoMCk7XG5cbiAgICBpZiAoJGVsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHBvcG92ZXIuZGVzdHJveSgpO1xuICAgIH1cblxuICAgIC8vIEJhY2tkcm9wXG4gICAgbGV0ICRiYWNrZHJvcEVsO1xuICAgIGlmIChwb3BvdmVyLnBhcmFtcy5iYWNrZHJvcCkge1xuICAgICAgJGJhY2tkcm9wRWwgPSBhcHAucm9vdC5jaGlsZHJlbignLnBvcG92ZXItYmFja2Ryb3AnKTtcbiAgICAgIGlmICgkYmFja2Ryb3BFbC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgJGJhY2tkcm9wRWwgPSAkKCc8ZGl2IGNsYXNzPVwicG9wb3Zlci1iYWNrZHJvcFwiPjwvZGl2PicpO1xuICAgICAgICBhcHAucm9vdC5hcHBlbmQoJGJhY2tkcm9wRWwpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEZpbmQgQW5nbGVcbiAgICBsZXQgJGFuZ2xlRWw7XG4gICAgaWYgKCRlbC5maW5kKCcucG9wb3Zlci1hbmdsZScpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgJGFuZ2xlRWwgPSAkKCc8ZGl2IGNsYXNzPVwicG9wb3Zlci1hbmdsZVwiPjwvZGl2PicpO1xuICAgICAgJGVsLnByZXBlbmQoJGFuZ2xlRWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICAkYW5nbGVFbCA9ICRlbC5maW5kKCcucG9wb3Zlci1hbmdsZScpO1xuICAgIH1cblxuICAgIC8vIE9wZW5cbiAgICBjb25zdCBvcmlnaW5hbE9wZW4gPSBwb3BvdmVyLm9wZW47XG5cbiAgICBVdGlscy5leHRlbmQocG9wb3Zlciwge1xuICAgICAgYXBwLFxuICAgICAgJGVsLFxuICAgICAgZWw6ICRlbFswXSxcbiAgICAgICR0YXJnZXRFbCxcbiAgICAgIHRhcmdldEVsOiAkdGFyZ2V0RWxbMF0sXG4gICAgICAkYW5nbGVFbCxcbiAgICAgIGFuZ2xlRWw6ICRhbmdsZUVsWzBdLFxuICAgICAgJGJhY2tkcm9wRWwsXG4gICAgICBiYWNrZHJvcEVsOiAkYmFja2Ryb3BFbCAmJiAkYmFja2Ryb3BFbFswXSxcbiAgICAgIHR5cGU6ICdwb3BvdmVyJyxcbiAgICAgIG9wZW4oLi4uYXJncykge1xuICAgICAgICBsZXQgW3RhcmdldEVsLCBhbmltYXRlXSA9IGFyZ3M7XG4gICAgICAgIGlmICh0eXBlb2YgYXJnc1swXSA9PT0gJ2Jvb2xlYW4nKSBbYW5pbWF0ZSwgdGFyZ2V0RWxdID0gYXJncztcbiAgICAgICAgaWYgKHRhcmdldEVsKSB7XG4gICAgICAgICAgcG9wb3Zlci4kdGFyZ2V0RWwgPSAkKHRhcmdldEVsKTtcbiAgICAgICAgICBwb3BvdmVyLnRhcmdldEVsID0gcG9wb3Zlci4kdGFyZ2V0RWxbMF07XG4gICAgICAgIH1cbiAgICAgICAgb3JpZ2luYWxPcGVuLmNhbGwocG9wb3ZlciwgYW5pbWF0ZSk7XG4gICAgICB9LFxuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gaGFuZGxlUmVzaXplKCkge1xuICAgICAgcG9wb3Zlci5yZXNpemUoKTtcbiAgICB9XG4gICAgcG9wb3Zlci5vbigncG9wb3Zlck9wZW4nLCAoKSA9PiB7XG4gICAgICBwb3BvdmVyLnJlc2l6ZSgpO1xuICAgICAgYXBwLm9uKCdyZXNpemUnLCBoYW5kbGVSZXNpemUpO1xuICAgICAgcG9wb3Zlci5vbigncG9wb3ZlckNsb3NlIHBvcG92ZXJCZWZvcmVEZXN0cm95JywgKCkgPT4ge1xuICAgICAgICBhcHAub2ZmKCdyZXNpemUnLCBoYW5kbGVSZXNpemUpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVDbGljayhlKSB7XG4gICAgICBjb25zdCB0YXJnZXQgPSBlLnRhcmdldDtcbiAgICAgIGNvbnN0ICR0YXJnZXQgPSAkKHRhcmdldCk7XG4gICAgICBpZiAoJHRhcmdldC5jbG9zZXN0KHBvcG92ZXIuZWwpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgcG9wb3Zlci5wYXJhbXMuY2xvc2VCeUJhY2tkcm9wQ2xpY2sgJiZcbiAgICAgICAgICBwb3BvdmVyLnBhcmFtcy5iYWNrZHJvcCAmJlxuICAgICAgICAgIHBvcG92ZXIuYmFja2Ryb3BFbCAmJlxuICAgICAgICAgIHBvcG92ZXIuYmFja2Ryb3BFbCA9PT0gdGFyZ2V0XG4gICAgICAgICkge1xuICAgICAgICAgIHBvcG92ZXIuY2xvc2UoKTtcbiAgICAgICAgfSBlbHNlIGlmIChwb3BvdmVyLnBhcmFtcy5jbG9zZUJ5T3V0c2lkZUNsaWNrKSB7XG4gICAgICAgICAgcG9wb3Zlci5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcG9wb3Zlci5vbigncG9wb3Zlck9wZW5lZCcsICgpID0+IHtcbiAgICAgIGlmIChwb3BvdmVyLnBhcmFtcy5jbG9zZUJ5T3V0c2lkZUNsaWNrIHx8IHBvcG92ZXIucGFyYW1zLmNsb3NlQnlCYWNrZHJvcENsaWNrKSB7XG4gICAgICAgIGFwcC5vbignY2xpY2snLCBoYW5kbGVDbGljayk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcG9wb3Zlci5vbigncG9wb3ZlckNsb3NlJywgKCkgPT4ge1xuICAgICAgaWYgKHBvcG92ZXIucGFyYW1zLmNsb3NlQnlPdXRzaWRlQ2xpY2sgfHwgcG9wb3Zlci5wYXJhbXMuY2xvc2VCeUJhY2tkcm9wQ2xpY2spIHtcbiAgICAgICAgYXBwLm9mZignY2xpY2snLCBoYW5kbGVDbGljayk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAkZWxbMF0uZjdNb2RhbCA9IHBvcG92ZXI7XG5cbiAgICByZXR1cm4gcG9wb3ZlcjtcbiAgfVxuICByZXNpemUoKSB7XG4gICAgY29uc3QgcG9wb3ZlciA9IHRoaXM7XG4gICAgY29uc3QgeyBhcHAsICRlbCwgJHRhcmdldEVsLCAkYW5nbGVFbCB9ID0gcG9wb3ZlcjtcbiAgICBjb25zdCB7IHRhcmdldFgsIHRhcmdldFkgfSA9IHBvcG92ZXIucGFyYW1zO1xuICAgICRlbC5jc3MoeyBsZWZ0OiAnJywgdG9wOiAnJyB9KTtcbiAgICBjb25zdCBbd2lkdGgsIGhlaWdodF0gPSBbJGVsLndpZHRoKCksICRlbC5oZWlnaHQoKV07XG4gICAgbGV0IGFuZ2xlU2l6ZSA9IDA7XG4gICAgbGV0IGFuZ2xlTGVmdDtcbiAgICBsZXQgYW5nbGVUb3A7XG4gICAgaWYgKGFwcC50aGVtZSA9PT0gJ2lvcycpIHtcbiAgICAgICRhbmdsZUVsLnJlbW92ZUNsYXNzKCdvbi1sZWZ0IG9uLXJpZ2h0IG9uLXRvcCBvbi1ib3R0b20nKS5jc3MoeyBsZWZ0OiAnJywgdG9wOiAnJyB9KTtcbiAgICAgIGFuZ2xlU2l6ZSA9ICRhbmdsZUVsLndpZHRoKCkgLyAyO1xuICAgIH0gZWxzZSB7XG4gICAgICAkZWwucmVtb3ZlQ2xhc3MoJ3BvcG92ZXItb24tbGVmdCBwb3BvdmVyLW9uLXJpZ2h0IHBvcG92ZXItb24tdG9wIHBvcG92ZXItb24tYm90dG9tJykuY3NzKHsgbGVmdDogJycsIHRvcDogJycgfSk7XG4gICAgfVxuXG4gICAgbGV0IHRhcmdldFdpZHRoO1xuICAgIGxldCB0YXJnZXRIZWlnaHQ7XG4gICAgbGV0IHRhcmdldE9mZnNldExlZnQ7XG4gICAgbGV0IHRhcmdldE9mZnNldFRvcDtcbiAgICBpZiAoJHRhcmdldEVsICYmICR0YXJnZXRFbC5sZW5ndGggPiAwKSB7XG4gICAgICB0YXJnZXRXaWR0aCA9ICR0YXJnZXRFbC5vdXRlcldpZHRoKCk7XG4gICAgICB0YXJnZXRIZWlnaHQgPSAkdGFyZ2V0RWwub3V0ZXJIZWlnaHQoKTtcblxuICAgICAgY29uc3QgdGFyZ2V0T2Zmc2V0ID0gJHRhcmdldEVsLm9mZnNldCgpO1xuICAgICAgdGFyZ2V0T2Zmc2V0TGVmdCA9IHRhcmdldE9mZnNldC5sZWZ0IC0gYXBwLmxlZnQ7XG4gICAgICB0YXJnZXRPZmZzZXRUb3AgPSB0YXJnZXRPZmZzZXQudG9wIC0gYXBwLnRvcDtcblxuICAgICAgY29uc3QgdGFyZ2V0UGFyZW50UGFnZSA9ICR0YXJnZXRFbC5wYXJlbnRzKCcucGFnZScpO1xuICAgICAgaWYgKHRhcmdldFBhcmVudFBhZ2UubGVuZ3RoID4gMCkge1xuICAgICAgICB0YXJnZXRPZmZzZXRUb3AgLT0gdGFyZ2V0UGFyZW50UGFnZVswXS5zY3JvbGxUb3A7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdGFyZ2V0WCAhPT0gJ3VuZGVmaW5lZCcgJiYgdGFyZ2V0WSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRhcmdldE9mZnNldExlZnQgPSB0YXJnZXRYO1xuICAgICAgdGFyZ2V0T2Zmc2V0VG9wID0gdGFyZ2V0WTtcbiAgICAgIHRhcmdldFdpZHRoID0gcG9wb3Zlci5wYXJhbXMudGFyZ2V0V2lkdGggfHwgMDtcbiAgICAgIHRhcmdldEhlaWdodCA9IHBvcG92ZXIucGFyYW1zLnRhcmdldEhlaWdodCB8fCAwO1xuICAgIH1cblxuICAgIGxldCBbbGVmdCwgdG9wLCBkaWZmXSA9IFswLCAwLCAwXTtcbiAgICAvLyBUb3AgUG9zaXRpb25cbiAgICBsZXQgcG9zaXRpb24gPSBhcHAudGhlbWUgPT09ICdtZCcgPyAnYm90dG9tJyA6ICd0b3AnO1xuICAgIGlmIChhcHAudGhlbWUgPT09ICdtZCcpIHtcbiAgICAgIGlmIChoZWlnaHQgPCBhcHAuaGVpZ2h0IC0gdGFyZ2V0T2Zmc2V0VG9wIC0gdGFyZ2V0SGVpZ2h0KSB7XG4gICAgICAgIC8vIE9uIGJvdHRvbVxuICAgICAgICBwb3NpdGlvbiA9ICdib3R0b20nO1xuICAgICAgICB0b3AgPSB0YXJnZXRPZmZzZXRUb3A7XG4gICAgICB9IGVsc2UgaWYgKGhlaWdodCA8IHRhcmdldE9mZnNldFRvcCkge1xuICAgICAgICAvLyBPbiB0b3BcbiAgICAgICAgdG9wID0gKHRhcmdldE9mZnNldFRvcCAtIGhlaWdodCkgKyB0YXJnZXRIZWlnaHQ7XG4gICAgICAgIHBvc2l0aW9uID0gJ3RvcCc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBPbiBtaWRkbGVcbiAgICAgICAgcG9zaXRpb24gPSAnYm90dG9tJztcbiAgICAgICAgdG9wID0gdGFyZ2V0T2Zmc2V0VG9wO1xuICAgICAgfVxuXG4gICAgICBpZiAodG9wIDw9IDApIHtcbiAgICAgICAgdG9wID0gODtcbiAgICAgIH0gZWxzZSBpZiAodG9wICsgaGVpZ2h0ID49IGFwcC5oZWlnaHQpIHtcbiAgICAgICAgdG9wID0gYXBwLmhlaWdodCAtIGhlaWdodCAtIDg7XG4gICAgICB9XG5cbiAgICAgIC8vIEhvcml6b250YWwgUG9zaXRpb25cbiAgICAgIGxlZnQgPSAodGFyZ2V0T2Zmc2V0TGVmdCArIHRhcmdldFdpZHRoKSAtIHdpZHRoIC0gODtcbiAgICAgIGlmIChsZWZ0ICsgd2lkdGggPj0gYXBwLndpZHRoIC0gOCkge1xuICAgICAgICBsZWZ0ID0gKHRhcmdldE9mZnNldExlZnQgKyB0YXJnZXRXaWR0aCkgLSB3aWR0aCAtIDg7XG4gICAgICB9XG4gICAgICBpZiAobGVmdCA8IDgpIHtcbiAgICAgICAgbGVmdCA9IDg7XG4gICAgICB9XG4gICAgICBpZiAocG9zaXRpb24gPT09ICd0b3AnKSB7XG4gICAgICAgICRlbC5hZGRDbGFzcygncG9wb3Zlci1vbi10b3AnKTtcbiAgICAgIH1cbiAgICAgIGlmIChwb3NpdGlvbiA9PT0gJ2JvdHRvbScpIHtcbiAgICAgICAgJGVsLmFkZENsYXNzKCdwb3BvdmVyLW9uLWJvdHRvbScpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoKGhlaWdodCArIGFuZ2xlU2l6ZSkgPCB0YXJnZXRPZmZzZXRUb3ApIHtcbiAgICAgICAgLy8gT24gdG9wXG4gICAgICAgIHRvcCA9IHRhcmdldE9mZnNldFRvcCAtIGhlaWdodCAtIGFuZ2xlU2l6ZTtcbiAgICAgIH0gZWxzZSBpZiAoKGhlaWdodCArIGFuZ2xlU2l6ZSkgPCBhcHAuaGVpZ2h0IC0gdGFyZ2V0T2Zmc2V0VG9wIC0gdGFyZ2V0SGVpZ2h0KSB7XG4gICAgICAgIC8vIE9uIGJvdHRvbVxuICAgICAgICBwb3NpdGlvbiA9ICdib3R0b20nO1xuICAgICAgICB0b3AgPSB0YXJnZXRPZmZzZXRUb3AgKyB0YXJnZXRIZWlnaHQgKyBhbmdsZVNpemU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBPbiBtaWRkbGVcbiAgICAgICAgcG9zaXRpb24gPSAnbWlkZGxlJztcbiAgICAgICAgdG9wID0gKCh0YXJnZXRIZWlnaHQgLyAyKSArIHRhcmdldE9mZnNldFRvcCkgLSAoaGVpZ2h0IC8gMik7XG4gICAgICAgIGRpZmYgPSB0b3A7XG4gICAgICAgIGlmICh0b3AgPD0gMCkge1xuICAgICAgICAgIHRvcCA9IDU7XG4gICAgICAgIH0gZWxzZSBpZiAodG9wICsgaGVpZ2h0ID49IGFwcC5oZWlnaHQpIHtcbiAgICAgICAgICB0b3AgPSBhcHAuaGVpZ2h0IC0gaGVpZ2h0IC0gNTtcbiAgICAgICAgfVxuICAgICAgICBkaWZmIC09IHRvcDtcbiAgICAgIH1cblxuICAgICAgLy8gSG9yaXpvbnRhbCBQb3NpdGlvblxuICAgICAgaWYgKHBvc2l0aW9uID09PSAndG9wJyB8fCBwb3NpdGlvbiA9PT0gJ2JvdHRvbScpIHtcbiAgICAgICAgbGVmdCA9ICgodGFyZ2V0V2lkdGggLyAyKSArIHRhcmdldE9mZnNldExlZnQpIC0gKHdpZHRoIC8gMik7XG4gICAgICAgIGRpZmYgPSBsZWZ0O1xuICAgICAgICBpZiAobGVmdCA8IDUpIGxlZnQgPSA1O1xuICAgICAgICBpZiAobGVmdCArIHdpZHRoID4gYXBwLndpZHRoKSBsZWZ0ID0gYXBwLndpZHRoIC0gd2lkdGggLSA1O1xuICAgICAgICBpZiAobGVmdCA8IDApIGxlZnQgPSAwO1xuICAgICAgICBpZiAocG9zaXRpb24gPT09ICd0b3AnKSB7XG4gICAgICAgICAgJGFuZ2xlRWwuYWRkQ2xhc3MoJ29uLWJvdHRvbScpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb3NpdGlvbiA9PT0gJ2JvdHRvbScpIHtcbiAgICAgICAgICAkYW5nbGVFbC5hZGRDbGFzcygnb24tdG9wJyk7XG4gICAgICAgIH1cbiAgICAgICAgZGlmZiAtPSBsZWZ0O1xuICAgICAgICBhbmdsZUxlZnQgPSAoKHdpZHRoIC8gMikgLSBhbmdsZVNpemUpICsgZGlmZjtcbiAgICAgICAgYW5nbGVMZWZ0ID0gTWF0aC5tYXgoTWF0aC5taW4oYW5nbGVMZWZ0LCB3aWR0aCAtIChhbmdsZVNpemUgKiAyKSAtIDEzKSwgMTMpO1xuICAgICAgICAkYW5nbGVFbC5jc3MoeyBsZWZ0OiBgJHthbmdsZUxlZnR9cHhgIH0pO1xuICAgICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ21pZGRsZScpIHtcbiAgICAgICAgbGVmdCA9IHRhcmdldE9mZnNldExlZnQgLSB3aWR0aCAtIGFuZ2xlU2l6ZTtcbiAgICAgICAgJGFuZ2xlRWwuYWRkQ2xhc3MoJ29uLXJpZ2h0Jyk7XG4gICAgICAgIGlmIChsZWZ0IDwgNSB8fCAobGVmdCArIHdpZHRoID4gYXBwLndpZHRoKSkge1xuICAgICAgICAgIGlmIChsZWZ0IDwgNSkgbGVmdCA9IHRhcmdldE9mZnNldExlZnQgKyB0YXJnZXRXaWR0aCArIGFuZ2xlU2l6ZTtcbiAgICAgICAgICBpZiAobGVmdCArIHdpZHRoID4gYXBwLndpZHRoKSBsZWZ0ID0gYXBwLndpZHRoIC0gd2lkdGggLSA1O1xuICAgICAgICAgICRhbmdsZUVsLnJlbW92ZUNsYXNzKCdvbi1yaWdodCcpLmFkZENsYXNzKCdvbi1sZWZ0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgYW5nbGVUb3AgPSAoKGhlaWdodCAvIDIpIC0gYW5nbGVTaXplKSArIGRpZmY7XG4gICAgICAgIGFuZ2xlVG9wID0gTWF0aC5tYXgoTWF0aC5taW4oYW5nbGVUb3AsIGhlaWdodCAtIChhbmdsZVNpemUgKiAyKSAtIDEzKSwgMTMpO1xuICAgICAgICAkYW5nbGVFbC5jc3MoeyB0b3A6IGAke2FuZ2xlVG9wfXB4YCB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBcHBseSBTdHlsZXNcbiAgICAkZWwuY3NzKHsgdG9wOiBgJHt0b3B9cHhgLCBsZWZ0OiBgJHtsZWZ0fXB4YCB9KTtcbiAgfVxufVxuXG52YXIgUG9wb3ZlciQxID0ge1xuICBuYW1lOiAncG9wb3ZlcicsXG4gIHBhcmFtczoge1xuICAgIHBvcG92ZXI6IHtcbiAgICAgIGNsb3NlQnlCYWNrZHJvcENsaWNrOiB0cnVlLFxuICAgICAgY2xvc2VCeU91dHNpZGVDbGljazogZmFsc2UsXG4gICAgICBiYWNrZHJvcDogdHJ1ZSxcbiAgICB9LFxuICB9LFxuICBzdGF0aWM6IHtcbiAgICBQb3BvdmVyLFxuICB9LFxuICBjcmVhdGUoKSB7XG4gICAgY29uc3QgYXBwID0gdGhpcztcbiAgICBhcHAucG9wb3ZlciA9IFV0aWxzLmV4dGVuZChcbiAgICAgIE1vZGFsTWV0aG9kcyh7XG4gICAgICAgIGFwcCxcbiAgICAgICAgY29uc3RydWN0b3I6IFBvcG92ZXIsXG4gICAgICAgIGRlZmF1bHRTZWxlY3RvcjogJy5wb3BvdmVyLm1vZGFsLWluJyxcbiAgICAgIH0pLFxuICAgICAge1xuICAgICAgICBvcGVuKHBvcG92ZXJFbCwgdGFyZ2V0RWwsIGFuaW1hdGUpIHtcbiAgICAgICAgICBjb25zdCAkcG9wb3ZlckVsID0gJChwb3BvdmVyRWwpO1xuICAgICAgICAgIGxldCBwb3BvdmVyID0gJHBvcG92ZXJFbFswXS5mN01vZGFsO1xuICAgICAgICAgIGlmICghcG9wb3ZlcikgcG9wb3ZlciA9IG5ldyBQb3BvdmVyKGFwcCwgeyBlbDogJHBvcG92ZXJFbCwgdGFyZ2V0RWwgfSk7XG4gICAgICAgICAgcmV0dXJuIHBvcG92ZXIub3Blbih0YXJnZXRFbCwgYW5pbWF0ZSk7XG4gICAgICAgIH0sXG4gICAgICB9XG4gICAgKTtcbiAgfSxcbiAgY2xpY2tzOiB7XG4gICAgJy5wb3BvdmVyLW9wZW4nOiBmdW5jdGlvbiBvcGVuUG9wb3ZlcigkY2xpY2tlZEVsLCBkYXRhID0ge30pIHtcbiAgICAgIGNvbnN0IGFwcCA9IHRoaXM7XG4gICAgICBhcHAucG9wb3Zlci5vcGVuKGRhdGEucG9wb3ZlciwgJGNsaWNrZWRFbCwgZGF0YS5hbmltYXRlKTtcbiAgICB9LFxuICAgICcucG9wb3Zlci1jbG9zZSc6IGZ1bmN0aW9uIGNsb3NlUG9wb3ZlcigkY2xpY2tlZEVsLCBkYXRhID0ge30pIHtcbiAgICAgIGNvbnN0IGFwcCA9IHRoaXM7XG4gICAgICBhcHAucG9wb3Zlci5jbG9zZShkYXRhLnBvcG92ZXIsIGRhdGEuYW5pbWF0ZSk7XG4gICAgfSxcbiAgfSxcbn07XG5cbi8qIGVzbGludCBpbmRlbnQ6IFtcIm9mZlwiXSAqL1xuXG5jbGFzcyBBY3Rpb25zIGV4dGVuZHMgTW9kYWwge1xuICBjb25zdHJ1Y3RvcihhcHAsIHBhcmFtcykge1xuICAgIGNvbnN0IGV4dGVuZGVkUGFyYW1zID0gVXRpbHMuZXh0ZW5kKFxuICAgICAgeyBvbjoge30gfSxcbiAgICAgIGFwcC5wYXJhbXMuYWN0aW9ucyxcbiAgICAgIHBhcmFtc1xuICAgICk7XG5cbiAgICAvLyBFeHRlbmRzIHdpdGggb3Blbi9jbG9zZSBNb2RhbCBtZXRob2RzO1xuICAgIHN1cGVyKGFwcCwgZXh0ZW5kZWRQYXJhbXMpO1xuXG4gICAgY29uc3QgYWN0aW9ucyA9IHRoaXM7XG5cbiAgICBhY3Rpb25zLnBhcmFtcyA9IGV4dGVuZGVkUGFyYW1zO1xuXG4gICAgLy8gQnV0dG9uc1xuICAgIGxldCBncm91cHM7XG4gICAgaWYgKGFjdGlvbnMucGFyYW1zLmJ1dHRvbnMpIHtcbiAgICAgIGdyb3VwcyA9IGFjdGlvbnMucGFyYW1zLmJ1dHRvbnM7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZ3JvdXBzWzBdKSkgZ3JvdXBzID0gW2dyb3Vwc107XG4gICAgfVxuICAgIGFjdGlvbnMuZ3JvdXBzID0gZ3JvdXBzO1xuXG4gICAgLy8gRmluZCBFbGVtZW50XG4gICAgbGV0ICRlbDtcbiAgICBpZiAoYWN0aW9ucy5wYXJhbXMuZWwpIHtcbiAgICAgICRlbCA9ICQoYWN0aW9ucy5wYXJhbXMuZWwpO1xuICAgIH0gZWxzZSBpZiAoYWN0aW9ucy5wYXJhbXMuY29udGVudCkge1xuICAgICAgJGVsID0gJChhY3Rpb25zLnBhcmFtcy5jb250ZW50KTtcbiAgICB9IGVsc2UgaWYgKGFjdGlvbnMucGFyYW1zLmJ1dHRvbnMpIHtcbiAgICAgIGlmIChhY3Rpb25zLnBhcmFtcy5jb252ZXJ0VG9Qb3BvdmVyKSB7XG4gICAgICAgIGFjdGlvbnMucG9wb3Zlckh0bWwgPSBhY3Rpb25zLnJlbmRlclBvcG92ZXIoKTtcbiAgICAgIH1cbiAgICAgIGFjdGlvbnMuYWN0aW9uc0h0bWwgPSBhY3Rpb25zLnJlbmRlcigpO1xuICAgIH1cblxuICAgIGlmICgkZWwgJiYgJGVsLmxlbmd0aCA+IDAgJiYgJGVsWzBdLmY3TW9kYWwpIHtcbiAgICAgIHJldHVybiAkZWxbMF0uZjdNb2RhbDtcbiAgICB9XG5cbiAgICBpZiAoJGVsICYmICRlbC5sZW5ndGggPT09IDAgJiYgIShhY3Rpb25zLmFjdGlvbnNIdG1sIHx8IGFjdGlvbnMucG9wb3Zlckh0bWwpKSB7XG4gICAgICByZXR1cm4gYWN0aW9ucy5kZXN0cm95KCk7XG4gICAgfVxuXG4gICAgLy8gQmFja2Ryb3BcbiAgICBsZXQgJGJhY2tkcm9wRWw7XG4gICAgaWYgKGFjdGlvbnMucGFyYW1zLmJhY2tkcm9wKSB7XG4gICAgICAkYmFja2Ryb3BFbCA9IGFwcC5yb290LmNoaWxkcmVuKCcuYWN0aW9ucy1iYWNrZHJvcCcpO1xuICAgICAgaWYgKCRiYWNrZHJvcEVsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAkYmFja2Ryb3BFbCA9ICQoJzxkaXYgY2xhc3M9XCJhY3Rpb25zLWJhY2tkcm9wXCI+PC9kaXY+Jyk7XG4gICAgICAgIGFwcC5yb290LmFwcGVuZCgkYmFja2Ryb3BFbCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qgb3JpZ2luYWxPcGVuID0gYWN0aW9ucy5vcGVuO1xuICAgIGNvbnN0IG9yaWdpbmFsQ2xvc2UgPSBhY3Rpb25zLmNsb3NlO1xuXG4gICAgbGV0IHBvcG92ZXI7XG4gICAgZnVuY3Rpb24gYnV0dG9uT25DbGljayhlKSB7XG4gICAgICBjb25zdCBidXR0b25FbCA9IHRoaXM7XG4gICAgICBsZXQgYnV0dG9uSW5kZXg7XG4gICAgICBsZXQgZ3JvdXBJbmRleDtcbiAgICAgIGlmICgkKGJ1dHRvbkVsKS5oYXNDbGFzcygnaXRlbS1saW5rJykpIHtcbiAgICAgICAgYnV0dG9uSW5kZXggPSAkKGJ1dHRvbkVsKS5wYXJlbnRzKCdsaScpLmluZGV4KCk7XG4gICAgICAgIGdyb3VwSW5kZXggPSAkKGJ1dHRvbkVsKS5wYXJlbnRzKCcubGlzdCcpLmluZGV4KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBidXR0b25JbmRleCA9ICQoYnV0dG9uRWwpLmluZGV4KCk7XG4gICAgICAgIGdyb3VwSW5kZXggPSAkKGJ1dHRvbkVsKS5wYXJlbnRzKCcuYWN0aW9ucy1ncm91cCcpLmluZGV4KCk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGdyb3VwcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29uc3QgYnV0dG9uID0gZ3JvdXBzW2dyb3VwSW5kZXhdW2J1dHRvbkluZGV4XTtcbiAgICAgICAgaWYgKGJ1dHRvbi5vbkNsaWNrKSBidXR0b24ub25DbGljayhhY3Rpb25zLCBlKTtcbiAgICAgICAgaWYgKGFjdGlvbnMucGFyYW1zLm9uQ2xpY2spIGFjdGlvbnMucGFyYW1zLm9uQ2xpY2soYWN0aW9ucywgZSk7XG4gICAgICAgIGlmIChidXR0b24uY2xvc2UgIT09IGZhbHNlKSBhY3Rpb25zLmNsb3NlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGFjdGlvbnMub3BlbiA9IGZ1bmN0aW9uIG9wZW4oYW5pbWF0ZSkge1xuICAgICAgbGV0IGNvbnZlcnRUb1BvcG92ZXIgPSBmYWxzZTtcbiAgICAgIGNvbnN0IHsgdGFyZ2V0RWwsIHRhcmdldFgsIHRhcmdldFksIHRhcmdldFdpZHRoLCB0YXJnZXRIZWlnaHQgfSA9IGFjdGlvbnMucGFyYW1zO1xuICAgICAgaWYgKGFjdGlvbnMucGFyYW1zLmNvbnZlcnRUb1BvcG92ZXIgJiYgKHRhcmdldEVsIHx8ICh0YXJnZXRYICE9PSB1bmRlZmluZWQgJiYgdGFyZ2V0WSAhPT0gdW5kZWZpbmVkKSkpIHtcbiAgICAgICAgLy8gUG9wb3ZlclxuICAgICAgICBpZiAoXG4gICAgICAgICAgYWN0aW9ucy5wYXJhbXMuZm9yY2VUb1BvcG92ZXIgfHxcbiAgICAgICAgICAoYXBwLmRldmljZS5pb3MgJiYgYXBwLmRldmljZS5pcGFkKSB8fFxuICAgICAgICAgIGFwcC53aWR0aCA+PSA3NjhcbiAgICAgICAgKSB7XG4gICAgICAgICAgY29udmVydFRvUG9wb3ZlciA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjb252ZXJ0VG9Qb3BvdmVyICYmIGFjdGlvbnMucG9wb3Zlckh0bWwpIHtcbiAgICAgICAgcG9wb3ZlciA9IGFwcC5wb3BvdmVyLmNyZWF0ZSh7XG4gICAgICAgICAgY29udGVudDogYWN0aW9ucy5wb3BvdmVySHRtbCxcbiAgICAgICAgICBiYWNrZHJvcDogYWN0aW9ucy5wYXJhbXMuYmFja2Ryb3AsXG4gICAgICAgICAgdGFyZ2V0RWwsXG4gICAgICAgICAgdGFyZ2V0WCxcbiAgICAgICAgICB0YXJnZXRZLFxuICAgICAgICAgIHRhcmdldFdpZHRoLFxuICAgICAgICAgIHRhcmdldEhlaWdodCxcbiAgICAgICAgfSk7XG4gICAgICAgIHBvcG92ZXIub3BlbihhbmltYXRlKTtcbiAgICAgICAgcG9wb3Zlci5vbmNlKCdwb3BvdmVyT3BlbmVkJywgKCkgPT4ge1xuICAgICAgICAgIHBvcG92ZXIuJGVsLmZpbmQoJy5pdGVtLWxpbmsnKS5lYWNoKChncm91cEluZGV4LCBidXR0b25FbCkgPT4ge1xuICAgICAgICAgICAgJChidXR0b25FbCkub24oJ2NsaWNrJywgYnV0dG9uT25DbGljayk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBwb3BvdmVyLm9uY2UoJ3BvcG92ZXJDbG9zZWQnLCAoKSA9PiB7XG4gICAgICAgICAgcG9wb3Zlci4kZWwuZmluZCgnLml0ZW0tbGluaycpLmVhY2goKGdyb3VwSW5kZXgsIGJ1dHRvbkVsKSA9PiB7XG4gICAgICAgICAgICAkKGJ1dHRvbkVsKS5vZmYoJ2NsaWNrJywgYnV0dG9uT25DbGljayk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgVXRpbHMubmV4dFRpY2soKCkgPT4ge1xuICAgICAgICAgICAgcG9wb3Zlci5kZXN0cm95KCk7XG4gICAgICAgICAgICBwb3BvdmVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFjdGlvbnMuJGVsID0gYWN0aW9ucy5hY3Rpb25zSHRtbCA/ICQoYWN0aW9ucy5hY3Rpb25zSHRtbCkgOiBhY3Rpb25zLiRlbDtcbiAgICAgICAgYWN0aW9ucy4kZWxbMF0uZjdNb2RhbCA9IGFjdGlvbnM7XG4gICAgICAgIGlmIChhY3Rpb25zLmdyb3Vwcykge1xuICAgICAgICAgIGFjdGlvbnMuJGVsLmZpbmQoJy5hY3Rpb25zLWJ1dHRvbicpLmVhY2goKGdyb3VwSW5kZXgsIGJ1dHRvbkVsKSA9PiB7XG4gICAgICAgICAgICAkKGJ1dHRvbkVsKS5vbignY2xpY2snLCBidXR0b25PbkNsaWNrKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBhY3Rpb25zLm9uY2UoJ2FjdGlvbnNDbG9zZWQnLCAoKSA9PiB7XG4gICAgICAgICAgICBhY3Rpb25zLiRlbC5maW5kKCcuYWN0aW9ucy1idXR0b24nKS5lYWNoKChncm91cEluZGV4LCBidXR0b25FbCkgPT4ge1xuICAgICAgICAgICAgICAkKGJ1dHRvbkVsKS5vZmYoJ2NsaWNrJywgYnV0dG9uT25DbGljayk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBvcmlnaW5hbE9wZW4uY2FsbChhY3Rpb25zLCBhbmltYXRlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhY3Rpb25zO1xuICAgIH07XG5cbiAgICBhY3Rpb25zLmNsb3NlID0gZnVuY3Rpb24gY2xvc2UoYW5pbWF0ZSkge1xuICAgICAgaWYgKHBvcG92ZXIpIHtcbiAgICAgICAgcG9wb3Zlci5jbG9zZShhbmltYXRlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9yaWdpbmFsQ2xvc2UuY2FsbChhY3Rpb25zLCBhbmltYXRlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhY3Rpb25zO1xuICAgIH07XG5cbiAgICBVdGlscy5leHRlbmQoYWN0aW9ucywge1xuICAgICAgYXBwLFxuICAgICAgJGVsLFxuICAgICAgZWw6ICRlbCA/ICRlbFswXSA6IHVuZGVmaW5lZCxcbiAgICAgICRiYWNrZHJvcEVsLFxuICAgICAgYmFja2Ryb3BFbDogJGJhY2tkcm9wRWwgJiYgJGJhY2tkcm9wRWxbMF0sXG4gICAgICB0eXBlOiAnYWN0aW9ucycsXG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVDbGljayhlKSB7XG4gICAgICBjb25zdCB0YXJnZXQgPSBlLnRhcmdldDtcbiAgICAgIGNvbnN0ICR0YXJnZXQgPSAkKHRhcmdldCk7XG4gICAgICBpZiAoJHRhcmdldC5jbG9zZXN0KGFjdGlvbnMuZWwpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgYWN0aW9ucy5wYXJhbXMuY2xvc2VCeUJhY2tkcm9wQ2xpY2sgJiZcbiAgICAgICAgICBhY3Rpb25zLnBhcmFtcy5iYWNrZHJvcCAmJlxuICAgICAgICAgIGFjdGlvbnMuYmFja2Ryb3BFbCAmJlxuICAgICAgICAgIGFjdGlvbnMuYmFja2Ryb3BFbCA9PT0gdGFyZ2V0XG4gICAgICAgICkge1xuICAgICAgICAgIGFjdGlvbnMuY2xvc2UoKTtcbiAgICAgICAgfSBlbHNlIGlmIChhY3Rpb25zLnBhcmFtcy5jbG9zZUJ5T3V0c2lkZUNsaWNrKSB7XG4gICAgICAgICAgYWN0aW9ucy5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgYWN0aW9ucy5vbignb3BlbmVkJywgKCkgPT4ge1xuICAgICAgaWYgKGFjdGlvbnMucGFyYW1zLmNsb3NlQnlCYWNrZHJvcENsaWNrIHx8IGFjdGlvbnMucGFyYW1zLmNsb3NlQnlPdXRzaWRlQ2xpY2spIHtcbiAgICAgICAgYXBwLm9uKCdjbGljaycsIGhhbmRsZUNsaWNrKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBhY3Rpb25zLm9uKCdjbG9zZScsICgpID0+IHtcbiAgICAgIGlmIChhY3Rpb25zLnBhcmFtcy5jbG9zZUJ5QmFja2Ryb3BDbGljayB8fCBhY3Rpb25zLnBhcmFtcy5jbG9zZUJ5T3V0c2lkZUNsaWNrKSB7XG4gICAgICAgIGFwcC5vZmYoJ2NsaWNrJywgaGFuZGxlQ2xpY2spO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKCRlbCkge1xuICAgICAgJGVsWzBdLmY3TW9kYWwgPSBhY3Rpb25zO1xuICAgIH1cblxuICAgIHJldHVybiBhY3Rpb25zO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCBhY3Rpb25zID0gdGhpcztcbiAgICBpZiAoYWN0aW9ucy5wYXJhbXMucmVuZGVyKSByZXR1cm4gYWN0aW9ucy5wYXJhbXMucmVuZGVyLmNhbGwoYWN0aW9ucywgYWN0aW9ucyk7XG4gICAgY29uc3QgeyBncm91cHMgfSA9IGFjdGlvbnM7XG4gICAgcmV0dXJuIGBcbiAgICAgIDxkaXYgY2xhc3M9XCJhY3Rpb25zLW1vZGFsJHthY3Rpb25zLnBhcmFtcy5ncmlkID8gJyBhY3Rpb25zLWdyaWQnIDogJyd9XCI+XG4gICAgICAgICR7Z3JvdXBzLm1hcChncm91cCA9PlxuICAgICAgICAgIGA8ZGl2IGNsYXNzPVwiYWN0aW9ucy1ncm91cFwiPlxuICAgICAgICAgICAgJHtncm91cC5tYXAoKGJ1dHRvbikgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBidXR0b25DbGFzc2VzID0gW2BhY3Rpb25zLSR7YnV0dG9uLmxhYmVsID8gJ2xhYmVsJyA6ICdidXR0b24nfWBdO1xuICAgICAgICAgICAgICBjb25zdCB7IGNvbG9yLCBiZywgYm9sZCwgZGlzYWJsZWQsIGxhYmVsLCB0ZXh0LCBpY29uIH0gPSBidXR0b247XG4gICAgICAgICAgICAgIGlmIChjb2xvcikgYnV0dG9uQ2xhc3Nlcy5wdXNoKGBjb2xvci0ke2NvbG9yfWApO1xuICAgICAgICAgICAgICBpZiAoYmcpIGJ1dHRvbkNsYXNzZXMucHVzaChgYmctY29sb3ItJHtiZ31gKTtcbiAgICAgICAgICAgICAgaWYgKGJvbGQpIGJ1dHRvbkNsYXNzZXMucHVzaCgnYWN0aW9ucy1idXR0b24tYm9sZCcpO1xuICAgICAgICAgICAgICBpZiAoZGlzYWJsZWQpIGJ1dHRvbkNsYXNzZXMucHVzaCgnZGlzYWJsZWQnKTtcbiAgICAgICAgICAgICAgaWYgKGxhYmVsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGA8ZGl2IGNsYXNzPVwiJHtidXR0b25DbGFzc2VzLmpvaW4oJyAnKX1cIj4ke3RleHR9PC9kaXY+YDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gYFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCIke2J1dHRvbkNsYXNzZXMuam9pbignICcpfVwiPlxuICAgICAgICAgICAgICAgICAgJHtpY29uID8gYDxkaXYgY2xhc3M9XCJhY3Rpb25zLWJ1dHRvbi1tZWRpYVwiPiR7aWNvbn08L2Rpdj5gIDogJyd9XG4gICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiYWN0aW9ucy1idXR0b24tdGV4dFwiPiR7dGV4dH08L2Rpdj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5gLnRyaW0oKTtcbiAgICAgICAgICAgIH0pLmpvaW4oJycpfVxuICAgICAgICAgIDwvZGl2PmApLmpvaW4oJycpfVxuICAgICAgPC9kaXY+XG4gICAgYC50cmltKCk7XG4gIH1cbiAgcmVuZGVyUG9wb3ZlcigpIHtcbiAgICBjb25zdCBhY3Rpb25zID0gdGhpcztcbiAgICBpZiAoYWN0aW9ucy5wYXJhbXMucmVuZGVyUG9wb3ZlcikgcmV0dXJuIGFjdGlvbnMucGFyYW1zLnJlbmRlclBvcG92ZXIuY2FsbChhY3Rpb25zLCBhY3Rpb25zKTtcbiAgICBjb25zdCB7IGdyb3VwcyB9ID0gYWN0aW9ucztcbiAgICByZXR1cm4gYFxuICAgICAgPGRpdiBjbGFzcz1cInBvcG92ZXIgcG9wb3Zlci1mcm9tLWFjdGlvbnNcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cInBvcG92ZXItaW5uZXJcIj5cbiAgICAgICAgICAke2dyb3Vwcy5tYXAoZ3JvdXAgPT4gYFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImxpc3RcIj5cbiAgICAgICAgICAgICAgPHVsPlxuICAgICAgICAgICAgICAgICR7Z3JvdXAubWFwKChidXR0b24pID0+IHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW1DbGFzc2VzID0gW107XG4gICAgICAgICAgICAgICAgICBjb25zdCB7IGNvbG9yLCBiZywgYm9sZCwgZGlzYWJsZWQsIGxhYmVsLCB0ZXh0LCBpY29uIH0gPSBidXR0b247XG4gICAgICAgICAgICAgICAgICBpZiAoY29sb3IpIGl0ZW1DbGFzc2VzLnB1c2goYGNvbG9yLSR7Y29sb3J9YCk7XG4gICAgICAgICAgICAgICAgICBpZiAoYmcpIGl0ZW1DbGFzc2VzLnB1c2goYGJnLWNvbG9yLSR7Ymd9YCk7XG4gICAgICAgICAgICAgICAgICBpZiAoYm9sZCkgaXRlbUNsYXNzZXMucHVzaCgncG9wb3Zlci1mcm9tLWFjdGlvbnMtYm9sZCcpO1xuICAgICAgICAgICAgICAgICAgaWYgKGRpc2FibGVkKSBpdGVtQ2xhc3Nlcy5wdXNoKCdkaXNhYmxlZCcpO1xuICAgICAgICAgICAgICAgICAgaWYgKGxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW1DbGFzc2VzLnB1c2goJ3BvcG92ZXItZnJvbS1hY3Rpb25zLWxhYmVsJyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBgPGxpIGNsYXNzPVwiJHtpdGVtQ2xhc3Nlcy5qb2luKCcgJyl9XCI+JHt0ZXh0fTwvbGk+YDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGl0ZW1DbGFzc2VzLnB1c2goJ2l0ZW0tbGluaycpO1xuICAgICAgICAgICAgICAgICAgaWYgKGljb24pIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbUNsYXNzZXMucHVzaCgnaXRlbS1jb250ZW50Jyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBgXG4gICAgICAgICAgICAgICAgICAgICAgPGxpPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGEgY2xhc3M9XCIke2l0ZW1DbGFzc2VzLmpvaW4oJyAnKX1cIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIml0ZW0tbWVkaWFcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAke2ljb259XG4gICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiaXRlbS1pbm5lclwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJpdGVtLXRpdGxlXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAke3RleHR9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9hPlxuICAgICAgICAgICAgICAgICAgICAgIDwvbGk+XG4gICAgICAgICAgICAgICAgICAgIGA7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpdGVtQ2xhc3Nlcy5wdXNoKCdsaXN0LWJ1dHRvbicpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGBcbiAgICAgICAgICAgICAgICAgICAgPGxpPlxuICAgICAgICAgICAgICAgICAgICAgIDxhIGhyZWY9XCIjXCIgY2xhc3M9XCJsaXN0LWJ1dHRvbiAke2l0ZW1DbGFzc2VzLmpvaW4oJyAnKX1cIj4ke3RleHR9PC9hPlxuICAgICAgICAgICAgICAgICAgICA8L2xpPlxuICAgICAgICAgICAgICAgICAgYDtcbiAgICAgICAgICAgICAgICB9KS5qb2luKCcnKX1cbiAgICAgICAgICAgICAgPC91bD5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIGApLmpvaW4oJycpfVxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIGAudHJpbSgpO1xuICB9XG59XG5cbnZhciBBY3Rpb25zJDEgPSB7XG4gIG5hbWU6ICdhY3Rpb25zJyxcbiAgcGFyYW1zOiB7XG4gICAgYWN0aW9uczoge1xuICAgICAgY29udmVydFRvUG9wb3ZlcjogdHJ1ZSxcbiAgICAgIGZvcmNlVG9Qb3BvdmVyOiBmYWxzZSxcbiAgICAgIGNsb3NlQnlCYWNrZHJvcENsaWNrOiB0cnVlLFxuICAgICAgcmVuZGVyOiBudWxsLFxuICAgICAgcmVuZGVyUG9wb3ZlcjogbnVsbCxcbiAgICAgIGJhY2tkcm9wOiB0cnVlLFxuICAgIH0sXG4gIH0sXG4gIHN0YXRpYzoge1xuICAgIEFjdGlvbnMsXG4gIH0sXG4gIGNyZWF0ZSgpIHtcbiAgICBjb25zdCBhcHAgPSB0aGlzO1xuICAgIGFwcC5hY3Rpb25zID0gTW9kYWxNZXRob2RzKHtcbiAgICAgIGFwcCxcbiAgICAgIGNvbnN0cnVjdG9yOiBBY3Rpb25zLFxuICAgICAgZGVmYXVsdFNlbGVjdG9yOiAnLmFjdGlvbnMtbW9kYWwubW9kYWwtaW4nLFxuICAgIH0pO1xuICB9LFxuICBjbGlja3M6IHtcbiAgICAnLmFjdGlvbnMtb3Blbic6IGZ1bmN0aW9uIG9wZW5BY3Rpb25zKCRjbGlja2VkRWwsIGRhdGEgPSB7fSkge1xuICAgICAgY29uc3QgYXBwID0gdGhpcztcbiAgICAgIGFwcC5hY3Rpb25zLm9wZW4oZGF0YS5hY3Rpb25zLCBkYXRhLmFuaW1hdGUpO1xuICAgIH0sXG4gICAgJy5hY3Rpb25zLWNsb3NlJzogZnVuY3Rpb24gY2xvc2VBY3Rpb25zKCRjbGlja2VkRWwsIGRhdGEgPSB7fSkge1xuICAgICAgY29uc3QgYXBwID0gdGhpcztcbiAgICAgIGFwcC5hY3Rpb25zLmNsb3NlKGRhdGEuYWN0aW9ucywgZGF0YS5hbmltYXRlKTtcbiAgICB9LFxuICB9LFxufTtcblxuY2xhc3MgU2hlZXQgZXh0ZW5kcyBNb2RhbCB7XG4gIGNvbnN0cnVjdG9yKGFwcCwgcGFyYW1zKSB7XG4gICAgY29uc3QgZXh0ZW5kZWRQYXJhbXMgPSBVdGlscy5leHRlbmQoXG4gICAgICB7IG9uOiB7fSB9LFxuICAgICAgYXBwLnBhcmFtcy5zaGVldCxcbiAgICAgIHBhcmFtc1xuICAgICk7XG5cbiAgICAvLyBFeHRlbmRzIHdpdGggb3Blbi9jbG9zZSBNb2RhbCBtZXRob2RzO1xuICAgIHN1cGVyKGFwcCwgZXh0ZW5kZWRQYXJhbXMpO1xuXG4gICAgY29uc3Qgc2hlZXQgPSB0aGlzO1xuXG4gICAgc2hlZXQucGFyYW1zID0gZXh0ZW5kZWRQYXJhbXM7XG5cbiAgICAvLyBGaW5kIEVsZW1lbnRcbiAgICBsZXQgJGVsO1xuICAgIGlmICghc2hlZXQucGFyYW1zLmVsKSB7XG4gICAgICAkZWwgPSAkKHNoZWV0LnBhcmFtcy5jb250ZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgJGVsID0gJChzaGVldC5wYXJhbXMuZWwpO1xuICAgIH1cblxuICAgIGlmICgkZWwgJiYgJGVsLmxlbmd0aCA+IDAgJiYgJGVsWzBdLmY3TW9kYWwpIHtcbiAgICAgIHJldHVybiAkZWxbMF0uZjdNb2RhbDtcbiAgICB9XG5cbiAgICBpZiAoJGVsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHNoZWV0LmRlc3Ryb3koKTtcbiAgICB9XG4gICAgbGV0ICRiYWNrZHJvcEVsO1xuICAgIGlmIChzaGVldC5wYXJhbXMuYmFja2Ryb3ApIHtcbiAgICAgICRiYWNrZHJvcEVsID0gYXBwLnJvb3QuY2hpbGRyZW4oJy5zaGVldC1iYWNrZHJvcCcpO1xuICAgICAgaWYgKCRiYWNrZHJvcEVsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAkYmFja2Ryb3BFbCA9ICQoJzxkaXYgY2xhc3M9XCJzaGVldC1iYWNrZHJvcFwiPjwvZGl2PicpO1xuICAgICAgICBhcHAucm9vdC5hcHBlbmQoJGJhY2tkcm9wRWwpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxldCAkcGFnZUNvbnRlbnRFbDtcbiAgICBmdW5jdGlvbiBzY3JvbGxUb09wZW4oKSB7XG4gICAgICBjb25zdCAkc2Nyb2xsRWwgPSAkKHNoZWV0LnBhcmFtcy5zY3JvbGxUb0VsKS5lcSgwKTtcbiAgICAgIGlmICgkc2Nyb2xsRWwubGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgICAkcGFnZUNvbnRlbnRFbCA9ICRzY3JvbGxFbC5wYXJlbnRzKCcucGFnZS1jb250ZW50Jyk7XG4gICAgICBpZiAoJHBhZ2VDb250ZW50RWwubGVuZ3RoID09PSAwKSByZXR1cm47XG5cbiAgICAgIGNvbnN0IHBhZGRpbmdUb3AgPSBwYXJzZUludCgkcGFnZUNvbnRlbnRFbC5jc3MoJ3BhZGRpbmctdG9wJyksIDEwKTtcbiAgICAgIGNvbnN0IHBhZGRpbmdCb3R0b20gPSBwYXJzZUludCgkcGFnZUNvbnRlbnRFbC5jc3MoJ3BhZGRpbmctYm90dG9tJyksIDEwKTtcbiAgICAgIGNvbnN0IHBhZ2VIZWlnaHQgPSAkcGFnZUNvbnRlbnRFbFswXS5vZmZzZXRIZWlnaHQgLSBwYWRkaW5nVG9wIC0gJGVsLmhlaWdodCgpO1xuICAgICAgY29uc3QgcGFnZVNjcm9sbEhlaWdodCA9ICRwYWdlQ29udGVudEVsWzBdLnNjcm9sbEhlaWdodCAtIHBhZGRpbmdUb3AgLSAkZWwuaGVpZ2h0KCk7XG4gICAgICBjb25zdCBwYWdlU2Nyb2xsID0gJHBhZ2VDb250ZW50RWwuc2Nyb2xsVG9wKCk7XG5cbiAgICAgIGxldCBuZXdQYWRkaW5nQm90dG9tO1xuXG4gICAgICBjb25zdCBzY3JvbGxFbFRvcCA9ICgkc2Nyb2xsRWwub2Zmc2V0KCkudG9wIC0gcGFkZGluZ1RvcCkgKyAkc2Nyb2xsRWxbMF0ub2Zmc2V0SGVpZ2h0O1xuICAgICAgaWYgKHNjcm9sbEVsVG9wID4gcGFnZUhlaWdodCkge1xuICAgICAgICBjb25zdCBzY3JvbGxUb3AgPSAocGFnZVNjcm9sbCArIHNjcm9sbEVsVG9wKSAtIHBhZ2VIZWlnaHQ7XG4gICAgICAgIGlmIChzY3JvbGxUb3AgKyBwYWdlSGVpZ2h0ID4gcGFnZVNjcm9sbEhlaWdodCkge1xuICAgICAgICAgIG5ld1BhZGRpbmdCb3R0b20gPSAoKHNjcm9sbFRvcCArIHBhZ2VIZWlnaHQpIC0gcGFnZVNjcm9sbEhlaWdodCkgKyBwYWRkaW5nQm90dG9tO1xuICAgICAgICAgIGlmIChwYWdlSGVpZ2h0ID09PSBwYWdlU2Nyb2xsSGVpZ2h0KSB7XG4gICAgICAgICAgICBuZXdQYWRkaW5nQm90dG9tID0gJGVsLmhlaWdodCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAkcGFnZUNvbnRlbnRFbC5jc3Moe1xuICAgICAgICAgICAgJ3BhZGRpbmctYm90dG9tJzogYCR7bmV3UGFkZGluZ0JvdHRvbX1weGAsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgJHBhZ2VDb250ZW50RWwuc2Nyb2xsVG9wKHNjcm9sbFRvcCwgMzAwKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzY3JvbGxUb0Nsb3NlKCkge1xuICAgICAgaWYgKCRwYWdlQ29udGVudEVsICYmICRwYWdlQ29udGVudEVsLmxlbmd0aCA+IDApIHtcbiAgICAgICAgJHBhZ2VDb250ZW50RWwuY3NzKHtcbiAgICAgICAgICAncGFkZGluZy1ib3R0b20nOiAnJyxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhbmRsZUNsaWNrKGUpIHtcbiAgICAgIGNvbnN0IHRhcmdldCA9IGUudGFyZ2V0O1xuICAgICAgY29uc3QgJHRhcmdldCA9ICQodGFyZ2V0KTtcbiAgICAgIGlmICgkdGFyZ2V0LmNsb3Nlc3Qoc2hlZXQuZWwpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgc2hlZXQucGFyYW1zLmNsb3NlQnlCYWNrZHJvcENsaWNrICYmXG4gICAgICAgICAgc2hlZXQucGFyYW1zLmJhY2tkcm9wICYmXG4gICAgICAgICAgc2hlZXQuYmFja2Ryb3BFbCAmJlxuICAgICAgICAgIHNoZWV0LmJhY2tkcm9wRWwgPT09IHRhcmdldFxuICAgICAgICApIHtcbiAgICAgICAgICBzaGVldC5jbG9zZSgpO1xuICAgICAgICB9IGVsc2UgaWYgKHNoZWV0LnBhcmFtcy5jbG9zZUJ5T3V0c2lkZUNsaWNrKSB7XG4gICAgICAgICAgc2hlZXQuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHNoZWV0Lm9uKCdzaGVldE9wZW4nLCAoKSA9PiB7XG4gICAgICBpZiAoc2hlZXQucGFyYW1zLnNjcm9sbFRvRWwpIHtcbiAgICAgICAgc2Nyb2xsVG9PcGVuKCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgc2hlZXQub24oJ3NoZWV0T3BlbmVkJywgKCkgPT4ge1xuICAgICAgaWYgKHNoZWV0LnBhcmFtcy5jbG9zZUJ5T3V0c2lkZUNsaWNrIHx8IHNoZWV0LnBhcmFtcy5jbG9zZUJ5QmFja2Ryb3BDbGljaykge1xuICAgICAgICBhcHAub24oJ2NsaWNrJywgaGFuZGxlQ2xpY2spO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHNoZWV0Lm9uKCdzaGVldENsb3NlJywgKCkgPT4ge1xuICAgICAgaWYgKHNoZWV0LnBhcmFtcy5zY3JvbGxUb0VsKSB7XG4gICAgICAgIHNjcm9sbFRvQ2xvc2UoKTtcbiAgICAgIH1cbiAgICAgIGlmIChzaGVldC5wYXJhbXMuY2xvc2VCeU91dHNpZGVDbGljayB8fCBzaGVldC5wYXJhbXMuY2xvc2VCeUJhY2tkcm9wQ2xpY2spIHtcbiAgICAgICAgYXBwLm9mZignY2xpY2snLCBoYW5kbGVDbGljayk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBVdGlscy5leHRlbmQoc2hlZXQsIHtcbiAgICAgIGFwcCxcbiAgICAgICRlbCxcbiAgICAgIGVsOiAkZWxbMF0sXG4gICAgICAkYmFja2Ryb3BFbCxcbiAgICAgIGJhY2tkcm9wRWw6ICRiYWNrZHJvcEVsICYmICRiYWNrZHJvcEVsWzBdLFxuICAgICAgdHlwZTogJ3NoZWV0JyxcbiAgICB9KTtcblxuICAgICRlbFswXS5mN01vZGFsID0gc2hlZXQ7XG5cbiAgICByZXR1cm4gc2hlZXQ7XG4gIH1cbn1cblxudmFyIFNoZWV0JDEgPSB7XG4gIG5hbWU6ICdzaGVldCcsXG4gIHBhcmFtczoge1xuICAgIHNoZWV0OiB7XG4gICAgICBjbG9zZUJ5QmFja2Ryb3BDbGljazogdHJ1ZSxcbiAgICAgIGNsb3NlQnlPdXRzaWRlQ2xpY2s6IGZhbHNlLFxuICAgIH0sXG4gIH0sXG4gIHN0YXRpYzoge1xuICAgIFNoZWV0LFxuICB9LFxuICBjcmVhdGUoKSB7XG4gICAgY29uc3QgYXBwID0gdGhpcztcbiAgICBpZiAoIWFwcC5wYXNzZWRQYXJhbXMuc2hlZXQgfHwgYXBwLnBhc3NlZFBhcmFtcy5zaGVldC5iYWNrZHJvcCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBhcHAucGFyYW1zLnNoZWV0LmJhY2tkcm9wID0gYXBwLnRoZW1lID09PSAnbWQnO1xuICAgIH1cbiAgICBhcHAuc2hlZXQgPSBVdGlscy5leHRlbmQoXG4gICAgICB7fSxcbiAgICAgIE1vZGFsTWV0aG9kcyh7XG4gICAgICAgIGFwcCxcbiAgICAgICAgY29uc3RydWN0b3I6IFNoZWV0LFxuICAgICAgICBkZWZhdWx0U2VsZWN0b3I6ICcuc2hlZXQtbW9kYWwubW9kYWwtaW4nLFxuICAgICAgfSlcbiAgICApO1xuICB9LFxuICBjbGlja3M6IHtcbiAgICAnLnNoZWV0LW9wZW4nOiBmdW5jdGlvbiBvcGVuU2hlZXQoJGNsaWNrZWRFbCwgZGF0YSA9IHt9KSB7XG4gICAgICBjb25zdCBhcHAgPSB0aGlzO1xuICAgICAgaWYgKCQoJy5zaGVldC1tb2RhbC5tb2RhbC1pbicpLmxlbmd0aCA+IDAgJiYgZGF0YS5zaGVldCAmJiAkKGRhdGEuc2hlZXQpWzBdICE9PSAkKCcuc2hlZXQtbW9kYWwubW9kYWwtaW4nKVswXSkge1xuICAgICAgICBhcHAuc2hlZXQuY2xvc2UoJy5zaGVldC1tb2RhbC5tb2RhbC1pbicpO1xuICAgICAgfVxuICAgICAgYXBwLnNoZWV0Lm9wZW4oZGF0YS5zaGVldCwgZGF0YS5hbmltYXRlKTtcbiAgICB9LFxuICAgICcuc2hlZXQtY2xvc2UnOiBmdW5jdGlvbiBjbG9zZVNoZWV0KCRjbGlja2VkRWwsIGRhdGEgPSB7fSkge1xuICAgICAgY29uc3QgYXBwID0gdGhpcztcbiAgICAgIGFwcC5zaGVldC5jbG9zZShkYXRhLnNoZWV0LCBkYXRhLmFuaW1hdGUpO1xuICAgIH0sXG4gIH0sXG59O1xuXG5jbGFzcyBUb2FzdCBleHRlbmRzIE1vZGFsIHtcbiAgY29uc3RydWN0b3IoYXBwLCBwYXJhbXMpIHtcbiAgICBjb25zdCBleHRlbmRlZFBhcmFtcyA9IFV0aWxzLmV4dGVuZCh7XG4gICAgICBvbjoge30sXG4gICAgfSwgYXBwLnBhcmFtcy50b2FzdCwgcGFyYW1zKTtcblxuICAgIC8vIEV4dGVuZHMgd2l0aCBvcGVuL2Nsb3NlIE1vZGFsIG1ldGhvZHM7XG4gICAgc3VwZXIoYXBwLCBleHRlbmRlZFBhcmFtcyk7XG5cbiAgICBjb25zdCB0b2FzdCA9IHRoaXM7XG5cbiAgICB0b2FzdC5hcHAgPSBhcHA7XG5cbiAgICB0b2FzdC5wYXJhbXMgPSBleHRlbmRlZFBhcmFtcztcblxuICAgIGNvbnN0IHsgY2xvc2VCdXR0b24sIGNsb3NlVGltZW91dCB9ID0gdG9hc3QucGFyYW1zO1xuXG4gICAgbGV0ICRlbDtcbiAgICBpZiAoIXRvYXN0LnBhcmFtcy5lbCkge1xuICAgICAgLy8gRmluZCBFbGVtZW50XG4gICAgICBjb25zdCB0b2FzdEh0bWwgPSB0b2FzdC5yZW5kZXIoKTtcblxuICAgICAgJGVsID0gJCh0b2FzdEh0bWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICAkZWwgPSAkKHRvYXN0LnBhcmFtcy5lbCk7XG4gICAgfVxuXG4gICAgaWYgKCRlbCAmJiAkZWwubGVuZ3RoID4gMCAmJiAkZWxbMF0uZjdNb2RhbCkge1xuICAgICAgcmV0dXJuICRlbFswXS5mN01vZGFsO1xuICAgIH1cblxuICAgIGlmICgkZWwubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdG9hc3QuZGVzdHJveSgpO1xuICAgIH1cblxuICAgIFV0aWxzLmV4dGVuZCh0b2FzdCwge1xuICAgICAgJGVsLFxuICAgICAgZWw6ICRlbFswXSxcbiAgICAgIHR5cGU6ICd0b2FzdCcsXG4gICAgfSk7XG5cbiAgICAkZWxbMF0uZjdNb2RhbCA9IHRvYXN0O1xuXG4gICAgaWYgKGNsb3NlQnV0dG9uKSB7XG4gICAgICAkZWwuZmluZCgnLnRvYXN0LWJ1dHRvbicpLm9uKCdjbGljaycsICgpID0+IHtcbiAgICAgICAgdG9hc3QuZW1pdCgnbG9jYWw6OmNsb3NlQnV0dG9uQ2xpY2sgdG9hc3RDbG9zZUJ1dHRvbkNsaWNrJywgdG9hc3QpO1xuICAgICAgICB0b2FzdC5jbG9zZSgpO1xuICAgICAgfSk7XG5cbiAgICAgIHRvYXN0Lm9uKCdiZWZvcmVEZXN0cm95JywgKCkgPT4ge1xuICAgICAgICAkZWwuZmluZCgnLnRvYXN0LWJ1dHRvbicpLm9mZignY2xpY2snKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGxldCB0aW1lb3V0SWQ7XG4gICAgdG9hc3Qub24oJ29wZW4nLCAoKSA9PiB7XG4gICAgICAkKCcudG9hc3QubW9kYWwtaW4nKS5lYWNoKChpbmRleCwgb3BlbmVkRWwpID0+IHtcbiAgICAgICAgY29uc3QgdG9hc3RJbnN0YW5jZSA9IGFwcC50b2FzdC5nZXQob3BlbmVkRWwpO1xuICAgICAgICBpZiAob3BlbmVkRWwgIT09IHRvYXN0LmVsICYmIHRvYXN0SW5zdGFuY2UpIHtcbiAgICAgICAgICB0b2FzdEluc3RhbmNlLmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKGNsb3NlVGltZW91dCkge1xuICAgICAgICB0aW1lb3V0SWQgPSBVdGlscy5uZXh0VGljaygoKSA9PiB7XG4gICAgICAgICAgdG9hc3QuY2xvc2UoKTtcbiAgICAgICAgfSwgY2xvc2VUaW1lb3V0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0b2FzdC5vbignY2xvc2UnLCAoKSA9PiB7XG4gICAgICB3aW5kb3ckMS5jbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICB9KTtcblxuICAgIGlmICh0b2FzdC5wYXJhbXMuZGVzdHJveU9uQ2xvc2UpIHtcbiAgICAgIHRvYXN0Lm9uY2UoJ2Nsb3NlZCcsICgpID0+IHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgdG9hc3QuZGVzdHJveSgpO1xuICAgICAgICB9LCAwKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB0b2FzdDtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgdG9hc3QgPSB0aGlzO1xuICAgIGNvbnN0IGFwcCA9IHRvYXN0LmFwcDtcbiAgICBpZiAodG9hc3QucGFyYW1zLnJlbmRlcikgcmV0dXJuIHRvYXN0LnBhcmFtcy5yZW5kZXIuY2FsbCh0b2FzdCwgdG9hc3QpO1xuICAgIGNvbnN0IHsgcG9zaXRpb24sIGNzc0NsYXNzLCBpY29uLCB0ZXh0LCBjbG9zZUJ1dHRvbiwgY2xvc2VCdXR0b25Db2xvciwgY2xvc2VCdXR0b25UZXh0IH0gPSB0b2FzdC5wYXJhbXM7XG4gICAgcmV0dXJuIGBcbiAgICAgIDxkaXYgY2xhc3M9XCJ0b2FzdCB0b2FzdC0ke3Bvc2l0aW9ufSAke2Nzc0NsYXNzIHx8ICcnfSAke2ljb24gPyAndG9hc3Qtd2l0aC1pY29uJyA6ICcnfVwiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwidG9hc3QtY29udGVudFwiPlxuICAgICAgICAgICR7aWNvbiA/IGA8ZGl2IGNsYXNzPVwidG9hc3QtaWNvblwiPiR7aWNvbn08L2Rpdj5gIDogJyd9XG4gICAgICAgICAgPGRpdiBjbGFzcz1cInRvYXN0LXRleHRcIj4ke3RleHR9PC9kaXY+XG4gICAgICAgICAgJHtjbG9zZUJ1dHRvbiAmJiAhaWNvbiA/IGBcbiAgICAgICAgICA8YSBjbGFzcz1cInRvYXN0LWJ1dHRvbiAke2FwcC50aGVtZSA9PT0gJ21kJyA/ICdidXR0b24nIDogJ2xpbmsnfSAke2Nsb3NlQnV0dG9uQ29sb3IgPyBgY29sb3ItJHtjbG9zZUJ1dHRvbkNvbG9yfWAgOiAnJ31cIj4ke2Nsb3NlQnV0dG9uVGV4dH08L2E+XG4gICAgICAgICAgYC50cmltKCkgOiAnJ31cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICBgLnRyaW0oKTtcbiAgfVxufVxuXG52YXIgVG9hc3QkMSA9IHtcbiAgbmFtZTogJ3RvYXN0JyxcbiAgc3RhdGljOiB7XG4gICAgVG9hc3QsXG4gIH0sXG4gIGNyZWF0ZSgpIHtcbiAgICBjb25zdCBhcHAgPSB0aGlzO1xuICAgIGFwcC50b2FzdCA9IFV0aWxzLmV4dGVuZChcbiAgICAgIHt9LFxuICAgICAgTW9kYWxNZXRob2RzKHtcbiAgICAgICAgYXBwLFxuICAgICAgICBjb25zdHJ1Y3RvcjogVG9hc3QsXG4gICAgICAgIGRlZmF1bHRTZWxlY3RvcjogJy50b2FzdC5tb2RhbC1pbicsXG4gICAgICB9KSxcbiAgICAgIHtcbiAgICAgICAgLy8gU2hvcnRjdXRzXG4gICAgICAgIHNob3cocGFyYW1zKSB7XG4gICAgICAgICAgVXRpbHMuZXh0ZW5kKHBhcmFtcywge1xuICAgICAgICAgICAgZGVzdHJveU9uQ2xvc2U6IHRydWUsXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIG5ldyBUb2FzdChhcHAsIHBhcmFtcykub3BlbigpO1xuICAgICAgICB9LFxuICAgICAgfVxuICAgICk7XG4gIH0sXG4gIHBhcmFtczoge1xuICAgIHRvYXN0OiB7XG4gICAgICBpY29uOiBudWxsLFxuICAgICAgdGV4dDogbnVsbCxcbiAgICAgIHBvc2l0aW9uOiAnYm90dG9tJyxcbiAgICAgIGNsb3NlQnV0dG9uOiBmYWxzZSxcbiAgICAgIGNsb3NlQnV0dG9uQ29sb3I6IG51bGwsXG4gICAgICBjbG9zZUJ1dHRvblRleHQ6ICdPaycsXG4gICAgICBjbG9zZVRpbWVvdXQ6IG51bGwsXG4gICAgICBjc3NDbGFzczogbnVsbCxcbiAgICAgIHJlbmRlcjogbnVsbCxcbiAgICB9LFxuICB9LFxufTtcblxuY29uc3QgUHJlbG9hZGVyID0ge1xuICBpbml0KGVsKSB7XG4gICAgY29uc3QgYXBwID0gdGhpcztcbiAgICBpZiAoYXBwLnRoZW1lICE9PSAnbWQnKSByZXR1cm47XG4gICAgY29uc3QgJGVsID0gJChlbCk7XG4gICAgaWYgKCRlbC5sZW5ndGggPT09IDAgfHwgJGVsLmNoaWxkcmVuKCcucHJlbG9hZGVyLWlubmVyJykubGVuZ3RoID4gMCkgcmV0dXJuO1xuICAgICRlbC5hcHBlbmQoVXRpbHMubWRQcmVsb2FkZXJDb250ZW50KTtcbiAgfSxcbiAgLy8gTW9kYWxcbiAgdmlzaWJsZTogZmFsc2UsXG4gIHNob3coY29sb3IgPSAnd2hpdGUnKSB7XG4gICAgY29uc3QgYXBwID0gdGhpcztcbiAgICBpZiAoUHJlbG9hZGVyLnZpc2libGUpIHJldHVybjtcbiAgICBjb25zdCBwcmVsb2FkZXJJbm5lciA9IGFwcC50aGVtZSAhPT0gJ21kJyA/ICcnIDogVXRpbHMubWRQcmVsb2FkZXJDb250ZW50O1xuICAgICQoJ2h0bWwnKS5hZGRDbGFzcygnd2l0aC1tb2RhbC1wcmVsb2FkZXInKTtcbiAgICBhcHAucm9vdC5hcHBlbmQoYFxuICAgICAgPGRpdiBjbGFzcz1cInByZWxvYWRlci1iYWNrZHJvcFwiPjwvZGl2PlxuICAgICAgPGRpdiBjbGFzcz1cInByZWxvYWRlci1tb2RhbFwiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwicHJlbG9hZGVyIGNvbG9yLSR7Y29sb3J9XCI+JHtwcmVsb2FkZXJJbm5lcn08L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIGApO1xuICAgIFByZWxvYWRlci52aXNpYmxlID0gdHJ1ZTtcbiAgfSxcbiAgaGlkZSgpIHtcbiAgICBjb25zdCBhcHAgPSB0aGlzO1xuICAgIGlmICghUHJlbG9hZGVyLnZpc2libGUpIHJldHVybjtcbiAgICAkKCdodG1sJykucmVtb3ZlQ2xhc3MoJ3dpdGgtbW9kYWwtcHJlbG9hZGVyJyk7XG4gICAgYXBwLnJvb3QuZmluZCgnLnByZWxvYWRlci1iYWNrZHJvcCwgLnByZWxvYWRlci1tb2RhbCcpLnJlbW92ZSgpO1xuICAgIFByZWxvYWRlci52aXNpYmxlID0gZmFsc2U7XG4gIH0sXG59O1xudmFyIFByZWxvYWRlciQxID0ge1xuICBuYW1lOiAncHJlbG9hZGVyJyxcbiAgY3JlYXRlKCkge1xuICAgIGNvbnN0IGFwcCA9IHRoaXM7XG4gICAgVXRpbHMuZXh0ZW5kKGFwcCwge1xuICAgICAgcHJlbG9hZGVyOiB7XG4gICAgICAgIGluaXQ6IFByZWxvYWRlci5pbml0LmJpbmQoYXBwKSxcbiAgICAgICAgc2hvdzogUHJlbG9hZGVyLnNob3cuYmluZChhcHApLFxuICAgICAgICBoaWRlOiBQcmVsb2FkZXIuaGlkZS5iaW5kKGFwcCksXG4gICAgICB9LFxuICAgIH0pO1xuICB9LFxuICBvbjoge1xuICAgIHBob3RvQnJvd3Nlck9wZW4ocGIpIHtcbiAgICAgIGNvbnN0IGFwcCA9IHRoaXM7XG4gICAgICBpZiAoYXBwLnRoZW1lICE9PSAnbWQnKSByZXR1cm47XG4gICAgICBwYi4kZWwuZmluZCgnLnByZWxvYWRlcicpLmVhY2goKGluZGV4LCBwcmVsb2FkZXJFbCkgPT4ge1xuICAgICAgICBhcHAucHJlbG9hZGVyLmluaXQocHJlbG9hZGVyRWwpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBwYWdlSW5pdChwYWdlKSB7XG4gICAgICBjb25zdCBhcHAgPSB0aGlzO1xuICAgICAgaWYgKGFwcC50aGVtZSAhPT0gJ21kJykgcmV0dXJuO1xuICAgICAgcGFnZS4kZWwuZmluZCgnLnByZWxvYWRlcicpLmVhY2goKGluZGV4LCBwcmVsb2FkZXJFbCkgPT4ge1xuICAgICAgICBhcHAucHJlbG9hZGVyLmluaXQocHJlbG9hZGVyRWwpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgfSxcbn07XG5cbmNvbnN0IFByb2dyZXNzYmFyID0ge1xuICBzZXQoLi4uYXJncykge1xuICAgIGNvbnN0IGFwcCA9IHRoaXM7XG4gICAgbGV0IFtlbCwgcHJvZ3Jlc3MsIGR1cmF0aW9uXSA9IGFyZ3M7XG4gICAgaWYgKHR5cGVvZiBhcmdzWzBdID09PSAnbnVtYmVyJykge1xuICAgICAgW3Byb2dyZXNzLCBkdXJhdGlvbl0gPSBhcmdzO1xuICAgICAgZWwgPSBhcHAucm9vdDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBwcm9ncmVzcyA9PT0gJ3VuZGVmaW5lZCcgfHwgcHJvZ3Jlc3MgPT09IG51bGwpIHJldHVybiBlbDtcbiAgICBpZiAoIXByb2dyZXNzKSBwcm9ncmVzcyA9IDA7XG5cbiAgICBjb25zdCAkZWwgPSAkKGVsIHx8IGFwcC5yb290KTtcbiAgICBpZiAoJGVsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGVsO1xuICAgIH1cbiAgICBjb25zdCBwcm9ncmVzc05vcm1hbGl6ZWQgPSBNYXRoLm1pbihNYXRoLm1heChwcm9ncmVzcywgMCksIDEwMCk7XG4gICAgbGV0ICRwcm9ncmVzc2JhckVsO1xuICAgIGlmICgkZWwuaGFzQ2xhc3MoJ3Byb2dyZXNzYmFyJykpICRwcm9ncmVzc2JhckVsID0gJGVsLmVxKDApO1xuICAgIGVsc2Uge1xuICAgICAgJHByb2dyZXNzYmFyRWwgPSAkZWwuY2hpbGRyZW4oJy5wcm9ncmVzc2JhcicpO1xuICAgIH1cbiAgICBpZiAoJHByb2dyZXNzYmFyRWwubGVuZ3RoID09PSAwIHx8ICRwcm9ncmVzc2JhckVsLmhhc0NsYXNzKCdwcm9ncmVzc2Jhci1pbmZpbml0ZScpKSB7XG4gICAgICByZXR1cm4gJHByb2dyZXNzYmFyRWw7XG4gICAgfVxuICAgIGxldCAkcHJvZ3Jlc3NiYXJMaW5lID0gJHByb2dyZXNzYmFyRWwuY2hpbGRyZW4oJ3NwYW4nKTtcbiAgICBpZiAoJHByb2dyZXNzYmFyTGluZS5sZW5ndGggPT09IDApIHtcbiAgICAgICRwcm9ncmVzc2JhckxpbmUgPSAkKCc8c3Bhbj48L3NwYW4+Jyk7XG4gICAgICAkcHJvZ3Jlc3NiYXJFbC5hcHBlbmQoJHByb2dyZXNzYmFyTGluZSk7XG4gICAgfVxuICAgICRwcm9ncmVzc2JhckxpbmVcbiAgICAgIC50cmFuc2l0aW9uKHR5cGVvZiBkdXJhdGlvbiAhPT0gJ3VuZGVmaW5lZCcgPyBkdXJhdGlvbiA6ICcnKVxuICAgICAgLnRyYW5zZm9ybShgdHJhbnNsYXRlM2QoJHsoLTEwMCArIHByb2dyZXNzTm9ybWFsaXplZCl9JSwwLDApYCk7XG5cbiAgICByZXR1cm4gJHByb2dyZXNzYmFyRWxbMF07XG4gIH0sXG4gIHNob3coLi4uYXJncykge1xuICAgIGNvbnN0IGFwcCA9IHRoaXM7XG5cbiAgICAvLyAnLnBhZ2UnLCA1MCwgJ211bHRpJ1xuICAgIGxldCBbZWwsIHByb2dyZXNzLCBjb2xvcl0gPSBhcmdzO1xuICAgIGxldCB0eXBlID0gJ2RldGVybWluZWQnO1xuXG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSAyKSB7XG4gICAgICBpZiAoKHR5cGVvZiBhcmdzWzBdID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgYXJnc1swXSA9PT0gJ29iamVjdCcpICYmIHR5cGVvZiBhcmdzWzFdID09PSAnc3RyaW5nJykge1xuICAgICAgICAvLyAnLnBhZ2UnLCAnbXVsdGknXG4gICAgICAgIFtlbCwgY29sb3IsIHByb2dyZXNzXSA9IGFyZ3M7XG4gICAgICAgIHR5cGUgPSAnaW5maW5pdGUnO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYXJnc1swXSA9PT0gJ251bWJlcicgJiYgdHlwZW9mIGFyZ3NbMV0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIC8vIDUwLCAnbXVsdGknXG4gICAgICAgIFtwcm9ncmVzcywgY29sb3JdID0gYXJncztcbiAgICAgICAgZWwgPSBhcHAucm9vdDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGFyZ3MubGVuZ3RoID09PSAxKSB7XG4gICAgICBpZiAodHlwZW9mIGFyZ3NbMF0gPT09ICdudW1iZXInKSB7XG4gICAgICAgIGVsID0gYXBwLnJvb3Q7XG4gICAgICAgIHByb2dyZXNzID0gYXJnc1swXTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZ3NbMF0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHR5cGUgPSAnaW5maW5pdGUnO1xuICAgICAgICBlbCA9IGFwcC5yb290O1xuICAgICAgICBjb2xvciA9IGFyZ3NbMF07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChhcmdzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdHlwZSA9ICdpbmZpbml0ZSc7XG4gICAgICBlbCA9IGFwcC5yb290O1xuICAgIH1cblxuICAgIGNvbnN0ICRlbCA9ICQoZWwpO1xuICAgIGlmICgkZWwubGVuZ3RoID09PSAwKSByZXR1cm4gdW5kZWZpbmVkO1xuXG4gICAgbGV0ICRwcm9ncmVzc2JhckVsO1xuICAgIGlmICgkZWwuaGFzQ2xhc3MoJ3Byb2dyZXNzYmFyJykgfHwgJGVsLmhhc0NsYXNzKCdwcm9ncmVzc2Jhci1pbmZpbml0ZScpKSB7XG4gICAgICAkcHJvZ3Jlc3NiYXJFbCA9ICRlbDtcbiAgICB9IGVsc2Uge1xuICAgICAgJHByb2dyZXNzYmFyRWwgPSAkZWwuY2hpbGRyZW4oJy5wcm9ncmVzc2Jhcjpub3QoLnByb2dyZXNzYmFyLW91dCksIC5wcm9ncmVzc2Jhci1pbmZpbml0ZTpub3QoLnByb2dyZXNzYmFyLW91dCknKTtcbiAgICAgIGlmICgkcHJvZ3Jlc3NiYXJFbC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgJHByb2dyZXNzYmFyRWwgPSAkKGBcbiAgICAgICAgICA8c3BhbiBjbGFzcz1cInByb2dyZXNzYmFyJHt0eXBlID09PSAnaW5maW5pdGUnID8gJy1pbmZpbml0ZScgOiAnJ30ke2NvbG9yID8gYCBjb2xvci0ke2NvbG9yfWAgOiAnJ30gcHJvZ3Jlc3NiYXItaW5cIj5cbiAgICAgICAgICAgICR7dHlwZSA9PT0gJ2luZmluaXRlJyA/ICcnIDogJzxzcGFuPjwvc3Bhbj4nfVxuICAgICAgICAgIDwvc3Bhbj5gKTtcbiAgICAgICAgJGVsLmFwcGVuZCgkcHJvZ3Jlc3NiYXJFbCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBwcm9ncmVzcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGFwcC5wcm9ncmVzc2Jhci5zZXQoJHByb2dyZXNzYmFyRWwsIHByb2dyZXNzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gJHByb2dyZXNzYmFyRWxbMF07XG4gIH0sXG4gIGhpZGUoZWwsIHJlbW92ZUFmdGVySGlkZSA9IHRydWUpIHtcbiAgICBjb25zdCBhcHAgPSB0aGlzO1xuICAgIGNvbnN0ICRlbCA9ICQoZWwgfHwgYXBwLnJvb3QpO1xuICAgIGlmICgkZWwubGVuZ3RoID09PSAwKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGxldCAkcHJvZ3Jlc3NiYXJFbDtcbiAgICBpZiAoJGVsLmhhc0NsYXNzKCdwcm9ncmVzc2JhcicpIHx8ICRlbC5oYXNDbGFzcygncHJvZ3Jlc3NiYXItaW5maW5pdGUnKSkge1xuICAgICAgJHByb2dyZXNzYmFyRWwgPSAkZWw7XG4gICAgfSBlbHNlIHtcbiAgICAgICRwcm9ncmVzc2JhckVsID0gJGVsLmNoaWxkcmVuKCcucHJvZ3Jlc3NiYXIsIC5wcm9ncmVzc2Jhci1pbmZpbml0ZScpO1xuICAgIH1cbiAgICBpZiAoJHByb2dyZXNzYmFyRWwubGVuZ3RoID09PSAwIHx8ICEkcHJvZ3Jlc3NiYXJFbC5oYXNDbGFzcygncHJvZ3Jlc3NiYXItaW4nKSB8fCAkcHJvZ3Jlc3NiYXJFbC5oYXNDbGFzcygncHJvZ3Jlc3NiYXItb3V0JykpIHtcbiAgICAgIHJldHVybiAkcHJvZ3Jlc3NiYXJFbDtcbiAgICB9XG4gICAgJHByb2dyZXNzYmFyRWxcbiAgICAgIC5yZW1vdmVDbGFzcygncHJvZ3Jlc3NiYXItaW4nKVxuICAgICAgLmFkZENsYXNzKCdwcm9ncmVzc2Jhci1vdXQnKVxuICAgICAgLmFuaW1hdGlvbkVuZCgoKSA9PiB7XG4gICAgICAgIGlmIChyZW1vdmVBZnRlckhpZGUpIHtcbiAgICAgICAgICAkcHJvZ3Jlc3NiYXJFbC5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgcmV0dXJuICRwcm9ncmVzc2JhckVsO1xuICB9LFxufTtcblxudmFyIFByb2dyZXNzYmFyJDEgPSB7XG4gIG5hbWU6ICdwcm9ncmVzc2JhcicsXG4gIGNyZWF0ZSgpIHtcbiAgICBjb25zdCBhcHAgPSB0aGlzO1xuICAgIFV0aWxzLmV4dGVuZChhcHAsIHtcbiAgICAgIHByb2dyZXNzYmFyOiB7XG4gICAgICAgIHNldDogUHJvZ3Jlc3NiYXIuc2V0LmJpbmQoYXBwKSxcbiAgICAgICAgc2hvdzogUHJvZ3Jlc3NiYXIuc2hvdy5iaW5kKGFwcCksXG4gICAgICAgIGhpZGU6IFByb2dyZXNzYmFyLmhpZGUuYmluZChhcHApLFxuICAgICAgfSxcbiAgICB9KTtcbiAgfSxcbiAgb246IHtcbiAgICBwYWdlSW5pdChwYWdlKSB7XG4gICAgICBjb25zdCBhcHAgPSB0aGlzO1xuICAgICAgcGFnZS4kZWwuZmluZCgnLnByb2dyZXNzYmFyJykuZWFjaCgoaW5kZXgsIHByb2dyZXNzYmFyRWwpID0+IHtcbiAgICAgICAgY29uc3QgJHByb2dyZXNzYmFyRWwgPSAkKHByb2dyZXNzYmFyRWwpO1xuICAgICAgICBhcHAucHJvZ3Jlc3NiYXIuc2V0KCRwcm9ncmVzc2JhckVsLCAkcHJvZ3Jlc3NiYXJFbC5hdHRyKCdkYXRhLXByb2dyZXNzJykpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgfSxcbn07XG5cbmNvbnN0IFNvcnRhYmxlID0ge1xuICBpbml0KCkge1xuICAgIGNvbnN0IGFwcCA9IHRoaXM7XG4gICAgbGV0IGlzVG91Y2hlZDtcbiAgICBsZXQgaXNNb3ZlZDtcbiAgICBsZXQgdG91Y2hTdGFydFk7XG4gICAgbGV0IHRvdWNoZXNEaWZmO1xuICAgIGxldCAkc29ydGluZ0VsO1xuICAgIGxldCAkc29ydGluZ0l0ZW1zO1xuICAgIGxldCAkc29ydGFibGVDb250YWluZXI7XG4gICAgbGV0IHNvcnRpbmdFbEhlaWdodDtcbiAgICBsZXQgbWluVG9wO1xuICAgIGxldCBtYXhUb3A7XG4gICAgbGV0ICRpbnNlcnRBZnRlckVsO1xuICAgIGxldCAkaW5zZXJ0QmVmb3JlRWw7XG4gICAgbGV0IGluZGV4RnJvbTtcbiAgICBsZXQgJHBhZ2VFbDtcbiAgICBsZXQgJHBhZ2VDb250ZW50RWw7XG4gICAgbGV0IHBhZ2VIZWlnaHQ7XG4gICAgbGV0IHBhZ2VPZmZzZXQ7XG4gICAgbGV0IHNvcnRpbmdFbE9mZnNldExvY2FsO1xuICAgIGxldCBzb3J0aW5nRWxPZmZzZXRUb3A7XG4gICAgbGV0IGluaXRpYWxTY3JvbGxUb3A7XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVUb3VjaFN0YXJ0KGUpIHtcbiAgICAgIGlzTW92ZWQgPSBmYWxzZTtcbiAgICAgIGlzVG91Y2hlZCA9IHRydWU7XG4gICAgICB0b3VjaFN0YXJ0WSA9IGUudHlwZSA9PT0gJ3RvdWNoc3RhcnQnID8gZS50YXJnZXRUb3VjaGVzWzBdLnBhZ2VZIDogZS5wYWdlWTtcbiAgICAgICRzb3J0aW5nRWwgPSAkKHRoaXMpLnBhcmVudCgnbGknKTtcbiAgICAgIGluZGV4RnJvbSA9ICRzb3J0aW5nRWwuaW5kZXgoKTtcbiAgICAgICRzb3J0YWJsZUNvbnRhaW5lciA9ICRzb3J0aW5nRWwucGFyZW50cygnLnNvcnRhYmxlJyk7XG4gICAgICBjb25zdCAkbGlzdEdyb3VwID0gJHNvcnRpbmdFbC5wYXJlbnRzKCcubGlzdC1ncm91cCcpO1xuICAgICAgaWYgKCRsaXN0R3JvdXAubGVuZ3RoICYmICRsaXN0R3JvdXAucGFyZW50cygkc29ydGFibGVDb250YWluZXIpLmxlbmd0aCkge1xuICAgICAgICAkc29ydGFibGVDb250YWluZXIgPSAkbGlzdEdyb3VwO1xuICAgICAgfVxuICAgICAgJHNvcnRpbmdJdGVtcyA9ICRzb3J0YWJsZUNvbnRhaW5lci5jaGlsZHJlbigndWwnKS5jaGlsZHJlbignbGknKTtcbiAgICAgIGlmIChhcHAucGFuZWwpIGFwcC5wYW5lbC5hbGxvd09wZW4gPSBmYWxzZTtcbiAgICAgIGlmIChhcHAuc3dpcGVvdXQpIGFwcC5zd2lwZW91dC5hbGxvdyA9IGZhbHNlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoYW5kbGVUb3VjaE1vdmUoZSkge1xuICAgICAgaWYgKCFpc1RvdWNoZWQgfHwgISRzb3J0aW5nRWwpIHJldHVybjtcbiAgICAgIGNvbnN0IHBhZ2VZID0gZS50eXBlID09PSAndG91Y2htb3ZlJyA/IGUudGFyZ2V0VG91Y2hlc1swXS5wYWdlWSA6IGUucGFnZVk7XG4gICAgICBpZiAoIWlzTW92ZWQpIHtcbiAgICAgICAgJHBhZ2VFbCA9ICRzb3J0aW5nRWwucGFyZW50cygnLnBhZ2UnKTtcbiAgICAgICAgJHBhZ2VDb250ZW50RWwgPSAkc29ydGluZ0VsLnBhcmVudHMoJy5wYWdlLWNvbnRlbnQnKTtcbiAgICAgICAgY29uc3QgcGFkZGluZ1RvcCA9IHBhcnNlSW50KCRwYWdlQ29udGVudEVsLmNzcygncGFkZGluZy10b3AnKSwgMTApO1xuICAgICAgICBjb25zdCBwYWRkaW5nQm90dG9tID0gcGFyc2VJbnQoJHBhZ2VDb250ZW50RWwuY3NzKCdwYWRkaW5nLWJvdHRvbScpLCAxMCk7XG4gICAgICAgIGluaXRpYWxTY3JvbGxUb3AgPSAkcGFnZUNvbnRlbnRFbFswXS5zY3JvbGxUb3A7XG4gICAgICAgIHBhZ2VPZmZzZXQgPSAkcGFnZUVsLm9mZnNldCgpLnRvcCArIHBhZGRpbmdUb3A7XG4gICAgICAgIHBhZ2VIZWlnaHQgPSAkcGFnZUVsLmhlaWdodCgpIC0gcGFkZGluZ1RvcCAtIHBhZGRpbmdCb3R0b207XG4gICAgICAgICRzb3J0aW5nRWwuYWRkQ2xhc3MoJ3NvcnRpbmcnKTtcbiAgICAgICAgJHNvcnRhYmxlQ29udGFpbmVyLmFkZENsYXNzKCdzb3J0YWJsZS1zb3J0aW5nJyk7XG4gICAgICAgIHNvcnRpbmdFbE9mZnNldExvY2FsID0gJHNvcnRpbmdFbFswXS5vZmZzZXRUb3A7XG4gICAgICAgIG1pblRvcCA9ICRzb3J0aW5nRWxbMF0ub2Zmc2V0VG9wO1xuICAgICAgICBtYXhUb3AgPSAkc29ydGluZ0VsLnBhcmVudCgpLmhlaWdodCgpIC0gc29ydGluZ0VsT2Zmc2V0TG9jYWwgLSAkc29ydGluZ0VsLmhlaWdodCgpO1xuICAgICAgICBzb3J0aW5nRWxIZWlnaHQgPSAkc29ydGluZ0VsWzBdLm9mZnNldEhlaWdodDtcbiAgICAgICAgc29ydGluZ0VsT2Zmc2V0VG9wID0gJHNvcnRpbmdFbC5vZmZzZXQoKS50b3A7XG4gICAgICB9XG4gICAgICBpc01vdmVkID0gdHJ1ZTtcblxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgZS5mN1ByZXZlbnRTd2lwZVBhbmVsID0gdHJ1ZTtcblxuICAgICAgdG91Y2hlc0RpZmYgPSBwYWdlWSAtIHRvdWNoU3RhcnRZO1xuXG4gICAgICBjb25zdCB0cmFuc2xhdGVTY3JvbGxPZmZzZXQgPSAkcGFnZUNvbnRlbnRFbFswXS5zY3JvbGxUb3AgLSBpbml0aWFsU2Nyb2xsVG9wO1xuICAgICAgY29uc3QgdHJhbnNsYXRlID0gTWF0aC5taW4oTWF0aC5tYXgodG91Y2hlc0RpZmYgKyB0cmFuc2xhdGVTY3JvbGxPZmZzZXQsIC1taW5Ub3ApLCBtYXhUb3ApO1xuICAgICAgJHNvcnRpbmdFbC50cmFuc2Zvcm0oYHRyYW5zbGF0ZTNkKDAsJHt0cmFuc2xhdGV9cHgsMClgKTtcblxuICAgICAgY29uc3Qgc2Nyb2xsQWRkaXRpb24gPSA0NDtcbiAgICAgIGxldCBhbGxvd1Njcm9sbCA9IHRydWU7XG4gICAgICBpZiAoKHRvdWNoZXNEaWZmICsgdHJhbnNsYXRlU2Nyb2xsT2Zmc2V0KSArIHNjcm9sbEFkZGl0aW9uIDwgLW1pblRvcCkge1xuICAgICAgICBhbGxvd1Njcm9sbCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKCh0b3VjaGVzRGlmZiArIHRyYW5zbGF0ZVNjcm9sbE9mZnNldCkgLSBzY3JvbGxBZGRpdGlvbiA+IG1heFRvcCkge1xuICAgICAgICBhbGxvd1Njcm9sbCA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAkaW5zZXJ0QmVmb3JlRWwgPSB1bmRlZmluZWQ7XG4gICAgICAkaW5zZXJ0QWZ0ZXJFbCA9IHVuZGVmaW5lZDtcblxuICAgICAgbGV0IHNjcm9sbERpZmY7XG4gICAgICBpZiAoYWxsb3dTY3JvbGwpIHtcbiAgICAgICAgaWYgKHNvcnRpbmdFbE9mZnNldFRvcCArIHRvdWNoZXNEaWZmICsgc29ydGluZ0VsSGVpZ2h0ICsgc2Nyb2xsQWRkaXRpb24gPiBwYWdlT2Zmc2V0ICsgcGFnZUhlaWdodCkge1xuICAgICAgICAgIC8vIFRvIEJvdHRvbVxuICAgICAgICAgIHNjcm9sbERpZmYgPSAoc29ydGluZ0VsT2Zmc2V0VG9wICsgdG91Y2hlc0RpZmYgKyBzb3J0aW5nRWxIZWlnaHQgKyBzY3JvbGxBZGRpdGlvbikgLSAocGFnZU9mZnNldCArIHBhZ2VIZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzb3J0aW5nRWxPZmZzZXRUb3AgKyB0b3VjaGVzRGlmZiA8IHBhZ2VPZmZzZXQgKyBzY3JvbGxBZGRpdGlvbikge1xuICAgICAgICAgIC8vIFRvIFRvcFxuICAgICAgICAgIHNjcm9sbERpZmYgPSAoc29ydGluZ0VsT2Zmc2V0VG9wICsgdG91Y2hlc0RpZmYpIC0gcGFnZU9mZnNldCAtIHNjcm9sbEFkZGl0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzY3JvbGxEaWZmKSB7XG4gICAgICAgICAgJHBhZ2VDb250ZW50RWxbMF0uc2Nyb2xsVG9wICs9IHNjcm9sbERpZmY7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgJHNvcnRpbmdJdGVtcy5lYWNoKChpbmRleCwgZWwpID0+IHtcbiAgICAgICAgY29uc3QgJGN1cnJlbnRFbCA9ICQoZWwpO1xuICAgICAgICBpZiAoJGN1cnJlbnRFbFswXSA9PT0gJHNvcnRpbmdFbFswXSkgcmV0dXJuO1xuICAgICAgICBjb25zdCBjdXJyZW50RWxPZmZzZXQgPSAkY3VycmVudEVsWzBdLm9mZnNldFRvcDtcbiAgICAgICAgY29uc3QgY3VycmVudEVsSGVpZ2h0ID0gJGN1cnJlbnRFbC5oZWlnaHQoKTtcbiAgICAgICAgY29uc3Qgc29ydGluZ0VsT2Zmc2V0ID0gc29ydGluZ0VsT2Zmc2V0TG9jYWwgKyB0cmFuc2xhdGU7XG5cbiAgICAgICAgaWYgKChzb3J0aW5nRWxPZmZzZXQgPj0gY3VycmVudEVsT2Zmc2V0IC0gKGN1cnJlbnRFbEhlaWdodCAvIDIpKSAmJiAkc29ydGluZ0VsLmluZGV4KCkgPCAkY3VycmVudEVsLmluZGV4KCkpIHtcbiAgICAgICAgICAkY3VycmVudEVsLnRyYW5zZm9ybShgdHJhbnNsYXRlM2QoMCwgJHstc29ydGluZ0VsSGVpZ2h0fXB4LDApYCk7XG4gICAgICAgICAgJGluc2VydEFmdGVyRWwgPSAkY3VycmVudEVsO1xuICAgICAgICAgICRpbnNlcnRCZWZvcmVFbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfSBlbHNlIGlmICgoc29ydGluZ0VsT2Zmc2V0IDw9IGN1cnJlbnRFbE9mZnNldCArIChjdXJyZW50RWxIZWlnaHQgLyAyKSkgJiYgJHNvcnRpbmdFbC5pbmRleCgpID4gJGN1cnJlbnRFbC5pbmRleCgpKSB7XG4gICAgICAgICAgJGN1cnJlbnRFbC50cmFuc2Zvcm0oYHRyYW5zbGF0ZTNkKDAsICR7c29ydGluZ0VsSGVpZ2h0fXB4LDApYCk7XG4gICAgICAgICAgJGluc2VydEFmdGVyRWwgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgaWYgKCEkaW5zZXJ0QmVmb3JlRWwpICRpbnNlcnRCZWZvcmVFbCA9ICRjdXJyZW50RWw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgJGN1cnJlbnRFbC50cmFuc2Zvcm0oJ3RyYW5zbGF0ZTNkKDAsIDAlLDApJyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoYW5kbGVUb3VjaEVuZCgpIHtcbiAgICAgIGlmICghaXNUb3VjaGVkIHx8ICFpc01vdmVkKSB7XG4gICAgICAgIGlzVG91Y2hlZCA9IGZhbHNlO1xuICAgICAgICBpc01vdmVkID0gZmFsc2U7XG4gICAgICAgIGlmIChpc1RvdWNoZWQgJiYgIWlzTW92ZWQpIHtcbiAgICAgICAgICBpZiAoYXBwLnBhbmVsKSBhcHAucGFuZWwuYWxsb3dPcGVuID0gdHJ1ZTtcbiAgICAgICAgICBpZiAoYXBwLnN3aXBlb3V0KSBhcHAuc3dpcGVvdXQuYWxsb3cgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChhcHAucGFuZWwpIGFwcC5wYW5lbC5hbGxvd09wZW4gPSB0cnVlO1xuICAgICAgaWYgKGFwcC5zd2lwZW91dCkgYXBwLnN3aXBlb3V0LmFsbG93ID0gdHJ1ZTtcblxuICAgICAgJHNvcnRpbmdJdGVtcy50cmFuc2Zvcm0oJycpO1xuICAgICAgJHNvcnRpbmdFbC5yZW1vdmVDbGFzcygnc29ydGluZycpO1xuICAgICAgJHNvcnRhYmxlQ29udGFpbmVyLnJlbW92ZUNsYXNzKCdzb3J0YWJsZS1zb3J0aW5nJyk7XG5cbiAgICAgIGxldCB2aXJ0dWFsTGlzdDtcbiAgICAgIGxldCBvbGRJbmRleDtcbiAgICAgIGxldCBuZXdJbmRleDtcbiAgICAgIGlmICgkaW5zZXJ0QWZ0ZXJFbCkge1xuICAgICAgICAkc29ydGluZ0VsLmluc2VydEFmdGVyKCRpbnNlcnRBZnRlckVsKTtcbiAgICAgIH1cbiAgICAgIGlmICgkaW5zZXJ0QmVmb3JlRWwpIHtcbiAgICAgICAgJHNvcnRpbmdFbC5pbnNlcnRCZWZvcmUoJGluc2VydEJlZm9yZUVsKTtcbiAgICAgIH1cblxuICAgICAgJHNvcnRpbmdFbC50cmlnZ2VyKCdzb3J0YWJsZTpzb3J0JywgeyBmcm9tOiBpbmRleEZyb20sIHRvOiAkc29ydGluZ0VsLmluZGV4KCkgfSk7XG4gICAgICBhcHAuZW1pdCgnc29ydGFibGVTb3J0JywgJHNvcnRpbmdFbFswXSwgeyBmcm9tOiBpbmRleEZyb20sIHRvOiAkc29ydGluZ0VsLmluZGV4KCkgfSk7XG5cbiAgICAgIGlmICgoJGluc2VydEFmdGVyRWwgfHwgJGluc2VydEJlZm9yZUVsKSAmJiAkc29ydGFibGVDb250YWluZXIuaGFzQ2xhc3MoJ3ZpcnR1YWwtbGlzdCcpKSB7XG4gICAgICAgIHZpcnR1YWxMaXN0ID0gJHNvcnRhYmxlQ29udGFpbmVyWzBdLmY3VmlydHVhbExpc3Q7XG4gICAgICAgIG9sZEluZGV4ID0gJHNvcnRpbmdFbFswXS5mN1ZpcnR1YWxMaXN0SW5kZXg7XG4gICAgICAgIG5ld0luZGV4ID0gJGluc2VydEJlZm9yZUVsID8gJGluc2VydEJlZm9yZUVsWzBdLmY3VmlydHVhbExpc3RJbmRleCA6ICRpbnNlcnRBZnRlckVsWzBdLmY3VmlydHVhbExpc3RJbmRleDtcbiAgICAgICAgaWYgKHZpcnR1YWxMaXN0KSB2aXJ0dWFsTGlzdC5tb3ZlSXRlbShvbGRJbmRleCwgbmV3SW5kZXgpO1xuICAgICAgfVxuICAgICAgJGluc2VydEJlZm9yZUVsID0gdW5kZWZpbmVkO1xuICAgICAgJGluc2VydEFmdGVyRWwgPSB1bmRlZmluZWQ7XG4gICAgICBpc1RvdWNoZWQgPSBmYWxzZTtcbiAgICAgIGlzTW92ZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBhY3RpdmVMaXN0ZW5lciA9IGFwcC5zdXBwb3J0LnBhc3NpdmVMaXN0ZW5lciA/IHsgcGFzc2l2ZTogZmFsc2UsIGNhcHR1cmU6IGZhbHNlIH0gOiBmYWxzZTtcblxuICAgICQoZG9jdW1lbnQpLm9uKGFwcC50b3VjaEV2ZW50cy5zdGFydCwgJy5saXN0LnNvcnRhYmxlIC5zb3J0YWJsZS1oYW5kbGVyJywgaGFuZGxlVG91Y2hTdGFydCwgYWN0aXZlTGlzdGVuZXIpO1xuICAgIGFwcC5vbigndG91Y2htb3ZlOmFjdGl2ZScsIGhhbmRsZVRvdWNoTW92ZSk7XG4gICAgYXBwLm9uKCd0b3VjaGVuZDpwYXNzaXZlJywgaGFuZGxlVG91Y2hFbmQpO1xuICB9LFxuICBlbmFibGUoZWwgPSAnLmxpc3Quc29ydGFibGUnKSB7XG4gICAgY29uc3QgYXBwID0gdGhpcztcbiAgICBjb25zdCAkZWwgPSAkKGVsKTtcbiAgICBpZiAoJGVsLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgICRlbC5hZGRDbGFzcygnc29ydGFibGUtZW5hYmxlZCcpO1xuICAgICRlbC50cmlnZ2VyKCdzb3J0YWJsZTplbmFibGUnKTtcbiAgICBhcHAuZW1pdCgnc29ydGFibGVFbmFibGUnLCAkZWxbMF0pO1xuICB9LFxuICBkaXNhYmxlKGVsID0gJy5saXN0LnNvcnRhYmxlJykge1xuICAgIGNvbnN0IGFwcCA9IHRoaXM7XG4gICAgY29uc3QgJGVsID0gJChlbCk7XG4gICAgaWYgKCRlbC5sZW5ndGggPT09IDApIHJldHVybjtcbiAgICAkZWwucmVtb3ZlQ2xhc3MoJ3NvcnRhYmxlLWVuYWJsZWQnKTtcbiAgICAkZWwudHJpZ2dlcignc29ydGFibGU6ZGlzYWJsZScpO1xuICAgIGFwcC5lbWl0KCdzb3J0YWJsZURpc2FibGUnLCAkZWxbMF0pO1xuICB9LFxuICB0b2dnbGUoZWwgPSAnLmxpc3Quc29ydGFibGUnKSB7XG4gICAgY29uc3QgYXBwID0gdGhpcztcbiAgICBjb25zdCAkZWwgPSAkKGVsKTtcbiAgICBpZiAoJGVsLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgIGlmICgkZWwuaGFzQ2xhc3MoJ3NvcnRhYmxlLWVuYWJsZWQnKSkge1xuICAgICAgYXBwLnNvcnRhYmxlLmRpc2FibGUoJGVsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXBwLnNvcnRhYmxlLmVuYWJsZSgkZWwpO1xuICAgIH1cbiAgfSxcbn07XG52YXIgU29ydGFibGUkMSA9IHtcbiAgbmFtZTogJ3NvcnRhYmxlJyxcbiAgcGFyYW1zOiB7XG4gICAgc29ydGFibGU6IHRydWUsXG4gIH0sXG4gIGNyZWF0ZSgpIHtcbiAgICBjb25zdCBhcHAgPSB0aGlzO1xuICAgIFV0aWxzLmV4dGVuZChhcHAsIHtcbiAgICAgIHNvcnRhYmxlOiB7XG4gICAgICAgIGluaXQ6IFNvcnRhYmxlLmluaXQuYmluZChhcHApLFxuICAgICAgICBlbmFibGU6IFNvcnRhYmxlLmVuYWJsZS5iaW5kKGFwcCksXG4gICAgICAgIGRpc2FibGU6IFNvcnRhYmxlLmRpc2FibGUuYmluZChhcHApLFxuICAgICAgICB0b2dnbGU6IFNvcnRhYmxlLnRvZ2dsZS5iaW5kKGFwcCksXG4gICAgICB9LFxuICAgIH0pO1xuICB9LFxuICBvbjoge1xuICAgIGluaXQoKSB7XG4gICAgICBjb25zdCBhcHAgPSB0aGlzO1xuICAgICAgaWYgKGFwcC5wYXJhbXMuc29ydGFibGUpIGFwcC5zb3J0YWJsZS5pbml0KCk7XG4gICAgfSxcbiAgfSxcbiAgY2xpY2tzOiB7XG4gICAgJy5zb3J0YWJsZS1lbmFibGUnOiBmdW5jdGlvbiBlbmFibGUoJGNsaWNrZWRFbCwgZGF0YSA9IHt9KSB7XG4gICAgICBjb25zdCBhcHAgPSB0aGlzO1xuICAgICAgYXBwLnNvcnRhYmxlLmVuYWJsZShkYXRhLnNvcnRhYmxlKTtcbiAgICB9LFxuICAgICcuc29ydGFibGUtZGlzYWJsZSc6IGZ1bmN0aW9uIGRpc2FibGUoJGNsaWNrZWRFbCwgZGF0YSA9IHt9KSB7XG4gICAgICBjb25zdCBhcHAgPSB0aGlzO1xuICAgICAgYXBwLnNvcnRhYmxlLmRpc2FibGUoZGF0YS5zb3J0YWJsZSk7XG4gICAgfSxcbiAgICAnLnNvcnRhYmxlLXRvZ2dsZSc6IGZ1bmN0aW9uIHRvZ2dsZSgkY2xpY2tlZEVsLCBkYXRhID0ge30pIHtcbiAgICAgIGNvbnN0IGFwcCA9IHRoaXM7XG4gICAgICBhcHAuc29ydGFibGUudG9nZ2xlKGRhdGEuc29ydGFibGUpO1xuICAgIH0sXG4gIH0sXG59O1xuXG5jb25zdCBTd2lwZW91dCA9IHtcbiAgaW5pdCgpIHtcbiAgICBjb25zdCBhcHAgPSB0aGlzO1xuICAgIGNvbnN0IHRvdWNoZXNTdGFydCA9IHt9O1xuICAgIGxldCBpc1RvdWNoZWQ7XG4gICAgbGV0IGlzTW92ZWQ7XG4gICAgbGV0IGlzU2Nyb2xsaW5nO1xuICAgIGxldCB0b3VjaFN0YXJ0VGltZTtcbiAgICBsZXQgdG91Y2hlc0RpZmY7XG4gICAgbGV0ICRzd2lwZW91dEVsO1xuICAgIGxldCAkc3dpcGVvdXRDb250ZW50O1xuICAgIGxldCAkYWN0aW9uc1JpZ2h0O1xuICAgIGxldCAkYWN0aW9uc0xlZnQ7XG4gICAgbGV0IGFjdGlvbnNMZWZ0V2lkdGg7XG4gICAgbGV0IGFjdGlvbnNSaWdodFdpZHRoO1xuICAgIGxldCB0cmFuc2xhdGU7XG4gICAgbGV0IG9wZW5lZDtcbiAgICBsZXQgb3BlbmVkQWN0aW9uc1NpZGU7XG4gICAgbGV0ICRsZWZ0QnV0dG9ucztcbiAgICBsZXQgJHJpZ2h0QnV0dG9ucztcbiAgICBsZXQgZGlyZWN0aW9uO1xuICAgIGxldCAkb3ZlcnN3aXBlTGVmdEJ1dHRvbjtcbiAgICBsZXQgJG92ZXJzd2lwZVJpZ2h0QnV0dG9uO1xuICAgIGxldCBvdmVyc3dpcGVMZWZ0O1xuICAgIGxldCBvdmVyc3dpcGVSaWdodDtcblxuICAgIGZ1bmN0aW9uIGhhbmRsZVRvdWNoU3RhcnQoZSkge1xuICAgICAgaWYgKCFTd2lwZW91dC5hbGxvdykgcmV0dXJuO1xuICAgICAgaXNNb3ZlZCA9IGZhbHNlO1xuICAgICAgaXNUb3VjaGVkID0gdHJ1ZTtcbiAgICAgIGlzU2Nyb2xsaW5nID0gdW5kZWZpbmVkO1xuICAgICAgdG91Y2hlc1N0YXJ0LnggPSBlLnR5cGUgPT09ICd0b3VjaHN0YXJ0JyA/IGUudGFyZ2V0VG91Y2hlc1swXS5wYWdlWCA6IGUucGFnZVg7XG4gICAgICB0b3VjaGVzU3RhcnQueSA9IGUudHlwZSA9PT0gJ3RvdWNoc3RhcnQnID8gZS50YXJnZXRUb3VjaGVzWzBdLnBhZ2VZIDogZS5wYWdlWTtcbiAgICAgIHRvdWNoU3RhcnRUaW1lID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcbiAgICAgICRzd2lwZW91dEVsID0gJCh0aGlzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaGFuZGxlVG91Y2hNb3ZlKGUpIHtcbiAgICAgIGlmICghaXNUb3VjaGVkKSByZXR1cm47XG4gICAgICBjb25zdCBwYWdlWCA9IGUudHlwZSA9PT0gJ3RvdWNobW92ZScgPyBlLnRhcmdldFRvdWNoZXNbMF0ucGFnZVggOiBlLnBhZ2VYO1xuICAgICAgY29uc3QgcGFnZVkgPSBlLnR5cGUgPT09ICd0b3VjaG1vdmUnID8gZS50YXJnZXRUb3VjaGVzWzBdLnBhZ2VZIDogZS5wYWdlWTtcbiAgICAgIGlmICh0eXBlb2YgaXNTY3JvbGxpbmcgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGlzU2Nyb2xsaW5nID0gISEoaXNTY3JvbGxpbmcgfHwgTWF0aC5hYnMocGFnZVkgLSB0b3VjaGVzU3RhcnQueSkgPiBNYXRoLmFicyhwYWdlWCAtIHRvdWNoZXNTdGFydC54KSk7XG4gICAgICB9XG4gICAgICBpZiAoaXNTY3JvbGxpbmcpIHtcbiAgICAgICAgaXNUb3VjaGVkID0gZmFsc2U7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc01vdmVkKSB7XG4gICAgICAgIGlmICgkKCcubGlzdC5zb3J0YWJsZS1vcGVuZWQnKS5sZW5ndGggPiAwKSByZXR1cm47XG4gICAgICAgICRzd2lwZW91dENvbnRlbnQgPSAkc3dpcGVvdXRFbC5maW5kKCcuc3dpcGVvdXQtY29udGVudCcpO1xuICAgICAgICAkYWN0aW9uc1JpZ2h0ID0gJHN3aXBlb3V0RWwuZmluZCgnLnN3aXBlb3V0LWFjdGlvbnMtcmlnaHQnKTtcbiAgICAgICAgJGFjdGlvbnNMZWZ0ID0gJHN3aXBlb3V0RWwuZmluZCgnLnN3aXBlb3V0LWFjdGlvbnMtbGVmdCcpO1xuICAgICAgICBhY3Rpb25zTGVmdFdpZHRoID0gbnVsbDtcbiAgICAgICAgYWN0aW9uc1JpZ2h0V2lkdGggPSBudWxsO1xuICAgICAgICAkbGVmdEJ1dHRvbnMgPSBudWxsO1xuICAgICAgICAkcmlnaHRCdXR0b25zID0gbnVsbDtcbiAgICAgICAgJG92ZXJzd2lwZVJpZ2h0QnV0dG9uID0gbnVsbDtcbiAgICAgICAgJG92ZXJzd2lwZUxlZnRCdXR0b24gPSBudWxsO1xuICAgICAgICBpZiAoJGFjdGlvbnNMZWZ0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBhY3Rpb25zTGVmdFdpZHRoID0gJGFjdGlvbnNMZWZ0Lm91dGVyV2lkdGgoKTtcbiAgICAgICAgICAkbGVmdEJ1dHRvbnMgPSAkYWN0aW9uc0xlZnQuY2hpbGRyZW4oJ2EnKTtcbiAgICAgICAgICAkb3ZlcnN3aXBlTGVmdEJ1dHRvbiA9ICRhY3Rpb25zTGVmdC5maW5kKCcuc3dpcGVvdXQtb3ZlcnN3aXBlJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCRhY3Rpb25zUmlnaHQubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGFjdGlvbnNSaWdodFdpZHRoID0gJGFjdGlvbnNSaWdodC5vdXRlcldpZHRoKCk7XG4gICAgICAgICAgJHJpZ2h0QnV0dG9ucyA9ICRhY3Rpb25zUmlnaHQuY2hpbGRyZW4oJ2EnKTtcbiAgICAgICAgICAkb3ZlcnN3aXBlUmlnaHRCdXR0b24gPSAkYWN0aW9uc1JpZ2h0LmZpbmQoJy5zd2lwZW91dC1vdmVyc3dpcGUnKTtcbiAgICAgICAgfVxuICAgICAgICBvcGVuZWQgPSAkc3dpcGVvdXRFbC5oYXNDbGFzcygnc3dpcGVvdXQtb3BlbmVkJyk7XG4gICAgICAgIGlmIChvcGVuZWQpIHtcbiAgICAgICAgICBvcGVuZWRBY3Rpb25zU2lkZSA9ICRzd2lwZW91dEVsLmZpbmQoJy5zd2lwZW91dC1hY3Rpb25zLWxlZnQuc3dpcGVvdXQtYWN0aW9ucy1vcGVuZWQnKS5sZW5ndGggPiAwID8gJ2xlZnQnIDogJ3JpZ2h0JztcbiAgICAgICAgfVxuICAgICAgICAkc3dpcGVvdXRFbC5yZW1vdmVDbGFzcygnc3dpcGVvdXQtdHJhbnNpdGlvbmluZycpO1xuICAgICAgICBpZiAoIWFwcC5wYXJhbXMuc3dpcGVvdXQubm9Gb2xsb3cpIHtcbiAgICAgICAgICAkc3dpcGVvdXRFbC5maW5kKCcuc3dpcGVvdXQtYWN0aW9ucy1vcGVuZWQnKS5yZW1vdmVDbGFzcygnc3dpcGVvdXQtYWN0aW9ucy1vcGVuZWQnKTtcbiAgICAgICAgICAkc3dpcGVvdXRFbC5yZW1vdmVDbGFzcygnc3dpcGVvdXQtb3BlbmVkJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlzTW92ZWQgPSB0cnVlO1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICB0b3VjaGVzRGlmZiA9IHBhZ2VYIC0gdG91Y2hlc1N0YXJ0Lng7XG4gICAgICB0cmFuc2xhdGUgPSB0b3VjaGVzRGlmZjtcblxuICAgICAgaWYgKG9wZW5lZCkge1xuICAgICAgICBpZiAob3BlbmVkQWN0aW9uc1NpZGUgPT09ICdyaWdodCcpIHRyYW5zbGF0ZSAtPSBhY3Rpb25zUmlnaHRXaWR0aDtcbiAgICAgICAgZWxzZSB0cmFuc2xhdGUgKz0gYWN0aW9uc0xlZnRXaWR0aDtcbiAgICAgIH1cblxuICAgICAgaWYgKFxuICAgICAgICAodHJhbnNsYXRlID4gMCAmJiAkYWN0aW9uc0xlZnQubGVuZ3RoID09PSAwKVxuICAgICAgICB8fFxuICAgICAgICAodHJhbnNsYXRlIDwgMCAmJiAkYWN0aW9uc1JpZ2h0Lmxlbmd0aCA9PT0gMClcbiAgICAgICkge1xuICAgICAgICBpZiAoIW9wZW5lZCkge1xuICAgICAgICAgIGlzVG91Y2hlZCA9IGZhbHNlO1xuICAgICAgICAgIGlzTW92ZWQgPSBmYWxzZTtcbiAgICAgICAgICAkc3dpcGVvdXRDb250ZW50LnRyYW5zZm9ybSgnJyk7XG4gICAgICAgICAgaWYgKCRyaWdodEJ1dHRvbnMgJiYgJHJpZ2h0QnV0dG9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAkcmlnaHRCdXR0b25zLnRyYW5zZm9ybSgnJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgkbGVmdEJ1dHRvbnMgJiYgJGxlZnRCdXR0b25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICRsZWZ0QnV0dG9ucy50cmFuc2Zvcm0oJycpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdHJhbnNsYXRlID0gMDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRyYW5zbGF0ZSA8IDApIGRpcmVjdGlvbiA9ICd0by1sZWZ0JztcbiAgICAgIGVsc2UgaWYgKHRyYW5zbGF0ZSA+IDApIGRpcmVjdGlvbiA9ICd0by1yaWdodCc7XG4gICAgICBlbHNlIGlmICghZGlyZWN0aW9uKSBkaXJlY3Rpb24gPSAndG8tbGVmdCc7XG5cbiAgICAgIGxldCBidXR0b25PZmZzZXQ7XG4gICAgICBsZXQgcHJvZ3Jlc3M7XG5cbiAgICAgIGUuZjdQcmV2ZW50U3dpcGVQYW5lbCA9IHRydWU7XG4gICAgICBpZiAoYXBwLnBhcmFtcy5zd2lwZW91dC5ub0ZvbGxvdykge1xuICAgICAgICBpZiAob3BlbmVkKSB7XG4gICAgICAgICAgaWYgKG9wZW5lZEFjdGlvbnNTaWRlID09PSAncmlnaHQnICYmIHRvdWNoZXNEaWZmID4gMCkge1xuICAgICAgICAgICAgYXBwLnN3aXBlb3V0LmNsb3NlKCRzd2lwZW91dEVsKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9wZW5lZEFjdGlvbnNTaWRlID09PSAnbGVmdCcgJiYgdG91Y2hlc0RpZmYgPCAwKSB7XG4gICAgICAgICAgICBhcHAuc3dpcGVvdXQuY2xvc2UoJHN3aXBlb3V0RWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodG91Y2hlc0RpZmYgPCAwICYmICRhY3Rpb25zUmlnaHQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgYXBwLnN3aXBlb3V0Lm9wZW4oJHN3aXBlb3V0RWwsICdyaWdodCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodG91Y2hlc0RpZmYgPiAwICYmICRhY3Rpb25zTGVmdC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBhcHAuc3dpcGVvdXQub3Blbigkc3dpcGVvdXRFbCwgJ2xlZnQnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaXNUb3VjaGVkID0gZmFsc2U7XG4gICAgICAgIGlzTW92ZWQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgb3ZlcnN3aXBlTGVmdCA9IGZhbHNlO1xuICAgICAgb3ZlcnN3aXBlUmlnaHQgPSBmYWxzZTtcbiAgICAgIGlmICgkYWN0aW9uc1JpZ2h0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgLy8gU2hvdyByaWdodCBhY3Rpb25zXG4gICAgICAgIGxldCBidXR0b25UcmFuc2xhdGUgPSB0cmFuc2xhdGU7XG4gICAgICAgIHByb2dyZXNzID0gYnV0dG9uVHJhbnNsYXRlIC8gYWN0aW9uc1JpZ2h0V2lkdGg7XG4gICAgICAgIGlmIChidXR0b25UcmFuc2xhdGUgPCAtYWN0aW9uc1JpZ2h0V2lkdGgpIHtcbiAgICAgICAgICBidXR0b25UcmFuc2xhdGUgPSAtYWN0aW9uc1JpZ2h0V2lkdGggLSAoKC1idXR0b25UcmFuc2xhdGUgLSBhY3Rpb25zUmlnaHRXaWR0aCkgKiogMC44KTtcbiAgICAgICAgICB0cmFuc2xhdGUgPSBidXR0b25UcmFuc2xhdGU7XG4gICAgICAgICAgaWYgKCRvdmVyc3dpcGVSaWdodEJ1dHRvbi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBvdmVyc3dpcGVSaWdodCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChkaXJlY3Rpb24gIT09ICd0by1sZWZ0Jykge1xuICAgICAgICAgIHByb2dyZXNzID0gMDtcbiAgICAgICAgICBidXR0b25UcmFuc2xhdGUgPSAwO1xuICAgICAgICB9XG4gICAgICAgICRyaWdodEJ1dHRvbnMuZWFjaCgoaW5kZXgsIGJ1dHRvbkVsKSA9PiB7XG4gICAgICAgICAgY29uc3QgJGJ1dHRvbkVsID0gJChidXR0b25FbCk7XG4gICAgICAgICAgaWYgKHR5cGVvZiBidXR0b25FbC5mN1N3aXBlb3V0QnV0dG9uT2Zmc2V0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgJGJ1dHRvbkVsWzBdLmY3U3dpcGVvdXRCdXR0b25PZmZzZXQgPSBidXR0b25FbC5vZmZzZXRMZWZ0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBidXR0b25PZmZzZXQgPSBidXR0b25FbC5mN1N3aXBlb3V0QnV0dG9uT2Zmc2V0O1xuICAgICAgICAgIGlmICgkb3ZlcnN3aXBlUmlnaHRCdXR0b24ubGVuZ3RoID4gMCAmJiAkYnV0dG9uRWwuaGFzQ2xhc3MoJ3N3aXBlb3V0LW92ZXJzd2lwZScpICYmIGRpcmVjdGlvbiA9PT0gJ3RvLWxlZnQnKSB7XG4gICAgICAgICAgICAkYnV0dG9uRWwuY3NzKHsgbGVmdDogYCR7b3ZlcnN3aXBlUmlnaHQgPyAtYnV0dG9uT2Zmc2V0IDogMH1weGAgfSk7XG4gICAgICAgICAgICBpZiAob3ZlcnN3aXBlUmlnaHQpIHtcbiAgICAgICAgICAgICAgJGJ1dHRvbkVsLmFkZENsYXNzKCdzd2lwZW91dC1vdmVyc3dpcGUtYWN0aXZlJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAkYnV0dG9uRWwucmVtb3ZlQ2xhc3MoJ3N3aXBlb3V0LW92ZXJzd2lwZS1hY3RpdmUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgJGJ1dHRvbkVsLnRyYW5zZm9ybShgdHJhbnNsYXRlM2QoJHtidXR0b25UcmFuc2xhdGUgLSAoYnV0dG9uT2Zmc2V0ICogKDEgKyBNYXRoLm1heChwcm9ncmVzcywgLTEpKSl9cHgsMCwwKWApO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmICgkYWN0aW9uc0xlZnQubGVuZ3RoID4gMCkge1xuICAgICAgICAvLyBTaG93IGxlZnQgYWN0aW9uc1xuICAgICAgICBsZXQgYnV0dG9uVHJhbnNsYXRlID0gdHJhbnNsYXRlO1xuICAgICAgICBwcm9ncmVzcyA9IGJ1dHRvblRyYW5zbGF0ZSAvIGFjdGlvbnNMZWZ0V2lkdGg7XG4gICAgICAgIGlmIChidXR0b25UcmFuc2xhdGUgPiBhY3Rpb25zTGVmdFdpZHRoKSB7XG4gICAgICAgICAgYnV0dG9uVHJhbnNsYXRlID0gYWN0aW9uc0xlZnRXaWR0aCArICgoYnV0dG9uVHJhbnNsYXRlIC0gYWN0aW9uc0xlZnRXaWR0aCkgKiogMC44KTtcbiAgICAgICAgICB0cmFuc2xhdGUgPSBidXR0b25UcmFuc2xhdGU7XG4gICAgICAgICAgaWYgKCRvdmVyc3dpcGVMZWZ0QnV0dG9uLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIG92ZXJzd2lwZUxlZnQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZGlyZWN0aW9uICE9PSAndG8tcmlnaHQnKSB7XG4gICAgICAgICAgYnV0dG9uVHJhbnNsYXRlID0gMDtcbiAgICAgICAgICBwcm9ncmVzcyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgJGxlZnRCdXR0b25zLmVhY2goKGluZGV4LCBidXR0b25FbCkgPT4ge1xuICAgICAgICAgIGNvbnN0ICRidXR0b25FbCA9ICQoYnV0dG9uRWwpO1xuICAgICAgICAgIGlmICh0eXBlb2YgYnV0dG9uRWwuZjdTd2lwZW91dEJ1dHRvbk9mZnNldCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICRidXR0b25FbFswXS5mN1N3aXBlb3V0QnV0dG9uT2Zmc2V0ID0gYWN0aW9uc0xlZnRXaWR0aCAtIGJ1dHRvbkVsLm9mZnNldExlZnQgLSBidXR0b25FbC5vZmZzZXRXaWR0aDtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnV0dG9uT2Zmc2V0ID0gYnV0dG9uRWwuZjdTd2lwZW91dEJ1dHRvbk9mZnNldDtcbiAgICAgICAgICBpZiAoJG92ZXJzd2lwZUxlZnRCdXR0b24ubGVuZ3RoID4gMCAmJiAkYnV0dG9uRWwuaGFzQ2xhc3MoJ3N3aXBlb3V0LW92ZXJzd2lwZScpICYmIGRpcmVjdGlvbiA9PT0gJ3RvLXJpZ2h0Jykge1xuICAgICAgICAgICAgJGJ1dHRvbkVsLmNzcyh7IGxlZnQ6IGAke292ZXJzd2lwZUxlZnQgPyBidXR0b25PZmZzZXQgOiAwfXB4YCB9KTtcbiAgICAgICAgICAgIGlmIChvdmVyc3dpcGVMZWZ0KSB7XG4gICAgICAgICAgICAgICRidXR0b25FbC5hZGRDbGFzcygnc3dpcGVvdXQtb3ZlcnN3aXBlLWFjdGl2ZScpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgJGJ1dHRvbkVsLnJlbW92ZUNsYXNzKCdzd2lwZW91dC1vdmVyc3dpcGUtYWN0aXZlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgkbGVmdEJ1dHRvbnMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgJGJ1dHRvbkVsLmNzcygnei1pbmRleCcsICRsZWZ0QnV0dG9ucy5sZW5ndGggLSBpbmRleCk7XG4gICAgICAgICAgfVxuICAgICAgICAgICRidXR0b25FbC50cmFuc2Zvcm0oYHRyYW5zbGF0ZTNkKCR7YnV0dG9uVHJhbnNsYXRlICsgKGJ1dHRvbk9mZnNldCAqICgxIC0gTWF0aC5taW4ocHJvZ3Jlc3MsIDEpKSl9cHgsMCwwKWApO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgICRzd2lwZW91dEVsLnRyaWdnZXIoJ3N3aXBlb3V0JywgcHJvZ3Jlc3MpO1xuICAgICAgYXBwLmVtaXQoJ3N3aXBlb3V0JywgJHN3aXBlb3V0RWxbMF0sIHByb2dyZXNzKTtcbiAgICAgICRzd2lwZW91dENvbnRlbnQudHJhbnNmb3JtKGB0cmFuc2xhdGUzZCgke3RyYW5zbGF0ZX1weCwwLDApYCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhbmRsZVRvdWNoRW5kKCkge1xuICAgICAgaWYgKCFpc1RvdWNoZWQgfHwgIWlzTW92ZWQpIHtcbiAgICAgICAgaXNUb3VjaGVkID0gZmFsc2U7XG4gICAgICAgIGlzTW92ZWQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpc1RvdWNoZWQgPSBmYWxzZTtcbiAgICAgIGlzTW92ZWQgPSBmYWxzZTtcbiAgICAgIGNvbnN0IHRpbWVEaWZmID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKSAtIHRvdWNoU3RhcnRUaW1lO1xuICAgICAgY29uc3QgJGFjdGlvbnMgPSBkaXJlY3Rpb24gPT09ICd0by1sZWZ0JyA/ICRhY3Rpb25zUmlnaHQgOiAkYWN0aW9uc0xlZnQ7XG4gICAgICBjb25zdCBhY3Rpb25zV2lkdGggPSBkaXJlY3Rpb24gPT09ICd0by1sZWZ0JyA/IGFjdGlvbnNSaWdodFdpZHRoIDogYWN0aW9uc0xlZnRXaWR0aDtcbiAgICAgIGxldCBhY3Rpb247XG4gICAgICBsZXQgJGJ1dHRvbnM7XG4gICAgICBsZXQgaTtcblxuICAgICAgaWYgKFxuICAgICAgICAoXG4gICAgICAgICAgdGltZURpZmYgPCAzMDBcbiAgICAgICAgICAmJlxuICAgICAgICAgIChcbiAgICAgICAgICAgICh0b3VjaGVzRGlmZiA8IC0xMCAmJiBkaXJlY3Rpb24gPT09ICd0by1sZWZ0JylcbiAgICAgICAgICAgIHx8XG4gICAgICAgICAgICAodG91Y2hlc0RpZmYgPiAxMCAmJiBkaXJlY3Rpb24gPT09ICd0by1yaWdodCcpXG4gICAgICAgICAgKVxuICAgICAgICApXG4gICAgICAgIHx8XG4gICAgICAgIChcbiAgICAgICAgICB0aW1lRGlmZiA+PSAzMDBcbiAgICAgICAgICAmJlxuICAgICAgICAgIChNYXRoLmFicyh0cmFuc2xhdGUpID4gYWN0aW9uc1dpZHRoIC8gMilcbiAgICAgICAgKVxuICAgICAgKSB7XG4gICAgICAgIGFjdGlvbiA9ICdvcGVuJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFjdGlvbiA9ICdjbG9zZSc7XG4gICAgICB9XG4gICAgICBpZiAodGltZURpZmYgPCAzMDApIHtcbiAgICAgICAgaWYgKE1hdGguYWJzKHRyYW5zbGF0ZSkgPT09IDApIGFjdGlvbiA9ICdjbG9zZSc7XG4gICAgICAgIGlmIChNYXRoLmFicyh0cmFuc2xhdGUpID09PSBhY3Rpb25zV2lkdGgpIGFjdGlvbiA9ICdvcGVuJztcbiAgICAgIH1cblxuICAgICAgaWYgKGFjdGlvbiA9PT0gJ29wZW4nKSB7XG4gICAgICAgIFN3aXBlb3V0LmVsID0gJHN3aXBlb3V0RWxbMF07XG4gICAgICAgICRzd2lwZW91dEVsLnRyaWdnZXIoJ3N3aXBlb3V0Om9wZW4nKTtcbiAgICAgICAgYXBwLmVtaXQoJ3N3aXBlb3V0T3BlbicsICRzd2lwZW91dEVsWzBdKTtcbiAgICAgICAgJHN3aXBlb3V0RWwuYWRkQ2xhc3MoJ3N3aXBlb3V0LW9wZW5lZCBzd2lwZW91dC10cmFuc2l0aW9uaW5nJyk7XG4gICAgICAgIGNvbnN0IG5ld1RyYW5zbGF0ZSA9IGRpcmVjdGlvbiA9PT0gJ3RvLWxlZnQnID8gLWFjdGlvbnNXaWR0aCA6IGFjdGlvbnNXaWR0aDtcbiAgICAgICAgJHN3aXBlb3V0Q29udGVudC50cmFuc2Zvcm0oYHRyYW5zbGF0ZTNkKCR7bmV3VHJhbnNsYXRlfXB4LDAsMClgKTtcbiAgICAgICAgJGFjdGlvbnMuYWRkQ2xhc3MoJ3N3aXBlb3V0LWFjdGlvbnMtb3BlbmVkJyk7XG4gICAgICAgICRidXR0b25zID0gZGlyZWN0aW9uID09PSAndG8tbGVmdCcgPyAkcmlnaHRCdXR0b25zIDogJGxlZnRCdXR0b25zO1xuICAgICAgICBpZiAoJGJ1dHRvbnMpIHtcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgJGJ1dHRvbnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICQoJGJ1dHRvbnNbaV0pLnRyYW5zZm9ybShgdHJhbnNsYXRlM2QoJHtuZXdUcmFuc2xhdGV9cHgsMCwwKWApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAob3ZlcnN3aXBlUmlnaHQpIHtcbiAgICAgICAgICAkYWN0aW9uc1JpZ2h0LmZpbmQoJy5zd2lwZW91dC1vdmVyc3dpcGUnKVswXS5jbGljaygpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvdmVyc3dpcGVMZWZ0KSB7XG4gICAgICAgICAgJGFjdGlvbnNMZWZ0LmZpbmQoJy5zd2lwZW91dC1vdmVyc3dpcGUnKVswXS5jbGljaygpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAkc3dpcGVvdXRFbC50cmlnZ2VyKCdzd2lwZW91dDpjbG9zZScpO1xuICAgICAgICBhcHAuZW1pdCgnc3dpcGVvdXRDbG9zZScsICRzd2lwZW91dEVsWzBdKTtcbiAgICAgICAgU3dpcGVvdXQuZWwgPSB1bmRlZmluZWQ7XG4gICAgICAgICRzd2lwZW91dEVsLmFkZENsYXNzKCdzd2lwZW91dC10cmFuc2l0aW9uaW5nJykucmVtb3ZlQ2xhc3MoJ3N3aXBlb3V0LW9wZW5lZCcpO1xuICAgICAgICAkc3dpcGVvdXRDb250ZW50LnRyYW5zZm9ybSgnJyk7XG4gICAgICAgICRhY3Rpb25zLnJlbW92ZUNsYXNzKCdzd2lwZW91dC1hY3Rpb25zLW9wZW5lZCcpO1xuICAgICAgfVxuXG4gICAgICBsZXQgYnV0dG9uT2Zmc2V0O1xuICAgICAgaWYgKCRsZWZ0QnV0dG9ucyAmJiAkbGVmdEJ1dHRvbnMubGVuZ3RoID4gMCAmJiAkbGVmdEJ1dHRvbnMgIT09ICRidXR0b25zKSB7XG4gICAgICAgICRsZWZ0QnV0dG9ucy5lYWNoKChpbmRleCwgYnV0dG9uRWwpID0+IHtcbiAgICAgICAgICBjb25zdCAkYnV0dG9uRWwgPSAkKGJ1dHRvbkVsKTtcbiAgICAgICAgICBidXR0b25PZmZzZXQgPSBidXR0b25FbC5mN1N3aXBlb3V0QnV0dG9uT2Zmc2V0O1xuICAgICAgICAgIGlmICh0eXBlb2YgYnV0dG9uT2Zmc2V0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgJGJ1dHRvbkVsWzBdLmY3U3dpcGVvdXRCdXR0b25PZmZzZXQgPSBhY3Rpb25zTGVmdFdpZHRoIC0gYnV0dG9uRWwub2Zmc2V0TGVmdCAtIGJ1dHRvbkVsLm9mZnNldFdpZHRoO1xuICAgICAgICAgIH1cbiAgICAgICAgICAkYnV0dG9uRWwudHJhbnNmb3JtKGB0cmFuc2xhdGUzZCgke2J1dHRvbk9mZnNldH1weCwwLDApYCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKCRyaWdodEJ1dHRvbnMgJiYgJHJpZ2h0QnV0dG9ucy5sZW5ndGggPiAwICYmICRyaWdodEJ1dHRvbnMgIT09ICRidXR0b25zKSB7XG4gICAgICAgICRyaWdodEJ1dHRvbnMuZWFjaCgoaW5kZXgsIGJ1dHRvbkVsKSA9PiB7XG4gICAgICAgICAgY29uc3QgJGJ1dHRvbkVsID0gJChidXR0b25FbCk7XG4gICAgICAgICAgYnV0dG9uT2Zmc2V0ID0gYnV0dG9uRWwuZjdTd2lwZW91dEJ1dHRvbk9mZnNldDtcbiAgICAgICAgICBpZiAodHlwZW9mIGJ1dHRvbk9mZnNldCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICRidXR0b25FbFswXS5mN1N3aXBlb3V0QnV0dG9uT2Zmc2V0ID0gYnV0dG9uRWwub2Zmc2V0TGVmdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgJGJ1dHRvbkVsLnRyYW5zZm9ybShgdHJhbnNsYXRlM2QoJHstYnV0dG9uT2Zmc2V0fXB4LDAsMClgKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICAkc3dpcGVvdXRDb250ZW50LnRyYW5zaXRpb25FbmQoKCkgPT4ge1xuICAgICAgICBpZiAoKG9wZW5lZCAmJiBhY3Rpb24gPT09ICdvcGVuJykgfHwgKCFvcGVuZWQgJiYgYWN0aW9uID09PSAnY2xvc2UnKSkgcmV0dXJuO1xuICAgICAgICAkc3dpcGVvdXRFbC50cmlnZ2VyKGFjdGlvbiA9PT0gJ29wZW4nID8gJ3N3aXBlb3V0Om9wZW5lZCcgOiAnc3dpcGVvdXQ6Y2xvc2VkJyk7XG4gICAgICAgIGFwcC5lbWl0KGFjdGlvbiA9PT0gJ29wZW4nID8gJ3N3aXBlb3V0T3BlbmVkJyA6ICdzd2lwZW91dENsb3NlZCcsICRzd2lwZW91dEVsWzBdKTtcbiAgICAgICAgJHN3aXBlb3V0RWwucmVtb3ZlQ2xhc3MoJ3N3aXBlb3V0LXRyYW5zaXRpb25pbmcnKTtcbiAgICAgICAgaWYgKG9wZW5lZCAmJiBhY3Rpb24gPT09ICdjbG9zZScpIHtcbiAgICAgICAgICBpZiAoJGFjdGlvbnNSaWdodC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAkcmlnaHRCdXR0b25zLnRyYW5zZm9ybSgnJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgkYWN0aW9uc0xlZnQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgJGxlZnRCdXR0b25zLnRyYW5zZm9ybSgnJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjb25zdCBwYXNzaXZlTGlzdGVuZXIgPSBhcHAuc3VwcG9ydC5wYXNzaXZlTGlzdGVuZXIgPyB7IHBhc3NpdmU6IHRydWUgfSA6IGZhbHNlO1xuXG4gICAgYXBwLm9uKCd0b3VjaHN0YXJ0JywgKGUpID0+IHtcbiAgICAgIGlmIChTd2lwZW91dC5lbCkge1xuICAgICAgICBjb25zdCAkdGFyZ2V0RWwgPSAkKGUudGFyZ2V0KTtcbiAgICAgICAgaWYgKCEoXG4gICAgICAgICAgJChTd2lwZW91dC5lbCkuaXMoJHRhcmdldEVsWzBdKSB8fFxuICAgICAgICAgICR0YXJnZXRFbC5wYXJlbnRzKCcuc3dpcGVvdXQnKS5pcyhTd2lwZW91dC5lbCkgfHxcbiAgICAgICAgICAkdGFyZ2V0RWwuaGFzQ2xhc3MoJ21vZGFsLWluJykgfHxcbiAgICAgICAgICAoJHRhcmdldEVsLmF0dHIoJ2NsYXNzJykgfHwgJycpLmluZGV4T2YoJy1iYWNrZHJvcCcpID4gMCB8fFxuICAgICAgICAgICR0YXJnZXRFbC5oYXNDbGFzcygnYWN0aW9ucy1tb2RhbCcpIHx8XG4gICAgICAgICAgJHRhcmdldEVsLnBhcmVudHMoJy5hY3Rpb25zLW1vZGFsLm1vZGFsLWluLCAuZGlhbG9nLm1vZGFsLWluJykubGVuZ3RoID4gMFxuICAgICAgICApKSB7XG4gICAgICAgICAgYXBwLnN3aXBlb3V0LmNsb3NlKFN3aXBlb3V0LmVsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgICQoZG9jdW1lbnQpLm9uKGFwcC50b3VjaEV2ZW50cy5zdGFydCwgJ2xpLnN3aXBlb3V0JywgaGFuZGxlVG91Y2hTdGFydCwgcGFzc2l2ZUxpc3RlbmVyKTtcbiAgICBhcHAub24oJ3RvdWNobW92ZTphY3RpdmUnLCBoYW5kbGVUb3VjaE1vdmUpO1xuICAgIGFwcC5vbigndG91Y2hlbmQ6cGFzc2l2ZScsIGhhbmRsZVRvdWNoRW5kKTtcbiAgfSxcbiAgYWxsb3c6IHRydWUsXG4gIGVsOiB1bmRlZmluZWQsXG4gIG9wZW4oLi4uYXJncykge1xuICAgIGNvbnN0IGFwcCA9IHRoaXM7XG4gICAgbGV0IFtlbCwgc2lkZSwgY2FsbGJhY2tdID0gYXJncztcbiAgICBpZiAodHlwZW9mIGFyZ3NbMV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIFtlbCwgY2FsbGJhY2ssIHNpZGVdID0gYXJncztcbiAgICB9XG4gICAgY29uc3QgJGVsID0gJChlbCkuZXEoMCk7XG5cbiAgICBpZiAoJGVsLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgIGlmICghJGVsLmhhc0NsYXNzKCdzd2lwZW91dCcpIHx8ICRlbC5oYXNDbGFzcygnc3dpcGVvdXQtb3BlbmVkJykpIHJldHVybjtcbiAgICBpZiAoIXNpZGUpIHtcbiAgICAgIGlmICgkZWwuZmluZCgnLnN3aXBlb3V0LWFjdGlvbnMtcmlnaHQnKS5sZW5ndGggPiAwKSBzaWRlID0gJ3JpZ2h0JztcbiAgICAgIGVsc2Ugc2lkZSA9ICdsZWZ0JztcbiAgICB9XG4gICAgY29uc3QgJHN3aXBlb3V0QWN0aW9ucyA9ICRlbC5maW5kKGAuc3dpcGVvdXQtYWN0aW9ucy0ke3NpZGV9YCk7XG4gICAgY29uc3QgJHN3aXBlb3V0Q29udGVudCA9ICRlbC5maW5kKCcuc3dpcGVvdXQtY29udGVudCcpO1xuICAgIGlmICgkc3dpcGVvdXRBY3Rpb25zLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgICRlbC50cmlnZ2VyKCdzd2lwZW91dDpvcGVuJykuYWRkQ2xhc3MoJ3N3aXBlb3V0LW9wZW5lZCcpLnJlbW92ZUNsYXNzKCdzd2lwZW91dC10cmFuc2l0aW9uaW5nJyk7XG4gICAgYXBwLmVtaXQoJ3N3aXBlb3V0T3BlbicsICRlbFswXSk7XG4gICAgJHN3aXBlb3V0QWN0aW9ucy5hZGRDbGFzcygnc3dpcGVvdXQtYWN0aW9ucy1vcGVuZWQnKTtcbiAgICBjb25zdCAkYnV0dG9ucyA9ICRzd2lwZW91dEFjdGlvbnMuY2hpbGRyZW4oJ2EnKTtcbiAgICBjb25zdCBzd2lwZW91dEFjdGlvbnNXaWR0aCA9ICRzd2lwZW91dEFjdGlvbnMub3V0ZXJXaWR0aCgpO1xuICAgIGNvbnN0IHRyYW5zbGF0ZSA9IHNpZGUgPT09ICdyaWdodCcgPyAtc3dpcGVvdXRBY3Rpb25zV2lkdGggOiBzd2lwZW91dEFjdGlvbnNXaWR0aDtcbiAgICBpZiAoJGJ1dHRvbnMubGVuZ3RoID4gMSkge1xuICAgICAgJGJ1dHRvbnMuZWFjaCgoYnV0dG9uSW5kZXgsIGJ1dHRvbkVsKSA9PiB7XG4gICAgICAgIGNvbnN0ICRidXR0b25FbCA9ICQoYnV0dG9uRWwpO1xuICAgICAgICBpZiAoc2lkZSA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICAgICRidXR0b25FbC50cmFuc2Zvcm0oYHRyYW5zbGF0ZTNkKCR7LWJ1dHRvbkVsLm9mZnNldExlZnR9cHgsMCwwKWApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICRidXR0b25FbC5jc3MoJ3otaW5kZXgnLCAkYnV0dG9ucy5sZW5ndGggLSBidXR0b25JbmRleCkudHJhbnNmb3JtKGB0cmFuc2xhdGUzZCgke3N3aXBlb3V0QWN0aW9uc1dpZHRoIC0gYnV0dG9uRWwub2Zmc2V0V2lkdGggLSBidXR0b25FbC5vZmZzZXRMZWZ0fXB4LDAsMClgKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgICRlbC5hZGRDbGFzcygnc3dpcGVvdXQtdHJhbnNpdGlvbmluZycpO1xuICAgICRzd2lwZW91dENvbnRlbnQudHJhbnNpdGlvbkVuZCgoKSA9PiB7XG4gICAgICAkZWwudHJpZ2dlcignc3dpcGVvdXQ6b3BlbmVkJyk7XG4gICAgICBhcHAuZW1pdCgnc3dpcGVvdXRPcGVuZWQnLCAkZWxbMF0pO1xuICAgICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjay5jYWxsKCRlbFswXSk7XG4gICAgfSk7XG4gICAgVXRpbHMubmV4dEZyYW1lKCgpID0+IHtcbiAgICAgICRidXR0b25zLnRyYW5zZm9ybShgdHJhbnNsYXRlM2QoJHt0cmFuc2xhdGV9cHgsMCwwKWApO1xuICAgICAgJHN3aXBlb3V0Q29udGVudC50cmFuc2Zvcm0oYHRyYW5zbGF0ZTNkKCR7dHJhbnNsYXRlfXB4LDAsMClgKTtcbiAgICB9KTtcbiAgICBTd2lwZW91dC5lbCA9ICRlbFswXTtcbiAgfSxcbiAgY2xvc2UoZWwsIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgYXBwID0gdGhpcztcbiAgICBjb25zdCAkZWwgPSAkKGVsKS5lcSgwKTtcbiAgICBpZiAoJGVsLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgIGlmICghJGVsLmhhc0NsYXNzKCdzd2lwZW91dC1vcGVuZWQnKSkgcmV0dXJuO1xuICAgIGNvbnN0IHNpZGUgPSAkZWwuZmluZCgnLnN3aXBlb3V0LWFjdGlvbnMtb3BlbmVkJykuaGFzQ2xhc3MoJ3N3aXBlb3V0LWFjdGlvbnMtcmlnaHQnKSA/ICdyaWdodCcgOiAnbGVmdCc7XG4gICAgY29uc3QgJHN3aXBlb3V0QWN0aW9ucyA9ICRlbC5maW5kKCcuc3dpcGVvdXQtYWN0aW9ucy1vcGVuZWQnKS5yZW1vdmVDbGFzcygnc3dpcGVvdXQtYWN0aW9ucy1vcGVuZWQnKTtcbiAgICBjb25zdCAkYnV0dG9ucyA9ICRzd2lwZW91dEFjdGlvbnMuY2hpbGRyZW4oJ2EnKTtcbiAgICBjb25zdCBzd2lwZW91dEFjdGlvbnNXaWR0aCA9ICRzd2lwZW91dEFjdGlvbnMub3V0ZXJXaWR0aCgpO1xuICAgIFN3aXBlb3V0LmFsbG93ID0gZmFsc2U7XG4gICAgJGVsLnRyaWdnZXIoJ3N3aXBlb3V0OmNsb3NlJyk7XG4gICAgYXBwLmVtaXQoJ3N3aXBlb3V0Q2xvc2UnLCAkZWxbMF0pO1xuICAgICRlbC5yZW1vdmVDbGFzcygnc3dpcGVvdXQtb3BlbmVkJykuYWRkQ2xhc3MoJ3N3aXBlb3V0LXRyYW5zaXRpb25pbmcnKTtcblxuICAgIGxldCBjbG9zZVRpbWVvdXQ7XG4gICAgZnVuY3Rpb24gb25Td2lwZW91dENsb3NlKCkge1xuICAgICAgU3dpcGVvdXQuYWxsb3cgPSB0cnVlO1xuICAgICAgaWYgKCRlbC5oYXNDbGFzcygnc3dpcGVvdXQtb3BlbmVkJykpIHJldHVybjtcbiAgICAgICRlbC5yZW1vdmVDbGFzcygnc3dpcGVvdXQtdHJhbnNpdGlvbmluZycpO1xuICAgICAgJGJ1dHRvbnMudHJhbnNmb3JtKCcnKTtcbiAgICAgICRlbC50cmlnZ2VyKCdzd2lwZW91dDpjbG9zZWQnKTtcbiAgICAgIGFwcC5lbWl0KCdzd2lwZW91dENsb3NlZCcsICRlbFswXSk7XG4gICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrLmNhbGwoJGVsWzBdKTtcbiAgICAgIGlmIChjbG9zZVRpbWVvdXQpIGNsZWFyVGltZW91dChjbG9zZVRpbWVvdXQpO1xuICAgIH1cbiAgICAkZWwuZmluZCgnLnN3aXBlb3V0LWNvbnRlbnQnKS50cmFuc2Zvcm0oJycpLnRyYW5zaXRpb25FbmQob25Td2lwZW91dENsb3NlKTtcbiAgICBjbG9zZVRpbWVvdXQgPSBzZXRUaW1lb3V0KG9uU3dpcGVvdXRDbG9zZSwgNTAwKTtcblxuICAgICRidXR0b25zLmVhY2goKGluZGV4LCBidXR0b25FbCkgPT4ge1xuICAgICAgY29uc3QgJGJ1dHRvbkVsID0gJChidXR0b25FbCk7XG4gICAgICBpZiAoc2lkZSA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICAkYnV0dG9uRWwudHJhbnNmb3JtKGB0cmFuc2xhdGUzZCgkey1idXR0b25FbC5vZmZzZXRMZWZ0fXB4LDAsMClgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICRidXR0b25FbC50cmFuc2Zvcm0oYHRyYW5zbGF0ZTNkKCR7c3dpcGVvdXRBY3Rpb25zV2lkdGggLSBidXR0b25FbC5vZmZzZXRXaWR0aCAtIGJ1dHRvbkVsLm9mZnNldExlZnR9cHgsMCwwKWApO1xuICAgICAgfVxuICAgICAgJGJ1dHRvbkVsLmNzcyh7IGxlZnQ6ICcwcHgnIH0pLnJlbW92ZUNsYXNzKCdzd2lwZW91dC1vdmVyc3dpcGUtYWN0aXZlJyk7XG4gICAgfSk7XG4gICAgaWYgKFN3aXBlb3V0LmVsICYmIFN3aXBlb3V0LmVsID09PSAkZWxbMF0pIFN3aXBlb3V0LmVsID0gdW5kZWZpbmVkO1xuICB9LFxuICBkZWxldGUoZWwsIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgYXBwID0gdGhpcztcbiAgICBjb25zdCAkZWwgPSAkKGVsKS5lcSgwKTtcbiAgICBpZiAoJGVsLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgIFN3aXBlb3V0LmVsID0gdW5kZWZpbmVkO1xuICAgICRlbC50cmlnZ2VyKCdzd2lwZW91dDpkZWxldGUnKTtcbiAgICBhcHAuZW1pdCgnc3dpcGVvdXREZWxldGUnLCAkZWxbMF0pO1xuICAgICRlbC5jc3MoeyBoZWlnaHQ6IGAkeyRlbC5vdXRlckhlaWdodCgpfXB4YCB9KTtcbiAgICAkZWwudHJhbnNpdGlvbkVuZCgoKSA9PiB7XG4gICAgICAkZWwudHJpZ2dlcignc3dpcGVvdXQ6ZGVsZXRlZCcpO1xuICAgICAgYXBwLmVtaXQoJ3N3aXBlb3V0RGVsZXRlZCcsICRlbFswXSk7XG4gICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrLmNhbGwoJGVsWzBdKTtcbiAgICAgIGlmICgkZWwucGFyZW50cygnLnZpcnR1YWwtbGlzdCcpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgdmlydHVhbExpc3QgPSAkZWwucGFyZW50cygnLnZpcnR1YWwtbGlzdCcpWzBdLmY3VmlydHVhbExpc3Q7XG4gICAgICAgIGNvbnN0IHZpcnR1YWxJbmRleCA9ICRlbFswXS5mN1ZpcnR1YWxMaXN0SW5kZXg7XG4gICAgICAgIGlmICh2aXJ0dWFsTGlzdCAmJiB0eXBlb2YgdmlydHVhbEluZGV4ICE9PSAndW5kZWZpbmVkJykgdmlydHVhbExpc3QuZGVsZXRlSXRlbSh2aXJ0dWFsSW5kZXgpO1xuICAgICAgfSBlbHNlIGlmIChhcHAucGFyYW1zLnN3aXBlb3V0LnJlbW92ZUVsZW1lbnRzKSB7XG4gICAgICAgIGlmIChhcHAucGFyYW1zLnN3aXBlb3V0LnJlbW92ZUVsZW1lbnRzV2l0aFRpbWVvdXQpIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICRlbC5yZW1vdmUoKTtcbiAgICAgICAgICB9LCBhcHAucGFyYW1zLnN3aXBlb3V0LnJlbW92ZUVsZW1lbnRzVGltZW91dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgJGVsLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAkZWwucmVtb3ZlQ2xhc3MoJ3N3aXBlb3V0LWRlbGV0aW5nIHN3aXBlb3V0LXRyYW5zaXRpb25pbmcnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAkZWxbMF0uX2NsaWVudExlZnQgPSAkZWxbMF0uY2xpZW50TGVmdDtcbiAgICAkZWxcbiAgICAgIC5hZGRDbGFzcygnc3dpcGVvdXQtZGVsZXRpbmcgc3dpcGVvdXQtdHJhbnNpdGlvbmluZycpXG4gICAgICAuY3NzKHsgaGVpZ2h0OiAnMHB4JyB9KVxuICAgICAgLmZpbmQoJy5zd2lwZW91dC1jb250ZW50JylcbiAgICAgIC50cmFuc2Zvcm0oJ3RyYW5zbGF0ZTNkKC0xMDAlLDAsMCknKTtcbiAgfSxcbn07XG52YXIgU3dpcGVvdXQkMSA9IHtcbiAgbmFtZTogJ3N3aXBlb3V0JyxcbiAgcGFyYW1zOiB7XG4gICAgc3dpcGVvdXQ6IHtcbiAgICAgIGFjdGlvbnNOb0ZvbGQ6IGZhbHNlLFxuICAgICAgbm9Gb2xsb3c6IGZhbHNlLFxuICAgICAgcmVtb3ZlRWxlbWVudHM6IHRydWUsXG4gICAgICByZW1vdmVFbGVtZW50c1dpdGhUaW1lb3V0OiBmYWxzZSxcbiAgICAgIHJlbW92ZUVsZW1lbnRzVGltZW91dDogMCxcbiAgICB9LFxuICB9LFxuICBjcmVhdGUoKSB7XG4gICAgY29uc3QgYXBwID0gdGhpcztcbiAgICBVdGlscy5leHRlbmQoYXBwLCB7XG4gICAgICBzd2lwZW91dDoge1xuICAgICAgICBpbml0OiBTd2lwZW91dC5pbml0LmJpbmQoYXBwKSxcbiAgICAgICAgb3BlbjogU3dpcGVvdXQub3Blbi5iaW5kKGFwcCksXG4gICAgICAgIGNsb3NlOiBTd2lwZW91dC5jbG9zZS5iaW5kKGFwcCksXG4gICAgICAgIGRlbGV0ZTogU3dpcGVvdXQuZGVsZXRlLmJpbmQoYXBwKSxcbiAgICAgIH0sXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFwcC5zd2lwZW91dCwgJ2VsJywge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogKCkgPT4gU3dpcGVvdXQuZWwsXG4gICAgICBzZXQoZWwpIHtcbiAgICAgICAgU3dpcGVvdXQuZWwgPSBlbDtcbiAgICAgIH0sXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFwcC5zd2lwZW91dCwgJ2FsbG93Jywge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogKCkgPT4gU3dpcGVvdXQuYWxsb3csXG4gICAgICBzZXQoYWxsb3cpIHtcbiAgICAgICAgU3dpcGVvdXQuYWxsb3cgPSBhbGxvdztcbiAgICAgIH0sXG4gICAgfSk7XG4gIH0sXG4gIGNsaWNrczoge1xuICAgICcuc3dpcGVvdXQtb3Blbic6IGZ1bmN0aW9uIG9wZW5Td2lwZW91dCgkY2xpY2tlZEVsLCBkYXRhID0ge30pIHtcbiAgICAgIGNvbnN0IGFwcCA9IHRoaXM7XG4gICAgICBhcHAuc3dpcGVvdXQub3BlbihkYXRhLnN3aXBlb3V0LCBkYXRhLnNpZGUpO1xuICAgIH0sXG4gICAgJy5zd2lwZW91dC1jbG9zZSc6IGZ1bmN0aW9uIGNsb3NlU3dpcGVvdXQoJGNsaWNrZWRFbCkge1xuICAgICAgY29uc3QgYXBwID0gdGhpcztcbiAgICAgIGNvbnN0ICRzd2lwZW91dEVsID0gJGNsaWNrZWRFbC5jbG9zZXN0KCcuc3dpcGVvdXQnKTtcbiAgICAgIGlmICgkc3dpcGVvdXRFbC5sZW5ndGggPT09IDApIHJldHVybjtcbiAgICAgIGFwcC5zd2lwZW91dC5jbG9zZSgkc3dpcGVvdXRFbCk7XG4gICAgfSxcbiAgICAnLnN3aXBlb3V0LWRlbGV0ZSc6IGZ1bmN0aW9uIGRlbGV0ZVN3aXBlb3V0KCRjbGlja2VkRWwsIGRhdGEgPSB7fSkge1xuICAgICAgY29uc3QgYXBwID0gdGhpcztcbiAgICAgIGNvbnN0ICRzd2lwZW91dEVsID0gJGNsaWNrZWRFbC5jbG9zZXN0KCcuc3dpcGVvdXQnKTtcbiAgICAgIGlmICgkc3dpcGVvdXRFbC5sZW5ndGggPT09IDApIHJldHVybjtcbiAgICAgIGNvbnN0IHsgY29uZmlybSwgY29uZmlybVRpdGxlIH0gPSBkYXRhO1xuICAgICAgaWYgKGRhdGEuY29uZmlybSkge1xuICAgICAgICBhcHAuZGlhbG9nLmNvbmZpcm0oY29uZmlybSwgY29uZmlybVRpdGxlLCAoKSA9PiB7XG4gICAgICAgICAgYXBwLnN3aXBlb3V0LmRlbGV0ZSgkc3dpcGVvdXRFbCk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXBwLnN3aXBlb3V0LmRlbGV0ZSgkc3dpcGVvdXRFbCk7XG4gICAgICB9XG4gICAgfSxcbiAgfSxcbiAgb246IHtcbiAgICBpbml0KCkge1xuICAgICAgY29uc3QgYXBwID0gdGhpcztcbiAgICAgIGlmICghYXBwLnBhcmFtcy5zd2lwZW91dCkgcmV0dXJuO1xuICAgICAgYXBwLnN3aXBlb3V0LmluaXQoKTtcbiAgICB9LFxuICB9LFxufTtcblxuLyogZXNsaW50IG5vLXVuZGVyc2NvcmUtZGFuZ2xlOiBbXCJlcnJvclwiLCB7IFwiYWxsb3dcIjogW1wiX2NsaWVudExlZnRcIl0gfV0gKi9cblxuY29uc3QgQWNjb3JkaW9uID0ge1xuICB0b2dnbGVDbGlja2VkKCRjbGlja2VkRWwpIHtcbiAgICBjb25zdCBhcHAgPSB0aGlzO1xuICAgIGxldCAkYWNjb3JkaW9uSXRlbUVsID0gJGNsaWNrZWRFbC5jbG9zZXN0KCcuYWNjb3JkaW9uLWl0ZW0nKS5lcSgwKTtcbiAgICBpZiAoISRhY2NvcmRpb25JdGVtRWwubGVuZ3RoKSAkYWNjb3JkaW9uSXRlbUVsID0gJGNsaWNrZWRFbC5wYXJlbnRzKCdsaScpLmVxKDApO1xuICAgIGlmICgkY2xpY2tlZEVsLnBhcmVudHMoJ2xpJykubGVuZ3RoID4gMSAmJiAkY2xpY2tlZEVsLnBhcmVudHMoJ2xpJylbMF0gIT09ICRhY2NvcmRpb25JdGVtRWxbMF0pIHJldHVybjtcbiAgICBhcHAuYWNjb3JkaW9uLnRvZ2dsZSgkYWNjb3JkaW9uSXRlbUVsKTtcbiAgfSxcbiAgb3BlbihlbCkge1xuICAgIGNvbnN0IGFwcCA9IHRoaXM7XG4gICAgY29uc3QgJGVsID0gJChlbCk7XG4gICAgY29uc3QgJGxpc3QgPSAkZWwucGFyZW50cygnLmFjY29yZGlvbi1saXN0JykuZXEoMCk7XG4gICAgbGV0ICRjb250ZW50RWwgPSAkZWwuY2hpbGRyZW4oJy5hY2NvcmRpb24taXRlbS1jb250ZW50Jyk7XG4gICAgaWYgKCRjb250ZW50RWwubGVuZ3RoID09PSAwKSAkY29udGVudEVsID0gJGVsLmZpbmQoJy5hY2NvcmRpb24taXRlbS1jb250ZW50Jyk7XG4gICAgaWYgKCRjb250ZW50RWwubGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgY29uc3QgJG9wZW5lZEl0ZW0gPSAkbGlzdC5sZW5ndGggPiAwICYmICRlbC5wYXJlbnQoKS5jaGlsZHJlbignLmFjY29yZGlvbi1pdGVtLW9wZW5lZCcpO1xuICAgIGlmICgkb3BlbmVkSXRlbS5sZW5ndGggPiAwKSB7XG4gICAgICBhcHAuYWNjb3JkaW9uLmNsb3NlKCRvcGVuZWRJdGVtKTtcbiAgICB9XG4gICAgJGNvbnRlbnRFbC50cmFuc2l0aW9uRW5kKCgpID0+IHtcbiAgICAgIGlmICgkZWwuaGFzQ2xhc3MoJ2FjY29yZGlvbi1pdGVtLW9wZW5lZCcpKSB7XG4gICAgICAgICRjb250ZW50RWwudHJhbnNpdGlvbigwKTtcbiAgICAgICAgJGNvbnRlbnRFbC5jc3MoJ2hlaWdodCcsICdhdXRvJyk7XG4gICAgICAgICRjb250ZW50RWwuX2NsaWVudExlZnQgPSAkY29udGVudEVsWzBdLmNsaWVudExlZnQ7XG4gICAgICAgICRjb250ZW50RWwudHJhbnNpdGlvbignJyk7XG4gICAgICAgICRlbC50cmlnZ2VyKCdhY2NvcmRpb246b3BlbmVkJyk7XG4gICAgICAgIGFwcC5lbWl0KCdhY2NvcmRpb25PcGVuZWQnLCAkZWxbMF0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJGNvbnRlbnRFbC5jc3MoJ2hlaWdodCcsICcnKTtcbiAgICAgICAgJGVsLnRyaWdnZXIoJ2FjY29yZGlvbjpjbG9zZWQnKTtcbiAgICAgICAgYXBwLmVtaXQoJ2FjY29yZGlvbkNsb3NlZCcsICRlbFswXSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgJGNvbnRlbnRFbC5jc3MoJ2hlaWdodCcsIGAkeyRjb250ZW50RWxbMF0uc2Nyb2xsSGVpZ2h0fXB4YCk7XG4gICAgJGVsLnRyaWdnZXIoJ2FjY29yZGlvbjpvcGVuJyk7XG4gICAgJGVsLmFkZENsYXNzKCdhY2NvcmRpb24taXRlbS1vcGVuZWQnKTtcbiAgICBhcHAuZW1pdCgnYWNjb3JkaW9uT3BlbicsICRlbFswXSk7XG4gIH0sXG4gIGNsb3NlKGVsKSB7XG4gICAgY29uc3QgYXBwID0gdGhpcztcbiAgICBjb25zdCAkZWwgPSAkKGVsKTtcbiAgICBsZXQgJGNvbnRlbnRFbCA9ICRlbC5jaGlsZHJlbignLmFjY29yZGlvbi1pdGVtLWNvbnRlbnQnKTtcbiAgICBpZiAoJGNvbnRlbnRFbC5sZW5ndGggPT09IDApICRjb250ZW50RWwgPSAkZWwuZmluZCgnLmFjY29yZGlvbi1pdGVtLWNvbnRlbnQnKTtcbiAgICAkZWwucmVtb3ZlQ2xhc3MoJ2FjY29yZGlvbi1pdGVtLW9wZW5lZCcpO1xuICAgICRjb250ZW50RWwudHJhbnNpdGlvbigwKTtcbiAgICAkY29udGVudEVsLmNzcygnaGVpZ2h0JywgYCR7JGNvbnRlbnRFbFswXS5zY3JvbGxIZWlnaHR9cHhgKTtcbiAgICAkY29udGVudEVsLl9jbGllbnRMZWZ0ID0gJGNvbnRlbnRFbFswXS5jbGllbnRMZWZ0O1xuICAgICRjb250ZW50RWwudHJhbnNpdGlvbignJyk7XG4gICAgLy8gQ2xvc2VcbiAgICAkY29udGVudEVsLnRyYW5zaXRpb25FbmQoKCkgPT4ge1xuICAgICAgaWYgKCRlbC5oYXNDbGFzcygnYWNjb3JkaW9uLWl0ZW0tb3BlbmVkJykpIHtcbiAgICAgICAgJGNvbnRlbnRFbC50cmFuc2l0aW9uKDApO1xuICAgICAgICAkY29udGVudEVsLmNzcygnaGVpZ2h0JywgJ2F1dG8nKTtcbiAgICAgICAgJGNvbnRlbnRFbC5fY2xpZW50TGVmdCA9ICRjb250ZW50RWxbMF0uY2xpZW50TGVmdDtcbiAgICAgICAgJGNvbnRlbnRFbC50cmFuc2l0aW9uKCcnKTtcbiAgICAgICAgJGVsLnRyaWdnZXIoJ2FjY29yZGlvbjpvcGVuZWQnKTtcbiAgICAgICAgYXBwLmVtaXQoJ2FjY29yZGlvbk9wZW5lZCcsICRlbFswXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAkY29udGVudEVsLmNzcygnaGVpZ2h0JywgJycpO1xuICAgICAgICAkZWwudHJpZ2dlcignYWNjb3JkaW9uOmNsb3NlZCcpO1xuICAgICAgICBhcHAuZW1pdCgnYWNjb3JkaW9uQ2xvc2VkJywgJGVsWzBdKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBVdGlscy5uZXh0RnJhbWUoKCkgPT4ge1xuICAgICAgJGNvbnRlbnRFbC50cmFuc2l0aW9uKCcnKTtcbiAgICAgICRjb250ZW50RWwuY3NzKCdoZWlnaHQnLCAnJyk7XG4gICAgICAkZWwudHJpZ2dlcignYWNjb3JkaW9uOmNsb3NlJyk7XG4gICAgICBhcHAuZW1pdCgnYWNjb3JkaW9uQ2xvc2UnKTtcbiAgICB9KTtcbiAgfSxcbiAgdG9nZ2xlKGVsKSB7XG4gICAgY29uc3QgYXBwID0gdGhpcztcbiAgICBjb25zdCAkZWwgPSAkKGVsKTtcbiAgICBpZiAoJGVsLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgIGlmICgkZWwuaGFzQ2xhc3MoJ2FjY29yZGlvbi1pdGVtLW9wZW5lZCcpKSBhcHAuYWNjb3JkaW9uLmNsb3NlKGVsKTtcbiAgICBlbHNlIGFwcC5hY2NvcmRpb24ub3BlbihlbCk7XG4gIH0sXG59O1xuXG52YXIgQWNjb3JkaW9uJDEgPSB7XG4gIG5hbWU6ICdhY2NvcmRpb24nLFxuICBjcmVhdGUoKSB7XG4gICAgY29uc3QgYXBwID0gdGhpcztcbiAgICBVdGlscy5leHRlbmQoYXBwLCB7XG4gICAgICBhY2NvcmRpb246IHtcbiAgICAgICAgb3BlbjogQWNjb3JkaW9uLm9wZW4uYmluZChhcHApLFxuICAgICAgICBjbG9zZTogQWNjb3JkaW9uLmNsb3NlLmJpbmQoYXBwKSxcbiAgICAgICAgdG9nZ2xlOiBBY2NvcmRpb24udG9nZ2xlLmJpbmQoYXBwKSxcbiAgICAgIH0sXG4gICAgfSk7XG4gIH0sXG4gIGNsaWNrczoge1xuICAgICcuYWNjb3JkaW9uLWl0ZW0gLml0ZW0tbGluaywgLmFjY29yZGlvbi1pdGVtLXRvZ2dsZSwgLmxpbmtzLWxpc3QuYWNjb3JkaW9uLWxpc3QgPiB1bCA+IGxpID4gYSc6IGZ1bmN0aW9uIG9wZW4oJGNsaWNrZWRFbCkge1xuICAgICAgY29uc3QgYXBwID0gdGhpcztcbiAgICAgIEFjY29yZGlvbi50b2dnbGVDbGlja2VkLmNhbGwoYXBwLCAkY2xpY2tlZEVsKTtcbiAgICB9LFxuICB9LFxufTtcblxuY2xhc3MgVmlydHVhbExpc3QgZXh0ZW5kcyBGcmFtZXdvcms3Q2xhc3Mge1xuICBjb25zdHJ1Y3RvcihhcHAsIHBhcmFtcyA9IHt9KSB7XG4gICAgc3VwZXIocGFyYW1zLCBbYXBwXSk7XG4gICAgY29uc3QgdmwgPSB0aGlzO1xuXG4gICAgY29uc3QgZGVmYXVsdHMgPSB7XG4gICAgICBjb2xzOiAxLFxuICAgICAgaGVpZ2h0OiBhcHAudGhlbWUgPT09ICdtZCcgPyA0OCA6IDQ0LFxuICAgICAgY2FjaGU6IHRydWUsXG4gICAgICBkeW5hbWljSGVpZ2h0QnVmZmVyU2l6ZTogMSxcbiAgICAgIHNob3dGaWx0ZXJlZEl0ZW1zT25seTogZmFsc2UsXG4gICAgICByZW5kZXJFeHRlcm5hbDogdW5kZWZpbmVkLFxuICAgICAgc2V0TGlzdEhlaWdodDogdHJ1ZSxcbiAgICAgIHNlYXJjaEJ5SXRlbTogdW5kZWZpbmVkLFxuICAgICAgc2VhcmNoQWxsOiB1bmRlZmluZWQsXG4gICAgICBpdGVtVGVtcGxhdGU6IHVuZGVmaW5lZCxcbiAgICAgIHVsOiBudWxsLFxuICAgICAgY3JlYXRlVWw6IHRydWUsXG4gICAgICByZW5kZXJJdGVtKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGBcbiAgICAgICAgICA8bGk+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiaXRlbS1jb250ZW50XCI+XG4gICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJpdGVtLWlubmVyXCI+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIml0ZW0tdGl0bGVcIj4ke2l0ZW19PC9kaXY+XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPC9saT5cbiAgICAgICAgYC50cmltKCk7XG4gICAgICB9LFxuICAgICAgb246IHt9LFxuICAgIH07XG5cbiAgICAvLyBFeHRlbmQgZGVmYXVsdHMgd2l0aCBtb2R1bGVzIHBhcmFtc1xuICAgIHZsLnVzZU1vZHVsZXNQYXJhbXMoZGVmYXVsdHMpO1xuXG4gICAgdmwucGFyYW1zID0gVXRpbHMuZXh0ZW5kKGRlZmF1bHRzLCBwYXJhbXMpO1xuICAgIGlmICh2bC5wYXJhbXMuaGVpZ2h0ID09PSB1bmRlZmluZWQgfHwgIXZsLnBhcmFtcy5oZWlnaHQpIHtcbiAgICAgIHZsLnBhcmFtcy5oZWlnaHQgPSBhcHAudGhlbWUgPT09ICdtZCcgPyA0OCA6IDQ0O1xuICAgIH1cblxuICAgIHZsLiRlbCA9ICQocGFyYW1zLmVsKTtcbiAgICB2bC5lbCA9IHZsLiRlbFswXTtcblxuICAgIGlmICh2bC4kZWwubGVuZ3RoID09PSAwKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgIHZsLiRlbFswXS5mN1ZpcnR1YWxMaXN0ID0gdmw7XG5cbiAgICB2bC5pdGVtcyA9IHZsLnBhcmFtcy5pdGVtcztcbiAgICBpZiAodmwucGFyYW1zLnNob3dGaWx0ZXJlZEl0ZW1zT25seSkge1xuICAgICAgdmwuZmlsdGVyZWRJdGVtcyA9IFtdO1xuICAgIH1cbiAgICBpZiAodmwucGFyYW1zLml0ZW1UZW1wbGF0ZSkge1xuICAgICAgaWYgKHR5cGVvZiB2bC5wYXJhbXMuaXRlbVRlbXBsYXRlID09PSAnc3RyaW5nJykgdmwucmVuZGVySXRlbSA9IFRlbXBsYXRlNy5jb21waWxlKHZsLnBhcmFtcy5pdGVtVGVtcGxhdGUpO1xuICAgICAgZWxzZSBpZiAodHlwZW9mIHZsLnBhcmFtcy5pdGVtVGVtcGxhdGUgPT09ICdmdW5jdGlvbicpIHZsLnJlbmRlckl0ZW0gPSB2bC5wYXJhbXMuaXRlbVRlbXBsYXRlO1xuICAgIH0gZWxzZSBpZiAodmwucGFyYW1zLnJlbmRlckl0ZW0pIHtcbiAgICAgIHZsLnJlbmRlckl0ZW0gPSB2bC5wYXJhbXMucmVuZGVySXRlbTtcbiAgICB9XG4gICAgdmwuJHBhZ2VDb250ZW50RWwgPSB2bC4kZWwucGFyZW50cygnLnBhZ2UtY29udGVudCcpO1xuICAgIHZsLnBhZ2VDb250ZW50RWwgPSB2bC4kcGFnZUNvbnRlbnRFbFswXTtcblxuICAgIC8vIEJhZCBzY3JvbGxcbiAgICBpZiAodHlwZW9mIHZsLnBhcmFtcy51cGRhdGFibGVTY3JvbGwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB2bC51cGRhdGFibGVTY3JvbGwgPSB2bC5wYXJhbXMudXBkYXRhYmxlU2Nyb2xsO1xuICAgIH0gZWxzZSB7XG4gICAgICB2bC51cGRhdGFibGVTY3JvbGwgPSB0cnVlO1xuICAgICAgaWYgKERldmljZS5pb3MgJiYgRGV2aWNlLm9zVmVyc2lvbi5zcGxpdCgnLicpWzBdIDwgOCkge1xuICAgICAgICB2bC51cGRhdGFibGVTY3JvbGwgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBcHBlbmQgPHVsPlxuICAgIGNvbnN0IHVsID0gdmwucGFyYW1zLnVsO1xuICAgIHZsLiR1bCA9IHVsID8gJCh2bC5wYXJhbXMudWwpIDogdmwuJGVsLmNoaWxkcmVuKCd1bCcpO1xuICAgIGlmICh2bC4kdWwubGVuZ3RoID09PSAwICYmIHZsLnBhcmFtcy5jcmVhdGVVbCkge1xuICAgICAgdmwuJGVsLmFwcGVuZCgnPHVsPjwvdWw+Jyk7XG4gICAgICB2bC4kdWwgPSB2bC4kZWwuY2hpbGRyZW4oJ3VsJyk7XG4gICAgfVxuICAgIHZsLnVsID0gdmwuJHVsWzBdO1xuXG4gICAgbGV0ICRpdGVtc1dyYXBFbDtcbiAgICBpZiAoIXZsLnVsICYmICF2bC5wYXJhbXMuY3JlYXRlVWwpICRpdGVtc1dyYXBFbCA9IHZsLiRlbDtcbiAgICBlbHNlICRpdGVtc1dyYXBFbCA9IHZsLiR1bDtcblxuICAgIFV0aWxzLmV4dGVuZCh2bCwge1xuICAgICAgJGl0ZW1zV3JhcEVsLFxuICAgICAgaXRlbXNXcmFwRWw6ICRpdGVtc1dyYXBFbFswXSxcbiAgICAgIC8vIERPTSBjYWNoZWQgaXRlbXNcbiAgICAgIGRvbUNhY2hlOiB7fSxcbiAgICAgIGRpc3BsYXlEb21DYWNoZToge30sXG4gICAgICAvLyBUZW1wb3JhcnkgRE9NIEVsZW1lbnRcbiAgICAgIHRlbXBEb21FbGVtZW50OiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd1bCcpLFxuICAgICAgLy8gTGFzdCByZXBhaW4gcG9zaXRpb25cbiAgICAgIGxhc3RSZXBhaW50WTogbnVsbCxcbiAgICAgIC8vIEZyYWdtZW50XG4gICAgICBmcmFnbWVudDogZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLFxuICAgICAgLy8gUHJvcHNcbiAgICAgIHBhZ2VIZWlnaHQ6IHVuZGVmaW5lZCxcbiAgICAgIHJvd3NQZXJTY3JlZW46IHVuZGVmaW5lZCxcbiAgICAgIHJvd3NCZWZvcmU6IHVuZGVmaW5lZCxcbiAgICAgIHJvd3NBZnRlcjogdW5kZWZpbmVkLFxuICAgICAgcm93c1RvUmVuZGVyOiB1bmRlZmluZWQsXG4gICAgICBtYXhCdWZmZXJIZWlnaHQ6IDAsXG4gICAgICBsaXN0SGVpZ2h0OiB1bmRlZmluZWQsXG4gICAgICBkeW5hbWljSGVpZ2h0OiB0eXBlb2YgdmwucGFyYW1zLmhlaWdodCA9PT0gJ2Z1bmN0aW9uJyxcbiAgICB9KTtcblxuICAgIC8vIEluc3RhbGwgTW9kdWxlc1xuICAgIHZsLnVzZU1vZHVsZXMoKTtcblxuICAgIC8vIEF0dGFjaCBldmVudHNcbiAgICBjb25zdCBoYW5kbGVTY3JvbGxCb3VuZCA9IHZsLmhhbmRsZVNjcm9sbC5iaW5kKHZsKTtcbiAgICBjb25zdCBoYW5kbGVSZXNpemVCb3VuZCA9IHZsLmhhbmRsZVJlc2l6ZS5iaW5kKHZsKTtcbiAgICBsZXQgJHBhZ2VFbDtcbiAgICBsZXQgJHRhYkVsO1xuICAgIGxldCAkcGFuZWxFbDtcbiAgICBsZXQgJHBvcHVwRWw7XG4gICAgdmwuYXR0YWNoRXZlbnRzID0gZnVuY3Rpb24gYXR0YWNoRXZlbnRzKCkge1xuICAgICAgJHBhZ2VFbCA9IHZsLiRlbC5wYXJlbnRzKCcucGFnZScpLmVxKDApO1xuICAgICAgJHRhYkVsID0gdmwuJGVsLnBhcmVudHMoJy50YWInKS5lcSgwKTtcbiAgICAgICRwYW5lbEVsID0gdmwuJGVsLnBhcmVudHMoJy5wYW5lbCcpLmVxKDApO1xuICAgICAgJHBvcHVwRWwgPSB2bC4kZWwucGFyZW50cygnLnBvcHVwJykuZXEoMCk7XG5cbiAgICAgIHZsLiRwYWdlQ29udGVudEVsLm9uKCdzY3JvbGwnLCBoYW5kbGVTY3JvbGxCb3VuZCk7XG4gICAgICBpZiAoJHBhZ2VFbCkgJHBhZ2VFbC5vbigncGFnZTpyZWluaXQnLCBoYW5kbGVSZXNpemVCb3VuZCk7XG4gICAgICBpZiAoJHRhYkVsKSAkdGFiRWwub24oJ3RhYjpzaG93JywgaGFuZGxlUmVzaXplQm91bmQpO1xuICAgICAgaWYgKCRwYW5lbEVsKSAkcGFuZWxFbC5vbigncGFuZWw6b3BlbicsIGhhbmRsZVJlc2l6ZUJvdW5kKTtcbiAgICAgIGlmICgkcG9wdXBFbCkgJHBvcHVwRWwub24oJ3BvcHVwOm9wZW4nLCBoYW5kbGVSZXNpemVCb3VuZCk7XG4gICAgICBhcHAub24oJ3Jlc2l6ZScsIGhhbmRsZVJlc2l6ZUJvdW5kKTtcbiAgICB9O1xuICAgIHZsLmRldGFjaEV2ZW50cyA9IGZ1bmN0aW9uIGF0dGFjaEV2ZW50cygpIHtcbiAgICAgIHZsLiRwYWdlQ29udGVudEVsLm9mZignc2Nyb2xsJywgaGFuZGxlU2Nyb2xsQm91bmQpO1xuICAgICAgaWYgKCRwYWdlRWwpICRwYWdlRWwub2ZmKCdwYWdlOnJlaW5pdCcsIGhhbmRsZVJlc2l6ZUJvdW5kKTtcbiAgICAgIGlmICgkdGFiRWwpICR0YWJFbC5vZmYoJ3RhYjpzaG93JywgaGFuZGxlUmVzaXplQm91bmQpO1xuICAgICAgaWYgKCRwYW5lbEVsKSAkcGFuZWxFbC5vZmYoJ3BhbmVsOm9wZW4nLCBoYW5kbGVSZXNpemVCb3VuZCk7XG4gICAgICBpZiAoJHBvcHVwRWwpICRwb3B1cEVsLm9mZigncG9wdXA6b3BlbicsIGhhbmRsZVJlc2l6ZUJvdW5kKTtcbiAgICAgIGFwcC5vZmYoJ3Jlc2l6ZScsIGhhbmRsZVJlc2l6ZUJvdW5kKTtcbiAgICB9O1xuICAgIC8vIEluaXRcbiAgICB2bC5pbml0KCk7XG5cbiAgICByZXR1cm4gdmw7XG4gIH1cbiAgc2V0TGlzdFNpemUoKSB7XG4gICAgY29uc3QgdmwgPSB0aGlzO1xuICAgIGNvbnN0IGl0ZW1zID0gdmwuZmlsdGVyZWRJdGVtcyB8fCB2bC5pdGVtcztcbiAgICB2bC5wYWdlSGVpZ2h0ID0gdmwuJHBhZ2VDb250ZW50RWxbMF0ub2Zmc2V0SGVpZ2h0O1xuICAgIGlmICh2bC5keW5hbWljSGVpZ2h0KSB7XG4gICAgICB2bC5saXN0SGVpZ2h0ID0gMDtcbiAgICAgIHZsLmhlaWdodHMgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgY29uc3QgaXRlbUhlaWdodCA9IHZsLnBhcmFtcy5oZWlnaHQoaXRlbXNbaV0pO1xuICAgICAgICB2bC5saXN0SGVpZ2h0ICs9IGl0ZW1IZWlnaHQ7XG4gICAgICAgIHZsLmhlaWdodHMucHVzaChpdGVtSGVpZ2h0KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmwubGlzdEhlaWdodCA9IE1hdGguY2VpbChpdGVtcy5sZW5ndGggLyB2bC5wYXJhbXMuY29scykgKiB2bC5wYXJhbXMuaGVpZ2h0O1xuICAgICAgdmwucm93c1BlclNjcmVlbiA9IE1hdGguY2VpbCh2bC5wYWdlSGVpZ2h0IC8gdmwucGFyYW1zLmhlaWdodCk7XG4gICAgICB2bC5yb3dzQmVmb3JlID0gdmwucGFyYW1zLnJvd3NCZWZvcmUgfHwgdmwucm93c1BlclNjcmVlbiAqIDI7XG4gICAgICB2bC5yb3dzQWZ0ZXIgPSB2bC5wYXJhbXMucm93c0FmdGVyIHx8IHZsLnJvd3NQZXJTY3JlZW47XG4gICAgICB2bC5yb3dzVG9SZW5kZXIgPSAodmwucm93c1BlclNjcmVlbiArIHZsLnJvd3NCZWZvcmUgKyB2bC5yb3dzQWZ0ZXIpO1xuICAgICAgdmwubWF4QnVmZmVySGVpZ2h0ID0gKHZsLnJvd3NCZWZvcmUgLyAyKSAqIHZsLnBhcmFtcy5oZWlnaHQ7XG4gICAgfVxuXG4gICAgaWYgKHZsLnVwZGF0YWJsZVNjcm9sbCB8fCB2bC5wYXJhbXMuc2V0TGlzdEhlaWdodCkge1xuICAgICAgdmwuJGl0ZW1zV3JhcEVsLmNzcyh7IGhlaWdodDogYCR7dmwubGlzdEhlaWdodH1weGAgfSk7XG4gICAgfVxuICB9XG4gIHJlbmRlcihmb3JjZSwgZm9yY2VTY3JvbGxUb3ApIHtcbiAgICBjb25zdCB2bCA9IHRoaXM7XG4gICAgaWYgKGZvcmNlKSB2bC5sYXN0UmVwYWludFkgPSBudWxsO1xuXG4gICAgbGV0IHNjcm9sbFRvcCA9IC0odmwuJGVsWzBdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCAtIHZsLiRwYWdlQ29udGVudEVsWzBdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCk7XG5cbiAgICBpZiAodHlwZW9mIGZvcmNlU2Nyb2xsVG9wICE9PSAndW5kZWZpbmVkJykgc2Nyb2xsVG9wID0gZm9yY2VTY3JvbGxUb3A7XG4gICAgaWYgKHZsLmxhc3RSZXBhaW50WSA9PT0gbnVsbCB8fCBNYXRoLmFicyhzY3JvbGxUb3AgLSB2bC5sYXN0UmVwYWludFkpID4gdmwubWF4QnVmZmVySGVpZ2h0IHx8ICghdmwudXBkYXRhYmxlU2Nyb2xsICYmICh2bC4kcGFnZUNvbnRlbnRFbFswXS5zY3JvbGxUb3AgKyB2bC5wYWdlSGVpZ2h0ID49IHZsLiRwYWdlQ29udGVudEVsWzBdLnNjcm9sbEhlaWdodCkpKSB7XG4gICAgICB2bC5sYXN0UmVwYWludFkgPSBzY3JvbGxUb3A7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBpdGVtcyA9IHZsLmZpbHRlcmVkSXRlbXMgfHwgdmwuaXRlbXM7XG4gICAgbGV0IGZyb21JbmRleDtcbiAgICBsZXQgdG9JbmRleDtcbiAgICBsZXQgaGVpZ2h0QmVmb3JlRmlyc3RJdGVtID0gMDtcbiAgICBsZXQgaGVpZ2h0QmVmb3JlTGFzdEl0ZW0gPSAwO1xuICAgIGlmICh2bC5keW5hbWljSGVpZ2h0KSB7XG4gICAgICBsZXQgaXRlbVRvcCA9IDA7XG4gICAgICBsZXQgaXRlbUhlaWdodDtcbiAgICAgIHZsLm1heEJ1ZmZlckhlaWdodCA9IHZsLnBhZ2VIZWlnaHQ7XG5cbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdmwuaGVpZ2h0cy5sZW5ndGg7IGogKz0gMSkge1xuICAgICAgICBpdGVtSGVpZ2h0ID0gdmwuaGVpZ2h0c1tqXTtcbiAgICAgICAgaWYgKHR5cGVvZiBmcm9tSW5kZXggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgaWYgKGl0ZW1Ub3AgKyBpdGVtSGVpZ2h0ID49IHNjcm9sbFRvcCAtICh2bC5wYWdlSGVpZ2h0ICogMiAqIHZsLnBhcmFtcy5keW5hbWljSGVpZ2h0QnVmZmVyU2l6ZSkpIGZyb21JbmRleCA9IGo7XG4gICAgICAgICAgZWxzZSBoZWlnaHRCZWZvcmVGaXJzdEl0ZW0gKz0gaXRlbUhlaWdodDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgdG9JbmRleCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBpZiAoaXRlbVRvcCArIGl0ZW1IZWlnaHQgPj0gc2Nyb2xsVG9wICsgKHZsLnBhZ2VIZWlnaHQgKiAyICogdmwucGFyYW1zLmR5bmFtaWNIZWlnaHRCdWZmZXJTaXplKSB8fCBqID09PSB2bC5oZWlnaHRzLmxlbmd0aCAtIDEpIHRvSW5kZXggPSBqICsgMTtcbiAgICAgICAgICBoZWlnaHRCZWZvcmVMYXN0SXRlbSArPSBpdGVtSGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIGl0ZW1Ub3AgKz0gaXRlbUhlaWdodDtcbiAgICAgIH1cbiAgICAgIHRvSW5kZXggPSBNYXRoLm1pbih0b0luZGV4LCBpdGVtcy5sZW5ndGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmcm9tSW5kZXggPSAocGFyc2VJbnQoc2Nyb2xsVG9wIC8gdmwucGFyYW1zLmhlaWdodCwgMTApIC0gdmwucm93c0JlZm9yZSkgKiB2bC5wYXJhbXMuY29scztcbiAgICAgIGlmIChmcm9tSW5kZXggPCAwKSB7XG4gICAgICAgIGZyb21JbmRleCA9IDA7XG4gICAgICB9XG4gICAgICB0b0luZGV4ID0gTWF0aC5taW4oZnJvbUluZGV4ICsgKHZsLnJvd3NUb1JlbmRlciAqIHZsLnBhcmFtcy5jb2xzKSwgaXRlbXMubGVuZ3RoKTtcbiAgICB9XG5cbiAgICBsZXQgdG9wUG9zaXRpb247XG4gICAgY29uc3QgcmVuZGVyRXh0ZXJuYWxJdGVtcyA9IFtdO1xuICAgIHZsLnJlYWNoRW5kID0gZmFsc2U7XG4gICAgbGV0IGk7XG4gICAgZm9yIChpID0gZnJvbUluZGV4OyBpIDwgdG9JbmRleDsgaSArPSAxKSB7XG4gICAgICBsZXQgaXRlbUVsO1xuICAgICAgLy8gRGVmaW5lIHJlYWwgaXRlbSBpbmRleFxuICAgICAgY29uc3QgaW5kZXggPSB2bC5pdGVtcy5pbmRleE9mKGl0ZW1zW2ldKTtcblxuICAgICAgaWYgKGkgPT09IGZyb21JbmRleCkgdmwuY3VycmVudEZyb21JbmRleCA9IGluZGV4O1xuICAgICAgaWYgKGkgPT09IHRvSW5kZXggLSAxKSB2bC5jdXJyZW50VG9JbmRleCA9IGluZGV4O1xuICAgICAgaWYgKHZsLmZpbHRlcmVkSXRlbXMpIHtcbiAgICAgICAgaWYgKHZsLml0ZW1zW2luZGV4XSA9PT0gdmwuZmlsdGVyZWRJdGVtc1t2bC5maWx0ZXJlZEl0ZW1zLmxlbmd0aCAtIDFdKSB2bC5yZWFjaEVuZCA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGluZGV4ID09PSB2bC5pdGVtcy5sZW5ndGggLSAxKSB2bC5yZWFjaEVuZCA9IHRydWU7XG5cbiAgICAgIC8vIEZpbmQgaXRlbXNcbiAgICAgIGlmICh2bC5wYXJhbXMucmVuZGVyRXh0ZXJuYWwpIHtcbiAgICAgICAgcmVuZGVyRXh0ZXJuYWxJdGVtcy5wdXNoKGl0ZW1zW2ldKTtcbiAgICAgIH0gZWxzZSBpZiAodmwuZG9tQ2FjaGVbaW5kZXhdKSB7XG4gICAgICAgIGl0ZW1FbCA9IHZsLmRvbUNhY2hlW2luZGV4XTtcbiAgICAgICAgaXRlbUVsLmY3VmlydHVhbExpc3RJbmRleCA9IGluZGV4O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHZsLnJlbmRlckl0ZW0pIHtcbiAgICAgICAgICB2bC50ZW1wRG9tRWxlbWVudC5pbm5lckhUTUwgPSB2bC5yZW5kZXJJdGVtKGl0ZW1zW2ldLCBpbmRleCkudHJpbSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZsLnRlbXBEb21FbGVtZW50LmlubmVySFRNTCA9IGl0ZW1zW2ldLnRvU3RyaW5nKCkudHJpbSgpO1xuICAgICAgICB9XG4gICAgICAgIGl0ZW1FbCA9IHZsLnRlbXBEb21FbGVtZW50LmNoaWxkTm9kZXNbMF07XG4gICAgICAgIGlmICh2bC5wYXJhbXMuY2FjaGUpIHZsLmRvbUNhY2hlW2luZGV4XSA9IGl0ZW1FbDtcbiAgICAgICAgaXRlbUVsLmY3VmlydHVhbExpc3RJbmRleCA9IGluZGV4O1xuICAgICAgfVxuXG4gICAgICAvLyBTZXQgaXRlbSB0b3AgcG9zaXRpb25cbiAgICAgIGlmIChpID09PSBmcm9tSW5kZXgpIHtcbiAgICAgICAgaWYgKHZsLmR5bmFtaWNIZWlnaHQpIHtcbiAgICAgICAgICB0b3BQb3NpdGlvbiA9IGhlaWdodEJlZm9yZUZpcnN0SXRlbTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0b3BQb3NpdGlvbiA9ICgoaSAqIHZsLnBhcmFtcy5oZWlnaHQpIC8gdmwucGFyYW1zLmNvbHMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIXZsLnBhcmFtcy5yZW5kZXJFeHRlcm5hbCkge1xuICAgICAgICBpdGVtRWwuc3R5bGUudG9wID0gYCR7dG9wUG9zaXRpb259cHhgO1xuXG4gICAgICAgIC8vIEJlZm9yZSBpdGVtIGluc2VydFxuICAgICAgICB2bC5lbWl0KCdsb2NhbDo6aXRlbUJlZm9yZUluc2VydCB2bEl0ZW1CZWZvcmVJbnNlcnQnLCB2bCwgaXRlbUVsLCBpdGVtc1tpXSk7XG5cbiAgICAgICAgLy8gQXBwZW5kIGl0ZW0gdG8gZnJhZ21lbnRcbiAgICAgICAgdmwuZnJhZ21lbnQuYXBwZW5kQ2hpbGQoaXRlbUVsKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgbGlzdCBoZWlnaHQgd2l0aCBub3QgdXBkYXRhYmxlIHNjcm9sbFxuICAgIGlmICghdmwudXBkYXRhYmxlU2Nyb2xsKSB7XG4gICAgICBpZiAodmwuZHluYW1pY0hlaWdodCkge1xuICAgICAgICB2bC5pdGVtc1dyYXBFbC5zdHlsZS5oZWlnaHQgPSBgJHtoZWlnaHRCZWZvcmVMYXN0SXRlbX1weGA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2bC5pdGVtc1dyYXBFbC5zdHlsZS5oZWlnaHQgPSBgJHsoaSAqIHZsLnBhcmFtcy5oZWlnaHQpIC8gdmwucGFyYW1zLmNvbHN9cHhgO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFVwZGF0ZSBsaXN0IGh0bWxcbiAgICBpZiAodmwucGFyYW1zLnJlbmRlckV4dGVybmFsKSB7XG4gICAgICBpZiAoaXRlbXMgJiYgaXRlbXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHZsLnJlYWNoRW5kID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmwuZW1pdCgnbG9jYWw6OmJlZm9yZUNsZWFyIHZsQmVmb3JlQ2xlYXInLCB2bCwgdmwuZnJhZ21lbnQpO1xuICAgICAgdmwuaXRlbXNXcmFwRWwuaW5uZXJIVE1MID0gJyc7XG5cbiAgICAgIHZsLmVtaXQoJ2xvY2FsOjppdGVtc0JlZm9yZUluc2VydCB2bEl0ZW1zQmVmb3JlSW5zZXJ0JywgdmwsIHZsLmZyYWdtZW50KTtcblxuICAgICAgaWYgKGl0ZW1zICYmIGl0ZW1zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB2bC5yZWFjaEVuZCA9IHRydWU7XG4gICAgICAgIGlmICh2bC5wYXJhbXMuZW1wdHlUZW1wbGF0ZSkgdmwuaXRlbXNXcmFwRWwuaW5uZXJIVE1MID0gdmwucGFyYW1zLmVtcHR5VGVtcGxhdGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2bC5pdGVtc1dyYXBFbC5hcHBlbmRDaGlsZCh2bC5mcmFnbWVudCk7XG4gICAgICB9XG5cbiAgICAgIHZsLmVtaXQoJ2xvY2FsOjppdGVtc0FmdGVySW5zZXJ0IHZsSXRlbXNBZnRlckluc2VydCcsIHZsLCB2bC5mcmFnbWVudCk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBmb3JjZVNjcm9sbFRvcCAhPT0gJ3VuZGVmaW5lZCcgJiYgZm9yY2UpIHtcbiAgICAgIHZsLiRwYWdlQ29udGVudEVsLnNjcm9sbFRvcChmb3JjZVNjcm9sbFRvcCwgMCk7XG4gICAgfVxuICAgIGlmICh2bC5wYXJhbXMucmVuZGVyRXh0ZXJuYWwpIHtcbiAgICAgIHZsLnBhcmFtcy5yZW5kZXJFeHRlcm5hbCh2bCwge1xuICAgICAgICBmcm9tSW5kZXgsXG4gICAgICAgIHRvSW5kZXgsXG4gICAgICAgIGxpc3RIZWlnaHQ6IHZsLmxpc3RIZWlnaHQsXG4gICAgICAgIHRvcFBvc2l0aW9uLFxuICAgICAgICBpdGVtczogcmVuZGVyRXh0ZXJuYWxJdGVtcyxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICAvLyBGaWx0ZXJcbiAgZmlsdGVySXRlbXMoaW5kZXhlcywgcmVzZXRTY3JvbGxUb3AgPSB0cnVlKSB7XG4gICAgY29uc3QgdmwgPSB0aGlzO1xuICAgIHZsLmZpbHRlcmVkSXRlbXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluZGV4ZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIHZsLmZpbHRlcmVkSXRlbXMucHVzaCh2bC5pdGVtc1tpbmRleGVzW2ldXSk7XG4gICAgfVxuICAgIGlmIChyZXNldFNjcm9sbFRvcCkge1xuICAgICAgdmwuJHBhZ2VDb250ZW50RWxbMF0uc2Nyb2xsVG9wID0gMDtcbiAgICB9XG4gICAgdmwudXBkYXRlKCk7XG4gIH1cbiAgcmVzZXRGaWx0ZXIoKSB7XG4gICAgY29uc3QgdmwgPSB0aGlzO1xuICAgIGlmICh2bC5wYXJhbXMuc2hvd0ZpbHRlcmVkSXRlbXNPbmx5KSB7XG4gICAgICB2bC5maWx0ZXJlZEl0ZW1zID0gW107XG4gICAgfSBlbHNlIHtcbiAgICAgIHZsLmZpbHRlcmVkSXRlbXMgPSBudWxsO1xuICAgICAgZGVsZXRlIHZsLmZpbHRlcmVkSXRlbXM7XG4gICAgfVxuICAgIHZsLnVwZGF0ZSgpO1xuICB9XG4gIHNjcm9sbFRvSXRlbShpbmRleCkge1xuICAgIGNvbnN0IHZsID0gdGhpcztcbiAgICBpZiAoaW5kZXggPiB2bC5pdGVtcy5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICBsZXQgaXRlbVRvcCA9IDA7XG4gICAgaWYgKHZsLmR5bmFtaWNIZWlnaHQpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5kZXg7IGkgKz0gMSkge1xuICAgICAgICBpdGVtVG9wICs9IHZsLmhlaWdodHNbaV07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGl0ZW1Ub3AgPSBpbmRleCAqIHZsLnBhcmFtcy5oZWlnaHQ7XG4gICAgfVxuICAgIGNvbnN0IGxpc3RUb3AgPSB2bC4kZWxbMF0ub2Zmc2V0VG9wO1xuICAgIHZsLnJlbmRlcih0cnVlLCAobGlzdFRvcCArIGl0ZW1Ub3ApIC0gcGFyc2VJbnQodmwuJHBhZ2VDb250ZW50RWwuY3NzKCdwYWRkaW5nLXRvcCcpLCAxMCkpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGhhbmRsZVNjcm9sbCgpIHtcbiAgICBjb25zdCB2bCA9IHRoaXM7XG4gICAgdmwucmVuZGVyKCk7XG4gIH1cbiAgLy8gSGFuZGxlIHJlc2l6ZSBldmVudFxuICBpc1Zpc2libGUoKSB7XG4gICAgY29uc3QgdmwgPSB0aGlzO1xuICAgIHJldHVybiAhISh2bC5lbC5vZmZzZXRXaWR0aCB8fCB2bC5lbC5vZmZzZXRIZWlnaHQgfHwgdmwuZWwuZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGgpO1xuICB9XG4gIGhhbmRsZVJlc2l6ZSgpIHtcbiAgICBjb25zdCB2bCA9IHRoaXM7XG4gICAgaWYgKHZsLmlzVmlzaWJsZSgpKSB7XG4gICAgICB2bC5zZXRMaXN0U2l6ZSgpO1xuICAgICAgdmwucmVuZGVyKHRydWUpO1xuICAgIH1cbiAgfVxuICAvLyBBcHBlbmRcbiAgYXBwZW5kSXRlbXMoaXRlbXMpIHtcbiAgICBjb25zdCB2bCA9IHRoaXM7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgdmwuaXRlbXMucHVzaChpdGVtc1tpXSk7XG4gICAgfVxuICAgIHZsLnVwZGF0ZSgpO1xuICB9XG4gIGFwcGVuZEl0ZW0oaXRlbSkge1xuICAgIGNvbnN0IHZsID0gdGhpcztcbiAgICB2bC5hcHBlbmRJdGVtcyhbaXRlbV0pO1xuICB9XG4gIC8vIFJlcGxhY2VcbiAgcmVwbGFjZUFsbEl0ZW1zKGl0ZW1zKSB7XG4gICAgY29uc3QgdmwgPSB0aGlzO1xuICAgIHZsLml0ZW1zID0gaXRlbXM7XG4gICAgZGVsZXRlIHZsLmZpbHRlcmVkSXRlbXM7XG4gICAgdmwuZG9tQ2FjaGUgPSB7fTtcbiAgICB2bC51cGRhdGUoKTtcbiAgfVxuICByZXBsYWNlSXRlbShpbmRleCwgaXRlbSkge1xuICAgIGNvbnN0IHZsID0gdGhpcztcbiAgICB2bC5pdGVtc1tpbmRleF0gPSBpdGVtO1xuICAgIGlmICh2bC5wYXJhbXMuY2FjaGUpIGRlbGV0ZSB2bC5kb21DYWNoZVtpbmRleF07XG4gICAgdmwudXBkYXRlKCk7XG4gIH1cbiAgLy8gUHJlcGVuZFxuICBwcmVwZW5kSXRlbXMoaXRlbXMpIHtcbiAgICBjb25zdCB2bCA9IHRoaXM7XG4gICAgZm9yIChsZXQgaSA9IGl0ZW1zLmxlbmd0aCAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7XG4gICAgICB2bC5pdGVtcy51bnNoaWZ0KGl0ZW1zW2ldKTtcbiAgICB9XG4gICAgaWYgKHZsLnBhcmFtcy5jYWNoZSkge1xuICAgICAgY29uc3QgbmV3Q2FjaGUgPSB7fTtcbiAgICAgIE9iamVjdC5rZXlzKHZsLmRvbUNhY2hlKS5mb3JFYWNoKChjYWNoZWQpID0+IHtcbiAgICAgICAgbmV3Q2FjaGVbcGFyc2VJbnQoY2FjaGVkLCAxMCkgKyBpdGVtcy5sZW5ndGhdID0gdmwuZG9tQ2FjaGVbY2FjaGVkXTtcbiAgICAgIH0pO1xuICAgICAgdmwuZG9tQ2FjaGUgPSBuZXdDYWNoZTtcbiAgICB9XG4gICAgdmwudXBkYXRlKCk7XG4gIH1cbiAgcHJlcGVuZEl0ZW0oaXRlbSkge1xuICAgIGNvbnN0IHZsID0gdGhpcztcbiAgICB2bC5wcmVwZW5kSXRlbXMoW2l0ZW1dKTtcbiAgfVxuXG4gIC8vIE1vdmVcbiAgbW92ZUl0ZW0oZnJvbSwgdG8pIHtcbiAgICBjb25zdCB2bCA9IHRoaXM7XG4gICAgY29uc3QgZnJvbUluZGV4ID0gZnJvbTtcbiAgICBsZXQgdG9JbmRleCA9IHRvO1xuICAgIGlmIChmcm9tSW5kZXggPT09IHRvSW5kZXgpIHJldHVybjtcbiAgICAvLyByZW1vdmUgaXRlbSBmcm9tIGFycmF5XG4gICAgY29uc3QgaXRlbSA9IHZsLml0ZW1zLnNwbGljZShmcm9tSW5kZXgsIDEpWzBdO1xuICAgIGlmICh0b0luZGV4ID49IHZsLml0ZW1zLmxlbmd0aCkge1xuICAgICAgLy8gQWRkIGl0ZW0gdG8gdGhlIGVuZFxuICAgICAgdmwuaXRlbXMucHVzaChpdGVtKTtcbiAgICAgIHRvSW5kZXggPSB2bC5pdGVtcy5sZW5ndGggLSAxO1xuICAgIH0gZWxzZSB7XG4gICAgLy8gQWRkIGl0ZW0gdG8gbmV3IGluZGV4XG4gICAgICB2bC5pdGVtcy5zcGxpY2UodG9JbmRleCwgMCwgaXRlbSk7XG4gICAgfVxuICAgIC8vIFVwZGF0ZSBjYWNoZVxuICAgIGlmICh2bC5wYXJhbXMuY2FjaGUpIHtcbiAgICAgIGNvbnN0IG5ld0NhY2hlID0ge307XG4gICAgICBPYmplY3Qua2V5cyh2bC5kb21DYWNoZSkuZm9yRWFjaCgoY2FjaGVkKSA9PiB7XG4gICAgICAgIGNvbnN0IGNhY2hlZEluZGV4ID0gcGFyc2VJbnQoY2FjaGVkLCAxMCk7XG4gICAgICAgIGNvbnN0IGxlZnRJbmRleCA9IGZyb21JbmRleCA8IHRvSW5kZXggPyBmcm9tSW5kZXggOiB0b0luZGV4O1xuICAgICAgICBjb25zdCByaWdodEluZGV4ID0gZnJvbUluZGV4IDwgdG9JbmRleCA/IHRvSW5kZXggOiBmcm9tSW5kZXg7XG4gICAgICAgIGNvbnN0IGluZGV4U2hpZnQgPSBmcm9tSW5kZXggPCB0b0luZGV4ID8gLTEgOiAxO1xuICAgICAgICBpZiAoY2FjaGVkSW5kZXggPCBsZWZ0SW5kZXggfHwgY2FjaGVkSW5kZXggPiByaWdodEluZGV4KSBuZXdDYWNoZVtjYWNoZWRJbmRleF0gPSB2bC5kb21DYWNoZVtjYWNoZWRJbmRleF07XG4gICAgICAgIGlmIChjYWNoZWRJbmRleCA9PT0gbGVmdEluZGV4KSBuZXdDYWNoZVtyaWdodEluZGV4XSA9IHZsLmRvbUNhY2hlW2NhY2hlZEluZGV4XTtcbiAgICAgICAgaWYgKGNhY2hlZEluZGV4ID4gbGVmdEluZGV4ICYmIGNhY2hlZEluZGV4IDw9IHJpZ2h0SW5kZXgpIG5ld0NhY2hlW2NhY2hlZEluZGV4ICsgaW5kZXhTaGlmdF0gPSB2bC5kb21DYWNoZVtjYWNoZWRJbmRleF07XG4gICAgICB9KTtcbiAgICAgIHZsLmRvbUNhY2hlID0gbmV3Q2FjaGU7XG4gICAgfVxuICAgIHZsLnVwZGF0ZSgpO1xuICB9XG4gIC8vIEluc2VydCBiZWZvcmVcbiAgaW5zZXJ0SXRlbUJlZm9yZShpbmRleCwgaXRlbSkge1xuICAgIGNvbnN0IHZsID0gdGhpcztcbiAgICBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgIHZsLnByZXBlbmRJdGVtKGl0ZW0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoaW5kZXggPj0gdmwuaXRlbXMubGVuZ3RoKSB7XG4gICAgICB2bC5hcHBlbmRJdGVtKGl0ZW0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2bC5pdGVtcy5zcGxpY2UoaW5kZXgsIDAsIGl0ZW0pO1xuICAgIC8vIFVwZGF0ZSBjYWNoZVxuICAgIGlmICh2bC5wYXJhbXMuY2FjaGUpIHtcbiAgICAgIGNvbnN0IG5ld0NhY2hlID0ge307XG4gICAgICBPYmplY3Qua2V5cyh2bC5kb21DYWNoZSkuZm9yRWFjaCgoY2FjaGVkKSA9PiB7XG4gICAgICAgIGNvbnN0IGNhY2hlZEluZGV4ID0gcGFyc2VJbnQoY2FjaGVkLCAxMCk7XG4gICAgICAgIGlmIChjYWNoZWRJbmRleCA+PSBpbmRleCkge1xuICAgICAgICAgIG5ld0NhY2hlW2NhY2hlZEluZGV4ICsgMV0gPSB2bC5kb21DYWNoZVtjYWNoZWRJbmRleF07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdmwuZG9tQ2FjaGUgPSBuZXdDYWNoZTtcbiAgICB9XG4gICAgdmwudXBkYXRlKCk7XG4gIH1cbiAgLy8gRGVsZXRlXG4gIGRlbGV0ZUl0ZW1zKGluZGV4ZXMpIHtcbiAgICBjb25zdCB2bCA9IHRoaXM7XG4gICAgbGV0IHByZXZJbmRleDtcbiAgICBsZXQgaW5kZXhTaGlmdCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbmRleGVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBsZXQgaW5kZXggPSBpbmRleGVzW2ldO1xuICAgICAgaWYgKHR5cGVvZiBwcmV2SW5kZXggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGlmIChpbmRleCA+IHByZXZJbmRleCkge1xuICAgICAgICAgIGluZGV4U2hpZnQgPSAtaTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaW5kZXggKz0gaW5kZXhTaGlmdDtcbiAgICAgIHByZXZJbmRleCA9IGluZGV4ZXNbaV07XG4gICAgICAvLyBEZWxldGUgaXRlbVxuICAgICAgY29uc3QgZGVsZXRlZEl0ZW0gPSB2bC5pdGVtcy5zcGxpY2UoaW5kZXgsIDEpWzBdO1xuXG4gICAgICAvLyBEZWxldGUgZnJvbSBmaWx0ZXJlZFxuICAgICAgaWYgKHZsLmZpbHRlcmVkSXRlbXMgJiYgdmwuZmlsdGVyZWRJdGVtcy5pbmRleE9mKGRlbGV0ZWRJdGVtKSA+PSAwKSB7XG4gICAgICAgIHZsLmZpbHRlcmVkSXRlbXMuc3BsaWNlKHZsLmZpbHRlcmVkSXRlbXMuaW5kZXhPZihkZWxldGVkSXRlbSksIDEpO1xuICAgICAgfVxuICAgICAgLy8gVXBkYXRlIGNhY2hlXG4gICAgICBpZiAodmwucGFyYW1zLmNhY2hlKSB7XG4gICAgICAgIGNvbnN0IG5ld0NhY2hlID0ge307XG4gICAgICAgIE9iamVjdC5rZXlzKHZsLmRvbUNhY2hlKS5mb3JFYWNoKChjYWNoZWQpID0+IHtcbiAgICAgICAgICBjb25zdCBjYWNoZWRJbmRleCA9IHBhcnNlSW50KGNhY2hlZCwgMTApO1xuICAgICAgICAgIGlmIChjYWNoZWRJbmRleCA9PT0gaW5kZXgpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB2bC5kb21DYWNoZVtpbmRleF07XG4gICAgICAgICAgfSBlbHNlIGlmIChwYXJzZUludChjYWNoZWQsIDEwKSA+IGluZGV4KSB7XG4gICAgICAgICAgICBuZXdDYWNoZVtjYWNoZWRJbmRleCAtIDFdID0gdmwuZG9tQ2FjaGVbY2FjaGVkXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3Q2FjaGVbY2FjaGVkSW5kZXhdID0gdmwuZG9tQ2FjaGVbY2FjaGVkXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB2bC5kb21DYWNoZSA9IG5ld0NhY2hlO1xuICAgICAgfVxuICAgIH1cbiAgICB2bC51cGRhdGUoKTtcbiAgfVxuICBkZWxldGVBbGxJdGVtcygpIHtcbiAgICBjb25zdCB2bCA9IHRoaXM7XG4gICAgdmwuaXRlbXMgPSBbXTtcbiAgICBkZWxldGUgdmwuZmlsdGVyZWRJdGVtcztcbiAgICBpZiAodmwucGFyYW1zLmNhY2hlKSB2bC5kb21DYWNoZSA9IHt9O1xuICAgIHZsLnVwZGF0ZSgpO1xuICB9XG4gIGRlbGV0ZUl0ZW0oaW5kZXgpIHtcbiAgICBjb25zdCB2bCA9IHRoaXM7XG4gICAgdmwuZGVsZXRlSXRlbXMoW2luZGV4XSk7XG4gIH1cbiAgLy8gQ2xlYXIgY2FjaGVcbiAgY2xlYXJDYWNoZWZ1bmN0aW9uKCkge1xuICAgIGNvbnN0IHZsID0gdGhpcztcbiAgICB2bC5kb21DYWNoZSA9IHt9O1xuICB9XG4gIC8vIFVwZGF0ZSBWaXJ0dWFsIExpc3RcbiAgdXBkYXRlKGRlbGV0ZUNhY2hlKSB7XG4gICAgY29uc3QgdmwgPSB0aGlzO1xuICAgIGlmIChkZWxldGVDYWNoZSAmJiB2bC5wYXJhbXMuY2FjaGUpIHtcbiAgICAgIHZsLmRvbUNhY2hlID0ge307XG4gICAgfVxuICAgIHZsLnNldExpc3RTaXplKCk7XG4gICAgdmwucmVuZGVyKHRydWUpO1xuICB9XG4gIGluaXQoKSB7XG4gICAgY29uc3QgdmwgPSB0aGlzO1xuICAgIHZsLmF0dGFjaEV2ZW50cygpO1xuICAgIHZsLnNldExpc3RTaXplKCk7XG4gICAgdmwucmVuZGVyKCk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICBsZXQgdmwgPSB0aGlzO1xuICAgIHZsLmRldGFjaEV2ZW50cygpO1xuICAgIHZsLiRlbFswXS5mN1ZpcnR1YWxMaXN0ID0gbnVsbDtcbiAgICBkZWxldGUgdmwuJGVsWzBdLmY3VmlydHVhbExpc3Q7XG4gICAgVXRpbHMuZGVsZXRlUHJvcHModmwpO1xuICAgIHZsID0gbnVsbDtcbiAgfVxufVxuXG52YXIgVmlydHVhbExpc3QkMSA9IHtcbiAgbmFtZTogJ3ZpcnR1YWxMaXN0JyxcbiAgc3RhdGljOiB7XG4gICAgVmlydHVhbExpc3QsXG4gIH0sXG4gIGNyZWF0ZSgpIHtcbiAgICBjb25zdCBhcHAgPSB0aGlzO1xuICAgIGFwcC52aXJ0dWFsTGlzdCA9IENvbnN0cnVjdG9yTWV0aG9kcyh7XG4gICAgICBkZWZhdWx0U2VsZWN0b3I6ICcudmlydHVhbC1saXN0JyxcbiAgICAgIGNvbnN0cnVjdG9yOiBWaXJ0dWFsTGlzdCxcbiAgICAgIGFwcCxcbiAgICAgIGRvbVByb3A6ICdmN1ZpcnR1YWxMaXN0JyxcbiAgICB9KTtcbiAgfSxcbn07XG5cbmNsYXNzIExpc3RJbmRleCBleHRlbmRzIEZyYW1ld29yazdDbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGFwcCwgcGFyYW1zID0ge30pIHtcbiAgICBzdXBlcihwYXJhbXMsIFthcHBdKTtcbiAgICBjb25zdCBpbmRleCA9IHRoaXM7XG5cbiAgICBjb25zdCBkZWZhdWx0cyA9IHtcbiAgICAgIGVsOiBudWxsLCAvLyB3aGVyZSB0byByZW5kZXIgaW5kZXhlc1xuICAgICAgbGlzdEVsOiBudWxsLCAvLyBsaXN0IGVsIHRvIGdlbmVyYXRlIGluZGV4ZXNcbiAgICAgIGluZGV4ZXM6ICdhdXRvJywgLy8gb3IgYXJyYXkgb2YgaW5kZXhlc1xuICAgICAgaW9zSXRlbUhlaWdodDogMTQsXG4gICAgICBtZEl0ZW1IZWlnaHQ6IDE0LFxuICAgICAgc2Nyb2xsTGlzdDogdHJ1ZSxcbiAgICAgIGxhYmVsOiBmYWxzZSxcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgcmVuZGVySXRlbShpdGVtQ29udGVudCwgaXRlbUluZGV4KSB7XG4gICAgICAgIHJldHVybiBgXG4gICAgICAgICAgPGxpPiR7aXRlbUNvbnRlbnR9PC9saT5cbiAgICAgICAgYC50cmltKCk7XG4gICAgICB9LFxuICAgICAgcmVuZGVyU2tpcFBsYWNlaG9sZGVyKCkge1xuICAgICAgICByZXR1cm4gJzxsaSBjbGFzcz1cImxpc3QtaW5kZXgtc2tpcC1wbGFjZWhvbGRlclwiPjwvbGk+JztcbiAgICAgIH0sXG4gICAgICBvbjoge30sXG4gICAgfTtcblxuICAgIC8vIEV4dGVuZCBkZWZhdWx0cyB3aXRoIG1vZHVsZXMgcGFyYW1zXG4gICAgaW5kZXgudXNlTW9kdWxlc1BhcmFtcyhkZWZhdWx0cyk7XG5cbiAgICBpbmRleC5wYXJhbXMgPSBVdGlscy5leHRlbmQoZGVmYXVsdHMsIHBhcmFtcyk7XG5cbiAgICBsZXQgJGVsO1xuICAgIGxldCAkbGlzdEVsO1xuICAgIGxldCAkcGFnZUNvbnRlbnRFbDtcbiAgICBsZXQgJHVsO1xuXG4gICAgaWYgKGluZGV4LnBhcmFtcy5lbCkge1xuICAgICAgJGVsID0gJChpbmRleC5wYXJhbXMuZWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxuXG4gICAgJHVsID0gJGVsLmZpbmQoJ3VsJyk7XG4gICAgaWYgKCR1bC5sZW5ndGggPT09IDApIHtcbiAgICAgICR1bCA9ICQoJzx1bD48L3VsPicpO1xuICAgICAgJGVsLmFwcGVuZCgkdWwpO1xuICAgIH1cblxuICAgIGlmIChpbmRleC5wYXJhbXMubGlzdEVsKSB7XG4gICAgICAkbGlzdEVsID0gJChpbmRleC5wYXJhbXMubGlzdEVsKTtcbiAgICB9XG5cbiAgICBpZiAoaW5kZXgucGFyYW1zLmluZGV4ZXMgPT09ICdhdXRvJyAmJiAhJGxpc3RFbCkge1xuICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH1cblxuICAgIGlmICgkbGlzdEVsKSB7XG4gICAgICAkcGFnZUNvbnRlbnRFbCA9ICRsaXN0RWwucGFyZW50cygnLnBhZ2UtY29udGVudCcpLmVxKDApO1xuICAgIH0gZWxzZSB7XG4gICAgICAkcGFnZUNvbnRlbnRFbCA9ICRlbC5zaWJsaW5ncygnLnBhZ2UtY29udGVudCcpLmVxKDApO1xuICAgICAgaWYgKCRwYWdlQ29udGVudEVsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAkcGFnZUNvbnRlbnRFbCA9ICRlbC5wYXJlbnRzKCcucGFnZScpLmVxKDApLmZpbmQoJy5wYWdlLWNvbnRlbnQnKS5lcSgwKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAkZWxbMF0uZjdMaXN0SW5kZXggPSBpbmRleDtcblxuICAgIFV0aWxzLmV4dGVuZChpbmRleCwge1xuICAgICAgYXBwLFxuICAgICAgJGVsLFxuICAgICAgZWw6ICRlbCAmJiAkZWxbMF0sXG4gICAgICAkdWwsXG4gICAgICB1bDogJHVsICYmICR1bFswXSxcbiAgICAgICRsaXN0RWwsXG4gICAgICBsaXN0RWw6ICRsaXN0RWwgJiYgJGxpc3RFbFswXSxcbiAgICAgICRwYWdlQ29udGVudEVsLFxuICAgICAgcGFnZUNvbnRlbnRFbDogJHBhZ2VDb250ZW50RWwgJiYgJHBhZ2VDb250ZW50RWxbMF0sXG4gICAgICBpbmRleGVzOiBwYXJhbXMuaW5kZXhlcyxcbiAgICAgIGhlaWdodDogMCxcbiAgICAgIHNraXBSYXRlOiAwLFxuICAgIH0pO1xuXG4gICAgLy8gSW5zdGFsbCBNb2R1bGVzXG4gICAgaW5kZXgudXNlTW9kdWxlcygpO1xuXG4gICAgLy8gQXR0YWNoIGV2ZW50c1xuICAgIGZ1bmN0aW9uIGhhbmRsZVJlc2l6ZSgpIHtcbiAgICAgIGNvbnN0IGhlaWdodCA9IHsgaW5kZXggfTtcbiAgICAgIGluZGV4LmNhbGNTaXplKCk7XG4gICAgICBpZiAoaGVpZ2h0ICE9PSBpbmRleC5oZWlnaHQpIHtcbiAgICAgICAgaW5kZXgucmVuZGVyKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFuZGxlQ2xpY2soZSkge1xuICAgICAgY29uc3QgJGNsaWNrZWRMaSA9ICQoZS50YXJnZXQpLmNsb3Nlc3QoJ2xpJyk7XG4gICAgICBpZiAoISRjbGlja2VkTGkubGVuZ3RoKSByZXR1cm47XG5cbiAgICAgIGxldCBpdGVtSW5kZXggPSAkY2xpY2tlZExpLmluZGV4KCk7XG4gICAgICBpZiAoaW5kZXguc2tpcFJhdGUgPiAwKSB7XG4gICAgICAgIGNvbnN0IHBlcmNlbnRhZ2UgPSBpdGVtSW5kZXggLyAoJGNsaWNrZWRMaS5zaWJsaW5ncygnbGknKS5sZW5ndGggLSAxKTtcbiAgICAgICAgaXRlbUluZGV4ID0gTWF0aC5yb3VuZCgoaW5kZXguaW5kZXhlcy5sZW5ndGggLSAxKSAqIHBlcmNlbnRhZ2UpO1xuICAgICAgfVxuICAgICAgY29uc3QgaXRlbUNvbnRlbnQgPSBpbmRleC5pbmRleGVzW2l0ZW1JbmRleF07XG5cbiAgICAgIGluZGV4LiRlbC50cmlnZ2VyKCdsaXN0aW5kZXg6Y2xpY2snLCBpdGVtQ29udGVudCwgaXRlbUluZGV4KTtcbiAgICAgIGluZGV4LmVtaXQoJ2xvY2FsOjpjbGljayBsaXN0SW5kZXhDbGljaycsIGluZGV4LCBpdGVtQ29udGVudCwgaXRlbUluZGV4KTtcbiAgICAgIGluZGV4LiRlbC50cmlnZ2VyKCdsaXN0aW5kZXg6c2VsZWN0JywgaXRlbUNvbnRlbnQsIGl0ZW1JbmRleCk7XG4gICAgICBpbmRleC5lbWl0KCdsb2NhbDo6c2VsZWN0IGxpc3RJbmRleFNlbGVjdCcsIGluZGV4LCBpdGVtQ29udGVudCwgaXRlbUluZGV4KTtcblxuICAgICAgaWYgKGluZGV4LiRsaXN0RWwgJiYgaW5kZXgucGFyYW1zLnNjcm9sbExpc3QpIHtcbiAgICAgICAgaW5kZXguc2Nyb2xsTGlzdFRvSW5kZXgoaXRlbUNvbnRlbnQsIGl0ZW1JbmRleCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgdG91Y2hlc1N0YXJ0ID0ge307XG4gICAgbGV0IGlzVG91Y2hlZDtcbiAgICBsZXQgaXNNb3ZlZDtcbiAgICBsZXQgdG9wUG9pbnQ7XG4gICAgbGV0IGJvdHRvbVBvaW50O1xuICAgIGxldCAkbGFiZWxFbDtcbiAgICBsZXQgcHJldmlvdXNJbmRleCA9IG51bGw7XG4gICAgZnVuY3Rpb24gaGFuZGxlVG91Y2hTdGFydChlKSB7XG4gICAgICBjb25zdCAkY2hpbGRyZW4gPSAkdWwuY2hpbGRyZW4oKTtcbiAgICAgIGlmICghJGNoaWxkcmVuLmxlbmd0aCkgcmV0dXJuO1xuICAgICAgdG9wUG9pbnQgPSAkY2hpbGRyZW5bMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wO1xuICAgICAgYm90dG9tUG9pbnQgPSAkY2hpbGRyZW5bJGNoaWxkcmVuLmxlbmd0aCAtIDFdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCArICRjaGlsZHJlblswXS5vZmZzZXRIZWlnaHQ7XG5cbiAgICAgIHRvdWNoZXNTdGFydC54ID0gZS50eXBlID09PSAndG91Y2hzdGFydCcgPyBlLnRhcmdldFRvdWNoZXNbMF0ucGFnZVggOiBlLnBhZ2VYO1xuICAgICAgdG91Y2hlc1N0YXJ0LnkgPSBlLnR5cGUgPT09ICd0b3VjaHN0YXJ0JyA/IGUudGFyZ2V0VG91Y2hlc1swXS5wYWdlWSA6IGUucGFnZVk7XG4gICAgICBpc1RvdWNoZWQgPSB0cnVlO1xuICAgICAgaXNNb3ZlZCA9IGZhbHNlO1xuICAgICAgcHJldmlvdXNJbmRleCA9IG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhbmRsZVRvdWNoTW92ZShlKSB7XG4gICAgICBpZiAoIWlzVG91Y2hlZCkgcmV0dXJuO1xuICAgICAgaWYgKCFpc01vdmVkICYmIGluZGV4LnBhcmFtcy5sYWJlbCkge1xuICAgICAgICAkbGFiZWxFbCA9ICQoJzxzcGFuIGNsYXNzPVwibGlzdC1pbmRleC1sYWJlbFwiPjwvc3Bhbj4nKTtcbiAgICAgICAgJGVsLmFwcGVuZCgkbGFiZWxFbCk7XG4gICAgICB9XG4gICAgICBpc01vdmVkID0gdHJ1ZTtcbiAgICAgIGNvbnN0IHBhZ2VZID0gZS50eXBlID09PSAndG91Y2htb3ZlJyA/IGUudGFyZ2V0VG91Y2hlc1swXS5wYWdlWSA6IGUucGFnZVk7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgIGxldCBwZXJjZW50YWdlID0gKHBhZ2VZIC0gdG9wUG9pbnQpIC8gKGJvdHRvbVBvaW50IC0gdG9wUG9pbnQpO1xuICAgICAgcGVyY2VudGFnZSA9IE1hdGgubWluKE1hdGgubWF4KHBlcmNlbnRhZ2UsIDApLCAxKTtcblxuICAgICAgY29uc3QgaXRlbUluZGV4ID0gTWF0aC5yb3VuZCgoaW5kZXguaW5kZXhlcy5sZW5ndGggLSAxKSAqIHBlcmNlbnRhZ2UpO1xuICAgICAgY29uc3QgaXRlbUNvbnRlbnQgPSBpbmRleC5pbmRleGVzW2l0ZW1JbmRleF07XG5cblxuICAgICAgY29uc3QgdWxIZWlnaHQgPSBib3R0b21Qb2ludCAtIHRvcFBvaW50O1xuICAgICAgY29uc3QgYnViYmxlQm90dG9tID0gKChpbmRleC5oZWlnaHQgLSB1bEhlaWdodCkgLyAyKSArICgoMSAtIHBlcmNlbnRhZ2UpICogdWxIZWlnaHQpO1xuXG4gICAgICBpZiAoaXRlbUluZGV4ICE9PSBwcmV2aW91c0luZGV4KSB7XG4gICAgICAgIGlmIChpbmRleC5wYXJhbXMubGFiZWwpIHtcbiAgICAgICAgICAkbGFiZWxFbC5odG1sKGl0ZW1Db250ZW50KS50cmFuc2Zvcm0oYHRyYW5zbGF0ZVkoLSR7YnViYmxlQm90dG9tfXB4KWApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGluZGV4LiRsaXN0RWwgJiYgaW5kZXgucGFyYW1zLnNjcm9sbExpc3QpIHtcbiAgICAgICAgICBpbmRleC5zY3JvbGxMaXN0VG9JbmRleChpdGVtQ29udGVudCwgaXRlbUluZGV4KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBwcmV2aW91c0luZGV4ID0gaXRlbUluZGV4O1xuXG4gICAgICBpbmRleC4kZWwudHJpZ2dlcignbGlzdGluZGV4OnNlbGVjdCcsIGluZGV4KTtcbiAgICAgIGluZGV4LmVtaXQoJ2xvY2FsOjpzZWxlY3QgbGlzdEluZGV4U2VsZWN0JywgaW5kZXgsIGl0ZW1Db250ZW50LCBpdGVtSW5kZXgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoYW5kbGVUb3VjaEVuZCgpIHtcbiAgICAgIGlmICghaXNUb3VjaGVkKSByZXR1cm47XG4gICAgICBpc1RvdWNoZWQgPSBmYWxzZTtcbiAgICAgIGlzTW92ZWQgPSBmYWxzZTtcbiAgICAgIGlmIChpbmRleC5wYXJhbXMubGFiZWwpIHtcbiAgICAgICAgaWYgKCRsYWJlbEVsKSAkbGFiZWxFbC5yZW1vdmUoKTtcbiAgICAgICAgJGxhYmVsRWwgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHBhc3NpdmVMaXN0ZW5lciA9IGFwcC5zdXBwb3J0LnBhc3NpdmVMaXN0ZW5lciA/IHsgcGFzc2l2ZTogdHJ1ZSB9IDogZmFsc2U7XG4gICAgaW5kZXguYXR0YWNoRXZlbnRzID0gZnVuY3Rpb24gYXR0YWNoRXZlbnRzKCkge1xuICAgICAgJGVsLnBhcmVudHMoJy50YWInKS5vbigndGFiOnNob3cnLCBoYW5kbGVSZXNpemUpO1xuICAgICAgJGVsLnBhcmVudHMoJy5wYWdlJykub24oJ3BhZ2U6cmVpbml0JywgaGFuZGxlUmVzaXplKTtcbiAgICAgICRlbC5wYXJlbnRzKCcucGFuZWwnKS5vbigncGFuZWw6b3BlbicsIGhhbmRsZVJlc2l6ZSk7XG4gICAgICAkZWxcbiAgICAgICAgLnBhcmVudHMoJy5zaGVldC1tb2RhbCwgLmFjdGlvbnMtbW9kYWwsIC5wb3B1cCwgLnBvcG92ZXIsIC5sb2dpbi1zY3JlZW4sIC5kaWFsb2csIC50b2FzdCcpXG4gICAgICAgIC5vbignbW9kYWw6b3BlbicsIGhhbmRsZVJlc2l6ZSk7XG4gICAgICBhcHAub24oJ3Jlc2l6ZScsIGhhbmRsZVJlc2l6ZSk7XG5cbiAgICAgICRlbC5vbignY2xpY2snLCBoYW5kbGVDbGljayk7XG4gICAgICAkZWwub24oYXBwLnRvdWNoRXZlbnRzLnN0YXJ0LCBoYW5kbGVUb3VjaFN0YXJ0LCBwYXNzaXZlTGlzdGVuZXIpO1xuICAgICAgYXBwLm9uKCd0b3VjaG1vdmU6YWN0aXZlJywgaGFuZGxlVG91Y2hNb3ZlKTtcbiAgICAgIGFwcC5vbigndG91Y2hlbmQ6cGFzc2l2ZScsIGhhbmRsZVRvdWNoRW5kKTtcbiAgICB9O1xuICAgIGluZGV4LmRldGFjaEV2ZW50cyA9IGZ1bmN0aW9uIGF0dGFjaEV2ZW50cygpIHtcbiAgICAgICRlbC5wYXJlbnRzKCcudGFiJykub2ZmKCd0YWI6c2hvdycsIGhhbmRsZVJlc2l6ZSk7XG4gICAgICAkZWwucGFyZW50cygnLnBhZ2UnKS5vZmYoJ3BhZ2U6cmVpbml0JywgaGFuZGxlUmVzaXplKTtcbiAgICAgICRlbC5wYXJlbnRzKCcucGFuZWwnKS5vZmYoJ3BhbmVsOm9wZW4nLCBoYW5kbGVSZXNpemUpO1xuICAgICAgJGVsXG4gICAgICAgIC5wYXJlbnRzKCcuc2hlZXQtbW9kYWwsIC5hY3Rpb25zLW1vZGFsLCAucG9wdXAsIC5wb3BvdmVyLCAubG9naW4tc2NyZWVuLCAuZGlhbG9nLCAudG9hc3QnKVxuICAgICAgICAub2ZmKCdtb2RhbDpvcGVuJywgaGFuZGxlUmVzaXplKTtcbiAgICAgIGFwcC5vZmYoJ3Jlc2l6ZScsIGhhbmRsZVJlc2l6ZSk7XG5cbiAgICAgICRlbC5vZmYoJ2NsaWNrJywgaGFuZGxlQ2xpY2spO1xuICAgICAgJGVsLm9mZihhcHAudG91Y2hFdmVudHMuc3RhcnQsIGhhbmRsZVRvdWNoU3RhcnQsIHBhc3NpdmVMaXN0ZW5lcik7XG4gICAgICBhcHAub2ZmKCd0b3VjaG1vdmU6YWN0aXZlJywgaGFuZGxlVG91Y2hNb3ZlKTtcbiAgICAgIGFwcC5vZmYoJ3RvdWNoZW5kOnBhc3NpdmUnLCBoYW5kbGVUb3VjaEVuZCk7XG4gICAgfTtcbiAgICAvLyBJbml0XG4gICAgaW5kZXguaW5pdCgpO1xuXG4gICAgcmV0dXJuIGluZGV4O1xuICB9XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICBzY3JvbGxMaXN0VG9JbmRleChpdGVtQ29udGVudCwgaXRlbUluZGV4KSB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzO1xuICAgIGNvbnN0IHsgJGxpc3RFbCwgJHBhZ2VDb250ZW50RWwgfSA9IGluZGV4O1xuICAgIGlmICghJGxpc3RFbCB8fCAhJHBhZ2VDb250ZW50RWwgfHwgJHBhZ2VDb250ZW50RWwubGVuZ3RoID09PSAwKSByZXR1cm4gaW5kZXg7XG5cbiAgICBsZXQgJHNjcm9sbFRvRWw7XG4gICAgJGxpc3RFbC5maW5kKCcubGlzdC1ncm91cC10aXRsZSwgLml0ZW0tZGl2aWRlcicpLmVhY2goKGVsSW5kZXgsIGVsKSA9PiB7XG4gICAgICBpZiAoJHNjcm9sbFRvRWwpIHJldHVybjtcbiAgICAgIGNvbnN0ICRlbCA9ICQoZWwpO1xuICAgICAgaWYgKCRlbC50ZXh0KCkgPT09IGl0ZW1Db250ZW50KSB7XG4gICAgICAgICRzY3JvbGxUb0VsID0gJGVsO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICghJHNjcm9sbFRvRWwgfHwgJHNjcm9sbFRvRWwubGVuZ3RoID09PSAwKSByZXR1cm4gaW5kZXg7XG5cbiAgICBjb25zdCBwYXJlbnRUb3AgPSAkc2Nyb2xsVG9FbC5wYXJlbnQoKS5vZmZzZXQoKS50b3A7XG4gICAgY29uc3QgcGFkZGluZ1RvcCA9IHBhcnNlSW50KCRwYWdlQ29udGVudEVsLmNzcygncGFkZGluZy10b3AnKSwgMTApO1xuICAgIGNvbnN0IHNjcm9sbFRvcCA9ICRwYWdlQ29udGVudEVsWzBdLnNjcm9sbFRvcDtcbiAgICBjb25zdCBzY3JvbGxUb0VsVG9wID0gJHNjcm9sbFRvRWwub2Zmc2V0KCkudG9wO1xuXG4gICAgaWYgKHBhcmVudFRvcCA8PSBwYWRkaW5nVG9wKSB7XG4gICAgICAkcGFnZUNvbnRlbnRFbC5zY3JvbGxUb3AoKHBhcmVudFRvcCArIHNjcm9sbFRvcCkgLSBwYWRkaW5nVG9wKTtcbiAgICB9IGVsc2Uge1xuICAgICAgJHBhZ2VDb250ZW50RWwuc2Nyb2xsVG9wKChzY3JvbGxUb0VsVG9wICsgc2Nyb2xsVG9wKSAtIHBhZGRpbmdUb3ApO1xuICAgIH1cbiAgICByZXR1cm4gaW5kZXg7XG4gIH1cbiAgcmVuZGVyU2tpcFBsYWNlaG9sZGVyKCkge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcztcbiAgICByZXR1cm4gaW5kZXgucGFyYW1zLnJlbmRlclNraXBQbGFjZWhvbGRlci5jYWxsKGluZGV4KTtcbiAgfVxuICByZW5kZXJJdGVtKGl0ZW1Db250ZW50LCBpdGVtSW5kZXgpIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXM7XG4gICAgcmV0dXJuIGluZGV4LnBhcmFtcy5yZW5kZXJJdGVtLmNhbGwoaW5kZXgsIGl0ZW1Db250ZW50LCBpdGVtSW5kZXgpO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXM7XG4gICAgY29uc3QgeyAkdWwsIGluZGV4ZXMsIHNraXBSYXRlIH0gPSBpbmRleDtcbiAgICBsZXQgd2FzU2tpcHBlZDtcblxuICAgIGNvbnN0IGh0bWwgPSBpbmRleGVzLm1hcCgoaXRlbUNvbnRlbnQsIGl0ZW1JbmRleCkgPT4ge1xuICAgICAgaWYgKGl0ZW1JbmRleCAlIHNraXBSYXRlICE9PSAwICYmIHNraXBSYXRlID4gMCkge1xuICAgICAgICB3YXNTa2lwcGVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuICAgICAgbGV0IGl0ZW1IdG1sID0gaW5kZXgucmVuZGVySXRlbShpdGVtQ29udGVudCwgaXRlbUluZGV4KTtcbiAgICAgIGlmICh3YXNTa2lwcGVkKSB7XG4gICAgICAgIGl0ZW1IdG1sID0gaW5kZXgucmVuZGVyU2tpcFBsYWNlaG9sZGVyKCkgKyBpdGVtSHRtbDtcbiAgICAgIH1cbiAgICAgIHdhc1NraXBwZWQgPSBmYWxzZTtcbiAgICAgIHJldHVybiBpdGVtSHRtbDtcbiAgICB9KS5qb2luKCcnKTtcblxuICAgICR1bC5odG1sKGh0bWwpO1xuXG4gICAgcmV0dXJuIGluZGV4O1xuICB9XG4gIGNhbGNTaXplKCkge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcztcbiAgICBjb25zdCB7IGFwcCwgcGFyYW1zLCBlbCwgaW5kZXhlcyB9ID0gaW5kZXg7XG4gICAgY29uc3QgaGVpZ2h0ID0gZWwub2Zmc2V0SGVpZ2h0O1xuICAgIGNvbnN0IGl0ZW1IZWlnaHQgPSBhcHAudGhlbWUgPT09ICdpb3MnID8gcGFyYW1zLmlvc0l0ZW1IZWlnaHQgOiBwYXJhbXMubWRJdGVtSGVpZ2h0O1xuICAgIGNvbnN0IG1heEl0ZW1zID0gTWF0aC5mbG9vcihoZWlnaHQgLyBpdGVtSGVpZ2h0KTtcbiAgICBjb25zdCBpdGVtcyA9IGluZGV4ZXMubGVuZ3RoO1xuICAgIGxldCBza2lwUmF0ZSA9IDA7XG4gICAgaWYgKGl0ZW1zID4gbWF4SXRlbXMpIHtcbiAgICAgIHNraXBSYXRlID0gTWF0aC5jZWlsKCgoaXRlbXMgKiAyKSAtIDEpIC8gbWF4SXRlbXMpO1xuICAgIH1cblxuICAgIGluZGV4LmhlaWdodCA9IGhlaWdodDtcbiAgICBpbmRleC5za2lwUmF0ZSA9IHNraXBSYXRlO1xuXG4gICAgcmV0dXJuIGluZGV4O1xuICB9XG4gIGNhbGNJbmRleGVzKCkge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcztcbiAgICBpZiAoaW5kZXgucGFyYW1zLmluZGV4ZXMgPT09ICdhdXRvJykge1xuICAgICAgaW5kZXguaW5kZXhlcyA9IFtdO1xuXG4gICAgICBpbmRleC4kbGlzdEVsLmZpbmQoJy5saXN0LWdyb3VwLXRpdGxlLCAuaXRlbS1kaXZpZGVyJykuZWFjaCgoZWxJbmRleCwgZWwpID0+IHtcbiAgICAgICAgY29uc3QgZWxDb250ZW50ID0gJChlbCkudGV4dCgpO1xuICAgICAgICBpZiAoaW5kZXguaW5kZXhlcy5pbmRleE9mKGVsQ29udGVudCkgPCAwKSB7XG4gICAgICAgICAgaW5kZXguaW5kZXhlcy5wdXNoKGVsQ29udGVudCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbmRleC5pbmRleGVzID0gaW5kZXgucGFyYW1zLmluZGV4ZXM7XG4gICAgfVxuICAgIHJldHVybiBpbmRleDtcbiAgfVxuICB1cGRhdGUoKSB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzO1xuICAgIGluZGV4LmNhbGNJbmRleGVzKCk7XG4gICAgaW5kZXguY2FsY1NpemUoKTtcbiAgICBpbmRleC5yZW5kZXIoKTtcblxuICAgIHJldHVybiBpbmRleDtcbiAgfVxuICBpbml0KCkge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcztcbiAgICBpbmRleC5jYWxjSW5kZXhlcygpO1xuICAgIGluZGV4LmNhbGNTaXplKCk7XG4gICAgaW5kZXgucmVuZGVyKCk7XG4gICAgaW5kZXguYXR0YWNoRXZlbnRzKCk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICBsZXQgaW5kZXggPSB0aGlzO1xuICAgIGluZGV4LiRlbC50cmlnZ2VyKCdsaXN0aW5kZXg6YmVmb3JlZGVzdHJveScsIGluZGV4KTtcbiAgICBpbmRleC5lbWl0KCdsb2NhbDo6YmVmb3JlRGVzdHJveSBsaXN0SW5kZXhCZWZvcmVEZXN0cm95JywgaW5kZXgpO1xuICAgIGluZGV4LmRldGFjaEV2ZW50cygpO1xuICAgIGluZGV4LiRlbFswXS5mN0xpc3RJbmRleCA9IG51bGw7XG4gICAgZGVsZXRlIGluZGV4LiRlbFswXS5mN0xpc3RJbmRleDtcbiAgICBVdGlscy5kZWxldGVQcm9wcyhpbmRleCk7XG4gICAgaW5kZXggPSBudWxsO1xuICB9XG59XG5cbnZhciBMaXN0SW5kZXgkMSA9IHtcbiAgbmFtZTogJ2xpc3RJbmRleCcsXG4gIHN0YXRpYzoge1xuICAgIExpc3RJbmRleCxcbiAgfSxcbiAgY3JlYXRlKCkge1xuICAgIGNvbnN0IGFwcCA9IHRoaXM7XG4gICAgYXBwLmxpc3RJbmRleCA9IENvbnN0cnVjdG9yTWV0aG9kcyh7XG4gICAgICBkZWZhdWx0U2VsZWN0b3I6ICcubGlzdC1pbmRleCcsXG4gICAgICBjb25zdHJ1Y3RvcjogTGlzdEluZGV4LFxuICAgICAgYXBwLFxuICAgICAgZG9tUHJvcDogJ2Y3TGlzdEluZGV4JyxcbiAgICB9KTtcbiAgfSxcbiAgb246IHtcbiAgICB0YWJNb3VudGVkKHRhYkVsKSB7XG4gICAgICBjb25zdCBhcHAgPSB0aGlzO1xuICAgICAgJCh0YWJFbCkuZmluZCgnLmxpc3QtaW5kZXgtaW5pdCcpLmVhY2goKGluZGV4LCBsaXN0SW5kZXhFbCkgPT4ge1xuICAgICAgICBjb25zdCBwYXJhbXMgPSBVdGlscy5leHRlbmQoJChsaXN0SW5kZXhFbCkuZGF0YXNldCgpLCB7IGVsOiBsaXN0SW5kZXhFbCB9KTtcbiAgICAgICAgYXBwLmxpc3RJbmRleC5jcmVhdGUocGFyYW1zKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgdGFiQmVmb3JlUmVtb3ZlKHRhYkVsKSB7XG4gICAgICAkKHRhYkVsKS5maW5kKCcubGlzdC1pbmRleC1pbml0JykuZWFjaCgoaW5kZXgsIGxpc3RJbmRleEVsKSA9PiB7XG4gICAgICAgIGlmIChsaXN0SW5kZXhFbC5mN0xpc3RJbmRleCkgbGlzdEluZGV4RWwuZjdMaXN0SW5kZXguZGVzdHJveSgpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBwYWdlSW5pdChwYWdlKSB7XG4gICAgICBjb25zdCBhcHAgPSB0aGlzO1xuICAgICAgcGFnZS4kZWwuZmluZCgnLmxpc3QtaW5kZXgtaW5pdCcpLmVhY2goKGluZGV4LCBsaXN0SW5kZXhFbCkgPT4ge1xuICAgICAgICBjb25zdCBwYXJhbXMgPSBVdGlscy5leHRlbmQoJChsaXN0SW5kZXhFbCkuZGF0YXNldCgpLCB7IGVsOiBsaXN0SW5kZXhFbCB9KTtcbiAgICAgICAgYXBwLmxpc3RJbmRleC5jcmVhdGUocGFyYW1zKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgcGFnZUJlZm9yZVJlbW92ZShwYWdlKSB7XG4gICAgICBwYWdlLiRlbC5maW5kKCcubGlzdC1pbmRleC1pbml0JykuZWFjaCgoaW5kZXgsIGxpc3RJbmRleEVsKSA9PiB7XG4gICAgICAgIGlmIChsaXN0SW5kZXhFbC5mN0xpc3RJbmRleCkgbGlzdEluZGV4RWwuZjdMaXN0SW5kZXguZGVzdHJveSgpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgfSxcbn07XG5cbnZhciBUaW1lbGluZSA9IHtcbiAgbmFtZTogJ3RpbWVsaW5lJyxcbn07XG5cbmNvbnN0IFRhYiA9IHtcbiAgc2hvdyguLi5hcmdzKSB7XG4gICAgY29uc3QgYXBwID0gdGhpcztcbiAgICBsZXQgdGFiRWw7XG4gICAgbGV0IHRhYkxpbmtFbDtcbiAgICBsZXQgYW5pbWF0ZTtcbiAgICBsZXQgdGFiUm91dGU7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSAxICYmIGFyZ3NbMF0uY29uc3RydWN0b3IgPT09IE9iamVjdCkge1xuICAgICAgdGFiRWwgPSBhcmdzWzBdLnRhYkVsO1xuICAgICAgdGFiTGlua0VsID0gYXJnc1swXS50YWJMaW5rRWw7XG4gICAgICBhbmltYXRlID0gYXJnc1swXS5hbmltYXRlO1xuICAgICAgdGFiUm91dGUgPSBhcmdzWzBdLnRhYlJvdXRlO1xuICAgIH0gZWxzZSB7XG4gICAgICBbdGFiRWwsIHRhYkxpbmtFbCwgYW5pbWF0ZSwgdGFiUm91dGVdID0gYXJncztcbiAgICAgIGlmICh0eXBlb2YgYXJnc1sxXSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIFt0YWJFbCwgYW5pbWF0ZSwgdGFiTGlua0VsLCB0YWJSb3V0ZV0gPSBhcmdzO1xuICAgICAgICBpZiAoYXJncy5sZW5ndGggPiAyICYmIHRhYkxpbmtFbC5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KSB7XG4gICAgICAgICAgW3RhYkVsLCBhbmltYXRlLCB0YWJSb3V0ZSwgdGFiTGlua0VsXSA9IGFyZ3M7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGVvZiBhbmltYXRlID09PSAndW5kZWZpbmVkJykgYW5pbWF0ZSA9IHRydWU7XG5cbiAgICBjb25zdCAkbmV3VGFiRWwgPSAkKHRhYkVsKTtcbiAgICBpZiAodGFiUm91dGUgJiYgJG5ld1RhYkVsWzBdKSB7XG4gICAgICAkbmV3VGFiRWxbMF0uZjdUYWJSb3V0ZSA9IHRhYlJvdXRlO1xuICAgIH1cblxuICAgIGlmICgkbmV3VGFiRWwubGVuZ3RoID09PSAwIHx8ICRuZXdUYWJFbC5oYXNDbGFzcygndGFiLWFjdGl2ZScpKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAkbmV3VGFiRWwsXG4gICAgICAgIG5ld1RhYkVsOiAkbmV3VGFiRWxbMF0sXG4gICAgICB9O1xuICAgIH1cblxuICAgIGxldCAkdGFiTGlua0VsO1xuICAgIGlmICh0YWJMaW5rRWwpICR0YWJMaW5rRWwgPSAkKHRhYkxpbmtFbCk7XG5cbiAgICBjb25zdCAkdGFic0VsID0gJG5ld1RhYkVsLnBhcmVudCgnLnRhYnMnKTtcbiAgICBpZiAoJHRhYnNFbC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICRuZXdUYWJFbCxcbiAgICAgICAgbmV3VGFiRWw6ICRuZXdUYWJFbFswXSxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gUmVsZWFzZSBzd2lwZW91dHMgaW4gaGlkZGVuIHRhYnNcbiAgICBpZiAoYXBwLnN3aXBlb3V0KSBhcHAuc3dpcGVvdXQuYWxsb3dPcGVuID0gdHJ1ZTtcblxuICAgIC8vIEFuaW1hdGVkIHRhYnNcbiAgICBjb25zdCB0YWJzQ2hhbmdlZENhbGxiYWNrcyA9IFtdO1xuXG4gICAgZnVuY3Rpb24gb25UYWJzQ2hhbmdlZChjYWxsYmFjaykge1xuICAgICAgdGFic0NoYW5nZWRDYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRhYnNDaGFuZ2VkKCkge1xuICAgICAgdGFic0NoYW5nZWRDYWxsYmFja3MuZm9yRWFjaCgoY2FsbGJhY2spID0+IHtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGxldCBhbmltYXRlZCA9IGZhbHNlO1xuXG4gICAgaWYgKCR0YWJzRWwucGFyZW50KCkuaGFzQ2xhc3MoJ3RhYnMtYW5pbWF0ZWQtd3JhcCcpKSB7XG4gICAgICAkdGFic0VsLnBhcmVudCgpW2FuaW1hdGUgPyAncmVtb3ZlQ2xhc3MnIDogJ2FkZENsYXNzJ10oJ25vdC1hbmltYXRlZCcpO1xuXG4gICAgICBjb25zdCB0cmFuc2l0aW9uRHVyYXRpb24gPSBwYXJzZUZsb2F0KCR0YWJzRWwuY3NzKCd0cmFuc2l0aW9uLWR1cmF0aW9uJykucmVwbGFjZSgnLCcsICcuJykpO1xuICAgICAgaWYgKGFuaW1hdGUgJiYgdHJhbnNpdGlvbkR1cmF0aW9uKSB7XG4gICAgICAgICR0YWJzRWwudHJhbnNpdGlvbkVuZCh0YWJzQ2hhbmdlZCk7XG4gICAgICAgIGFuaW1hdGVkID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdGFic1RyYW5zbGF0ZSA9IChhcHAucnRsID8gJG5ld1RhYkVsLmluZGV4KCkgOiAtJG5ld1RhYkVsLmluZGV4KCkpICogMTAwO1xuICAgICAgJHRhYnNFbC50cmFuc2Zvcm0oYHRyYW5zbGF0ZTNkKCR7dGFic1RyYW5zbGF0ZX0lLDAsMClgKTtcbiAgICB9XG5cbiAgICAvLyBTd2lwZWFibGUgdGFic1xuICAgIGlmICgkdGFic0VsLnBhcmVudCgpLmhhc0NsYXNzKCd0YWJzLXN3aXBlYWJsZS13cmFwJykgJiYgYXBwLnN3aXBlcikge1xuICAgICAgY29uc3Qgc3dpcGVyID0gJHRhYnNFbC5wYXJlbnQoKVswXS5zd2lwZXI7XG4gICAgICBpZiAoc3dpcGVyICYmIHN3aXBlci5hY3RpdmVJbmRleCAhPT0gJG5ld1RhYkVsLmluZGV4KCkpIHtcbiAgICAgICAgYW5pbWF0ZWQgPSB0cnVlO1xuICAgICAgICBzd2lwZXJcbiAgICAgICAgICAub25jZSgnc2xpZGVDaGFuZ2VUcmFuc2l0aW9uRW5kJywgKCkgPT4ge1xuICAgICAgICAgICAgdGFic0NoYW5nZWQoKTtcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5zbGlkZVRvKCRuZXdUYWJFbC5pbmRleCgpLCBhbmltYXRlID8gdW5kZWZpbmVkIDogMCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmVtb3ZlIGFjdGl2ZSBjbGFzcyBmcm9tIG9sZCB0YWJzXG4gICAgY29uc3QgJG9sZFRhYkVsID0gJHRhYnNFbC5jaGlsZHJlbignLnRhYi1hY3RpdmUnKTtcbiAgICAkb2xkVGFiRWxcbiAgICAgIC5yZW1vdmVDbGFzcygndGFiLWFjdGl2ZScpXG4gICAgICAudHJpZ2dlcigndGFiOmhpZGUnKTtcbiAgICBhcHAuZW1pdCgndGFiSGlkZScsICRvbGRUYWJFbFswXSk7XG5cbiAgICAvLyBUcmlnZ2VyICdzaG93JyBldmVudCBvbiBuZXcgdGFiXG4gICAgJG5ld1RhYkVsXG4gICAgICAuYWRkQ2xhc3MoJ3RhYi1hY3RpdmUnKVxuICAgICAgLnRyaWdnZXIoJ3RhYjpzaG93Jyk7XG4gICAgYXBwLmVtaXQoJ3RhYlNob3cnLCAkbmV3VGFiRWxbMF0pO1xuXG4gICAgLy8gRmluZCByZWxhdGVkIGxpbmsgZm9yIG5ldyB0YWJcbiAgICBpZiAoISR0YWJMaW5rRWwpIHtcbiAgICAgIC8vIFNlYXJjaCBieSBpZFxuICAgICAgaWYgKHR5cGVvZiB0YWJFbCA9PT0gJ3N0cmluZycpICR0YWJMaW5rRWwgPSAkKGAudGFiLWxpbmtbaHJlZj1cIiR7dGFiRWx9XCJdYCk7XG4gICAgICBlbHNlICR0YWJMaW5rRWwgPSAkKGAudGFiLWxpbmtbaHJlZj1cIiMkeyRuZXdUYWJFbC5hdHRyKCdpZCcpfVwiXWApO1xuICAgICAgLy8gU2VhcmNoIGJ5IGRhdGEtdGFiXG4gICAgICBpZiAoISR0YWJMaW5rRWwgfHwgKCR0YWJMaW5rRWwgJiYgJHRhYkxpbmtFbC5sZW5ndGggPT09IDApKSB7XG4gICAgICAgICQoJ1tkYXRhLXRhYl0nKS5lYWNoKChpbmRleCwgZWwpID0+IHtcbiAgICAgICAgICBpZiAoJG5ld1RhYkVsLmlzKCQoZWwpLmF0dHIoJ2RhdGEtdGFiJykpKSAkdGFiTGlua0VsID0gJChlbCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKHRhYlJvdXRlICYmICghJHRhYkxpbmtFbCB8fCAoJHRhYkxpbmtFbCAmJiAkdGFiTGlua0VsLmxlbmd0aCA9PT0gMCkpKSB7XG4gICAgICAgICR0YWJMaW5rRWwgPSAkKGBbZGF0YS1yb3V0ZS10YWItaWQ9XCIke3RhYlJvdXRlLnJvdXRlLnRhYi5pZH1cIl1gKTtcbiAgICAgICAgaWYgKCR0YWJMaW5rRWwubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgJHRhYkxpbmtFbCA9ICQoYC50YWItbGlua1tocmVmPVwiJHt0YWJSb3V0ZS51cmx9XCJdYCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICgkdGFiTGlua0VsLmxlbmd0aCA+IDEgJiYgJG5ld1RhYkVsLnBhcmVudHMoJy5wYWdlJykubGVuZ3RoKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICAkdGFiTGlua0VsID0gJHRhYkxpbmtFbC5maWx0ZXIoKGluZGV4LCB0YWJMaW5rRWxlbWVudCkgPT4ge1xuICAgICAgICAgIHJldHVybiAkKHRhYkxpbmtFbGVtZW50KS5wYXJlbnRzKCcucGFnZScpWzBdID09PSAkbmV3VGFiRWwucGFyZW50cygnLnBhZ2UnKVswXTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChhcHAudGhlbWUgPT09ICdpb3MnICYmICR0YWJMaW5rRWwubGVuZ3RoID09PSAwICYmIHRhYlJvdXRlKSB7XG4gICAgICAgICAgY29uc3QgJHBhZ2VFbCA9ICRuZXdUYWJFbC5wYXJlbnRzKCcucGFnZScpO1xuICAgICAgICAgIGNvbnN0ICRuYXZiYXJFbCA9ICQoYXBwLm5hdmJhci5nZXRFbEJ5UGFnZSgkcGFnZUVsKSk7XG4gICAgICAgICAgJHRhYkxpbmtFbCA9ICRuYXZiYXJFbC5maW5kKGBbZGF0YS1yb3V0ZS10YWItaWQ9XCIke3RhYlJvdXRlLnJvdXRlLnRhYi5pZH1cIl1gKTtcbiAgICAgICAgICBpZiAoJHRhYkxpbmtFbC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICR0YWJMaW5rRWwgPSAkbmF2YmFyRWwuZmluZChgLnRhYi1saW5rW2hyZWY9XCIke3RhYlJvdXRlLnVybH1cIl1gKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCR0YWJMaW5rRWwubGVuZ3RoID4gMCkge1xuICAgICAgLy8gRmluZCByZWxhdGVkIGxpbmsgZm9yIG9sZCB0YWJcbiAgICAgIGxldCAkb2xkVGFiTGlua0VsO1xuICAgICAgaWYgKCRvbGRUYWJFbCAmJiAkb2xkVGFiRWwubGVuZ3RoID4gMCkge1xuICAgICAgICAvLyBTZWFyY2ggYnkgaWRcbiAgICAgICAgY29uc3Qgb2xkVGFiSWQgPSAkb2xkVGFiRWwuYXR0cignaWQnKTtcbiAgICAgICAgaWYgKG9sZFRhYklkKSB7XG4gICAgICAgICAgJG9sZFRhYkxpbmtFbCA9ICQoYC50YWItbGlua1tocmVmPVwiIyR7b2xkVGFiSWR9XCJdYCk7XG4gICAgICAgICAgLy8gU2VhcmNoIGJ5IGRhdGEtcm91dGUtdGFiLWlkXG4gICAgICAgICAgaWYgKCEkb2xkVGFiTGlua0VsIHx8ICgkb2xkVGFiTGlua0VsICYmICRvbGRUYWJMaW5rRWwubGVuZ3RoID09PSAwKSkge1xuICAgICAgICAgICAgJG9sZFRhYkxpbmtFbCA9ICQoYC50YWItbGlua1tkYXRhLXJvdXRlLXRhYi1pZD1cIiR7b2xkVGFiSWR9XCJdYCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFNlYXJjaCBieSBkYXRhLXRhYlxuICAgICAgICBpZiAoISRvbGRUYWJMaW5rRWwgfHwgKCRvbGRUYWJMaW5rRWwgJiYgJG9sZFRhYkxpbmtFbC5sZW5ndGggPT09IDApKSB7XG4gICAgICAgICAgJCgnW2RhdGEtdGFiXScpLmVhY2goKGluZGV4LCB0YWJMaW5rRWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKCRvbGRUYWJFbC5pcygkKHRhYkxpbmtFbGVtZW50KS5hdHRyKCdkYXRhLXRhYicpKSkgJG9sZFRhYkxpbmtFbCA9ICQodGFiTGlua0VsZW1lbnQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghJG9sZFRhYkxpbmtFbCB8fCAoJG9sZFRhYkxpbmtFbCAmJiAkb2xkVGFiTGlua0VsLmxlbmd0aCA9PT0gMCkpIHtcbiAgICAgICAgICAkb2xkVGFiTGlua0VsID0gJHRhYkxpbmtFbC5zaWJsaW5ncygnLnRhYi1saW5rLWFjdGl2ZScpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRhYlJvdXRlKSB7XG4gICAgICAgICRvbGRUYWJMaW5rRWwgPSAkdGFiTGlua0VsLnNpYmxpbmdzKCcudGFiLWxpbmstYWN0aXZlJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICgkb2xkVGFiTGlua0VsICYmICRvbGRUYWJMaW5rRWwubGVuZ3RoID4gMSAmJiAkb2xkVGFiRWwgJiYgJG9sZFRhYkVsLnBhcmVudHMoJy5wYWdlJykubGVuZ3RoKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICAkb2xkVGFiTGlua0VsID0gJG9sZFRhYkxpbmtFbC5maWx0ZXIoKGluZGV4LCB0YWJMaW5rRWxlbWVudCkgPT4ge1xuICAgICAgICAgIHJldHVybiAkKHRhYkxpbmtFbGVtZW50KS5wYXJlbnRzKCcucGFnZScpWzBdID09PSAkb2xkVGFiRWwucGFyZW50cygnLnBhZ2UnKVswXTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmICgkb2xkVGFiTGlua0VsICYmICRvbGRUYWJMaW5rRWwubGVuZ3RoID4gMCkgJG9sZFRhYkxpbmtFbC5yZW1vdmVDbGFzcygndGFiLWxpbmstYWN0aXZlJyk7XG5cbiAgICAgIC8vIFVwZGF0ZSBsaW5rcycgY2xhc3Nlc1xuICAgICAgaWYgKCR0YWJMaW5rRWwgJiYgJHRhYkxpbmtFbC5sZW5ndGggPiAwKSB7XG4gICAgICAgICR0YWJMaW5rRWwuYWRkQ2xhc3MoJ3RhYi1saW5rLWFjdGl2ZScpO1xuICAgICAgICAvLyBNYXRlcmlhbCBIaWdobGlnaHRcbiAgICAgICAgaWYgKGFwcC50aGVtZSA9PT0gJ21kJyAmJiBhcHAudG9vbGJhcikge1xuICAgICAgICAgIGNvbnN0ICR0YWJiYXJFbCA9ICR0YWJMaW5rRWwucGFyZW50cygnLnRhYmJhciwgLnRhYmJhci1sYWJlbHMnKTtcbiAgICAgICAgICBpZiAoJHRhYmJhckVsLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGFwcC50b29sYmFyLnNldEhpZ2hsaWdodCgkdGFiYmFyRWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgJG5ld1RhYkVsLFxuICAgICAgbmV3VGFiRWw6ICRuZXdUYWJFbFswXSxcbiAgICAgICRvbGRUYWJFbCxcbiAgICAgIG9sZFRhYkVsOiAkb2xkVGFiRWxbMF0sXG4gICAgICBvblRhYnNDaGFuZ2VkLFxuICAgICAgYW5pbWF0ZWQsXG4gICAgfTtcbiAgfSxcbn07XG52YXIgVGFicyA9IHtcbiAgbmFtZTogJ3RhYnMnLFxuICBjcmVhdGUoKSB7XG4gICAgY29uc3QgYXBwID0gdGhpcztcbiAgICBVdGlscy5leHRlbmQoYXBwLCB7XG4gICAgICB0YWI6IHtcbiAgICAgICAgc2hvdzogVGFiLnNob3cuYmluZChhcHApLFxuICAgICAgfSxcbiAgICB9KTtcbiAgfSxcbiAgY2xpY2tzOiB7XG4gICAgJy50YWItbGluayc6IGZ1bmN0aW9uIHRhYkxpbmtDbGljaygkY2xpY2tlZEVsLCBkYXRhID0ge30pIHtcbiAgICAgIGNvbnN0IGFwcCA9IHRoaXM7XG4gICAgICBpZiAoKCRjbGlja2VkRWwuYXR0cignaHJlZicpICYmICRjbGlja2VkRWwuYXR0cignaHJlZicpLmluZGV4T2YoJyMnKSA9PT0gMCkgfHwgJGNsaWNrZWRFbC5hdHRyKCdkYXRhLXRhYicpKSB7XG4gICAgICAgIGFwcC50YWIuc2hvdyh7XG4gICAgICAgICAgdGFiRWw6IGRhdGEudGFiIHx8ICRjbGlja2VkRWwuYXR0cignaHJlZicpLFxuICAgICAgICAgIHRhYkxpbmtFbDogJGNsaWNrZWRFbCxcbiAgICAgICAgICBhbmltYXRlOiBkYXRhLmFuaW1hdGUsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gIH0sXG59O1xuXG5mdW5jdGlvbiBzd2lwZVBhbmVsKHBhbmVsKSB7XG4gIGNvbnN0IGFwcCA9IHBhbmVsLmFwcDtcbiAgVXRpbHMuZXh0ZW5kKHBhbmVsLCB7XG4gICAgc3dpcGVhYmxlOiB0cnVlLFxuICAgIHN3aXBlSW5pdGlhbGl6ZWQ6IHRydWUsXG4gIH0pO1xuICBjb25zdCBwYXJhbXMgPSBhcHAucGFyYW1zLnBhbmVsO1xuICBjb25zdCB7ICRlbCwgJGJhY2tkcm9wRWwsIHNpZGUsIGVmZmVjdCB9ID0gcGFuZWw7XG4gIGxldCBvdGhlclBhbmVsO1xuXG4gIGxldCBpc1RvdWNoZWQ7XG4gIGxldCBpc01vdmVkO1xuICBsZXQgaXNTY3JvbGxpbmc7XG4gIGNvbnN0IHRvdWNoZXNTdGFydCA9IHt9O1xuICBsZXQgdG91Y2hTdGFydFRpbWU7XG4gIGxldCB0b3VjaGVzRGlmZjtcbiAgbGV0IHRyYW5zbGF0ZTtcbiAgbGV0IGJhY2tkcm9wT3BhY2l0eTtcbiAgbGV0IHBhbmVsV2lkdGg7XG4gIGxldCBkaXJlY3Rpb247XG5cbiAgbGV0ICR2aWV3RWw7XG5cbiAgbGV0IHRvdWNoTW92ZXMgPSAwO1xuICBmdW5jdGlvbiBoYW5kbGVUb3VjaFN0YXJ0KGUpIHtcbiAgICBpZiAoIXBhbmVsLnN3aXBlYWJsZSkgcmV0dXJuO1xuICAgIGlmICghYXBwLnBhbmVsLmFsbG93T3BlbiB8fCAoIXBhcmFtcy5zd2lwZSAmJiAhcGFyYW1zLnN3aXBlT25seUNsb3NlKSB8fCBpc1RvdWNoZWQpIHJldHVybjtcbiAgICBpZiAoJCgnLm1vZGFsLWluLCAucGhvdG8tYnJvd3Nlci1pbicpLmxlbmd0aCA+IDApIHJldHVybjtcbiAgICBvdGhlclBhbmVsID0gYXBwLnBhbmVsW3NpZGUgPT09ICdsZWZ0JyA/ICdyaWdodCcgOiAnbGVmdCddIHx8IHt9O1xuICAgIGlmICghcGFuZWwub3BlbmVkICYmIG90aGVyUGFuZWwub3BlbmVkKSByZXR1cm47XG4gICAgaWYgKCEocGFyYW1zLnN3aXBlQ2xvc2VPcHBvc2l0ZSB8fCBwYXJhbXMuc3dpcGVPbmx5Q2xvc2UpKSB7XG4gICAgICBpZiAob3RoZXJQYW5lbC5vcGVuZWQpIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGUudGFyZ2V0ICYmIGUudGFyZ2V0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdpbnB1dCcgJiYgZS50YXJnZXQudHlwZSA9PT0gJ3JhbmdlJykgcmV0dXJuO1xuICAgIGlmICgkKGUudGFyZ2V0KS5jbG9zZXN0KCcucmFuZ2Utc2xpZGVyLCAudGFicy1zd2lwZWFibGUtd3JhcCwgLmNhbGVuZGFyLW1vbnRocywgLm5vLXN3aXBlLXBhbmVsJykubGVuZ3RoID4gMCkgcmV0dXJuO1xuICAgIHRvdWNoZXNTdGFydC54ID0gZS50eXBlID09PSAndG91Y2hzdGFydCcgPyBlLnRhcmdldFRvdWNoZXNbMF0ucGFnZVggOiBlLnBhZ2VYO1xuICAgIHRvdWNoZXNTdGFydC55ID0gZS50eXBlID09PSAndG91Y2hzdGFydCcgPyBlLnRhcmdldFRvdWNoZXNbMF0ucGFnZVkgOiBlLnBhZ2VZO1xuICAgIGlmIChwYXJhbXMuc3dpcGVPbmx5Q2xvc2UgJiYgIXBhbmVsLm9wZW5lZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAocGFyYW1zLnN3aXBlICE9PSAnYm90aCcgJiYgcGFyYW1zLnN3aXBlQ2xvc2VPcHBvc2l0ZSAmJiBwYXJhbXMuc3dpcGUgIT09IHNpZGUgJiYgIXBhbmVsLm9wZW5lZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAocGFyYW1zLnN3aXBlQWN0aXZlQXJlYSAmJiAhcGFuZWwub3BlbmVkKSB7XG4gICAgICBpZiAoc2lkZSA9PT0gJ2xlZnQnKSB7XG4gICAgICAgIGlmICh0b3VjaGVzU3RhcnQueCA+IHBhcmFtcy5zd2lwZUFjdGl2ZUFyZWEpIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChzaWRlID09PSAncmlnaHQnKSB7XG4gICAgICAgIGlmICh0b3VjaGVzU3RhcnQueCA8IGFwcC53aWR0aCAtIHBhcmFtcy5zd2lwZUFjdGl2ZUFyZWEpIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHBhcmFtcy5zd2lwZUNsb3NlQWN0aXZlQXJlYVNpZGUgJiYgcGFuZWwub3BlbmVkKSB7XG4gICAgICBpZiAoc2lkZSA9PT0gJ2xlZnQnKSB7XG4gICAgICAgIGlmICh0b3VjaGVzU3RhcnQueCA8ICgkZWxbMF0ub2Zmc2V0V2lkdGggLSBwYXJhbXMuc3dpcGVDbG9zZUFjdGl2ZUFyZWFTaWRlKSkgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHNpZGUgPT09ICdyaWdodCcpIHtcbiAgICAgICAgaWYgKHRvdWNoZXNTdGFydC54ID4gKChhcHAud2lkdGggLSAkZWxbMF0ub2Zmc2V0V2lkdGgpICsgcGFyYW1zLnN3aXBlQ2xvc2VBY3RpdmVBcmVhU2lkZSkpIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgdG91Y2hNb3ZlcyA9IDA7XG4gICAgJHZpZXdFbCA9ICQocGFuZWwuZ2V0Vmlld0VsKCkpO1xuICAgIGlzTW92ZWQgPSBmYWxzZTtcbiAgICBpc1RvdWNoZWQgPSB0cnVlO1xuICAgIGlzU2Nyb2xsaW5nID0gdW5kZWZpbmVkO1xuXG4gICAgdG91Y2hTdGFydFRpbWUgPSBVdGlscy5ub3coKTtcbiAgICBkaXJlY3Rpb24gPSB1bmRlZmluZWQ7XG4gIH1cbiAgZnVuY3Rpb24gaGFuZGxlVG91Y2hNb3ZlKGUpIHtcbiAgICBpZiAoIWlzVG91Y2hlZCkgcmV0dXJuO1xuICAgIHRvdWNoTW92ZXMgKz0gMTtcbiAgICBpZiAodG91Y2hNb3ZlcyA8IDIpIHJldHVybjtcbiAgICBpZiAoZS5mN1ByZXZlbnRTd2lwZVBhbmVsIHx8IGFwcC5wcmV2ZW50U3dpcGVQYW5lbEJ5U3dpcGVCYWNrIHx8IGFwcC5wcmV2ZW50U3dpcGVQYW5lbCkge1xuICAgICAgaXNUb3VjaGVkID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHBhZ2VYID0gZS50eXBlID09PSAndG91Y2htb3ZlJyA/IGUudGFyZ2V0VG91Y2hlc1swXS5wYWdlWCA6IGUucGFnZVg7XG4gICAgY29uc3QgcGFnZVkgPSBlLnR5cGUgPT09ICd0b3VjaG1vdmUnID8gZS50YXJnZXRUb3VjaGVzWzBdLnBhZ2VZIDogZS5wYWdlWTtcbiAgICBpZiAodHlwZW9mIGlzU2Nyb2xsaW5nID09PSAndW5kZWZpbmVkJykge1xuICAgICAgaXNTY3JvbGxpbmcgPSAhIShpc1Njcm9sbGluZyB8fCBNYXRoLmFicyhwYWdlWSAtIHRvdWNoZXNTdGFydC55KSA+IE1hdGguYWJzKHBhZ2VYIC0gdG91Y2hlc1N0YXJ0LngpKTtcbiAgICB9XG4gICAgaWYgKGlzU2Nyb2xsaW5nKSB7XG4gICAgICBpc1RvdWNoZWQgPSBmYWxzZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFkaXJlY3Rpb24pIHtcbiAgICAgIGlmIChwYWdlWCA+IHRvdWNoZXNTdGFydC54KSB7XG4gICAgICAgIGRpcmVjdGlvbiA9ICd0by1yaWdodCc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkaXJlY3Rpb24gPSAndG8tbGVmdCc7XG4gICAgICB9XG5cbiAgICAgIGlmIChwYXJhbXMuc3dpcGUgPT09ICdib3RoJykge1xuICAgICAgICBpZiAocGFyYW1zLnN3aXBlQWN0aXZlQXJlYSA+IDAgJiYgIXBhbmVsLm9wZW5lZCkge1xuICAgICAgICAgIGlmIChzaWRlID09PSAnbGVmdCcgJiYgdG91Y2hlc1N0YXJ0LnggPiBwYXJhbXMuc3dpcGVBY3RpdmVBcmVhKSB7XG4gICAgICAgICAgICBpc1RvdWNoZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNpZGUgPT09ICdyaWdodCcgJiYgdG91Y2hlc1N0YXJ0LnggPCBhcHAud2lkdGggLSBwYXJhbXMuc3dpcGVBY3RpdmVBcmVhKSB7XG4gICAgICAgICAgICBpc1RvdWNoZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICgkZWwuaGFzQ2xhc3MoJ3BhbmVsLXZpc2libGUtYnktYnJlYWtwb2ludCcpKSB7XG4gICAgICAgIGlzVG91Y2hlZCA9IGZhbHNlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChcbiAgICAgICAgKHNpZGUgPT09ICdsZWZ0JyAmJlxuICAgICAgICAgIChcbiAgICAgICAgICAgIGRpcmVjdGlvbiA9PT0gJ3RvLWxlZnQnICYmICEkZWwuaGFzQ2xhc3MoJ3BhbmVsLWFjdGl2ZScpXG4gICAgICAgICAgKVxuICAgICAgICApXG4gICAgICAgIHx8XG4gICAgICAgIChzaWRlID09PSAncmlnaHQnICYmXG4gICAgICAgICAgKFxuICAgICAgICAgICAgZGlyZWN0aW9uID09PSAndG8tcmlnaHQnICYmICEkZWwuaGFzQ2xhc3MoJ3BhbmVsLWFjdGl2ZScpXG4gICAgICAgICAgKVxuICAgICAgICApXG4gICAgICApIHtcbiAgICAgICAgaXNUb3VjaGVkID0gZmFsc2U7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocGFyYW1zLnN3aXBlTm9Gb2xsb3cpIHtcbiAgICAgIGNvbnN0IHRpbWVEaWZmID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKSAtIHRvdWNoU3RhcnRUaW1lO1xuICAgICAgaWYgKHRpbWVEaWZmIDwgMzAwKSB7XG4gICAgICAgIGlmIChkaXJlY3Rpb24gPT09ICd0by1sZWZ0Jykge1xuICAgICAgICAgIGlmIChzaWRlID09PSAncmlnaHQnKSBhcHAucGFuZWwub3BlbihzaWRlKTtcbiAgICAgICAgICBpZiAoc2lkZSA9PT0gJ2xlZnQnICYmICRlbC5oYXNDbGFzcygncGFuZWwtYWN0aXZlJykpIGFwcC5wYW5lbC5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkaXJlY3Rpb24gPT09ICd0by1yaWdodCcpIHtcbiAgICAgICAgICBpZiAoc2lkZSA9PT0gJ2xlZnQnKSBhcHAucGFuZWwub3BlbihzaWRlKTtcbiAgICAgICAgICBpZiAoc2lkZSA9PT0gJ3JpZ2h0JyAmJiAkZWwuaGFzQ2xhc3MoJ3BhbmVsLWFjdGl2ZScpKSBhcHAucGFuZWwuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaXNUb3VjaGVkID0gZmFsc2U7XG4gICAgICBpc01vdmVkID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFpc01vdmVkKSB7XG4gICAgICBpZiAoIXBhbmVsLm9wZW5lZCkge1xuICAgICAgICAkZWwuc2hvdygpO1xuICAgICAgICAkYmFja2Ryb3BFbC5zaG93KCk7XG4gICAgICAgICRlbC50cmlnZ2VyKCdwYW5lbDpzd2lwZW9wZW4nLCBwYW5lbCk7XG4gICAgICAgIHBhbmVsLmVtaXQoJ2xvY2FsOjpzd2lwZU9wZW4gcGFuZWxTd2lwZU9wZW4nLCBwYW5lbCk7XG4gICAgICB9XG4gICAgICBwYW5lbFdpZHRoID0gJGVsWzBdLm9mZnNldFdpZHRoO1xuICAgICAgJGVsLnRyYW5zaXRpb24oMCk7XG4gICAgfVxuXG4gICAgaXNNb3ZlZCA9IHRydWU7XG5cbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgbGV0IHRocmVzaG9sZCA9IHBhbmVsLm9wZW5lZCA/IDAgOiAtcGFyYW1zLnN3aXBlVGhyZXNob2xkO1xuICAgIGlmIChzaWRlID09PSAncmlnaHQnKSB0aHJlc2hvbGQgPSAtdGhyZXNob2xkO1xuXG4gICAgdG91Y2hlc0RpZmYgPSAocGFnZVggLSB0b3VjaGVzU3RhcnQueCkgKyB0aHJlc2hvbGQ7XG5cbiAgICBpZiAoc2lkZSA9PT0gJ3JpZ2h0Jykge1xuICAgICAgaWYgKGVmZmVjdCA9PT0gJ2NvdmVyJykge1xuICAgICAgICB0cmFuc2xhdGUgPSB0b3VjaGVzRGlmZiArIChwYW5lbC5vcGVuZWQgPyAwIDogcGFuZWxXaWR0aCk7XG4gICAgICAgIGlmICh0cmFuc2xhdGUgPCAwKSB0cmFuc2xhdGUgPSAwO1xuICAgICAgICBpZiAodHJhbnNsYXRlID4gcGFuZWxXaWR0aCkge1xuICAgICAgICAgIHRyYW5zbGF0ZSA9IHBhbmVsV2lkdGg7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyYW5zbGF0ZSA9IHRvdWNoZXNEaWZmIC0gKHBhbmVsLm9wZW5lZCA/IHBhbmVsV2lkdGggOiAwKTtcbiAgICAgICAgaWYgKHRyYW5zbGF0ZSA+IDApIHRyYW5zbGF0ZSA9IDA7XG4gICAgICAgIGlmICh0cmFuc2xhdGUgPCAtcGFuZWxXaWR0aCkge1xuICAgICAgICAgIHRyYW5zbGF0ZSA9IC1wYW5lbFdpZHRoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyYW5zbGF0ZSA9IHRvdWNoZXNEaWZmICsgKHBhbmVsLm9wZW5lZCA/IHBhbmVsV2lkdGggOiAwKTtcbiAgICAgIGlmICh0cmFuc2xhdGUgPCAwKSB0cmFuc2xhdGUgPSAwO1xuICAgICAgaWYgKHRyYW5zbGF0ZSA+IHBhbmVsV2lkdGgpIHtcbiAgICAgICAgdHJhbnNsYXRlID0gcGFuZWxXaWR0aDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVmZmVjdCA9PT0gJ3JldmVhbCcpIHtcbiAgICAgICR2aWV3RWwudHJhbnNmb3JtKGB0cmFuc2xhdGUzZCgke3RyYW5zbGF0ZX1weCwwLDApYCkudHJhbnNpdGlvbigwKTtcbiAgICAgICRiYWNrZHJvcEVsLnRyYW5zZm9ybShgdHJhbnNsYXRlM2QoJHt0cmFuc2xhdGV9cHgsMCwwKWApLnRyYW5zaXRpb24oMCk7XG5cbiAgICAgICRlbC50cmlnZ2VyKCdwYW5lbDpzd2lwZScsIHBhbmVsLCBNYXRoLmFicyh0cmFuc2xhdGUgLyBwYW5lbFdpZHRoKSk7XG4gICAgICBwYW5lbC5lbWl0KCdsb2NhbDo6c3dpcGUgcGFuZWxTd2lwZScsIHBhbmVsLCBNYXRoLmFicyh0cmFuc2xhdGUgLyBwYW5lbFdpZHRoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChzaWRlID09PSAnbGVmdCcpIHRyYW5zbGF0ZSAtPSBwYW5lbFdpZHRoO1xuICAgICAgJGVsLnRyYW5zZm9ybShgdHJhbnNsYXRlM2QoJHt0cmFuc2xhdGV9cHgsMCwwKWApLnRyYW5zaXRpb24oMCk7XG5cbiAgICAgICRiYWNrZHJvcEVsLnRyYW5zaXRpb24oMCk7XG4gICAgICBiYWNrZHJvcE9wYWNpdHkgPSAxIC0gTWF0aC5hYnModHJhbnNsYXRlIC8gcGFuZWxXaWR0aCk7XG4gICAgICAkYmFja2Ryb3BFbC5jc3MoeyBvcGFjaXR5OiBiYWNrZHJvcE9wYWNpdHkgfSk7XG5cbiAgICAgICRlbC50cmlnZ2VyKCdwYW5lbDpzd2lwZScsIHBhbmVsLCBNYXRoLmFicyh0cmFuc2xhdGUgLyBwYW5lbFdpZHRoKSk7XG4gICAgICBwYW5lbC5lbWl0KCdsb2NhbDo6c3dpcGUgcGFuZWxTd2lwZScsIHBhbmVsLCBNYXRoLmFicyh0cmFuc2xhdGUgLyBwYW5lbFdpZHRoKSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGhhbmRsZVRvdWNoRW5kKCkge1xuICAgIGlmICghaXNUb3VjaGVkIHx8ICFpc01vdmVkKSB7XG4gICAgICBpc1RvdWNoZWQgPSBmYWxzZTtcbiAgICAgIGlzTW92ZWQgPSBmYWxzZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaXNUb3VjaGVkID0gZmFsc2U7XG4gICAgaXNNb3ZlZCA9IGZhbHNlO1xuICAgIGNvbnN0IHRpbWVEaWZmID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKSAtIHRvdWNoU3RhcnRUaW1lO1xuICAgIGxldCBhY3Rpb247XG4gICAgY29uc3QgZWRnZSA9ICh0cmFuc2xhdGUgPT09IDAgfHwgTWF0aC5hYnModHJhbnNsYXRlKSA9PT0gcGFuZWxXaWR0aCk7XG5cbiAgICBjb25zdCB0aHJlc2hvbGQgPSBwYXJhbXMuc3dpcGVUaHJlc2hvbGQgfHwgMDtcblxuICAgIGlmICghcGFuZWwub3BlbmVkKSB7XG4gICAgICBpZiAoTWF0aC5hYnModG91Y2hlc0RpZmYpIDwgdGhyZXNob2xkKSB7XG4gICAgICAgIGFjdGlvbiA9ICdyZXNldCc7XG4gICAgICB9IGVsc2UgaWYgKGVmZmVjdCA9PT0gJ2NvdmVyJykge1xuICAgICAgICBpZiAodHJhbnNsYXRlID09PSAwKSB7XG4gICAgICAgICAgYWN0aW9uID0gJ3N3YXAnOyAvLyBvcGVuXG4gICAgICAgIH0gZWxzZSBpZiAodGltZURpZmYgPCAzMDAgJiYgTWF0aC5hYnModHJhbnNsYXRlKSA+IDApIHtcbiAgICAgICAgICBhY3Rpb24gPSAnc3dhcCc7IC8vIG9wZW5cbiAgICAgICAgfSBlbHNlIGlmICh0aW1lRGlmZiA+PSAzMDAgJiYgTWF0aC5hYnModHJhbnNsYXRlKSA8IHBhbmVsV2lkdGggLyAyKSB7XG4gICAgICAgICAgYWN0aW9uID0gJ3N3YXAnOyAvLyBvcGVuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWN0aW9uID0gJ3Jlc2V0JzsgLy8gY2xvc2VcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0cmFuc2xhdGUgPT09IDApIHtcbiAgICAgICAgYWN0aW9uID0gJ3Jlc2V0JztcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICh0aW1lRGlmZiA8IDMwMCAmJiBNYXRoLmFicyh0cmFuc2xhdGUpID4gMClcbiAgICAgICAgfHxcbiAgICAgICAgKHRpbWVEaWZmID49IDMwMCAmJiAoTWF0aC5hYnModHJhbnNsYXRlKSA+PSBwYW5lbFdpZHRoIC8gMikpXG4gICAgICApIHtcbiAgICAgICAgYWN0aW9uID0gJ3N3YXAnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWN0aW9uID0gJ3Jlc2V0JztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGVmZmVjdCA9PT0gJ2NvdmVyJykge1xuICAgICAgaWYgKHRyYW5zbGF0ZSA9PT0gMCkge1xuICAgICAgICBhY3Rpb24gPSAncmVzZXQnOyAvLyBvcGVuXG4gICAgICB9IGVsc2UgaWYgKHRpbWVEaWZmIDwgMzAwICYmIE1hdGguYWJzKHRyYW5zbGF0ZSkgPiAwKSB7XG4gICAgICAgIGFjdGlvbiA9ICdzd2FwJzsgLy8gb3BlblxuICAgICAgfSBlbHNlIGlmICh0aW1lRGlmZiA+PSAzMDAgJiYgTWF0aC5hYnModHJhbnNsYXRlKSA8IHBhbmVsV2lkdGggLyAyKSB7XG4gICAgICAgIGFjdGlvbiA9ICdyZXNldCc7IC8vIG9wZW5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFjdGlvbiA9ICdzd2FwJzsgLy8gY2xvc2VcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRyYW5zbGF0ZSA9PT0gLXBhbmVsV2lkdGgpIHtcbiAgICAgIGFjdGlvbiA9ICdyZXNldCc7XG4gICAgfSBlbHNlIGlmIChcbiAgICAgICh0aW1lRGlmZiA8IDMwMCAmJiBNYXRoLmFicyh0cmFuc2xhdGUpID49IDApXG4gICAgICB8fFxuICAgICAgKHRpbWVEaWZmID49IDMwMCAmJiAoTWF0aC5hYnModHJhbnNsYXRlKSA8PSBwYW5lbFdpZHRoIC8gMikpXG4gICAgKSB7XG4gICAgICBpZiAoc2lkZSA9PT0gJ2xlZnQnICYmIHRyYW5zbGF0ZSA9PT0gcGFuZWxXaWR0aCkgYWN0aW9uID0gJ3Jlc2V0JztcbiAgICAgIGVsc2UgYWN0aW9uID0gJ3N3YXAnO1xuICAgIH0gZWxzZSB7XG4gICAgICBhY3Rpb24gPSAncmVzZXQnO1xuICAgIH1cbiAgICBpZiAoYWN0aW9uID09PSAnc3dhcCcpIHtcbiAgICAgIGlmIChwYW5lbC5vcGVuZWQpIHtcbiAgICAgICAgcGFuZWwuY2xvc2UoIWVkZ2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFuZWwub3BlbighZWRnZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChhY3Rpb24gPT09ICdyZXNldCcpIHtcbiAgICAgIGlmICghcGFuZWwub3BlbmVkKSB7XG4gICAgICAgIGlmIChlZGdlKSB7XG4gICAgICAgICAgJGVsLmNzcyh7IGRpc3BsYXk6ICcnIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IHRhcmdldCA9IGVmZmVjdCA9PT0gJ3JldmVhbCcgPyAkdmlld0VsIDogJGVsO1xuICAgICAgICAgICQoJ2h0bWwnKS5hZGRDbGFzcygnd2l0aC1wYW5lbC10cmFuc2l0aW9uaW5nJyk7XG4gICAgICAgICAgdGFyZ2V0LnRyYW5zaXRpb25FbmQoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCRlbC5oYXNDbGFzcygncGFuZWwtYWN0aXZlJykpIHJldHVybjtcbiAgICAgICAgICAgICRlbC5jc3MoeyBkaXNwbGF5OiAnJyB9KTtcbiAgICAgICAgICAgICQoJ2h0bWwnKS5yZW1vdmVDbGFzcygnd2l0aC1wYW5lbC10cmFuc2l0aW9uaW5nJyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVmZmVjdCA9PT0gJ3JldmVhbCcpIHtcbiAgICAgIFV0aWxzLm5leHRGcmFtZSgoKSA9PiB7XG4gICAgICAgICR2aWV3RWwudHJhbnNpdGlvbignJyk7XG4gICAgICAgICR2aWV3RWwudHJhbnNmb3JtKCcnKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAkZWwudHJhbnNpdGlvbignJykudHJhbnNmb3JtKCcnKTtcbiAgICAkYmFja2Ryb3BFbC5jc3MoeyBkaXNwbGF5OiAnJyB9KS50cmFuc2Zvcm0oJycpLnRyYW5zaXRpb24oJycpLmNzcygnb3BhY2l0eScsICcnKTtcbiAgfVxuXG4gIC8vIEFkZCBFdmVudHNcbiAgYXBwLm9uKCd0b3VjaHN0YXJ0OnBhc3NpdmUnLCBoYW5kbGVUb3VjaFN0YXJ0KTtcbiAgYXBwLm9uKCd0b3VjaG1vdmU6YWN0aXZlJywgaGFuZGxlVG91Y2hNb3ZlKTtcbiAgYXBwLm9uKCd0b3VjaGVuZDpwYXNzaXZlJywgaGFuZGxlVG91Y2hFbmQpO1xuICBwYW5lbC5vbigncGFuZWxEZXN0cm95JywgKCkgPT4ge1xuICAgIGFwcC5vZmYoJ3RvdWNoc3RhcnQ6cGFzc2l2ZScsIGhhbmRsZVRvdWNoU3RhcnQpO1xuICAgIGFwcC5vZmYoJ3RvdWNobW92ZTphY3RpdmUnLCBoYW5kbGVUb3VjaE1vdmUpO1xuICAgIGFwcC5vZmYoJ3RvdWNoZW5kOnBhc3NpdmUnLCBoYW5kbGVUb3VjaEVuZCk7XG4gIH0pO1xufVxuXG5jbGFzcyBQYW5lbCBleHRlbmRzIEZyYW1ld29yazdDbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGFwcCwgcGFyYW1zID0ge30pIHtcbiAgICBzdXBlcihwYXJhbXMsIFthcHBdKTtcbiAgICBjb25zdCBwYW5lbCA9IHRoaXM7XG5cbiAgICBjb25zdCBlbCA9IHBhcmFtcy5lbDtcbiAgICBjb25zdCAkZWwgPSAkKGVsKTtcbiAgICBpZiAoJGVsLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHBhbmVsO1xuICAgIGlmICgkZWxbMF0uZjdQYW5lbCkgcmV0dXJuICRlbFswXS5mN1BhbmVsO1xuXG4gICAgJGVsWzBdLmY3UGFuZWwgPSBwYW5lbDtcblxuICAgIGxldCB7IG9wZW5lZCwgc2lkZSwgZWZmZWN0IH0gPSBwYXJhbXM7XG4gICAgaWYgKHR5cGVvZiBvcGVuZWQgPT09ICd1bmRlZmluZWQnKSBvcGVuZWQgPSAkZWwuaGFzQ2xhc3MoJ3BhbmVsLWFjdGl2ZScpO1xuICAgIGlmICh0eXBlb2Ygc2lkZSA9PT0gJ3VuZGVmaW5lZCcpIHNpZGUgPSAkZWwuaGFzQ2xhc3MoJ3BhbmVsLWxlZnQnKSA/ICdsZWZ0JyA6ICdyaWdodCc7XG4gICAgaWYgKHR5cGVvZiBlZmZlY3QgPT09ICd1bmRlZmluZWQnKSBlZmZlY3QgPSAkZWwuaGFzQ2xhc3MoJ3BhbmVsLWNvdmVyJykgPyAnY292ZXInIDogJ3JldmVhbCc7XG5cbiAgICBpZiAoIWFwcC5wYW5lbFtzaWRlXSkge1xuICAgICAgVXRpbHMuZXh0ZW5kKGFwcC5wYW5lbCwge1xuICAgICAgICBbc2lkZV06IHBhbmVsLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgbGV0ICRiYWNrZHJvcEVsID0gJCgnLnBhbmVsLWJhY2tkcm9wJyk7XG4gICAgaWYgKCRiYWNrZHJvcEVsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgJGJhY2tkcm9wRWwgPSAkKCc8ZGl2IGNsYXNzPVwicGFuZWwtYmFja2Ryb3BcIj48L2Rpdj4nKTtcbiAgICAgICRiYWNrZHJvcEVsLmluc2VydEJlZm9yZSgkZWwpO1xuICAgIH1cblxuICAgIFV0aWxzLmV4dGVuZChwYW5lbCwge1xuICAgICAgYXBwLFxuICAgICAgc2lkZSxcbiAgICAgIGVmZmVjdCxcbiAgICAgICRlbCxcbiAgICAgIGVsOiAkZWxbMF0sXG4gICAgICBvcGVuZWQsXG4gICAgICAkYmFja2Ryb3BFbCxcbiAgICAgIGJhY2tkcm9wRWw6ICRiYWNrZHJvcEVsWzBdLFxuICAgIH0pO1xuXG4gICAgLy8gSW5zdGFsbCBNb2R1bGVzXG4gICAgcGFuZWwudXNlTW9kdWxlcygpO1xuXG4gICAgLy8gSW5pdFxuICAgIHBhbmVsLmluaXQoKTtcblxuICAgIHJldHVybiBwYW5lbDtcbiAgfVxuICBpbml0KCkge1xuICAgIGNvbnN0IHBhbmVsID0gdGhpcztcbiAgICBjb25zdCBhcHAgPSBwYW5lbC5hcHA7XG4gICAgaWYgKGFwcC5wYXJhbXMucGFuZWxbYCR7cGFuZWwuc2lkZX1CcmVha3BvaW50YF0pIHtcbiAgICAgIHBhbmVsLmluaXRCcmVha3BvaW50cygpO1xuICAgIH1cbiAgICB7XG4gICAgICBpZiAoXG4gICAgICAgIChhcHAucGFyYW1zLnBhbmVsLnN3aXBlID09PSBwYW5lbC5zaWRlKVxuICAgICAgICB8fFxuICAgICAgICAoYXBwLnBhcmFtcy5wYW5lbC5zd2lwZSA9PT0gJ2JvdGgnKVxuICAgICAgICB8fFxuICAgICAgICAoYXBwLnBhcmFtcy5wYW5lbC5zd2lwZSAmJiBhcHAucGFyYW1zLnBhbmVsLnN3aXBlICE9PSBwYW5lbC5zaWRlICYmIGFwcC5wYXJhbXMucGFuZWwuc3dpcGVDbG9zZU9wcG9zaXRlKVxuICAgICAgKSB7XG4gICAgICAgIHBhbmVsLmluaXRTd2lwZVBhbmVsKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGdldFZpZXdFbCgpIHtcbiAgICBjb25zdCBwYW5lbCA9IHRoaXM7XG4gICAgY29uc3QgYXBwID0gcGFuZWwuYXBwO1xuICAgIGxldCB2aWV3RWw7XG4gICAgaWYgKGFwcC5yb290LmNoaWxkcmVuKCcudmlld3MnKS5sZW5ndGggPiAwKSB7XG4gICAgICB2aWV3RWwgPSBhcHAucm9vdC5jaGlsZHJlbignLnZpZXdzJylbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZpZXdFbCA9IGFwcC5yb290LmNoaWxkcmVuKCcudmlldycpWzBdO1xuICAgIH1cbiAgICByZXR1cm4gdmlld0VsO1xuICB9XG4gIHNldEJyZWFrcG9pbnQoKSB7XG4gICAgY29uc3QgcGFuZWwgPSB0aGlzO1xuICAgIGNvbnN0IGFwcCA9IHBhbmVsLmFwcDtcbiAgICBjb25zdCB7IHNpZGUsICRlbCB9ID0gcGFuZWw7XG4gICAgY29uc3QgJHZpZXdFbCA9ICQocGFuZWwuZ2V0Vmlld0VsKCkpO1xuICAgIGNvbnN0IGJyZWFrcG9pbnQgPSBhcHAucGFyYW1zLnBhbmVsW2Ake3NpZGV9QnJlYWtwb2ludGBdO1xuICAgIGNvbnN0IHdhc1Zpc2libGUgPSAkZWwuaGFzQ2xhc3MoJ3BhbmVsLXZpc2libGUtYnktYnJlYWtwb2ludCcpO1xuXG4gICAgaWYgKGFwcC53aWR0aCA+PSBicmVha3BvaW50KSB7XG4gICAgICBpZiAoIXdhc1Zpc2libGUpIHtcbiAgICAgICAgJCgnaHRtbCcpLnJlbW92ZUNsYXNzKGB3aXRoLXBhbmVsLSR7c2lkZX0tcmV2ZWFsIHdpdGgtcGFuZWwtJHtzaWRlfS1jb3ZlciB3aXRoLXBhbmVsYCk7XG4gICAgICAgICRlbC5jc3MoJ2Rpc3BsYXknLCAnJykuYWRkQ2xhc3MoJ3BhbmVsLXZpc2libGUtYnktYnJlYWtwb2ludCcpLnJlbW92ZUNsYXNzKCdwYW5lbC1hY3RpdmUnKTtcbiAgICAgICAgcGFuZWwub25PcGVuKCk7XG4gICAgICAgIHBhbmVsLm9uT3BlbmVkKCk7XG4gICAgICAgICR2aWV3RWwuY3NzKHtcbiAgICAgICAgICBbYG1hcmdpbi0ke3NpZGV9YF06IGAkeyRlbC53aWR0aCgpfXB4YCxcbiAgICAgICAgfSk7XG4gICAgICAgIGFwcC5hbGxvd1BhbmVsT3BlbiA9IHRydWU7XG4gICAgICAgIGFwcC5lbWl0KCdsb2NhbDo6YnJlYWtwb2ludCBwYW5lbEJyZWFrcG9pbnQnKTtcbiAgICAgICAgcGFuZWwuJGVsLnRyaWdnZXIoJ3BhbmVsOmJyZWFrcG9pbnQnLCBwYW5lbCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh3YXNWaXNpYmxlKSB7XG4gICAgICAkZWwuY3NzKCdkaXNwbGF5JywgJycpLnJlbW92ZUNsYXNzKCdwYW5lbC12aXNpYmxlLWJ5LWJyZWFrcG9pbnQgcGFuZWwtYWN0aXZlJyk7XG4gICAgICBwYW5lbC5vbkNsb3NlKCk7XG4gICAgICBwYW5lbC5vbkNsb3NlZCgpO1xuICAgICAgJHZpZXdFbC5jc3Moe1xuICAgICAgICBbYG1hcmdpbi0ke3NpZGV9YF06ICcnLFxuICAgICAgfSk7XG4gICAgICBhcHAuZW1pdCgnbG9jYWw6OmJyZWFrcG9pbnQgcGFuZWxCcmVha3BvaW50Jyk7XG4gICAgICBwYW5lbC4kZWwudHJpZ2dlcigncGFuZWw6YnJlYWtwb2ludCcsIHBhbmVsKTtcbiAgICB9XG4gIH1cbiAgaW5pdEJyZWFrcG9pbnRzKCkge1xuICAgIGNvbnN0IHBhbmVsID0gdGhpcztcbiAgICBjb25zdCBhcHAgPSBwYW5lbC5hcHA7XG4gICAgcGFuZWwucmVzaXplSGFuZGxlciA9IGZ1bmN0aW9uIHJlc2l6ZUhhbmRsZXIoKSB7XG4gICAgICBwYW5lbC5zZXRCcmVha3BvaW50KCk7XG4gICAgfTtcbiAgICBpZiAoYXBwLnBhcmFtcy5wYW5lbFtgJHtwYW5lbC5zaWRlfUJyZWFrcG9pbnRgXSkge1xuICAgICAgYXBwLm9uKCdyZXNpemUnLCBwYW5lbC5yZXNpemVIYW5kbGVyKTtcbiAgICB9XG4gICAgcGFuZWwuc2V0QnJlYWtwb2ludCgpO1xuICAgIHJldHVybiBwYW5lbDtcbiAgfVxuICBpbml0U3dpcGVQYW5lbCgpIHtcbiAgICB7XG4gICAgICBzd2lwZVBhbmVsKHRoaXMpO1xuICAgIH1cbiAgfVxuICBkZXN0cm95KCkge1xuICAgIGxldCBwYW5lbCA9IHRoaXM7XG4gICAgY29uc3QgYXBwID0gcGFuZWwuYXBwO1xuXG4gICAgcGFuZWwuZW1pdCgnbG9jYWw6OmJlZm9yZURlc3Ryb3kgcGFuZWxCZWZvcmVEZXN0cm95JywgcGFuZWwpO1xuICAgIHBhbmVsLiRlbC50cmlnZ2VyKCdwYW5lbDpiZWZvcmVkZXN0cm95JywgcGFuZWwpO1xuXG4gICAgaWYgKHBhbmVsLnJlc2l6ZUhhbmRsZXIpIHtcbiAgICAgIGFwcC5vZmYoJ3Jlc2l6ZScsIHBhbmVsLnJlc2l6ZUhhbmRsZXIpO1xuICAgIH1cbiAgICBwYW5lbC4kZWwudHJpZ2dlcigncGFuZWw6ZGVzdHJveScsIHBhbmVsKTtcbiAgICBwYW5lbC5lbWl0KCdsb2NhbDo6ZGVzdHJveSBwYW5lbERlc3Ryb3knKTtcbiAgICBkZWxldGUgYXBwLnBhbmVsW3BhbmVsLnNpZGVdO1xuICAgIGRlbGV0ZSBwYW5lbC5lbC5mN1BhbmVsO1xuICAgIFV0aWxzLmRlbGV0ZVByb3BzKHBhbmVsKTtcbiAgICBwYW5lbCA9IG51bGw7XG4gIH1cbiAgb3BlbihhbmltYXRlID0gdHJ1ZSkge1xuICAgIGNvbnN0IHBhbmVsID0gdGhpcztcbiAgICBjb25zdCBhcHAgPSBwYW5lbC5hcHA7XG4gICAgaWYgKCFhcHAucGFuZWwuYWxsb3dPcGVuKSByZXR1cm4gZmFsc2U7XG5cbiAgICBjb25zdCB7IHNpZGUsIGVmZmVjdCwgJGVsLCAkYmFja2Ryb3BFbCwgb3BlbmVkIH0gPSBwYW5lbDtcblxuICAgIC8vIElnbm9yZSBpZiBvcGVuZWRcbiAgICBpZiAob3BlbmVkIHx8ICRlbC5oYXNDbGFzcygncGFuZWwtdmlzaWJsZS1ieS1icmVha3BvaW50JykgfHwgJGVsLmhhc0NsYXNzKCdwYW5lbC1hY3RpdmUnKSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgLy8gQ2xvc2UgaWYgc29tZSBwYW5lbCBpcyBvcGVuZWRcbiAgICBhcHAucGFuZWwuY2xvc2Uoc2lkZSA9PT0gJ2xlZnQnID8gJ3JpZ2h0JyA6ICdsZWZ0JywgYW5pbWF0ZSk7XG5cbiAgICBhcHAucGFuZWwuYWxsb3dPcGVuID0gZmFsc2U7XG5cbiAgICAkZWxbYW5pbWF0ZSA/ICdyZW1vdmVDbGFzcycgOiAnYWRkQ2xhc3MnXSgnbm90LWFuaW1hdGVkJyk7XG4gICAgJGVsXG4gICAgICAuY3NzKHsgZGlzcGxheTogJ2Jsb2NrJyB9KVxuICAgICAgLmFkZENsYXNzKCdwYW5lbC1hY3RpdmUnKTtcblxuICAgICRiYWNrZHJvcEVsW2FuaW1hdGUgPyAncmVtb3ZlQ2xhc3MnIDogJ2FkZENsYXNzJ10oJ25vdC1hbmltYXRlZCcpO1xuICAgICRiYWNrZHJvcEVsLnNob3coKTtcblxuICAgIC8qIGVzbGludCBuby11bmRlcnNjb3JlLWRhbmdsZTogW1wiZXJyb3JcIiwgeyBcImFsbG93XCI6IFtcIl9jbGllbnRMZWZ0XCJdIH1dICovXG4gICAgcGFuZWwuX2NsaWVudExlZnQgPSAkZWxbMF0uY2xpZW50TGVmdDtcblxuICAgICQoJ2h0bWwnKS5hZGRDbGFzcyhgd2l0aC1wYW5lbCB3aXRoLXBhbmVsLSR7c2lkZX0tJHtlZmZlY3R9YCk7XG4gICAgcGFuZWwub25PcGVuKCk7XG5cbiAgICAvLyBUcmFuc2l0aW9uIEVuZDtcbiAgICBjb25zdCB0cmFuc2l0aW9uRW5kVGFyZ2V0ID0gZWZmZWN0ID09PSAncmV2ZWFsJyA/ICRlbC5uZXh0QWxsKCcudmlldywgLnZpZXdzJykuZXEoMCkgOiAkZWw7XG5cbiAgICBmdW5jdGlvbiBwYW5lbFRyYW5zaXRpb25FbmQoKSB7XG4gICAgICB0cmFuc2l0aW9uRW5kVGFyZ2V0LnRyYW5zaXRpb25FbmQoKGUpID0+IHtcbiAgICAgICAgaWYgKCQoZS50YXJnZXQpLmlzKHRyYW5zaXRpb25FbmRUYXJnZXQpKSB7XG4gICAgICAgICAgaWYgKCRlbC5oYXNDbGFzcygncGFuZWwtYWN0aXZlJykpIHtcbiAgICAgICAgICAgIHBhbmVsLm9uT3BlbmVkKCk7XG4gICAgICAgICAgICAkYmFja2Ryb3BFbC5jc3MoeyBkaXNwbGF5OiAnJyB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFuZWwub25DbG9zZWQoKTtcbiAgICAgICAgICAgICRiYWNrZHJvcEVsLmNzcyh7IGRpc3BsYXk6ICcnIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHBhbmVsVHJhbnNpdGlvbkVuZCgpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChhbmltYXRlKSB7XG4gICAgICBwYW5lbFRyYW5zaXRpb25FbmQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFuZWwub25PcGVuZWQoKTtcbiAgICAgICRiYWNrZHJvcEVsLmNzcyh7IGRpc3BsYXk6ICcnIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNsb3NlKGFuaW1hdGUgPSB0cnVlKSB7XG4gICAgY29uc3QgcGFuZWwgPSB0aGlzO1xuICAgIGNvbnN0IGFwcCA9IHBhbmVsLmFwcDtcblxuICAgIGNvbnN0IHsgc2lkZSwgZWZmZWN0LCAkZWwsICRiYWNrZHJvcEVsLCBvcGVuZWQgfSA9IHBhbmVsO1xuXG4gICAgaWYgKCFvcGVuZWQgfHwgJGVsLmhhc0NsYXNzKCdwYW5lbC12aXNpYmxlLWJ5LWJyZWFrcG9pbnQnKSB8fCAhJGVsLmhhc0NsYXNzKCdwYW5lbC1hY3RpdmUnKSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgJGVsW2FuaW1hdGUgPyAncmVtb3ZlQ2xhc3MnIDogJ2FkZENsYXNzJ10oJ25vdC1hbmltYXRlZCcpO1xuICAgICRlbC5yZW1vdmVDbGFzcygncGFuZWwtYWN0aXZlJyk7XG5cbiAgICAkYmFja2Ryb3BFbFthbmltYXRlID8gJ3JlbW92ZUNsYXNzJyA6ICdhZGRDbGFzcyddKCdub3QtYW5pbWF0ZWQnKTtcblxuICAgIGNvbnN0IHRyYW5zaXRpb25FbmRUYXJnZXQgPSBlZmZlY3QgPT09ICdyZXZlYWwnID8gJGVsLm5leHRBbGwoJy52aWV3LCAudmlld3MnKS5lcSgwKSA6ICRlbDtcblxuICAgIHBhbmVsLm9uQ2xvc2UoKTtcbiAgICBhcHAucGFuZWwuYWxsb3dPcGVuID0gZmFsc2U7XG5cbiAgICBpZiAoYW5pbWF0ZSkge1xuICAgICAgdHJhbnNpdGlvbkVuZFRhcmdldC50cmFuc2l0aW9uRW5kKCgpID0+IHtcbiAgICAgICAgaWYgKCRlbC5oYXNDbGFzcygncGFuZWwtYWN0aXZlJykpIHJldHVybjtcbiAgICAgICAgJGVsLmNzcyh7IGRpc3BsYXk6ICcnIH0pO1xuICAgICAgICAkKCdodG1sJykucmVtb3ZlQ2xhc3MoJ3dpdGgtcGFuZWwtdHJhbnNpdGlvbmluZycpO1xuICAgICAgICBwYW5lbC5vbkNsb3NlZCgpO1xuICAgICAgfSk7XG4gICAgICAkKCdodG1sJylcbiAgICAgICAgLnJlbW92ZUNsYXNzKGB3aXRoLXBhbmVsIHdpdGgtcGFuZWwtJHtzaWRlfS0ke2VmZmVjdH1gKVxuICAgICAgICAuYWRkQ2xhc3MoJ3dpdGgtcGFuZWwtdHJhbnNpdGlvbmluZycpO1xuICAgIH0gZWxzZSB7XG4gICAgICAkZWwuY3NzKHsgZGlzcGxheTogJycgfSk7XG4gICAgICAkZWwucmVtb3ZlQ2xhc3MoJ25vdC1hbmltYXRlZCcpO1xuICAgICAgJCgnaHRtbCcpLnJlbW92ZUNsYXNzKGB3aXRoLXBhbmVsIHdpdGgtcGFuZWwtdHJhbnNpdGlvbmluZyB3aXRoLXBhbmVsLSR7c2lkZX0tJHtlZmZlY3R9YCk7XG4gICAgICBwYW5lbC5vbkNsb3NlZCgpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBvbk9wZW4oKSB7XG4gICAgY29uc3QgcGFuZWwgPSB0aGlzO1xuICAgIHBhbmVsLm9wZW5lZCA9IHRydWU7XG4gICAgcGFuZWwuJGVsLnRyaWdnZXIoJ3BhbmVsOm9wZW4nLCBwYW5lbCk7XG4gICAgcGFuZWwuZW1pdCgnbG9jYWw6Om9wZW4gcGFuZWxPcGVuJywgcGFuZWwpO1xuICB9XG4gIG9uT3BlbmVkKCkge1xuICAgIGNvbnN0IHBhbmVsID0gdGhpcztcbiAgICBjb25zdCBhcHAgPSBwYW5lbC5hcHA7XG4gICAgYXBwLnBhbmVsLmFsbG93T3BlbiA9IHRydWU7XG5cbiAgICBwYW5lbC4kZWwudHJpZ2dlcigncGFuZWw6b3BlbmVkJywgcGFuZWwpO1xuICAgIHBhbmVsLmVtaXQoJ2xvY2FsOjpvcGVuZWQgcGFuZWxPcGVuZWQnLCBwYW5lbCk7XG4gIH1cbiAgb25DbG9zZSgpIHtcbiAgICBjb25zdCBwYW5lbCA9IHRoaXM7XG4gICAgcGFuZWwub3BlbmVkID0gZmFsc2U7XG4gICAgcGFuZWwuJGVsLmFkZENsYXNzKCdwYW5lbC1jbG9zaW5nJyk7XG4gICAgcGFuZWwuJGVsLnRyaWdnZXIoJ3BhbmVsOmNsb3NlJywgcGFuZWwpO1xuICAgIHBhbmVsLmVtaXQoJ2xvY2FsOjpjbG9zZSBwYW5lbENsb3NlJywgcGFuZWwpO1xuICB9XG4gIG9uQ2xvc2VkKCkge1xuICAgIGNvbnN0IHBhbmVsID0gdGhpcztcbiAgICBjb25zdCBhcHAgPSBwYW5lbC5hcHA7XG4gICAgYXBwLnBhbmVsLmFsbG93T3BlbiA9IHRydWU7XG4gICAgcGFuZWwuJGVsLnJlbW92ZUNsYXNzKCdwYW5lbC1jbG9zaW5nJyk7XG4gICAgcGFuZWwuJGVsLnRyaWdnZXIoJ3BhbmVsOmNsb3NlZCcsIHBhbmVsKTtcbiAgICBwYW5lbC5lbWl0KCdsb2NhbDo6Y2xvc2VkIHBhbmVsQ2xvc2VkJywgcGFuZWwpO1xuICB9XG59XG5cbnZhciBQYW5lbCQxID0ge1xuICBuYW1lOiAncGFuZWwnLFxuICBwYXJhbXM6IHtcbiAgICBwYW5lbDoge1xuICAgICAgbGVmdEJyZWFrcG9pbnQ6IDAsXG4gICAgICByaWdodEJyZWFrcG9pbnQ6IDAsXG4gICAgICBzd2lwZTogdW5kZWZpbmVkLCAvLyBvciAnbGVmdCcgb3IgJ3JpZ2h0JyBvciAnYm90aCdcbiAgICAgIHN3aXBlQWN0aXZlQXJlYTogMCxcbiAgICAgIHN3aXBlQ2xvc2VBY3RpdmVBcmVhU2lkZTogMCxcbiAgICAgIHN3aXBlQ2xvc2VPcHBvc2l0ZTogdHJ1ZSxcbiAgICAgIHN3aXBlT25seUNsb3NlOiBmYWxzZSxcbiAgICAgIHN3aXBlTm9Gb2xsb3c6IGZhbHNlLFxuICAgICAgc3dpcGVUaHJlc2hvbGQ6IDAsXG4gICAgICBjbG9zZUJ5QmFja2Ryb3BDbGljazogdHJ1ZSxcbiAgICB9LFxuICB9LFxuICBzdGF0aWM6IHtcbiAgICBQYW5lbCxcbiAgfSxcbiAgaW5zdGFuY2U6IHtcbiAgICBwYW5lbDoge1xuICAgICAgYWxsb3dPcGVuOiB0cnVlLFxuICAgIH0sXG4gIH0sXG4gIGNyZWF0ZSgpIHtcbiAgICBjb25zdCBhcHAgPSB0aGlzO1xuICAgIFV0aWxzLmV4dGVuZChhcHAucGFuZWwsIHtcbiAgICAgIGRpc2FibGVTd2lwZShwYW5lbCA9ICdib3RoJykge1xuICAgICAgICBsZXQgc2lkZTtcbiAgICAgICAgbGV0IHBhbmVscyA9IFtdO1xuICAgICAgICBpZiAodHlwZW9mIHBhbmVsID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGlmIChwYW5lbCA9PT0gJ2JvdGgnKSB7XG4gICAgICAgICAgICBzaWRlID0gJ2JvdGgnO1xuICAgICAgICAgICAgcGFuZWxzID0gW2FwcC5wYW5lbC5sZWZ0LCBhcHAucGFuZWwucmlnaHRdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzaWRlID0gcGFuZWw7XG4gICAgICAgICAgICBwYW5lbHMgPSBhcHAucGFuZWxbc2lkZV07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhbmVscyA9IFtwYW5lbF07XG4gICAgICAgIH1cbiAgICAgICAgcGFuZWxzLmZvckVhY2goKHBhbmVsSW5zdGFuY2UpID0+IHtcbiAgICAgICAgICBpZiAocGFuZWxJbnN0YW5jZSkgVXRpbHMuZXh0ZW5kKHBhbmVsSW5zdGFuY2UsIHsgc3dpcGVhYmxlOiBmYWxzZSB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgZW5hYmxlU3dpcGUocGFuZWwgPSAnYm90aCcpIHtcbiAgICAgICAgbGV0IHBhbmVscyA9IFtdO1xuICAgICAgICBsZXQgc2lkZTtcbiAgICAgICAgaWYgKHR5cGVvZiBwYW5lbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBzaWRlID0gcGFuZWw7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgKGFwcC5wYXJhbXMucGFuZWwuc3dpcGUgPT09ICdsZWZ0JyAmJiBzaWRlID09PSAncmlnaHQnKSB8fFxuICAgICAgICAgICAgKGFwcC5wYXJhbXMucGFuZWwuc3dpcGUgPT09ICdyaWdodCcgJiYgc2lkZSA9PT0gJ2xlZnQnKSB8fFxuICAgICAgICAgICAgc2lkZSA9PT0gJ2JvdGgnXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBzaWRlID0gJ2JvdGgnO1xuICAgICAgICAgICAgYXBwLnBhcmFtcy5wYW5lbC5zd2lwZSA9IHNpZGU7XG4gICAgICAgICAgICBwYW5lbHMgPSBbYXBwLnBhbmVsLmxlZnQsIGFwcC5wYW5lbC5yaWdodF07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFwcC5wYXJhbXMucGFuZWwuc3dpcGUgPSBzaWRlO1xuICAgICAgICAgICAgcGFuZWxzLnB1c2goYXBwLnBhbmVsW3NpZGVdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAocGFuZWwpIHtcbiAgICAgICAgICBwYW5lbHMucHVzaChwYW5lbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhbmVscy5sZW5ndGgpIHtcbiAgICAgICAgICBwYW5lbHMuZm9yRWFjaCgocGFuZWxJbnN0YW5jZSkgPT4ge1xuICAgICAgICAgICAgaWYgKCFwYW5lbEluc3RhbmNlKSByZXR1cm47XG4gICAgICAgICAgICBpZiAoIXBhbmVsSW5zdGFuY2Uuc3dpcGVJbml0aWFsaXplZCkge1xuICAgICAgICAgICAgICBwYW5lbEluc3RhbmNlLmluaXRTd2lwZVBhbmVsKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBVdGlscy5leHRlbmQocGFuZWxJbnN0YW5jZSwgeyBzd2lwZWFibGU6IHRydWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjcmVhdGUocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBuZXcgUGFuZWwoYXBwLCBwYXJhbXMpO1xuICAgICAgfSxcbiAgICAgIG9wZW4oc2lkZSwgYW5pbWF0ZSkge1xuICAgICAgICBsZXQgcGFuZWxTaWRlID0gc2lkZTtcbiAgICAgICAgaWYgKCFwYW5lbFNpZGUpIHtcbiAgICAgICAgICBpZiAoJCgnLnBhbmVsJykubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwYW5lbFNpZGUgPSAkKCcucGFuZWwnKS5oYXNDbGFzcygncGFuZWwtbGVmdCcpID8gJ2xlZnQnIDogJ3JpZ2h0JztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXBhbmVsU2lkZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoYXBwLnBhbmVsW3BhbmVsU2lkZV0pIHtcbiAgICAgICAgICByZXR1cm4gYXBwLnBhbmVsW3BhbmVsU2lkZV0ub3BlbihhbmltYXRlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCAkcGFuZWxFbCA9ICQoYC5wYW5lbC0ke3BhbmVsU2lkZX1gKTtcbiAgICAgICAgaWYgKCRwYW5lbEVsLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICByZXR1cm4gYXBwLnBhbmVsLmNyZWF0ZSh7IGVsOiAkcGFuZWxFbCB9KS5vcGVuKGFuaW1hdGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0sXG4gICAgICBjbG9zZShzaWRlLCBhbmltYXRlKSB7XG4gICAgICAgIGxldCAkcGFuZWxFbDtcbiAgICAgICAgbGV0IHBhbmVsU2lkZTtcbiAgICAgICAgaWYgKHBhbmVsU2lkZSkge1xuICAgICAgICAgIHBhbmVsU2lkZSA9IHNpZGU7XG4gICAgICAgICAgJHBhbmVsRWwgPSAkKGAucGFuZWwtJHtwYW5lbFNpZGV9YCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgJHBhbmVsRWwgPSAkKCcucGFuZWwucGFuZWwtYWN0aXZlJyk7XG4gICAgICAgICAgcGFuZWxTaWRlID0gJHBhbmVsRWwuaGFzQ2xhc3MoJ3BhbmVsLWxlZnQnKSA/ICdsZWZ0JyA6ICdyaWdodCc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwYW5lbFNpZGUpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGFwcC5wYW5lbFtwYW5lbFNpZGVdKSB7XG4gICAgICAgICAgcmV0dXJuIGFwcC5wYW5lbFtwYW5lbFNpZGVdLmNsb3NlKGFuaW1hdGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgkcGFuZWxFbC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgcmV0dXJuIGFwcC5wYW5lbC5jcmVhdGUoeyBlbDogJHBhbmVsRWwgfSkuY2xvc2UoYW5pbWF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSxcbiAgICAgIGdldChzaWRlKSB7XG4gICAgICAgIGxldCBwYW5lbFNpZGUgPSBzaWRlO1xuICAgICAgICBpZiAoIXBhbmVsU2lkZSkge1xuICAgICAgICAgIGlmICgkKCcucGFuZWwnKS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwYW5lbFNpZGUgPSAkKCcucGFuZWwnKS5oYXNDbGFzcygncGFuZWwtbGVmdCcpID8gJ2xlZnQnIDogJ3JpZ2h0JztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXBhbmVsU2lkZSkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKGFwcC5wYW5lbFtwYW5lbFNpZGVdKSB7XG4gICAgICAgICAgcmV0dXJuIGFwcC5wYW5lbFtwYW5lbFNpZGVdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0ICRwYW5lbEVsID0gJChgLnBhbmVsLSR7cGFuZWxTaWRlfWApO1xuICAgICAgICBpZiAoJHBhbmVsRWwubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHJldHVybiBhcHAucGFuZWwuY3JlYXRlKHsgZWw6ICRwYW5lbEVsIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9LFxuICAgIH0pO1xuICB9LFxuICBvbjoge1xuICAgIGluaXQoKSB7XG4gICAgICBjb25zdCBhcHAgPSB0aGlzO1xuXG4gICAgICAvLyBDcmVhdGUgUGFuZWxzXG4gICAgICAkKCcucGFuZWwnKS5lYWNoKChpbmRleCwgcGFuZWxFbCkgPT4ge1xuICAgICAgICBjb25zdCBzaWRlID0gJChwYW5lbEVsKS5oYXNDbGFzcygncGFuZWwtbGVmdCcpID8gJ2xlZnQnIDogJ3JpZ2h0JztcbiAgICAgICAgYXBwLnBhbmVsW3NpZGVdID0gYXBwLnBhbmVsLmNyZWF0ZSh7IGVsOiBwYW5lbEVsLCBzaWRlIH0pO1xuICAgICAgfSk7XG4gICAgfSxcbiAgfSxcbiAgY2xpY2tzOiB7XG4gICAgJy5wYW5lbC1vcGVuJzogZnVuY3Rpb24gb3BlbihjbGlja2VkRWwsIGRhdGEgPSB7fSkge1xuICAgICAgY29uc3QgYXBwID0gdGhpcztcbiAgICAgIGxldCBzaWRlID0gJ2xlZnQnO1xuICAgICAgaWYgKGRhdGEucGFuZWwgPT09ICdyaWdodCcgfHwgKCQoJy5wYW5lbCcpLmxlbmd0aCA9PT0gMSAmJiAkKCcucGFuZWwnKS5oYXNDbGFzcygncGFuZWwtcmlnaHQnKSkpIHtcbiAgICAgICAgc2lkZSA9ICdyaWdodCc7XG4gICAgICB9XG4gICAgICBhcHAucGFuZWwub3BlbihzaWRlLCBkYXRhLmFuaW1hdGUpO1xuICAgIH0sXG4gICAgJy5wYW5lbC1jbG9zZSc6IGZ1bmN0aW9uIGNsb3NlKGNsaWNrZWRFbCwgZGF0YSA9IHt9KSB7XG4gICAgICBjb25zdCBhcHAgPSB0aGlzO1xuICAgICAgY29uc3Qgc2lkZSA9IGRhdGEucGFuZWw7XG4gICAgICBhcHAucGFuZWwuY2xvc2Uoc2lkZSwgZGF0YS5hbmltYXRlKTtcbiAgICB9LFxuICAgICcucGFuZWwtYmFja2Ryb3AnOiBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICAgIGNvbnN0IGFwcCA9IHRoaXM7XG4gICAgICBjb25zdCAkcGFuZWxFbCA9ICQoJy5wYW5lbC1hY3RpdmUnKTtcbiAgICAgIGNvbnN0IGluc3RhbmNlID0gJHBhbmVsRWxbMF0gJiYgJHBhbmVsRWxbMF0uZjdQYW5lbDtcbiAgICAgICRwYW5lbEVsLnRyaWdnZXIoJ3BhbmVsOmJhY2tkcm9wLWNsaWNrJyk7XG4gICAgICBpZiAoaW5zdGFuY2UpIHtcbiAgICAgICAgaW5zdGFuY2UuZW1pdCgnYmFja2Ryb3BDbGljaycsIGluc3RhbmNlKTtcbiAgICAgIH1cbiAgICAgIGFwcC5lbWl0KCdwYW5lbEJhY2tkcm9wQ2xpY2snLCBpbnN0YW5jZSB8fCAkcGFuZWxFbFswXSk7XG4gICAgICBpZiAoYXBwLnBhcmFtcy5wYW5lbC5jbG9zZUJ5QmFja2Ryb3BDbGljaykgYXBwLnBhbmVsLmNsb3NlKCk7XG4gICAgfSxcbiAgfSxcbn07XG5cbnZhciBDYXJkID0ge1xuICBuYW1lOiAnY2FyZCcsXG59O1xuXG52YXIgQ2hpcCA9IHtcbiAgbmFtZTogJ2NoaXAnLFxufTtcblxuLy8gRm9ybSBEYXRhXG5jb25zdCBGb3JtRGF0YSQxID0ge1xuICBzdG9yZShmb3JtLCBkYXRhKSB7XG4gICAgY29uc3QgYXBwID0gdGhpcztcbiAgICBsZXQgZm9ybUlkID0gZm9ybTtcblxuICAgIGNvbnN0ICRmb3JtRWwgPSAkKGZvcm0pO1xuICAgIGlmICgkZm9ybUVsLmxlbmd0aCAmJiAkZm9ybUVsLmlzKCdmb3JtJykgJiYgJGZvcm1FbC5hdHRyKCdpZCcpKSB7XG4gICAgICBmb3JtSWQgPSAkZm9ybUVsLmF0dHIoJ2lkJyk7XG4gICAgfVxuICAgIC8vIFN0b3JlIGZvcm0gZGF0YSBpbiBhcHAuZm9ybXNEYXRhXG4gICAgYXBwLmZvcm0uZGF0YVtgZm9ybS0ke2Zvcm1JZH1gXSA9IGRhdGE7XG5cbiAgICAvLyBTdG9yZSBmb3JtIGRhdGEgaW4gbG9jYWwgc3RvcmFnZSBhbHNvXG4gICAgdHJ5IHtcbiAgICAgIHdpbmRvdyQxLmxvY2FsU3RvcmFnZVtgZjdmb3JtLSR7Zm9ybUlkfWBdID0gSlNPTi5zdHJpbmdpZnkoZGF0YSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gIH0sXG4gIGdldChmb3JtKSB7XG4gICAgY29uc3QgYXBwID0gdGhpcztcbiAgICBsZXQgZm9ybUlkID0gZm9ybTtcblxuICAgIGNvbnN0ICRmb3JtRWwgPSAkKGZvcm0pO1xuICAgIGlmICgkZm9ybUVsLmxlbmd0aCAmJiAkZm9ybUVsLmlzKCdmb3JtJykgJiYgJGZvcm1FbC5hdHRyKCdpZCcpKSB7XG4gICAgICBmb3JtSWQgPSAkZm9ybUVsLmF0dHIoJ2lkJyk7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGlmICh3aW5kb3ckMS5sb2NhbFN0b3JhZ2VbYGY3Zm9ybS0ke2Zvcm1JZH1gXSkge1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZSh3aW5kb3ckMS5sb2NhbFN0b3JhZ2VbYGY3Zm9ybS0ke2Zvcm1JZH1gXSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gICAgaWYgKGFwcC5mb3JtLmRhdGFbYGZvcm0tJHtmb3JtSWR9YF0pIHtcbiAgICAgIHJldHVybiBhcHAuZm9ybS5kYXRhW2Bmb3JtLSR7Zm9ybUlkfWBdO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9LFxuICByZW1vdmUoZm9ybSkge1xuICAgIGNvbnN0IGFwcCA9IHRoaXM7XG4gICAgbGV0IGZvcm1JZCA9IGZvcm07XG5cbiAgICBjb25zdCAkZm9ybUVsID0gJChmb3JtKTtcbiAgICBpZiAoJGZvcm1FbC5sZW5ndGggJiYgJGZvcm1FbC5pcygnZm9ybScpICYmICRmb3JtRWwuYXR0cignaWQnKSkge1xuICAgICAgZm9ybUlkID0gJGZvcm1FbC5hdHRyKCdpZCcpO1xuICAgIH1cblxuICAgIC8vIERlbGV0ZSBmb3JtIGRhdGEgZnJvbSBhcHAuZm9ybXNEYXRhXG4gICAgaWYgKGFwcC5mb3JtLmRhdGFbYGZvcm0tJHtmb3JtSWR9YF0pIHtcbiAgICAgIGFwcC5mb3JtLmRhdGFbYGZvcm0tJHtmb3JtSWR9YF0gPSAnJztcbiAgICAgIGRlbGV0ZSBhcHAuZm9ybS5kYXRhW2Bmb3JtLSR7Zm9ybUlkfWBdO1xuICAgIH1cblxuICAgIC8vIERlbGV0ZSBmb3JtIGRhdGEgZnJvbSBsb2NhbCBzdG9yYWdlIGFsc29cbiAgICB0cnkge1xuICAgICAgaWYgKHdpbmRvdyQxLmxvY2FsU3RvcmFnZVtgZjdmb3JtLSR7Zm9ybUlkfWBdKSB7XG4gICAgICAgIHdpbmRvdyQxLmxvY2FsU3RvcmFnZVtgZjdmb3JtLSR7Zm9ybUlkfWBdID0gJyc7XG4gICAgICAgIHdpbmRvdyQxLmxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKGBmN2Zvcm0tJHtmb3JtSWR9YCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gIH0sXG59O1xuXG4vLyBGb3JtIFN0b3JhZ2VcbmNvbnN0IEZvcm1TdG9yYWdlID0ge1xuICBpbml0KGZvcm1FbCkge1xuICAgIGNvbnN0IGFwcCA9IHRoaXM7XG4gICAgY29uc3QgJGZvcm1FbCA9ICQoZm9ybUVsKTtcbiAgICBjb25zdCBmb3JtSWQgPSAkZm9ybUVsLmF0dHIoJ2lkJyk7XG4gICAgaWYgKCFmb3JtSWQpIHJldHVybjtcbiAgICBjb25zdCBpbml0aWFsRGF0YSA9IGFwcC5mb3JtLmdldEZvcm1EYXRhKGZvcm1JZCk7XG4gICAgaWYgKGluaXRpYWxEYXRhKSB7XG4gICAgICBhcHAuZm9ybS5maWxsRnJvbURhdGEoJGZvcm1FbCwgaW5pdGlhbERhdGEpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzdG9yZSgpIHtcbiAgICAgIGNvbnN0IGRhdGEgPSBhcHAuZm9ybS5jb252ZXJ0VG9EYXRhKCRmb3JtRWwpO1xuICAgICAgaWYgKCFkYXRhKSByZXR1cm47XG4gICAgICBhcHAuZm9ybS5zdG9yZUZvcm1EYXRhKGZvcm1JZCwgZGF0YSk7XG4gICAgICAkZm9ybUVsLnRyaWdnZXIoJ2Zvcm06c3RvcmVkYXRhJywgZGF0YSk7XG4gICAgICBhcHAuZW1pdCgnZm9ybVN0b3JlRGF0YScsICRmb3JtRWxbMF0sIGRhdGEpO1xuICAgIH1cbiAgICAkZm9ybUVsLm9uKCdjaGFuZ2Ugc3VibWl0Jywgc3RvcmUpO1xuICB9LFxuICBkZXN0cm95KGZvcm1FbCkge1xuICAgIGNvbnN0ICRmb3JtRWwgPSAkKGZvcm1FbCk7XG4gICAgJGZvcm1FbC5vZmYoJ2NoYW5nZSBzdWJtaXQnKTtcbiAgfSxcbn07XG5cbi8vIEZvcm0gVG8vRnJvbSBEYXRhXG5mdW5jdGlvbiBmb3JtVG9EYXRhKGZvcm1FbCkge1xuICBjb25zdCBhcHAgPSB0aGlzO1xuICBjb25zdCAkZm9ybUVsID0gJChmb3JtRWwpLmVxKDApO1xuICBpZiAoJGZvcm1FbC5sZW5ndGggPT09IDApIHJldHVybiB1bmRlZmluZWQ7XG5cbiAgLy8gRm9ybSBkYXRhXG4gIGNvbnN0IGRhdGEgPSB7fTtcblxuICAvLyBTa2lwIGlucHV0IHR5cGVzXG4gIGNvbnN0IHNraXBUeXBlcyA9IFsnc3VibWl0JywgJ2ltYWdlJywgJ2J1dHRvbicsICdmaWxlJ107XG4gIGNvbnN0IHNraXBOYW1lcyA9IFtdO1xuICAkZm9ybUVsLmZpbmQoJ2lucHV0LCBzZWxlY3QsIHRleHRhcmVhJykuZWFjaCgoaW5wdXRJbmRleCwgaW5wdXRFbCkgPT4ge1xuICAgIGNvbnN0ICRpbnB1dEVsID0gJChpbnB1dEVsKTtcbiAgICBpZiAoJGlucHV0RWwuaGFzQ2xhc3MoJ2lnbm9yZS1zdG9yZS1kYXRhJykgfHwgJGlucHV0RWwuaGFzQ2xhc3MoJ25vLXN0b3JlLWRhdGEnKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBuYW1lID0gJGlucHV0RWwuYXR0cignbmFtZScpO1xuICAgIGNvbnN0IHR5cGUgPSAkaW5wdXRFbC5hdHRyKCd0eXBlJyk7XG4gICAgY29uc3QgdGFnID0gaW5wdXRFbC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChza2lwVHlwZXMuaW5kZXhPZih0eXBlKSA+PSAwKSByZXR1cm47XG4gICAgaWYgKHNraXBOYW1lcy5pbmRleE9mKG5hbWUpID49IDAgfHwgIW5hbWUpIHJldHVybjtcbiAgICBpZiAodGFnID09PSAnc2VsZWN0JyAmJiAkaW5wdXRFbC5wcm9wKCdtdWx0aXBsZScpKSB7XG4gICAgICBza2lwTmFtZXMucHVzaChuYW1lKTtcbiAgICAgIGRhdGFbbmFtZV0gPSBbXTtcbiAgICAgICRmb3JtRWwuZmluZChgc2VsZWN0W25hbWU9XCIke25hbWV9XCJdIG9wdGlvbmApLmVhY2goKGluZGV4LCBlbCkgPT4ge1xuICAgICAgICBpZiAoZWwuc2VsZWN0ZWQpIGRhdGFbbmFtZV0ucHVzaChlbC52YWx1ZSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgJ2NoZWNrYm94JzpcbiAgICAgICAgICBza2lwTmFtZXMucHVzaChuYW1lKTtcbiAgICAgICAgICBkYXRhW25hbWVdID0gW107XG4gICAgICAgICAgJGZvcm1FbC5maW5kKGBpbnB1dFtuYW1lPVwiJHtuYW1lfVwiXWApLmVhY2goKGluZGV4LCBlbCkgPT4ge1xuICAgICAgICAgICAgaWYgKGVsLmNoZWNrZWQpIGRhdGFbbmFtZV0ucHVzaChlbC52YWx1ZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3JhZGlvJzpcbiAgICAgICAgICBza2lwTmFtZXMucHVzaChuYW1lKTtcbiAgICAgICAgICAkZm9ybUVsLmZpbmQoYGlucHV0W25hbWU9XCIke25hbWV9XCJdYCkuZWFjaCgoaW5kZXgsIGVsKSA9PiB7XG4gICAgICAgICAgICBpZiAoZWwuY2hlY2tlZCkgZGF0YVtuYW1lXSA9IGVsLnZhbHVlO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGRhdGFbbmFtZV0gPSAkaW5wdXRFbC52YWwoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICAkZm9ybUVsLnRyaWdnZXIoJ2Zvcm06dG9kYXRhJywgZGF0YSk7XG4gIGFwcC5lbWl0KCdmb3JtVG9EYXRhJywgJGZvcm1FbFswXSwgZGF0YSk7XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5mdW5jdGlvbiBmb3JtRnJvbURhdGEoZm9ybUVsLCBmb3JtRGF0YSkge1xuICBjb25zdCBhcHAgPSB0aGlzO1xuICBjb25zdCAkZm9ybUVsID0gJChmb3JtRWwpLmVxKDApO1xuICBpZiAoISRmb3JtRWwubGVuZ3RoKSByZXR1cm47XG5cbiAgbGV0IGRhdGEgPSBmb3JtRGF0YTtcbiAgY29uc3QgZm9ybUlkID0gJGZvcm1FbC5hdHRyKCdpZCcpO1xuXG4gIGlmICghZGF0YSAmJiBmb3JtSWQpIHtcbiAgICBkYXRhID0gYXBwLmZvcm0uZ2V0Rm9ybURhdGEoZm9ybUlkKTtcbiAgfVxuXG4gIGlmICghZGF0YSkgcmV0dXJuO1xuXG4gIC8vIFNraXAgaW5wdXQgdHlwZXNcbiAgY29uc3Qgc2tpcFR5cGVzID0gWydzdWJtaXQnLCAnaW1hZ2UnLCAnYnV0dG9uJywgJ2ZpbGUnXTtcbiAgY29uc3Qgc2tpcE5hbWVzID0gW107XG5cbiAgJGZvcm1FbC5maW5kKCdpbnB1dCwgc2VsZWN0LCB0ZXh0YXJlYScpLmVhY2goKGlucHV0SW5kZXgsIGlucHV0RWwpID0+IHtcbiAgICBjb25zdCAkaW5wdXRFbCA9ICQoaW5wdXRFbCk7XG4gICAgaWYgKCRpbnB1dEVsLmhhc0NsYXNzKCdpZ25vcmUtc3RvcmUtZGF0YScpIHx8ICRpbnB1dEVsLmhhc0NsYXNzKCduby1zdG9yZS1kYXRhJykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbmFtZSA9ICRpbnB1dEVsLmF0dHIoJ25hbWUnKTtcbiAgICBjb25zdCB0eXBlID0gJGlucHV0RWwuYXR0cigndHlwZScpO1xuICAgIGNvbnN0IHRhZyA9IGlucHV0RWwubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAodHlwZW9mIGRhdGFbbmFtZV0gPT09ICd1bmRlZmluZWQnIHx8IGRhdGFbbmFtZV0gPT09IG51bGwpIHJldHVybjtcbiAgICBpZiAoc2tpcFR5cGVzLmluZGV4T2YodHlwZSkgPj0gMCkgcmV0dXJuO1xuICAgIGlmIChza2lwTmFtZXMuaW5kZXhPZihuYW1lKSA+PSAwIHx8ICFuYW1lKSByZXR1cm47XG4gICAgaWYgKHRhZyA9PT0gJ3NlbGVjdCcgJiYgJGlucHV0RWwucHJvcCgnbXVsdGlwbGUnKSkge1xuICAgICAgc2tpcE5hbWVzLnB1c2gobmFtZSk7XG4gICAgICAkZm9ybUVsLmZpbmQoYHNlbGVjdFtuYW1lPVwiJHtuYW1lfVwiXSBvcHRpb25gKS5lYWNoKChpbmRleCwgZWwpID0+IHtcbiAgICAgICAgY29uc3Qgc2VsZWN0RWwgPSBlbDtcbiAgICAgICAgaWYgKGRhdGFbbmFtZV0uaW5kZXhPZihlbC52YWx1ZSkgPj0gMCkgc2VsZWN0RWwuc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICBlbHNlIHNlbGVjdEVsLnNlbGVjdGVkID0gZmFsc2U7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgJ2NoZWNrYm94JzpcbiAgICAgICAgICBza2lwTmFtZXMucHVzaChuYW1lKTtcbiAgICAgICAgICAkZm9ybUVsLmZpbmQoYGlucHV0W25hbWU9XCIke25hbWV9XCJdYCkuZWFjaCgoaW5kZXgsIGVsKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjaGVja2JveEVsID0gZWw7XG4gICAgICAgICAgICBpZiAoZGF0YVtuYW1lXS5pbmRleE9mKGVsLnZhbHVlKSA+PSAwKSBjaGVja2JveEVsLmNoZWNrZWQgPSB0cnVlO1xuICAgICAgICAgICAgZWxzZSBjaGVja2JveEVsLmNoZWNrZWQgPSBmYWxzZTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAncmFkaW8nOlxuICAgICAgICAgIHNraXBOYW1lcy5wdXNoKG5hbWUpO1xuICAgICAgICAgICRmb3JtRWwuZmluZChgaW5wdXRbbmFtZT1cIiR7bmFtZX1cIl1gKS5lYWNoKChpbmRleCwgZWwpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJhZGlvRWwgPSBlbDtcbiAgICAgICAgICAgIGlmIChkYXRhW25hbWVdID09PSBlbC52YWx1ZSkgcmFkaW9FbC5jaGVja2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIGVsc2UgcmFkaW9FbC5jaGVja2VkID0gZmFsc2U7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgJGlucHV0RWwudmFsKGRhdGFbbmFtZV0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGFnID09PSAnc2VsZWN0JyB8fCB0YWcgPT09ICdpbnB1dCcgfHwgdGFnID09PSAndGV4dGFyZWEnKSB7XG4gICAgICAkaW5wdXRFbC50cmlnZ2VyKCdjaGFuZ2UnLCAnZnJvbWRhdGEnKTtcbiAgICB9XG4gIH0pO1xuICAkZm9ybUVsLnRyaWdnZXIoJ2Zvcm06ZnJvbWRhdGEnLCBkYXRhKTtcbiAgYXBwLmVtaXQoJ2Zvcm1Gcm9tRGF0YScsICRmb3JtRWxbMF0sIGRhdGEpO1xufVxuXG5mdW5jdGlvbiBpbml0QWpheEZvcm0oKSB7XG4gIGNvbnN0IGFwcCA9IHRoaXM7XG5cbiAgZnVuY3Rpb24gb25TdWJtaXRDaGFuZ2UoZSwgZnJvbURhdGEpIHtcbiAgICBjb25zdCAkZm9ybUVsID0gJCh0aGlzKTtcbiAgICBpZiAoZS50eXBlID09PSAnY2hhbmdlJyAmJiAhJGZvcm1FbC5oYXNDbGFzcygnZm9ybS1hamF4LXN1Ym1pdC1vbmNoYW5nZScpKSByZXR1cm47XG4gICAgaWYgKGUudHlwZSA9PT0gJ3N1Ym1pdCcpIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgIGlmIChlLnR5cGUgPT09ICdjaGFuZ2UnICYmIGZyb21EYXRhID09PSAnZnJvbWRhdGEnKSByZXR1cm47XG5cbiAgICBjb25zdCBtZXRob2QgPSAoJGZvcm1FbC5hdHRyKCdtZXRob2QnKSB8fCAnR0VUJykudG9VcHBlckNhc2UoKTtcbiAgICBjb25zdCBjb250ZW50VHlwZSA9ICRmb3JtRWwucHJvcCgnZW5jdHlwZScpIHx8ICRmb3JtRWwuYXR0cignZW5jdHlwZScpO1xuXG4gICAgY29uc3QgdXJsID0gJGZvcm1FbC5hdHRyKCdhY3Rpb24nKTtcbiAgICBpZiAoIXVybCkgcmV0dXJuO1xuXG4gICAgbGV0IGRhdGE7XG4gICAgaWYgKG1ldGhvZCA9PT0gJ1BPU1QnKSB7XG4gICAgICBpZiAoY29udGVudFR5cGUgPT09ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnKSB7XG4gICAgICAgIGRhdGEgPSBhcHAuZm9ybS5jb252ZXJ0VG9EYXRhKCRmb3JtRWxbMF0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF0YSA9IG5ldyB3aW5kb3ckMS5Gb3JtRGF0YSgkZm9ybUVsWzBdKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZGF0YSA9IFV0aWxzLnNlcmlhbGl6ZU9iamVjdChhcHAuZm9ybS5jb252ZXJ0VG9EYXRhKCRmb3JtRWxbMF0pKTtcbiAgICB9XG5cbiAgICBjb25zdCB4aHIgPSBhcHAucmVxdWVzdCh7XG4gICAgICBtZXRob2QsXG4gICAgICB1cmwsXG4gICAgICBjb250ZW50VHlwZSxcbiAgICAgIGRhdGEsXG4gICAgICBiZWZvcmVTZW5kKCkge1xuICAgICAgICAkZm9ybUVsLnRyaWdnZXIoJ2Zvcm1hamF4OmJlZm9yZXNlbmQnLCBkYXRhLCB4aHIpO1xuICAgICAgICBhcHAuZW1pdCgnZm9ybUFqYXhCZWZvcmVTZW5kJywgJGZvcm1FbFswXSwgZGF0YSwgeGhyKTtcbiAgICAgIH0sXG4gICAgICBlcnJvcigpIHtcbiAgICAgICAgJGZvcm1FbC50cmlnZ2VyKCdmb3JtYWpheDplcnJvcicsIGRhdGEsIHhocik7XG4gICAgICAgIGFwcC5lbWl0KCdmb3JtQWpheEVycm9yJywgJGZvcm1FbFswXSwgZGF0YSwgeGhyKTtcbiAgICAgIH0sXG4gICAgICBjb21wbGV0ZSgpIHtcbiAgICAgICAgJGZvcm1FbC50cmlnZ2VyKCdmb3JtYWpheDpjb21wbGV0ZScsIGRhdGEsIHhocik7XG4gICAgICAgIGFwcC5lbWl0KCdmb3JtQWpheENvbXBsZXRlJywgJGZvcm1FbFswXSwgZGF0YSwgeGhyKTtcbiAgICAgIH0sXG4gICAgICBzdWNjZXNzKCkge1xuICAgICAgICAkZm9ybUVsLnRyaWdnZXIoJ2Zvcm1hamF4OnN1Y2Nlc3MnLCBkYXRhLCB4aHIpO1xuICAgICAgICBhcHAuZW1pdCgnZm9ybUFqYXhTdWNjZXNzJywgJGZvcm1FbFswXSwgZGF0YSwgeGhyKTtcbiAgICAgIH0sXG4gICAgfSk7XG4gIH1cbiAgJChkb2N1bWVudCkub24oJ3N1Ym1pdCBjaGFuZ2UnLCAnZm9ybS5mb3JtLWFqYXgtc3VibWl0LCBmb3JtLmZvcm0tYWpheC1zdWJtaXQtb25jaGFuZ2UnLCBvblN1Ym1pdENoYW5nZSk7XG59XG5cbnZhciBGb3JtID0ge1xuICBuYW1lOiAnZm9ybScsXG4gIGNyZWF0ZSgpIHtcbiAgICBjb25zdCBhcHAgPSB0aGlzO1xuICAgIFV0aWxzLmV4dGVuZChhcHAsIHtcbiAgICAgIGZvcm06IHtcbiAgICAgICAgZGF0YToge30sXG4gICAgICAgIHN0b3JlRm9ybURhdGE6IEZvcm1EYXRhJDEuc3RvcmUuYmluZChhcHApLFxuICAgICAgICBnZXRGb3JtRGF0YTogRm9ybURhdGEkMS5nZXQuYmluZChhcHApLFxuICAgICAgICByZW1vdmVGb3JtRGF0YTogRm9ybURhdGEkMS5yZW1vdmUuYmluZChhcHApLFxuICAgICAgICBjb252ZXJ0VG9EYXRhOiBmb3JtVG9EYXRhLmJpbmQoYXBwKSxcbiAgICAgICAgZmlsbEZyb21EYXRhOiBmb3JtRnJvbURhdGEuYmluZChhcHApLFxuICAgICAgICBzdG9yYWdlOiB7XG4gICAgICAgICAgaW5pdDogRm9ybVN0b3JhZ2UuaW5pdC5iaW5kKGFwcCksXG4gICAgICAgICAgZGVzdHJveTogRm9ybVN0b3JhZ2UuZGVzdHJveS5iaW5kKGFwcCksXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIH0pO1xuICB9LFxuICBvbjoge1xuICAgIGluaXQoKSB7XG4gICAgICBjb25zdCBhcHAgPSB0aGlzO1xuICAgICAgaW5pdEFqYXhGb3JtLmNhbGwoYXBwKTtcbiAgICB9LFxuICAgIHRhYkJlZm9yZVJlbW92ZSh0YWJFbCkge1xuICAgICAgY29uc3QgYXBwID0gdGhpcztcbiAgICAgICQodGFiRWwpLmZpbmQoJy5mb3JtLXN0b3JlLWRhdGEnKS5lYWNoKChpbmRleCwgZm9ybUVsKSA9PiB7XG4gICAgICAgIGFwcC5mb3JtLnN0b3JhZ2UuZGVzdHJveShmb3JtRWwpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICB0YWJNb3VudGVkKHRhYkVsKSB7XG4gICAgICBjb25zdCBhcHAgPSB0aGlzO1xuICAgICAgJCh0YWJFbCkuZmluZCgnLmZvcm0tc3RvcmUtZGF0YScpLmVhY2goKGluZGV4LCBmb3JtRWwpID0+IHtcbiAgICAgICAgYXBwLmZvcm0uc3RvcmFnZS5pbml0KGZvcm1FbCk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIHBhZ2VCZWZvcmVSZW1vdmUocGFnZSkge1xuICAgICAgY29uc3QgYXBwID0gdGhpcztcbiAgICAgIHBhZ2UuJGVsLmZpbmQoJy5mb3JtLXN0b3JlLWRhdGEnKS5lYWNoKChpbmRleCwgZm9ybUVsKSA9PiB7XG4gICAgICAgIGFwcC5mb3JtLnN0b3JhZ2UuZGVzdHJveShmb3JtRWwpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBwYWdlSW5pdChwYWdlKSB7XG4gICAgICBjb25zdCBhcHAgPSB0aGlzO1xuICAgICAgcGFnZS4kZWwuZmluZCgnLmZvcm0tc3RvcmUtZGF0YScpLmVhY2goKGluZGV4LCBmb3JtRWwpID0+IHtcbiAgICAgICAgYXBwLmZvcm0uc3RvcmFnZS5pbml0KGZvcm1FbCk7XG4gICAgICB9KTtcbiAgICB9LFxuICB9LFxufTtcblxuY29uc3QgSW5wdXQgPSB7XG4gIGlnbm9yZVR5cGVzOiBbJ2NoZWNrYm94JywgJ2J1dHRvbicsICdzdWJtaXQnLCAncmFuZ2UnLCAncmFkaW8nLCAnaW1hZ2UnXSxcbiAgY3JlYXRlVGV4dGFyZWFSZXNpemFibGVTaGFkb3coKSB7XG4gICAgY29uc3QgJHNoYWRvd0VsID0gJChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZXh0YXJlYScpKTtcbiAgICAkc2hhZG93RWwuYWRkQ2xhc3MoJ3RleHRhcmVhLXJlc2l6YWJsZS1zaGFkb3cnKTtcbiAgICAkc2hhZG93RWwucHJvcCh7XG4gICAgICBkaXNhYmxlZDogdHJ1ZSxcbiAgICAgIHJlYWRvbmx5OiB0cnVlLFxuICAgIH0pO1xuICAgIElucHV0LnRleHRhcmVhUmVzaXphYmxlU2hhZG93ID0gJHNoYWRvd0VsO1xuICB9LFxuICB0ZXh0YXJlYVJlc2l6YWJsZVNoYWRvdzogdW5kZWZpbmVkLFxuICByZXNpemVUZXh0YXJlYSh0ZXh0YXJlYUVsKSB7XG4gICAgY29uc3QgYXBwID0gdGhpcztcbiAgICBjb25zdCAkdGV4dGFyZWFFbCA9ICQodGV4dGFyZWFFbCk7XG4gICAgaWYgKCFJbnB1dC50ZXh0YXJlYVJlc2l6YWJsZVNoYWRvdykge1xuICAgICAgSW5wdXQuY3JlYXRlVGV4dGFyZWFSZXNpemFibGVTaGFkb3coKTtcbiAgICB9XG4gICAgY29uc3QgJHNoYWRvd0VsID0gSW5wdXQudGV4dGFyZWFSZXNpemFibGVTaGFkb3c7XG4gICAgaWYgKCEkdGV4dGFyZWFFbC5sZW5ndGgpIHJldHVybjtcbiAgICBpZiAoISR0ZXh0YXJlYUVsLmhhc0NsYXNzKCdyZXNpemFibGUnKSkgcmV0dXJuO1xuICAgIGlmIChJbnB1dC50ZXh0YXJlYVJlc2l6YWJsZVNoYWRvdy5wYXJlbnRzKCkubGVuZ3RoID09PSAwKSB7XG4gICAgICBhcHAucm9vdC5hcHBlbmQoJHNoYWRvd0VsKTtcbiAgICB9XG5cbiAgICBjb25zdCBzdHlsZXMgPSB3aW5kb3ckMS5nZXRDb21wdXRlZFN0eWxlKCR0ZXh0YXJlYUVsWzBdKTtcbiAgICAoJ3BhZGRpbmcgbWFyZ2luIHdpZHRoIGZvbnQtc2l6ZSBmb250LWZhbWlseSBmb250LXN0eWxlIGZvbnQtd2VpZ2h0IGxpbmUtaGVpZ2h0IGZvbnQtdmFyaWFudCB0ZXh0LXRyYW5zZm9ybSBsZXR0ZXItc3BhY2luZyBib3JkZXIgYm94LXNpemluZyBkaXNwbGF5Jykuc3BsaXQoJyAnKS5mb3JFYWNoKChzdHlsZSkgPT4ge1xuICAgICAgbGV0IHN0eWxlVmFsdWUgPSBzdHlsZXNbc3R5bGVdO1xuICAgICAgaWYgKCgnZm9udC1zaXplIGxpbmUtaGVpZ2h0IGxldHRlci1zcGFjaW5nIHdpZHRoJykuc3BsaXQoJyAnKS5pbmRleE9mKHN0eWxlKSA+PSAwKSB7XG4gICAgICAgIHN0eWxlVmFsdWUgPSBzdHlsZVZhbHVlLnJlcGxhY2UoJywnLCAnLicpO1xuICAgICAgfVxuICAgICAgJHNoYWRvd0VsLmNzcyhzdHlsZSwgc3R5bGVWYWx1ZSk7XG4gICAgfSk7XG4gICAgY29uc3QgY3VycmVudEhlaWdodCA9ICR0ZXh0YXJlYUVsWzBdLmNsaWVudEhlaWdodDtcblxuICAgICRzaGFkb3dFbC52YWwoJycpO1xuICAgIGNvbnN0IGluaXRpYWxIZWlnaHQgPSAkc2hhZG93RWxbMF0uc2Nyb2xsSGVpZ2h0O1xuXG4gICAgJHNoYWRvd0VsLnZhbCgkdGV4dGFyZWFFbC52YWwoKSk7XG4gICAgJHNoYWRvd0VsLmNzcygnaGVpZ2h0JywgMCk7XG4gICAgY29uc3Qgc2Nyb2xsSGVpZ2h0ID0gJHNoYWRvd0VsWzBdLnNjcm9sbEhlaWdodDtcblxuICAgIGlmIChjdXJyZW50SGVpZ2h0ICE9PSBzY3JvbGxIZWlnaHQpIHtcbiAgICAgIGlmIChzY3JvbGxIZWlnaHQgPiBpbml0aWFsSGVpZ2h0KSB7XG4gICAgICAgICR0ZXh0YXJlYUVsLmNzcygnaGVpZ2h0JywgYCR7c2Nyb2xsSGVpZ2h0fXB4YCk7XG4gICAgICAgICR0ZXh0YXJlYUVsLnRyaWdnZXIoJ3RleHRhcmVhOnJlc2l6ZScsIHsgaW5pdGlhbEhlaWdodCwgY3VycmVudEhlaWdodCwgc2Nyb2xsSGVpZ2h0IH0pO1xuICAgICAgfSBlbHNlIGlmIChzY3JvbGxIZWlnaHQgPCBjdXJyZW50SGVpZ2h0KSB7XG4gICAgICAgICR0ZXh0YXJlYUVsLmNzcygnaGVpZ2h0JywgJycpO1xuICAgICAgICAkdGV4dGFyZWFFbC50cmlnZ2VyKCd0ZXh0YXJlYTpyZXNpemUnLCB7IGluaXRpYWxIZWlnaHQsIGN1cnJlbnRIZWlnaHQsIHNjcm9sbEhlaWdodCB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHZhbGlkYXRlKGlucHV0RWwpIHtcbiAgICBjb25zdCAkaW5wdXRFbCA9ICQoaW5wdXRFbCk7XG4gICAgaWYgKCEkaW5wdXRFbC5sZW5ndGgpIHJldHVybjtcbiAgICBjb25zdCAkaXRlbUlucHV0RWwgPSAkaW5wdXRFbC5wYXJlbnRzKCcuaXRlbS1pbnB1dCcpO1xuICAgIGNvbnN0ICRpbnB1dFdyYXBFbCA9ICRpbnB1dEVsLnBhcmVudHMoJy5pbnB1dCcpO1xuICAgIGNvbnN0IHZhbGlkaXR5ID0gJGlucHV0RWxbMF0udmFsaWRpdHk7XG4gICAgY29uc3QgdmFsaWRhdGlvbk1lc3NhZ2UgPSAkaW5wdXRFbC5kYXRhc2V0KCkuZXJyb3JNZXNzYWdlIHx8ICRpbnB1dEVsWzBdLnZhbGlkYXRpb25NZXNzYWdlIHx8ICcnO1xuICAgIGlmICghdmFsaWRpdHkpIHJldHVybjtcbiAgICBpZiAoIXZhbGlkaXR5LnZhbGlkKSB7XG4gICAgICBsZXQgJGVycm9yRWwgPSAkaW5wdXRFbC5uZXh0QWxsKCcuaXRlbS1pbnB1dC1lcnJvci1tZXNzYWdlLCAuaW5wdXQtZXJyb3ItbWVzc2FnZScpO1xuICAgICAgaWYgKHZhbGlkYXRpb25NZXNzYWdlKSB7XG4gICAgICAgIGlmICgkZXJyb3JFbC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAkZXJyb3JFbCA9ICQoYDxkaXYgY2xhc3M9XCIkeyRpbnB1dFdyYXBFbC5sZW5ndGggPyAnaW5wdXQtZXJyb3ItbWVzc2FnZScgOiAnaXRlbS1pbnB1dC1lcnJvci1tZXNzYWdlJ31cIj48L2Rpdj5gKTtcbiAgICAgICAgICAkZXJyb3JFbC5pbnNlcnRBZnRlcigkaW5wdXRFbCk7XG4gICAgICAgIH1cbiAgICAgICAgJGVycm9yRWwudGV4dCh2YWxpZGF0aW9uTWVzc2FnZSk7XG4gICAgICB9XG4gICAgICBpZiAoJGVycm9yRWwubGVuZ3RoID4gMCkge1xuICAgICAgICAkaXRlbUlucHV0RWwuYWRkQ2xhc3MoJ2l0ZW0taW5wdXQtd2l0aC1lcnJvci1tZXNzYWdlJyk7XG4gICAgICAgICRpbnB1dFdyYXBFbC5hZGRDbGFzcygnaW5wdXQtd2l0aC1lcm9yLW1lc3NhZ2UnKTtcbiAgICAgIH1cbiAgICAgICRpdGVtSW5wdXRFbC5hZGRDbGFzcygnaXRlbS1pbnB1dC1pbnZhbGlkJyk7XG4gICAgICAkaW5wdXRXcmFwRWwuYWRkQ2xhc3MoJ2lucHV0LWludmFsaWQnKTtcbiAgICAgICRpbnB1dEVsLmFkZENsYXNzKCdpbnB1dC1pbnZhbGlkJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICRpdGVtSW5wdXRFbC5yZW1vdmVDbGFzcygnaXRlbS1pbnB1dC1pbnZhbGlkIGl0ZW0taW5wdXQtd2l0aC1lcnJvci1tZXNzYWdlJyk7XG4gICAgICAkaW5wdXRXcmFwRWwucmVtb3ZlQ2xhc3MoJ2lucHV0LWludmFsaWQgaW5wdXQtd2l0aC1lcnJvci1tZXNzYWdlJyk7XG4gICAgICAkaW5wdXRFbC5yZW1vdmVDbGFzcygnaW5wdXQtaW52YWxpZCcpO1xuICAgIH1cbiAgfSxcbiAgdmFsaWRhdGVJbnB1dHMoZWwpIHtcbiAgICBjb25zdCBhcHAgPSB0aGlzO1xuICAgICQoZWwpLmZpbmQoJ2lucHV0LCB0ZXh0YXJlYSwgc2VsZWN0JykuZWFjaCgoaW5kZXgsIGlucHV0RWwpID0+IHtcbiAgICAgIGFwcC5pbnB1dC52YWxpZGF0ZShpbnB1dEVsKTtcbiAgICB9KTtcbiAgfSxcbiAgZm9jdXMoaW5wdXRFbCkge1xuICAgIGNvbnN0ICRpbnB1dEVsID0gJChpbnB1dEVsKTtcbiAgICBjb25zdCB0eXBlID0gJGlucHV0RWwuYXR0cigndHlwZScpO1xuICAgIGlmIChJbnB1dC5pZ25vcmVUeXBlcy5pbmRleE9mKHR5cGUpID49IDApIHJldHVybjtcbiAgICAkaW5wdXRFbC5wYXJlbnRzKCcuaXRlbS1pbnB1dCcpLmFkZENsYXNzKCdpdGVtLWlucHV0LWZvY3VzZWQnKTtcbiAgICAkaW5wdXRFbC5wYXJlbnRzKCcuaW5wdXQnKS5hZGRDbGFzcygnaW5wdXQtZm9jdXNlZCcpO1xuICAgICRpbnB1dEVsLmFkZENsYXNzKCdpbnB1dC1mb2N1c2VkJyk7XG4gIH0sXG4gIGJsdXIoaW5wdXRFbCkge1xuICAgIGNvbnN0ICRpbnB1dEVsID0gJChpbnB1dEVsKTtcbiAgICAkaW5wdXRFbC5wYXJlbnRzKCcuaXRlbS1pbnB1dCcpLnJlbW92ZUNsYXNzKCdpdGVtLWlucHV0LWZvY3VzZWQnKTtcbiAgICAkaW5wdXRFbC5wYXJlbnRzKCcuaW5wdXQnKS5yZW1vdmVDbGFzcygnaW5wdXQtZm9jdXNlZCcpO1xuICAgICRpbnB1dEVsLnJlbW92ZUNsYXNzKCdpbnB1dC1mb2N1c2VkJyk7XG4gIH0sXG4gIGNoZWNrRW1wdHlTdGF0ZShpbnB1dEVsKSB7XG4gICAgY29uc3QgJGlucHV0RWwgPSAkKGlucHV0RWwpO1xuICAgIGNvbnN0IHZhbHVlID0gJGlucHV0RWwudmFsKCk7XG4gICAgY29uc3QgJGl0ZW1JbnB1dEVsID0gJGlucHV0RWwucGFyZW50cygnLml0ZW0taW5wdXQnKTtcbiAgICBjb25zdCAkaW5wdXRXcmFwRWwgPSAkaW5wdXRFbC5wYXJlbnRzKCcuaW5wdXQnKTtcbiAgICBpZiAoKHZhbHVlICYmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHZhbHVlLnRyaW0oKSAhPT0gJycpKSB8fCAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoID4gMCkpIHtcbiAgICAgICRpdGVtSW5wdXRFbC5hZGRDbGFzcygnaXRlbS1pbnB1dC13aXRoLXZhbHVlJyk7XG4gICAgICAkaW5wdXRXcmFwRWwuYWRkQ2xhc3MoJ2lucHV0LXdpdGgtdmFsdWUnKTtcbiAgICAgICRpbnB1dEVsLmFkZENsYXNzKCdpbnB1dC13aXRoLXZhbHVlJyk7XG4gICAgICAkaW5wdXRFbC50cmlnZ2VyKCdpbnB1dDpub3RlbXB0eScpO1xuICAgIH0gZWxzZSB7XG4gICAgICAkaXRlbUlucHV0RWwucmVtb3ZlQ2xhc3MoJ2l0ZW0taW5wdXQtd2l0aC12YWx1ZScpO1xuICAgICAgJGlucHV0V3JhcEVsLnJlbW92ZUNsYXNzKCdpbnB1dC13aXRoLXZhbHVlJyk7XG4gICAgICAkaW5wdXRFbC5yZW1vdmVDbGFzcygnaW5wdXQtd2l0aC12YWx1ZScpO1xuICAgICAgJGlucHV0RWwudHJpZ2dlcignaW5wdXQ6ZW1wdHknKTtcbiAgICB9XG4gIH0sXG4gIHNjcm9sbEludG9WaWV3KGlucHV0RWwsIGR1cmF0aW9uID0gMCwgY2VudGVyZWQpIHtcbiAgICBjb25zdCAkaW5wdXRFbCA9ICQoaW5wdXRFbCk7XG4gICAgY29uc3QgJHNjcm9sbGFibGVFbCA9ICRpbnB1dEVsLnBhcmVudHMoJy5wYWdlLWNvbnRlbnQsIC5wYW5lbCcpLmVxKDApO1xuICAgIGlmICghJHNjcm9sbGFibGVFbC5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgY29udGVudEhlaWdodCA9ICRzY3JvbGxhYmxlRWxbMF0ub2Zmc2V0SGVpZ2h0O1xuICAgIGNvbnN0IGNvbnRlbnRTY3JvbGxUb3AgPSAkc2Nyb2xsYWJsZUVsWzBdLnNjcm9sbFRvcDtcbiAgICBjb25zdCBjb250ZW50UGFkZGluZ1RvcCA9IHBhcnNlSW50KCRzY3JvbGxhYmxlRWwuY3NzKCdwYWRkaW5nLXRvcCcpLCAxMCk7XG4gICAgY29uc3QgY29udGVudFBhZGRpbmdCb3R0b20gPSBwYXJzZUludCgkc2Nyb2xsYWJsZUVsLmNzcygncGFkZGluZy1ib3R0b20nKSwgMTApO1xuICAgIGNvbnN0IGNvbnRlbnRPZmZzZXRUb3AgPSAkc2Nyb2xsYWJsZUVsLm9mZnNldCgpLnRvcCAtIGNvbnRlbnRTY3JvbGxUb3A7XG5cbiAgICBjb25zdCBpbnB1dE9mZnNldFRvcCA9ICRpbnB1dEVsLm9mZnNldCgpLnRvcCAtIGNvbnRlbnRPZmZzZXRUb3A7XG4gICAgY29uc3QgaW5wdXRIZWlnaHQgPSAkaW5wdXRFbFswXS5vZmZzZXRIZWlnaHQ7XG5cbiAgICBjb25zdCBtaW4gPSAoaW5wdXRPZmZzZXRUb3AgKyBjb250ZW50U2Nyb2xsVG9wKSAtIGNvbnRlbnRQYWRkaW5nVG9wO1xuICAgIGNvbnN0IG1heCA9ICgoaW5wdXRPZmZzZXRUb3AgKyBjb250ZW50U2Nyb2xsVG9wKSAtIGNvbnRlbnRIZWlnaHQpICsgY29udGVudFBhZGRpbmdCb3R0b20gKyBpbnB1dEhlaWdodDtcbiAgICBjb25zdCBjZW50ZXJlZFBvc2l0aW9uID0gbWluICsgKChtYXggLSBtaW4pIC8gMik7XG5cbiAgICBpZiAoY29udGVudFNjcm9sbFRvcCA+IG1pbikge1xuICAgICAgJHNjcm9sbGFibGVFbC5zY3JvbGxUb3AoY2VudGVyZWQgPyBjZW50ZXJlZFBvc2l0aW9uIDogbWluLCBkdXJhdGlvbik7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGNvbnRlbnRTY3JvbGxUb3AgPCBtYXgpIHtcbiAgICAgICRzY3JvbGxhYmxlRWwuc2Nyb2xsVG9wKGNlbnRlcmVkID8gY2VudGVyZWRQb3NpdGlvbiA6IG1heCwgZHVyYXRpb24pO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcbiAgaW5pdCgpIHtcbiAgICBjb25zdCBhcHAgPSB0aGlzO1xuICAgIElucHV0LmNyZWF0ZVRleHRhcmVhUmVzaXphYmxlU2hhZG93KCk7XG4gICAgZnVuY3Rpb24gb25Gb2N1cygpIHtcbiAgICAgIGNvbnN0IGlucHV0RWwgPSB0aGlzO1xuICAgICAgaWYgKGFwcC5wYXJhbXMuaW5wdXQuc2Nyb2xsSW50b1ZpZXdPbkZvY3VzKSB7XG4gICAgICAgIGlmIChEZXZpY2UuYW5kcm9pZCkge1xuICAgICAgICAgICQod2luZG93JDEpLm9uY2UoJ3Jlc2l6ZScsICgpID0+IHtcbiAgICAgICAgICAgIGlmIChkb2N1bWVudCAmJiBkb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSBpbnB1dEVsKSB7XG4gICAgICAgICAgICAgIGFwcC5pbnB1dC5zY3JvbGxJbnRvVmlldyhpbnB1dEVsLCAwLCBhcHAucGFyYW1zLmlucHV0LnNjcm9sbEludG9WaWV3Q2VudGVyZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFwcC5pbnB1dC5zY3JvbGxJbnRvVmlldyhpbnB1dEVsLCAwLCBhcHAucGFyYW1zLmlucHV0LnNjcm9sbEludG9WaWV3Q2VudGVyZWQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBhcHAuaW5wdXQuZm9jdXMoaW5wdXRFbCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uQmx1cigpIHtcbiAgICAgIGNvbnN0ICRpbnB1dEVsID0gJCh0aGlzKTtcbiAgICAgIGNvbnN0IHRhZyA9ICRpbnB1dEVsWzBdLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICBhcHAuaW5wdXQuYmx1cigkaW5wdXRFbCk7XG4gICAgICBpZiAoJGlucHV0RWwuZGF0YXNldCgpLnZhbGlkYXRlIHx8ICRpbnB1dEVsLmF0dHIoJ3ZhbGlkYXRlJykgIT09IG51bGwpIHtcbiAgICAgICAgYXBwLmlucHV0LnZhbGlkYXRlKCRpbnB1dEVsKTtcbiAgICAgIH1cbiAgICAgIC8vIFJlc2l6ZSB0ZXh0YXJlYVxuICAgICAgaWYgKHRhZyA9PT0gJ3RleHRhcmVhJyAmJiAkaW5wdXRFbC5oYXNDbGFzcygncmVzaXphYmxlJykpIHtcbiAgICAgICAgaWYgKElucHV0LnRleHRhcmVhUmVzaXphYmxlU2hhZG93KSBJbnB1dC50ZXh0YXJlYVJlc2l6YWJsZVNoYWRvdy5yZW1vdmUoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gb25DaGFuZ2UoKSB7XG4gICAgICBjb25zdCAkaW5wdXRFbCA9ICQodGhpcyk7XG4gICAgICBjb25zdCB0eXBlID0gJGlucHV0RWwuYXR0cigndHlwZScpO1xuICAgICAgY29uc3QgdGFnID0gJGlucHV0RWxbMF0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIGlmIChJbnB1dC5pZ25vcmVUeXBlcy5pbmRleE9mKHR5cGUpID49IDApIHJldHVybjtcblxuICAgICAgLy8gQ2hlY2sgRW1wdHkgU3RhdGVcbiAgICAgIGFwcC5pbnB1dC5jaGVja0VtcHR5U3RhdGUoJGlucHV0RWwpO1xuXG4gICAgICAvLyBDaGVjayB2YWxpZGF0aW9uXG4gICAgICBpZiAoJGlucHV0RWwuZGF0YXNldCgpLnZhbGlkYXRlIHx8ICRpbnB1dEVsLmF0dHIoJ3ZhbGlkYXRlJykgIT09IG51bGwpIHtcbiAgICAgICAgYXBwLmlucHV0LnZhbGlkYXRlKCRpbnB1dEVsKTtcbiAgICAgIH1cblxuICAgICAgLy8gUmVzaXplIHRleHRhcmVhXG4gICAgICBpZiAodGFnID09PSAndGV4dGFyZWEnICYmICRpbnB1dEVsLmhhc0NsYXNzKCdyZXNpemFibGUnKSkge1xuICAgICAgICBhcHAuaW5wdXQucmVzaXplVGV4dGFyZWEoJGlucHV0RWwpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBvbkludmFsaWQoZSkge1xuICAgICAgY29uc3QgJGlucHV0RWwgPSAkKHRoaXMpO1xuICAgICAgaWYgKCRpbnB1dEVsLmRhdGFzZXQoKS52YWxpZGF0ZSB8fCAkaW5wdXRFbC5hdHRyKCd2YWxpZGF0ZScpICE9PSBudWxsKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgYXBwLmlucHV0LnZhbGlkYXRlKCRpbnB1dEVsKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY2xlYXJJbnB1dCgpIHtcbiAgICAgIGNvbnN0ICRjbGlja2VkID0gJCh0aGlzKTtcbiAgICAgIGNvbnN0ICRpbnB1dEVsID0gJGNsaWNrZWQuc2libGluZ3MoJ2lucHV0LCB0ZXh0YXJlYScpLmVxKDApO1xuICAgICAgY29uc3QgcHJldmlvdXNWYWx1ZSA9ICRpbnB1dEVsLnZhbCgpO1xuICAgICAgJGlucHV0RWxcbiAgICAgICAgLnZhbCgnJylcbiAgICAgICAgLnRyaWdnZXIoJ2NoYW5nZScpXG4gICAgICAgIC5mb2N1cygpXG4gICAgICAgIC50cmlnZ2VyKCdpbnB1dDpjbGVhcicsIHByZXZpb3VzVmFsdWUpO1xuICAgIH1cbiAgICAkKGRvY3VtZW50KS5vbignY2xpY2snLCAnLmlucHV0LWNsZWFyLWJ1dHRvbicsIGNsZWFySW5wdXQpO1xuICAgICQoZG9jdW1lbnQpLm9uKCdjaGFuZ2UgaW5wdXQnLCAnaW5wdXQsIHRleHRhcmVhLCBzZWxlY3QnLCBvbkNoYW5nZSwgdHJ1ZSk7XG4gICAgJChkb2N1bWVudCkub24oJ2ZvY3VzJywgJ2lucHV0LCB0ZXh0YXJlYSwgc2VsZWN0Jywgb25Gb2N1cywgdHJ1ZSk7XG4gICAgJChkb2N1bWVudCkub24oJ2JsdXInLCAnaW5wdXQsIHRleHRhcmVhLCBzZWxlY3QnLCBvbkJsdXIsIHRydWUpO1xuICAgICQoZG9jdW1lbnQpLm9uKCdpbnZhbGlkJywgJ2lucHV0LCB0ZXh0YXJlYSwgc2VsZWN0Jywgb25JbnZhbGlkLCB0cnVlKTtcbiAgfSxcbn07XG5cbnZhciBJbnB1dCQxID0ge1xuICBuYW1lOiAnaW5wdXQnLFxuICBwYXJhbXM6IHtcbiAgICBpbnB1dDoge1xuICAgICAgc2Nyb2xsSW50b1ZpZXdPbkZvY3VzOiBEZXZpY2UuYW5kcm9pZCxcbiAgICAgIHNjcm9sbEludG9WaWV3Q2VudGVyZWQ6IGZhbHNlLFxuICAgIH0sXG4gIH0sXG4gIGNyZWF0ZSgpIHtcbiAgICBjb25zdCBhcHAgPSB0aGlzO1xuICAgIFV0aWxzLmV4dGVuZChhcHAsIHtcbiAgICAgIGlucHV0OiB7XG4gICAgICAgIHNjcm9sbEludG9WaWV3OiBJbnB1dC5zY3JvbGxJbnRvVmlldy5iaW5kKGFwcCksXG4gICAgICAgIGZvY3VzOiBJbnB1dC5mb2N1cy5iaW5kKGFwcCksXG4gICAgICAgIGJsdXI6IElucHV0LmJsdXIuYmluZChhcHApLFxuICAgICAgICB2YWxpZGF0ZTogSW5wdXQudmFsaWRhdGUuYmluZChhcHApLFxuICAgICAgICB2YWxpZGF0ZUlucHV0czogSW5wdXQudmFsaWRhdGVJbnB1dHMuYmluZChhcHApLFxuICAgICAgICBjaGVja0VtcHR5U3RhdGU6IElucHV0LmNoZWNrRW1wdHlTdGF0ZS5iaW5kKGFwcCksXG4gICAgICAgIHJlc2l6ZVRleHRhcmVhOiBJbnB1dC5yZXNpemVUZXh0YXJlYS5iaW5kKGFwcCksXG4gICAgICAgIGluaXQ6IElucHV0LmluaXQuYmluZChhcHApLFxuICAgICAgfSxcbiAgICB9KTtcbiAgfSxcbiAgb246IHtcbiAgICBpbml0KCkge1xuICAgICAgY29uc3QgYXBwID0gdGhpcztcbiAgICAgIGFwcC5pbnB1dC5pbml0KCk7XG4gICAgfSxcbiAgICB0YWJNb3VudGVkKHRhYkVsKSB7XG4gICAgICBjb25zdCBhcHAgPSB0aGlzO1xuICAgICAgY29uc3QgJHRhYkVsID0gJCh0YWJFbCk7XG4gICAgICAkdGFiRWwuZmluZCgnLml0ZW0taW5wdXQsIC5pbnB1dCcpLmVhY2goKGl0ZW1JbnB1dEluZGV4LCBpdGVtSW5wdXRFbCkgPT4ge1xuICAgICAgICBjb25zdCAkaXRlbUlucHV0RWwgPSAkKGl0ZW1JbnB1dEVsKTtcbiAgICAgICAgJGl0ZW1JbnB1dEVsLmZpbmQoJ2lucHV0LCBzZWxlY3QsIHRleHRhcmVhJykuZWFjaCgoaW5wdXRJbmRleCwgaW5wdXRFbCkgPT4ge1xuICAgICAgICAgIGNvbnN0ICRpbnB1dEVsID0gJChpbnB1dEVsKTtcbiAgICAgICAgICBpZiAoSW5wdXQuaWdub3JlVHlwZXMuaW5kZXhPZigkaW5wdXRFbC5hdHRyKCd0eXBlJykpID49IDApIHJldHVybjtcbiAgICAgICAgICBhcHAuaW5wdXQuY2hlY2tFbXB0eVN0YXRlKCRpbnB1dEVsKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgICR0YWJFbC5maW5kKCd0ZXh0YXJlYS5yZXNpemFibGUnKS5lYWNoKCh0ZXh0YXJlYUluZGV4LCB0ZXh0YXJlYUVsKSA9PiB7XG4gICAgICAgIGFwcC5pbnB1dC5yZXNpemVUZXh0YXJlYSh0ZXh0YXJlYUVsKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgcGFnZUluaXQocGFnZSkge1xuICAgICAgY29uc3QgYXBwID0gdGhpcztcbiAgICAgIGNvbnN0ICRwYWdlRWwgPSBwYWdlLiRlbDtcbiAgICAgICRwYWdlRWwuZmluZCgnLml0ZW0taW5wdXQsIC5pbnB1dCcpLmVhY2goKGl0ZW1JbnB1dEluZGV4LCBpdGVtSW5wdXRFbCkgPT4ge1xuICAgICAgICBjb25zdCAkaXRlbUlucHV0RWwgPSAkKGl0ZW1JbnB1dEVsKTtcbiAgICAgICAgJGl0ZW1JbnB1dEVsLmZpbmQoJ2lucHV0LCBzZWxlY3QsIHRleHRhcmVhJykuZWFjaCgoaW5wdXRJbmRleCwgaW5wdXRFbCkgPT4ge1xuICAgICAgICAgIGNvbnN0ICRpbnB1dEVsID0gJChpbnB1dEVsKTtcbiAgICAgICAgICBpZiAoSW5wdXQuaWdub3JlVHlwZXMuaW5kZXhPZigkaW5wdXRFbC5hdHRyKCd0eXBlJykpID49IDApIHJldHVybjtcbiAgICAgICAgICBhcHAuaW5wdXQuY2hlY2tFbXB0eVN0YXRlKCRpbnB1dEVsKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgICRwYWdlRWwuZmluZCgndGV4dGFyZWEucmVzaXphYmxlJykuZWFjaCgodGV4dGFyZWFJbmRleCwgdGV4dGFyZWFFbCkgPT4ge1xuICAgICAgICBhcHAuaW5wdXQucmVzaXplVGV4dGFyZWEodGV4dGFyZWFFbCk7XG4gICAgICB9KTtcbiAgICB9LFxuICB9LFxufTtcblxudmFyIENoZWNrYm94ID0ge1xuICBuYW1lOiAnY2hlY2tib3gnLFxufTtcblxudmFyIFJhZGlvID0ge1xuICBuYW1lOiAncmFkaW8nLFxufTtcblxuY2xhc3MgVG9nZ2xlIGV4dGVuZHMgRnJhbWV3b3JrN0NsYXNzIHtcbiAgY29uc3RydWN0b3IoYXBwLCBwYXJhbXMgPSB7fSkge1xuICAgIHN1cGVyKHBhcmFtcywgW2FwcF0pO1xuICAgIGNvbnN0IHRvZ2dsZSA9IHRoaXM7XG5cbiAgICBjb25zdCBkZWZhdWx0cyA9IHt9O1xuXG4gICAgLy8gRXh0ZW5kIGRlZmF1bHRzIHdpdGggbW9kdWxlcyBwYXJhbXNcbiAgICB0b2dnbGUudXNlTW9kdWxlc1BhcmFtcyhkZWZhdWx0cyk7XG5cbiAgICB0b2dnbGUucGFyYW1zID0gVXRpbHMuZXh0ZW5kKGRlZmF1bHRzLCBwYXJhbXMpO1xuXG4gICAgY29uc3QgZWwgPSB0b2dnbGUucGFyYW1zLmVsO1xuICAgIGlmICghZWwpIHJldHVybiB0b2dnbGU7XG5cbiAgICBjb25zdCAkZWwgPSAkKGVsKTtcbiAgICBpZiAoJGVsLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRvZ2dsZTtcblxuXG4gICAgY29uc3QgJGlucHV0RWwgPSAkZWwuY2hpbGRyZW4oJ2lucHV0W3R5cGU9XCJjaGVja2JveFwiXScpO1xuXG4gICAgVXRpbHMuZXh0ZW5kKHRvZ2dsZSwge1xuICAgICAgYXBwLFxuICAgICAgJGVsLFxuICAgICAgZWw6ICRlbFswXSxcbiAgICAgICRpbnB1dEVsLFxuICAgICAgaW5wdXRFbDogJGlucHV0RWxbMF0sXG4gICAgICBkaXNhYmxlZDogJGVsLmhhc0NsYXNzKCdkaXNhYmxlZCcpIHx8ICRpbnB1dEVsLmhhc0NsYXNzKCdkaXNhYmxlZCcpIHx8ICRpbnB1dEVsLmF0dHIoJ2Rpc2FibGVkJykgfHwgJGlucHV0RWxbMF0uZGlzYWJsZWQsXG4gICAgfSk7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodG9nZ2xlLCAnY2hlY2tlZCcsIHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBzZXQoY2hlY2tlZCkge1xuICAgICAgICBpZiAoIXRvZ2dsZSB8fCB0eXBlb2YgdG9nZ2xlLiRpbnB1dEVsID09PSAndW5kZWZpbmVkJykgcmV0dXJuO1xuICAgICAgICBpZiAodG9nZ2xlLmNoZWNrZWQgPT09IGNoZWNrZWQpIHJldHVybjtcbiAgICAgICAgJGlucHV0RWxbMF0uY2hlY2tlZCA9IGNoZWNrZWQ7XG4gICAgICAgIHRvZ2dsZS4kaW5wdXRFbC50cmlnZ2VyKCdjaGFuZ2UnKTtcbiAgICAgIH0sXG4gICAgICBnZXQoKSB7XG4gICAgICAgIHJldHVybiAkaW5wdXRFbFswXS5jaGVja2VkO1xuICAgICAgfSxcbiAgICB9KTtcblxuICAgICRlbFswXS5mN1RvZ2dsZSA9IHRvZ2dsZTtcblxuICAgIGxldCBpc1RvdWNoZWQ7XG4gICAgY29uc3QgdG91Y2hlc1N0YXJ0ID0ge307XG4gICAgbGV0IGlzU2Nyb2xsaW5nO1xuICAgIGxldCB0b3VjaGVzRGlmZjtcbiAgICBsZXQgdG9nZ2xlV2lkdGg7XG4gICAgbGV0IHRvdWNoU3RhcnRUaW1lO1xuICAgIGxldCB0b3VjaFN0YXJ0Q2hlY2tlZDtcbiAgICBmdW5jdGlvbiBoYW5kbGVUb3VjaFN0YXJ0KGUpIHtcbiAgICAgIGlmIChpc1RvdWNoZWQgfHwgdG9nZ2xlLmRpc2FibGVkKSByZXR1cm47XG4gICAgICB0b3VjaGVzU3RhcnQueCA9IGUudHlwZSA9PT0gJ3RvdWNoc3RhcnQnID8gZS50YXJnZXRUb3VjaGVzWzBdLnBhZ2VYIDogZS5wYWdlWDtcbiAgICAgIHRvdWNoZXNTdGFydC55ID0gZS50eXBlID09PSAndG91Y2hzdGFydCcgPyBlLnRhcmdldFRvdWNoZXNbMF0ucGFnZVkgOiBlLnBhZ2VZO1xuICAgICAgdG91Y2hlc0RpZmYgPSAwO1xuXG4gICAgICBpc1RvdWNoZWQgPSB0cnVlO1xuICAgICAgaXNTY3JvbGxpbmcgPSB1bmRlZmluZWQ7XG4gICAgICB0b3VjaFN0YXJ0VGltZSA9IFV0aWxzLm5vdygpO1xuICAgICAgdG91Y2hTdGFydENoZWNrZWQgPSB0b2dnbGUuY2hlY2tlZDtcblxuICAgICAgdG9nZ2xlV2lkdGggPSAkZWxbMF0ub2Zmc2V0V2lkdGg7XG4gICAgICBVdGlscy5uZXh0VGljaygoKSA9PiB7XG4gICAgICAgIGlmIChpc1RvdWNoZWQpIHtcbiAgICAgICAgICAkZWwuYWRkQ2xhc3MoJ3RvZ2dsZS1hY3RpdmUtc3RhdGUnKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhbmRsZVRvdWNoTW92ZShlKSB7XG4gICAgICBpZiAoIWlzVG91Y2hlZCB8fCB0b2dnbGUuZGlzYWJsZWQpIHJldHVybjtcbiAgICAgIGNvbnN0IHBhZ2VYID0gZS50eXBlID09PSAndG91Y2htb3ZlJyA/IGUudGFyZ2V0VG91Y2hlc1swXS5wYWdlWCA6IGUucGFnZVg7XG4gICAgICBjb25zdCBwYWdlWSA9IGUudHlwZSA9PT0gJ3RvdWNobW92ZScgPyBlLnRhcmdldFRvdWNoZXNbMF0ucGFnZVkgOiBlLnBhZ2VZO1xuICAgICAgY29uc3QgaW52ZXJ0ZXIgPSBhcHAucnRsID8gLTEgOiAxO1xuXG4gICAgICBpZiAodHlwZW9mIGlzU2Nyb2xsaW5nID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBpc1Njcm9sbGluZyA9ICEhKGlzU2Nyb2xsaW5nIHx8IE1hdGguYWJzKHBhZ2VZIC0gdG91Y2hlc1N0YXJ0LnkpID4gTWF0aC5hYnMocGFnZVggLSB0b3VjaGVzU3RhcnQueCkpO1xuICAgICAgfVxuICAgICAgaWYgKGlzU2Nyb2xsaW5nKSB7XG4gICAgICAgIGlzVG91Y2hlZCA9IGZhbHNlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgIHRvdWNoZXNEaWZmID0gcGFnZVggLSB0b3VjaGVzU3RhcnQueDtcblxuXG4gICAgICBsZXQgY2hhbmdlZDtcbiAgICAgIGlmICh0b3VjaGVzRGlmZiAqIGludmVydGVyIDwgMCAmJiBNYXRoLmFicyh0b3VjaGVzRGlmZikgPiB0b2dnbGVXaWR0aCAvIDMgJiYgdG91Y2hTdGFydENoZWNrZWQpIHtcbiAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAodG91Y2hlc0RpZmYgKiBpbnZlcnRlciA+IDAgJiYgTWF0aC5hYnModG91Y2hlc0RpZmYpID4gdG9nZ2xlV2lkdGggLyAzICYmICF0b3VjaFN0YXJ0Q2hlY2tlZCkge1xuICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICAgIHRvdWNoZXNTdGFydC54ID0gcGFnZVg7XG4gICAgICAgIHRvZ2dsZS5jaGVja2VkID0gIXRvdWNoU3RhcnRDaGVja2VkO1xuICAgICAgICB0b3VjaFN0YXJ0Q2hlY2tlZCA9ICF0b3VjaFN0YXJ0Q2hlY2tlZDtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gaGFuZGxlVG91Y2hFbmQoKSB7XG4gICAgICBpZiAoIWlzVG91Y2hlZCB8fCB0b2dnbGUuZGlzYWJsZWQpIHtcbiAgICAgICAgaWYgKGlzU2Nyb2xsaW5nKSAkZWwucmVtb3ZlQ2xhc3MoJ3RvZ2dsZS1hY3RpdmUtc3RhdGUnKTtcbiAgICAgICAgaXNUb3VjaGVkID0gZmFsc2U7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGludmVydGVyID0gYXBwLnJ0bCA/IC0xIDogMTtcbiAgICAgIGlzVG91Y2hlZCA9IGZhbHNlO1xuXG4gICAgICAkZWwucmVtb3ZlQ2xhc3MoJ3RvZ2dsZS1hY3RpdmUtc3RhdGUnKTtcblxuICAgICAgbGV0IGNoYW5nZWQ7XG4gICAgICBpZiAoKFV0aWxzLm5vdygpIC0gdG91Y2hTdGFydFRpbWUpIDwgMzAwKSB7XG4gICAgICAgIGlmICh0b3VjaGVzRGlmZiAqIGludmVydGVyIDwgMCAmJiB0b3VjaFN0YXJ0Q2hlY2tlZCkge1xuICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b3VjaGVzRGlmZiAqIGludmVydGVyID4gMCAmJiAhdG91Y2hTdGFydENoZWNrZWQpIHtcbiAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgICAgIHRvZ2dsZS5jaGVja2VkID0gIXRvdWNoU3RhcnRDaGVja2VkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhbmRsZUlucHV0Q2hhbmdlKCkge1xuICAgICAgdG9nZ2xlLiRlbC50cmlnZ2VyKCd0b2dnbGU6Y2hhbmdlJywgdG9nZ2xlKTtcbiAgICAgIHRvZ2dsZS5lbWl0KCdsb2NhbDo6Y2hhbmdlIHRvZ2dsZUNoYW5nZScsIHRvZ2dsZSk7XG4gICAgfVxuICAgIHRvZ2dsZS5hdHRhY2hFdmVudHMgPSBmdW5jdGlvbiBhdHRhY2hFdmVudHMoKSB7XG4gICAgICB7XG4gICAgICAgIGlmICghU3VwcG9ydC50b3VjaCkgcmV0dXJuO1xuICAgICAgICBjb25zdCBwYXNzaXZlID0gU3VwcG9ydC5wYXNzaXZlTGlzdGVuZXIgPyB7IHBhc3NpdmU6IHRydWUgfSA6IGZhbHNlO1xuICAgICAgICAkZWwub24oYXBwLnRvdWNoRXZlbnRzLnN0YXJ0LCBoYW5kbGVUb3VjaFN0YXJ0LCBwYXNzaXZlKTtcbiAgICAgICAgYXBwLm9uKCd0b3VjaG1vdmUnLCBoYW5kbGVUb3VjaE1vdmUpO1xuICAgICAgICBhcHAub24oJ3RvdWNoZW5kOnBhc3NpdmUnLCBoYW5kbGVUb3VjaEVuZCk7XG4gICAgICB9XG4gICAgICB0b2dnbGUuJGlucHV0RWwub24oJ2NoYW5nZScsIGhhbmRsZUlucHV0Q2hhbmdlKTtcbiAgICB9O1xuICAgIHRvZ2dsZS5kZXRhY2hFdmVudHMgPSBmdW5jdGlvbiBkZXRhY2hFdmVudHMoKSB7XG4gICAgICB7XG4gICAgICAgIGlmICghU3VwcG9ydC50b3VjaCkgcmV0dXJuO1xuICAgICAgICBjb25zdCBwYXNzaXZlID0gU3VwcG9ydC5wYXNzaXZlTGlzdGVuZXIgPyB7IHBhc3NpdmU6IHRydWUgfSA6IGZhbHNlO1xuICAgICAgICAkZWwub2ZmKGFwcC50b3VjaEV2ZW50cy5zdGFydCwgaGFuZGxlVG91Y2hTdGFydCwgcGFzc2l2ZSk7XG4gICAgICAgIGFwcC5vZmYoJ3RvdWNobW92ZScsIGhhbmRsZVRvdWNoTW92ZSk7XG4gICAgICAgIGFwcC5vZmYoJ3RvdWNoZW5kOnBhc3NpdmUnLCBoYW5kbGVUb3VjaEVuZCk7XG4gICAgICB9XG4gICAgICB0b2dnbGUuJGlucHV0RWwub2ZmKCdjaGFuZ2UnLCBoYW5kbGVJbnB1dENoYW5nZSk7XG4gICAgfTtcblxuXG4gICAgLy8gSW5zdGFsbCBNb2R1bGVzXG4gICAgdG9nZ2xlLnVzZU1vZHVsZXMoKTtcblxuICAgIC8vIEluaXRcbiAgICB0b2dnbGUuaW5pdCgpO1xuICB9XG4gIHRvZ2dsZSgpIHtcbiAgICBjb25zdCB0b2dnbGUgPSB0aGlzO1xuICAgIHRvZ2dsZS5jaGVja2VkID0gIXRvZ2dsZS5jaGVja2VkO1xuICB9XG4gIGluaXQoKSB7XG4gICAgY29uc3QgdG9nZ2xlID0gdGhpcztcbiAgICB0b2dnbGUuYXR0YWNoRXZlbnRzKCk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICBsZXQgdG9nZ2xlID0gdGhpcztcbiAgICB0b2dnbGUuJGVsLnRyaWdnZXIoJ3RvZ2dsZTpiZWZvcmVkZXN0cm95JywgdG9nZ2xlKTtcbiAgICB0b2dnbGUuZW1pdCgnbG9jYWw6OmJlZm9yZURlc3Ryb3kgdG9nZ2xlQmVmb3JlRGVzdHJveScsIHRvZ2dsZSk7XG4gICAgZGVsZXRlIHRvZ2dsZS4kZWxbMF0uZjdUb2dnbGU7XG4gICAgdG9nZ2xlLmRldGFjaEV2ZW50cygpO1xuICAgIFV0aWxzLmRlbGV0ZVByb3BzKHRvZ2dsZSk7XG4gICAgdG9nZ2xlID0gbnVsbDtcbiAgfVxufVxuXG52YXIgVG9nZ2xlJDEgPSB7XG4gIG5hbWU6ICd0b2dnbGUnLFxuICBjcmVhdGUoKSB7XG4gICAgY29uc3QgYXBwID0gdGhpcztcbiAgICBhcHAudG9nZ2xlID0gQ29uc3RydWN0b3JNZXRob2RzKHtcbiAgICAgIGRlZmF1bHRTZWxlY3RvcjogJy50b2dnbGUnLFxuICAgICAgY29uc3RydWN0b3I6IFRvZ2dsZSxcbiAgICAgIGFwcCxcbiAgICAgIGRvbVByb3A6ICdmN1RvZ2dsZScsXG4gICAgfSk7XG4gIH0sXG4gIHN0YXRpYzoge1xuICAgIFRvZ2dsZSxcbiAgfSxcbiAgb246IHtcbiAgICB0YWJNb3VudGVkKHRhYkVsKSB7XG4gICAgICBjb25zdCBhcHAgPSB0aGlzO1xuICAgICAgJCh0YWJFbCkuZmluZCgnLnRvZ2dsZS1pbml0JykuZWFjaCgoaW5kZXgsIHRvZ2dsZUVsKSA9PiBhcHAudG9nZ2xlLmNyZWF0ZSh7IGVsOiB0b2dnbGVFbCB9KSk7XG4gICAgfSxcbiAgICB0YWJCZWZvcmVSZW1vdmUodGFiRWwpIHtcbiAgICAgICQodGFiRWwpLmZpbmQoJy50b2dnbGUtaW5pdCcpLmVhY2goKGluZGV4LCB0b2dnbGVFbCkgPT4ge1xuICAgICAgICBpZiAodG9nZ2xlRWwuZjdUb2dnbGUpIHRvZ2dsZUVsLmY3VG9nZ2xlLmRlc3Ryb3koKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgcGFnZUluaXQocGFnZSkge1xuICAgICAgY29uc3QgYXBwID0gdGhpcztcbiAgICAgIHBhZ2UuJGVsLmZpbmQoJy50b2dnbGUtaW5pdCcpLmVhY2goKGluZGV4LCB0b2dnbGVFbCkgPT4gYXBwLnRvZ2dsZS5jcmVhdGUoeyBlbDogdG9nZ2xlRWwgfSkpO1xuICAgIH0sXG4gICAgcGFnZUJlZm9yZVJlbW92ZShwYWdlKSB7XG4gICAgICBwYWdlLiRlbC5maW5kKCcudG9nZ2xlLWluaXQnKS5lYWNoKChpbmRleCwgdG9nZ2xlRWwpID0+IHtcbiAgICAgICAgaWYgKHRvZ2dsZUVsLmY3VG9nZ2xlKSB0b2dnbGVFbC5mN1RvZ2dsZS5kZXN0cm95KCk7XG4gICAgICB9KTtcbiAgICB9LFxuICB9LFxufTtcblxuY2xhc3MgUmFuZ2UgZXh0ZW5kcyBGcmFtZXdvcms3Q2xhc3Mge1xuICBjb25zdHJ1Y3RvcihhcHAsIHBhcmFtcykge1xuICAgIHN1cGVyKHBhcmFtcywgW2FwcF0pO1xuICAgIGNvbnN0IHJhbmdlID0gdGhpcztcbiAgICBjb25zdCBkZWZhdWx0cyA9IHtcbiAgICAgIGVsOiBudWxsLFxuICAgICAgaW5wdXRFbDogbnVsbCxcbiAgICAgIGR1YWw6IGZhbHNlLFxuICAgICAgc3RlcDogMSxcbiAgICAgIGxhYmVsOiBmYWxzZSxcbiAgICAgIG1pbjogMCxcbiAgICAgIG1heDogMTAwLFxuICAgICAgdmFsdWU6IDAsXG4gICAgICBkcmFnZ2FibGVCYXI6IHRydWUsXG4gICAgfTtcblxuICAgIC8vIEV4dGVuZCBkZWZhdWx0cyB3aXRoIG1vZHVsZXMgcGFyYW1zXG4gICAgcmFuZ2UudXNlTW9kdWxlc1BhcmFtcyhkZWZhdWx0cyk7XG5cbiAgICByYW5nZS5wYXJhbXMgPSBVdGlscy5leHRlbmQoZGVmYXVsdHMsIHBhcmFtcyk7XG5cbiAgICBjb25zdCBlbCA9IHJhbmdlLnBhcmFtcy5lbDtcbiAgICBpZiAoIWVsKSByZXR1cm4gcmFuZ2U7XG5cbiAgICBjb25zdCAkZWwgPSAkKGVsKTtcbiAgICBpZiAoJGVsLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHJhbmdlO1xuXG4gICAgY29uc3QgZGF0YXNldCA9ICRlbC5kYXRhc2V0KCk7XG5cbiAgICAoJ3N0ZXAgbWluIG1heCB2YWx1ZScpLnNwbGl0KCcgJykuZm9yRWFjaCgocGFyYW1OYW1lKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIHBhcmFtc1twYXJhbU5hbWVdID09PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZGF0YXNldFtwYXJhbU5hbWVdICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICByYW5nZS5wYXJhbXNbcGFyYW1OYW1lXSA9IHBhcnNlRmxvYXQoZGF0YXNldFtwYXJhbU5hbWVdKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICAoJ2R1YWwgbGFiZWwnKS5zcGxpdCgnICcpLmZvckVhY2goKHBhcmFtTmFtZSkgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBwYXJhbXNbcGFyYW1OYW1lXSA9PT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRhdGFzZXRbcGFyYW1OYW1lXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmFuZ2UucGFyYW1zW3BhcmFtTmFtZV0gPSBkYXRhc2V0W3BhcmFtTmFtZV07XG4gICAgICB9XG4gICAgfSk7XG5cblxuICAgIGlmICghcmFuZ2UucGFyYW1zLnZhbHVlKSB7XG4gICAgICBpZiAodHlwZW9mIGRhdGFzZXQudmFsdWUgIT09ICd1bmRlZmluZWQnKSByYW5nZS5wYXJhbXMudmFsdWUgPSBkYXRhc2V0LnZhbHVlO1xuICAgICAgaWYgKHR5cGVvZiBkYXRhc2V0LnZhbHVlTGVmdCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRhdGFzZXQudmFsdWVSaWdodCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmFuZ2UucGFyYW1zLnZhbHVlID0gW3BhcnNlRmxvYXQoZGF0YXNldC52YWx1ZUxlZnQpLCBwYXJzZUZsb2F0KGRhdGFzZXQudmFsdWVSaWdodCldO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxldCAkaW5wdXRFbDtcbiAgICBpZiAoIXJhbmdlLnBhcmFtcy5kdWFsKSB7XG4gICAgICBpZiAocmFuZ2UucGFyYW1zLmlucHV0RWwpIHtcbiAgICAgICAgJGlucHV0RWwgPSAkKHJhbmdlLnBhcmFtcy5pbnB1dEVsKTtcbiAgICAgIH0gZWxzZSBpZiAoJGVsLmZpbmQoJ2lucHV0W3R5cGU9XCJyYW5nZVwiXScpLmxlbmd0aCkge1xuICAgICAgICAkaW5wdXRFbCA9ICRlbC5maW5kKCdpbnB1dFt0eXBlPVwicmFuZ2VcIl0nKS5lcSgwKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCB7IGR1YWwsIHN0ZXAsIGxhYmVsLCBtaW4sIG1heCwgdmFsdWUgfSA9IHJhbmdlLnBhcmFtcztcbiAgICBVdGlscy5leHRlbmQocmFuZ2UsIHtcbiAgICAgICRlbCxcbiAgICAgIGVsOiAkZWxbMF0sXG4gICAgICAkaW5wdXRFbCxcbiAgICAgIGlucHV0RWw6ICRpbnB1dEVsID8gJGlucHV0RWxbMF0gOiB1bmRlZmluZWQsXG4gICAgICBkdWFsLFxuICAgICAgc3RlcCxcbiAgICAgIGxhYmVsLFxuICAgICAgbWluLFxuICAgICAgbWF4LFxuICAgICAgdmFsdWUsXG4gICAgICBwcmV2aW91c1ZhbHVlOiB2YWx1ZSxcbiAgICB9KTtcblxuICAgIGlmICgkaW5wdXRFbCkge1xuICAgICAgKCdzdGVwIG1pbiBtYXgnKS5zcGxpdCgnICcpLmZvckVhY2goKHBhcmFtTmFtZSkgPT4ge1xuICAgICAgICBpZiAoIXBhcmFtc1twYXJhbU5hbWVdICYmICRpbnB1dEVsLmF0dHIocGFyYW1OYW1lKSkge1xuICAgICAgICAgIHJhbmdlLnBhcmFtc1twYXJhbU5hbWVdID0gcGFyc2VGbG9hdCgkaW5wdXRFbC5hdHRyKHBhcmFtTmFtZSkpO1xuICAgICAgICAgIHJhbmdlW3BhcmFtTmFtZV0gPSBwYXJzZUZsb2F0KCRpbnB1dEVsLmF0dHIocGFyYW1OYW1lKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKHR5cGVvZiAkaW5wdXRFbC52YWwoKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmFuZ2UucGFyYW1zLnZhbHVlID0gcGFyc2VGbG9hdCgkaW5wdXRFbC52YWwoKSk7XG4gICAgICAgIHJhbmdlLnZhbHVlID0gcGFyc2VGbG9hdCgkaW5wdXRFbC52YWwoKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRHVhbFxuICAgIGlmIChyYW5nZS5kdWFsKSB7XG4gICAgICAkZWwuYWRkQ2xhc3MoJ3JhbmdlLXNsaWRlci1kdWFsJyk7XG4gICAgfVxuICAgIGlmIChyYW5nZS5sYWJlbCkge1xuICAgICAgJGVsLmFkZENsYXNzKCdyYW5nZS1zbGlkZXItbGFiZWwnKTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3IgbGF5b3V0XG4gICAgY29uc3QgJGJhckVsID0gJCgnPGRpdiBjbGFzcz1cInJhbmdlLWJhclwiPjwvZGl2PicpO1xuICAgIGNvbnN0ICRiYXJBY3RpdmVFbCA9ICQoJzxkaXYgY2xhc3M9XCJyYW5nZS1iYXItYWN0aXZlXCI+PC9kaXY+Jyk7XG4gICAgJGJhckVsLmFwcGVuZCgkYmFyQWN0aXZlRWwpO1xuXG4gICAgLy8gQ3JlYXRlIEtub2JzXG4gICAgY29uc3Qga25vYkhUTUwgPSBgXG4gICAgICA8ZGl2IGNsYXNzPVwicmFuZ2Uta25vYi13cmFwXCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJyYW5nZS1rbm9iXCI+PC9kaXY+XG4gICAgICAgICR7cmFuZ2UubGFiZWwgPyAnPGRpdiBjbGFzcz1cInJhbmdlLWtub2ItbGFiZWxcIj48L2Rpdj4nIDogJyd9XG4gICAgICA8L2Rpdj5cbiAgICBgO1xuICAgIGNvbnN0IGtub2JzID0gWyQoa25vYkhUTUwpXTtcbiAgICBjb25zdCBsYWJlbHMgPSBbXTtcblxuICAgIGlmIChyYW5nZS5kdWFsKSB7XG4gICAgICBrbm9icy5wdXNoKCQoa25vYkhUTUwpKTtcbiAgICB9XG5cbiAgICAkZWwuYXBwZW5kKCRiYXJFbCk7XG4gICAga25vYnMuZm9yRWFjaCgoJGtub2JFbCkgPT4ge1xuICAgICAgJGVsLmFwcGVuZCgka25vYkVsKTtcbiAgICB9KTtcblxuICAgIC8vIExhYmVsc1xuICAgIGlmIChyYW5nZS5sYWJlbCkge1xuICAgICAgbGFiZWxzLnB1c2goa25vYnNbMF0uZmluZCgnLnJhbmdlLWtub2ItbGFiZWwnKSk7XG4gICAgICBpZiAocmFuZ2UuZHVhbCkge1xuICAgICAgICBsYWJlbHMucHVzaChrbm9ic1sxXS5maW5kKCcucmFuZ2Uta25vYi1sYWJlbCcpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBVdGlscy5leHRlbmQocmFuZ2UsIHtcbiAgICAgIGFwcCxcbiAgICAgIGtub2JzLFxuICAgICAgbGFiZWxzLFxuICAgICAgJGJhckVsLFxuICAgICAgJGJhckFjdGl2ZUVsLFxuICAgIH0pO1xuXG4gICAgJGVsWzBdLmY3UmFuZ2UgPSByYW5nZTtcblxuICAgIC8vIFRvdWNoIEV2ZW50c1xuICAgIGxldCBpc1RvdWNoZWQ7XG4gICAgY29uc3QgdG91Y2hlc1N0YXJ0ID0ge307XG4gICAgbGV0IGlzU2Nyb2xsaW5nO1xuICAgIGxldCByYW5nZU9mZnNldExlZnQ7XG4gICAgbGV0ICR0b3VjaGVkS25vYkVsO1xuICAgIGxldCBkdWFsVmFsdWVJbmRleDtcbiAgICBsZXQgdmFsdWVDaGFuZ2VkQnlUb3VjaDtcbiAgICBmdW5jdGlvbiBvblRvdWNoQ2hhbmdlKCkge1xuICAgICAgdmFsdWVDaGFuZ2VkQnlUb3VjaCA9IHRydWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhbmRsZVRvdWNoU3RhcnQoZSkge1xuICAgICAgaWYgKGlzVG91Y2hlZCkgcmV0dXJuO1xuICAgICAgaWYgKCFyYW5nZS5wYXJhbXMuZHJhZ2dhYmxlQmFyKSB7XG4gICAgICAgIGlmICgkKGUudGFyZ2V0KS5jbG9zZXN0KCcucmFuZ2Uta25vYicpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFsdWVDaGFuZ2VkQnlUb3VjaCA9IGZhbHNlO1xuICAgICAgdG91Y2hlc1N0YXJ0LnggPSBlLnR5cGUgPT09ICd0b3VjaHN0YXJ0JyA/IGUudGFyZ2V0VG91Y2hlc1swXS5wYWdlWCA6IGUucGFnZVg7XG4gICAgICB0b3VjaGVzU3RhcnQueSA9IGUudHlwZSA9PT0gJ3RvdWNoc3RhcnQnID8gZS50YXJnZXRUb3VjaGVzWzBdLnBhZ2VZIDogZS5wYWdlWTtcblxuICAgICAgaXNUb3VjaGVkID0gdHJ1ZTtcbiAgICAgIGlzU2Nyb2xsaW5nID0gdW5kZWZpbmVkO1xuICAgICAgcmFuZ2VPZmZzZXRMZWZ0ID0gJGVsLm9mZnNldCgpLmxlZnQ7XG5cbiAgICAgIGxldCBwcm9ncmVzcztcbiAgICAgIGlmIChyYW5nZS5hcHAucnRsKSB7XG4gICAgICAgIHByb2dyZXNzID0gKChyYW5nZU9mZnNldExlZnQgKyByYW5nZS5yYW5nZVdpZHRoKSAtIHRvdWNoZXNTdGFydC54KSAvIHJhbmdlLnJhbmdlV2lkdGg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9ncmVzcyA9ICh0b3VjaGVzU3RhcnQueCAtIHJhbmdlT2Zmc2V0TGVmdCkgLyByYW5nZS5yYW5nZVdpZHRoO1xuICAgICAgfVxuXG4gICAgICBsZXQgbmV3VmFsdWUgPSAocHJvZ3Jlc3MgKiAocmFuZ2UubWF4IC0gcmFuZ2UubWluKSkgKyByYW5nZS5taW47XG4gICAgICBpZiAocmFuZ2UuZHVhbCkge1xuICAgICAgICBpZiAoTWF0aC5hYnMocmFuZ2UudmFsdWVbMF0gLSBuZXdWYWx1ZSkgPCBNYXRoLmFicyhyYW5nZS52YWx1ZVsxXSAtIG5ld1ZhbHVlKSkge1xuICAgICAgICAgIGR1YWxWYWx1ZUluZGV4ID0gMDtcbiAgICAgICAgICAkdG91Y2hlZEtub2JFbCA9IHJhbmdlLmtub2JzWzBdO1xuICAgICAgICAgIG5ld1ZhbHVlID0gW25ld1ZhbHVlLCByYW5nZS52YWx1ZVsxXV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZHVhbFZhbHVlSW5kZXggPSAxO1xuICAgICAgICAgICR0b3VjaGVkS25vYkVsID0gcmFuZ2Uua25vYnNbMV07XG4gICAgICAgICAgbmV3VmFsdWUgPSBbcmFuZ2UudmFsdWVbMF0sIG5ld1ZhbHVlXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJHRvdWNoZWRLbm9iRWwgPSByYW5nZS5rbm9ic1swXTtcbiAgICAgICAgbmV3VmFsdWUgPSAocHJvZ3Jlc3MgKiAocmFuZ2UubWF4IC0gcmFuZ2UubWluKSkgKyByYW5nZS5taW47XG4gICAgICB9XG4gICAgICBVdGlscy5uZXh0VGljaygoKSA9PiB7XG4gICAgICAgIGlmIChpc1RvdWNoZWQpICR0b3VjaGVkS25vYkVsLmFkZENsYXNzKCdyYW5nZS1rbm9iLWFjdGl2ZS1zdGF0ZScpO1xuICAgICAgfSwgNzApO1xuICAgICAgcmFuZ2Uub24oJ2NoYW5nZScsIG9uVG91Y2hDaGFuZ2UpO1xuICAgICAgcmFuZ2Uuc2V0VmFsdWUobmV3VmFsdWUsIHRydWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoYW5kbGVUb3VjaE1vdmUoZSkge1xuICAgICAgaWYgKCFpc1RvdWNoZWQpIHJldHVybjtcbiAgICAgIGNvbnN0IHBhZ2VYID0gZS50eXBlID09PSAndG91Y2htb3ZlJyA/IGUudGFyZ2V0VG91Y2hlc1swXS5wYWdlWCA6IGUucGFnZVg7XG4gICAgICBjb25zdCBwYWdlWSA9IGUudHlwZSA9PT0gJ3RvdWNobW92ZScgPyBlLnRhcmdldFRvdWNoZXNbMF0ucGFnZVkgOiBlLnBhZ2VZO1xuXG4gICAgICBpZiAodHlwZW9mIGlzU2Nyb2xsaW5nID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBpc1Njcm9sbGluZyA9ICEhKGlzU2Nyb2xsaW5nIHx8IE1hdGguYWJzKHBhZ2VZIC0gdG91Y2hlc1N0YXJ0LnkpID4gTWF0aC5hYnMocGFnZVggLSB0b3VjaGVzU3RhcnQueCkpO1xuICAgICAgfVxuICAgICAgaWYgKGlzU2Nyb2xsaW5nKSB7XG4gICAgICAgIGlzVG91Y2hlZCA9IGZhbHNlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgIGxldCBwcm9ncmVzcztcbiAgICAgIGlmIChyYW5nZS5hcHAucnRsKSB7XG4gICAgICAgIHByb2dyZXNzID0gKChyYW5nZU9mZnNldExlZnQgKyByYW5nZS5yYW5nZVdpZHRoKSAtIHBhZ2VYKSAvIHJhbmdlLnJhbmdlV2lkdGg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9ncmVzcyA9IChwYWdlWCAtIHJhbmdlT2Zmc2V0TGVmdCkgLyByYW5nZS5yYW5nZVdpZHRoO1xuICAgICAgfVxuXG4gICAgICBsZXQgbmV3VmFsdWUgPSAocHJvZ3Jlc3MgKiAocmFuZ2UubWF4IC0gcmFuZ2UubWluKSkgKyByYW5nZS5taW47XG4gICAgICBpZiAocmFuZ2UuZHVhbCkge1xuICAgICAgICBsZXQgbGVmdFZhbHVlO1xuICAgICAgICBsZXQgcmlnaHRWYWx1ZTtcbiAgICAgICAgaWYgKGR1YWxWYWx1ZUluZGV4ID09PSAwKSB7XG4gICAgICAgICAgbGVmdFZhbHVlID0gbmV3VmFsdWU7XG4gICAgICAgICAgcmlnaHRWYWx1ZSA9IHJhbmdlLnZhbHVlWzFdO1xuICAgICAgICAgIGlmIChsZWZ0VmFsdWUgPiByaWdodFZhbHVlKSB7XG4gICAgICAgICAgICByaWdodFZhbHVlID0gbGVmdFZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsZWZ0VmFsdWUgPSByYW5nZS52YWx1ZVswXTtcbiAgICAgICAgICByaWdodFZhbHVlID0gbmV3VmFsdWU7XG4gICAgICAgICAgaWYgKHJpZ2h0VmFsdWUgPCBsZWZ0VmFsdWUpIHtcbiAgICAgICAgICAgIGxlZnRWYWx1ZSA9IHJpZ2h0VmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG5ld1ZhbHVlID0gW2xlZnRWYWx1ZSwgcmlnaHRWYWx1ZV07XG4gICAgICB9XG4gICAgICByYW5nZS5zZXRWYWx1ZShuZXdWYWx1ZSwgdHJ1ZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhbmRsZVRvdWNoRW5kKCkge1xuICAgICAgaWYgKCFpc1RvdWNoZWQpIHtcbiAgICAgICAgaWYgKGlzU2Nyb2xsaW5nKSAkdG91Y2hlZEtub2JFbC5yZW1vdmVDbGFzcygncmFuZ2Uta25vYi1hY3RpdmUtc3RhdGUnKTtcbiAgICAgICAgaXNUb3VjaGVkID0gZmFsc2U7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJhbmdlLm9mZignY2hhbmdlJywgb25Ub3VjaENoYW5nZSk7XG4gICAgICBpc1RvdWNoZWQgPSBmYWxzZTtcbiAgICAgICR0b3VjaGVkS25vYkVsLnJlbW92ZUNsYXNzKCdyYW5nZS1rbm9iLWFjdGl2ZS1zdGF0ZScpO1xuICAgICAgaWYgKHZhbHVlQ2hhbmdlZEJ5VG91Y2ggJiYgcmFuZ2UuJGlucHV0RWwgJiYgIXJhbmdlLmR1YWwpIHtcbiAgICAgICAgcmFuZ2UuJGlucHV0RWwudHJpZ2dlcignY2hhbmdlJyk7XG4gICAgICB9XG4gICAgICB2YWx1ZUNoYW5nZWRCeVRvdWNoID0gZmFsc2U7XG4gICAgICBpZiAodHlwZW9mIHJhbmdlLnByZXZpb3VzVmFsdWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAoXG4gICAgICAgICAgICByYW5nZS5kdWFsICYmXG4gICAgICAgICAgICAoXG4gICAgICAgICAgICAgIHJhbmdlLnByZXZpb3VzVmFsdWVbMF0gIT09IHJhbmdlLnZhbHVlWzBdIHx8XG4gICAgICAgICAgICAgIHJhbmdlLnByZXZpb3VzVmFsdWVbMV0gIT09IHJhbmdlLnZhbHVlWzFdXG4gICAgICAgICAgICApXG4gICAgICAgICAgKSB8fFxuICAgICAgICAgIChcbiAgICAgICAgICAgICFyYW5nZS5kdWFsICYmXG4gICAgICAgICAgICByYW5nZS5wcmV2aW91c1ZhbHVlICE9PSByYW5nZS52YWx1ZVxuICAgICAgICAgIClcbiAgICAgICAgKSB7XG4gICAgICAgICAgcmFuZ2UuJGVsLnRyaWdnZXIoJ3JhbmdlOmNoYW5nZWQnLCByYW5nZSwgcmFuZ2UudmFsdWUpO1xuICAgICAgICAgIHJhbmdlLmVtaXQoJ2xvY2FsOjpjaGFuZ2VkIHJhbmdlQ2hhbmdlZCcsIHJhbmdlLCByYW5nZS52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVSZXNpemUoKSB7XG4gICAgICByYW5nZS5jYWxjU2l6ZSgpO1xuICAgICAgcmFuZ2UubGF5b3V0KCk7XG4gICAgfVxuICAgIHJhbmdlLmF0dGFjaEV2ZW50cyA9IGZ1bmN0aW9uIGF0dGFjaEV2ZW50cygpIHtcbiAgICAgIGNvbnN0IHBhc3NpdmUgPSBTdXBwb3J0LnBhc3NpdmVMaXN0ZW5lciA/IHsgcGFzc2l2ZTogdHJ1ZSB9IDogZmFsc2U7XG4gICAgICByYW5nZS4kZWwub24oYXBwLnRvdWNoRXZlbnRzLnN0YXJ0LCBoYW5kbGVUb3VjaFN0YXJ0LCBwYXNzaXZlKTtcbiAgICAgIGFwcC5vbigndG91Y2htb3ZlJywgaGFuZGxlVG91Y2hNb3ZlKTtcbiAgICAgIGFwcC5vbigndG91Y2hlbmQ6cGFzc2l2ZScsIGhhbmRsZVRvdWNoRW5kKTtcbiAgICAgIGFwcC5vbigndGFiU2hvdycsIGhhbmRsZVJlc2l6ZSk7XG4gICAgICBhcHAub24oJ3Jlc2l6ZScsIGhhbmRsZVJlc2l6ZSk7XG4gICAgICByYW5nZS4kZWxcbiAgICAgICAgLnBhcmVudHMoJy5zaGVldC1tb2RhbCwgLmFjdGlvbnMtbW9kYWwsIC5wb3B1cCwgLnBvcG92ZXIsIC5sb2dpbi1zY3JlZW4sIC5kaWFsb2csIC50b2FzdCcpXG4gICAgICAgIC5vbignbW9kYWw6b3BlbicsIGhhbmRsZVJlc2l6ZSk7XG4gICAgICByYW5nZS4kZWxcbiAgICAgICAgLnBhcmVudHMoJy5wYW5lbCcpXG4gICAgICAgIC5vbigncGFuZWw6b3BlbicsIGhhbmRsZVJlc2l6ZSk7XG4gICAgfTtcbiAgICByYW5nZS5kZXRhY2hFdmVudHMgPSBmdW5jdGlvbiBkZXRhY2hFdmVudHMoKSB7XG4gICAgICBjb25zdCBwYXNzaXZlID0gU3VwcG9ydC5wYXNzaXZlTGlzdGVuZXIgPyB7IHBhc3NpdmU6IHRydWUgfSA6IGZhbHNlO1xuICAgICAgcmFuZ2UuJGVsLm9mZihhcHAudG91Y2hFdmVudHMuc3RhcnQsIGhhbmRsZVRvdWNoU3RhcnQsIHBhc3NpdmUpO1xuICAgICAgYXBwLm9mZigndG91Y2htb3ZlJywgaGFuZGxlVG91Y2hNb3ZlKTtcbiAgICAgIGFwcC5vZmYoJ3RvdWNoZW5kOnBhc3NpdmUnLCBoYW5kbGVUb3VjaEVuZCk7XG4gICAgICBhcHAub2ZmKCd0YWJTaG93JywgaGFuZGxlUmVzaXplKTtcbiAgICAgIGFwcC5vZmYoJ3Jlc2l6ZScsIGhhbmRsZVJlc2l6ZSk7XG4gICAgICByYW5nZS4kZWxcbiAgICAgICAgLnBhcmVudHMoJy5zaGVldC1tb2RhbCwgLmFjdGlvbnMtbW9kYWwsIC5wb3B1cCwgLnBvcG92ZXIsIC5sb2dpbi1zY3JlZW4sIC5kaWFsb2csIC50b2FzdCcpXG4gICAgICAgIC5vZmYoJ21vZGFsOm9wZW4nLCBoYW5kbGVSZXNpemUpO1xuICAgICAgcmFuZ2UuJGVsXG4gICAgICAgIC5wYXJlbnRzKCcucGFuZWwnKVxuICAgICAgICAub2ZmKCdwYW5lbDpvcGVuJywgaGFuZGxlUmVzaXplKTtcbiAgICB9O1xuXG4gICAgLy8gSW5zdGFsbCBNb2R1bGVzXG4gICAgcmFuZ2UudXNlTW9kdWxlcygpO1xuXG4gICAgLy8gSW5pdFxuICAgIHJhbmdlLmluaXQoKTtcblxuICAgIHJldHVybiByYW5nZTtcbiAgfVxuICBjYWxjU2l6ZSgpIHtcbiAgICBjb25zdCByYW5nZSA9IHRoaXM7XG4gICAgY29uc3Qgd2lkdGggPSByYW5nZS4kZWwub3V0ZXJXaWR0aCgpO1xuICAgIGlmICh3aWR0aCA9PT0gMCkgcmV0dXJuO1xuICAgIHJhbmdlLnJhbmdlV2lkdGggPSB3aWR0aDtcbiAgICByYW5nZS5rbm9iV2lkdGggPSByYW5nZS5rbm9ic1swXS5vdXRlcldpZHRoKCk7XG4gIH1cbiAgbGF5b3V0KCkge1xuICAgIGNvbnN0IHJhbmdlID0gdGhpcztcbiAgICBjb25zdCB7XG4gICAgICBhcHAsXG4gICAgICBrbm9iV2lkdGgsXG4gICAgICByYW5nZVdpZHRoLFxuICAgICAgbWluLFxuICAgICAgbWF4LFxuICAgICAga25vYnMsXG4gICAgICAkYmFyQWN0aXZlRWwsXG4gICAgICB2YWx1ZSxcbiAgICAgIGxhYmVsLFxuICAgICAgbGFiZWxzLFxuICAgIH0gPSByYW5nZTtcbiAgICBjb25zdCBwb3NpdGlvblByb3BlcnR5ID0gYXBwLnJ0bCA/ICdyaWdodCcgOiAnbGVmdCc7XG4gICAgaWYgKHJhbmdlLmR1YWwpIHtcbiAgICAgIGNvbnN0IHByb2dyZXNzID0gWygodmFsdWVbMF0gLSBtaW4pIC8gKG1heCAtIG1pbikpLCAoKHZhbHVlWzFdIC0gbWluKSAvIChtYXggLSBtaW4pKV07XG4gICAgICAkYmFyQWN0aXZlRWwuY3NzKHtcbiAgICAgICAgW3Bvc2l0aW9uUHJvcGVydHldOiBgJHtwcm9ncmVzc1swXSAqIDEwMH0lYCxcbiAgICAgICAgd2lkdGg6IGAkeyhwcm9ncmVzc1sxXSAtIHByb2dyZXNzWzBdKSAqIDEwMH0lYCxcbiAgICAgIH0pO1xuICAgICAga25vYnMuZm9yRWFjaCgoJGtub2JFbCwga25vYkluZGV4KSA9PiB7XG4gICAgICAgIGxldCBsZWZ0UG9zID0gcmFuZ2VXaWR0aCAqIHByb2dyZXNzW2tub2JJbmRleF07XG4gICAgICAgIGNvbnN0IHJlYWxMZWZ0ID0gKHJhbmdlV2lkdGggKiBwcm9ncmVzc1trbm9iSW5kZXhdKSAtIChrbm9iV2lkdGggLyAyKTtcbiAgICAgICAgaWYgKHJlYWxMZWZ0IDwgMCkgbGVmdFBvcyA9IGtub2JXaWR0aCAvIDI7XG4gICAgICAgIGlmICgocmVhbExlZnQgKyBrbm9iV2lkdGgpID4gcmFuZ2VXaWR0aCkgbGVmdFBvcyA9IHJhbmdlV2lkdGggLSAoa25vYldpZHRoIC8gMik7XG4gICAgICAgICRrbm9iRWwuY3NzKHBvc2l0aW9uUHJvcGVydHksIGAke2xlZnRQb3N9cHhgKTtcbiAgICAgICAgaWYgKGxhYmVsKSBsYWJlbHNba25vYkluZGV4XS50ZXh0KHZhbHVlW2tub2JJbmRleF0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHByb2dyZXNzID0gKCh2YWx1ZSAtIG1pbikgLyAobWF4IC0gbWluKSk7XG4gICAgICAkYmFyQWN0aXZlRWwuY3NzKCd3aWR0aCcsIGAke3Byb2dyZXNzICogMTAwfSVgKTtcblxuICAgICAgbGV0IGxlZnRQb3MgPSByYW5nZVdpZHRoICogcHJvZ3Jlc3M7XG4gICAgICBjb25zdCByZWFsTGVmdCA9IChyYW5nZVdpZHRoICogcHJvZ3Jlc3MpIC0gKGtub2JXaWR0aCAvIDIpO1xuICAgICAgaWYgKHJlYWxMZWZ0IDwgMCkgbGVmdFBvcyA9IGtub2JXaWR0aCAvIDI7XG4gICAgICBpZiAoKHJlYWxMZWZ0ICsga25vYldpZHRoKSA+IHJhbmdlV2lkdGgpIGxlZnRQb3MgPSByYW5nZVdpZHRoIC0gKGtub2JXaWR0aCAvIDIpO1xuICAgICAga25vYnNbMF0uY3NzKHBvc2l0aW9uUHJvcGVydHksIGAke2xlZnRQb3N9cHhgKTtcbiAgICAgIGlmIChsYWJlbCkgbGFiZWxzWzBdLnRleHQodmFsdWUpO1xuICAgIH1cbiAgICBpZiAoKHJhbmdlLmR1YWwgJiYgdmFsdWUuaW5kZXhPZihtaW4pID49IDApIHx8ICghcmFuZ2UuZHVhbCAmJiB2YWx1ZSA9PT0gbWluKSkge1xuICAgICAgcmFuZ2UuJGVsLmFkZENsYXNzKCdyYW5nZS1zbGlkZXItbWluJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJhbmdlLiRlbC5yZW1vdmVDbGFzcygncmFuZ2Utc2xpZGVyLW1pbicpO1xuICAgIH1cbiAgICBpZiAoKHJhbmdlLmR1YWwgJiYgdmFsdWUuaW5kZXhPZihtYXgpID49IDApIHx8ICghcmFuZ2UuZHVhbCAmJiB2YWx1ZSA9PT0gbWF4KSkge1xuICAgICAgcmFuZ2UuJGVsLmFkZENsYXNzKCdyYW5nZS1zbGlkZXItbWF4Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJhbmdlLiRlbC5yZW1vdmVDbGFzcygncmFuZ2Utc2xpZGVyLW1heCcpO1xuICAgIH1cbiAgfVxuICBzZXRWYWx1ZShuZXdWYWx1ZSwgYnlUb3VjaE1vdmUpIHtcbiAgICBjb25zdCByYW5nZSA9IHRoaXM7XG4gICAgY29uc3QgeyBzdGVwLCBtaW4sIG1heCB9ID0gcmFuZ2U7XG4gICAgbGV0IHZhbHVlQ2hhbmdlZDtcbiAgICBsZXQgb2xkVmFsdWU7XG4gICAgaWYgKHJhbmdlLmR1YWwpIHtcbiAgICAgIG9sZFZhbHVlID0gW3JhbmdlLnZhbHVlWzBdLCByYW5nZS52YWx1ZVsxXV07XG4gICAgICBsZXQgbmV3VmFsdWVzID0gbmV3VmFsdWU7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkobmV3VmFsdWVzKSkgbmV3VmFsdWVzID0gW25ld1ZhbHVlLCBuZXdWYWx1ZV07XG4gICAgICBpZiAobmV3VmFsdWVbMF0gPiBuZXdWYWx1ZVsxXSkge1xuICAgICAgICBuZXdWYWx1ZXMgPSBbbmV3VmFsdWVzWzBdLCBuZXdWYWx1ZXNbMF1dO1xuICAgICAgfVxuICAgICAgbmV3VmFsdWVzID0gbmV3VmFsdWVzLm1hcCh2YWx1ZSA9PiBNYXRoLm1heChNYXRoLm1pbihNYXRoLnJvdW5kKHZhbHVlIC8gc3RlcCkgKiBzdGVwLCBtYXgpLCBtaW4pKTtcbiAgICAgIGlmIChuZXdWYWx1ZXNbMF0gPT09IHJhbmdlLnZhbHVlWzBdICYmIG5ld1ZhbHVlc1sxXSA9PT0gcmFuZ2UudmFsdWVbMV0pIHtcbiAgICAgICAgcmV0dXJuIHJhbmdlO1xuICAgICAgfVxuICAgICAgbmV3VmFsdWVzLmZvckVhY2goKHZhbHVlLCB2YWx1ZUluZGV4KSA9PiB7XG4gICAgICAgIHJhbmdlLnZhbHVlW3ZhbHVlSW5kZXhdID0gdmFsdWU7XG4gICAgICB9KTtcbiAgICAgIHZhbHVlQ2hhbmdlZCA9IG9sZFZhbHVlWzBdICE9PSBuZXdWYWx1ZXNbMF0gfHwgb2xkVmFsdWVbMV0gIT09IG5ld1ZhbHVlc1sxXTtcbiAgICAgIHJhbmdlLmxheW91dCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvbGRWYWx1ZSA9IHJhbmdlLnZhbHVlO1xuICAgICAgY29uc3QgdmFsdWUgPSBNYXRoLm1heChNYXRoLm1pbihNYXRoLnJvdW5kKG5ld1ZhbHVlIC8gc3RlcCkgKiBzdGVwLCBtYXgpLCBtaW4pO1xuICAgICAgcmFuZ2UudmFsdWUgPSB2YWx1ZTtcbiAgICAgIHJhbmdlLmxheW91dCgpO1xuICAgICAgdmFsdWVDaGFuZ2VkID0gb2xkVmFsdWUgIT09IHZhbHVlO1xuICAgIH1cblxuICAgIGlmICh2YWx1ZUNoYW5nZWQpIHtcbiAgICAgIHJhbmdlLnByZXZpb3VzVmFsdWUgPSBvbGRWYWx1ZTtcbiAgICB9XG4gICAgLy8gRXZlbnRzXG4gICAgaWYgKCF2YWx1ZUNoYW5nZWQpIHJldHVybiByYW5nZTtcbiAgICByYW5nZS4kZWwudHJpZ2dlcigncmFuZ2U6Y2hhbmdlJywgcmFuZ2UsIHJhbmdlLnZhbHVlKTtcbiAgICBpZiAocmFuZ2UuJGlucHV0RWwgJiYgIXJhbmdlLmR1YWwpIHtcbiAgICAgIHJhbmdlLiRpbnB1dEVsLnZhbChyYW5nZS52YWx1ZSk7XG4gICAgICBpZiAoIWJ5VG91Y2hNb3ZlKSB7XG4gICAgICAgIHJhbmdlLiRpbnB1dEVsLnRyaWdnZXIoJ2lucHV0IGNoYW5nZScpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmFuZ2UuJGlucHV0RWwudHJpZ2dlcignaW5wdXQnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFieVRvdWNoTW92ZSkge1xuICAgICAgcmFuZ2UuJGVsLnRyaWdnZXIoJ3JhbmdlOmNoYW5nZWQnLCByYW5nZSwgcmFuZ2UudmFsdWUpO1xuICAgICAgcmFuZ2UuZW1pdCgnbG9jYWw6OmNoYW5nZWQgcmFuZ2VDaGFuZ2VkJywgcmFuZ2UsIHJhbmdlLnZhbHVlKTtcbiAgICB9XG4gICAgcmFuZ2UuZW1pdCgnbG9jYWw6OmNoYW5nZSByYW5nZUNoYW5nZScsIHJhbmdlLCByYW5nZS52YWx1ZSk7XG4gICAgcmV0dXJuIHJhbmdlO1xuICB9XG4gIGdldFZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICB9XG4gIGluaXQoKSB7XG4gICAgY29uc3QgcmFuZ2UgPSB0aGlzO1xuICAgIHJhbmdlLmNhbGNTaXplKCk7XG4gICAgcmFuZ2UubGF5b3V0KCk7XG4gICAgcmFuZ2UuYXR0YWNoRXZlbnRzKCk7XG4gICAgcmV0dXJuIHJhbmdlO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgbGV0IHJhbmdlID0gdGhpcztcbiAgICByYW5nZS4kZWwudHJpZ2dlcigncmFuZ2U6YmVmb3JlZGVzdHJveScsIHJhbmdlKTtcbiAgICByYW5nZS5lbWl0KCdsb2NhbDo6YmVmb3JlRGVzdHJveSByYW5nZUJlZm9yZURlc3Ryb3knLCByYW5nZSk7XG4gICAgZGVsZXRlIHJhbmdlLiRlbFswXS5mN1JhbmdlO1xuICAgIHJhbmdlLmRldGFjaEV2ZW50cygpO1xuICAgIFV0aWxzLmRlbGV0ZVByb3BzKHJhbmdlKTtcbiAgICByYW5nZSA9IG51bGw7XG4gIH1cbn1cblxudmFyIFJhbmdlJDEgPSB7XG4gIG5hbWU6ICdyYW5nZScsXG4gIGNyZWF0ZSgpIHtcbiAgICBjb25zdCBhcHAgPSB0aGlzO1xuICAgIGFwcC5yYW5nZSA9IFV0aWxzLmV4dGVuZChcbiAgICAgIENvbnN0cnVjdG9yTWV0aG9kcyh7XG4gICAgICAgIGRlZmF1bHRTZWxlY3RvcjogJy5yYW5nZS1zbGlkZXInLFxuICAgICAgICBjb25zdHJ1Y3RvcjogUmFuZ2UsXG4gICAgICAgIGFwcCxcbiAgICAgICAgZG9tUHJvcDogJ2Y3UmFuZ2UnLFxuICAgICAgfSksXG4gICAgICB7XG4gICAgICAgIGdldFZhbHVlKGVsID0gJy5yYW5nZS1zbGlkZXInKSB7XG4gICAgICAgICAgY29uc3QgcmFuZ2UgPSBhcHAucmFuZ2UuZ2V0KGVsKTtcbiAgICAgICAgICBpZiAocmFuZ2UpIHJldHVybiByYW5nZS5nZXRWYWx1ZSgpO1xuICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH0sXG4gICAgICAgIHNldFZhbHVlKGVsID0gJy5yYW5nZS1zbGlkZXInLCB2YWx1ZSkge1xuICAgICAgICAgIGNvbnN0IHJhbmdlID0gYXBwLnJhbmdlLmdldChlbCk7XG4gICAgICAgICAgaWYgKHJhbmdlKSByZXR1cm4gcmFuZ2Uuc2V0VmFsdWUodmFsdWUpO1xuICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH0sXG4gICAgICB9XG4gICAgKTtcbiAgfSxcbiAgc3RhdGljOiB7XG4gICAgUmFuZ2UsXG4gIH0sXG4gIG9uOiB7XG4gICAgdGFiTW91bnRlZCh0YWJFbCkge1xuICAgICAgY29uc3QgYXBwID0gdGhpcztcbiAgICAgICQodGFiRWwpLmZpbmQoJy5yYW5nZS1zbGlkZXItaW5pdCcpLmVhY2goKGluZGV4LCByYW5nZUVsKSA9PiBuZXcgUmFuZ2UoYXBwLCB7XG4gICAgICAgIGVsOiByYW5nZUVsLFxuICAgICAgfSkpO1xuICAgIH0sXG4gICAgdGFiQmVmb3JlUmVtb3ZlKHRhYkVsKSB7XG4gICAgICAkKHRhYkVsKS5maW5kKCcucmFuZ2Utc2xpZGVyLWluaXQnKS5lYWNoKChpbmRleCwgcmFuZ2VFbCkgPT4ge1xuICAgICAgICBpZiAocmFuZ2VFbC5mN1JhbmdlKSByYW5nZUVsLmY3UmFuZ2UuZGVzdHJveSgpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBwYWdlSW5pdChwYWdlKSB7XG4gICAgICBjb25zdCBhcHAgPSB0aGlzO1xuICAgICAgcGFnZS4kZWwuZmluZCgnLnJhbmdlLXNsaWRlci1pbml0JykuZWFjaCgoaW5kZXgsIHJhbmdlRWwpID0+IG5ldyBSYW5nZShhcHAsIHtcbiAgICAgICAgZWw6IHJhbmdlRWwsXG4gICAgICB9KSk7XG4gICAgfSxcbiAgICBwYWdlQmVmb3JlUmVtb3ZlKHBhZ2UpIHtcbiAgICAgIHBhZ2UuJGVsLmZpbmQoJy5yYW5nZS1zbGlkZXItaW5pdCcpLmVhY2goKGluZGV4LCByYW5nZUVsKSA9PiB7XG4gICAgICAgIGlmIChyYW5nZUVsLmY3UmFuZ2UpIHJhbmdlRWwuZjdSYW5nZS5kZXN0cm95KCk7XG4gICAgICB9KTtcbiAgICB9LFxuICB9LFxufTtcblxuY2xhc3MgU3RlcHBlciBleHRlbmRzIEZyYW1ld29yazdDbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGFwcCwgcGFyYW1zKSB7XG4gICAgc3VwZXIocGFyYW1zLCBbYXBwXSk7XG4gICAgY29uc3Qgc3RlcHBlciA9IHRoaXM7XG5cbiAgICBjb25zdCBkZWZhdWx0cyA9IHtcbiAgICAgIGVsOiBudWxsLFxuICAgICAgaW5wdXRFbDogbnVsbCxcbiAgICAgIHZhbHVlRWw6IG51bGwsXG4gICAgICB2YWx1ZTogMCxcbiAgICAgIGZvcm1hdFZhbHVlOiBudWxsLFxuICAgICAgc3RlcDogMSxcbiAgICAgIG1pbjogMCxcbiAgICAgIG1heDogMTAwLFxuICAgICAgd2F0Y2hJbnB1dDogdHJ1ZSxcbiAgICAgIGF1dG9yZXBlYXQ6IGZhbHNlLFxuICAgICAgYXV0b3JlcGVhdER5bmFtaWM6IGZhbHNlLFxuICAgICAgd3JhcHM6IGZhbHNlLFxuICAgIH07XG5cbiAgICAvLyBFeHRlbmQgZGVmYXVsdHMgd2l0aCBtb2R1bGVzIHBhcmFtc1xuICAgIHN0ZXBwZXIudXNlTW9kdWxlc1BhcmFtcyhkZWZhdWx0cyk7XG5cbiAgICBzdGVwcGVyLnBhcmFtcyA9IFV0aWxzLmV4dGVuZChkZWZhdWx0cywgcGFyYW1zKTtcbiAgICBpZiAoc3RlcHBlci5wYXJhbXMudmFsdWUgPCBzdGVwcGVyLnBhcmFtcy5taW4pIHtcbiAgICAgIHN0ZXBwZXIucGFyYW1zLnZhbHVlID0gc3RlcHBlci5wYXJhbXMubWluO1xuICAgIH1cbiAgICBpZiAoc3RlcHBlci5wYXJhbXMudmFsdWUgPiBzdGVwcGVyLnBhcmFtcy5tYXgpIHtcbiAgICAgIHN0ZXBwZXIucGFyYW1zLnZhbHVlID0gc3RlcHBlci5wYXJhbXMubWF4O1xuICAgIH1cblxuICAgIGNvbnN0IGVsID0gc3RlcHBlci5wYXJhbXMuZWw7XG4gICAgaWYgKCFlbCkgcmV0dXJuIHN0ZXBwZXI7XG5cbiAgICBjb25zdCAkZWwgPSAkKGVsKTtcbiAgICBpZiAoJGVsLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHN0ZXBwZXI7XG5cbiAgICBsZXQgJGlucHV0RWw7XG4gICAgaWYgKHN0ZXBwZXIucGFyYW1zLmlucHV0RWwpIHtcbiAgICAgICRpbnB1dEVsID0gJChzdGVwcGVyLnBhcmFtcy5pbnB1dEVsKTtcbiAgICB9IGVsc2UgaWYgKCRlbC5maW5kKCcuc3RlcHBlci1pbnB1dC13cmFwJykuZmluZCgnaW5wdXQsIHRleHRhcmVhJykubGVuZ3RoKSB7XG4gICAgICAkaW5wdXRFbCA9ICRlbC5maW5kKCcuc3RlcHBlci1pbnB1dC13cmFwJykuZmluZCgnaW5wdXQsIHRleHRhcmVhJykuZXEoMCk7XG4gICAgfVxuXG4gICAgaWYgKCRpbnB1dEVsICYmICRpbnB1dEVsLmxlbmd0aCkge1xuICAgICAgKCdzdGVwIG1pbiBtYXgnKS5zcGxpdCgnICcpLmZvckVhY2goKHBhcmFtTmFtZSkgPT4ge1xuICAgICAgICBpZiAoIXBhcmFtc1twYXJhbU5hbWVdICYmICRpbnB1dEVsLmF0dHIocGFyYW1OYW1lKSkge1xuICAgICAgICAgIHN0ZXBwZXIucGFyYW1zW3BhcmFtTmFtZV0gPSBwYXJzZUZsb2F0KCRpbnB1dEVsLmF0dHIocGFyYW1OYW1lKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBpbnB1dFZhbHVlID0gcGFyc2VGbG9hdCgkaW5wdXRFbC52YWwoKSk7XG4gICAgICBpZiAodHlwZW9mIHBhcmFtcy52YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgJiYgIU51bWJlci5pc05hTihpbnB1dFZhbHVlKSAmJiAoaW5wdXRWYWx1ZSB8fCBpbnB1dFZhbHVlID09PSAwKSkge1xuICAgICAgICBzdGVwcGVyLnBhcmFtcy52YWx1ZSA9IGlucHV0VmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0ICR2YWx1ZUVsO1xuICAgIGlmIChzdGVwcGVyLnBhcmFtcy52YWx1ZUVsKSB7XG4gICAgICAkdmFsdWVFbCA9ICQoc3RlcHBlci5wYXJhbXMudmFsdWVFbCk7XG4gICAgfSBlbHNlIGlmICgkZWwuZmluZCgnLnN0ZXBwZXItdmFsdWUnKS5sZW5ndGgpIHtcbiAgICAgICR2YWx1ZUVsID0gJGVsLmZpbmQoJy5zdGVwcGVyLXZhbHVlJykuZXEoMCk7XG4gICAgfVxuXG4gICAgY29uc3QgJGJ1dHRvblBsdXNFbCA9ICRlbC5maW5kKCcuc3RlcHBlci1idXR0b24tcGx1cycpO1xuICAgIGNvbnN0ICRidXR0b25NaW51c0VsID0gJGVsLmZpbmQoJy5zdGVwcGVyLWJ1dHRvbi1taW51cycpO1xuXG4gICAgY29uc3QgeyBzdGVwLCBtaW4sIG1heCwgdmFsdWUgfSA9IHN0ZXBwZXIucGFyYW1zO1xuXG4gICAgVXRpbHMuZXh0ZW5kKHN0ZXBwZXIsIHtcbiAgICAgIGFwcCxcbiAgICAgICRlbCxcbiAgICAgIGVsOiAkZWxbMF0sXG4gICAgICAkYnV0dG9uUGx1c0VsLFxuICAgICAgYnV0dG9uUGx1c0VsOiAkYnV0dG9uUGx1c0VsWzBdLFxuICAgICAgJGJ1dHRvbk1pbnVzRWwsXG4gICAgICBidXR0b25NaW51c0VsOiAkYnV0dG9uTWludXNFbFswXSxcbiAgICAgICRpbnB1dEVsLFxuICAgICAgaW5wdXRFbDogJGlucHV0RWwgPyAkaW5wdXRFbFswXSA6IHVuZGVmaW5lZCxcbiAgICAgICR2YWx1ZUVsLFxuICAgICAgdmFsdWVFbDogJHZhbHVlRWwgPyAkdmFsdWVFbFswXSA6IHVuZGVmaW5lZCxcbiAgICAgIHN0ZXAsXG4gICAgICBtaW4sXG4gICAgICBtYXgsXG4gICAgICB2YWx1ZSxcbiAgICB9KTtcblxuICAgICRlbFswXS5mN1N0ZXBwZXIgPSBzdGVwcGVyO1xuXG4gICAgLy8gSGFuZGxlIEV2ZW50c1xuICAgIGNvbnN0IHRvdWNoZXNTdGFydCA9IHt9O1xuICAgIGxldCBpc1RvdWNoZWQ7XG4gICAgbGV0IGlzU2Nyb2xsaW5nO1xuICAgIGxldCBwcmV2ZW50QnV0dG9uQ2xpY2s7XG4gICAgbGV0IGludGVydmFsSWQ7XG4gICAgbGV0IHRpbWVvdXRJZDtcbiAgICBsZXQgYXV0b3JlcGVhdEFjdGlvbiA9IG51bGw7XG4gICAgbGV0IGF1dG9yZXBlYXRJbkFjdGlvbiA9IGZhbHNlO1xuXG4gICAgZnVuY3Rpb24gZHluYW1pY1JlcGVhdChjdXJyZW50LCBwcm9ncmVzc2lvbnMsIHN0YXJ0c0luLCBwcm9ncmVzc2lvblN0ZXAsIHJlcGVhdEV2ZXJ5LCBhY3Rpb24pIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgdGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmIChjdXJyZW50ID09PSAxKSB7XG4gICAgICAgICAgcHJldmVudEJ1dHRvbkNsaWNrID0gdHJ1ZTtcbiAgICAgICAgICBhdXRvcmVwZWF0SW5BY3Rpb24gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWxJZCk7XG4gICAgICAgIGFjdGlvbigpO1xuICAgICAgICBpbnRlcnZhbElkID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICAgIGFjdGlvbigpO1xuICAgICAgICB9LCByZXBlYXRFdmVyeSk7XG4gICAgICAgIGlmIChjdXJyZW50IDwgcHJvZ3Jlc3Npb25zKSB7XG4gICAgICAgICAgZHluYW1pY1JlcGVhdChjdXJyZW50ICsgMSwgcHJvZ3Jlc3Npb25zLCBzdGFydHNJbiwgcHJvZ3Jlc3Npb25TdGVwLCByZXBlYXRFdmVyeSAvIDIsIGFjdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH0sIGN1cnJlbnQgPT09IDEgPyBzdGFydHNJbiA6IHByb2dyZXNzaW9uU3RlcCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25Ub3VjaFN0YXJ0KGUpIHtcbiAgICAgIGlmIChpc1RvdWNoZWQpIHJldHVybjtcbiAgICAgIGlmICgkKGUudGFyZ2V0KS5jbG9zZXN0KCRidXR0b25QbHVzRWwpLmxlbmd0aCkge1xuICAgICAgICBhdXRvcmVwZWF0QWN0aW9uID0gJ2luY3JlbWVudCc7XG4gICAgICB9IGVsc2UgaWYgKCQoZS50YXJnZXQpLmNsb3Nlc3QoJGJ1dHRvbk1pbnVzRWwpLmxlbmd0aCkge1xuICAgICAgICBhdXRvcmVwZWF0QWN0aW9uID0gJ2RlY3JlbWVudCc7XG4gICAgICB9XG4gICAgICBpZiAoIWF1dG9yZXBlYXRBY3Rpb24pIHJldHVybjtcblxuICAgICAgdG91Y2hlc1N0YXJ0LnggPSBlLnR5cGUgPT09ICd0b3VjaHN0YXJ0JyA/IGUudGFyZ2V0VG91Y2hlc1swXS5wYWdlWCA6IGUucGFnZVg7XG4gICAgICB0b3VjaGVzU3RhcnQueSA9IGUudHlwZSA9PT0gJ3RvdWNoc3RhcnQnID8gZS50YXJnZXRUb3VjaGVzWzBdLnBhZ2VZIDogZS5wYWdlWTtcbiAgICAgIGlzVG91Y2hlZCA9IHRydWU7XG4gICAgICBpc1Njcm9sbGluZyA9IHVuZGVmaW5lZDtcblxuICAgICAgY29uc3QgcHJvZ3Jlc3Npb25zID0gc3RlcHBlci5wYXJhbXMuYXV0b3JlcGVhdER5bmFtaWMgPyA0IDogMTtcbiAgICAgIGR5bmFtaWNSZXBlYXQoMSwgcHJvZ3Jlc3Npb25zLCA1MDAsIDEwMDAsIDMwMCwgKCkgPT4ge1xuICAgICAgICBzdGVwcGVyW2F1dG9yZXBlYXRBY3Rpb25dKCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gb25Ub3VjaE1vdmUoZSkge1xuICAgICAgaWYgKCFpc1RvdWNoZWQpIHJldHVybjtcbiAgICAgIGNvbnN0IHBhZ2VYID0gZS50eXBlID09PSAndG91Y2htb3ZlJyA/IGUudGFyZ2V0VG91Y2hlc1swXS5wYWdlWCA6IGUucGFnZVg7XG4gICAgICBjb25zdCBwYWdlWSA9IGUudHlwZSA9PT0gJ3RvdWNobW92ZScgPyBlLnRhcmdldFRvdWNoZXNbMF0ucGFnZVkgOiBlLnBhZ2VZO1xuXG4gICAgICBpZiAodHlwZW9mIGlzU2Nyb2xsaW5nID09PSAndW5kZWZpbmVkJyAmJiAhYXV0b3JlcGVhdEluQWN0aW9uKSB7XG4gICAgICAgIGlzU2Nyb2xsaW5nID0gISEoaXNTY3JvbGxpbmcgfHwgTWF0aC5hYnMocGFnZVkgLSB0b3VjaGVzU3RhcnQueSkgPiBNYXRoLmFicyhwYWdlWCAtIHRvdWNoZXNTdGFydC54KSk7XG4gICAgICB9XG4gICAgICBjb25zdCBkaXN0YW5jZSA9ICgoKHBhZ2VYIC0gdG91Y2hlc1N0YXJ0LngpICoqIDIpICsgKChwYWdlWSAtIHRvdWNoZXNTdGFydC55KSAqKiAyKSkgKiogMC41O1xuXG4gICAgICBpZiAoaXNTY3JvbGxpbmcgfHwgZGlzdGFuY2UgPiAyMCkge1xuICAgICAgICBpc1RvdWNoZWQgPSBmYWxzZTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWxJZCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uVG91Y2hFbmQoKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWxJZCk7XG4gICAgICBhdXRvcmVwZWF0QWN0aW9uID0gbnVsbDtcbiAgICAgIGF1dG9yZXBlYXRJbkFjdGlvbiA9IGZhbHNlO1xuICAgICAgaXNUb3VjaGVkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25NaW51c0NsaWNrKCkge1xuICAgICAgaWYgKHByZXZlbnRCdXR0b25DbGljaykge1xuICAgICAgICBwcmV2ZW50QnV0dG9uQ2xpY2sgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc3RlcHBlci5kZWNyZW1lbnQoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gb25QbHVzQ2xpY2soKSB7XG4gICAgICBpZiAocHJldmVudEJ1dHRvbkNsaWNrKSB7XG4gICAgICAgIHByZXZlbnRCdXR0b25DbGljayA9IGZhbHNlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzdGVwcGVyLmluY3JlbWVudCgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvbklucHV0KGUpIHtcbiAgICAgIGlmIChlLmRldGFpbCAmJiBlLmRldGFpbC5zZW50QnlGN1N0ZXBwZXIpIHJldHVybjtcbiAgICAgIHN0ZXBwZXIuc2V0VmFsdWUoZS50YXJnZXQudmFsdWUsIHRydWUpO1xuICAgIH1cbiAgICBzdGVwcGVyLmF0dGFjaEV2ZW50cyA9IGZ1bmN0aW9uIGF0dGFjaEV2ZW50cygpIHtcbiAgICAgICRidXR0b25NaW51c0VsLm9uKCdjbGljaycsIG9uTWludXNDbGljayk7XG4gICAgICAkYnV0dG9uUGx1c0VsLm9uKCdjbGljaycsIG9uUGx1c0NsaWNrKTtcbiAgICAgIGlmIChzdGVwcGVyLnBhcmFtcy53YXRjaElucHV0ICYmICRpbnB1dEVsICYmICRpbnB1dEVsLmxlbmd0aCkge1xuICAgICAgICAkaW5wdXRFbC5vbignaW5wdXQnLCBvbklucHV0KTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGVwcGVyLnBhcmFtcy5hdXRvcmVwZWF0KSB7XG4gICAgICAgIGFwcC5vbigndG91Y2hzdGFydDpwYXNzaXZlJywgb25Ub3VjaFN0YXJ0KTtcbiAgICAgICAgYXBwLm9uKCd0b3VjaG1vdmU6YWN0aXZlJywgb25Ub3VjaE1vdmUpO1xuICAgICAgICBhcHAub24oJ3RvdWNoZW5kOnBhc3NpdmUnLCBvblRvdWNoRW5kKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHN0ZXBwZXIuZGV0YWNoRXZlbnRzID0gZnVuY3Rpb24gZGV0YWNoRXZlbnRzKCkge1xuICAgICAgJGJ1dHRvbk1pbnVzRWwub2ZmKCdjbGljaycsIG9uTWludXNDbGljayk7XG4gICAgICAkYnV0dG9uUGx1c0VsLm9mZignY2xpY2snLCBvblBsdXNDbGljayk7XG4gICAgICBpZiAoc3RlcHBlci5wYXJhbXMud2F0Y2hJbnB1dCAmJiAkaW5wdXRFbCAmJiAkaW5wdXRFbC5sZW5ndGgpIHtcbiAgICAgICAgJGlucHV0RWwub2ZmKCdpbnB1dCcsIG9uSW5wdXQpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBJbnN0YWxsIE1vZHVsZXNcbiAgICBzdGVwcGVyLnVzZU1vZHVsZXMoKTtcblxuICAgIC8vIEluaXRcbiAgICBzdGVwcGVyLmluaXQoKTtcblxuICAgIHJldHVybiBzdGVwcGVyO1xuICB9XG4gIG1pbnVzKCkge1xuICAgIHJldHVybiB0aGlzLmRlY3JlbWVudCgpO1xuICB9XG4gIHBsdXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5jcmVtZW50KCk7XG4gIH1cbiAgZGVjcmVtZW50KCkge1xuICAgIGNvbnN0IHN0ZXBwZXIgPSB0aGlzO1xuICAgIHJldHVybiBzdGVwcGVyLnNldFZhbHVlKHN0ZXBwZXIudmFsdWUgLSBzdGVwcGVyLnN0ZXApO1xuICB9XG4gIGluY3JlbWVudCgpIHtcbiAgICBjb25zdCBzdGVwcGVyID0gdGhpcztcbiAgICByZXR1cm4gc3RlcHBlci5zZXRWYWx1ZShzdGVwcGVyLnZhbHVlICsgc3RlcHBlci5zdGVwKTtcbiAgfVxuICBzZXRWYWx1ZShuZXdWYWx1ZSwgZm9yY2VVcGRhdGUpIHtcbiAgICBjb25zdCBzdGVwcGVyID0gdGhpcztcbiAgICBjb25zdCB7IHN0ZXAsIG1pbiwgbWF4IH0gPSBzdGVwcGVyO1xuXG4gICAgY29uc3Qgb2xkVmFsdWUgPSBzdGVwcGVyLnZhbHVlO1xuXG4gICAgbGV0IHZhbHVlID0gTWF0aC5yb3VuZChuZXdWYWx1ZSAvIHN0ZXApICogc3RlcDtcbiAgICBpZiAoIXN0ZXBwZXIucGFyYW1zLndyYXBzKSB7XG4gICAgICB2YWx1ZSA9IE1hdGgubWF4KE1hdGgubWluKHZhbHVlLCBtYXgpLCBtaW4pO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodmFsdWUgPiBtYXgpIHZhbHVlID0gbWluO1xuICAgICAgaWYgKHZhbHVlIDwgbWluKSB2YWx1ZSA9IG1heDtcbiAgICB9XG4gICAgaWYgKE51bWJlci5pc05hTih2YWx1ZSkpIHtcbiAgICAgIHZhbHVlID0gb2xkVmFsdWU7XG4gICAgfVxuICAgIHN0ZXBwZXIudmFsdWUgPSB2YWx1ZTtcblxuICAgIGNvbnN0IHZhbHVlQ2hhbmdlZCA9IG9sZFZhbHVlICE9PSB2YWx1ZTtcblxuICAgIC8vIEV2ZW50c1xuICAgIGlmICghdmFsdWVDaGFuZ2VkICYmICFmb3JjZVVwZGF0ZSkgcmV0dXJuIHN0ZXBwZXI7XG4gICAgc3RlcHBlci4kZWwudHJpZ2dlcignc3RlcHBlcjpjaGFuZ2UnLCBzdGVwcGVyLCBzdGVwcGVyLnZhbHVlKTtcbiAgICBjb25zdCBmb3JtYXR0ZWRWYWx1ZSA9IHN0ZXBwZXIuZm9ybWF0VmFsdWUoc3RlcHBlci52YWx1ZSk7XG4gICAgaWYgKHN0ZXBwZXIuJGlucHV0RWwgJiYgc3RlcHBlci4kaW5wdXRFbC5sZW5ndGgpIHtcbiAgICAgIHN0ZXBwZXIuJGlucHV0RWwudmFsKGZvcm1hdHRlZFZhbHVlKTtcbiAgICAgIHN0ZXBwZXIuJGlucHV0RWwudHJpZ2dlcignaW5wdXQgY2hhbmdlJywgeyBzZW50QnlGN1N0ZXBwZXI6IHRydWUgfSk7XG4gICAgfVxuICAgIGlmIChzdGVwcGVyLiR2YWx1ZUVsICYmIHN0ZXBwZXIuJHZhbHVlRWwubGVuZ3RoKSB7XG4gICAgICBzdGVwcGVyLiR2YWx1ZUVsLmh0bWwoZm9ybWF0dGVkVmFsdWUpO1xuICAgIH1cbiAgICBzdGVwcGVyLmVtaXQoJ2xvY2FsOjpjaGFuZ2Ugc3RlcHBlckNoYW5nZScsIHN0ZXBwZXIsIHN0ZXBwZXIudmFsdWUpO1xuICAgIHJldHVybiBzdGVwcGVyO1xuICB9XG4gIGdldFZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICB9XG4gIGZvcm1hdFZhbHVlKHZhbHVlKSB7XG4gICAgY29uc3Qgc3RlcHBlciA9IHRoaXM7XG4gICAgaWYgKCFzdGVwcGVyLnBhcmFtcy5mb3JtYXRWYWx1ZSkgcmV0dXJuIHZhbHVlO1xuICAgIHJldHVybiBzdGVwcGVyLnBhcmFtcy5mb3JtYXRWYWx1ZS5jYWxsKHN0ZXBwZXIsIHZhbHVlKTtcbiAgfVxuICBpbml0KCkge1xuICAgIGNvbnN0IHN0ZXBwZXIgPSB0aGlzO1xuICAgIHN0ZXBwZXIuYXR0YWNoRXZlbnRzKCk7XG4gICAgaWYgKHN0ZXBwZXIuJHZhbHVlRWwgJiYgc3RlcHBlci4kdmFsdWVFbC5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGZvcm1hdHRlZFZhbHVlID0gc3RlcHBlci5mb3JtYXRWYWx1ZShzdGVwcGVyLnZhbHVlKTtcbiAgICAgIHN0ZXBwZXIuJHZhbHVlRWwuaHRtbChmb3JtYXR0ZWRWYWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBzdGVwcGVyO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgbGV0IHN0ZXBwZXIgPSB0aGlzO1xuICAgIHN0ZXBwZXIuJGVsLnRyaWdnZXIoJ3N0ZXBwZXI6YmVmb3JlZGVzdHJveScsIHN0ZXBwZXIpO1xuICAgIHN0ZXBwZXIuZW1pdCgnbG9jYWw6OmJlZm9yZURlc3Ryb3kgc3RlcHBlckJlZm9yZURlc3Ryb3knLCBzdGVwcGVyKTtcbiAgICBkZWxldGUgc3RlcHBlci4kZWxbMF0uZjdTdGVwcGVyO1xuICAgIHN0ZXBwZXIuZGV0YWNoRXZlbnRzKCk7XG4gICAgVXRpbHMuZGVsZXRlUHJvcHMoc3RlcHBlcik7XG4gICAgc3RlcHBlciA9IG51bGw7XG4gIH1cbn1cblxudmFyIFN0ZXBwZXIkMSA9IHtcbiAgbmFtZTogJ3N0ZXBwZXInLFxuICBjcmVhdGUoKSB7XG4gICAgY29uc3QgYXBwID0gdGhpcztcbiAgICBhcHAuc3RlcHBlciA9IFV0aWxzLmV4dGVuZChcbiAgICAgIENvbnN0cnVjdG9yTWV0aG9kcyh7XG4gICAgICAgIGRlZmF1bHRTZWxlY3RvcjogJy5zdGVwcGVyJyxcbiAgICAgICAgY29uc3RydWN0b3I6IFN0ZXBwZXIsXG4gICAgICAgIGFwcCxcbiAgICAgICAgZG9tUHJvcDogJ2Y3U3RlcHBlcicsXG4gICAgICB9KSxcbiAgICAgIHtcbiAgICAgICAgZ2V0VmFsdWUoZWwgPSAnLnN0ZXBwZXInKSB7XG4gICAgICAgICAgY29uc3Qgc3RlcHBlciA9IGFwcC5zdGVwcGVyLmdldChlbCk7XG4gICAgICAgICAgaWYgKHN0ZXBwZXIpIHJldHVybiBzdGVwcGVyLmdldFZhbHVlKCk7XG4gICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0VmFsdWUoZWwgPSAnLnN0ZXBwZXInLCB2YWx1ZSkge1xuICAgICAgICAgIGNvbnN0IHN0ZXBwZXIgPSBhcHAuc3RlcHBlci5nZXQoZWwpO1xuICAgICAgICAgIGlmIChzdGVwcGVyKSByZXR1cm4gc3RlcHBlci5zZXRWYWx1ZSh2YWx1ZSk7XG4gICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfSxcbiAgICAgIH1cbiAgICApO1xuICB9LFxuICBzdGF0aWM6IHtcbiAgICBTdGVwcGVyLFxuICB9LFxuICBvbjoge1xuICAgIHRhYk1vdW50ZWQodGFiRWwpIHtcbiAgICAgIGNvbnN0IGFwcCA9IHRoaXM7XG4gICAgICAkKHRhYkVsKS5maW5kKCcuc3RlcHBlci1pbml0JykuZWFjaCgoaW5kZXgsIHN0ZXBwZXJFbCkgPT4ge1xuICAgICAgICBjb25zdCBkYXRhc2V0ID0gJChzdGVwcGVyRWwpLmRhdGFzZXQoKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgIG5ldyBTdGVwcGVyKGFwcCwgVXRpbHMuZXh0ZW5kKHsgZWw6IHN0ZXBwZXJFbCB9LCBkYXRhc2V0IHx8IHt9KSk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIHRhYkJlZm9yZVJlbW92ZSh0YWJFbCkge1xuICAgICAgJCh0YWJFbCkuZmluZCgnLnN0ZXBwZXItaW5pdCcpLmVhY2goKGluZGV4LCBzdGVwcGVyRWwpID0+IHtcbiAgICAgICAgaWYgKHN0ZXBwZXJFbC5mN1N0ZXBwZXIpIHN0ZXBwZXJFbC5mN1N0ZXBwZXIuZGVzdHJveSgpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBwYWdlSW5pdChwYWdlKSB7XG4gICAgICBjb25zdCBhcHAgPSB0aGlzO1xuICAgICAgcGFnZS4kZWwuZmluZCgnLnN0ZXBwZXItaW5pdCcpLmVhY2goKGluZGV4LCBzdGVwcGVyRWwpID0+IHtcbiAgICAgICAgY29uc3QgZGF0YXNldCA9ICQoc3RlcHBlckVsKS5kYXRhc2V0KCk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICBuZXcgU3RlcHBlcihhcHAsIFV0aWxzLmV4dGVuZCh7IGVsOiBzdGVwcGVyRWwgfSwgZGF0YXNldCB8fCB7fSkpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBwYWdlQmVmb3JlUmVtb3ZlKHBhZ2UpIHtcbiAgICAgIHBhZ2UuJGVsLmZpbmQoJy5zdGVwcGVyLWluaXQnKS5lYWNoKChpbmRleCwgc3RlcHBlckVsKSA9PiB7XG4gICAgICAgIGlmIChzdGVwcGVyRWwuZjdTdGVwcGVyKSBzdGVwcGVyRWwuZjdTdGVwcGVyLmRlc3Ryb3koKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gIH0sXG59O1xuXG5jbGFzcyBTbWFydFNlbGVjdCBleHRlbmRzIEZyYW1ld29yazdDbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGFwcCwgcGFyYW1zID0ge30pIHtcbiAgICBzdXBlcihwYXJhbXMsIFthcHBdKTtcbiAgICBjb25zdCBzcyA9IHRoaXM7XG4gICAgc3MuYXBwID0gYXBwO1xuICAgIGNvbnN0IGRlZmF1bHRzID0gVXRpbHMuZXh0ZW5kKHtcbiAgICAgIG9uOiB7fSxcbiAgICB9LCBhcHAucGFyYW1zLnNtYXJ0U2VsZWN0KTtcblxuICAgIGNvbnN0ICRlbCA9ICQocGFyYW1zLmVsKS5lcSgwKTtcbiAgICBpZiAoJGVsLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHNzO1xuXG4gICAgY29uc3QgJHNlbGVjdEVsID0gJGVsLmZpbmQoJ3NlbGVjdCcpLmVxKDApO1xuICAgIGlmICgkc2VsZWN0RWwubGVuZ3RoID09PSAwKSByZXR1cm4gc3M7XG5cbiAgICBsZXQgJHZhbHVlRWwgPSAkKHBhcmFtcy52YWx1ZUVsKTtcbiAgICBpZiAoJHZhbHVlRWwubGVuZ3RoID09PSAwKSB7XG4gICAgICAkdmFsdWVFbCA9ICQoJzxkaXYgY2xhc3M9XCJpdGVtLWFmdGVyXCI+PC9kaXY+Jyk7XG4gICAgICAkdmFsdWVFbC5pbnNlcnRBZnRlcigkZWwuZmluZCgnLml0ZW0tdGl0bGUnKSk7XG4gICAgfVxuXG4gICAgLy8gRXh0ZW5kIGRlZmF1bHRzIHdpdGggbW9kdWxlcyBwYXJhbXNcbiAgICBzcy51c2VNb2R1bGVzUGFyYW1zKGRlZmF1bHRzKTtcblxuICAgIC8vIFZpZXdcbiAgICBsZXQgdmlldyA9IHBhcmFtcy52aWV3O1xuICAgIGlmICghdmlldykge1xuICAgICAgdmlldyA9ICRlbC5wYXJlbnRzKCcudmlldycpLmxlbmd0aCAmJiAkZWwucGFyZW50cygnLnZpZXcnKVswXS5mN1ZpZXc7XG4gICAgfVxuICAgIGlmICghdmlldykge1xuICAgICAgdGhyb3cgRXJyb3IoJ1NtYXJ0IFNlbGVjdCByZXF1aXJlcyBpbml0aWFsaXplZCBWaWV3Jyk7XG4gICAgfVxuXG4gICAgLy8gVXJsXG4gICAgbGV0IHVybCA9IHBhcmFtcy51cmw7XG4gICAgaWYgKCF1cmwpIHtcbiAgICAgIGlmICgkZWwuYXR0cignaHJlZicpICYmICRlbC5hdHRyKCdocmVmJykgIT09ICcjJykgdXJsID0gJGVsLmF0dHIoJ2hyZWYnKTtcbiAgICAgIGVsc2UgdXJsID0gYCR7JHNlbGVjdEVsLmF0dHIoJ25hbWUnKS50b0xvd2VyQ2FzZSgpfS1zZWxlY3QvYDtcbiAgICB9XG4gICAgaWYgKCF1cmwpIHVybCA9IHNzLnBhcmFtcy51cmw7XG5cbiAgICBjb25zdCBtdWx0aXBsZSA9ICRzZWxlY3RFbFswXS5tdWx0aXBsZTtcbiAgICBjb25zdCBpbnB1dFR5cGUgPSBtdWx0aXBsZSA/ICdjaGVja2JveCcgOiAncmFkaW8nO1xuICAgIGNvbnN0IGlkID0gVXRpbHMubm93KCk7XG4gICAgVXRpbHMuZXh0ZW5kKHNzLCB7XG4gICAgICBwYXJhbXM6IFV0aWxzLmV4dGVuZChkZWZhdWx0cywgcGFyYW1zKSxcbiAgICAgICRlbCxcbiAgICAgIGVsOiAkZWxbMF0sXG4gICAgICAkc2VsZWN0RWwsXG4gICAgICBzZWxlY3RFbDogJHNlbGVjdEVsWzBdLFxuICAgICAgJHZhbHVlRWwsXG4gICAgICB2YWx1ZUVsOiAkdmFsdWVFbFswXSxcbiAgICAgIHVybCxcbiAgICAgIG11bHRpcGxlLFxuICAgICAgaW5wdXRUeXBlLFxuICAgICAgaWQsXG4gICAgICB2aWV3LFxuICAgICAgaW5wdXROYW1lOiBgJHtpbnB1dFR5cGV9LSR7aWR9YCxcbiAgICAgIHNlbGVjdE5hbWU6ICRzZWxlY3RFbC5hdHRyKCduYW1lJyksXG4gICAgICBtYXhMZW5ndGg6ICRzZWxlY3RFbC5hdHRyKCdtYXhsZW5ndGgnKSB8fCBwYXJhbXMubWF4TGVuZ3RoLFxuICAgIH0pO1xuICAgICRlbFswXS5mN1NtYXJ0U2VsZWN0ID0gc3M7XG5cbiAgICAvLyBFdmVudHNcbiAgICBmdW5jdGlvbiBvbkNsaWNrKCkge1xuICAgICAgc3Mub3BlbigpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvbkNoYW5nZSgpIHtcbiAgICAgIHNzLnNldFZhbHVlKCk7XG4gICAgfVxuICAgIHNzLmF0dGFjaEV2ZW50cyA9IGZ1bmN0aW9uIGF0dGFjaEV2ZW50cygpIHtcbiAgICAgICRlbC5vbignY2xpY2snLCBvbkNsaWNrKTtcbiAgICAgICRlbC5vbignY2hhbmdlJywgJ3NlbGVjdCcsIG9uQ2hhbmdlKTtcbiAgICB9O1xuICAgIHNzLmRldGFjaEV2ZW50cyA9IGZ1bmN0aW9uIGRldGFjaEV2ZW50cygpIHtcbiAgICAgICRlbC5vZmYoJ2NsaWNrJywgb25DbGljayk7XG4gICAgICAkZWwub2ZmKCdjaGFuZ2UnLCAnc2VsZWN0Jywgb25DaGFuZ2UpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVJbnB1dENoYW5nZSgpIHtcbiAgICAgIGxldCBvcHRpb25FbDtcbiAgICAgIGxldCB0ZXh0O1xuICAgICAgY29uc3QgaW5wdXRFbCA9IHRoaXM7XG4gICAgICBjb25zdCB2YWx1ZSA9IGlucHV0RWwudmFsdWU7XG4gICAgICBsZXQgb3B0aW9uVGV4dCA9IFtdO1xuICAgICAgbGV0IGRpc3BsYXlBcztcbiAgICAgIGlmIChpbnB1dEVsLnR5cGUgPT09ICdjaGVja2JveCcpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzcy5zZWxlY3RFbC5vcHRpb25zLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgb3B0aW9uRWwgPSBzcy5zZWxlY3RFbC5vcHRpb25zW2ldO1xuICAgICAgICAgIGlmIChvcHRpb25FbC52YWx1ZSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIG9wdGlvbkVsLnNlbGVjdGVkID0gaW5wdXRFbC5jaGVja2VkO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob3B0aW9uRWwuc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIGRpc3BsYXlBcyA9IG9wdGlvbkVsLmRhdGFzZXQgPyBvcHRpb25FbC5kYXRhc2V0LmRpc3BsYXlBcyA6ICQob3B0aW9uRWwpLmRhdGEoJ2Rpc3BsYXktdmFsdWUtYXMnKTtcbiAgICAgICAgICAgIHRleHQgPSBkaXNwbGF5QXMgJiYgdHlwZW9mIGRpc3BsYXlBcyAhPT0gJ3VuZGVmaW5lZCcgPyBkaXNwbGF5QXMgOiBvcHRpb25FbC50ZXh0Q29udGVudDtcbiAgICAgICAgICAgIG9wdGlvblRleHQucHVzaCh0ZXh0LnRyaW0oKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzcy5tYXhMZW5ndGgpIHtcbiAgICAgICAgICBzcy5jaGVja01heExlbmd0aCgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcHRpb25FbCA9IHNzLiRzZWxlY3RFbC5maW5kKGBvcHRpb25bdmFsdWU9XCIke3ZhbHVlfVwiXWApWzBdO1xuICAgICAgICBkaXNwbGF5QXMgPSBvcHRpb25FbC5kYXRhc2V0ID8gb3B0aW9uRWwuZGF0YXNldC5kaXNwbGF5QXMgOiAkKG9wdGlvbkVsKS5kYXRhKCdkaXNwbGF5LWFzJyk7XG4gICAgICAgIHRleHQgPSBkaXNwbGF5QXMgJiYgdHlwZW9mIGRpc3BsYXlBcyAhPT0gJ3VuZGVmaW5lZCcgPyBkaXNwbGF5QXMgOiBvcHRpb25FbC50ZXh0Q29udGVudDtcbiAgICAgICAgb3B0aW9uVGV4dCA9IFt0ZXh0XTtcbiAgICAgICAgc3Muc2VsZWN0RWwudmFsdWUgPSB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgc3MuJHNlbGVjdEVsLnRyaWdnZXIoJ2NoYW5nZScpO1xuICAgICAgc3MuJHZhbHVlRWwudGV4dChvcHRpb25UZXh0LmpvaW4oJywgJykpO1xuICAgICAgaWYgKHNzLnBhcmFtcy5jbG9zZU9uU2VsZWN0ICYmIHNzLmlucHV0VHlwZSA9PT0gJ3JhZGlvJykge1xuICAgICAgICBzcy5jbG9zZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNzLmF0dGFjaElucHV0c0V2ZW50cyA9IGZ1bmN0aW9uIGF0dGFjaElucHV0c0V2ZW50cygpIHtcbiAgICAgIHNzLiRjb250YWluZXJFbC5vbignY2hhbmdlJywgJ2lucHV0W3R5cGU9XCJjaGVja2JveFwiXSwgaW5wdXRbdHlwZT1cInJhZGlvXCJdJywgaGFuZGxlSW5wdXRDaGFuZ2UpO1xuICAgIH07XG4gICAgc3MuZGV0YWNoSW5wdXRzRXZlbnRzID0gZnVuY3Rpb24gZGV0YWNoSW5wdXRzRXZlbnRzKCkge1xuICAgICAgc3MuJGNvbnRhaW5lckVsLm9mZignY2hhbmdlJywgJ2lucHV0W3R5cGU9XCJjaGVja2JveFwiXSwgaW5wdXRbdHlwZT1cInJhZGlvXCJdJywgaGFuZGxlSW5wdXRDaGFuZ2UpO1xuICAgIH07XG5cbiAgICAvLyBJbnN0YWxsIE1vZHVsZXNcbiAgICBzcy51c2VNb2R1bGVzKCk7XG5cbiAgICAvLyBJbml0XG4gICAgc3MuaW5pdCgpO1xuXG4gICAgcmV0dXJuIHNzO1xuICB9XG4gIGNoZWNrTWF4TGVuZ3RoKCkge1xuICAgIGNvbnN0IHNzID0gdGhpcztcbiAgICBjb25zdCAkY29udGFpbmVyRWwgPSBzcy4kY29udGFpbmVyRWw7XG4gICAgaWYgKHNzLnNlbGVjdEVsLnNlbGVjdGVkT3B0aW9ucy5sZW5ndGggPj0gc3MubWF4TGVuZ3RoKSB7XG4gICAgICAkY29udGFpbmVyRWwuZmluZCgnaW5wdXRbdHlwZT1cImNoZWNrYm94XCJdJykuZWFjaCgoaW5kZXgsIGlucHV0RWwpID0+IHtcbiAgICAgICAgaWYgKCFpbnB1dEVsLmNoZWNrZWQpIHtcbiAgICAgICAgICAkKGlucHV0RWwpLnBhcmVudHMoJ2xpJykuYWRkQ2xhc3MoJ2Rpc2FibGVkJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgJChpbnB1dEVsKS5wYXJlbnRzKCdsaScpLnJlbW92ZUNsYXNzKCdkaXNhYmxlZCcpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgJGNvbnRhaW5lckVsLmZpbmQoJy5kaXNhYmxlZCcpLnJlbW92ZUNsYXNzKCdkaXNhYmxlZCcpO1xuICAgIH1cbiAgfVxuICBzZXRWYWx1ZSh2YWx1ZSkge1xuICAgIGNvbnN0IHNzID0gdGhpcztcbiAgICBsZXQgdmFsdWVBcnJheSA9IFtdO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWVBcnJheSA9IHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWVBcnJheSA9IFt2YWx1ZV07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHNzLiRzZWxlY3RFbC5maW5kKCdvcHRpb24nKS5lYWNoKChvcHRpb25JbmRleCwgb3B0aW9uRWwpID0+IHtcbiAgICAgICAgY29uc3QgJG9wdGlvbkVsID0gJChvcHRpb25FbCk7XG4gICAgICAgIGlmIChvcHRpb25FbC5zZWxlY3RlZCkge1xuICAgICAgICAgIGNvbnN0IGRpc3BsYXlBcyA9IG9wdGlvbkVsLmRhdGFzZXQgPyBvcHRpb25FbC5kYXRhc2V0LmRpc3BsYXlBcyA6ICRvcHRpb25FbC5kYXRhKCdkaXNwbGF5LXZhbHVlLWFzJyk7XG4gICAgICAgICAgaWYgKGRpc3BsYXlBcyAmJiB0eXBlb2YgZGlzcGxheUFzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdmFsdWVBcnJheS5wdXNoKGRpc3BsYXlBcyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhbHVlQXJyYXkucHVzaChvcHRpb25FbC50ZXh0Q29udGVudC50cmltKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHNzLiR2YWx1ZUVsLnRleHQodmFsdWVBcnJheS5qb2luKCcsICcpKTtcbiAgfVxuICBnZXRJdGVtc0RhdGEoKSB7XG4gICAgY29uc3Qgc3MgPSB0aGlzO1xuICAgIGNvbnN0IGl0ZW1zID0gW107XG4gICAgbGV0IHByZXZpb3VzR3JvdXBFbDtcbiAgICBzcy4kc2VsZWN0RWwuZmluZCgnb3B0aW9uJykuZWFjaCgoaW5kZXgsIG9wdGlvbkVsKSA9PiB7XG4gICAgICBjb25zdCAkb3B0aW9uRWwgPSAkKG9wdGlvbkVsKTtcbiAgICAgIGNvbnN0IG9wdGlvbkRhdGEgPSAkb3B0aW9uRWwuZGF0YXNldCgpO1xuICAgICAgY29uc3Qgb3B0aW9uSW1hZ2UgPSBvcHRpb25EYXRhLm9wdGlvbkltYWdlIHx8IHNzLnBhcmFtcy5vcHRpb25JbWFnZTtcbiAgICAgIGNvbnN0IG9wdGlvbkljb24gPSBvcHRpb25EYXRhLm9wdGlvbkljb24gfHwgc3MucGFyYW1zLm9wdGlvbkljb247XG4gICAgICBjb25zdCBvcHRpb25IYXNNZWRpYSA9IG9wdGlvbkltYWdlIHx8IG9wdGlvbkljb247XG4gICAgICAvLyBpZiAobWF0ZXJpYWwpIG9wdGlvbkhhc01lZGlhID0gb3B0aW9uSW1hZ2UgfHwgb3B0aW9uSWNvbjtcbiAgICAgIGNvbnN0IG9wdGlvbkNvbG9yID0gb3B0aW9uRGF0YS5vcHRpb25Db2xvcjtcblxuICAgICAgbGV0IG9wdGlvbkNsYXNzTmFtZSA9IG9wdGlvbkRhdGEub3B0aW9uQ2xhc3MgfHwgJyc7XG4gICAgICBpZiAoJG9wdGlvbkVsWzBdLmRpc2FibGVkKSBvcHRpb25DbGFzc05hbWUgKz0gJyBkaXNhYmxlZCc7XG5cbiAgICAgIGNvbnN0IG9wdGlvbkdyb3VwRWwgPSAkb3B0aW9uRWwucGFyZW50KCdvcHRncm91cCcpWzBdO1xuICAgICAgY29uc3Qgb3B0aW9uR3JvdXBMYWJlbCA9IG9wdGlvbkdyb3VwRWwgJiYgb3B0aW9uR3JvdXBFbC5sYWJlbDtcbiAgICAgIGxldCBvcHRpb25Jc0xhYmVsID0gZmFsc2U7XG4gICAgICBpZiAob3B0aW9uR3JvdXBFbCAmJiBvcHRpb25Hcm91cEVsICE9PSBwcmV2aW91c0dyb3VwRWwpIHtcbiAgICAgICAgb3B0aW9uSXNMYWJlbCA9IHRydWU7XG4gICAgICAgIHByZXZpb3VzR3JvdXBFbCA9IG9wdGlvbkdyb3VwRWw7XG4gICAgICAgIGl0ZW1zLnB1c2goe1xuICAgICAgICAgIGdyb3VwTGFiZWw6IG9wdGlvbkdyb3VwTGFiZWwsXG4gICAgICAgICAgaXNMYWJlbDogb3B0aW9uSXNMYWJlbCxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpdGVtcy5wdXNoKHtcbiAgICAgICAgdmFsdWU6ICRvcHRpb25FbFswXS52YWx1ZSxcbiAgICAgICAgdGV4dDogJG9wdGlvbkVsWzBdLnRleHRDb250ZW50LnRyaW0oKSxcbiAgICAgICAgc2VsZWN0ZWQ6ICRvcHRpb25FbFswXS5zZWxlY3RlZCxcbiAgICAgICAgZ3JvdXBFbDogb3B0aW9uR3JvdXBFbCxcbiAgICAgICAgZ3JvdXBMYWJlbDogb3B0aW9uR3JvdXBMYWJlbCxcbiAgICAgICAgaW1hZ2U6IG9wdGlvbkltYWdlLFxuICAgICAgICBpY29uOiBvcHRpb25JY29uLFxuICAgICAgICBjb2xvcjogb3B0aW9uQ29sb3IsXG4gICAgICAgIGNsYXNzTmFtZTogb3B0aW9uQ2xhc3NOYW1lLFxuICAgICAgICBkaXNhYmxlZDogJG9wdGlvbkVsWzBdLmRpc2FibGVkLFxuICAgICAgICBpZDogc3MuaWQsXG4gICAgICAgIGhhc01lZGlhOiBvcHRpb25IYXNNZWRpYSxcbiAgICAgICAgY2hlY2tib3g6IHNzLmlucHV0VHlwZSA9PT0gJ2NoZWNrYm94JyxcbiAgICAgICAgcmFkaW86IHNzLmlucHV0VHlwZSA9PT0gJ3JhZGlvJyxcbiAgICAgICAgaW5wdXROYW1lOiBzcy5pbnB1dE5hbWUsXG4gICAgICAgIGlucHV0VHlwZTogc3MuaW5wdXRUeXBlLFxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgc3MuaXRlbXMgPSBpdGVtcztcbiAgICByZXR1cm4gaXRlbXM7XG4gIH1cbiAgcmVuZGVyU2VhcmNoYmFyKCkge1xuICAgIGNvbnN0IHNzID0gdGhpcztcbiAgICBpZiAoc3MucGFyYW1zLnJlbmRlclNlYXJjaGJhcikgcmV0dXJuIHNzLnBhcmFtcy5yZW5kZXJTZWFyY2hiYXIuY2FsbChzcyk7XG4gICAgY29uc3Qgc2VhcmNoYmFySFRNTCA9IGBcbiAgICAgIDxmb3JtIGNsYXNzPVwic2VhcmNoYmFyXCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJzZWFyY2hiYXItaW5uZXJcIj5cbiAgICAgICAgICA8ZGl2IGNsYXNzPVwic2VhcmNoYmFyLWlucHV0LXdyYXBcIj5cbiAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwic2VhcmNoXCIgcGxhY2Vob2xkZXI9XCIke3NzLnBhcmFtcy5zZWFyY2hiYXJQbGFjZWhvbGRlcn1cIi8+XG4gICAgICAgICAgICA8aSBjbGFzcz1cInNlYXJjaGJhci1pY29uXCI+PC9pPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJpbnB1dC1jbGVhci1idXR0b25cIj48L3NwYW4+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPHNwYW4gY2xhc3M9XCJzZWFyY2hiYXItZGlzYWJsZS1idXR0b25cIj4ke3NzLnBhcmFtcy5zZWFyY2hiYXJEaXNhYmxlVGV4dH08L3NwYW4+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9mb3JtPlxuICAgIGA7XG4gICAgcmV0dXJuIHNlYXJjaGJhckhUTUw7XG4gIH1cbiAgcmVuZGVySXRlbShpdGVtLCBpbmRleCkge1xuICAgIGNvbnN0IHNzID0gdGhpcztcbiAgICBpZiAoc3MucGFyYW1zLnJlbmRlckl0ZW0pIHJldHVybiBzcy5wYXJhbXMucmVuZGVySXRlbS5jYWxsKHNzLCBpdGVtLCBpbmRleCk7XG4gICAgbGV0IGl0ZW1IdG1sO1xuICAgIGlmIChpdGVtLmlzTGFiZWwpIHtcbiAgICAgIGl0ZW1IdG1sID0gYDxsaSBjbGFzcz1cIml0ZW0tZGl2aWRlclwiPiR7aXRlbS5ncm91cExhYmVsfTwvbGk+YDtcbiAgICB9IGVsc2Uge1xuICAgICAgaXRlbUh0bWwgPSBgXG4gICAgICAgIDxsaSBjbGFzcz1cIiR7aXRlbS5jbGFzc05hbWUgfHwgJyd9XCI+XG4gICAgICAgICAgPGxhYmVsIGNsYXNzPVwiaXRlbS0ke2l0ZW0uaW5wdXRUeXBlfSBpdGVtLWNvbnRlbnRcIj5cbiAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwiJHtpdGVtLmlucHV0VHlwZX1cIiBuYW1lPVwiJHtpdGVtLmlucHV0TmFtZX1cIiB2YWx1ZT1cIiR7aXRlbS52YWx1ZX1cIiAke2l0ZW0uc2VsZWN0ZWQgPyAnY2hlY2tlZCcgOiAnJ30vPlxuICAgICAgICAgICAgPGkgY2xhc3M9XCJpY29uIGljb24tJHtpdGVtLmlucHV0VHlwZX1cIj48L2k+XG4gICAgICAgICAgICAke2l0ZW0uaGFzTWVkaWEgPyBgXG4gICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJpdGVtLW1lZGlhXCI+XG4gICAgICAgICAgICAgICAgJHtpdGVtLmljb24gPyBgPGkgY2xhc3M9XCJpY29uICR7aXRlbS5pY29ufVwiPjwvaT5gIDogJyd9XG4gICAgICAgICAgICAgICAgJHtpdGVtLmltYWdlID8gYDxpbWcgc3JjPVwiJHtpdGVtLmltYWdlfVwiPmAgOiAnJ31cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICBgIDogJyd9XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiaXRlbS1pbm5lclwiPlxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiaXRlbS10aXRsZSR7aXRlbS5jb2xvciA/IGAgY29sb3ItJHtpdGVtLmNvbG9yfWAgOiAnJ31cIj4ke2l0ZW0udGV4dH08L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDwvbGFiZWw+XG4gICAgICAgIDwvbGk+XG4gICAgICBgO1xuICAgIH1cbiAgICByZXR1cm4gaXRlbUh0bWw7XG4gIH1cbiAgcmVuZGVySXRlbXMoKSB7XG4gICAgY29uc3Qgc3MgPSB0aGlzO1xuICAgIGlmIChzcy5wYXJhbXMucmVuZGVySXRlbXMpIHJldHVybiBzcy5wYXJhbXMucmVuZGVySXRlbXMuY2FsbChzcywgc3MuaXRlbXMpO1xuICAgIGNvbnN0IGl0ZW1zSHRtbCA9IGBcbiAgICAgICR7c3MuaXRlbXMubWFwKChpdGVtLCBpbmRleCkgPT4gYCR7c3MucmVuZGVySXRlbShpdGVtLCBpbmRleCl9YCkuam9pbignJyl9XG4gICAgYDtcbiAgICByZXR1cm4gaXRlbXNIdG1sO1xuICB9XG4gIHJlbmRlclBhZ2UoKSB7XG4gICAgY29uc3Qgc3MgPSB0aGlzO1xuICAgIGlmIChzcy5wYXJhbXMucmVuZGVyUGFnZSkgcmV0dXJuIHNzLnBhcmFtcy5yZW5kZXJQYWdlLmNhbGwoc3MsIHNzLml0ZW1zKTtcbiAgICBsZXQgcGFnZVRpdGxlID0gc3MucGFyYW1zLnBhZ2VUaXRsZTtcbiAgICBpZiAodHlwZW9mIHBhZ2VUaXRsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHBhZ2VUaXRsZSA9IHNzLiRlbC5maW5kKCcuaXRlbS10aXRsZScpLnRleHQoKS50cmltKCk7XG4gICAgfVxuICAgIGNvbnN0IHBhZ2VIdG1sID0gYFxuICAgICAgPGRpdiBjbGFzcz1cInBhZ2Ugc21hcnQtc2VsZWN0LXBhZ2VcIiBkYXRhLW5hbWU9XCJzbWFydC1zZWxlY3QtcGFnZVwiIGRhdGEtc2VsZWN0LW5hbWU9XCIke3NzLnNlbGVjdE5hbWV9XCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJuYXZiYXIgJHtzcy5wYXJhbXMubmF2YmFyQ29sb3JUaGVtZSA/IGBjb2xvci10aGVtZS0ke3NzLnBhcmFtcy5uYXZiYXJDb2xvclRoZW1lfWAgOiAnJ31cIj5cbiAgICAgICAgICA8ZGl2IGNsYXNzPVwibmF2YmFyLWlubmVyIHNsaWRpbmcgJHtzcy5wYXJhbXMubmF2YmFyQ29sb3JUaGVtZSA/IGBjb2xvci10aGVtZS0ke3NzLnBhcmFtcy5uYXZiYXJDb2xvclRoZW1lfWAgOiAnJ31cIj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJsZWZ0XCI+XG4gICAgICAgICAgICAgIDxhIGhyZWY9XCIjXCIgY2xhc3M9XCJsaW5rIGJhY2tcIj5cbiAgICAgICAgICAgICAgICA8aSBjbGFzcz1cImljb24gaWNvbi1iYWNrXCI+PC9pPlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiaW9zLW9ubHlcIj4ke3NzLnBhcmFtcy5wYWdlQmFja0xpbmtUZXh0fTwvc3Bhbj5cbiAgICAgICAgICAgICAgPC9hPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAke3BhZ2VUaXRsZSA/IGA8ZGl2IGNsYXNzPVwidGl0bGVcIj4ke3BhZ2VUaXRsZX08L2Rpdj5gIDogJyd9XG4gICAgICAgICAgICAke3NzLnBhcmFtcy5zZWFyY2hiYXIgPyBgPGRpdiBjbGFzcz1cInN1Ym5hdmJhclwiPiR7c3MucmVuZGVyU2VhcmNoYmFyKCl9PC9kaXY+YCA6ICcnfVxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgJHtzcy5wYXJhbXMuc2VhcmNoYmFyID8gJzxkaXYgY2xhc3M9XCJzZWFyY2hiYXItYmFja2Ryb3BcIj48L2Rpdj4nIDogJyd9XG4gICAgICAgIDxkaXYgY2xhc3M9XCJwYWdlLWNvbnRlbnRcIj5cbiAgICAgICAgICA8ZGl2IGNsYXNzPVwibGlzdCBzbWFydC1zZWxlY3QtbGlzdC0ke3NzLmlkfSAke3NzLnBhcmFtcy52aXJ0dWFsTGlzdCA/ICcgdmlydHVhbC1saXN0JyA6ICcnfSAke3NzLnBhcmFtcy5mb3JtQ29sb3JUaGVtZSA/IGBjb2xvci10aGVtZS0ke3NzLnBhcmFtcy5mb3JtQ29sb3JUaGVtZX1gIDogJyd9XCI+XG4gICAgICAgICAgICA8dWw+JHshc3MucGFyYW1zLnZpcnR1YWxMaXN0ICYmIHNzLnJlbmRlckl0ZW1zKHNzLml0ZW1zKX08L3VsPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIGA7XG4gICAgcmV0dXJuIHBhZ2VIdG1sO1xuICB9XG4gIHJlbmRlclBvcHVwKCkge1xuICAgIGNvbnN0IHNzID0gdGhpcztcbiAgICBpZiAoc3MucGFyYW1zLnJlbmRlclBvcHVwKSByZXR1cm4gc3MucGFyYW1zLnJlbmRlclBvcHVwLmNhbGwoc3MsIHNzLml0ZW1zKTtcbiAgICBsZXQgcGFnZVRpdGxlID0gc3MucGFyYW1zLnBhZ2VUaXRsZTtcbiAgICBpZiAodHlwZW9mIHBhZ2VUaXRsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHBhZ2VUaXRsZSA9IHNzLiRlbC5maW5kKCcuaXRlbS10aXRsZScpLnRleHQoKS50cmltKCk7XG4gICAgfVxuICAgIGNvbnN0IHBvcHVwSHRtbCA9IGBcbiAgICAgIDxkaXYgY2xhc3M9XCJwb3B1cCBzbWFydC1zZWxlY3QtcG9wdXBcIiBkYXRhLXNlbGVjdC1uYW1lPVwiJHtzcy5zZWxlY3ROYW1lfVwiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwidmlld1wiPlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJwYWdlIHNtYXJ0LXNlbGVjdC1wYWdlICR7c3MucGFyYW1zLnNlYXJjaGJhciA/ICdwYWdlLXdpdGgtc3VibmF2YmFyJyA6ICcnfVwiIGRhdGEtbmFtZT1cInNtYXJ0LXNlbGVjdC1wYWdlXCI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwibmF2YmFyJHtzcy5wYXJhbXMubmF2YmFyQ29sb3JUaGVtZSA/IGB0aGVtZS0ke3NzLnBhcmFtcy5uYXZiYXJDb2xvclRoZW1lfWAgOiAnJ31cIj5cbiAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm5hdmJhci1pbm5lciBzbGlkaW5nXCI+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImxlZnRcIj5cbiAgICAgICAgICAgICAgICAgIDxhIGhyZWY9XCIjXCIgY2xhc3M9XCJsaW5rIHBvcHVwLWNsb3NlXCI+XG4gICAgICAgICAgICAgICAgICAgIDxpIGNsYXNzPVwiaWNvbiBpY29uLWJhY2tcIj48L2k+XG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiaW9zLW9ubHlcIj4ke3NzLnBhcmFtcy5wb3B1cENsb3NlTGlua1RleHR9PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgPC9hPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICR7cGFnZVRpdGxlID8gYDxkaXYgY2xhc3M9XCJ0aXRsZVwiPiR7cGFnZVRpdGxlfTwvZGl2PmAgOiAnJ31cbiAgICAgICAgICAgICAgICAke3NzLnBhcmFtcy5zZWFyY2hiYXIgPyBgPGRpdiBjbGFzcz1cInN1Ym5hdmJhclwiPiR7c3MucmVuZGVyU2VhcmNoYmFyKCl9PC9kaXY+YCA6ICcnfVxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgJHtzcy5wYXJhbXMuc2VhcmNoYmFyID8gJzxkaXYgY2xhc3M9XCJzZWFyY2hiYXItYmFja2Ryb3BcIj48L2Rpdj4nIDogJyd9XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwicGFnZS1jb250ZW50XCI+XG4gICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJsaXN0IHNtYXJ0LXNlbGVjdC1saXN0LSR7c3MuaWR9ICR7c3MucGFyYW1zLnZpcnR1YWxMaXN0ID8gJyB2aXJ0dWFsLWxpc3QnIDogJyd9JHtzcy5wYXJhbXMuZm9ybUNvbG9yVGhlbWUgPyBgdGhlbWUtJHtzcy5wYXJhbXMuZm9ybUNvbG9yVGhlbWV9YCA6ICcnfVwiPlxuICAgICAgICAgICAgICAgIDx1bD4keyFzcy5wYXJhbXMudmlydHVhbExpc3QgJiYgc3MucmVuZGVySXRlbXMoc3MuaXRlbXMpfTwvdWw+XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgYDtcbiAgICByZXR1cm4gcG9wdXBIdG1sO1xuICB9XG4gIHJlbmRlclNoZWV0KCkge1xuICAgIGNvbnN0IHNzID0gdGhpcztcbiAgICBpZiAoc3MucGFyYW1zLnJlbmRlclNoZWV0KSByZXR1cm4gc3MucGFyYW1zLnJlbmRlclNoZWV0LmNhbGwoc3MsIHNzLml0ZW1zKTtcbiAgICBjb25zdCBzaGVldEh0bWwgPSBgXG4gICAgICA8ZGl2IGNsYXNzPVwic2hlZXQtbW9kYWwgc21hcnQtc2VsZWN0LXNoZWV0XCIgZGF0YS1zZWxlY3QtbmFtZT1cIiR7c3Muc2VsZWN0TmFtZX1cIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cInRvb2xiYXIgJHtzcy5wYXJhbXMudG9vbGJhckNvbG9yVGhlbWUgPyBgdGhlbWUtJHtzcy5wYXJhbXMudG9vbGJhckNvbG9yVGhlbWV9YCA6ICcnfVwiPlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJ0b29sYmFyLWlubmVyXCI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwibGVmdFwiPjwvZGl2PlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cInJpZ2h0XCI+XG4gICAgICAgICAgICAgIDxhIGNsYXNzPVwibGluayBzaGVldC1jbG9zZVwiPiR7c3MucGFyYW1zLnNoZWV0Q2xvc2VMaW5rVGV4dH08L2E+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJzaGVldC1tb2RhbC1pbm5lclwiPlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJwYWdlLWNvbnRlbnRcIj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJsaXN0IHNtYXJ0LXNlbGVjdC1saXN0LSR7c3MuaWR9ICR7c3MucGFyYW1zLnZpcnR1YWxMaXN0ID8gJyB2aXJ0dWFsLWxpc3QnIDogJyd9JHtzcy5wYXJhbXMuZm9ybUNvbG9yVGhlbWUgPyBgdGhlbWUtJHtzcy5wYXJhbXMuZm9ybUNvbG9yVGhlbWV9YCA6ICcnfVwiPlxuICAgICAgICAgICAgICA8dWw+JHshc3MucGFyYW1zLnZpcnR1YWxMaXN0ICYmIHNzLnJlbmRlckl0ZW1zKHNzLml0ZW1zKX08L3VsPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgYDtcbiAgICByZXR1cm4gc2hlZXRIdG1sO1xuICB9XG4gIHJlbmRlclBvcG92ZXIoKSB7XG4gICAgY29uc3Qgc3MgPSB0aGlzO1xuICAgIGlmIChzcy5wYXJhbXMucmVuZGVyUG9wb3ZlcikgcmV0dXJuIHNzLnBhcmFtcy5yZW5kZXJQb3BvdmVyLmNhbGwoc3MsIHNzLml0ZW1zKTtcbiAgICBjb25zdCBwb3BvdmVySHRtbCA9IGBcbiAgICAgIDxkaXYgY2xhc3M9XCJwb3BvdmVyIHNtYXJ0LXNlbGVjdC1wb3BvdmVyXCIgZGF0YS1zZWxlY3QtbmFtZT1cIiR7c3Muc2VsZWN0TmFtZX1cIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cInBvcG92ZXItaW5uZXJcIj5cbiAgICAgICAgICA8ZGl2IGNsYXNzPVwibGlzdCBzbWFydC1zZWxlY3QtbGlzdC0ke3NzLmlkfSAke3NzLnBhcmFtcy52aXJ0dWFsTGlzdCA/ICcgdmlydHVhbC1saXN0JyA6ICcnfSR7c3MucGFyYW1zLmZvcm1Db2xvclRoZW1lID8gYHRoZW1lLSR7c3MucGFyYW1zLmZvcm1Db2xvclRoZW1lfWAgOiAnJ31cIj5cbiAgICAgICAgICAgIDx1bD4keyFzcy5wYXJhbXMudmlydHVhbExpc3QgJiYgc3MucmVuZGVySXRlbXMoc3MuaXRlbXMpfTwvdWw+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgYDtcbiAgICByZXR1cm4gcG9wb3Zlckh0bWw7XG4gIH1cbiAgb25PcGVuKHR5cGUsIGNvbnRhaW5lckVsKSB7XG4gICAgY29uc3Qgc3MgPSB0aGlzO1xuICAgIGNvbnN0IGFwcCA9IHNzLmFwcDtcbiAgICBjb25zdCAkY29udGFpbmVyRWwgPSAkKGNvbnRhaW5lckVsKTtcbiAgICBzcy4kY29udGFpbmVyRWwgPSAkY29udGFpbmVyRWw7XG4gICAgc3Mub3BlbmVkSW4gPSB0eXBlO1xuICAgIHNzLm9wZW5lZCA9IHRydWU7XG5cbiAgICAvLyBJbml0IFZMXG4gICAgaWYgKHNzLnBhcmFtcy52aXJ0dWFsTGlzdCkge1xuICAgICAgc3MudmwgPSBhcHAudmlydHVhbExpc3QuY3JlYXRlKHtcbiAgICAgICAgZWw6ICRjb250YWluZXJFbC5maW5kKCcudmlydHVhbC1saXN0JyksXG4gICAgICAgIGl0ZW1zOiBzcy5pdGVtcyxcbiAgICAgICAgcmVuZGVySXRlbTogc3MucmVuZGVySXRlbS5iaW5kKHNzKSxcbiAgICAgICAgaGVpZ2h0OiBzcy5wYXJhbXMudmlydHVhbExpc3RIZWlnaHQsXG4gICAgICAgIHNlYXJjaEJ5SXRlbShxdWVyeSwgaXRlbSkge1xuICAgICAgICAgIGlmIChpdGVtLnRleHQgJiYgaXRlbS50ZXh0LnRvTG93ZXJDYXNlKCkuaW5kZXhPZihxdWVyeS50cmltKCkudG9Mb3dlckNhc2UoKSkgPj0gMCkgcmV0dXJuIHRydWU7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9LFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gSW5pdCBTQlxuICAgIGlmIChzcy5wYXJhbXMuc2VhcmNoYmFyKSB7XG4gICAgICBsZXQgJHNlYXJjaGJhckVsID0gJGNvbnRhaW5lckVsLmZpbmQoJy5zZWFyY2hiYXInKTtcbiAgICAgIGlmICh0eXBlID09PSAncGFnZScgJiYgYXBwLnRoZW1lID09PSAnaW9zJykge1xuICAgICAgICAkc2VhcmNoYmFyRWwgPSAkKGFwcC5uYXZiYXIuZ2V0RWxCeVBhZ2UoJGNvbnRhaW5lckVsKSkuZmluZCgnLnNlYXJjaGJhcicpO1xuICAgICAgfVxuICAgICAgc3Muc2VhcmNoYmFyID0gYXBwLnNlYXJjaGJhci5jcmVhdGUoe1xuICAgICAgICBlbDogJHNlYXJjaGJhckVsLFxuICAgICAgICBiYWNrZHJvcEVsOiAkY29udGFpbmVyRWwuZmluZCgnLnNlYXJjaGJhci1iYWNrZHJvcCcpLFxuICAgICAgICBzZWFyY2hDb250YWluZXI6IGAuc21hcnQtc2VsZWN0LWxpc3QtJHtzcy5pZH1gLFxuICAgICAgICBzZWFyY2hJbjogJy5pdGVtLXRpdGxlJyxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGZvciBtYXggbGVuZ3RoXG4gICAgaWYgKHNzLm1heExlbmd0aCkge1xuICAgICAgc3MuY2hlY2tNYXhMZW5ndGgoKTtcbiAgICB9XG5cbiAgICAvLyBDbG9zZSBvbiBzZWxlY3RcbiAgICBpZiAoc3MucGFyYW1zLmNsb3NlT25TZWxlY3QpIHtcbiAgICAgIHNzLiRjb250YWluZXJFbC5maW5kKGBpbnB1dFt0eXBlPVwicmFkaW9cIl1bbmFtZT1cIiR7c3MuaW5wdXROYW1lfVwiXTpjaGVja2VkYCkucGFyZW50cygnbGFiZWwnKS5vbmNlKCdjbGljaycsICgpID0+IHtcbiAgICAgICAgc3MuY2xvc2UoKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIEF0dGFjaCBpbnB1dCBldmVudHNcbiAgICBzcy5hdHRhY2hJbnB1dHNFdmVudHMoKTtcblxuICAgIHNzLiRlbC50cmlnZ2VyKCdzbWFydHNlbGVjdDpvcGVuJywgc3MpO1xuICAgIHNzLmVtaXQoJ2xvY2FsOjpvcGVuIHNtYXJ0U2VsZWN0T3BlbicsIHNzKTtcbiAgfVxuICBvbk9wZW5lZCgpIHtcbiAgICBjb25zdCBzcyA9IHRoaXM7XG5cbiAgICBzcy4kZWwudHJpZ2dlcignc21hcnRzZWxlY3Q6b3BlbmVkJywgc3MpO1xuICAgIHNzLmVtaXQoJ2xvY2FsOjpvcGVuZWQgc21hcnRTZWxlY3RPcGVuZWQnLCBzcyk7XG4gIH1cbiAgb25DbG9zZSgpIHtcbiAgICBjb25zdCBzcyA9IHRoaXM7XG4gICAgaWYgKHNzLmRlc3Ryb3llZCkgcmV0dXJuO1xuXG4gICAgLy8gRGVzdHJveSBWTFxuICAgIGlmIChzcy52bCAmJiBzcy52bC5kZXN0cm95KSB7XG4gICAgICBzcy52bC5kZXN0cm95KCk7XG4gICAgICBzcy52bCA9IG51bGw7XG4gICAgICBkZWxldGUgc3Mudmw7XG4gICAgfVxuXG4gICAgLy8gRGVzdHJveSBTQlxuICAgIGlmIChzcy5zZWFyY2hiYXIgJiYgc3Muc2VhcmNoYmFyLmRlc3Ryb3kpIHtcbiAgICAgIHNzLnNlYXJjaGJhci5kZXN0cm95KCk7XG4gICAgICBzcy5zZWFyY2hiYXIgPSBudWxsO1xuICAgICAgZGVsZXRlIHNzLnNlYXJjaGJhcjtcbiAgICB9XG4gICAgLy8gRGV0YWNoIGV2ZW50c1xuICAgIHNzLmRldGFjaElucHV0c0V2ZW50cygpO1xuXG4gICAgc3MuJGVsLnRyaWdnZXIoJ3NtYXJ0c2VsZWN0OmNsb3NlJywgc3MpO1xuICAgIHNzLmVtaXQoJ2xvY2FsOjpjbG9zZSBzbWFydFNlbGVjdENsb3NlJywgc3MpO1xuICB9XG4gIG9uQ2xvc2VkKCkge1xuICAgIGNvbnN0IHNzID0gdGhpcztcbiAgICBpZiAoc3MuZGVzdHJveWVkKSByZXR1cm47XG4gICAgc3Mub3BlbmVkID0gZmFsc2U7XG4gICAgc3MuJGNvbnRhaW5lckVsID0gbnVsbDtcbiAgICBkZWxldGUgc3MuJGNvbnRhaW5lckVsO1xuXG4gICAgc3MuJGVsLnRyaWdnZXIoJ3NtYXJ0c2VsZWN0OmNsb3NlZCcsIHNzKTtcbiAgICBzcy5lbWl0KCdsb2NhbDo6Y2xvc2VkIHNtYXJ0U2VsZWN0Q2xvc2VkJywgc3MpO1xuICB9XG4gIG9wZW5QYWdlKCkge1xuICAgIGNvbnN0IHNzID0gdGhpcztcbiAgICBpZiAoc3Mub3BlbmVkKSByZXR1cm4gc3M7XG4gICAgc3MuZ2V0SXRlbXNEYXRhKCk7XG4gICAgY29uc3QgcGFnZUh0bWwgPSBzcy5yZW5kZXJQYWdlKHNzLml0ZW1zKTtcblxuICAgIHNzLnZpZXcucm91dGVyLm5hdmlnYXRlKHtcbiAgICAgIHVybDogc3MudXJsLFxuICAgICAgcm91dGU6IHtcbiAgICAgICAgY29udGVudDogcGFnZUh0bWwsXG4gICAgICAgIHBhdGg6IHNzLnVybCxcbiAgICAgICAgb246IHtcbiAgICAgICAgICBwYWdlQmVmb3JlSW4oZSwgcGFnZSkge1xuICAgICAgICAgICAgc3Mub25PcGVuKCdwYWdlJywgcGFnZS5lbCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBwYWdlQWZ0ZXJJbihlLCBwYWdlKSB7XG4gICAgICAgICAgICBzcy5vbk9wZW5lZCgncGFnZScsIHBhZ2UuZWwpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgcGFnZUJlZm9yZU91dChlLCBwYWdlKSB7XG4gICAgICAgICAgICBzcy5vbkNsb3NlKCdwYWdlJywgcGFnZS5lbCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBwYWdlQWZ0ZXJPdXQoZSwgcGFnZSkge1xuICAgICAgICAgICAgc3Mub25DbG9zZWQoJ3BhZ2UnLCBwYWdlLmVsKTtcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9KTtcbiAgICByZXR1cm4gc3M7XG4gIH1cbiAgb3BlblBvcHVwKCkge1xuICAgIGNvbnN0IHNzID0gdGhpcztcbiAgICBpZiAoc3Mub3BlbmVkKSByZXR1cm4gc3M7XG4gICAgc3MuZ2V0SXRlbXNEYXRhKCk7XG4gICAgY29uc3QgcG9wdXBIdG1sID0gc3MucmVuZGVyUG9wdXAoc3MuaXRlbXMpO1xuXG4gICAgY29uc3QgcG9wdXBQYXJhbXMgPSB7XG4gICAgICBjb250ZW50OiBwb3B1cEh0bWwsXG4gICAgICBvbjoge1xuICAgICAgICBwb3B1cE9wZW4ocG9wdXApIHtcbiAgICAgICAgICBzcy5vbk9wZW4oJ3BvcHVwJywgcG9wdXAuZWwpO1xuICAgICAgICB9LFxuICAgICAgICBwb3B1cE9wZW5lZChwb3B1cCkge1xuICAgICAgICAgIHNzLm9uT3BlbmVkKCdwb3B1cCcsIHBvcHVwLmVsKTtcbiAgICAgICAgfSxcbiAgICAgICAgcG9wdXBDbG9zZShwb3B1cCkge1xuICAgICAgICAgIHNzLm9uQ2xvc2UoJ3BvcHVwJywgcG9wdXAuZWwpO1xuICAgICAgICB9LFxuICAgICAgICBwb3B1cENsb3NlZChwb3B1cCkge1xuICAgICAgICAgIHNzLm9uQ2xvc2VkKCdwb3B1cCcsIHBvcHVwLmVsKTtcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgfTtcblxuICAgIGlmIChzcy5wYXJhbXMucm91dGFibGVNb2RhbHMpIHtcbiAgICAgIHNzLnZpZXcucm91dGVyLm5hdmlnYXRlKHtcbiAgICAgICAgdXJsOiBzcy51cmwsXG4gICAgICAgIHJvdXRlOiB7XG4gICAgICAgICAgcGF0aDogc3MudXJsLFxuICAgICAgICAgIHBvcHVwOiBwb3B1cFBhcmFtcyxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBzcy5tb2RhbCA9IHNzLmFwcC5wb3B1cC5jcmVhdGUocG9wdXBQYXJhbXMpLm9wZW4oKTtcbiAgICB9XG4gICAgcmV0dXJuIHNzO1xuICB9XG4gIG9wZW5TaGVldCgpIHtcbiAgICBjb25zdCBzcyA9IHRoaXM7XG4gICAgaWYgKHNzLm9wZW5lZCkgcmV0dXJuIHNzO1xuICAgIHNzLmdldEl0ZW1zRGF0YSgpO1xuICAgIGNvbnN0IHNoZWV0SHRtbCA9IHNzLnJlbmRlclNoZWV0KHNzLml0ZW1zKTtcblxuICAgIGNvbnN0IHNoZWV0UGFyYW1zID0ge1xuICAgICAgY29udGVudDogc2hlZXRIdG1sLFxuICAgICAgYmFja2Ryb3A6IGZhbHNlLFxuICAgICAgc2Nyb2xsVG9FbDogc3MuJGVsLFxuICAgICAgY2xvc2VCeU91dHNpZGVDbGljazogdHJ1ZSxcbiAgICAgIG9uOiB7XG4gICAgICAgIHNoZWV0T3BlbihzaGVldCkge1xuICAgICAgICAgIHNzLm9uT3Blbignc2hlZXQnLCBzaGVldC5lbCk7XG4gICAgICAgIH0sXG4gICAgICAgIHNoZWV0T3BlbmVkKHNoZWV0KSB7XG4gICAgICAgICAgc3Mub25PcGVuZWQoJ3NoZWV0Jywgc2hlZXQuZWwpO1xuICAgICAgICB9LFxuICAgICAgICBzaGVldENsb3NlKHNoZWV0KSB7XG4gICAgICAgICAgc3Mub25DbG9zZSgnc2hlZXQnLCBzaGVldC5lbCk7XG4gICAgICAgIH0sXG4gICAgICAgIHNoZWV0Q2xvc2VkKHNoZWV0KSB7XG4gICAgICAgICAgc3Mub25DbG9zZWQoJ3NoZWV0Jywgc2hlZXQuZWwpO1xuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9O1xuXG4gICAgaWYgKHNzLnBhcmFtcy5yb3V0YWJsZU1vZGFscykge1xuICAgICAgc3Mudmlldy5yb3V0ZXIubmF2aWdhdGUoe1xuICAgICAgICB1cmw6IHNzLnVybCxcbiAgICAgICAgcm91dGU6IHtcbiAgICAgICAgICBwYXRoOiBzcy51cmwsXG4gICAgICAgICAgc2hlZXQ6IHNoZWV0UGFyYW1zLFxuICAgICAgICB9LFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNzLm1vZGFsID0gc3MuYXBwLnNoZWV0LmNyZWF0ZShzaGVldFBhcmFtcykub3BlbigpO1xuICAgIH1cbiAgICByZXR1cm4gc3M7XG4gIH1cbiAgb3BlblBvcG92ZXIoKSB7XG4gICAgY29uc3Qgc3MgPSB0aGlzO1xuICAgIGlmIChzcy5vcGVuZWQpIHJldHVybiBzcztcbiAgICBzcy5nZXRJdGVtc0RhdGEoKTtcbiAgICBjb25zdCBwb3BvdmVySHRtbCA9IHNzLnJlbmRlclBvcG92ZXIoc3MuaXRlbXMpO1xuICAgIGNvbnN0IHBvcG92ZXJQYXJhbXMgPSB7XG4gICAgICBjb250ZW50OiBwb3BvdmVySHRtbCxcbiAgICAgIHRhcmdldEVsOiBzcy4kZWwsXG4gICAgICBvbjoge1xuICAgICAgICBwb3BvdmVyT3Blbihwb3BvdmVyKSB7XG4gICAgICAgICAgc3Mub25PcGVuKCdwb3BvdmVyJywgcG9wb3Zlci5lbCk7XG4gICAgICAgIH0sXG4gICAgICAgIHBvcG92ZXJPcGVuZWQocG9wb3Zlcikge1xuICAgICAgICAgIHNzLm9uT3BlbmVkKCdwb3BvdmVyJywgcG9wb3Zlci5lbCk7XG4gICAgICAgIH0sXG4gICAgICAgIHBvcG92ZXJDbG9zZShwb3BvdmVyKSB7XG4gICAgICAgICAgc3Mub25DbG9zZSgncG9wb3ZlcicsIHBvcG92ZXIuZWwpO1xuICAgICAgICB9LFxuICAgICAgICBwb3BvdmVyQ2xvc2VkKHBvcG92ZXIpIHtcbiAgICAgICAgICBzcy5vbkNsb3NlZCgncG9wb3ZlcicsIHBvcG92ZXIuZWwpO1xuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9O1xuICAgIGlmIChzcy5wYXJhbXMucm91dGFibGVNb2RhbHMpIHtcbiAgICAgIHNzLnZpZXcucm91dGVyLm5hdmlnYXRlKHtcbiAgICAgICAgdXJsOiBzcy51cmwsXG4gICAgICAgIHJvdXRlOiB7XG4gICAgICAgICAgcGF0aDogc3MudXJsLFxuICAgICAgICAgIHBvcG92ZXI6IHBvcG92ZXJQYXJhbXMsXG4gICAgICAgIH0sXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3MubW9kYWwgPSBzcy5hcHAucG9wb3Zlci5jcmVhdGUocG9wb3ZlclBhcmFtcykub3BlbigpO1xuICAgIH1cbiAgICByZXR1cm4gc3M7XG4gIH1cbiAgb3Blbih0eXBlKSB7XG4gICAgY29uc3Qgc3MgPSB0aGlzO1xuICAgIGlmIChzcy5vcGVuZWQpIHJldHVybiBzcztcbiAgICBjb25zdCBvcGVuSW4gPSB0eXBlIHx8IHNzLnBhcmFtcy5vcGVuSW47XG4gICAgc3NbYG9wZW4ke29wZW5Jbi5zcGxpdCgnJykubWFwKChlbCwgaW5kZXgpID0+IHtcbiAgICAgIGlmIChpbmRleCA9PT0gMCkgcmV0dXJuIGVsLnRvVXBwZXJDYXNlKCk7XG4gICAgICByZXR1cm4gZWw7XG4gICAgfSkuam9pbignJyl9YF0oKTtcbiAgICByZXR1cm4gc3M7XG4gIH1cbiAgY2xvc2UoKSB7XG4gICAgY29uc3Qgc3MgPSB0aGlzO1xuICAgIGlmICghc3Mub3BlbmVkKSByZXR1cm4gc3M7XG4gICAgaWYgKHNzLnBhcmFtcy5yb3V0YWJsZU1vZGFscyB8fCBzcy5vcGVuZWRJbiA9PT0gJ3BhZ2UnKSB7XG4gICAgICBzcy52aWV3LnJvdXRlci5iYWNrKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNzLm1vZGFsLm9uY2UoJ21vZGFsQ2xvc2VkJywgKCkgPT4ge1xuICAgICAgICBVdGlscy5uZXh0VGljaygoKSA9PiB7XG4gICAgICAgICAgc3MubW9kYWwuZGVzdHJveSgpO1xuICAgICAgICAgIGRlbGV0ZSBzcy5tb2RhbDtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHNzLm1vZGFsLmNsb3NlKCk7XG4gICAgfVxuICAgIHJldHVybiBzcztcbiAgfVxuICBpbml0KCkge1xuICAgIGNvbnN0IHNzID0gdGhpcztcbiAgICBzcy5hdHRhY2hFdmVudHMoKTtcbiAgICBzcy5zZXRWYWx1ZSgpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgY29uc3Qgc3MgPSB0aGlzO1xuICAgIHNzLmVtaXQoJ2xvY2FsOjpiZWZvcmVEZXN0cm95IHNtYXJ0U2VsZWN0QmVmb3JlRGVzdHJveScsIHNzKTtcbiAgICBzcy4kZWwudHJpZ2dlcignc21hcnRzZWxlY3Q6YmVmb3JlZGVzdHJveScsIHNzKTtcbiAgICBzcy5kZXRhY2hFdmVudHMoKTtcbiAgICBkZWxldGUgc3MuJGVsWzBdLmY3U21hcnRTZWxlY3Q7XG4gICAgVXRpbHMuZGVsZXRlUHJvcHMoc3MpO1xuICAgIHNzLmRlc3Ryb3llZCA9IHRydWU7XG4gIH1cbn1cblxudmFyIFNtYXJ0U2VsZWN0JDEgPSB7XG4gIG5hbWU6ICdzbWFydFNlbGVjdCcsXG4gIHBhcmFtczoge1xuICAgIHNtYXJ0U2VsZWN0OiB7XG4gICAgICBlbDogdW5kZWZpbmVkLFxuICAgICAgdmFsdWVFbDogdW5kZWZpbmVkLFxuICAgICAgb3BlbkluOiAncGFnZScsIC8vIG9yICdwb3B1cCcgb3IgJ3NoZWV0JyBvciAncG9wb3ZlcidcbiAgICAgIHBhZ2VUaXRsZTogdW5kZWZpbmVkLFxuICAgICAgcGFnZUJhY2tMaW5rVGV4dDogJ0JhY2snLFxuICAgICAgcG9wdXBDbG9zZUxpbmtUZXh0OiAnQ2xvc2UnLFxuICAgICAgc2hlZXRDbG9zZUxpbmtUZXh0OiAnRG9uZScsXG4gICAgICBzZWFyY2hiYXI6IGZhbHNlLFxuICAgICAgc2VhcmNoYmFyUGxhY2Vob2xkZXI6ICdTZWFyY2gnLFxuICAgICAgc2VhcmNoYmFyRGlzYWJsZVRleHQ6ICdDYW5jZWwnLFxuICAgICAgY2xvc2VPblNlbGVjdDogZmFsc2UsXG4gICAgICB2aXJ0dWFsTGlzdDogZmFsc2UsXG4gICAgICB2aXJ0dWFsTGlzdEhlaWdodDogdW5kZWZpbmVkLFxuICAgICAgZm9ybUNvbG9yVGhlbWU6IHVuZGVmaW5lZCxcbiAgICAgIG5hdmJhckNvbG9yVGhlbWU6IHVuZGVmaW5lZCxcbiAgICAgIHJvdXRhYmxlTW9kYWxzOiB0cnVlLFxuICAgICAgdXJsOiAnc2VsZWN0LycsXG4gICAgICAvKlxuICAgICAgICBDdXN0b20gcmVuZGVyIGZ1bmN0aW9uc1xuICAgICAgKi9cbiAgICAgIHJlbmRlclBhZ2U6IHVuZGVmaW5lZCxcbiAgICAgIHJlbmRlclBvcHVwOiB1bmRlZmluZWQsXG4gICAgICByZW5kZXJTaGVldDogdW5kZWZpbmVkLFxuICAgICAgcmVuZGVyUG9wb3ZlcjogdW5kZWZpbmVkLFxuICAgICAgcmVuZGVySXRlbXM6IHVuZGVmaW5lZCxcbiAgICAgIHJlbmRlckl0ZW06IHVuZGVmaW5lZCxcbiAgICAgIHJlbmRlclNlYXJjaGJhcjogdW5kZWZpbmVkLFxuICAgIH0sXG4gIH0sXG4gIHN0YXRpYzoge1xuICAgIFNtYXJ0U2VsZWN0LFxuICB9LFxuICBjcmVhdGUoKSB7XG4gICAgY29uc3QgYXBwID0gdGhpcztcbiAgICBhcHAuc21hcnRTZWxlY3QgPSBVdGlscy5leHRlbmQoXG4gICAgICBDb25zdHJ1Y3Rvck1ldGhvZHMoe1xuICAgICAgICBkZWZhdWx0U2VsZWN0b3I6ICcuc21hcnQtc2VsZWN0JyxcbiAgICAgICAgY29uc3RydWN0b3I6IFNtYXJ0U2VsZWN0LFxuICAgICAgICBhcHAsXG4gICAgICAgIGRvbVByb3A6ICdmN1NtYXJ0U2VsZWN0JyxcbiAgICAgIH0pLFxuICAgICAge1xuICAgICAgICBvcGVuKHNtYXJ0U2VsZWN0RWwpIHtcbiAgICAgICAgICBjb25zdCBzcyA9IGFwcC5zbWFydFNlbGVjdC5nZXQoc21hcnRTZWxlY3RFbCk7XG4gICAgICAgICAgaWYgKHNzICYmIHNzLm9wZW4pIHJldHVybiBzcy5vcGVuKCk7XG4gICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfSxcbiAgICAgICAgY2xvc2Uoc21hcnRTZWxlY3RFbCkge1xuICAgICAgICAgIGNvbnN0IHNzID0gYXBwLnNtYXJ0U2VsZWN0LmdldChzbWFydFNlbGVjdEVsKTtcbiAgICAgICAgICBpZiAoc3MgJiYgc3MuY2xvc2UpIHJldHVybiBzcy5jbG9zZSgpO1xuICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH0sXG4gICAgICB9XG4gICAgKTtcbiAgfSxcblxuICBvbjoge1xuICAgIHRhYk1vdW50ZWQodGFiRWwpIHtcbiAgICAgIGNvbnN0IGFwcCA9IHRoaXM7XG4gICAgICAkKHRhYkVsKS5maW5kKCcuc21hcnQtc2VsZWN0LWluaXQnKS5lYWNoKChpbmRleCwgc21hcnRTZWxlY3RFbCkgPT4ge1xuICAgICAgICBhcHAuc21hcnRTZWxlY3QuY3JlYXRlKFV0aWxzLmV4dGVuZCh7IGVsOiBzbWFydFNlbGVjdEVsIH0sICQoc21hcnRTZWxlY3RFbCkuZGF0YXNldCgpKSk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIHRhYkJlZm9yZVJlbW92ZSh0YWJFbCkge1xuICAgICAgJCh0YWJFbCkuZmluZCgnLnNtYXJ0LXNlbGVjdC1pbml0JykuZWFjaCgoaW5kZXgsIHNtYXJ0U2VsZWN0RWwpID0+IHtcbiAgICAgICAgaWYgKHNtYXJ0U2VsZWN0RWwuZjdTbWFydFNlbGVjdCAmJiBzbWFydFNlbGVjdEVsLmY3U21hcnRTZWxlY3QuZGVzdHJveSkge1xuICAgICAgICAgIHNtYXJ0U2VsZWN0RWwuZjdTbWFydFNlbGVjdC5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG4gICAgcGFnZUluaXQocGFnZSkge1xuICAgICAgY29uc3QgYXBwID0gdGhpcztcbiAgICAgIHBhZ2UuJGVsLmZpbmQoJy5zbWFydC1zZWxlY3QtaW5pdCcpLmVhY2goKGluZGV4LCBzbWFydFNlbGVjdEVsKSA9PiB7XG4gICAgICAgIGFwcC5zbWFydFNlbGVjdC5jcmVhdGUoVXRpbHMuZXh0ZW5kKHsgZWw6IHNtYXJ0U2VsZWN0RWwgfSwgJChzbWFydFNlbGVjdEVsKS5kYXRhc2V0KCkpKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgcGFnZUJlZm9yZVJlbW92ZShwYWdlKSB7XG4gICAgICBwYWdlLiRlbC5maW5kKCcuc21hcnQtc2VsZWN0LWluaXQnKS5lYWNoKChpbmRleCwgc21hcnRTZWxlY3RFbCkgPT4ge1xuICAgICAgICBpZiAoc21hcnRTZWxlY3RFbC5mN1NtYXJ0U2VsZWN0ICYmIHNtYXJ0U2VsZWN0RWwuZjdTbWFydFNlbGVjdC5kZXN0cm95KSB7XG4gICAgICAgICAgc21hcnRTZWxlY3RFbC5mN1NtYXJ0U2VsZWN0LmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcbiAgfSxcbiAgY2xpY2tzOiB7XG4gICAgJy5zbWFydC1zZWxlY3QnOiBmdW5jdGlvbiBvcGVuKCRjbGlja2VkRWwsIGRhdGEpIHtcbiAgICAgIGNvbnN0IGFwcCA9IHRoaXM7XG4gICAgICBpZiAoISRjbGlja2VkRWxbMF0uZjdTbWFydFNlbGVjdCkge1xuICAgICAgICBjb25zdCBzcyA9IGFwcC5zbWFydFNlbGVjdC5jcmVhdGUoVXRpbHMuZXh0ZW5kKHsgZWw6ICRjbGlja2VkRWwgfSwgZGF0YSkpO1xuICAgICAgICBzcy5vcGVuKCk7XG4gICAgICB9XG4gICAgfSxcbiAgfSxcbn07XG5cbnZhciBHcmlkID0ge1xuICBuYW1lOiAnZ3JpZCcsXG59O1xuXG5jbGFzcyBDYWxlbmRhciBleHRlbmRzIEZyYW1ld29yazdDbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGFwcCwgcGFyYW1zID0ge30pIHtcbiAgICBzdXBlcihwYXJhbXMsIFthcHBdKTtcbiAgICBjb25zdCBjYWxlbmRhciA9IHRoaXM7XG4gICAgY2FsZW5kYXIucGFyYW1zID0gVXRpbHMuZXh0ZW5kKHt9LCBhcHAucGFyYW1zLmNhbGVuZGFyLCBwYXJhbXMpO1xuXG4gICAgbGV0ICRjb250YWluZXJFbDtcbiAgICBpZiAoY2FsZW5kYXIucGFyYW1zLmNvbnRhaW5lckVsKSB7XG4gICAgICAkY29udGFpbmVyRWwgPSAkKGNhbGVuZGFyLnBhcmFtcy5jb250YWluZXJFbCk7XG4gICAgICBpZiAoJGNvbnRhaW5lckVsLmxlbmd0aCA9PT0gMCkgcmV0dXJuIGNhbGVuZGFyO1xuICAgIH1cblxuICAgIGxldCAkaW5wdXRFbDtcbiAgICBpZiAoY2FsZW5kYXIucGFyYW1zLmlucHV0RWwpIHtcbiAgICAgICRpbnB1dEVsID0gJChjYWxlbmRhci5wYXJhbXMuaW5wdXRFbCk7XG4gICAgfVxuXG4gICAgbGV0IHZpZXc7XG4gICAgaWYgKCRpbnB1dEVsKSB7XG4gICAgICB2aWV3ID0gJGlucHV0RWwucGFyZW50cygnLnZpZXcnKS5sZW5ndGggJiYgJGlucHV0RWwucGFyZW50cygnLnZpZXcnKVswXS5mN1ZpZXc7XG4gICAgfVxuICAgIGlmICghdmlldykgdmlldyA9IGFwcC52aWV3cy5tYWluO1xuXG4gICAgY29uc3QgaXNIb3Jpem9udGFsID0gY2FsZW5kYXIucGFyYW1zLmRpcmVjdGlvbiA9PT0gJ2hvcml6b250YWwnO1xuXG4gICAgbGV0IGludmVydGVyID0gMTtcbiAgICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICBpbnZlcnRlciA9IGFwcC5ydGwgPyAtMSA6IDE7XG4gICAgfVxuXG4gICAgVXRpbHMuZXh0ZW5kKGNhbGVuZGFyLCB7XG4gICAgICBhcHAsXG4gICAgICAkY29udGFpbmVyRWwsXG4gICAgICBjb250YWluZXJFbDogJGNvbnRhaW5lckVsICYmICRjb250YWluZXJFbFswXSxcbiAgICAgIGlubGluZTogJGNvbnRhaW5lckVsICYmICRjb250YWluZXJFbC5sZW5ndGggPiAwLFxuICAgICAgJGlucHV0RWwsXG4gICAgICBpbnB1dEVsOiAkaW5wdXRFbCAmJiAkaW5wdXRFbFswXSxcbiAgICAgIGluaXRpYWxpemVkOiBmYWxzZSxcbiAgICAgIG9wZW5lZDogZmFsc2UsXG4gICAgICB1cmw6IGNhbGVuZGFyLnBhcmFtcy51cmwsXG4gICAgICBpc0hvcml6b250YWwsXG4gICAgICBpbnZlcnRlcixcbiAgICAgIHZpZXcsXG4gICAgICBhbmltYXRpbmc6IGZhbHNlLFxuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gb25JbnB1dENsaWNrKCkge1xuICAgICAgY2FsZW5kYXIub3BlbigpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvbklucHV0Rm9jdXMoZSkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvbkh0bWxDbGljayhlKSB7XG4gICAgICBjb25zdCAkdGFyZ2V0RWwgPSAkKGUudGFyZ2V0KTtcbiAgICAgIGlmIChjYWxlbmRhci5pc1BvcG92ZXIoKSkgcmV0dXJuO1xuICAgICAgaWYgKCFjYWxlbmRhci5vcGVuZWQpIHJldHVybjtcbiAgICAgIGlmICgkdGFyZ2V0RWwuY2xvc2VzdCgnW2NsYXNzKj1cImJhY2tkcm9wXCJdJykubGVuZ3RoKSByZXR1cm47XG4gICAgICBpZiAoJGlucHV0RWwgJiYgJGlucHV0RWwubGVuZ3RoID4gMCkge1xuICAgICAgICBpZiAoJHRhcmdldEVsWzBdICE9PSAkaW5wdXRFbFswXSAmJiAkdGFyZ2V0RWwuY2xvc2VzdCgnLnNoZWV0LW1vZGFsLCAuY2FsZW5kYXItbW9kYWwnKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBjYWxlbmRhci5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCQoZS50YXJnZXQpLmNsb3Nlc3QoJy5zaGVldC1tb2RhbCwgLmNhbGVuZGFyLW1vZGFsJykubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNhbGVuZGFyLmNsb3NlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRXZlbnRzXG4gICAgVXRpbHMuZXh0ZW5kKGNhbGVuZGFyLCB7XG4gICAgICBhdHRhY2hJbnB1dEV2ZW50cygpIHtcbiAgICAgICAgY2FsZW5kYXIuJGlucHV0RWwub24oJ2NsaWNrJywgb25JbnB1dENsaWNrKTtcbiAgICAgICAgaWYgKGNhbGVuZGFyLnBhcmFtcy5pbnB1dFJlYWRPbmx5KSB7XG4gICAgICAgICAgY2FsZW5kYXIuJGlucHV0RWwub24oJ2ZvY3VzIG1vdXNlZG93bicsIG9uSW5wdXRGb2N1cyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBkZXRhY2hJbnB1dEV2ZW50cygpIHtcbiAgICAgICAgY2FsZW5kYXIuJGlucHV0RWwub2ZmKCdjbGljaycsIG9uSW5wdXRDbGljayk7XG4gICAgICAgIGlmIChjYWxlbmRhci5wYXJhbXMuaW5wdXRSZWFkT25seSkge1xuICAgICAgICAgIGNhbGVuZGFyLiRpbnB1dEVsLm9mZignZm9jdXMgbW91c2Vkb3duJywgb25JbnB1dEZvY3VzKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGF0dGFjaEh0bWxFdmVudHMoKSB7XG4gICAgICAgIGFwcC5vbignY2xpY2snLCBvbkh0bWxDbGljayk7XG4gICAgICB9LFxuICAgICAgZGV0YWNoSHRtbEV2ZW50cygpIHtcbiAgICAgICAgYXBwLm9mZignY2xpY2snLCBvbkh0bWxDbGljayk7XG4gICAgICB9LFxuICAgIH0pO1xuICAgIGNhbGVuZGFyLmF0dGFjaENhbGVuZGFyRXZlbnRzID0gZnVuY3Rpb24gYXR0YWNoQ2FsZW5kYXJFdmVudHMoKSB7XG4gICAgICBsZXQgYWxsb3dJdGVtQ2xpY2sgPSB0cnVlO1xuICAgICAgbGV0IGlzVG91Y2hlZDtcbiAgICAgIGxldCBpc01vdmVkO1xuICAgICAgbGV0IHRvdWNoU3RhcnRYO1xuICAgICAgbGV0IHRvdWNoU3RhcnRZO1xuICAgICAgbGV0IHRvdWNoQ3VycmVudFg7XG4gICAgICBsZXQgdG91Y2hDdXJyZW50WTtcbiAgICAgIGxldCB0b3VjaFN0YXJ0VGltZTtcbiAgICAgIGxldCB0b3VjaEVuZFRpbWU7XG4gICAgICBsZXQgY3VycmVudFRyYW5zbGF0ZTtcbiAgICAgIGxldCB3cmFwcGVyV2lkdGg7XG4gICAgICBsZXQgd3JhcHBlckhlaWdodDtcbiAgICAgIGxldCBwZXJjZW50YWdlO1xuICAgICAgbGV0IHRvdWNoZXNEaWZmO1xuICAgICAgbGV0IGlzU2Nyb2xsaW5nO1xuXG4gICAgICBjb25zdCB7ICRlbCwgJHdyYXBwZXJFbCB9ID0gY2FsZW5kYXI7XG5cbiAgICAgIGZ1bmN0aW9uIGhhbmRsZVRvdWNoU3RhcnQoZSkge1xuICAgICAgICBpZiAoaXNNb3ZlZCB8fCBpc1RvdWNoZWQpIHJldHVybjtcbiAgICAgICAgaXNUb3VjaGVkID0gdHJ1ZTtcbiAgICAgICAgdG91Y2hTdGFydFggPSBlLnR5cGUgPT09ICd0b3VjaHN0YXJ0JyA/IGUudGFyZ2V0VG91Y2hlc1swXS5wYWdlWCA6IGUucGFnZVg7XG4gICAgICAgIHRvdWNoQ3VycmVudFggPSB0b3VjaFN0YXJ0WDtcbiAgICAgICAgdG91Y2hTdGFydFkgPSBlLnR5cGUgPT09ICd0b3VjaHN0YXJ0JyA/IGUudGFyZ2V0VG91Y2hlc1swXS5wYWdlWSA6IGUucGFnZVk7XG4gICAgICAgIHRvdWNoQ3VycmVudFkgPSB0b3VjaFN0YXJ0WTtcbiAgICAgICAgdG91Y2hTdGFydFRpbWUgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuICAgICAgICBwZXJjZW50YWdlID0gMDtcbiAgICAgICAgYWxsb3dJdGVtQ2xpY2sgPSB0cnVlO1xuICAgICAgICBpc1Njcm9sbGluZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgY3VycmVudFRyYW5zbGF0ZSA9IGNhbGVuZGFyLm1vbnRoc1RyYW5zbGF0ZTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGhhbmRsZVRvdWNoTW92ZShlKSB7XG4gICAgICAgIGlmICghaXNUb3VjaGVkKSByZXR1cm47XG4gICAgICAgIGNvbnN0IHsgaXNIb3Jpem9udGFsOiBpc0ggfSA9IGNhbGVuZGFyO1xuXG4gICAgICAgIHRvdWNoQ3VycmVudFggPSBlLnR5cGUgPT09ICd0b3VjaG1vdmUnID8gZS50YXJnZXRUb3VjaGVzWzBdLnBhZ2VYIDogZS5wYWdlWDtcbiAgICAgICAgdG91Y2hDdXJyZW50WSA9IGUudHlwZSA9PT0gJ3RvdWNobW92ZScgPyBlLnRhcmdldFRvdWNoZXNbMF0ucGFnZVkgOiBlLnBhZ2VZO1xuICAgICAgICBpZiAodHlwZW9mIGlzU2Nyb2xsaW5nID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIGlzU2Nyb2xsaW5nID0gISEoaXNTY3JvbGxpbmcgfHwgTWF0aC5hYnModG91Y2hDdXJyZW50WSAtIHRvdWNoU3RhcnRZKSA+IE1hdGguYWJzKHRvdWNoQ3VycmVudFggLSB0b3VjaFN0YXJ0WCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0ggJiYgaXNTY3JvbGxpbmcpIHtcbiAgICAgICAgICBpc1RvdWNoZWQgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBpZiAoY2FsZW5kYXIuYW5pbWF0aW5nKSB7XG4gICAgICAgICAgaXNUb3VjaGVkID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGFsbG93SXRlbUNsaWNrID0gZmFsc2U7XG4gICAgICAgIGlmICghaXNNb3ZlZCkge1xuICAgICAgICAgIC8vIEZpcnN0IG1vdmVcbiAgICAgICAgICBpc01vdmVkID0gdHJ1ZTtcbiAgICAgICAgICB3cmFwcGVyV2lkdGggPSAkd3JhcHBlckVsWzBdLm9mZnNldFdpZHRoO1xuICAgICAgICAgIHdyYXBwZXJIZWlnaHQgPSAkd3JhcHBlckVsWzBdLm9mZnNldEhlaWdodDtcbiAgICAgICAgICAkd3JhcHBlckVsLnRyYW5zaXRpb24oMCk7XG4gICAgICAgIH1cblxuICAgICAgICB0b3VjaGVzRGlmZiA9IGlzSCA/IHRvdWNoQ3VycmVudFggLSB0b3VjaFN0YXJ0WCA6IHRvdWNoQ3VycmVudFkgLSB0b3VjaFN0YXJ0WTtcbiAgICAgICAgcGVyY2VudGFnZSA9IHRvdWNoZXNEaWZmIC8gKGlzSCA/IHdyYXBwZXJXaWR0aCA6IHdyYXBwZXJIZWlnaHQpO1xuICAgICAgICBjdXJyZW50VHJhbnNsYXRlID0gKChjYWxlbmRhci5tb250aHNUcmFuc2xhdGUgKiBjYWxlbmRhci5pbnZlcnRlcikgKyBwZXJjZW50YWdlKSAqIDEwMDtcblxuICAgICAgICAvLyBUcmFuc2Zvcm0gd3JhcHBlclxuICAgICAgICAkd3JhcHBlckVsLnRyYW5zZm9ybShgdHJhbnNsYXRlM2QoJHtpc0ggPyBjdXJyZW50VHJhbnNsYXRlIDogMH0lLCAke2lzSCA/IDAgOiBjdXJyZW50VHJhbnNsYXRlfSUsIDApYCk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBoYW5kbGVUb3VjaEVuZCgpIHtcbiAgICAgICAgaWYgKCFpc1RvdWNoZWQgfHwgIWlzTW92ZWQpIHtcbiAgICAgICAgICBpc1RvdWNoZWQgPSBmYWxzZTtcbiAgICAgICAgICBpc01vdmVkID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlzVG91Y2hlZCA9IGZhbHNlO1xuICAgICAgICBpc01vdmVkID0gZmFsc2U7XG5cbiAgICAgICAgdG91Y2hFbmRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgIGlmICh0b3VjaEVuZFRpbWUgLSB0b3VjaFN0YXJ0VGltZSA8IDMwMCkge1xuICAgICAgICAgIGlmIChNYXRoLmFicyh0b3VjaGVzRGlmZikgPCAxMCkge1xuICAgICAgICAgICAgY2FsZW5kYXIucmVzZXRNb250aCgpO1xuICAgICAgICAgIH0gZWxzZSBpZiAodG91Y2hlc0RpZmYgPj0gMTApIHtcbiAgICAgICAgICAgIGlmIChhcHAucnRsKSBjYWxlbmRhci5uZXh0TW9udGgoKTtcbiAgICAgICAgICAgIGVsc2UgY2FsZW5kYXIucHJldk1vbnRoKCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChhcHAucnRsKSBjYWxlbmRhci5wcmV2TW9udGgoKTtcbiAgICAgICAgICBlbHNlIGNhbGVuZGFyLm5leHRNb250aCgpO1xuICAgICAgICB9IGVsc2UgaWYgKHBlcmNlbnRhZ2UgPD0gLTAuNSkge1xuICAgICAgICAgIGlmIChhcHAucnRsKSBjYWxlbmRhci5wcmV2TW9udGgoKTtcbiAgICAgICAgICBlbHNlIGNhbGVuZGFyLm5leHRNb250aCgpO1xuICAgICAgICB9IGVsc2UgaWYgKHBlcmNlbnRhZ2UgPj0gMC41KSB7XG4gICAgICAgICAgaWYgKGFwcC5ydGwpIGNhbGVuZGFyLm5leHRNb250aCgpO1xuICAgICAgICAgIGVsc2UgY2FsZW5kYXIucHJldk1vbnRoKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FsZW5kYXIucmVzZXRNb250aCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWxsb3cgY2xpY2tcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgYWxsb3dJdGVtQ2xpY2sgPSB0cnVlO1xuICAgICAgICB9LCAxMDApO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBoYW5kbGVEYXlDbGljayhlKSB7XG4gICAgICAgIGlmICghYWxsb3dJdGVtQ2xpY2spIHJldHVybjtcbiAgICAgICAgbGV0ICRkYXlFbCA9ICQoZS50YXJnZXQpLnBhcmVudHMoJy5jYWxlbmRhci1kYXknKTtcbiAgICAgICAgaWYgKCRkYXlFbC5sZW5ndGggPT09IDAgJiYgJChlLnRhcmdldCkuaGFzQ2xhc3MoJ2NhbGVuZGFyLWRheScpKSB7XG4gICAgICAgICAgJGRheUVsID0gJChlLnRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCRkYXlFbC5sZW5ndGggPT09IDApIHJldHVybjtcbiAgICAgICAgaWYgKCRkYXlFbC5oYXNDbGFzcygnY2FsZW5kYXItZGF5LWRpc2FibGVkJykpIHJldHVybjtcbiAgICAgICAgaWYgKCFjYWxlbmRhci5wYXJhbXMucmFuZ2VQaWNrZXIpIHtcbiAgICAgICAgICBpZiAoJGRheUVsLmhhc0NsYXNzKCdjYWxlbmRhci1kYXktbmV4dCcpKSBjYWxlbmRhci5uZXh0TW9udGgoKTtcbiAgICAgICAgICBpZiAoJGRheUVsLmhhc0NsYXNzKCdjYWxlbmRhci1kYXktcHJldicpKSBjYWxlbmRhci5wcmV2TW9udGgoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkYXRlWWVhciA9ICRkYXlFbC5hdHRyKCdkYXRhLXllYXInKTtcbiAgICAgICAgY29uc3QgZGF0ZU1vbnRoID0gJGRheUVsLmF0dHIoJ2RhdGEtbW9udGgnKTtcbiAgICAgICAgY29uc3QgZGF0ZURheSA9ICRkYXlFbC5hdHRyKCdkYXRhLWRheScpO1xuICAgICAgICBjYWxlbmRhci5lbWl0KFxuICAgICAgICAgICdsb2NhbDo6ZGF5Q2xpY2sgY2FsZW5kYXJEYXlDbGljaycsXG4gICAgICAgICAgY2FsZW5kYXIsXG4gICAgICAgICAgJGRheUVsWzBdLFxuICAgICAgICAgIGRhdGVZZWFyLFxuICAgICAgICAgIGRhdGVNb250aCxcbiAgICAgICAgICBkYXRlRGF5XG4gICAgICAgICk7XG4gICAgICAgIGlmICghJGRheUVsLmhhc0NsYXNzKCdjYWxlbmRhci1kYXktc2VsZWN0ZWQnKSB8fCBjYWxlbmRhci5wYXJhbXMubXVsdGlwbGUgfHwgY2FsZW5kYXIucGFyYW1zLnJhbmdlUGlja2VyKSB7XG4gICAgICAgICAgY2FsZW5kYXIuYWRkVmFsdWUobmV3IERhdGUoZGF0ZVllYXIsIGRhdGVNb250aCwgZGF0ZURheSwgMCwgMCwgMCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYWxlbmRhci5wYXJhbXMuY2xvc2VPblNlbGVjdCkge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIChjYWxlbmRhci5wYXJhbXMucmFuZ2VQaWNrZXIgJiYgY2FsZW5kYXIudmFsdWUubGVuZ3RoID09PSAyKSB8fFxuICAgICAgICAgICAgIWNhbGVuZGFyLnBhcmFtcy5yYW5nZVBpY2tlclxuICAgICAgICAgICkge1xuICAgICAgICAgICAgY2FsZW5kYXIuY2xvc2UoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIG9uTmV4dE1vbnRoQ2xpY2soKSB7XG4gICAgICAgIGNhbGVuZGFyLm5leHRNb250aCgpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gb25QcmV2TW9udGhDbGljaygpIHtcbiAgICAgICAgY2FsZW5kYXIucHJldk1vbnRoKCk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBvbk5leHRZZWFyQ2xpY2soKSB7XG4gICAgICAgIGNhbGVuZGFyLm5leHRZZWFyKCk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBvblByZXZZZWFyQ2xpY2soKSB7XG4gICAgICAgIGNhbGVuZGFyLnByZXZZZWFyKCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHBhc3NpdmVMaXN0ZW5lciA9IGFwcC50b3VjaEV2ZW50cy5zdGFydCA9PT0gJ3RvdWNoc3RhcnQnICYmIGFwcC5zdXBwb3J0LnBhc3NpdmVMaXN0ZW5lciA/IHsgcGFzc2l2ZTogdHJ1ZSwgY2FwdHVyZTogZmFsc2UgfSA6IGZhbHNlO1xuICAgICAgLy8gU2VsZWN0b3JzIGNsaWNrc1xuICAgICAgJGVsLmZpbmQoJy5jYWxlbmRhci1wcmV2LW1vbnRoLWJ1dHRvbicpLm9uKCdjbGljaycsIG9uUHJldk1vbnRoQ2xpY2spO1xuICAgICAgJGVsLmZpbmQoJy5jYWxlbmRhci1uZXh0LW1vbnRoLWJ1dHRvbicpLm9uKCdjbGljaycsIG9uTmV4dE1vbnRoQ2xpY2spO1xuICAgICAgJGVsLmZpbmQoJy5jYWxlbmRhci1wcmV2LXllYXItYnV0dG9uJykub24oJ2NsaWNrJywgb25QcmV2WWVhckNsaWNrKTtcbiAgICAgICRlbC5maW5kKCcuY2FsZW5kYXItbmV4dC15ZWFyLWJ1dHRvbicpLm9uKCdjbGljaycsIG9uTmV4dFllYXJDbGljayk7XG4gICAgICAvLyBEYXkgY2xpY2tzXG4gICAgICAkd3JhcHBlckVsLm9uKCdjbGljaycsIGhhbmRsZURheUNsaWNrKTtcbiAgICAgIC8vIFRvdWNoIGV2ZW50c1xuICAgICAge1xuICAgICAgICBpZiAoY2FsZW5kYXIucGFyYW1zLnRvdWNoTW92ZSkge1xuICAgICAgICAgICR3cmFwcGVyRWwub24oYXBwLnRvdWNoRXZlbnRzLnN0YXJ0LCBoYW5kbGVUb3VjaFN0YXJ0LCBwYXNzaXZlTGlzdGVuZXIpO1xuICAgICAgICAgIGFwcC5vbigndG91Y2htb3ZlOmFjdGl2ZScsIGhhbmRsZVRvdWNoTW92ZSk7XG4gICAgICAgICAgYXBwLm9uKCd0b3VjaGVuZDpwYXNzaXZlJywgaGFuZGxlVG91Y2hFbmQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNhbGVuZGFyLmRldGFjaENhbGVuZGFyRXZlbnRzID0gZnVuY3Rpb24gZGV0YWNoQ2FsZW5kYXJFdmVudHMoKSB7XG4gICAgICAgICRlbC5maW5kKCcuY2FsZW5kYXItcHJldi1tb250aC1idXR0b24nKS5vZmYoJ2NsaWNrJywgb25QcmV2TW9udGhDbGljayk7XG4gICAgICAgICRlbC5maW5kKCcuY2FsZW5kYXItbmV4dC1tb250aC1idXR0b24nKS5vZmYoJ2NsaWNrJywgb25OZXh0TW9udGhDbGljayk7XG4gICAgICAgICRlbC5maW5kKCcuY2FsZW5kYXItcHJldi15ZWFyLWJ1dHRvbicpLm9mZignY2xpY2snLCBvblByZXZZZWFyQ2xpY2spO1xuICAgICAgICAkZWwuZmluZCgnLmNhbGVuZGFyLW5leHQteWVhci1idXR0b24nKS5vZmYoJ2NsaWNrJywgb25OZXh0WWVhckNsaWNrKTtcbiAgICAgICAgJHdyYXBwZXJFbC5vZmYoJ2NsaWNrJywgaGFuZGxlRGF5Q2xpY2spO1xuICAgICAgICB7XG4gICAgICAgICAgaWYgKGNhbGVuZGFyLnBhcmFtcy50b3VjaE1vdmUpIHtcbiAgICAgICAgICAgICR3cmFwcGVyRWwub2ZmKGFwcC50b3VjaEV2ZW50cy5zdGFydCwgaGFuZGxlVG91Y2hTdGFydCwgcGFzc2l2ZUxpc3RlbmVyKTtcbiAgICAgICAgICAgIGFwcC5vZmYoJ3RvdWNobW92ZTphY3RpdmUnLCBoYW5kbGVUb3VjaE1vdmUpO1xuICAgICAgICAgICAgYXBwLm9mZigndG91Y2hlbmQ6cGFzc2l2ZScsIGhhbmRsZVRvdWNoRW5kKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfTtcblxuICAgIGNhbGVuZGFyLmluaXQoKTtcblxuICAgIHJldHVybiBjYWxlbmRhcjtcbiAgfVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgbm9ybWFsaXplRGF0ZShkYXRlKSB7XG4gICAgY29uc3QgZCA9IG5ldyBEYXRlKGRhdGUpO1xuICAgIHJldHVybiBuZXcgRGF0ZShkLmdldEZ1bGxZZWFyKCksIGQuZ2V0TW9udGgoKSwgZC5nZXREYXRlKCkpO1xuICB9XG4gIG5vcm1hbGl6ZVZhbHVlcyh2YWx1ZXMpIHtcbiAgICBjb25zdCBjYWxlbmRhciA9IHRoaXM7XG4gICAgbGV0IG5ld1ZhbHVlcyA9IFtdO1xuICAgIGlmICh2YWx1ZXMgJiYgQXJyYXkuaXNBcnJheSh2YWx1ZXMpKSB7XG4gICAgICBuZXdWYWx1ZXMgPSB2YWx1ZXMubWFwKHZhbCA9PiBjYWxlbmRhci5ub3JtYWxpemVEYXRlKHZhbCkpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3VmFsdWVzO1xuICB9XG4gIGluaXRJbnB1dCgpIHtcbiAgICBjb25zdCBjYWxlbmRhciA9IHRoaXM7XG4gICAgaWYgKCFjYWxlbmRhci4kaW5wdXRFbCkgcmV0dXJuO1xuICAgIGlmIChjYWxlbmRhci5wYXJhbXMuaW5wdXRSZWFkT25seSkgY2FsZW5kYXIuJGlucHV0RWwucHJvcCgncmVhZE9ubHknLCB0cnVlKTtcbiAgfVxuICBpc1BvcG92ZXIoKSB7XG4gICAgY29uc3QgY2FsZW5kYXIgPSB0aGlzO1xuICAgIGNvbnN0IHsgYXBwLCBtb2RhbCwgcGFyYW1zIH0gPSBjYWxlbmRhcjtcbiAgICBpZiAocGFyYW1zLm9wZW5JbiA9PT0gJ3NoZWV0JykgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChtb2RhbCAmJiBtb2RhbC50eXBlICE9PSAncG9wb3ZlcicpIHJldHVybiBmYWxzZTtcblxuICAgIGlmICghY2FsZW5kYXIuaW5saW5lICYmIGNhbGVuZGFyLmlucHV0RWwpIHtcbiAgICAgIGlmIChwYXJhbXMub3BlbkluID09PSAncG9wb3ZlcicpIHJldHVybiB0cnVlO1xuICAgICAgZWxzZSBpZiAoYXBwLmRldmljZS5pb3MpIHtcbiAgICAgICAgcmV0dXJuICEhYXBwLmRldmljZS5pcGFkO1xuICAgICAgfSBlbHNlIGlmIChhcHAud2lkdGggPj0gNzY4KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9ybWF0RGF0ZShkKSB7XG4gICAgY29uc3QgY2FsZW5kYXIgPSB0aGlzO1xuICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZShkKTtcbiAgICBjb25zdCB5ZWFyID0gZGF0ZS5nZXRGdWxsWWVhcigpO1xuICAgIGNvbnN0IG1vbnRoID0gZGF0ZS5nZXRNb250aCgpO1xuICAgIGNvbnN0IG1vbnRoMSA9IG1vbnRoICsgMTtcbiAgICBjb25zdCBkYXkgPSBkYXRlLmdldERhdGUoKTtcbiAgICBjb25zdCB3ZWVrRGF5ID0gZGF0ZS5nZXREYXkoKTtcbiAgICBjb25zdCB7IGRhdGVGb3JtYXQsIG1vbnRoTmFtZXMsIG1vbnRoTmFtZXNTaG9ydCwgZGF5TmFtZXMsIGRheU5hbWVzU2hvcnQgfSA9IGNhbGVuZGFyLnBhcmFtcztcblxuICAgIHJldHVybiBkYXRlRm9ybWF0XG4gICAgICAucmVwbGFjZSgveXl5eS9nLCB5ZWFyKVxuICAgICAgLnJlcGxhY2UoL3l5L2csIFN0cmluZyh5ZWFyKS5zdWJzdHJpbmcoMikpXG4gICAgICAucmVwbGFjZSgvbW0vZywgbW9udGgxIDwgMTAgPyBgMCR7bW9udGgxfWAgOiBtb250aDEpXG4gICAgICAucmVwbGFjZSgvbShcXFcrKS9nLCBgJHttb250aDF9JDFgKVxuICAgICAgLnJlcGxhY2UoL01NL2csIG1vbnRoTmFtZXNbbW9udGhdKVxuICAgICAgLnJlcGxhY2UoL00oXFxXKykvZywgYCR7bW9udGhOYW1lc1Nob3J0W21vbnRoXX0kMWApXG4gICAgICAucmVwbGFjZSgvZGQvZywgZGF5IDwgMTAgPyBgMCR7ZGF5fWAgOiBkYXkpXG4gICAgICAucmVwbGFjZSgvZChcXFcrKS9nLCBgJHtkYXl9JDFgKVxuICAgICAgLnJlcGxhY2UoL0REL2csIGRheU5hbWVzW3dlZWtEYXldKVxuICAgICAgLnJlcGxhY2UoL0QoXFxXKykvZywgYCR7ZGF5TmFtZXNTaG9ydFt3ZWVrRGF5XX0kMWApO1xuICB9XG4gIGZvcm1hdFZhbHVlKCkge1xuICAgIGNvbnN0IGNhbGVuZGFyID0gdGhpcztcbiAgICBjb25zdCB7IHZhbHVlIH0gPSBjYWxlbmRhcjtcbiAgICBpZiAoY2FsZW5kYXIucGFyYW1zLmZvcm1hdFZhbHVlKSB7XG4gICAgICByZXR1cm4gY2FsZW5kYXIucGFyYW1zLmZvcm1hdFZhbHVlLmNhbGwoY2FsZW5kYXIsIHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlXG4gICAgICAubWFwKHYgPT4gY2FsZW5kYXIuZm9ybWF0RGF0ZSh2KSlcbiAgICAgIC5qb2luKGNhbGVuZGFyLnBhcmFtcy5yYW5nZVBpY2tlciA/ICcgLSAnIDogJywgJyk7XG4gIH1cbiAgYWRkVmFsdWUobmV3VmFsdWUpIHtcbiAgICBjb25zdCBjYWxlbmRhciA9IHRoaXM7XG4gICAgY29uc3QgeyBtdWx0aXBsZSwgcmFuZ2VQaWNrZXIgfSA9IGNhbGVuZGFyLnBhcmFtcztcbiAgICBpZiAobXVsdGlwbGUpIHtcbiAgICAgIGlmICghY2FsZW5kYXIudmFsdWUpIGNhbGVuZGFyLnZhbHVlID0gW107XG4gICAgICBsZXQgaW5WYWx1ZXNJbmRleDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2FsZW5kYXIudmFsdWUubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKG5ldyBEYXRlKG5ld1ZhbHVlKS5nZXRUaW1lKCkgPT09IG5ldyBEYXRlKGNhbGVuZGFyLnZhbHVlW2ldKS5nZXRUaW1lKCkpIHtcbiAgICAgICAgICBpblZhbHVlc0luZGV4ID0gaTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBpblZhbHVlc0luZGV4ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjYWxlbmRhci52YWx1ZS5wdXNoKG5ld1ZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGVuZGFyLnZhbHVlLnNwbGljZShpblZhbHVlc0luZGV4LCAxKTtcbiAgICAgIH1cbiAgICAgIGNhbGVuZGFyLnVwZGF0ZVZhbHVlKCk7XG4gICAgfSBlbHNlIGlmIChyYW5nZVBpY2tlcikge1xuICAgICAgaWYgKCFjYWxlbmRhci52YWx1ZSkgY2FsZW5kYXIudmFsdWUgPSBbXTtcbiAgICAgIGlmIChjYWxlbmRhci52YWx1ZS5sZW5ndGggPT09IDIgfHwgY2FsZW5kYXIudmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNhbGVuZGFyLnZhbHVlID0gW107XG4gICAgICB9XG4gICAgICBpZiAoY2FsZW5kYXIudmFsdWVbMF0gIT09IG5ld1ZhbHVlKSBjYWxlbmRhci52YWx1ZS5wdXNoKG5ld1ZhbHVlKTtcbiAgICAgIGVsc2UgY2FsZW5kYXIudmFsdWUgPSBbXTtcbiAgICAgIGNhbGVuZGFyLnZhbHVlLnNvcnQoKGEsIGIpID0+IGEgLSBiKTtcbiAgICAgIGNhbGVuZGFyLnVwZGF0ZVZhbHVlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGVuZGFyLnZhbHVlID0gW25ld1ZhbHVlXTtcbiAgICAgIGNhbGVuZGFyLnVwZGF0ZVZhbHVlKCk7XG4gICAgfVxuICB9XG4gIHNldFZhbHVlKHZhbHVlcykge1xuICAgIGNvbnN0IGNhbGVuZGFyID0gdGhpcztcbiAgICBjYWxlbmRhci52YWx1ZSA9IHZhbHVlcztcbiAgICBjYWxlbmRhci51cGRhdGVWYWx1ZSgpO1xuICB9XG4gIGdldFZhbHVlKCkge1xuICAgIGNvbnN0IGNhbGVuZGFyID0gdGhpcztcbiAgICByZXR1cm4gY2FsZW5kYXIudmFsdWU7XG4gIH1cbiAgdXBkYXRlVmFsdWUob25seUhlYWRlcikge1xuICAgIGNvbnN0IGNhbGVuZGFyID0gdGhpcztcbiAgICBjb25zdCB7XG4gICAgICAkZWwsXG4gICAgICAkd3JhcHBlckVsLFxuICAgICAgJGlucHV0RWwsXG4gICAgICB2YWx1ZSxcbiAgICAgIHBhcmFtcyxcbiAgICB9ID0gY2FsZW5kYXI7XG4gICAgbGV0IGk7XG4gICAgaWYgKCRlbCAmJiAkZWwubGVuZ3RoID4gMCkge1xuICAgICAgJHdyYXBwZXJFbC5maW5kKCcuY2FsZW5kYXItZGF5LXNlbGVjdGVkJykucmVtb3ZlQ2xhc3MoJ2NhbGVuZGFyLWRheS1zZWxlY3RlZCcpO1xuICAgICAgbGV0IHZhbHVlRGF0ZTtcbiAgICAgIGlmIChwYXJhbXMucmFuZ2VQaWNrZXIgJiYgdmFsdWUubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIGZvciAoaSA9IG5ldyBEYXRlKHZhbHVlWzBdKS5nZXRUaW1lKCk7IGkgPD0gbmV3IERhdGUodmFsdWVbMV0pLmdldFRpbWUoKTsgaSArPSAyNCAqIDYwICogNjAgKiAxMDAwKSB7XG4gICAgICAgICAgdmFsdWVEYXRlID0gbmV3IERhdGUoaSk7XG4gICAgICAgICAgJHdyYXBwZXJFbC5maW5kKGAuY2FsZW5kYXItZGF5W2RhdGEtZGF0ZT1cIiR7dmFsdWVEYXRlLmdldEZ1bGxZZWFyKCl9LSR7dmFsdWVEYXRlLmdldE1vbnRoKCl9LSR7dmFsdWVEYXRlLmdldERhdGUoKX1cIl1gKS5hZGRDbGFzcygnY2FsZW5kYXItZGF5LXNlbGVjdGVkJyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjYWxlbmRhci52YWx1ZS5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgIHZhbHVlRGF0ZSA9IG5ldyBEYXRlKHZhbHVlW2ldKTtcbiAgICAgICAgICAkd3JhcHBlckVsLmZpbmQoYC5jYWxlbmRhci1kYXlbZGF0YS1kYXRlPVwiJHt2YWx1ZURhdGUuZ2V0RnVsbFllYXIoKX0tJHt2YWx1ZURhdGUuZ2V0TW9udGgoKX0tJHt2YWx1ZURhdGUuZ2V0RGF0ZSgpfVwiXWApLmFkZENsYXNzKCdjYWxlbmRhci1kYXktc2VsZWN0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIW9ubHlIZWFkZXIpIHtcbiAgICAgIGNhbGVuZGFyLmVtaXQoJ2xvY2FsOjpjaGFuZ2UgY2FsZW5kYXJDaGFuZ2UnLCBjYWxlbmRhciwgdmFsdWUpO1xuICAgIH1cblxuXG4gICAgaWYgKCgkaW5wdXRFbCAmJiAkaW5wdXRFbC5sZW5ndGgpIHx8IHBhcmFtcy5oZWFkZXIpIHtcbiAgICAgIGNvbnN0IGlucHV0VmFsdWUgPSBjYWxlbmRhci5mb3JtYXRWYWx1ZSh2YWx1ZSk7XG4gICAgICBpZiAocGFyYW1zLmhlYWRlciAmJiAkZWwgJiYgJGVsLmxlbmd0aCkge1xuICAgICAgICAkZWwuZmluZCgnLmNhbGVuZGFyLXNlbGVjdGVkLWRhdGUnKS50ZXh0KGlucHV0VmFsdWUpO1xuICAgICAgfVxuICAgICAgaWYgKCRpbnB1dEVsICYmICRpbnB1dEVsLmxlbmd0aCAmJiAhb25seUhlYWRlcikge1xuICAgICAgICAkaW5wdXRFbC52YWwoaW5wdXRWYWx1ZSk7XG4gICAgICAgICRpbnB1dEVsLnRyaWdnZXIoJ2NoYW5nZScpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICB1cGRhdGVDdXJyZW50TW9udGhZZWFyKGRpcikge1xuICAgIGNvbnN0IGNhbGVuZGFyID0gdGhpcztcbiAgICBjb25zdCB7ICRtb250aHMsICRlbCwgcGFyYW1zIH0gPSBjYWxlbmRhcjtcbiAgICBpZiAodHlwZW9mIGRpciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNhbGVuZGFyLmN1cnJlbnRNb250aCA9IHBhcnNlSW50KCRtb250aHMuZXEoMSkuYXR0cignZGF0YS1tb250aCcpLCAxMCk7XG4gICAgICBjYWxlbmRhci5jdXJyZW50WWVhciA9IHBhcnNlSW50KCRtb250aHMuZXEoMSkuYXR0cignZGF0YS15ZWFyJyksIDEwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FsZW5kYXIuY3VycmVudE1vbnRoID0gcGFyc2VJbnQoJG1vbnRocy5lcShkaXIgPT09ICduZXh0JyA/ICgkbW9udGhzLmxlbmd0aCAtIDEpIDogMCkuYXR0cignZGF0YS1tb250aCcpLCAxMCk7XG4gICAgICBjYWxlbmRhci5jdXJyZW50WWVhciA9IHBhcnNlSW50KCRtb250aHMuZXEoZGlyID09PSAnbmV4dCcgPyAoJG1vbnRocy5sZW5ndGggLSAxKSA6IDApLmF0dHIoJ2RhdGEteWVhcicpLCAxMCk7XG4gICAgfVxuICAgICRlbC5maW5kKCcuY3VycmVudC1tb250aC12YWx1ZScpLnRleHQocGFyYW1zLm1vbnRoTmFtZXNbY2FsZW5kYXIuY3VycmVudE1vbnRoXSk7XG4gICAgJGVsLmZpbmQoJy5jdXJyZW50LXllYXItdmFsdWUnKS50ZXh0KGNhbGVuZGFyLmN1cnJlbnRZZWFyKTtcbiAgfVxuICB1cGRhdGUoKSB7XG4gICAgY29uc3QgY2FsZW5kYXIgPSB0aGlzO1xuICAgIGNvbnN0IHsgY3VycmVudFllYXIsIGN1cnJlbnRNb250aCwgJHdyYXBwZXJFbCB9ID0gY2FsZW5kYXI7XG4gICAgY29uc3QgY3VycmVudERhdGUgPSBuZXcgRGF0ZShjdXJyZW50WWVhciwgY3VycmVudE1vbnRoKTtcbiAgICBjb25zdCBwcmV2TW9udGhIdG1sID0gY2FsZW5kYXIucmVuZGVyTW9udGgoY3VycmVudERhdGUsICdwcmV2Jyk7XG4gICAgY29uc3QgY3VycmVudE1vbnRoSHRtbCA9IGNhbGVuZGFyLnJlbmRlck1vbnRoKGN1cnJlbnREYXRlKTtcbiAgICBjb25zdCBuZXh0TW9udGhIdG1sID0gY2FsZW5kYXIucmVuZGVyTW9udGgoY3VycmVudERhdGUsICduZXh0Jyk7XG5cbiAgICAkd3JhcHBlckVsXG4gICAgICAudHJhbnNpdGlvbigwKVxuICAgICAgLmh0bWwoYCR7cHJldk1vbnRoSHRtbH0ke2N1cnJlbnRNb250aEh0bWx9JHtuZXh0TW9udGhIdG1sfWApXG4gICAgICAudHJhbnNmb3JtKCd0cmFuc2xhdGUzZCgwLDAsMCknKTtcbiAgICBjYWxlbmRhci4kbW9udGhzID0gJHdyYXBwZXJFbC5maW5kKCcuY2FsZW5kYXItbW9udGgnKTtcbiAgICBjYWxlbmRhci5tb250aHNUcmFuc2xhdGUgPSAwO1xuICAgIGNhbGVuZGFyLnNldE1vbnRoc1RyYW5zbGF0ZSgpO1xuICAgIGNhbGVuZGFyLiRtb250aHMuZWFjaCgoaW5kZXgsIG1vbnRoRWwpID0+IHtcbiAgICAgIGNhbGVuZGFyLmVtaXQoXG4gICAgICAgICdsb2NhbDo6bW9udGhBZGQgY2FsZW5kYXJNb250aEFkZCcsXG4gICAgICAgIG1vbnRoRWxcbiAgICAgICk7XG4gICAgfSk7XG4gIH1cbiAgb25Nb250aENoYW5nZVN0YXJ0KGRpcikge1xuICAgIGNvbnN0IGNhbGVuZGFyID0gdGhpcztcbiAgICBjb25zdCB7ICRtb250aHMsIGN1cnJlbnRZZWFyLCBjdXJyZW50TW9udGggfSA9IGNhbGVuZGFyO1xuICAgIGNhbGVuZGFyLnVwZGF0ZUN1cnJlbnRNb250aFllYXIoZGlyKTtcbiAgICAkbW9udGhzLnJlbW92ZUNsYXNzKCdjYWxlbmRhci1tb250aC1jdXJyZW50IGNhbGVuZGFyLW1vbnRoLXByZXYgY2FsZW5kYXItbW9udGgtbmV4dCcpO1xuICAgIGNvbnN0IGN1cnJlbnRJbmRleCA9IGRpciA9PT0gJ25leHQnID8gJG1vbnRocy5sZW5ndGggLSAxIDogMDtcblxuICAgICRtb250aHMuZXEoY3VycmVudEluZGV4KS5hZGRDbGFzcygnY2FsZW5kYXItbW9udGgtY3VycmVudCcpO1xuICAgICRtb250aHMuZXEoZGlyID09PSAnbmV4dCcgPyBjdXJyZW50SW5kZXggLSAxIDogY3VycmVudEluZGV4ICsgMSkuYWRkQ2xhc3MoZGlyID09PSAnbmV4dCcgPyAnY2FsZW5kYXItbW9udGgtcHJldicgOiAnY2FsZW5kYXItbW9udGgtbmV4dCcpO1xuXG4gICAgY2FsZW5kYXIuZW1pdChcbiAgICAgICdsb2NhbDo6bW9udGhZZWFyQ2hhbmdlU3RhcnQgY2FsZW5kYXJNb250aFllYXJDaGFuZ2VTdGFydCcsXG4gICAgICBjYWxlbmRhcixcbiAgICAgIGN1cnJlbnRZZWFyLFxuICAgICAgY3VycmVudE1vbnRoXG4gICAgKTtcbiAgfVxuICBvbk1vbnRoQ2hhbmdlRW5kKGRpciwgcmVidWlsZEJvdGgpIHtcbiAgICBjb25zdCBjYWxlbmRhciA9IHRoaXM7XG4gICAgY29uc3QgeyBjdXJyZW50WWVhciwgY3VycmVudE1vbnRoLCAkd3JhcHBlckVsLCBtb250aHNUcmFuc2xhdGUgfSA9IGNhbGVuZGFyO1xuICAgIGNhbGVuZGFyLmFuaW1hdGluZyA9IGZhbHNlO1xuICAgIGxldCBuZXh0TW9udGhIdG1sO1xuICAgIGxldCBwcmV2TW9udGhIdG1sO1xuICAgIGxldCBjdXJyZW50TW9udGhIdG1sO1xuICAgICR3cmFwcGVyRWxcbiAgICAgIC5maW5kKCcuY2FsZW5kYXItbW9udGg6bm90KC5jYWxlbmRhci1tb250aC1wcmV2KTpub3QoLmNhbGVuZGFyLW1vbnRoLWN1cnJlbnQpOm5vdCguY2FsZW5kYXItbW9udGgtbmV4dCknKVxuICAgICAgLnJlbW92ZSgpO1xuXG4gICAgaWYgKHR5cGVvZiBkaXIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBkaXIgPSAnbmV4dCc7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgIHJlYnVpbGRCb3RoID0gdHJ1ZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIH1cbiAgICBpZiAoIXJlYnVpbGRCb3RoKSB7XG4gICAgICBjdXJyZW50TW9udGhIdG1sID0gY2FsZW5kYXIucmVuZGVyTW9udGgobmV3IERhdGUoY3VycmVudFllYXIsIGN1cnJlbnRNb250aCksIGRpcik7XG4gICAgfSBlbHNlIHtcbiAgICAgICR3cmFwcGVyRWwuZmluZCgnLmNhbGVuZGFyLW1vbnRoLW5leHQsIC5jYWxlbmRhci1tb250aC1wcmV2JykucmVtb3ZlKCk7XG4gICAgICBwcmV2TW9udGhIdG1sID0gY2FsZW5kYXIucmVuZGVyTW9udGgobmV3IERhdGUoY3VycmVudFllYXIsIGN1cnJlbnRNb250aCksICdwcmV2Jyk7XG4gICAgICBuZXh0TW9udGhIdG1sID0gY2FsZW5kYXIucmVuZGVyTW9udGgobmV3IERhdGUoY3VycmVudFllYXIsIGN1cnJlbnRNb250aCksICduZXh0Jyk7XG4gICAgfVxuICAgIGlmIChkaXIgPT09ICduZXh0JyB8fCByZWJ1aWxkQm90aCkge1xuICAgICAgJHdyYXBwZXJFbC5hcHBlbmQoY3VycmVudE1vbnRoSHRtbCB8fCBuZXh0TW9udGhIdG1sKTtcbiAgICB9XG4gICAgaWYgKGRpciA9PT0gJ3ByZXYnIHx8IHJlYnVpbGRCb3RoKSB7XG4gICAgICAkd3JhcHBlckVsLnByZXBlbmQoY3VycmVudE1vbnRoSHRtbCB8fCBwcmV2TW9udGhIdG1sKTtcbiAgICB9XG4gICAgY29uc3QgJG1vbnRocyA9ICR3cmFwcGVyRWwuZmluZCgnLmNhbGVuZGFyLW1vbnRoJyk7XG4gICAgY2FsZW5kYXIuJG1vbnRocyA9ICRtb250aHM7XG4gICAgY2FsZW5kYXIuc2V0TW9udGhzVHJhbnNsYXRlKG1vbnRoc1RyYW5zbGF0ZSk7XG4gICAgY2FsZW5kYXIuZW1pdChcbiAgICAgICdsb2NhbDo6bW9udGhBZGQgY2FsZW5kYXJNb250aEFkZCcsXG4gICAgICBjYWxlbmRhcixcbiAgICAgIGRpciA9PT0gJ25leHQnID8gJG1vbnRocy5lcSgkbW9udGhzLmxlbmd0aCAtIDEpWzBdIDogJG1vbnRocy5lcSgwKVswXVxuICAgICk7XG4gICAgY2FsZW5kYXIuZW1pdChcbiAgICAgICdsb2NhbDo6bW9udGhZZWFyQ2hhbmdlRW5kIGNhbGVuZGFyTW9udGhZZWFyQ2hhbmdlRW5kJyxcbiAgICAgIGNhbGVuZGFyLFxuICAgICAgY3VycmVudFllYXIsXG4gICAgICBjdXJyZW50TW9udGhcbiAgICApO1xuICB9XG4gIHNldE1vbnRoc1RyYW5zbGF0ZSh0cmFuc2xhdGUpIHtcbiAgICBjb25zdCBjYWxlbmRhciA9IHRoaXM7XG4gICAgY29uc3QgeyAkbW9udGhzLCBpc0hvcml6b250YWw6IGlzSCwgaW52ZXJ0ZXIgfSA9IGNhbGVuZGFyO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgIHRyYW5zbGF0ZSA9IHRyYW5zbGF0ZSB8fCBjYWxlbmRhci5tb250aHNUcmFuc2xhdGUgfHwgMDtcbiAgICBpZiAodHlwZW9mIGNhbGVuZGFyLm1vbnRoc1RyYW5zbGF0ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNhbGVuZGFyLm1vbnRoc1RyYW5zbGF0ZSA9IHRyYW5zbGF0ZTtcbiAgICB9XG4gICAgJG1vbnRocy5yZW1vdmVDbGFzcygnY2FsZW5kYXItbW9udGgtY3VycmVudCBjYWxlbmRhci1tb250aC1wcmV2IGNhbGVuZGFyLW1vbnRoLW5leHQnKTtcbiAgICBjb25zdCBwcmV2TW9udGhUcmFuc2xhdGUgPSAtKHRyYW5zbGF0ZSArIDEpICogMTAwICogaW52ZXJ0ZXI7XG4gICAgY29uc3QgY3VycmVudE1vbnRoVHJhbnNsYXRlID0gLXRyYW5zbGF0ZSAqIDEwMCAqIGludmVydGVyO1xuICAgIGNvbnN0IG5leHRNb250aFRyYW5zbGF0ZSA9IC0odHJhbnNsYXRlIC0gMSkgKiAxMDAgKiBpbnZlcnRlcjtcbiAgICAkbW9udGhzLmVxKDApXG4gICAgICAudHJhbnNmb3JtKGB0cmFuc2xhdGUzZCgke2lzSCA/IHByZXZNb250aFRyYW5zbGF0ZSA6IDB9JSwgJHtpc0ggPyAwIDogcHJldk1vbnRoVHJhbnNsYXRlfSUsIDApYClcbiAgICAgIC5hZGRDbGFzcygnY2FsZW5kYXItbW9udGgtcHJldicpO1xuICAgICRtb250aHMuZXEoMSlcbiAgICAgIC50cmFuc2Zvcm0oYHRyYW5zbGF0ZTNkKCR7aXNIID8gY3VycmVudE1vbnRoVHJhbnNsYXRlIDogMH0lLCAke2lzSCA/IDAgOiBjdXJyZW50TW9udGhUcmFuc2xhdGV9JSwgMClgKVxuICAgICAgLmFkZENsYXNzKCdjYWxlbmRhci1tb250aC1jdXJyZW50Jyk7XG4gICAgJG1vbnRocy5lcSgyKVxuICAgICAgLnRyYW5zZm9ybShgdHJhbnNsYXRlM2QoJHtpc0ggPyBuZXh0TW9udGhUcmFuc2xhdGUgOiAwfSUsICR7aXNIID8gMCA6IG5leHRNb250aFRyYW5zbGF0ZX0lLCAwKWApXG4gICAgICAuYWRkQ2xhc3MoJ2NhbGVuZGFyLW1vbnRoLW5leHQnKTtcbiAgfVxuICBuZXh0TW9udGgodHJhbnNpdGlvbikge1xuICAgIGNvbnN0IGNhbGVuZGFyID0gdGhpcztcbiAgICBjb25zdCB7IHBhcmFtcywgJHdyYXBwZXJFbCwgaW52ZXJ0ZXIsIGlzSG9yaXpvbnRhbDogaXNIIH0gPSBjYWxlbmRhcjtcbiAgICBpZiAodHlwZW9mIHRyYW5zaXRpb24gPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiB0cmFuc2l0aW9uID09PSAnb2JqZWN0Jykge1xuICAgICAgdHJhbnNpdGlvbiA9ICcnOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICBpZiAoIXBhcmFtcy5hbmltYXRlKSB0cmFuc2l0aW9uID0gMDsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIH1cbiAgICBjb25zdCBuZXh0TW9udGggPSBwYXJzZUludChjYWxlbmRhci4kbW9udGhzLmVxKGNhbGVuZGFyLiRtb250aHMubGVuZ3RoIC0gMSkuYXR0cignZGF0YS1tb250aCcpLCAxMCk7XG4gICAgY29uc3QgbmV4dFllYXIgPSBwYXJzZUludChjYWxlbmRhci4kbW9udGhzLmVxKGNhbGVuZGFyLiRtb250aHMubGVuZ3RoIC0gMSkuYXR0cignZGF0YS15ZWFyJyksIDEwKTtcbiAgICBjb25zdCBuZXh0RGF0ZSA9IG5ldyBEYXRlKG5leHRZZWFyLCBuZXh0TW9udGgpO1xuICAgIGNvbnN0IG5leHREYXRlVGltZSA9IG5leHREYXRlLmdldFRpbWUoKTtcbiAgICBjb25zdCB0cmFuc2l0aW9uRW5kQ2FsbGJhY2sgPSAhY2FsZW5kYXIuYW5pbWF0aW5nO1xuICAgIGlmIChwYXJhbXMubWF4RGF0ZSkge1xuICAgICAgaWYgKG5leHREYXRlVGltZSA+IG5ldyBEYXRlKHBhcmFtcy5tYXhEYXRlKS5nZXRUaW1lKCkpIHtcbiAgICAgICAgY2FsZW5kYXIucmVzZXRNb250aCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGNhbGVuZGFyLm1vbnRoc1RyYW5zbGF0ZSAtPSAxO1xuICAgIGlmIChuZXh0TW9udGggPT09IGNhbGVuZGFyLmN1cnJlbnRNb250aCkge1xuICAgICAgY29uc3QgbmV4dE1vbnRoVHJhbnNsYXRlID0gLShjYWxlbmRhci5tb250aHNUcmFuc2xhdGUpICogMTAwICogaW52ZXJ0ZXI7XG4gICAgICBjb25zdCBuZXh0TW9udGhIdG1sID0gJChjYWxlbmRhci5yZW5kZXJNb250aChuZXh0RGF0ZVRpbWUsICduZXh0JykpXG4gICAgICAgIC50cmFuc2Zvcm0oYHRyYW5zbGF0ZTNkKCR7aXNIID8gbmV4dE1vbnRoVHJhbnNsYXRlIDogMH0lLCAke2lzSCA/IDAgOiBuZXh0TW9udGhUcmFuc2xhdGV9JSwgMClgKVxuICAgICAgICAuYWRkQ2xhc3MoJ2NhbGVuZGFyLW1vbnRoLW5leHQnKTtcbiAgICAgICR3cmFwcGVyRWwuYXBwZW5kKG5leHRNb250aEh0bWxbMF0pO1xuICAgICAgY2FsZW5kYXIuJG1vbnRocyA9ICR3cmFwcGVyRWwuZmluZCgnLmNhbGVuZGFyLW1vbnRoJyk7XG4gICAgICBjYWxlbmRhci5lbWl0KFxuICAgICAgICAnbG9jYWw6Om1vbnRoQWRkIGNhbGVuZGFyTW9udGhBZGQnLFxuICAgICAgICBjYWxlbmRhci4kbW9udGhzLmVxKGNhbGVuZGFyLiRtb250aHMubGVuZ3RoIC0gMSlbMF1cbiAgICAgICk7XG4gICAgfVxuICAgIGNhbGVuZGFyLmFuaW1hdGluZyA9IHRydWU7XG4gICAgY2FsZW5kYXIub25Nb250aENoYW5nZVN0YXJ0KCduZXh0Jyk7XG4gICAgY29uc3QgdHJhbnNsYXRlID0gKGNhbGVuZGFyLm1vbnRoc1RyYW5zbGF0ZSAqIDEwMCkgKiBpbnZlcnRlcjtcblxuICAgICR3cmFwcGVyRWwudHJhbnNpdGlvbih0cmFuc2l0aW9uKS50cmFuc2Zvcm0oYHRyYW5zbGF0ZTNkKCR7aXNIID8gdHJhbnNsYXRlIDogMH0lLCAke2lzSCA/IDAgOiB0cmFuc2xhdGV9JSwgMClgKTtcbiAgICBpZiAodHJhbnNpdGlvbkVuZENhbGxiYWNrKSB7XG4gICAgICAkd3JhcHBlckVsLnRyYW5zaXRpb25FbmQoKCkgPT4ge1xuICAgICAgICBjYWxlbmRhci5vbk1vbnRoQ2hhbmdlRW5kKCduZXh0Jyk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKCFwYXJhbXMuYW5pbWF0ZSkge1xuICAgICAgY2FsZW5kYXIub25Nb250aENoYW5nZUVuZCgnbmV4dCcpO1xuICAgIH1cbiAgfVxuICBwcmV2TW9udGgodHJhbnNpdGlvbikge1xuICAgIGNvbnN0IGNhbGVuZGFyID0gdGhpcztcbiAgICBjb25zdCB7IHBhcmFtcywgJHdyYXBwZXJFbCwgaW52ZXJ0ZXIsIGlzSG9yaXpvbnRhbDogaXNIIH0gPSBjYWxlbmRhcjtcbiAgICBpZiAodHlwZW9mIHRyYW5zaXRpb24gPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiB0cmFuc2l0aW9uID09PSAnb2JqZWN0Jykge1xuICAgICAgdHJhbnNpdGlvbiA9ICcnOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICBpZiAoIXBhcmFtcy5hbmltYXRlKSB0cmFuc2l0aW9uID0gMDsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIH1cbiAgICBjb25zdCBwcmV2TW9udGggPSBwYXJzZUludChjYWxlbmRhci4kbW9udGhzLmVxKDApLmF0dHIoJ2RhdGEtbW9udGgnKSwgMTApO1xuICAgIGNvbnN0IHByZXZZZWFyID0gcGFyc2VJbnQoY2FsZW5kYXIuJG1vbnRocy5lcSgwKS5hdHRyKCdkYXRhLXllYXInKSwgMTApO1xuICAgIGNvbnN0IHByZXZEYXRlID0gbmV3IERhdGUocHJldlllYXIsIHByZXZNb250aCArIDEsIC0xKTtcbiAgICBjb25zdCBwcmV2RGF0ZVRpbWUgPSBwcmV2RGF0ZS5nZXRUaW1lKCk7XG4gICAgY29uc3QgdHJhbnNpdGlvbkVuZENhbGxiYWNrID0gIWNhbGVuZGFyLmFuaW1hdGluZztcbiAgICBpZiAocGFyYW1zLm1pbkRhdGUpIHtcbiAgICAgIGlmIChwcmV2RGF0ZVRpbWUgPCBuZXcgRGF0ZShwYXJhbXMubWluRGF0ZSkuZ2V0VGltZSgpKSB7XG4gICAgICAgIGNhbGVuZGFyLnJlc2V0TW9udGgoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBjYWxlbmRhci5tb250aHNUcmFuc2xhdGUgKz0gMTtcbiAgICBpZiAocHJldk1vbnRoID09PSBjYWxlbmRhci5jdXJyZW50TW9udGgpIHtcbiAgICAgIGNvbnN0IHByZXZNb250aFRyYW5zbGF0ZSA9IC0oY2FsZW5kYXIubW9udGhzVHJhbnNsYXRlKSAqIDEwMCAqIGludmVydGVyO1xuICAgICAgY29uc3QgcHJldk1vbnRoSHRtbCA9ICQoY2FsZW5kYXIucmVuZGVyTW9udGgocHJldkRhdGVUaW1lLCAncHJldicpKVxuICAgICAgICAudHJhbnNmb3JtKGB0cmFuc2xhdGUzZCgke2lzSCA/IHByZXZNb250aFRyYW5zbGF0ZSA6IDB9JSwgJHtpc0ggPyAwIDogcHJldk1vbnRoVHJhbnNsYXRlfSUsIDApYClcbiAgICAgICAgLmFkZENsYXNzKCdjYWxlbmRhci1tb250aC1wcmV2Jyk7XG4gICAgICAkd3JhcHBlckVsLnByZXBlbmQocHJldk1vbnRoSHRtbFswXSk7XG4gICAgICBjYWxlbmRhci4kbW9udGhzID0gJHdyYXBwZXJFbC5maW5kKCcuY2FsZW5kYXItbW9udGgnKTtcbiAgICAgIGNhbGVuZGFyLmVtaXQoXG4gICAgICAgICdsb2NhbDo6bW9udGhBZGQgY2FsZW5kYXJNb250aEFkZCcsXG4gICAgICAgIGNhbGVuZGFyLiRtb250aHMuZXEoMClbMF1cbiAgICAgICk7XG4gICAgfVxuICAgIGNhbGVuZGFyLmFuaW1hdGluZyA9IHRydWU7XG4gICAgY2FsZW5kYXIub25Nb250aENoYW5nZVN0YXJ0KCdwcmV2Jyk7XG4gICAgY29uc3QgdHJhbnNsYXRlID0gKGNhbGVuZGFyLm1vbnRoc1RyYW5zbGF0ZSAqIDEwMCkgKiBpbnZlcnRlcjtcbiAgICAkd3JhcHBlckVsXG4gICAgICAudHJhbnNpdGlvbih0cmFuc2l0aW9uKVxuICAgICAgLnRyYW5zZm9ybShgdHJhbnNsYXRlM2QoJHtpc0ggPyB0cmFuc2xhdGUgOiAwfSUsICR7aXNIID8gMCA6IHRyYW5zbGF0ZX0lLCAwKWApO1xuICAgIGlmICh0cmFuc2l0aW9uRW5kQ2FsbGJhY2spIHtcbiAgICAgICR3cmFwcGVyRWwudHJhbnNpdGlvbkVuZCgoKSA9PiB7XG4gICAgICAgIGNhbGVuZGFyLm9uTW9udGhDaGFuZ2VFbmQoJ3ByZXYnKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoIXBhcmFtcy5hbmltYXRlKSB7XG4gICAgICBjYWxlbmRhci5vbk1vbnRoQ2hhbmdlRW5kKCdwcmV2Jyk7XG4gICAgfVxuICB9XG4gIHJlc2V0TW9udGgodHJhbnNpdGlvbiA9ICcnKSB7XG4gICAgY29uc3QgY2FsZW5kYXIgPSB0aGlzO1xuICAgIGNvbnN0IHsgJHdyYXBwZXJFbCwgaW52ZXJ0ZXIsIGlzSG9yaXpvbnRhbDogaXNILCBtb250aHNUcmFuc2xhdGUgfSA9IGNhbGVuZGFyO1xuICAgIGNvbnN0IHRyYW5zbGF0ZSA9IChtb250aHNUcmFuc2xhdGUgKiAxMDApICogaW52ZXJ0ZXI7XG4gICAgJHdyYXBwZXJFbFxuICAgICAgLnRyYW5zaXRpb24odHJhbnNpdGlvbilcbiAgICAgIC50cmFuc2Zvcm0oYHRyYW5zbGF0ZTNkKCR7aXNIID8gdHJhbnNsYXRlIDogMH0lLCAke2lzSCA/IDAgOiB0cmFuc2xhdGV9JSwgMClgKTtcbiAgfVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgc2V0WWVhck1vbnRoKHllYXIsIG1vbnRoLCB0cmFuc2l0aW9uKSB7XG4gICAgY29uc3QgY2FsZW5kYXIgPSB0aGlzO1xuICAgIGNvbnN0IHsgcGFyYW1zLCBpc0hvcml6b250YWw6IGlzSCwgJHdyYXBwZXJFbCwgaW52ZXJ0ZXIgfSA9IGNhbGVuZGFyO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgIGlmICh0eXBlb2YgeWVhciA9PT0gJ3VuZGVmaW5lZCcpIHllYXIgPSBjYWxlbmRhci5jdXJyZW50WWVhcjtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICBpZiAodHlwZW9mIG1vbnRoID09PSAndW5kZWZpbmVkJykgbW9udGggPSBjYWxlbmRhci5jdXJyZW50TW9udGg7XG4gICAgaWYgKHR5cGVvZiB0cmFuc2l0aW9uID09PSAndW5kZWZpbmVkJyB8fCB0eXBlb2YgdHJhbnNpdGlvbiA9PT0gJ29iamVjdCcpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgdHJhbnNpdGlvbiA9ICcnO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICBpZiAoIXBhcmFtcy5hbmltYXRlKSB0cmFuc2l0aW9uID0gMDtcbiAgICB9XG4gICAgbGV0IHRhcmdldERhdGU7XG4gICAgaWYgKHllYXIgPCBjYWxlbmRhci5jdXJyZW50WWVhcikge1xuICAgICAgdGFyZ2V0RGF0ZSA9IG5ldyBEYXRlKHllYXIsIG1vbnRoICsgMSwgLTEpLmdldFRpbWUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGFyZ2V0RGF0ZSA9IG5ldyBEYXRlKHllYXIsIG1vbnRoKS5nZXRUaW1lKCk7XG4gICAgfVxuICAgIGlmIChwYXJhbXMubWF4RGF0ZSAmJiB0YXJnZXREYXRlID4gbmV3IERhdGUocGFyYW1zLm1heERhdGUpLmdldFRpbWUoKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAocGFyYW1zLm1pbkRhdGUgJiYgdGFyZ2V0RGF0ZSA8IG5ldyBEYXRlKHBhcmFtcy5taW5EYXRlKS5nZXRUaW1lKCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgY3VycmVudERhdGUgPSBuZXcgRGF0ZShjYWxlbmRhci5jdXJyZW50WWVhciwgY2FsZW5kYXIuY3VycmVudE1vbnRoKS5nZXRUaW1lKCk7XG4gICAgY29uc3QgZGlyID0gdGFyZ2V0RGF0ZSA+IGN1cnJlbnREYXRlID8gJ25leHQnIDogJ3ByZXYnO1xuICAgIGNvbnN0IG5ld01vbnRoSFRNTCA9IGNhbGVuZGFyLnJlbmRlck1vbnRoKG5ldyBEYXRlKHllYXIsIG1vbnRoKSk7XG4gICAgY2FsZW5kYXIubW9udGhzVHJhbnNsYXRlID0gY2FsZW5kYXIubW9udGhzVHJhbnNsYXRlIHx8IDA7XG4gICAgY29uc3QgcHJldlRyYW5zbGF0ZSA9IGNhbGVuZGFyLm1vbnRoc1RyYW5zbGF0ZTtcbiAgICBsZXQgbW9udGhUcmFuc2xhdGU7XG4gICAgY29uc3QgdHJhbnNpdGlvbkVuZENhbGxiYWNrID0gIWNhbGVuZGFyLmFuaW1hdGluZztcbiAgICBpZiAodGFyZ2V0RGF0ZSA+IGN1cnJlbnREYXRlKSB7XG4gICAgICAvLyBUbyBuZXh0XG4gICAgICBjYWxlbmRhci5tb250aHNUcmFuc2xhdGUgLT0gMTtcbiAgICAgIGlmICghY2FsZW5kYXIuYW5pbWF0aW5nKSBjYWxlbmRhci4kbW9udGhzLmVxKGNhbGVuZGFyLiRtb250aHMubGVuZ3RoIC0gMSkucmVtb3ZlKCk7XG4gICAgICAkd3JhcHBlckVsLmFwcGVuZChuZXdNb250aEhUTUwpO1xuICAgICAgY2FsZW5kYXIuJG1vbnRocyA9ICR3cmFwcGVyRWwuZmluZCgnLmNhbGVuZGFyLW1vbnRoJyk7XG4gICAgICBtb250aFRyYW5zbGF0ZSA9IC0ocHJldlRyYW5zbGF0ZSAtIDEpICogMTAwICogaW52ZXJ0ZXI7XG4gICAgICBjYWxlbmRhci4kbW9udGhzXG4gICAgICAgIC5lcShjYWxlbmRhci4kbW9udGhzLmxlbmd0aCAtIDEpXG4gICAgICAgIC50cmFuc2Zvcm0oYHRyYW5zbGF0ZTNkKCR7aXNIID8gbW9udGhUcmFuc2xhdGUgOiAwfSUsICR7aXNIID8gMCA6IG1vbnRoVHJhbnNsYXRlfSUsIDApYClcbiAgICAgICAgLmFkZENsYXNzKCdjYWxlbmRhci1tb250aC1uZXh0Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRvIHByZXZcbiAgICAgIGNhbGVuZGFyLm1vbnRoc1RyYW5zbGF0ZSArPSAxO1xuICAgICAgaWYgKCFjYWxlbmRhci5hbmltYXRpbmcpIGNhbGVuZGFyLiRtb250aHMuZXEoMCkucmVtb3ZlKCk7XG4gICAgICAkd3JhcHBlckVsLnByZXBlbmQobmV3TW9udGhIVE1MKTtcbiAgICAgIGNhbGVuZGFyLiRtb250aHMgPSAkd3JhcHBlckVsLmZpbmQoJy5jYWxlbmRhci1tb250aCcpO1xuICAgICAgbW9udGhUcmFuc2xhdGUgPSAtKHByZXZUcmFuc2xhdGUgKyAxKSAqIDEwMCAqIGludmVydGVyO1xuICAgICAgY2FsZW5kYXIuJG1vbnRoc1xuICAgICAgICAuZXEoMClcbiAgICAgICAgLnRyYW5zZm9ybShgdHJhbnNsYXRlM2QoJHtpc0ggPyBtb250aFRyYW5zbGF0ZSA6IDB9JSwgJHtpc0ggPyAwIDogbW9udGhUcmFuc2xhdGV9JSwgMClgKVxuICAgICAgICAuYWRkQ2xhc3MoJ2NhbGVuZGFyLW1vbnRoLXByZXYnKTtcbiAgICB9XG4gICAgY2FsZW5kYXIuZW1pdChcbiAgICAgICdsb2NhbDo6bW9udGhBZGQgY2FsZW5kYXJNb250aEFkZCcsXG4gICAgICBkaXIgPT09ICduZXh0J1xuICAgICAgICA/IGNhbGVuZGFyLiRtb250aHMuZXEoY2FsZW5kYXIuJG1vbnRocy5sZW5ndGggLSAxKVswXVxuICAgICAgICA6IGNhbGVuZGFyLiRtb250aHMuZXEoMClbMF1cbiAgICApO1xuXG4gICAgY2FsZW5kYXIuYW5pbWF0aW5nID0gdHJ1ZTtcbiAgICBjYWxlbmRhci5vbk1vbnRoQ2hhbmdlU3RhcnQoZGlyKTtcbiAgICBjb25zdCB3cmFwcGVyVHJhbnNsYXRlID0gKGNhbGVuZGFyLm1vbnRoc1RyYW5zbGF0ZSAqIDEwMCkgKiBpbnZlcnRlcjtcbiAgICAkd3JhcHBlckVsXG4gICAgICAudHJhbnNpdGlvbih0cmFuc2l0aW9uKVxuICAgICAgLnRyYW5zZm9ybShgdHJhbnNsYXRlM2QoJHtpc0ggPyB3cmFwcGVyVHJhbnNsYXRlIDogMH0lLCAke2lzSCA/IDAgOiB3cmFwcGVyVHJhbnNsYXRlfSUsIDApYCk7XG4gICAgaWYgKHRyYW5zaXRpb25FbmRDYWxsYmFjaykge1xuICAgICAgJHdyYXBwZXJFbC50cmFuc2l0aW9uRW5kKCgpID0+IHtcbiAgICAgICAgY2FsZW5kYXIub25Nb250aENoYW5nZUVuZChkaXIsIHRydWUpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICghcGFyYW1zLmFuaW1hdGUpIHtcbiAgICAgIGNhbGVuZGFyLm9uTW9udGhDaGFuZ2VFbmQoZGlyKTtcbiAgICB9XG4gIH1cbiAgbmV4dFllYXIoKSB7XG4gICAgY29uc3QgY2FsZW5kYXIgPSB0aGlzO1xuICAgIGNhbGVuZGFyLnNldFllYXJNb250aChjYWxlbmRhci5jdXJyZW50WWVhciArIDEpO1xuICB9XG4gIHByZXZZZWFyKCkge1xuICAgIGNvbnN0IGNhbGVuZGFyID0gdGhpcztcbiAgICBjYWxlbmRhci5zZXRZZWFyTW9udGgoY2FsZW5kYXIuY3VycmVudFllYXIgLSAxKTtcbiAgfVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgZGF0ZUluUmFuZ2UoZGF5RGF0ZSwgcmFuZ2UpIHtcbiAgICBsZXQgbWF0Y2ggPSBmYWxzZTtcbiAgICBsZXQgaTtcbiAgICBpZiAoIXJhbmdlKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocmFuZ2UpKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgcmFuZ2UubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKHJhbmdlW2ldLmZyb20gfHwgcmFuZ2VbaV0udG8pIHtcbiAgICAgICAgICBpZiAocmFuZ2VbaV0uZnJvbSAmJiByYW5nZVtpXS50bykge1xuICAgICAgICAgICAgaWYgKChkYXlEYXRlIDw9IG5ldyBEYXRlKHJhbmdlW2ldLnRvKS5nZXRUaW1lKCkpICYmIChkYXlEYXRlID49IG5ldyBEYXRlKHJhbmdlW2ldLmZyb20pLmdldFRpbWUoKSkpIHtcbiAgICAgICAgICAgICAgbWF0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAocmFuZ2VbaV0uZnJvbSkge1xuICAgICAgICAgICAgaWYgKGRheURhdGUgPj0gbmV3IERhdGUocmFuZ2VbaV0uZnJvbSkuZ2V0VGltZSgpKSB7XG4gICAgICAgICAgICAgIG1hdGNoID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHJhbmdlW2ldLnRvKSB7XG4gICAgICAgICAgICBpZiAoZGF5RGF0ZSA8PSBuZXcgRGF0ZShyYW5nZVtpXS50bykuZ2V0VGltZSgpKSB7XG4gICAgICAgICAgICAgIG1hdGNoID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZGF5RGF0ZSA9PT0gbmV3IERhdGUocmFuZ2VbaV0pLmdldFRpbWUoKSkge1xuICAgICAgICAgIG1hdGNoID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocmFuZ2UuZnJvbSB8fCByYW5nZS50bykge1xuICAgICAgaWYgKHJhbmdlLmZyb20gJiYgcmFuZ2UudG8pIHtcbiAgICAgICAgaWYgKChkYXlEYXRlIDw9IG5ldyBEYXRlKHJhbmdlLnRvKS5nZXRUaW1lKCkpICYmIChkYXlEYXRlID49IG5ldyBEYXRlKHJhbmdlLmZyb20pLmdldFRpbWUoKSkpIHtcbiAgICAgICAgICBtYXRjaCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocmFuZ2UuZnJvbSkge1xuICAgICAgICBpZiAoZGF5RGF0ZSA+PSBuZXcgRGF0ZShyYW5nZS5mcm9tKS5nZXRUaW1lKCkpIHtcbiAgICAgICAgICBtYXRjaCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocmFuZ2UudG8pIHtcbiAgICAgICAgaWYgKGRheURhdGUgPD0gbmV3IERhdGUocmFuZ2UudG8pLmdldFRpbWUoKSkge1xuICAgICAgICAgIG1hdGNoID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHJhbmdlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBtYXRjaCA9IHJhbmdlKG5ldyBEYXRlKGRheURhdGUpKTtcbiAgICB9XG4gICAgcmV0dXJuIG1hdGNoO1xuICB9XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICBkYXlzSW5Nb250aChkYXRlKSB7XG4gICAgY29uc3QgZCA9IG5ldyBEYXRlKGRhdGUpO1xuICAgIHJldHVybiBuZXcgRGF0ZShkLmdldEZ1bGxZZWFyKCksIGQuZ2V0TW9udGgoKSArIDEsIDApLmdldERhdGUoKTtcbiAgfVxuICByZW5kZXJNb250aHMoZGF0ZSkge1xuICAgIGNvbnN0IGNhbGVuZGFyID0gdGhpcztcbiAgICBpZiAoY2FsZW5kYXIucGFyYW1zLnJlbmRlck1vbnRocykge1xuICAgICAgcmV0dXJuIGNhbGVuZGFyLnBhcmFtcy5yZW5kZXJNb250aHMuY2FsbChjYWxlbmRhciwgZGF0ZSk7XG4gICAgfVxuICAgIHJldHVybiBgXG4gICAgICA8ZGl2IGNsYXNzPVwiY2FsZW5kYXItbW9udGhzLXdyYXBwZXJcIj5cbiAgICAgICAgJHtjYWxlbmRhci5yZW5kZXJNb250aChkYXRlLCAncHJldicpfVxuICAgICAgICAke2NhbGVuZGFyLnJlbmRlck1vbnRoKGRhdGUpfVxuICAgICAgICAke2NhbGVuZGFyLnJlbmRlck1vbnRoKGRhdGUsICduZXh0Jyl9XG4gICAgICA8L2Rpdj5cbiAgICBgLnRyaW0oKTtcbiAgfVxuICByZW5kZXJNb250aChkLCBvZmZzZXQpIHtcbiAgICBjb25zdCBjYWxlbmRhciA9IHRoaXM7XG4gICAgY29uc3QgeyBwYXJhbXMsIHZhbHVlIH0gPSBjYWxlbmRhcjtcbiAgICBpZiAocGFyYW1zLnJlbmRlck1vbnRoKSB7XG4gICAgICByZXR1cm4gcGFyYW1zLnJlbmRlck1vbnRoLmNhbGwoY2FsZW5kYXIsIGQsIG9mZnNldCk7XG4gICAgfVxuICAgIGxldCBkYXRlID0gbmV3IERhdGUoZCk7XG4gICAgbGV0IHllYXIgPSBkYXRlLmdldEZ1bGxZZWFyKCk7XG4gICAgbGV0IG1vbnRoID0gZGF0ZS5nZXRNb250aCgpO1xuXG4gICAgaWYgKG9mZnNldCA9PT0gJ25leHQnKSB7XG4gICAgICBpZiAobW9udGggPT09IDExKSBkYXRlID0gbmV3IERhdGUoeWVhciArIDEsIDApO1xuICAgICAgZWxzZSBkYXRlID0gbmV3IERhdGUoeWVhciwgbW9udGggKyAxLCAxKTtcbiAgICB9XG4gICAgaWYgKG9mZnNldCA9PT0gJ3ByZXYnKSB7XG4gICAgICBpZiAobW9udGggPT09IDApIGRhdGUgPSBuZXcgRGF0ZSh5ZWFyIC0gMSwgMTEpO1xuICAgICAgZWxzZSBkYXRlID0gbmV3IERhdGUoeWVhciwgbW9udGggLSAxLCAxKTtcbiAgICB9XG4gICAgaWYgKG9mZnNldCA9PT0gJ25leHQnIHx8IG9mZnNldCA9PT0gJ3ByZXYnKSB7XG4gICAgICBtb250aCA9IGRhdGUuZ2V0TW9udGgoKTtcbiAgICAgIHllYXIgPSBkYXRlLmdldEZ1bGxZZWFyKCk7XG4gICAgfVxuXG4gICAgY29uc3QgY3VycmVudFZhbHVlcyA9IFtdO1xuICAgIGNvbnN0IHRvZGF5ID0gbmV3IERhdGUoKS5zZXRIb3VycygwLCAwLCAwLCAwKTtcbiAgICBjb25zdCBtaW5EYXRlID0gcGFyYW1zLm1pbkRhdGUgPyBuZXcgRGF0ZShwYXJhbXMubWluRGF0ZSkuZ2V0VGltZSgpIDogbnVsbDtcbiAgICBjb25zdCBtYXhEYXRlID0gcGFyYW1zLm1heERhdGUgPyBuZXcgRGF0ZShwYXJhbXMubWF4RGF0ZSkuZ2V0VGltZSgpIDogbnVsbDtcbiAgICBjb25zdCByb3dzID0gNjtcbiAgICBjb25zdCBjb2xzID0gNztcbiAgICBjb25zdCBkYXlzSW5QcmV2TW9udGggPSBjYWxlbmRhci5kYXlzSW5Nb250aChuZXcgRGF0ZShkYXRlLmdldEZ1bGxZZWFyKCksIGRhdGUuZ2V0TW9udGgoKSkuZ2V0VGltZSgpIC0gKDEwICogMjQgKiA2MCAqIDYwICogMTAwMCkpO1xuICAgIGNvbnN0IGRheXNJbk1vbnRoID0gY2FsZW5kYXIuZGF5c0luTW9udGgoZGF0ZSk7XG4gICAgY29uc3QgbWluRGF5TnVtYmVyID0gcGFyYW1zLmZpcnN0RGF5ID09PSA2ID8gMCA6IDE7XG5cbiAgICBsZXQgbW9udGhIdG1sID0gJyc7XG4gICAgbGV0IGRheUluZGV4ID0gMCArIChwYXJhbXMuZmlyc3REYXkgLSAxKTtcbiAgICBsZXQgZGlzYWJsZWQ7XG4gICAgbGV0IGhhc0V2ZW50O1xuICAgIGxldCBmaXJzdERheU9mTW9udGhJbmRleCA9IG5ldyBEYXRlKGRhdGUuZ2V0RnVsbFllYXIoKSwgZGF0ZS5nZXRNb250aCgpKS5nZXREYXkoKTtcbiAgICBpZiAoZmlyc3REYXlPZk1vbnRoSW5kZXggPT09IDApIGZpcnN0RGF5T2ZNb250aEluZGV4ID0gNztcblxuICAgIGlmICh2YWx1ZSAmJiB2YWx1ZS5sZW5ndGgpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgY3VycmVudFZhbHVlcy5wdXNoKG5ldyBEYXRlKHZhbHVlW2ldKS5zZXRIb3VycygwLCAwLCAwLCAwKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChsZXQgcm93ID0gMTsgcm93IDw9IHJvd3M7IHJvdyArPSAxKSB7XG4gICAgICBsZXQgcm93SHRtbCA9ICcnO1xuICAgICAgZm9yIChsZXQgY29sID0gMTsgY29sIDw9IGNvbHM7IGNvbCArPSAxKSB7XG4gICAgICAgIGRheUluZGV4ICs9IDE7XG4gICAgICAgIGxldCBkYXlEYXRlO1xuICAgICAgICBsZXQgZGF5TnVtYmVyID0gZGF5SW5kZXggLSBmaXJzdERheU9mTW9udGhJbmRleDtcbiAgICAgICAgbGV0IGFkZENsYXNzID0gJyc7XG4gICAgICAgIGlmIChyb3cgPT09IDEgJiYgY29sID09PSAxICYmIGRheU51bWJlciA+IG1pbkRheU51bWJlciAmJiBwYXJhbXMuZmlyc3REYXkgIT09IDEpIHtcbiAgICAgICAgICBkYXlJbmRleCAtPSA3O1xuICAgICAgICAgIGRheU51bWJlciA9IGRheUluZGV4IC0gZmlyc3REYXlPZk1vbnRoSW5kZXg7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB3ZWVrRGF5SW5kZXggPSAoKGNvbCAtIDEpICsgcGFyYW1zLmZpcnN0RGF5ID4gNilcbiAgICAgICAgICA/ICgoY29sIC0gMSAtIDcpICsgcGFyYW1zLmZpcnN0RGF5KVxuICAgICAgICAgIDogKChjb2wgLSAxKSArIHBhcmFtcy5maXJzdERheSk7XG5cbiAgICAgICAgaWYgKGRheU51bWJlciA8IDApIHtcbiAgICAgICAgICBkYXlOdW1iZXIgPSBkYXlzSW5QcmV2TW9udGggKyBkYXlOdW1iZXIgKyAxO1xuICAgICAgICAgIGFkZENsYXNzICs9ICcgY2FsZW5kYXItZGF5LXByZXYnO1xuICAgICAgICAgIGRheURhdGUgPSBuZXcgRGF0ZShtb250aCAtIDEgPCAwID8geWVhciAtIDEgOiB5ZWFyLCBtb250aCAtIDEgPCAwID8gMTEgOiBtb250aCAtIDEsIGRheU51bWJlcikuZ2V0VGltZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRheU51bWJlciArPSAxO1xuICAgICAgICAgIGlmIChkYXlOdW1iZXIgPiBkYXlzSW5Nb250aCkge1xuICAgICAgICAgICAgZGF5TnVtYmVyIC09IGRheXNJbk1vbnRoO1xuICAgICAgICAgICAgYWRkQ2xhc3MgKz0gJyBjYWxlbmRhci1kYXktbmV4dCc7XG4gICAgICAgICAgICBkYXlEYXRlID0gbmV3IERhdGUobW9udGggKyAxID4gMTEgPyB5ZWFyICsgMSA6IHllYXIsIG1vbnRoICsgMSA+IDExID8gMCA6IG1vbnRoICsgMSwgZGF5TnVtYmVyKS5nZXRUaW1lKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRheURhdGUgPSBuZXcgRGF0ZSh5ZWFyLCBtb250aCwgZGF5TnVtYmVyKS5nZXRUaW1lKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFRvZGF5XG4gICAgICAgIGlmIChkYXlEYXRlID09PSB0b2RheSkgYWRkQ2xhc3MgKz0gJyBjYWxlbmRhci1kYXktdG9kYXknO1xuXG4gICAgICAgIC8vIFNlbGVjdGVkXG4gICAgICAgIGlmIChwYXJhbXMucmFuZ2VQaWNrZXIgJiYgY3VycmVudFZhbHVlcy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICBpZiAoZGF5RGF0ZSA+PSBjdXJyZW50VmFsdWVzWzBdICYmIGRheURhdGUgPD0gY3VycmVudFZhbHVlc1sxXSkgYWRkQ2xhc3MgKz0gJyBjYWxlbmRhci1kYXktc2VsZWN0ZWQnO1xuICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnRWYWx1ZXMuaW5kZXhPZihkYXlEYXRlKSA+PSAwKSBhZGRDbGFzcyArPSAnIGNhbGVuZGFyLWRheS1zZWxlY3RlZCc7XG4gICAgICAgIC8vIFdlZWtlbmRcbiAgICAgICAgaWYgKHBhcmFtcy53ZWVrZW5kRGF5cy5pbmRleE9mKHdlZWtEYXlJbmRleCkgPj0gMCkge1xuICAgICAgICAgIGFkZENsYXNzICs9ICcgY2FsZW5kYXItZGF5LXdlZWtlbmQnO1xuICAgICAgICB9XG4gICAgICAgIC8vIEhhcyBFdmVudHNcbiAgICAgICAgaGFzRXZlbnQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHBhcmFtcy5ldmVudHMpIHtcbiAgICAgICAgICBpZiAoY2FsZW5kYXIuZGF0ZUluUmFuZ2UoZGF5RGF0ZSwgcGFyYW1zLmV2ZW50cykpIHtcbiAgICAgICAgICAgIGhhc0V2ZW50ID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc0V2ZW50KSB7XG4gICAgICAgICAgYWRkQ2xhc3MgKz0gJyBjYWxlbmRhci1kYXktaGFzLWV2ZW50cyc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ3VzdG9tIFJhbmdlc1xuICAgICAgICBpZiAocGFyYW1zLnJhbmdlc0NsYXNzZXMpIHtcbiAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IHBhcmFtcy5yYW5nZXNDbGFzc2VzLmxlbmd0aDsgayArPSAxKSB7XG4gICAgICAgICAgICBpZiAoY2FsZW5kYXIuZGF0ZUluUmFuZ2UoZGF5RGF0ZSwgcGFyYW1zLnJhbmdlc0NsYXNzZXNba10ucmFuZ2UpKSB7XG4gICAgICAgICAgICAgIGFkZENsYXNzICs9IGAgJHtwYXJhbXMucmFuZ2VzQ2xhc3Nlc1trXS5jc3NDbGFzc31gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBEaXNhYmxlZFxuICAgICAgICBkaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICBpZiAoKG1pbkRhdGUgJiYgZGF5RGF0ZSA8IG1pbkRhdGUpIHx8IChtYXhEYXRlICYmIGRheURhdGUgPiBtYXhEYXRlKSkge1xuICAgICAgICAgIGRpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyYW1zLmRpc2FibGVkKSB7XG4gICAgICAgICAgaWYgKGNhbGVuZGFyLmRhdGVJblJhbmdlKGRheURhdGUsIHBhcmFtcy5kaXNhYmxlZCkpIHtcbiAgICAgICAgICAgIGRpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRpc2FibGVkKSB7XG4gICAgICAgICAgYWRkQ2xhc3MgKz0gJyBjYWxlbmRhci1kYXktZGlzYWJsZWQnO1xuICAgICAgICB9XG5cbiAgICAgICAgZGF5RGF0ZSA9IG5ldyBEYXRlKGRheURhdGUpO1xuICAgICAgICBjb25zdCBkYXlZZWFyID0gZGF5RGF0ZS5nZXRGdWxsWWVhcigpO1xuICAgICAgICBjb25zdCBkYXlNb250aCA9IGRheURhdGUuZ2V0TW9udGgoKTtcbiAgICAgICAgcm93SHRtbCArPSBgXG4gICAgICAgICAgPGRpdiBkYXRhLXllYXI9XCIke2RheVllYXJ9XCIgZGF0YS1tb250aD1cIiR7ZGF5TW9udGh9XCIgZGF0YS1kYXk9XCIke2RheU51bWJlcn1cIiBjbGFzcz1cImNhbGVuZGFyLWRheSR7YWRkQ2xhc3N9XCIgZGF0YS1kYXRlPVwiJHtkYXlZZWFyfS0ke2RheU1vbnRofS0ke2RheU51bWJlcn1cIj5cbiAgICAgICAgICAgIDxzcGFuPiR7ZGF5TnVtYmVyfTwvc3Bhbj5cbiAgICAgICAgICA8L2Rpdj5gLnRyaW0oKTtcbiAgICAgIH1cbiAgICAgIG1vbnRoSHRtbCArPSBgPGRpdiBjbGFzcz1cImNhbGVuZGFyLXJvd1wiPiR7cm93SHRtbH08L2Rpdj5gO1xuICAgIH1cbiAgICBtb250aEh0bWwgPSBgPGRpdiBjbGFzcz1cImNhbGVuZGFyLW1vbnRoXCIgZGF0YS15ZWFyPVwiJHt5ZWFyfVwiIGRhdGEtbW9udGg9XCIke21vbnRofVwiPiR7bW9udGhIdG1sfTwvZGl2PmA7XG4gICAgcmV0dXJuIG1vbnRoSHRtbDtcbiAgfVxuICByZW5kZXJXZWVrSGVhZGVyKCkge1xuICAgIGNvbnN0IGNhbGVuZGFyID0gdGhpcztcbiAgICBpZiAoY2FsZW5kYXIucGFyYW1zLnJlbmRlcldlZWtIZWFkZXIpIHtcbiAgICAgIHJldHVybiBjYWxlbmRhci5wYXJhbXMucmVuZGVyV2Vla0hlYWRlci5jYWxsKGNhbGVuZGFyKTtcbiAgICB9XG4gICAgY29uc3QgeyBwYXJhbXMgfSA9IGNhbGVuZGFyO1xuICAgIGxldCB3ZWVrRGF5c0h0bWwgPSAnJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDc7IGkgKz0gMSkge1xuICAgICAgY29uc3QgZGF5SW5kZXggPSAoaSArIHBhcmFtcy5maXJzdERheSA+IDYpXG4gICAgICAgID8gKChpIC0gNykgKyBwYXJhbXMuZmlyc3REYXkpXG4gICAgICAgIDogKGkgKyBwYXJhbXMuZmlyc3REYXkpO1xuICAgICAgY29uc3QgZGF5TmFtZSA9IHBhcmFtcy5kYXlOYW1lc1Nob3J0W2RheUluZGV4XTtcbiAgICAgIHdlZWtEYXlzSHRtbCArPSBgPGRpdiBjbGFzcz1cImNhbGVuZGFyLXdlZWstZGF5XCI+JHtkYXlOYW1lfTwvZGl2PmA7XG4gICAgfVxuICAgIHJldHVybiBgXG4gICAgICA8ZGl2IGNsYXNzPVwiY2FsZW5kYXItd2Vlay1oZWFkZXJcIj5cbiAgICAgICAgJHt3ZWVrRGF5c0h0bWx9XG4gICAgICA8L2Rpdj5cbiAgICBgLnRyaW0oKTtcbiAgfVxuICByZW5kZXJNb250aFNlbGVjdG9yKCkge1xuICAgIGNvbnN0IGNhbGVuZGFyID0gdGhpcztcbiAgICBjb25zdCBhcHAgPSBjYWxlbmRhci5hcHA7XG4gICAgaWYgKGNhbGVuZGFyLnBhcmFtcy5yZW5kZXJNb250aFNlbGVjdG9yKSB7XG4gICAgICByZXR1cm4gY2FsZW5kYXIucGFyYW1zLnJlbmRlck1vbnRoU2VsZWN0b3IuY2FsbChjYWxlbmRhcik7XG4gICAgfVxuXG4gICAgbGV0IG5lZWRzQmxhY2tJY29uO1xuICAgIGlmIChjYWxlbmRhci5pbmxpbmUgJiYgY2FsZW5kYXIuJGNvbnRhaW5lckVsLmNsb3Nlc3QoJy50aGVtZS1kYXJrJykubGVuZ3RoID09PSAwKSB7XG4gICAgICBuZWVkc0JsYWNrSWNvbiA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChhcHAucm9vdC5jbG9zZXN0KCcudGhlbWUtZGFyaycpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgbmVlZHNCbGFja0ljb24gPSB0cnVlO1xuICAgIH1cblxuICAgIGNvbnN0IGljb25Db2xvciA9IGFwcC50aGVtZSA9PT0gJ21kJyAmJiBuZWVkc0JsYWNrSWNvbiA/ICdjb2xvci1ibGFjaycgOiAnJztcbiAgICByZXR1cm4gYFxuICAgICAgPGRpdiBjbGFzcz1cImNhbGVuZGFyLW1vbnRoLXNlbGVjdG9yXCI+XG4gICAgICAgIDxhIGhyZWY9XCIjXCIgY2xhc3M9XCJsaW5rIGljb24tb25seSBjYWxlbmRhci1wcmV2LW1vbnRoLWJ1dHRvblwiPlxuICAgICAgICAgIDxpIGNsYXNzPVwiaWNvbiBpY29uLXByZXYgJHtpY29uQ29sb3J9XCI+PC9pPlxuICAgICAgICA8L2E+XG4gICAgICAgIDxzcGFuIGNsYXNzPVwiY3VycmVudC1tb250aC12YWx1ZVwiPjwvc3Bhbj5cbiAgICAgICAgPGEgaHJlZj1cIiNcIiBjbGFzcz1cImxpbmsgaWNvbi1vbmx5IGNhbGVuZGFyLW5leHQtbW9udGgtYnV0dG9uXCI+XG4gICAgICAgICAgPGkgY2xhc3M9XCJpY29uIGljb24tbmV4dCAke2ljb25Db2xvcn1cIj48L2k+XG4gICAgICAgIDwvYT5cbiAgICAgIDwvZGl2PlxuICAgIGAudHJpbSgpO1xuICB9XG4gIHJlbmRlclllYXJTZWxlY3RvcigpIHtcbiAgICBjb25zdCBjYWxlbmRhciA9IHRoaXM7XG4gICAgY29uc3QgYXBwID0gY2FsZW5kYXIuYXBwO1xuICAgIGlmIChjYWxlbmRhci5wYXJhbXMucmVuZGVyWWVhclNlbGVjdG9yKSB7XG4gICAgICByZXR1cm4gY2FsZW5kYXIucGFyYW1zLnJlbmRlclllYXJTZWxlY3Rvci5jYWxsKGNhbGVuZGFyKTtcbiAgICB9XG5cbiAgICBsZXQgbmVlZHNCbGFja0ljb247XG4gICAgaWYgKGNhbGVuZGFyLmlubGluZSAmJiBjYWxlbmRhci4kY29udGFpbmVyRWwuY2xvc2VzdCgnLnRoZW1lLWRhcmsnKS5sZW5ndGggPT09IDApIHtcbiAgICAgIG5lZWRzQmxhY2tJY29uID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGFwcC5yb290LmNsb3Nlc3QoJy50aGVtZS1kYXJrJykubGVuZ3RoID09PSAwKSB7XG4gICAgICBuZWVkc0JsYWNrSWNvbiA9IHRydWU7XG4gICAgfVxuXG4gICAgY29uc3QgaWNvbkNvbG9yID0gYXBwLnRoZW1lID09PSAnbWQnICYmIG5lZWRzQmxhY2tJY29uID8gJ2NvbG9yLWJsYWNrJyA6ICcnO1xuICAgIHJldHVybiBgXG4gICAgICA8ZGl2IGNsYXNzPVwiY2FsZW5kYXIteWVhci1zZWxlY3RvclwiPlxuICAgICAgICA8YSBocmVmPVwiI1wiIGNsYXNzPVwibGluayBpY29uLW9ubHkgY2FsZW5kYXItcHJldi15ZWFyLWJ1dHRvblwiPlxuICAgICAgICAgIDxpIGNsYXNzPVwiaWNvbiBpY29uLXByZXYgJHtpY29uQ29sb3J9XCI+PC9pPlxuICAgICAgICA8L2E+XG4gICAgICAgIDxzcGFuIGNsYXNzPVwiY3VycmVudC15ZWFyLXZhbHVlXCI+PC9zcGFuPlxuICAgICAgICA8YSBocmVmPVwiI1wiIGNsYXNzPVwibGluayBpY29uLW9ubHkgY2FsZW5kYXItbmV4dC15ZWFyLWJ1dHRvblwiPlxuICAgICAgICAgIDxpIGNsYXNzPVwiaWNvbiBpY29uLW5leHQgJHtpY29uQ29sb3J9XCI+PC9pPlxuICAgICAgICA8L2E+XG4gICAgICA8L2Rpdj5cbiAgICBgLnRyaW0oKTtcbiAgfVxuICByZW5kZXJIZWFkZXIoKSB7XG4gICAgY29uc3QgY2FsZW5kYXIgPSB0aGlzO1xuICAgIGlmIChjYWxlbmRhci5wYXJhbXMucmVuZGVySGVhZGVyKSB7XG4gICAgICByZXR1cm4gY2FsZW5kYXIucGFyYW1zLnJlbmRlckhlYWRlci5jYWxsKGNhbGVuZGFyKTtcbiAgICB9XG4gICAgcmV0dXJuIGBcbiAgICAgIDxkaXYgY2xhc3M9XCJjYWxlbmRhci1oZWFkZXJcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImNhbGVuZGFyLXNlbGVjdGVkLWRhdGVcIj4ke2NhbGVuZGFyLnBhcmFtcy5oZWFkZXJQbGFjZWhvbGRlcn08L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIGAudHJpbSgpO1xuICB9XG4gIHJlbmRlckZvb3RlcigpIHtcbiAgICBjb25zdCBjYWxlbmRhciA9IHRoaXM7XG4gICAgY29uc3QgYXBwID0gY2FsZW5kYXIuYXBwO1xuICAgIGlmIChjYWxlbmRhci5wYXJhbXMucmVuZGVyRm9vdGVyKSB7XG4gICAgICByZXR1cm4gY2FsZW5kYXIucGFyYW1zLnJlbmRlckZvb3Rlci5jYWxsKGNhbGVuZGFyKTtcbiAgICB9XG4gICAgcmV0dXJuIGBcbiAgICAgIDxkaXYgY2xhc3M9XCJjYWxlbmRhci1mb290ZXJcIj5cbiAgICAgICAgPGEgaHJlZj1cIiNcIiBjbGFzcz1cIiR7YXBwLnRoZW1lID09PSAnbWQnID8gJ2J1dHRvbicgOiAnbGluayd9IGNhbGVuZGFyLWNsb3NlIHNoZWV0LWNsb3NlIHBvcG92ZXItY2xvc2VcIj4ke2NhbGVuZGFyLnBhcmFtcy50b29sYmFyQ2xvc2VUZXh0fTwvYT5cbiAgICAgIDwvZGl2PlxuICAgIGAudHJpbSgpO1xuICB9XG4gIHJlbmRlclRvb2xiYXIoKSB7XG4gICAgY29uc3QgY2FsZW5kYXIgPSB0aGlzO1xuICAgIGlmIChjYWxlbmRhci5wYXJhbXMucmVuZGVyVG9vbGJhcikge1xuICAgICAgcmV0dXJuIGNhbGVuZGFyLnBhcmFtcy5yZW5kZXJUb29sYmFyLmNhbGwoY2FsZW5kYXIsIGNhbGVuZGFyKTtcbiAgICB9XG4gICAgcmV0dXJuIGBcbiAgICAgIDxkaXYgY2xhc3M9XCJ0b29sYmFyIG5vLXNoYWRvd1wiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwidG9vbGJhci1pbm5lclwiPlxuICAgICAgICAgICR7Y2FsZW5kYXIucmVuZGVyTW9udGhTZWxlY3RvcigpfVxuICAgICAgICAgICR7Y2FsZW5kYXIucmVuZGVyWWVhclNlbGVjdG9yKCl9XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgYC50cmltKCk7XG4gIH1cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gIHJlbmRlcklubGluZSgpIHtcbiAgICBjb25zdCBjYWxlbmRhciA9IHRoaXM7XG4gICAgY29uc3QgeyBjc3NDbGFzcywgdG9vbGJhciwgaGVhZGVyLCBmb290ZXIsIHJhbmdlUGlja2VyLCB3ZWVrSGVhZGVyIH0gPSBjYWxlbmRhci5wYXJhbXM7XG4gICAgY29uc3QgeyB2YWx1ZSB9ID0gY2FsZW5kYXI7XG4gICAgY29uc3QgZGF0ZSA9IHZhbHVlICYmIHZhbHVlLmxlbmd0aCA/IHZhbHVlWzBdIDogbmV3IERhdGUoKS5zZXRIb3VycygwLCAwLCAwKTtcbiAgICBjb25zdCBpbmxpbmVIdG1sID0gYFxuICAgICAgPGRpdiBjbGFzcz1cImNhbGVuZGFyIGNhbGVuZGFyLWlubGluZSAke3JhbmdlUGlja2VyID8gJ2NhbGVuZGFyLXJhbmdlJyA6ICcnfSAke2Nzc0NsYXNzIHx8ICcnfVwiPlxuICAgICAgICAke2hlYWRlciA/IGNhbGVuZGFyLnJlbmRlckhlYWRlcigpIDogJyd9XG4gICAgICAgICR7dG9vbGJhciA/IGNhbGVuZGFyLnJlbmRlclRvb2xiYXIoKSA6ICcnfVxuICAgICAgICAke3dlZWtIZWFkZXIgPyBjYWxlbmRhci5yZW5kZXJXZWVrSGVhZGVyKCkgOiAnJ31cbiAgICAgICAgPGRpdiBjbGFzcz1cImNhbGVuZGFyLW1vbnRoc1wiPlxuICAgICAgICAgICR7Y2FsZW5kYXIucmVuZGVyTW9udGhzKGRhdGUpfVxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgJHtmb290ZXIgPyBjYWxlbmRhci5yZW5kZXJGb290ZXIoKSA6ICcnfVxuICAgICAgPC9kaXY+XG4gICAgYC50cmltKCk7XG5cbiAgICByZXR1cm4gaW5saW5lSHRtbDtcbiAgfVxuICByZW5kZXJDdXN0b21Nb2RhbCgpIHtcbiAgICBjb25zdCBjYWxlbmRhciA9IHRoaXM7XG4gICAgY29uc3QgeyBjc3NDbGFzcywgdG9vbGJhciwgaGVhZGVyLCBmb290ZXIsIHJhbmdlUGlja2VyLCB3ZWVrSGVhZGVyIH0gPSBjYWxlbmRhci5wYXJhbXM7XG4gICAgY29uc3QgeyB2YWx1ZSB9ID0gY2FsZW5kYXI7XG4gICAgY29uc3QgZGF0ZSA9IHZhbHVlICYmIHZhbHVlLmxlbmd0aCA/IHZhbHVlWzBdIDogbmV3IERhdGUoKS5zZXRIb3VycygwLCAwLCAwKTtcbiAgICBjb25zdCBzaGVldEh0bWwgPSBgXG4gICAgICA8ZGl2IGNsYXNzPVwiY2FsZW5kYXIgY2FsZW5kYXItbW9kYWwgJHtyYW5nZVBpY2tlciA/ICdjYWxlbmRhci1yYW5nZScgOiAnJ30gJHtjc3NDbGFzcyB8fCAnJ31cIj5cbiAgICAgICAgJHtoZWFkZXIgPyBjYWxlbmRhci5yZW5kZXJIZWFkZXIoKSA6ICcnfVxuICAgICAgICAke3Rvb2xiYXIgPyBjYWxlbmRhci5yZW5kZXJUb29sYmFyKCkgOiAnJ31cbiAgICAgICAgJHt3ZWVrSGVhZGVyID8gY2FsZW5kYXIucmVuZGVyV2Vla0hlYWRlcigpIDogJyd9XG4gICAgICAgIDxkaXYgY2xhc3M9XCJjYWxlbmRhci1tb250aHNcIj5cbiAgICAgICAgICAke2NhbGVuZGFyLnJlbmRlck1vbnRocyhkYXRlKX1cbiAgICAgICAgPC9kaXY+XG4gICAgICAgICR7Zm9vdGVyID8gY2FsZW5kYXIucmVuZGVyRm9vdGVyKCkgOiAnJ31cbiAgICAgIDwvZGl2PlxuICAgIGAudHJpbSgpO1xuXG4gICAgcmV0dXJuIHNoZWV0SHRtbDtcbiAgfVxuICByZW5kZXJTaGVldCgpIHtcbiAgICBjb25zdCBjYWxlbmRhciA9IHRoaXM7XG4gICAgY29uc3QgeyBjc3NDbGFzcywgdG9vbGJhciwgaGVhZGVyLCBmb290ZXIsIHJhbmdlUGlja2VyLCB3ZWVrSGVhZGVyIH0gPSBjYWxlbmRhci5wYXJhbXM7XG4gICAgY29uc3QgeyB2YWx1ZSB9ID0gY2FsZW5kYXI7XG4gICAgY29uc3QgZGF0ZSA9IHZhbHVlICYmIHZhbHVlLmxlbmd0aCA/IHZhbHVlWzBdIDogbmV3IERhdGUoKS5zZXRIb3VycygwLCAwLCAwKTtcbiAgICBjb25zdCBzaGVldEh0bWwgPSBgXG4gICAgICA8ZGl2IGNsYXNzPVwic2hlZXQtbW9kYWwgY2FsZW5kYXIgY2FsZW5kYXItc2hlZXQgJHtyYW5nZVBpY2tlciA/ICdjYWxlbmRhci1yYW5nZScgOiAnJ30gJHtjc3NDbGFzcyB8fCAnJ31cIj5cbiAgICAgICAgJHtoZWFkZXIgPyBjYWxlbmRhci5yZW5kZXJIZWFkZXIoKSA6ICcnfVxuICAgICAgICAke3Rvb2xiYXIgPyBjYWxlbmRhci5yZW5kZXJUb29sYmFyKCkgOiAnJ31cbiAgICAgICAgJHt3ZWVrSGVhZGVyID8gY2FsZW5kYXIucmVuZGVyV2Vla0hlYWRlcigpIDogJyd9XG4gICAgICAgIDxkaXYgY2xhc3M9XCJzaGVldC1tb2RhbC1pbm5lciBjYWxlbmRhci1tb250aHNcIj5cbiAgICAgICAgICAke2NhbGVuZGFyLnJlbmRlck1vbnRocyhkYXRlKX1cbiAgICAgICAgPC9kaXY+XG4gICAgICAgICR7Zm9vdGVyID8gY2FsZW5kYXIucmVuZGVyRm9vdGVyKCkgOiAnJ31cbiAgICAgIDwvZGl2PlxuICAgIGAudHJpbSgpO1xuXG4gICAgcmV0dXJuIHNoZWV0SHRtbDtcbiAgfVxuICByZW5kZXJQb3BvdmVyKCkge1xuICAgIGNvbnN0IGNhbGVuZGFyID0gdGhpcztcbiAgICBjb25zdCB7IGNzc0NsYXNzLCB0b29sYmFyLCBoZWFkZXIsIGZvb3RlciwgcmFuZ2VQaWNrZXIsIHdlZWtIZWFkZXIgfSA9IGNhbGVuZGFyLnBhcmFtcztcbiAgICBjb25zdCB7IHZhbHVlIH0gPSBjYWxlbmRhcjtcbiAgICBjb25zdCBkYXRlID0gdmFsdWUgJiYgdmFsdWUubGVuZ3RoID8gdmFsdWVbMF0gOiBuZXcgRGF0ZSgpLnNldEhvdXJzKDAsIDAsIDApO1xuICAgIGNvbnN0IHBvcG92ZXJIdG1sID0gYFxuICAgICAgPGRpdiBjbGFzcz1cInBvcG92ZXIgY2FsZW5kYXItcG9wb3ZlclwiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwicG9wb3Zlci1pbm5lclwiPlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJjYWxlbmRhciAke3JhbmdlUGlja2VyID8gJ2NhbGVuZGFyLXJhbmdlJyA6ICcnfSAke2Nzc0NsYXNzIHx8ICcnfVwiPlxuICAgICAgICAgICAgJHtoZWFkZXIgPyBjYWxlbmRhci5yZW5kZXJIZWFkZXIoKSA6ICcnfVxuICAgICAgICAgICAgJHt0b29sYmFyID8gY2FsZW5kYXIucmVuZGVyVG9vbGJhcigpIDogJyd9XG4gICAgICAgICAgICAke3dlZWtIZWFkZXIgPyBjYWxlbmRhci5yZW5kZXJXZWVrSGVhZGVyKCkgOiAnJ31cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjYWxlbmRhci1tb250aHNcIj5cbiAgICAgICAgICAgICAgJHtjYWxlbmRhci5yZW5kZXJNb250aHMoZGF0ZSl9XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICR7Zm9vdGVyID8gY2FsZW5kYXIucmVuZGVyRm9vdGVyKCkgOiAnJ31cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICBgLnRyaW0oKTtcblxuICAgIHJldHVybiBwb3BvdmVySHRtbDtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgY2FsZW5kYXIgPSB0aGlzO1xuICAgIGNvbnN0IHsgcGFyYW1zIH0gPSBjYWxlbmRhcjtcbiAgICBpZiAocGFyYW1zLnJlbmRlcikgcmV0dXJuIHBhcmFtcy5yZW5kZXIuY2FsbChjYWxlbmRhcik7XG4gICAgaWYgKCFjYWxlbmRhci5pbmxpbmUpIHtcbiAgICAgIGxldCBtb2RhbFR5cGUgPSBwYXJhbXMub3BlbkluO1xuICAgICAgaWYgKG1vZGFsVHlwZSA9PT0gJ2F1dG8nKSBtb2RhbFR5cGUgPSBjYWxlbmRhci5pc1BvcG92ZXIoKSA/ICdwb3BvdmVyJyA6ICdzaGVldCc7XG5cbiAgICAgIGlmIChtb2RhbFR5cGUgPT09ICdwb3BvdmVyJykgcmV0dXJuIGNhbGVuZGFyLnJlbmRlclBvcG92ZXIoKTtcbiAgICAgIGVsc2UgaWYgKG1vZGFsVHlwZSA9PT0gJ3NoZWV0JykgcmV0dXJuIGNhbGVuZGFyLnJlbmRlclNoZWV0KCk7XG4gICAgICByZXR1cm4gY2FsZW5kYXIucmVuZGVyQ3VzdG9tTW9kYWwoKTtcbiAgICB9XG4gICAgcmV0dXJuIGNhbGVuZGFyLnJlbmRlcklubGluZSgpO1xuICB9XG4gIG9uT3BlbigpIHtcbiAgICBjb25zdCBjYWxlbmRhciA9IHRoaXM7XG4gICAgY29uc3QgeyBpbml0aWFsaXplZCwgJGVsLCBhcHAsICRpbnB1dEVsLCBpbmxpbmUsIHZhbHVlLCBwYXJhbXMgfSA9IGNhbGVuZGFyO1xuICAgIGNhbGVuZGFyLm9wZW5lZCA9IHRydWU7XG5cbiAgICAvLyBJbml0IG1haW4gZXZlbnRzXG4gICAgY2FsZW5kYXIuYXR0YWNoQ2FsZW5kYXJFdmVudHMoKTtcblxuICAgIGNvbnN0IHVwZGF0ZVZhbHVlID0gIXZhbHVlICYmIHBhcmFtcy52YWx1ZTtcblxuICAgIC8vIFNldCB2YWx1ZVxuICAgIGlmICghaW5pdGlhbGl6ZWQpIHtcbiAgICAgIGlmICh2YWx1ZSkgY2FsZW5kYXIuc2V0VmFsdWUodmFsdWUsIDApO1xuICAgICAgZWxzZSBpZiAocGFyYW1zLnZhbHVlKSB7XG4gICAgICAgIGNhbGVuZGFyLnNldFZhbHVlKGNhbGVuZGFyLm5vcm1hbGl6ZVZhbHVlcyhwYXJhbXMudmFsdWUpLCAwKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHZhbHVlKSB7XG4gICAgICBjYWxlbmRhci5zZXRWYWx1ZSh2YWx1ZSwgMCk7XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIGN1cnJlbnQgbW9udGggYW5kIHllYXJcbiAgICBjYWxlbmRhci51cGRhdGVDdXJyZW50TW9udGhZZWFyKCk7XG5cbiAgICAvLyBTZXQgaW5pdGlhbCB0cmFuc2xhdGVcbiAgICBjYWxlbmRhci5tb250aHNUcmFuc2xhdGUgPSAwO1xuICAgIGNhbGVuZGFyLnNldE1vbnRoc1RyYW5zbGF0ZSgpO1xuXG4gICAgLy8gVXBkYXRlIGlucHV0IHZhbHVlXG4gICAgaWYgKHVwZGF0ZVZhbHVlKSBjYWxlbmRhci51cGRhdGVWYWx1ZSgpO1xuICAgIGVsc2UgaWYgKHBhcmFtcy5oZWFkZXIgJiYgdmFsdWUpIHtcbiAgICAgIGNhbGVuZGFyLnVwZGF0ZVZhbHVlKHRydWUpO1xuICAgIH1cblxuICAgIC8vIEV4dHJhIGZvY3VzXG4gICAgaWYgKCFpbmxpbmUgJiYgJGlucHV0RWwubGVuZ3RoICYmIGFwcC50aGVtZSA9PT0gJ21kJykge1xuICAgICAgJGlucHV0RWwudHJpZ2dlcignZm9jdXMnKTtcbiAgICB9XG5cbiAgICBjYWxlbmRhci5pbml0aWFsaXplZCA9IHRydWU7XG5cbiAgICBjYWxlbmRhci4kbW9udGhzLmVhY2goKGluZGV4LCBtb250aEVsKSA9PiB7XG4gICAgICBjYWxlbmRhci5lbWl0KCdsb2NhbDo6bW9udGhBZGQgY2FsZW5kYXJNb250aEFkZCcsIG1vbnRoRWwpO1xuICAgIH0pO1xuXG4gICAgLy8gVHJpZ2dlciBldmVudHNcbiAgICBpZiAoJGVsKSB7XG4gICAgICAkZWwudHJpZ2dlcignY2FsZW5kYXI6b3BlbicsIGNhbGVuZGFyKTtcbiAgICB9XG4gICAgaWYgKCRpbnB1dEVsKSB7XG4gICAgICAkaW5wdXRFbC50cmlnZ2VyKCdjYWxlbmRhcjpvcGVuJywgY2FsZW5kYXIpO1xuICAgIH1cbiAgICBjYWxlbmRhci5lbWl0KCdsb2NhbDo6b3BlbiBjYWxlbmRhck9wZW4nLCBjYWxlbmRhcik7XG4gIH1cbiAgb25PcGVuZWQoKSB7XG4gICAgY29uc3QgY2FsZW5kYXIgPSB0aGlzO1xuICAgIGlmIChjYWxlbmRhci4kZWwpIHtcbiAgICAgIGNhbGVuZGFyLiRlbC50cmlnZ2VyKCdjYWxlbmRhcjpvcGVuZWQnLCBjYWxlbmRhcik7XG4gICAgfVxuICAgIGlmIChjYWxlbmRhci4kaW5wdXRFbCkge1xuICAgICAgY2FsZW5kYXIuJGlucHV0RWwudHJpZ2dlcignY2FsZW5kYXI6b3BlbmVkJywgY2FsZW5kYXIpO1xuICAgIH1cbiAgICBjYWxlbmRhci5lbWl0KCdsb2NhbDo6b3BlbmVkIGNhbGVuZGFyT3BlbmVkJywgY2FsZW5kYXIpO1xuICB9XG4gIG9uQ2xvc2UoKSB7XG4gICAgY29uc3QgY2FsZW5kYXIgPSB0aGlzO1xuICAgIGNvbnN0IGFwcCA9IGNhbGVuZGFyLmFwcDtcblxuICAgIGlmIChjYWxlbmRhci4kaW5wdXRFbCAmJiBhcHAudGhlbWUgPT09ICdtZCcpIHtcbiAgICAgIGNhbGVuZGFyLiRpbnB1dEVsLnRyaWdnZXIoJ2JsdXInKTtcbiAgICB9XG4gICAgaWYgKGNhbGVuZGFyLmRldGFjaENhbGVuZGFyRXZlbnRzKSB7XG4gICAgICBjYWxlbmRhci5kZXRhY2hDYWxlbmRhckV2ZW50cygpO1xuICAgIH1cblxuICAgIGlmIChjYWxlbmRhci4kZWwpIHtcbiAgICAgIGNhbGVuZGFyLiRlbC50cmlnZ2VyKCdjYWxlbmRhcjpjbG9zZScsIGNhbGVuZGFyKTtcbiAgICB9XG4gICAgaWYgKGNhbGVuZGFyLiRpbnB1dEVsKSB7XG4gICAgICBjYWxlbmRhci4kaW5wdXRFbC50cmlnZ2VyKCdjYWxlbmRhcjpjbG9zZScsIGNhbGVuZGFyKTtcbiAgICB9XG4gICAgY2FsZW5kYXIuZW1pdCgnbG9jYWw6OmNsb3NlIGNhbGVuZGFyQ2xvc2UnLCBjYWxlbmRhcik7XG4gIH1cbiAgb25DbG9zZWQoKSB7XG4gICAgY29uc3QgY2FsZW5kYXIgPSB0aGlzO1xuICAgIGNhbGVuZGFyLm9wZW5lZCA9IGZhbHNlO1xuXG4gICAgaWYgKCFjYWxlbmRhci5pbmxpbmUpIHtcbiAgICAgIFV0aWxzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgaWYgKGNhbGVuZGFyLm1vZGFsICYmIGNhbGVuZGFyLm1vZGFsLmVsICYmIGNhbGVuZGFyLm1vZGFsLmRlc3Ryb3kpIHtcbiAgICAgICAgICBpZiAoIWNhbGVuZGFyLnBhcmFtcy5yb3V0YWJsZU1vZGFscykge1xuICAgICAgICAgICAgY2FsZW5kYXIubW9kYWwuZGVzdHJveSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgY2FsZW5kYXIubW9kYWw7XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGNhbGVuZGFyLiRlbCkge1xuICAgICAgY2FsZW5kYXIuJGVsLnRyaWdnZXIoJ2NhbGVuZGFyOmNsb3NlZCcsIGNhbGVuZGFyKTtcbiAgICB9XG4gICAgaWYgKGNhbGVuZGFyLiRpbnB1dEVsKSB7XG4gICAgICBjYWxlbmRhci4kaW5wdXRFbC50cmlnZ2VyKCdjYWxlbmRhcjpjbG9zZWQnLCBjYWxlbmRhcik7XG4gICAgfVxuICAgIGNhbGVuZGFyLmVtaXQoJ2xvY2FsOjpjbG9zZWQgY2FsZW5kYXJDbG9zZWQnLCBjYWxlbmRhcik7XG4gIH1cbiAgb3BlbigpIHtcbiAgICBjb25zdCBjYWxlbmRhciA9IHRoaXM7XG4gICAgY29uc3QgeyBhcHAsIG9wZW5lZCwgaW5saW5lLCAkaW5wdXRFbCwgcGFyYW1zIH0gPSBjYWxlbmRhcjtcbiAgICBpZiAob3BlbmVkKSByZXR1cm47XG5cbiAgICBpZiAoaW5saW5lKSB7XG4gICAgICBjYWxlbmRhci4kZWwgPSAkKGNhbGVuZGFyLnJlbmRlcigpKTtcbiAgICAgIGNhbGVuZGFyLiRlbFswXS5mN0NhbGVuZGFyID0gY2FsZW5kYXI7XG4gICAgICBjYWxlbmRhci4kd3JhcHBlckVsID0gY2FsZW5kYXIuJGVsLmZpbmQoJy5jYWxlbmRhci1tb250aHMtd3JhcHBlcicpO1xuICAgICAgY2FsZW5kYXIuJG1vbnRocyA9IGNhbGVuZGFyLiR3cmFwcGVyRWwuZmluZCgnLmNhbGVuZGFyLW1vbnRoJyk7XG4gICAgICBjYWxlbmRhci4kY29udGFpbmVyRWwuYXBwZW5kKGNhbGVuZGFyLiRlbCk7XG4gICAgICBjYWxlbmRhci5vbk9wZW4oKTtcbiAgICAgIGNhbGVuZGFyLm9uT3BlbmVkKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBtb2RhbFR5cGUgPSBwYXJhbXMub3BlbkluO1xuICAgIGlmIChtb2RhbFR5cGUgPT09ICdhdXRvJykge1xuICAgICAgbW9kYWxUeXBlID0gY2FsZW5kYXIuaXNQb3BvdmVyKCkgPyAncG9wb3ZlcicgOiAnc2hlZXQnO1xuICAgIH1cbiAgICBjb25zdCBtb2RhbENvbnRlbnQgPSBjYWxlbmRhci5yZW5kZXIoKTtcblxuICAgIGNvbnN0IG1vZGFsUGFyYW1zID0ge1xuICAgICAgdGFyZ2V0RWw6ICRpbnB1dEVsLFxuICAgICAgc2Nyb2xsVG9FbDogY2FsZW5kYXIucGFyYW1zLnNjcm9sbFRvSW5wdXQgPyAkaW5wdXRFbCA6IHVuZGVmaW5lZCxcbiAgICAgIGNvbnRlbnQ6IG1vZGFsQ29udGVudCxcbiAgICAgIGJhY2tkcm9wOiBtb2RhbFR5cGUgPT09ICdwb3BvdmVyJyAmJiBhcHAucGFyYW1zLnBvcG92ZXIuYmFja2Ryb3AgIT09IGZhbHNlLFxuICAgICAgb246IHtcbiAgICAgICAgb3BlbigpIHtcbiAgICAgICAgICBjb25zdCBtb2RhbCA9IHRoaXM7XG4gICAgICAgICAgY2FsZW5kYXIubW9kYWwgPSBtb2RhbDtcbiAgICAgICAgICBjYWxlbmRhci4kZWwgPSBtb2RhbFR5cGUgPT09ICdwb3BvdmVyJyA/IG1vZGFsLiRlbC5maW5kKCcuY2FsZW5kYXInKSA6IG1vZGFsLiRlbDtcbiAgICAgICAgICBjYWxlbmRhci4kd3JhcHBlckVsID0gY2FsZW5kYXIuJGVsLmZpbmQoJy5jYWxlbmRhci1tb250aHMtd3JhcHBlcicpO1xuICAgICAgICAgIGNhbGVuZGFyLiRtb250aHMgPSBjYWxlbmRhci4kd3JhcHBlckVsLmZpbmQoJy5jYWxlbmRhci1tb250aCcpO1xuICAgICAgICAgIGNhbGVuZGFyLiRlbFswXS5mN0NhbGVuZGFyID0gY2FsZW5kYXI7XG4gICAgICAgICAgaWYgKG1vZGFsVHlwZSA9PT0gJ2N1c3RvbU1vZGFsJykge1xuICAgICAgICAgICAgJChjYWxlbmRhci4kZWwpLmZpbmQoJy5jYWxlbmRhci1jbG9zZScpLm9uY2UoJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgICAgICAgICBjYWxlbmRhci5jbG9zZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhbGVuZGFyLm9uT3BlbigpO1xuICAgICAgICB9LFxuICAgICAgICBvcGVuZWQoKSB7IGNhbGVuZGFyLm9uT3BlbmVkKCk7IH0sXG4gICAgICAgIGNsb3NlKCkgeyBjYWxlbmRhci5vbkNsb3NlKCk7IH0sXG4gICAgICAgIGNsb3NlZCgpIHsgY2FsZW5kYXIub25DbG9zZWQoKTsgfSxcbiAgICAgIH0sXG4gICAgfTtcbiAgICBpZiAoY2FsZW5kYXIucGFyYW1zLnJvdXRhYmxlTW9kYWxzKSB7XG4gICAgICBjYWxlbmRhci52aWV3LnJvdXRlci5uYXZpZ2F0ZSh7XG4gICAgICAgIHVybDogY2FsZW5kYXIudXJsLFxuICAgICAgICByb3V0ZToge1xuICAgICAgICAgIHBhdGg6IGNhbGVuZGFyLnVybCxcbiAgICAgICAgICBbbW9kYWxUeXBlXTogbW9kYWxQYXJhbXMsXG4gICAgICAgIH0sXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FsZW5kYXIubW9kYWwgPSBhcHBbbW9kYWxUeXBlXS5jcmVhdGUobW9kYWxQYXJhbXMpO1xuICAgICAgY2FsZW5kYXIubW9kYWwub3BlbigpO1xuICAgIH1cbiAgfVxuICBjbG9zZSgpIHtcbiAgICBjb25zdCBjYWxlbmRhciA9IHRoaXM7XG4gICAgY29uc3QgeyBvcGVuZWQsIGlubGluZSB9ID0gY2FsZW5kYXI7XG4gICAgaWYgKCFvcGVuZWQpIHJldHVybjtcbiAgICBpZiAoaW5saW5lKSB7XG4gICAgICBjYWxlbmRhci5vbkNsb3NlKCk7XG4gICAgICBjYWxlbmRhci5vbkNsb3NlZCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoY2FsZW5kYXIucGFyYW1zLnJvdXRhYmxlTW9kYWxzKSB7XG4gICAgICBjYWxlbmRhci52aWV3LnJvdXRlci5iYWNrKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGVuZGFyLm1vZGFsLmNsb3NlKCk7XG4gICAgfVxuICB9XG4gIGluaXQoKSB7XG4gICAgY29uc3QgY2FsZW5kYXIgPSB0aGlzO1xuXG4gICAgY2FsZW5kYXIuaW5pdElucHV0KCk7XG5cbiAgICBpZiAoY2FsZW5kYXIuaW5saW5lKSB7XG4gICAgICBjYWxlbmRhci5vcGVuKCk7XG4gICAgICBjYWxlbmRhci5lbWl0KCdsb2NhbDo6aW5pdCBjYWxlbmRhckluaXQnLCBjYWxlbmRhcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFjYWxlbmRhci5pbml0aWFsaXplZCAmJiBjYWxlbmRhci5wYXJhbXMudmFsdWUpIHtcbiAgICAgIGNhbGVuZGFyLnNldFZhbHVlKGNhbGVuZGFyLm5vcm1hbGl6ZVZhbHVlcyhjYWxlbmRhci5wYXJhbXMudmFsdWUpKTtcbiAgICB9XG5cbiAgICAvLyBBdHRhY2ggaW5wdXQgRXZlbnRzXG4gICAgaWYgKGNhbGVuZGFyLiRpbnB1dEVsKSB7XG4gICAgICBjYWxlbmRhci5hdHRhY2hJbnB1dEV2ZW50cygpO1xuICAgIH1cbiAgICBpZiAoY2FsZW5kYXIucGFyYW1zLmNsb3NlQnlPdXRzaWRlQ2xpY2spIHtcbiAgICAgIGNhbGVuZGFyLmF0dGFjaEh0bWxFdmVudHMoKTtcbiAgICB9XG4gICAgY2FsZW5kYXIuZW1pdCgnbG9jYWw6OmluaXQgY2FsZW5kYXJJbml0JywgY2FsZW5kYXIpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgY29uc3QgY2FsZW5kYXIgPSB0aGlzO1xuICAgIGlmIChjYWxlbmRhci5kZXN0cm95ZWQpIHJldHVybjtcbiAgICBjb25zdCB7ICRlbCB9ID0gY2FsZW5kYXI7XG4gICAgY2FsZW5kYXIuZW1pdCgnbG9jYWw6OmJlZm9yZURlc3Ryb3kgY2FsZW5kYXJCZWZvcmVEZXN0cm95JywgY2FsZW5kYXIpO1xuICAgIGlmICgkZWwpICRlbC50cmlnZ2VyKCdjYWxlbmRhcjpiZWZvcmVkZXN0cm95JywgY2FsZW5kYXIpO1xuXG4gICAgY2FsZW5kYXIuY2xvc2UoKTtcblxuICAgIC8vIERldGFjaCBFdmVudHNcbiAgICBpZiAoY2FsZW5kYXIuJGlucHV0RWwpIHtcbiAgICAgIGNhbGVuZGFyLmRldGFjaElucHV0RXZlbnRzKCk7XG4gICAgfVxuICAgIGlmIChjYWxlbmRhci5wYXJhbXMuY2xvc2VCeU91dHNpZGVDbGljaykge1xuICAgICAgY2FsZW5kYXIuZGV0YWNoSHRtbEV2ZW50cygpO1xuICAgIH1cblxuICAgIGlmICgkZWwgJiYgJGVsLmxlbmd0aCkgZGVsZXRlIGNhbGVuZGFyLiRlbFswXS5mN0NhbGVuZGFyO1xuICAgIFV0aWxzLmRlbGV0ZVByb3BzKGNhbGVuZGFyKTtcbiAgICBjYWxlbmRhci5kZXN0cm95ZWQgPSB0cnVlO1xuICB9XG59XG5cbnZhciBDYWxlbmRhciQxID0ge1xuICBuYW1lOiAnY2FsZW5kYXInLFxuICBzdGF0aWM6IHtcbiAgICBDYWxlbmRhcixcbiAgfSxcbiAgY3JlYXRlKCkge1xuICAgIGNvbnN0IGFwcCA9IHRoaXM7XG4gICAgYXBwLmNhbGVuZGFyID0gQ29uc3RydWN0b3JNZXRob2RzKHtcbiAgICAgIGRlZmF1bHRTZWxlY3RvcjogJy5jYWxlbmRhcicsXG4gICAgICBjb25zdHJ1Y3RvcjogQ2FsZW5kYXIsXG4gICAgICBhcHAsXG4gICAgICBkb21Qcm9wOiAnZjdDYWxlbmRhcicsXG4gICAgfSk7XG4gICAgYXBwLmNhbGVuZGFyLmNsb3NlID0gZnVuY3Rpb24gY2xvc2UoZWwgPSAnLmNhbGVuZGFyJykge1xuICAgICAgY29uc3QgJGVsID0gJChlbCk7XG4gICAgICBpZiAoJGVsLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgICAgY29uc3QgY2FsZW5kYXIgPSAkZWxbMF0uZjdDYWxlbmRhcjtcbiAgICAgIGlmICghY2FsZW5kYXIgfHwgKGNhbGVuZGFyICYmICFjYWxlbmRhci5vcGVuZWQpKSByZXR1cm47XG4gICAgICBjYWxlbmRhci5jbG9zZSgpO1xuICAgIH07XG4gIH0sXG4gIHBhcmFtczoge1xuICAgIGNhbGVuZGFyOiB7XG4gICAgICAvLyBDYWxlbmRhciBzZXR0aW5nc1xuICAgICAgbW9udGhOYW1lczogWydKYW51YXJ5JywgJ0ZlYnJ1YXJ5JywgJ01hcmNoJywgJ0FwcmlsJywgJ01heScsICdKdW5lJywgJ0p1bHknLCAnQXVndXN0JywgJ1NlcHRlbWJlcicsICdPY3RvYmVyJywgJ05vdmVtYmVyJywgJ0RlY2VtYmVyJ10sXG4gICAgICBtb250aE5hbWVzU2hvcnQ6IFsnSmFuJywgJ0ZlYicsICdNYXInLCAnQXByJywgJ01heScsICdKdW4nLCAnSnVsJywgJ0F1ZycsICdTZXAnLCAnT2N0JywgJ05vdicsICdEZWMnXSxcbiAgICAgIGRheU5hbWVzOiBbJ1N1bmRheScsICdNb25kYXknLCAnVHVlc2RheScsICdXZWRuZXNkYXknLCAnVGh1cnNkYXknLCAnRnJpZGF5JywgJ1NhdHVyZGF5J10sXG4gICAgICBkYXlOYW1lc1Nob3J0OiBbJ1N1bicsICdNb24nLCAnVHVlJywgJ1dlZCcsICdUaHUnLCAnRnJpJywgJ1NhdCddLFxuICAgICAgZmlyc3REYXk6IDEsIC8vIEZpcnN0IGRheSBvZiB0aGUgd2VlaywgTW9uZGF5XG4gICAgICB3ZWVrZW5kRGF5czogWzAsIDZdLCAvLyBTdW5kYXkgYW5kIFNhdHVyZGF5XG4gICAgICBtdWx0aXBsZTogZmFsc2UsXG4gICAgICByYW5nZVBpY2tlcjogZmFsc2UsXG4gICAgICBkYXRlRm9ybWF0OiAneXl5eS1tbS1kZCcsXG4gICAgICBkaXJlY3Rpb246ICdob3Jpem9udGFsJywgLy8gb3IgJ3ZlcnRpY2FsJ1xuICAgICAgbWluRGF0ZTogbnVsbCxcbiAgICAgIG1heERhdGU6IG51bGwsXG4gICAgICBkaXNhYmxlZDogbnVsbCwgLy8gZGF0ZXMgcmFuZ2Ugb2YgZGlzYWJsZWQgZGF5c1xuICAgICAgZXZlbnRzOiBudWxsLCAvLyBkYXRlcyByYW5nZSBvZiBkYXlzIHdpdGggZXZlbnRzXG4gICAgICByYW5nZXNDbGFzc2VzOiBudWxsLCAvLyBhcnJheSB3aXRoIGN1c3RvbSBjbGFzc2VzIGRhdGUgcmFuZ2VzXG4gICAgICB0b3VjaE1vdmU6IHRydWUsXG4gICAgICBhbmltYXRlOiB0cnVlLFxuICAgICAgY2xvc2VPblNlbGVjdDogZmFsc2UsXG4gICAgICBtb250aFNlbGVjdG9yOiB0cnVlLFxuICAgICAgeWVhclNlbGVjdG9yOiB0cnVlLFxuICAgICAgd2Vla0hlYWRlcjogdHJ1ZSxcbiAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgLy8gQ29tbW9uIG9wZW5lciBzZXR0aW5nc1xuICAgICAgY29udGFpbmVyRWw6IG51bGwsXG4gICAgICBvcGVuSW46ICdhdXRvJywgLy8gb3IgJ3BvcG92ZXInIG9yICdzaGVldCcgb3IgJ2N1c3RvbU1vZGFsJ1xuICAgICAgZm9ybWF0VmFsdWU6IG51bGwsXG4gICAgICBpbnB1dEVsOiBudWxsLFxuICAgICAgaW5wdXRSZWFkT25seTogdHJ1ZSxcbiAgICAgIGNsb3NlQnlPdXRzaWRlQ2xpY2s6IHRydWUsXG4gICAgICBzY3JvbGxUb0lucHV0OiB0cnVlLFxuICAgICAgaGVhZGVyOiBmYWxzZSxcbiAgICAgIGhlYWRlclBsYWNlaG9sZGVyOiAnU2VsZWN0IGRhdGUnLFxuICAgICAgZm9vdGVyOiBmYWxzZSxcbiAgICAgIHRvb2xiYXI6IHRydWUsXG4gICAgICB0b29sYmFyQ2xvc2VUZXh0OiAnRG9uZScsXG4gICAgICBjc3NDbGFzczogbnVsbCxcbiAgICAgIHJvdXRhYmxlTW9kYWxzOiB0cnVlLFxuICAgICAgdmlldzogbnVsbCxcbiAgICAgIHVybDogJ2RhdGUvJyxcbiAgICAgIC8vIFJlbmRlciBmdW5jdGlvbnNcbiAgICAgIHJlbmRlcldlZWtIZWFkZXI6IG51bGwsXG4gICAgICByZW5kZXJNb250aHM6IG51bGwsXG4gICAgICByZW5kZXJNb250aDogbnVsbCxcbiAgICAgIHJlbmRlck1vbnRoU2VsZWN0b3I6IG51bGwsXG4gICAgICByZW5kZXJZZWFyU2VsZWN0b3I6IG51bGwsXG4gICAgICByZW5kZXJIZWFkZXI6IG51bGwsXG4gICAgICByZW5kZXJGb290ZXI6IG51bGwsXG4gICAgICByZW5kZXJUb29sYmFyOiBudWxsLFxuICAgICAgcmVuZGVySW5saW5lOiBudWxsLFxuICAgICAgcmVuZGVyUG9wb3ZlcjogbnVsbCxcbiAgICAgIHJlbmRlclNoZWV0OiBudWxsLFxuICAgICAgcmVuZGVyOiBudWxsLFxuICAgIH0sXG4gIH0sXG59O1xuXG5mdW5jdGlvbiBwaWNrZXJDb2x1bW4gKGNvbEVsLCB1cGRhdGVJdGVtcykge1xuICBjb25zdCBwaWNrZXIgPSB0aGlzO1xuICBjb25zdCBhcHAgPSBwaWNrZXIuYXBwO1xuICBjb25zdCAkY29sRWwgPSAkKGNvbEVsKTtcbiAgY29uc3QgY29sSW5kZXggPSAkY29sRWwuaW5kZXgoKTtcbiAgY29uc3QgY29sID0gcGlja2VyLmNvbHNbY29sSW5kZXhdO1xuICBpZiAoY29sLmRpdmlkZXIpIHJldHVybjtcblxuICBjb2wuJGVsID0gJGNvbEVsO1xuICBjb2wuZWwgPSAkY29sRWxbMF07XG4gIGNvbC4kaXRlbXNFbCA9IGNvbC4kZWwuZmluZCgnLnBpY2tlci1pdGVtcycpO1xuICBjb2wuaXRlbXMgPSBjb2wuJGl0ZW1zRWwuZmluZCgnLnBpY2tlci1pdGVtJyk7XG5cbiAgbGV0IGl0ZW1IZWlnaHQ7XG4gIGxldCBpdGVtc0hlaWdodDtcbiAgbGV0IG1pblRyYW5zbGF0ZTtcbiAgbGV0IG1heFRyYW5zbGF0ZTtcbiAgbGV0IGFuaW1hdGlvbkZyYW1lSWQ7XG5cbiAgZnVuY3Rpb24gdXBkYXRlRHVyaW5nU2Nyb2xsKCkge1xuICAgIGFuaW1hdGlvbkZyYW1lSWQgPSBVdGlscy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgY29sLnVwZGF0ZUl0ZW1zKHVuZGVmaW5lZCwgdW5kZWZpbmVkLCAwKTtcbiAgICAgIHVwZGF0ZUR1cmluZ1Njcm9sbCgpO1xuICAgIH0pO1xuICB9XG5cbiAgY29sLnJlcGxhY2VWYWx1ZXMgPSBmdW5jdGlvbiByZXBsYWNlQ29sVmFsdWVzKHZhbHVlcywgZGlzcGxheVZhbHVlcykge1xuICAgIGNvbC5kZXRhY2hFdmVudHMoKTtcbiAgICBjb2wudmFsdWVzID0gdmFsdWVzO1xuICAgIGNvbC5kaXNwbGF5VmFsdWVzID0gZGlzcGxheVZhbHVlcztcbiAgICBjb2wuJGl0ZW1zRWwuaHRtbChwaWNrZXIucmVuZGVyQ29sdW1uKGNvbCwgdHJ1ZSkpO1xuICAgIGNvbC5pdGVtcyA9IGNvbC4kaXRlbXNFbC5maW5kKCcucGlja2VyLWl0ZW0nKTtcbiAgICBjb2wuY2FsY1NpemUoKTtcbiAgICBjb2wuc2V0VmFsdWUoY29sLnZhbHVlc1swXSwgMCwgdHJ1ZSk7XG4gICAgY29sLmF0dGFjaEV2ZW50cygpO1xuICB9O1xuICBjb2wuY2FsY1NpemUgPSBmdW5jdGlvbiBjYWxjQ29sU2l6ZSgpIHtcbiAgICBpZiAocGlja2VyLnBhcmFtcy5yb3RhdGVFZmZlY3QpIHtcbiAgICAgIGNvbC4kZWwucmVtb3ZlQ2xhc3MoJ3BpY2tlci1jb2x1bW4tYWJzb2x1dGUnKTtcbiAgICAgIGlmICghY29sLndpZHRoKSBjb2wuJGVsLmNzcyh7IHdpZHRoOiAnJyB9KTtcbiAgICB9XG4gICAgbGV0IGNvbFdpZHRoID0gMDtcbiAgICBjb25zdCBjb2xIZWlnaHQgPSBjb2wuJGVsWzBdLm9mZnNldEhlaWdodDtcbiAgICBpdGVtSGVpZ2h0ID0gY29sLml0ZW1zWzBdLm9mZnNldEhlaWdodDtcbiAgICBpdGVtc0hlaWdodCA9IGl0ZW1IZWlnaHQgKiBjb2wuaXRlbXMubGVuZ3RoO1xuICAgIG1pblRyYW5zbGF0ZSA9ICgoY29sSGVpZ2h0IC8gMikgLSBpdGVtc0hlaWdodCkgKyAoaXRlbUhlaWdodCAvIDIpO1xuICAgIG1heFRyYW5zbGF0ZSA9IChjb2xIZWlnaHQgLyAyKSAtIChpdGVtSGVpZ2h0IC8gMik7XG4gICAgaWYgKGNvbC53aWR0aCkge1xuICAgICAgY29sV2lkdGggPSBjb2wud2lkdGg7XG4gICAgICBpZiAocGFyc2VJbnQoY29sV2lkdGgsIDEwKSA9PT0gY29sV2lkdGgpIGNvbFdpZHRoICs9ICdweCc7XG4gICAgICBjb2wuJGVsLmNzcyh7IHdpZHRoOiBjb2xXaWR0aCB9KTtcbiAgICB9XG4gICAgaWYgKHBpY2tlci5wYXJhbXMucm90YXRlRWZmZWN0KSB7XG4gICAgICBpZiAoIWNvbC53aWR0aCkge1xuICAgICAgICBjb2wuaXRlbXMuZWFjaCgoaW5kZXgsIGl0ZW1FbCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGl0ZW0gPSAkKGl0ZW1FbCkuY2hpbGRyZW4oJ3NwYW4nKTtcbiAgICAgICAgICBjb2xXaWR0aCA9IE1hdGgubWF4KGNvbFdpZHRoLCBpdGVtWzBdLm9mZnNldFdpZHRoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbC4kZWwuY3NzKHsgd2lkdGg6IGAke2NvbFdpZHRoICsgMn1weGAgfSk7XG4gICAgICB9XG4gICAgICBjb2wuJGVsLmFkZENsYXNzKCdwaWNrZXItY29sdW1uLWFic29sdXRlJyk7XG4gICAgfVxuICB9O1xuXG4gIGNvbC5zZXRWYWx1ZSA9IGZ1bmN0aW9uIHNldENvbFZhbHVlKG5ld1ZhbHVlLCB0cmFuc2l0aW9uID0gJycsIHZhbHVlQ2FsbGJhY2tzKSB7XG4gICAgY29uc3QgbmV3QWN0aXZlSW5kZXggPSBjb2wuJGl0ZW1zRWwuZmluZChgLnBpY2tlci1pdGVtW2RhdGEtcGlja2VyLXZhbHVlPVwiJHtuZXdWYWx1ZX1cIl1gKS5pbmRleCgpO1xuICAgIGlmICh0eXBlb2YgbmV3QWN0aXZlSW5kZXggPT09ICd1bmRlZmluZWQnIHx8IG5ld0FjdGl2ZUluZGV4ID09PSAtMSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBuZXdUcmFuc2xhdGUgPSAoLW5ld0FjdGl2ZUluZGV4ICogaXRlbUhlaWdodCkgKyBtYXhUcmFuc2xhdGU7XG4gICAgLy8gVXBkYXRlIHdyYXBwZXJcbiAgICBjb2wuJGl0ZW1zRWwudHJhbnNpdGlvbih0cmFuc2l0aW9uKTtcbiAgICBjb2wuJGl0ZW1zRWwudHJhbnNmb3JtKGB0cmFuc2xhdGUzZCgwLCR7bmV3VHJhbnNsYXRlfXB4LDApYCk7XG5cbiAgICAvLyBXYXRjaCBpdGVtc1xuICAgIGlmIChwaWNrZXIucGFyYW1zLnVwZGF0ZVZhbHVlc09uTW9tZW50dW0gJiYgY29sLmFjdGl2ZUluZGV4ICYmIGNvbC5hY3RpdmVJbmRleCAhPT0gbmV3QWN0aXZlSW5kZXgpIHtcbiAgICAgIFV0aWxzLmNhbmNlbEFuaW1hdGlvbkZyYW1lKGFuaW1hdGlvbkZyYW1lSWQpO1xuICAgICAgY29sLiRpdGVtc0VsLnRyYW5zaXRpb25FbmQoKCkgPT4ge1xuICAgICAgICBVdGlscy5jYW5jZWxBbmltYXRpb25GcmFtZShhbmltYXRpb25GcmFtZUlkKTtcbiAgICAgIH0pO1xuICAgICAgdXBkYXRlRHVyaW5nU2Nyb2xsKCk7XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIGl0ZW1zXG4gICAgY29sLnVwZGF0ZUl0ZW1zKG5ld0FjdGl2ZUluZGV4LCBuZXdUcmFuc2xhdGUsIHRyYW5zaXRpb24sIHZhbHVlQ2FsbGJhY2tzKTtcbiAgfTtcblxuICBjb2wudXBkYXRlSXRlbXMgPSBmdW5jdGlvbiB1cGRhdGVDb2xJdGVtcyhhY3RpdmVJbmRleCwgdHJhbnNsYXRlLCB0cmFuc2l0aW9uLCB2YWx1ZUNhbGxiYWNrcykge1xuICAgIGlmICh0eXBlb2YgdHJhbnNsYXRlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICB0cmFuc2xhdGUgPSBVdGlscy5nZXRUcmFuc2xhdGUoY29sLiRpdGVtc0VsWzBdLCAneScpO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICBpZiAodHlwZW9mIGFjdGl2ZUluZGV4ID09PSAndW5kZWZpbmVkJykgYWN0aXZlSW5kZXggPSAtTWF0aC5yb3VuZCgodHJhbnNsYXRlIC0gbWF4VHJhbnNsYXRlKSAvIGl0ZW1IZWlnaHQpO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgIGlmIChhY3RpdmVJbmRleCA8IDApIGFjdGl2ZUluZGV4ID0gMDtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICBpZiAoYWN0aXZlSW5kZXggPj0gY29sLml0ZW1zLmxlbmd0aCkgYWN0aXZlSW5kZXggPSBjb2wuaXRlbXMubGVuZ3RoIC0gMTtcbiAgICBjb25zdCBwcmV2aW91c0FjdGl2ZUluZGV4ID0gY29sLmFjdGl2ZUluZGV4O1xuICAgIGNvbC5hY3RpdmVJbmRleCA9IGFjdGl2ZUluZGV4O1xuICAgIGNvbC4kaXRlbXNFbC5maW5kKCcucGlja2VyLWl0ZW0tc2VsZWN0ZWQnKS5yZW1vdmVDbGFzcygncGlja2VyLWl0ZW0tc2VsZWN0ZWQnKTtcblxuICAgIGNvbC5pdGVtcy50cmFuc2l0aW9uKHRyYW5zaXRpb24pO1xuXG4gICAgY29uc3Qgc2VsZWN0ZWRJdGVtID0gY29sLml0ZW1zLmVxKGFjdGl2ZUluZGV4KS5hZGRDbGFzcygncGlja2VyLWl0ZW0tc2VsZWN0ZWQnKS50cmFuc2Zvcm0oJycpO1xuXG4gICAgLy8gU2V0IDNEIHJvdGF0ZSBlZmZlY3RcbiAgICBpZiAocGlja2VyLnBhcmFtcy5yb3RhdGVFZmZlY3QpIHtcbiAgICAgIGNvbC5pdGVtcy5lYWNoKChpbmRleCwgaXRlbUVsKSA9PiB7XG4gICAgICAgIGNvbnN0ICRpdGVtRWwgPSAkKGl0ZW1FbCk7XG4gICAgICAgIGNvbnN0IGl0ZW1PZmZzZXRUb3AgPSAkaXRlbUVsLmluZGV4KCkgKiBpdGVtSGVpZ2h0O1xuICAgICAgICBjb25zdCB0cmFuc2xhdGVPZmZzZXQgPSBtYXhUcmFuc2xhdGUgLSB0cmFuc2xhdGU7XG4gICAgICAgIGNvbnN0IGl0ZW1PZmZzZXQgPSBpdGVtT2Zmc2V0VG9wIC0gdHJhbnNsYXRlT2Zmc2V0O1xuICAgICAgICBjb25zdCBwZXJjZW50YWdlID0gaXRlbU9mZnNldCAvIGl0ZW1IZWlnaHQ7XG4gICAgICAgIGNvbnN0IGl0ZW1zRml0ID0gTWF0aC5jZWlsKGNvbC5oZWlnaHQgLyBpdGVtSGVpZ2h0IC8gMikgKyAxO1xuXG4gICAgICAgIGxldCBhbmdsZSA9ICgtMTggKiBwZXJjZW50YWdlKTtcbiAgICAgICAgaWYgKGFuZ2xlID4gMTgwKSBhbmdsZSA9IDE4MDtcbiAgICAgICAgaWYgKGFuZ2xlIDwgLTE4MCkgYW5nbGUgPSAtMTgwO1xuICAgICAgICBpZiAoTWF0aC5hYnMocGVyY2VudGFnZSkgPiBpdGVtc0ZpdCkge1xuICAgICAgICAgICRpdGVtRWwuYWRkQ2xhc3MoJ3BpY2tlci1pdGVtLWZhcicpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICRpdGVtRWwucmVtb3ZlQ2xhc3MoJ3BpY2tlci1pdGVtLWZhcicpO1xuICAgICAgICB9XG4gICAgICAgICRpdGVtRWwudHJhbnNmb3JtKGB0cmFuc2xhdGUzZCgwLCAkey10cmFuc2xhdGUgKyBtYXhUcmFuc2xhdGV9cHgsICR7cGlja2VyLm5lZWRzT3JpZ2luRml4ID8gLTExMCA6IDB9cHgpIHJvdGF0ZVgoJHthbmdsZX1kZWcpYCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAodmFsdWVDYWxsYmFja3MgfHwgdHlwZW9mIHZhbHVlQ2FsbGJhY2tzID09PSAndW5kZWZpbmVkJykge1xuICAgICAgLy8gVXBkYXRlIHZhbHVlc1xuICAgICAgY29sLnZhbHVlID0gc2VsZWN0ZWRJdGVtLmF0dHIoJ2RhdGEtcGlja2VyLXZhbHVlJyk7XG4gICAgICBjb2wuZGlzcGxheVZhbHVlID0gY29sLmRpc3BsYXlWYWx1ZXMgPyBjb2wuZGlzcGxheVZhbHVlc1thY3RpdmVJbmRleF0gOiBjb2wudmFsdWU7XG4gICAgICAvLyBPbiBjaGFuZ2UgY2FsbGJhY2tcbiAgICAgIGlmIChwcmV2aW91c0FjdGl2ZUluZGV4ICE9PSBhY3RpdmVJbmRleCkge1xuICAgICAgICBpZiAoY29sLm9uQ2hhbmdlKSB7XG4gICAgICAgICAgY29sLm9uQ2hhbmdlKHBpY2tlciwgY29sLnZhbHVlLCBjb2wuZGlzcGxheVZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBwaWNrZXIudXBkYXRlVmFsdWUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgbGV0IGFsbG93SXRlbUNsaWNrID0gdHJ1ZTtcbiAgbGV0IGlzVG91Y2hlZDtcbiAgbGV0IGlzTW92ZWQ7XG4gIGxldCB0b3VjaFN0YXJ0WTtcbiAgbGV0IHRvdWNoQ3VycmVudFk7XG4gIGxldCB0b3VjaFN0YXJ0VGltZTtcbiAgbGV0IHRvdWNoRW5kVGltZTtcbiAgbGV0IHN0YXJ0VHJhbnNsYXRlO1xuICBsZXQgcmV0dXJuVG87XG4gIGxldCBjdXJyZW50VHJhbnNsYXRlO1xuICBsZXQgcHJldlRyYW5zbGF0ZTtcbiAgbGV0IHZlbG9jaXR5VHJhbnNsYXRlO1xuICBmdW5jdGlvbiBoYW5kbGVUb3VjaFN0YXJ0KGUpIHtcbiAgICBpZiAoaXNNb3ZlZCB8fCBpc1RvdWNoZWQpIHJldHVybjtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgaXNUb3VjaGVkID0gdHJ1ZTtcbiAgICB0b3VjaFN0YXJ0WSA9IGUudHlwZSA9PT0gJ3RvdWNoc3RhcnQnID8gZS50YXJnZXRUb3VjaGVzWzBdLnBhZ2VZIDogZS5wYWdlWTtcbiAgICB0b3VjaEN1cnJlbnRZID0gdG91Y2hTdGFydFk7XG4gICAgdG91Y2hTdGFydFRpbWUgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuXG4gICAgYWxsb3dJdGVtQ2xpY2sgPSB0cnVlO1xuICAgIHN0YXJ0VHJhbnNsYXRlID0gVXRpbHMuZ2V0VHJhbnNsYXRlKGNvbC4kaXRlbXNFbFswXSwgJ3knKTtcbiAgICBjdXJyZW50VHJhbnNsYXRlID0gc3RhcnRUcmFuc2xhdGU7XG4gIH1cbiAgZnVuY3Rpb24gaGFuZGxlVG91Y2hNb3ZlKGUpIHtcbiAgICBpZiAoIWlzVG91Y2hlZCkgcmV0dXJuO1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBhbGxvd0l0ZW1DbGljayA9IGZhbHNlO1xuICAgIHRvdWNoQ3VycmVudFkgPSBlLnR5cGUgPT09ICd0b3VjaG1vdmUnID8gZS50YXJnZXRUb3VjaGVzWzBdLnBhZ2VZIDogZS5wYWdlWTtcbiAgICBpZiAoIWlzTW92ZWQpIHtcbiAgICAgIC8vIEZpcnN0IG1vdmVcbiAgICAgIFV0aWxzLmNhbmNlbEFuaW1hdGlvbkZyYW1lKGFuaW1hdGlvbkZyYW1lSWQpO1xuICAgICAgaXNNb3ZlZCA9IHRydWU7XG4gICAgICBzdGFydFRyYW5zbGF0ZSA9IFV0aWxzLmdldFRyYW5zbGF0ZShjb2wuJGl0ZW1zRWxbMF0sICd5Jyk7XG4gICAgICBjdXJyZW50VHJhbnNsYXRlID0gc3RhcnRUcmFuc2xhdGU7XG4gICAgICBjb2wuJGl0ZW1zRWwudHJhbnNpdGlvbigwKTtcbiAgICB9XG5cbiAgICBjb25zdCBkaWZmID0gdG91Y2hDdXJyZW50WSAtIHRvdWNoU3RhcnRZO1xuICAgIGN1cnJlbnRUcmFuc2xhdGUgPSBzdGFydFRyYW5zbGF0ZSArIGRpZmY7XG4gICAgcmV0dXJuVG8gPSB1bmRlZmluZWQ7XG5cbiAgICAvLyBOb3JtYWxpemUgdHJhbnNsYXRlXG4gICAgaWYgKGN1cnJlbnRUcmFuc2xhdGUgPCBtaW5UcmFuc2xhdGUpIHtcbiAgICAgIGN1cnJlbnRUcmFuc2xhdGUgPSBtaW5UcmFuc2xhdGUgLSAoKG1pblRyYW5zbGF0ZSAtIGN1cnJlbnRUcmFuc2xhdGUpICoqIDAuOCk7XG4gICAgICByZXR1cm5UbyA9ICdtaW4nO1xuICAgIH1cbiAgICBpZiAoY3VycmVudFRyYW5zbGF0ZSA+IG1heFRyYW5zbGF0ZSkge1xuICAgICAgY3VycmVudFRyYW5zbGF0ZSA9IG1heFRyYW5zbGF0ZSArICgoY3VycmVudFRyYW5zbGF0ZSAtIG1heFRyYW5zbGF0ZSkgKiogMC44KTtcbiAgICAgIHJldHVyblRvID0gJ21heCc7XG4gICAgfVxuICAgIC8vIFRyYW5zZm9ybSB3cmFwcGVyXG4gICAgY29sLiRpdGVtc0VsLnRyYW5zZm9ybShgdHJhbnNsYXRlM2QoMCwke2N1cnJlbnRUcmFuc2xhdGV9cHgsMClgKTtcblxuICAgIC8vIFVwZGF0ZSBpdGVtc1xuICAgIGNvbC51cGRhdGVJdGVtcyh1bmRlZmluZWQsIGN1cnJlbnRUcmFuc2xhdGUsIDAsIHBpY2tlci5wYXJhbXMudXBkYXRlVmFsdWVzT25Ub3VjaG1vdmUpO1xuXG4gICAgLy8gQ2FsYyB2ZWxvY2l0eVxuICAgIHZlbG9jaXR5VHJhbnNsYXRlID0gY3VycmVudFRyYW5zbGF0ZSAtIHByZXZUcmFuc2xhdGUgfHwgY3VycmVudFRyYW5zbGF0ZTtcbiAgICBwcmV2VHJhbnNsYXRlID0gY3VycmVudFRyYW5zbGF0ZTtcbiAgfVxuICBmdW5jdGlvbiBoYW5kbGVUb3VjaEVuZCgpIHtcbiAgICBpZiAoIWlzVG91Y2hlZCB8fCAhaXNNb3ZlZCkge1xuICAgICAgaXNUb3VjaGVkID0gZmFsc2U7XG4gICAgICBpc01vdmVkID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlzVG91Y2hlZCA9IGZhbHNlO1xuICAgIGlzTW92ZWQgPSBmYWxzZTtcbiAgICBjb2wuJGl0ZW1zRWwudHJhbnNpdGlvbignJyk7XG4gICAgaWYgKHJldHVyblRvKSB7XG4gICAgICBpZiAocmV0dXJuVG8gPT09ICdtaW4nKSB7XG4gICAgICAgIGNvbC4kaXRlbXNFbC50cmFuc2Zvcm0oYHRyYW5zbGF0ZTNkKDAsJHttaW5UcmFuc2xhdGV9cHgsMClgKTtcbiAgICAgIH0gZWxzZSBjb2wuJGl0ZW1zRWwudHJhbnNmb3JtKGB0cmFuc2xhdGUzZCgwLCR7bWF4VHJhbnNsYXRlfXB4LDApYCk7XG4gICAgfVxuICAgIHRvdWNoRW5kVGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgIGxldCBuZXdUcmFuc2xhdGU7XG4gICAgaWYgKHRvdWNoRW5kVGltZSAtIHRvdWNoU3RhcnRUaW1lID4gMzAwKSB7XG4gICAgICBuZXdUcmFuc2xhdGUgPSBjdXJyZW50VHJhbnNsYXRlO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXdUcmFuc2xhdGUgPSBjdXJyZW50VHJhbnNsYXRlICsgKHZlbG9jaXR5VHJhbnNsYXRlICogcGlja2VyLnBhcmFtcy5tb21lbnR1bVJhdGlvKTtcbiAgICB9XG5cbiAgICBuZXdUcmFuc2xhdGUgPSBNYXRoLm1heChNYXRoLm1pbihuZXdUcmFuc2xhdGUsIG1heFRyYW5zbGF0ZSksIG1pblRyYW5zbGF0ZSk7XG5cbiAgICAvLyBBY3RpdmUgSW5kZXhcbiAgICBjb25zdCBhY3RpdmVJbmRleCA9IC1NYXRoLmZsb29yKChuZXdUcmFuc2xhdGUgLSBtYXhUcmFuc2xhdGUpIC8gaXRlbUhlaWdodCk7XG5cbiAgICAvLyBOb3JtYWxpemUgdHJhbnNsYXRlXG4gICAgaWYgKCFwaWNrZXIucGFyYW1zLmZyZWVNb2RlKSBuZXdUcmFuc2xhdGUgPSAoLWFjdGl2ZUluZGV4ICogaXRlbUhlaWdodCkgKyBtYXhUcmFuc2xhdGU7XG5cbiAgICAvLyBUcmFuc2Zvcm0gd3JhcHBlclxuICAgIGNvbC4kaXRlbXNFbC50cmFuc2Zvcm0oYHRyYW5zbGF0ZTNkKDAsJHtwYXJzZUludChuZXdUcmFuc2xhdGUsIDEwKX1weCwwKWApO1xuXG4gICAgLy8gVXBkYXRlIGl0ZW1zXG4gICAgY29sLnVwZGF0ZUl0ZW1zKGFjdGl2ZUluZGV4LCBuZXdUcmFuc2xhdGUsICcnLCB0cnVlKTtcblxuICAgIC8vIFdhdGNoIGl0ZW1zXG4gICAgaWYgKHBpY2tlci5wYXJhbXMudXBkYXRlVmFsdWVzT25Nb21lbnR1bSkge1xuICAgICAgdXBkYXRlRHVyaW5nU2Nyb2xsKCk7XG4gICAgICBjb2wuJGl0ZW1zRWwudHJhbnNpdGlvbkVuZCgoKSA9PiB7XG4gICAgICAgIFV0aWxzLmNhbmNlbEFuaW1hdGlvbkZyYW1lKGFuaW1hdGlvbkZyYW1lSWQpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gQWxsb3cgY2xpY2tcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGFsbG93SXRlbUNsaWNrID0gdHJ1ZTtcbiAgICB9LCAxMDApO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlQ2xpY2soKSB7XG4gICAgaWYgKCFhbGxvd0l0ZW1DbGljaykgcmV0dXJuO1xuICAgIFV0aWxzLmNhbmNlbEFuaW1hdGlvbkZyYW1lKGFuaW1hdGlvbkZyYW1lSWQpO1xuICAgIGNvbnN0IHZhbHVlID0gJCh0aGlzKS5hdHRyKCdkYXRhLXBpY2tlci12YWx1ZScpO1xuICAgIGNvbC5zZXRWYWx1ZSh2YWx1ZSk7XG4gIH1cblxuICBjb25zdCBhY3RpdmVMaXN0ZW5lciA9IGFwcC5zdXBwb3J0LnBhc3NpdmVMaXN0ZW5lciA/IHsgcGFzc2l2ZTogZmFsc2UsIGNhcHR1cmU6IGZhbHNlIH0gOiBmYWxzZTtcbiAgY29sLmF0dGFjaEV2ZW50cyA9IGZ1bmN0aW9uIGF0dGFjaENvbEV2ZW50cygpIHtcbiAgICBjb2wuJGVsLm9uKGFwcC50b3VjaEV2ZW50cy5zdGFydCwgaGFuZGxlVG91Y2hTdGFydCwgYWN0aXZlTGlzdGVuZXIpO1xuICAgIGFwcC5vbigndG91Y2htb3ZlOmFjdGl2ZScsIGhhbmRsZVRvdWNoTW92ZSk7XG4gICAgYXBwLm9uKCd0b3VjaGVuZDpwYXNzaXZlJywgaGFuZGxlVG91Y2hFbmQpO1xuICAgIGNvbC5pdGVtcy5vbignY2xpY2snLCBoYW5kbGVDbGljayk7XG4gIH07XG4gIGNvbC5kZXRhY2hFdmVudHMgPSBmdW5jdGlvbiBkZXRhY2hDb2xFdmVudHMoKSB7XG4gICAgY29sLiRlbC5vZmYoYXBwLnRvdWNoRXZlbnRzLnN0YXJ0LCBoYW5kbGVUb3VjaFN0YXJ0LCBhY3RpdmVMaXN0ZW5lcik7XG4gICAgYXBwLm9mZigndG91Y2htb3ZlOmFjdGl2ZScsIGhhbmRsZVRvdWNoTW92ZSk7XG4gICAgYXBwLm9mZigndG91Y2hlbmQ6cGFzc2l2ZScsIGhhbmRsZVRvdWNoRW5kKTtcbiAgICBjb2wuaXRlbXMub2ZmKCdjbGljaycsIGhhbmRsZUNsaWNrKTtcbiAgfTtcblxuICBjb2wuaW5pdCA9IGZ1bmN0aW9uIGluaXRDb2woKSB7XG4gICAgY29sLmNhbGNTaXplKCk7XG4gICAgY29sLiRpdGVtc0VsLnRyYW5zZm9ybShgdHJhbnNsYXRlM2QoMCwke21heFRyYW5zbGF0ZX1weCwwKWApLnRyYW5zaXRpb24oMCk7XG4gICAgaWYgKGNvbEluZGV4ID09PSAwKSBjb2wuJGVsLmFkZENsYXNzKCdwaWNrZXItY29sdW1uLWZpcnN0Jyk7XG4gICAgaWYgKGNvbEluZGV4ID09PSBwaWNrZXIuY29scy5sZW5ndGggLSAxKSBjb2wuJGVsLmFkZENsYXNzKCdwaWNrZXItY29sdW1uLWxhc3QnKTtcbiAgICAvLyBVcGRhdGUgaXRlbXMgb24gaW5pdFxuICAgIGlmICh1cGRhdGVJdGVtcykgY29sLnVwZGF0ZUl0ZW1zKDAsIG1heFRyYW5zbGF0ZSwgMCk7XG5cbiAgICBjb2wuYXR0YWNoRXZlbnRzKCk7XG4gIH07XG5cbiAgY29sLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95Q29sKCkge1xuICAgIGNvbC5kZXRhY2hFdmVudHMoKTtcbiAgfTtcblxuICBjb2wuaW5pdCgpO1xufVxuXG5jbGFzcyBQaWNrZXIgZXh0ZW5kcyBGcmFtZXdvcms3Q2xhc3Mge1xuICBjb25zdHJ1Y3RvcihhcHAsIHBhcmFtcyA9IHt9KSB7XG4gICAgc3VwZXIocGFyYW1zLCBbYXBwXSk7XG4gICAgY29uc3QgcGlja2VyID0gdGhpcztcbiAgICBwaWNrZXIucGFyYW1zID0gVXRpbHMuZXh0ZW5kKHt9LCBhcHAucGFyYW1zLnBpY2tlciwgcGFyYW1zKTtcblxuICAgIGxldCAkY29udGFpbmVyRWw7XG4gICAgaWYgKHBpY2tlci5wYXJhbXMuY29udGFpbmVyRWwpIHtcbiAgICAgICRjb250YWluZXJFbCA9ICQocGlja2VyLnBhcmFtcy5jb250YWluZXJFbCk7XG4gICAgICBpZiAoJGNvbnRhaW5lckVsLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHBpY2tlcjtcbiAgICB9XG5cbiAgICBsZXQgJGlucHV0RWw7XG4gICAgaWYgKHBpY2tlci5wYXJhbXMuaW5wdXRFbCkge1xuICAgICAgJGlucHV0RWwgPSAkKHBpY2tlci5wYXJhbXMuaW5wdXRFbCk7XG4gICAgfVxuXG4gICAgbGV0IHZpZXc7XG4gICAgaWYgKCRpbnB1dEVsKSB7XG4gICAgICB2aWV3ID0gJGlucHV0RWwucGFyZW50cygnLnZpZXcnKS5sZW5ndGggJiYgJGlucHV0RWwucGFyZW50cygnLnZpZXcnKVswXS5mN1ZpZXc7XG4gICAgfVxuICAgIGlmICghdmlldykgdmlldyA9IGFwcC52aWV3cy5tYWluO1xuXG4gICAgVXRpbHMuZXh0ZW5kKHBpY2tlciwge1xuICAgICAgYXBwLFxuICAgICAgJGNvbnRhaW5lckVsLFxuICAgICAgY29udGFpbmVyRWw6ICRjb250YWluZXJFbCAmJiAkY29udGFpbmVyRWxbMF0sXG4gICAgICBpbmxpbmU6ICRjb250YWluZXJFbCAmJiAkY29udGFpbmVyRWwubGVuZ3RoID4gMCxcbiAgICAgIG5lZWRzT3JpZ2luRml4OiBhcHAuZGV2aWNlLmlvcyB8fCAoKHdpbmRvdyQxLm5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdzYWZhcmknKSA+PSAwICYmIHdpbmRvdyQxLm5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdjaHJvbWUnKSA8IDApICYmICFhcHAuZGV2aWNlLmFuZHJvaWQpLFxuICAgICAgY29sczogW10sXG4gICAgICAkaW5wdXRFbCxcbiAgICAgIGlucHV0RWw6ICRpbnB1dEVsICYmICRpbnB1dEVsWzBdLFxuICAgICAgaW5pdGlhbGl6ZWQ6IGZhbHNlLFxuICAgICAgb3BlbmVkOiBmYWxzZSxcbiAgICAgIHVybDogcGlja2VyLnBhcmFtcy51cmwsXG4gICAgICB2aWV3LFxuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gb25SZXNpemUoKSB7XG4gICAgICBwaWNrZXIucmVzaXplQ29scygpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvbklucHV0Q2xpY2soKSB7XG4gICAgICBwaWNrZXIub3BlbigpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvbklucHV0Rm9jdXMoZSkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvbkh0bWxDbGljayhlKSB7XG4gICAgICBjb25zdCAkdGFyZ2V0RWwgPSAkKGUudGFyZ2V0KTtcbiAgICAgIGlmIChwaWNrZXIuaXNQb3BvdmVyKCkpIHJldHVybjtcbiAgICAgIGlmICghcGlja2VyLm9wZW5lZCkgcmV0dXJuO1xuICAgICAgaWYgKCR0YXJnZXRFbC5jbG9zZXN0KCdbY2xhc3MqPVwiYmFja2Ryb3BcIl0nKS5sZW5ndGgpIHJldHVybjtcbiAgICAgIGlmICgkaW5wdXRFbCAmJiAkaW5wdXRFbC5sZW5ndGggPiAwKSB7XG4gICAgICAgIGlmICgkdGFyZ2V0RWxbMF0gIT09ICRpbnB1dEVsWzBdICYmICR0YXJnZXRFbC5jbG9zZXN0KCcuc2hlZXQtbW9kYWwnKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBwaWNrZXIuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICgkKGUudGFyZ2V0KS5jbG9zZXN0KCcuc2hlZXQtbW9kYWwnKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcGlja2VyLmNsb3NlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRXZlbnRzXG4gICAgVXRpbHMuZXh0ZW5kKHBpY2tlciwge1xuICAgICAgYXR0YWNoUmVzaXplRXZlbnQoKSB7XG4gICAgICAgIGFwcC5vbigncmVzaXplJywgb25SZXNpemUpO1xuICAgICAgfSxcbiAgICAgIGRldGFjaFJlc2l6ZUV2ZW50KCkge1xuICAgICAgICBhcHAub2ZmKCdyZXNpemUnLCBvblJlc2l6ZSk7XG4gICAgICB9LFxuICAgICAgYXR0YWNoSW5wdXRFdmVudHMoKSB7XG4gICAgICAgIHBpY2tlci4kaW5wdXRFbC5vbignY2xpY2snLCBvbklucHV0Q2xpY2spO1xuICAgICAgICBpZiAocGlja2VyLnBhcmFtcy5pbnB1dFJlYWRPbmx5KSB7XG4gICAgICAgICAgcGlja2VyLiRpbnB1dEVsLm9uKCdmb2N1cyBtb3VzZWRvd24nLCBvbklucHV0Rm9jdXMpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZGV0YWNoSW5wdXRFdmVudHMoKSB7XG4gICAgICAgIHBpY2tlci4kaW5wdXRFbC5vZmYoJ2NsaWNrJywgb25JbnB1dENsaWNrKTtcbiAgICAgICAgaWYgKHBpY2tlci5wYXJhbXMuaW5wdXRSZWFkT25seSkge1xuICAgICAgICAgIHBpY2tlci4kaW5wdXRFbC5vZmYoJ2ZvY3VzIG1vdXNlZG93bicsIG9uSW5wdXRGb2N1cyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBhdHRhY2hIdG1sRXZlbnRzKCkge1xuICAgICAgICBhcHAub24oJ2NsaWNrJywgb25IdG1sQ2xpY2spO1xuICAgICAgfSxcbiAgICAgIGRldGFjaEh0bWxFdmVudHMoKSB7XG4gICAgICAgIGFwcC5vZmYoJ2NsaWNrJywgb25IdG1sQ2xpY2spO1xuICAgICAgfSxcbiAgICB9KTtcblxuICAgIHBpY2tlci5pbml0KCk7XG5cbiAgICByZXR1cm4gcGlja2VyO1xuICB9XG4gIGluaXRJbnB1dCgpIHtcbiAgICBjb25zdCBwaWNrZXIgPSB0aGlzO1xuICAgIGlmICghcGlja2VyLiRpbnB1dEVsKSByZXR1cm47XG4gICAgaWYgKHBpY2tlci5wYXJhbXMuaW5wdXRSZWFkT25seSkgcGlja2VyLiRpbnB1dEVsLnByb3AoJ3JlYWRPbmx5JywgdHJ1ZSk7XG4gIH1cbiAgcmVzaXplQ29scygpIHtcbiAgICBjb25zdCBwaWNrZXIgPSB0aGlzO1xuICAgIGlmICghcGlja2VyLm9wZW5lZCkgcmV0dXJuO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGlja2VyLmNvbHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGlmICghcGlja2VyLmNvbHNbaV0uZGl2aWRlcikge1xuICAgICAgICBwaWNrZXIuY29sc1tpXS5jYWxjU2l6ZSgpO1xuICAgICAgICBwaWNrZXIuY29sc1tpXS5zZXRWYWx1ZShwaWNrZXIuY29sc1tpXS52YWx1ZSwgMCwgZmFsc2UpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpc1BvcG92ZXIoKSB7XG4gICAgY29uc3QgcGlja2VyID0gdGhpcztcbiAgICBjb25zdCB7IGFwcCwgbW9kYWwsIHBhcmFtcyB9ID0gcGlja2VyO1xuICAgIGlmIChwYXJhbXMub3BlbkluID09PSAnc2hlZXQnKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKG1vZGFsICYmIG1vZGFsLnR5cGUgIT09ICdwb3BvdmVyJykgcmV0dXJuIGZhbHNlO1xuXG4gICAgaWYgKCFwaWNrZXIuaW5saW5lICYmIHBpY2tlci5pbnB1dEVsKSB7XG4gICAgICBpZiAocGFyYW1zLm9wZW5JbiA9PT0gJ3BvcG92ZXInKSByZXR1cm4gdHJ1ZTtcbiAgICAgIGVsc2UgaWYgKGFwcC5kZXZpY2UuaW9zKSB7XG4gICAgICAgIHJldHVybiAhIWFwcC5kZXZpY2UuaXBhZDtcbiAgICAgIH0gZWxzZSBpZiAoYXBwLndpZHRoID49IDc2OCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZvcm1hdFZhbHVlKCkge1xuICAgIGNvbnN0IHBpY2tlciA9IHRoaXM7XG4gICAgY29uc3QgeyB2YWx1ZSwgZGlzcGxheVZhbHVlIH0gPSBwaWNrZXI7XG4gICAgaWYgKHBpY2tlci5wYXJhbXMuZm9ybWF0VmFsdWUpIHtcbiAgICAgIHJldHVybiBwaWNrZXIucGFyYW1zLmZvcm1hdFZhbHVlLmNhbGwocGlja2VyLCB2YWx1ZSwgZGlzcGxheVZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlLmpvaW4oJyAnKTtcbiAgfVxuICBzZXRWYWx1ZSh2YWx1ZXMsIHRyYW5zaXRpb24pIHtcbiAgICBjb25zdCBwaWNrZXIgPSB0aGlzO1xuICAgIGxldCB2YWx1ZUluZGV4ID0gMDtcbiAgICBpZiAocGlja2VyLmNvbHMubGVuZ3RoID09PSAwKSB7XG4gICAgICBwaWNrZXIudmFsdWUgPSB2YWx1ZXM7XG4gICAgICBwaWNrZXIudXBkYXRlVmFsdWUodmFsdWVzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwaWNrZXIuY29scy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgaWYgKHBpY2tlci5jb2xzW2ldICYmICFwaWNrZXIuY29sc1tpXS5kaXZpZGVyKSB7XG4gICAgICAgIHBpY2tlci5jb2xzW2ldLnNldFZhbHVlKHZhbHVlc1t2YWx1ZUluZGV4XSwgdHJhbnNpdGlvbik7XG4gICAgICAgIHZhbHVlSW5kZXggKz0gMTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZ2V0VmFsdWUoKSB7XG4gICAgY29uc3QgcGlja2VyID0gdGhpcztcbiAgICByZXR1cm4gcGlja2VyLnZhbHVlO1xuICB9XG4gIHVwZGF0ZVZhbHVlKGZvcmNlVmFsdWVzKSB7XG4gICAgY29uc3QgcGlja2VyID0gdGhpcztcbiAgICBjb25zdCBuZXdWYWx1ZSA9IGZvcmNlVmFsdWVzIHx8IFtdO1xuICAgIGNvbnN0IG5ld0Rpc3BsYXlWYWx1ZSA9IFtdO1xuICAgIGxldCBjb2x1bW47XG4gICAgaWYgKHBpY2tlci5jb2xzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgY29uc3Qgbm9EaXZpZGVyQ29sdW1ucyA9IHBpY2tlci5wYXJhbXMuY29scy5maWx0ZXIoYyA9PiAhYy5kaXZpZGVyKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9EaXZpZGVyQ29sdW1ucy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBjb2x1bW4gPSBub0RpdmlkZXJDb2x1bW5zW2ldO1xuICAgICAgICBpZiAoY29sdW1uLmRpc3BsYXlWYWx1ZXMgIT09IHVuZGVmaW5lZCAmJiBjb2x1bW4udmFsdWVzICE9PSB1bmRlZmluZWQgJiYgY29sdW1uLnZhbHVlcy5pbmRleE9mKG5ld1ZhbHVlW2ldKSAhPT0gLTEpIHtcbiAgICAgICAgICBuZXdEaXNwbGF5VmFsdWUucHVzaChjb2x1bW4uZGlzcGxheVZhbHVlc1tjb2x1bW4udmFsdWVzLmluZGV4T2YobmV3VmFsdWVbaV0pXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV3RGlzcGxheVZhbHVlLnB1c2gobmV3VmFsdWVbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGlja2VyLmNvbHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKCFwaWNrZXIuY29sc1tpXS5kaXZpZGVyKSB7XG4gICAgICAgICAgbmV3VmFsdWUucHVzaChwaWNrZXIuY29sc1tpXS52YWx1ZSk7XG4gICAgICAgICAgbmV3RGlzcGxheVZhbHVlLnB1c2gocGlja2VyLmNvbHNbaV0uZGlzcGxheVZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChuZXdWYWx1ZS5pbmRleE9mKHVuZGVmaW5lZCkgPj0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBwaWNrZXIudmFsdWUgPSBuZXdWYWx1ZTtcbiAgICBwaWNrZXIuZGlzcGxheVZhbHVlID0gbmV3RGlzcGxheVZhbHVlO1xuICAgIHBpY2tlci5lbWl0KCdsb2NhbDo6Y2hhbmdlIHBpY2tlckNoYW5nZScsIHBpY2tlciwgcGlja2VyLnZhbHVlLCBwaWNrZXIuZGlzcGxheVZhbHVlKTtcbiAgICBpZiAocGlja2VyLmlucHV0RWwpIHtcbiAgICAgIHBpY2tlci4kaW5wdXRFbC52YWwocGlja2VyLmZvcm1hdFZhbHVlKCkpO1xuICAgICAgcGlja2VyLiRpbnB1dEVsLnRyaWdnZXIoJ2NoYW5nZScpO1xuICAgIH1cbiAgfVxuICBpbml0Q29sdW1uKGNvbEVsLCB1cGRhdGVJdGVtcykge1xuICAgIGNvbnN0IHBpY2tlciA9IHRoaXM7XG4gICAgcGlja2VyQ29sdW1uLmNhbGwocGlja2VyLCBjb2xFbCwgdXBkYXRlSXRlbXMpO1xuICB9XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICBkZXN0cm95Q29sdW1uKGNvbEVsKSB7XG4gICAgY29uc3QgcGlja2VyID0gdGhpcztcbiAgICBjb25zdCAkY29sRWwgPSAkKGNvbEVsKTtcbiAgICBjb25zdCBpbmRleCA9ICRjb2xFbC5pbmRleCgpO1xuICAgIGlmIChwaWNrZXIuY29sc1tpbmRleF0gJiYgcGlja2VyLmNvbHNbaW5kZXhdLmRlc3Ryb3kpIHtcbiAgICAgIHBpY2tlci5jb2xzW2luZGV4XS5kZXN0cm95KCk7XG4gICAgfVxuICB9XG4gIHJlbmRlclRvb2xiYXIoKSB7XG4gICAgY29uc3QgcGlja2VyID0gdGhpcztcbiAgICBpZiAocGlja2VyLnBhcmFtcy5yZW5kZXJUb29sYmFyKSByZXR1cm4gcGlja2VyLnBhcmFtcy5yZW5kZXJUb29sYmFyLmNhbGwocGlja2VyLCBwaWNrZXIpO1xuICAgIHJldHVybiBgXG4gICAgICA8ZGl2IGNsYXNzPVwidG9vbGJhciBuby1zaGFkb3dcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cInRvb2xiYXItaW5uZXJcIj5cbiAgICAgICAgICA8ZGl2IGNsYXNzPVwibGVmdFwiPjwvZGl2PlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJyaWdodFwiPlxuICAgICAgICAgICAgPGEgaHJlZj1cIiNcIiBjbGFzcz1cImxpbmsgc2hlZXQtY2xvc2UgcG9wb3Zlci1jbG9zZVwiPiR7cGlja2VyLnBhcmFtcy50b29sYmFyQ2xvc2VUZXh0fTwvYT5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICBgLnRyaW0oKTtcbiAgfVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgcmVuZGVyQ29sdW1uKGNvbCwgb25seUl0ZW1zKSB7XG4gICAgY29uc3QgY29sQ2xhc3NlcyA9IGBwaWNrZXItY29sdW1uICR7Y29sLnRleHRBbGlnbiA/IGBwaWNrZXItY29sdW1uLSR7Y29sLnRleHRBbGlnbn1gIDogJyd9ICR7Y29sLmNzc0NsYXNzIHx8ICcnfWA7XG4gICAgbGV0IGNvbHVtbkh0bWw7XG4gICAgbGV0IGNvbHVtbkl0ZW1zSHRtbDtcblxuICAgIGlmIChjb2wuZGl2aWRlcikge1xuICAgICAgY29sdW1uSHRtbCA9IGBcbiAgICAgICAgPGRpdiBjbGFzcz1cIiR7Y29sQ2xhc3Nlc30gcGlja2VyLWNvbHVtbi1kaXZpZGVyXCI+JHtjb2wuY29udGVudH08L2Rpdj5cbiAgICAgIGA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbHVtbkl0ZW1zSHRtbCA9IGNvbC52YWx1ZXMubWFwKCh2YWx1ZSwgaW5kZXgpID0+IGBcbiAgICAgICAgPGRpdiBjbGFzcz1cInBpY2tlci1pdGVtXCIgZGF0YS1waWNrZXItdmFsdWU9XCIke3ZhbHVlfVwiPlxuICAgICAgICAgIDxzcGFuPiR7Y29sLmRpc3BsYXlWYWx1ZXMgPyBjb2wuZGlzcGxheVZhbHVlc1tpbmRleF0gOiB2YWx1ZX08L3NwYW4+XG4gICAgICAgIDwvZGl2PlxuICAgICAgYCkuam9pbignJyk7XG4gICAgICBjb2x1bW5IdG1sID0gYFxuICAgICAgICA8ZGl2IGNsYXNzPVwiJHtjb2xDbGFzc2VzfVwiPlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJwaWNrZXItaXRlbXNcIj4ke2NvbHVtbkl0ZW1zSHRtbH08L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICBgO1xuICAgIH1cblxuICAgIHJldHVybiBvbmx5SXRlbXMgPyBjb2x1bW5JdGVtc0h0bWwudHJpbSgpIDogY29sdW1uSHRtbC50cmltKCk7XG4gIH1cbiAgcmVuZGVySW5saW5lKCkge1xuICAgIGNvbnN0IHBpY2tlciA9IHRoaXM7XG4gICAgY29uc3QgeyByb3RhdGVFZmZlY3QsIGNzc0NsYXNzLCB0b29sYmFyIH0gPSBwaWNrZXIucGFyYW1zO1xuICAgIGNvbnN0IGlubGluZUh0bWwgPSBgXG4gICAgICA8ZGl2IGNsYXNzPVwicGlja2VyIHBpY2tlci1pbmxpbmUgJHtyb3RhdGVFZmZlY3QgPyAncGlja2VyLTNkJyA6ICcnfSAke2Nzc0NsYXNzIHx8ICcnfVwiPlxuICAgICAgICAke3Rvb2xiYXIgPyBwaWNrZXIucmVuZGVyVG9vbGJhcigpIDogJyd9XG4gICAgICAgIDxkaXYgY2xhc3M9XCJwaWNrZXItY29sdW1uc1wiPlxuICAgICAgICAgICR7cGlja2VyLmNvbHMubWFwKGNvbCA9PiBwaWNrZXIucmVuZGVyQ29sdW1uKGNvbCkpLmpvaW4oJycpfVxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJwaWNrZXItY2VudGVyLWhpZ2hsaWdodFwiPjwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIGAudHJpbSgpO1xuXG4gICAgcmV0dXJuIGlubGluZUh0bWw7XG4gIH1cbiAgcmVuZGVyU2hlZXQoKSB7XG4gICAgY29uc3QgcGlja2VyID0gdGhpcztcbiAgICBjb25zdCB7IHJvdGF0ZUVmZmVjdCwgY3NzQ2xhc3MsIHRvb2xiYXIgfSA9IHBpY2tlci5wYXJhbXM7XG4gICAgY29uc3Qgc2hlZXRIdG1sID0gYFxuICAgICAgPGRpdiBjbGFzcz1cInNoZWV0LW1vZGFsIHBpY2tlciBwaWNrZXItc2hlZXQgJHtyb3RhdGVFZmZlY3QgPyAncGlja2VyLTNkJyA6ICcnfSAke2Nzc0NsYXNzIHx8ICcnfVwiPlxuICAgICAgICAke3Rvb2xiYXIgPyBwaWNrZXIucmVuZGVyVG9vbGJhcigpIDogJyd9XG4gICAgICAgIDxkaXYgY2xhc3M9XCJzaGVldC1tb2RhbC1pbm5lciBwaWNrZXItY29sdW1uc1wiPlxuICAgICAgICAgICR7cGlja2VyLmNvbHMubWFwKGNvbCA9PiBwaWNrZXIucmVuZGVyQ29sdW1uKGNvbCkpLmpvaW4oJycpfVxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJwaWNrZXItY2VudGVyLWhpZ2hsaWdodFwiPjwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIGAudHJpbSgpO1xuXG4gICAgcmV0dXJuIHNoZWV0SHRtbDtcbiAgfVxuICByZW5kZXJQb3BvdmVyKCkge1xuICAgIGNvbnN0IHBpY2tlciA9IHRoaXM7XG4gICAgY29uc3QgeyByb3RhdGVFZmZlY3QsIGNzc0NsYXNzLCB0b29sYmFyIH0gPSBwaWNrZXIucGFyYW1zO1xuICAgIGNvbnN0IHBvcG92ZXJIdG1sID0gYFxuICAgICAgPGRpdiBjbGFzcz1cInBvcG92ZXIgcGlja2VyLXBvcG92ZXJcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cInBvcG92ZXItaW5uZXJcIj5cbiAgICAgICAgICA8ZGl2IGNsYXNzPVwicGlja2VyICR7cm90YXRlRWZmZWN0ID8gJ3BpY2tlci0zZCcgOiAnJ30gJHtjc3NDbGFzcyB8fCAnJ31cIj5cbiAgICAgICAgICAgICR7dG9vbGJhciA/IHBpY2tlci5yZW5kZXJUb29sYmFyKCkgOiAnJ31cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJwaWNrZXItY29sdW1uc1wiPlxuICAgICAgICAgICAgICAke3BpY2tlci5jb2xzLm1hcChjb2wgPT4gcGlja2VyLnJlbmRlckNvbHVtbihjb2wpKS5qb2luKCcnKX1cbiAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInBpY2tlci1jZW50ZXItaGlnaGxpZ2h0XCI+PC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICBgLnRyaW0oKTtcblxuICAgIHJldHVybiBwb3BvdmVySHRtbDtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgcGlja2VyID0gdGhpcztcbiAgICBpZiAocGlja2VyLnBhcmFtcy5yZW5kZXIpIHJldHVybiBwaWNrZXIucGFyYW1zLnJlbmRlci5jYWxsKHBpY2tlcik7XG4gICAgaWYgKCFwaWNrZXIuaW5saW5lKSB7XG4gICAgICBpZiAocGlja2VyLmlzUG9wb3ZlcigpKSByZXR1cm4gcGlja2VyLnJlbmRlclBvcG92ZXIoKTtcbiAgICAgIHJldHVybiBwaWNrZXIucmVuZGVyU2hlZXQoKTtcbiAgICB9XG4gICAgcmV0dXJuIHBpY2tlci5yZW5kZXJJbmxpbmUoKTtcbiAgfVxuICBvbk9wZW4oKSB7XG4gICAgY29uc3QgcGlja2VyID0gdGhpcztcbiAgICBjb25zdCB7IGluaXRpYWxpemVkLCAkZWwsIGFwcCwgJGlucHV0RWwsIGlubGluZSwgdmFsdWUsIHBhcmFtcyB9ID0gcGlja2VyO1xuICAgIHBpY2tlci5vcGVuZWQgPSB0cnVlO1xuXG4gICAgLy8gSW5pdCBtYWluIGV2ZW50c1xuICAgIHBpY2tlci5hdHRhY2hSZXNpemVFdmVudCgpO1xuXG4gICAgLy8gSW5pdCBjb2xzXG4gICAgJGVsLmZpbmQoJy5waWNrZXItY29sdW1uJykuZWFjaCgoaW5kZXgsIGNvbEVsKSA9PiB7XG4gICAgICBsZXQgdXBkYXRlSXRlbXMgPSB0cnVlO1xuICAgICAgaWYgKFxuICAgICAgICAoIWluaXRpYWxpemVkICYmIHBhcmFtcy52YWx1ZSkgfHxcbiAgICAgICAgKGluaXRpYWxpemVkICYmIHZhbHVlKVxuICAgICAgKSB7XG4gICAgICAgIHVwZGF0ZUl0ZW1zID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBwaWNrZXIuaW5pdENvbHVtbihjb2xFbCwgdXBkYXRlSXRlbXMpO1xuICAgIH0pO1xuXG4gICAgLy8gU2V0IHZhbHVlXG4gICAgaWYgKCFpbml0aWFsaXplZCkge1xuICAgICAgaWYgKHZhbHVlKSBwaWNrZXIuc2V0VmFsdWUodmFsdWUsIDApO1xuICAgICAgZWxzZSBpZiAocGFyYW1zLnZhbHVlKSB7XG4gICAgICAgIHBpY2tlci5zZXRWYWx1ZShwYXJhbXMudmFsdWUsIDApO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodmFsdWUpIHtcbiAgICAgIHBpY2tlci5zZXRWYWx1ZSh2YWx1ZSwgMCk7XG4gICAgfVxuXG4gICAgLy8gRXh0cmEgZm9jdXNcbiAgICBpZiAoIWlubGluZSAmJiAkaW5wdXRFbC5sZW5ndGggJiYgYXBwLnRoZW1lID09PSAnbWQnKSB7XG4gICAgICAkaW5wdXRFbC50cmlnZ2VyKCdmb2N1cycpO1xuICAgIH1cblxuICAgIHBpY2tlci5pbml0aWFsaXplZCA9IHRydWU7XG5cbiAgICAvLyBUcmlnZ2VyIGV2ZW50c1xuICAgIGlmICgkZWwpIHtcbiAgICAgICRlbC50cmlnZ2VyKCdwaWNrZXI6b3BlbicsIHBpY2tlcik7XG4gICAgfVxuICAgIGlmICgkaW5wdXRFbCkge1xuICAgICAgJGlucHV0RWwudHJpZ2dlcigncGlja2VyOm9wZW4nLCBwaWNrZXIpO1xuICAgIH1cbiAgICBwaWNrZXIuZW1pdCgnbG9jYWw6Om9wZW4gcGlja2VyT3BlbicsIHBpY2tlcik7XG4gIH1cbiAgb25PcGVuZWQoKSB7XG4gICAgY29uc3QgcGlja2VyID0gdGhpcztcblxuICAgIGlmIChwaWNrZXIuJGVsKSB7XG4gICAgICBwaWNrZXIuJGVsLnRyaWdnZXIoJ3BpY2tlcjpvcGVuZWQnLCBwaWNrZXIpO1xuICAgIH1cbiAgICBpZiAocGlja2VyLiRpbnB1dEVsKSB7XG4gICAgICBwaWNrZXIuJGlucHV0RWwudHJpZ2dlcigncGlja2VyOm9wZW5lZCcsIHBpY2tlcik7XG4gICAgfVxuICAgIHBpY2tlci5lbWl0KCdsb2NhbDo6b3BlbmVkIHBpY2tlck9wZW5lZCcsIHBpY2tlcik7XG4gIH1cbiAgb25DbG9zZSgpIHtcbiAgICBjb25zdCBwaWNrZXIgPSB0aGlzO1xuICAgIGNvbnN0IGFwcCA9IHBpY2tlci5hcHA7XG5cbiAgICAvLyBEZXRhY2ggZXZlbnRzXG4gICAgcGlja2VyLmRldGFjaFJlc2l6ZUV2ZW50KCk7XG5cbiAgICBwaWNrZXIuY29scy5mb3JFYWNoKChjb2wpID0+IHtcbiAgICAgIGlmIChjb2wuZGVzdHJveSkgY29sLmRlc3Ryb3koKTtcbiAgICB9KTtcbiAgICBpZiAocGlja2VyLiRpbnB1dEVsICYmIGFwcC50aGVtZSA9PT0gJ21kJykge1xuICAgICAgcGlja2VyLiRpbnB1dEVsLnRyaWdnZXIoJ2JsdXInKTtcbiAgICB9XG5cbiAgICBpZiAocGlja2VyLiRlbCkge1xuICAgICAgcGlja2VyLiRlbC50cmlnZ2VyKCdwaWNrZXI6Y2xvc2UnLCBwaWNrZXIpO1xuICAgIH1cbiAgICBpZiAocGlja2VyLiRpbnB1dEVsKSB7XG4gICAgICBwaWNrZXIuJGlucHV0RWwudHJpZ2dlcigncGlja2VyOmNsb3NlJywgcGlja2VyKTtcbiAgICB9XG4gICAgcGlja2VyLmVtaXQoJ2xvY2FsOjpjbG9zZSBwaWNrZXJDbG9zZScsIHBpY2tlcik7XG4gIH1cbiAgb25DbG9zZWQoKSB7XG4gICAgY29uc3QgcGlja2VyID0gdGhpcztcbiAgICBwaWNrZXIub3BlbmVkID0gZmFsc2U7XG5cbiAgICBpZiAoIXBpY2tlci5pbmxpbmUpIHtcbiAgICAgIFV0aWxzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgaWYgKHBpY2tlci5tb2RhbCAmJiBwaWNrZXIubW9kYWwuZWwgJiYgcGlja2VyLm1vZGFsLmRlc3Ryb3kpIHtcbiAgICAgICAgICBpZiAoIXBpY2tlci5wYXJhbXMucm91dGFibGVNb2RhbHMpIHtcbiAgICAgICAgICAgIHBpY2tlci5tb2RhbC5kZXN0cm95KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSBwaWNrZXIubW9kYWw7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAocGlja2VyLiRlbCkge1xuICAgICAgcGlja2VyLiRlbC50cmlnZ2VyKCdwaWNrZXI6Y2xvc2VkJywgcGlja2VyKTtcbiAgICB9XG4gICAgaWYgKHBpY2tlci4kaW5wdXRFbCkge1xuICAgICAgcGlja2VyLiRpbnB1dEVsLnRyaWdnZXIoJ3BpY2tlcjpjbG9zZWQnLCBwaWNrZXIpO1xuICAgIH1cbiAgICBwaWNrZXIuZW1pdCgnbG9jYWw6OmNsb3NlZCBwaWNrZXJDbG9zZWQnLCBwaWNrZXIpO1xuICB9XG4gIG9wZW4oKSB7XG4gICAgY29uc3QgcGlja2VyID0gdGhpcztcbiAgICBjb25zdCB7IGFwcCwgb3BlbmVkLCBpbmxpbmUsICRpbnB1dEVsIH0gPSBwaWNrZXI7XG4gICAgaWYgKG9wZW5lZCkgcmV0dXJuO1xuICAgIGlmIChwaWNrZXIuY29scy5sZW5ndGggPT09IDAgJiYgcGlja2VyLnBhcmFtcy5jb2xzLmxlbmd0aCkge1xuICAgICAgcGlja2VyLnBhcmFtcy5jb2xzLmZvckVhY2goKGNvbCkgPT4ge1xuICAgICAgICBwaWNrZXIuY29scy5wdXNoKGNvbCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGlubGluZSkge1xuICAgICAgcGlja2VyLiRlbCA9ICQocGlja2VyLnJlbmRlcigpKTtcbiAgICAgIHBpY2tlci4kZWxbMF0uZjdQaWNrZXIgPSBwaWNrZXI7XG4gICAgICBwaWNrZXIuJGNvbnRhaW5lckVsLmFwcGVuZChwaWNrZXIuJGVsKTtcbiAgICAgIHBpY2tlci5vbk9wZW4oKTtcbiAgICAgIHBpY2tlci5vbk9wZW5lZCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpc1BvcG92ZXIgPSBwaWNrZXIuaXNQb3BvdmVyKCk7XG4gICAgY29uc3QgbW9kYWxUeXBlID0gaXNQb3BvdmVyID8gJ3BvcG92ZXInIDogJ3NoZWV0JztcbiAgICBjb25zdCBtb2RhbFBhcmFtcyA9IHtcbiAgICAgIHRhcmdldEVsOiAkaW5wdXRFbCxcbiAgICAgIHNjcm9sbFRvRWw6IHBpY2tlci5wYXJhbXMuc2Nyb2xsVG9JbnB1dCA/ICRpbnB1dEVsIDogdW5kZWZpbmVkLFxuICAgICAgY29udGVudDogcGlja2VyLnJlbmRlcigpLFxuICAgICAgYmFja2Ryb3A6IGlzUG9wb3ZlcixcbiAgICAgIG9uOiB7XG4gICAgICAgIG9wZW4oKSB7XG4gICAgICAgICAgY29uc3QgbW9kYWwgPSB0aGlzO1xuICAgICAgICAgIHBpY2tlci5tb2RhbCA9IG1vZGFsO1xuICAgICAgICAgIHBpY2tlci4kZWwgPSBpc1BvcG92ZXIgPyBtb2RhbC4kZWwuZmluZCgnLnBpY2tlcicpIDogbW9kYWwuJGVsO1xuICAgICAgICAgIHBpY2tlci4kZWxbMF0uZjdQaWNrZXIgPSBwaWNrZXI7XG4gICAgICAgICAgcGlja2VyLm9uT3BlbigpO1xuICAgICAgICB9LFxuICAgICAgICBvcGVuZWQoKSB7IHBpY2tlci5vbk9wZW5lZCgpOyB9LFxuICAgICAgICBjbG9zZSgpIHsgcGlja2VyLm9uQ2xvc2UoKTsgfSxcbiAgICAgICAgY2xvc2VkKCkgeyBwaWNrZXIub25DbG9zZWQoKTsgfSxcbiAgICAgIH0sXG4gICAgfTtcbiAgICBpZiAocGlja2VyLnBhcmFtcy5yb3V0YWJsZU1vZGFscykge1xuICAgICAgcGlja2VyLnZpZXcucm91dGVyLm5hdmlnYXRlKHtcbiAgICAgICAgdXJsOiBwaWNrZXIudXJsLFxuICAgICAgICByb3V0ZToge1xuICAgICAgICAgIHBhdGg6IHBpY2tlci51cmwsXG4gICAgICAgICAgW21vZGFsVHlwZV06IG1vZGFsUGFyYW1zLFxuICAgICAgICB9LFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBpY2tlci5tb2RhbCA9IGFwcFttb2RhbFR5cGVdLmNyZWF0ZShtb2RhbFBhcmFtcyk7XG4gICAgICBwaWNrZXIubW9kYWwub3BlbigpO1xuICAgIH1cbiAgfVxuICBjbG9zZSgpIHtcbiAgICBjb25zdCBwaWNrZXIgPSB0aGlzO1xuICAgIGNvbnN0IHsgb3BlbmVkLCBpbmxpbmUgfSA9IHBpY2tlcjtcbiAgICBpZiAoIW9wZW5lZCkgcmV0dXJuO1xuICAgIGlmIChpbmxpbmUpIHtcbiAgICAgIHBpY2tlci5vbkNsb3NlKCk7XG4gICAgICBwaWNrZXIub25DbG9zZWQoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHBpY2tlci5wYXJhbXMucm91dGFibGVNb2RhbHMpIHtcbiAgICAgIHBpY2tlci52aWV3LnJvdXRlci5iYWNrKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBpY2tlci5tb2RhbC5jbG9zZSgpO1xuICAgIH1cbiAgfVxuICBpbml0KCkge1xuICAgIGNvbnN0IHBpY2tlciA9IHRoaXM7XG5cbiAgICBwaWNrZXIuaW5pdElucHV0KCk7XG5cbiAgICBpZiAocGlja2VyLmlubGluZSkge1xuICAgICAgcGlja2VyLm9wZW4oKTtcbiAgICAgIHBpY2tlci5lbWl0KCdsb2NhbDo6aW5pdCBwaWNrZXJJbml0JywgcGlja2VyKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIXBpY2tlci5pbml0aWFsaXplZCAmJiBwaWNrZXIucGFyYW1zLnZhbHVlKSB7XG4gICAgICBwaWNrZXIuc2V0VmFsdWUocGlja2VyLnBhcmFtcy52YWx1ZSk7XG4gICAgfVxuXG4gICAgLy8gQXR0YWNoIGlucHV0IEV2ZW50c1xuICAgIGlmIChwaWNrZXIuJGlucHV0RWwpIHtcbiAgICAgIHBpY2tlci5hdHRhY2hJbnB1dEV2ZW50cygpO1xuICAgIH1cbiAgICBpZiAocGlja2VyLnBhcmFtcy5jbG9zZUJ5T3V0c2lkZUNsaWNrKSB7XG4gICAgICBwaWNrZXIuYXR0YWNoSHRtbEV2ZW50cygpO1xuICAgIH1cbiAgICBwaWNrZXIuZW1pdCgnbG9jYWw6OmluaXQgcGlja2VySW5pdCcsIHBpY2tlcik7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICBjb25zdCBwaWNrZXIgPSB0aGlzO1xuICAgIGlmIChwaWNrZXIuZGVzdHJveWVkKSByZXR1cm47XG4gICAgY29uc3QgeyAkZWwgfSA9IHBpY2tlcjtcbiAgICBwaWNrZXIuZW1pdCgnbG9jYWw6OmJlZm9yZURlc3Ryb3kgcGlja2VyQmVmb3JlRGVzdHJveScsIHBpY2tlcik7XG4gICAgaWYgKCRlbCkgJGVsLnRyaWdnZXIoJ3BpY2tlcjpiZWZvcmVkZXN0cm95JywgcGlja2VyKTtcblxuICAgIHBpY2tlci5jbG9zZSgpO1xuXG4gICAgLy8gRGV0YWNoIEV2ZW50c1xuICAgIGlmIChwaWNrZXIuJGlucHV0RWwpIHtcbiAgICAgIHBpY2tlci5kZXRhY2hJbnB1dEV2ZW50cygpO1xuICAgIH1cbiAgICBpZiAocGlja2VyLnBhcmFtcy5jbG9zZUJ5T3V0c2lkZUNsaWNrKSB7XG4gICAgICBwaWNrZXIuZGV0YWNoSHRtbEV2ZW50cygpO1xuICAgIH1cblxuICAgIGlmICgkZWwgJiYgJGVsLmxlbmd0aCkgZGVsZXRlIHBpY2tlci4kZWxbMF0uZjdQaWNrZXI7XG4gICAgVXRpbHMuZGVsZXRlUHJvcHMocGlja2VyKTtcbiAgICBwaWNrZXIuZGVzdHJveWVkID0gdHJ1ZTtcbiAgfVxufVxuXG52YXIgUGlja2VyJDEgPSB7XG4gIG5hbWU6ICdwaWNrZXInLFxuICBzdGF0aWM6IHtcbiAgICBQaWNrZXIsXG4gIH0sXG4gIGNyZWF0ZSgpIHtcbiAgICBjb25zdCBhcHAgPSB0aGlzO1xuICAgIGFwcC5waWNrZXIgPSBDb25zdHJ1Y3Rvck1ldGhvZHMoe1xuICAgICAgZGVmYXVsdFNlbGVjdG9yOiAnLnBpY2tlcicsXG4gICAgICBjb25zdHJ1Y3RvcjogUGlja2VyLFxuICAgICAgYXBwLFxuICAgICAgZG9tUHJvcDogJ2Y3UGlja2VyJyxcbiAgICB9KTtcbiAgICBhcHAucGlja2VyLmNsb3NlID0gZnVuY3Rpb24gY2xvc2UoZWwgPSAnLnBpY2tlcicpIHtcbiAgICAgIGNvbnN0ICRlbCA9ICQoZWwpO1xuICAgICAgaWYgKCRlbC5sZW5ndGggPT09IDApIHJldHVybjtcbiAgICAgIGNvbnN0IHBpY2tlciA9ICRlbFswXS5mN1BpY2tlcjtcbiAgICAgIGlmICghcGlja2VyIHx8IChwaWNrZXIgJiYgIXBpY2tlci5vcGVuZWQpKSByZXR1cm47XG4gICAgICBwaWNrZXIuY2xvc2UoKTtcbiAgICB9O1xuICB9LFxuICBwYXJhbXM6IHtcbiAgICBwaWNrZXI6IHtcbiAgICAgIC8vIFBpY2tlciBzZXR0aW5nc1xuICAgICAgdXBkYXRlVmFsdWVzT25Nb21lbnR1bTogZmFsc2UsXG4gICAgICB1cGRhdGVWYWx1ZXNPblRvdWNobW92ZTogdHJ1ZSxcbiAgICAgIHJvdGF0ZUVmZmVjdDogZmFsc2UsXG4gICAgICBtb21lbnR1bVJhdGlvOiA3LFxuICAgICAgZnJlZU1vZGU6IGZhbHNlLFxuICAgICAgY29sczogW10sXG4gICAgICAvLyBDb21tb24gb3BlbmVyIHNldHRpbmdzXG4gICAgICBjb250YWluZXJFbDogbnVsbCxcbiAgICAgIG9wZW5JbjogJ2F1dG8nLCAvLyBvciAncG9wb3Zlcicgb3IgJ3NoZWV0J1xuICAgICAgZm9ybWF0VmFsdWU6IG51bGwsXG4gICAgICBpbnB1dEVsOiBudWxsLFxuICAgICAgaW5wdXRSZWFkT25seTogdHJ1ZSxcbiAgICAgIGNsb3NlQnlPdXRzaWRlQ2xpY2s6IHRydWUsXG4gICAgICBzY3JvbGxUb0lucHV0OiB0cnVlLFxuICAgICAgdG9vbGJhcjogdHJ1ZSxcbiAgICAgIHRvb2xiYXJDbG9zZVRleHQ6ICdEb25lJyxcbiAgICAgIGNzc0NsYXNzOiBudWxsLFxuICAgICAgcm91dGFibGVNb2RhbHM6IHRydWUsXG4gICAgICB2aWV3OiBudWxsLFxuICAgICAgdXJsOiAnc2VsZWN0LycsXG4gICAgICAvLyBSZW5kZXIgZnVuY3Rpb25zXG4gICAgICByZW5kZXJUb29sYmFyOiBudWxsLFxuICAgICAgcmVuZGVyOiBudWxsLFxuICAgIH0sXG4gIH0sXG59O1xuXG5jb25zdCBJbmZpbml0ZVNjcm9sbCA9IHtcbiAgaGFuZGxlU2Nyb2xsKGVsLCBlKSB7XG4gICAgY29uc3QgYXBwID0gdGhpcztcbiAgICBjb25zdCAkZWwgPSAkKGVsKTtcbiAgICBjb25zdCBzY3JvbGxUb3AgPSAkZWxbMF0uc2Nyb2xsVG9wO1xuICAgIGNvbnN0IHNjcm9sbEhlaWdodCA9ICRlbFswXS5zY3JvbGxIZWlnaHQ7XG4gICAgY29uc3QgaGVpZ2h0ID0gJGVsWzBdLm9mZnNldEhlaWdodDtcbiAgICBsZXQgZGlzdGFuY2UgPSAkZWxbMF0uZ2V0QXR0cmlidXRlKCdkYXRhLWluZmluaXRlLWRpc3RhbmNlJyk7XG5cbiAgICBjb25zdCB2aXJ0dWFsTGlzdENvbnRhaW5lciA9ICRlbC5maW5kKCcudmlydHVhbC1saXN0Jyk7XG4gICAgbGV0IHZpcnR1YWxMaXN0O1xuXG4gICAgY29uc3Qgb25Ub3AgPSAkZWwuaGFzQ2xhc3MoJ2luZmluaXRlLXNjcm9sbC10b3AnKTtcbiAgICBpZiAoIWRpc3RhbmNlKSBkaXN0YW5jZSA9IDUwO1xuICAgIGlmICh0eXBlb2YgZGlzdGFuY2UgPT09ICdzdHJpbmcnICYmIGRpc3RhbmNlLmluZGV4T2YoJyUnKSA+PSAwKSB7XG4gICAgICBkaXN0YW5jZSA9IChwYXJzZUludChkaXN0YW5jZSwgMTApIC8gMTAwKSAqIGhlaWdodDtcbiAgICB9XG4gICAgaWYgKGRpc3RhbmNlID4gaGVpZ2h0KSBkaXN0YW5jZSA9IGhlaWdodDtcbiAgICBpZiAob25Ub3ApIHtcbiAgICAgIGlmIChzY3JvbGxUb3AgPCBkaXN0YW5jZSkge1xuICAgICAgICAkZWwudHJpZ2dlcignaW5maW5pdGUnLCBlKTtcbiAgICAgICAgYXBwLmVtaXQoJ2luZmluaXRlJywgJGVsWzBdLCBlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHNjcm9sbFRvcCArIGhlaWdodCA+PSBzY3JvbGxIZWlnaHQgLSBkaXN0YW5jZSkge1xuICAgICAgaWYgKHZpcnR1YWxMaXN0Q29udGFpbmVyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmlydHVhbExpc3QgPSB2aXJ0dWFsTGlzdENvbnRhaW5lci5lcSgtMSlbMF0uZjdWaXJ0dWFsTGlzdDtcbiAgICAgICAgaWYgKHZpcnR1YWxMaXN0ICYmICF2aXJ0dWFsTGlzdC5yZWFjaEVuZCAmJiAhdmlydHVhbExpc3QucGFyYW1zLnVwZGF0YWJsZVNjcm9sbCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgJGVsLnRyaWdnZXIoJ2luZmluaXRlJywgZSk7XG4gICAgICBhcHAuZW1pdCgnaW5maW5pdGUnLCAkZWxbMF0sIGUpO1xuICAgIH1cbiAgfSxcbiAgY3JlYXRlKGVsKSB7XG4gICAgY29uc3QgJGVsID0gJChlbCk7XG4gICAgY29uc3QgYXBwID0gdGhpcztcbiAgICAkZWwub24oJ3Njcm9sbCcsIGZ1bmN0aW9uIGhhbmRsZShlKSB7XG4gICAgICBhcHAuaW5maW5pdGVTY3JvbGwuaGFuZGxlKHRoaXMsIGUpO1xuICAgIH0pO1xuICB9LFxuICBkZXN0cm95KGVsKSB7XG4gICAgY29uc3QgJGVsID0gJChlbCk7XG4gICAgJGVsLm9mZignc2Nyb2xsJyk7XG4gIH0sXG59O1xudmFyIEluZmluaXRlU2Nyb2xsJDEgPSB7XG4gIG5hbWU6ICdpbmZpbml0ZVNjcm9sbCcsXG4gIGNyZWF0ZSgpIHtcbiAgICBjb25zdCBhcHAgPSB0aGlzO1xuICAgIFV0aWxzLmV4dGVuZChhcHAsIHtcbiAgICAgIGluZmluaXRlU2Nyb2xsOiB7XG4gICAgICAgIGhhbmRsZTogSW5maW5pdGVTY3JvbGwuaGFuZGxlU2Nyb2xsLmJpbmQoYXBwKSxcbiAgICAgICAgY3JlYXRlOiBJbmZpbml0ZVNjcm9sbC5jcmVhdGUuYmluZChhcHApLFxuICAgICAgICBkZXN0cm95OiBJbmZpbml0ZVNjcm9sbC5kZXN0cm95LmJpbmQoYXBwKSxcbiAgICAgIH0sXG4gICAgfSk7XG4gIH0sXG4gIG9uOiB7XG4gICAgdGFiTW91bnRlZCh0YWJFbCkge1xuICAgICAgY29uc3QgYXBwID0gdGhpcztcbiAgICAgIGNvbnN0ICR0YWJFbCA9ICQodGFiRWwpO1xuICAgICAgJHRhYkVsLmZpbmQoJy5pbmZpbml0ZS1zY3JvbGwtY29udGVudCcpLmVhY2goKGluZGV4LCBlbCkgPT4ge1xuICAgICAgICBhcHAuaW5maW5pdGVTY3JvbGwuY3JlYXRlKGVsKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgdGFiQmVmb3JlUmVtb3ZlKHRhYkVsKSB7XG4gICAgICBjb25zdCAkdGFiRWwgPSAkKHRhYkVsKTtcbiAgICAgIGNvbnN0IGFwcCA9IHRoaXM7XG4gICAgICAkdGFiRWwuZmluZCgnLmluZmluaXRlLXNjcm9sbC1jb250ZW50JykuZWFjaCgoaW5kZXgsIGVsKSA9PiB7XG4gICAgICAgIGFwcC5pbmZpbml0ZVNjcm9sbC5kZXN0cm95KGVsKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgcGFnZUluaXQocGFnZSkge1xuICAgICAgY29uc3QgYXBwID0gdGhpcztcbiAgICAgIHBhZ2UuJGVsLmZpbmQoJy5pbmZpbml0ZS1zY3JvbGwtY29udGVudCcpLmVhY2goKGluZGV4LCBlbCkgPT4ge1xuICAgICAgICBhcHAuaW5maW5pdGVTY3JvbGwuY3JlYXRlKGVsKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgcGFnZUJlZm9yZVJlbW92ZShwYWdlKSB7XG4gICAgICBjb25zdCBhcHAgPSB0aGlzO1xuICAgICAgcGFnZS4kZWwuZmluZCgnLmluZmluaXRlLXNjcm9sbC1jb250ZW50JykuZWFjaCgoaW5kZXgsIGVsKSA9PiB7XG4gICAgICAgIGFwcC5pbmZpbml0ZVNjcm9sbC5kZXN0cm95KGVsKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gIH0sXG59O1xuXG5jbGFzcyBQdWxsVG9SZWZyZXNoIGV4dGVuZHMgRnJhbWV3b3JrN0NsYXNzIHtcbiAgY29uc3RydWN0b3IoYXBwLCBlbCkge1xuICAgIHN1cGVyKHt9LCBbYXBwXSk7XG4gICAgY29uc3QgcHRyID0gdGhpcztcbiAgICBjb25zdCAkZWwgPSAkKGVsKTtcbiAgICBjb25zdCAkcHJlbG9hZGVyRWwgPSAkZWwuZmluZCgnLnB0ci1wcmVsb2FkZXInKTtcblxuICAgIHB0ci4kZWwgPSAkZWw7XG4gICAgcHRyLmVsID0gJGVsWzBdO1xuICAgIHB0ci5hcHAgPSBhcHA7XG5cbiAgICAvLyBFeHRlbmQgZGVmYXVsdHMgd2l0aCBtb2R1bGVzIHBhcmFtc1xuICAgIHB0ci51c2VNb2R1bGVzUGFyYW1zKHt9KTtcblxuICAgIGNvbnN0IGlzTWF0ZXJpYWwgPSBhcHAudGhlbWUgPT09ICdtZCc7XG5cbiAgICAvLyBEb25lXG4gICAgcHRyLmRvbmUgPSBmdW5jdGlvbiBkb25lKCkge1xuICAgICAgY29uc3QgJHRyYW5zaXRpb25UYXJnZXQgPSBpc01hdGVyaWFsID8gJHByZWxvYWRlckVsIDogJGVsO1xuICAgICAgJHRyYW5zaXRpb25UYXJnZXQudHJhbnNpdGlvbkVuZCgoKSA9PiB7XG4gICAgICAgICRlbC5yZW1vdmVDbGFzcygncHRyLXRyYW5zaXRpb25pbmcgcHRyLXB1bGwtdXAgcHRyLXB1bGwtZG93bicpO1xuICAgICAgICAkZWwudHJpZ2dlcigncHRyOmRvbmUnKTtcbiAgICAgICAgcHRyLmVtaXQoJ2xvY2FsOjpkb25lIHB0ckRvbmUnLCAkZWxbMF0pO1xuICAgICAgfSk7XG4gICAgICAkZWwucmVtb3ZlQ2xhc3MoJ3B0ci1yZWZyZXNoaW5nJykuYWRkQ2xhc3MoJ3B0ci10cmFuc2l0aW9uaW5nJyk7XG4gICAgICByZXR1cm4gcHRyO1xuICAgIH07XG5cbiAgICBwdHIucmVmcmVzaCA9IGZ1bmN0aW9uIHJlZnJlc2goKSB7XG4gICAgICBpZiAoJGVsLmhhc0NsYXNzKCdwdHItcmVmcmVzaGluZycpKSByZXR1cm4gcHRyO1xuICAgICAgJGVsLmFkZENsYXNzKCdwdHItdHJhbnNpdGlvbmluZyBwdHItcmVmcmVzaGluZycpO1xuICAgICAgJGVsLnRyaWdnZXIoJ3B0cjpyZWZyZXNoJywgcHRyLmRvbmUpO1xuICAgICAgcHRyLmVtaXQoJ2xvY2FsOjpyZWZyZXNoIHB0clJlZnJlc2gnLCAkZWxbMF0sIHB0ci5kb25lKTtcbiAgICAgIHJldHVybiBwdHI7XG4gICAgfTtcblxuICAgIC8vIEV2ZW50cyBoYW5kbGluZ1xuICAgIGxldCB0b3VjaElkO1xuICAgIGxldCBpc1RvdWNoZWQ7XG4gICAgbGV0IGlzTW92ZWQ7XG4gICAgY29uc3QgdG91Y2hlc1N0YXJ0ID0ge307XG4gICAgbGV0IGlzU2Nyb2xsaW5nO1xuICAgIGxldCB0b3VjaGVzRGlmZjtcbiAgICBsZXQgcmVmcmVzaCA9IGZhbHNlO1xuICAgIGxldCB1c2VUcmFuc2xhdGUgPSBmYWxzZTtcbiAgICBsZXQgc3RhcnRUcmFuc2xhdGUgPSAwO1xuICAgIGxldCB0cmFuc2xhdGU7XG4gICAgbGV0IHNjcm9sbFRvcDtcbiAgICBsZXQgd2FzU2Nyb2xsZWQ7XG4gICAgbGV0IHRyaWdnZXJEaXN0YW5jZTtcbiAgICBsZXQgZHluYW1pY1RyaWdnZXJEaXN0YW5jZTtcbiAgICBsZXQgcHVsbFN0YXJ0ZWQ7XG4gICAgbGV0IGhhc05hdmJhciA9IGZhbHNlO1xuICAgIGNvbnN0ICRwYWdlRWwgPSAkZWwucGFyZW50cygnLnBhZ2UnKTtcblxuICAgIGlmICgkcGFnZUVsLmZpbmQoJy5uYXZiYXInKS5sZW5ndGggPiAwIHx8ICRwYWdlRWwucGFyZW50cygnLnZpZXcnKS5jaGlsZHJlbignLm5hdmJhcicpLmxlbmd0aCA+IDApIGhhc05hdmJhciA9IHRydWU7XG4gICAgaWYgKCRwYWdlRWwuaGFzQ2xhc3MoJ25vLW5hdmJhcicpKSBoYXNOYXZiYXIgPSBmYWxzZTtcbiAgICBpZiAoIWhhc05hdmJhcikgJGVsLmFkZENsYXNzKCdwdHItbm8tbmF2YmFyJyk7XG5cbiAgICAvLyBEZWZpbmUgdHJpZ2dlciBkaXN0YW5jZVxuICAgIGlmICgkZWwuYXR0cignZGF0YS1wdHItZGlzdGFuY2UnKSkge1xuICAgICAgZHluYW1pY1RyaWdnZXJEaXN0YW5jZSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyaWdnZXJEaXN0YW5jZSA9IGlzTWF0ZXJpYWwgPyA2NiA6IDQ0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhbmRsZVRvdWNoU3RhcnQoZSkge1xuICAgICAgaWYgKGlzVG91Y2hlZCkge1xuICAgICAgICBpZiAoRGV2aWNlLm9zID09PSAnYW5kcm9pZCcpIHtcbiAgICAgICAgICBpZiAoJ3RhcmdldFRvdWNoZXMnIGluIGUgJiYgZS50YXJnZXRUb3VjaGVzLmxlbmd0aCA+IDEpIHJldHVybjtcbiAgICAgICAgfSBlbHNlIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCRlbC5oYXNDbGFzcygncHRyLXJlZnJlc2hpbmcnKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoJChlLnRhcmdldCkuY2xvc2VzdCgnLnNvcnRhYmxlLWhhbmRsZXInKS5sZW5ndGgpIHJldHVybjtcblxuICAgICAgaXNNb3ZlZCA9IGZhbHNlO1xuICAgICAgcHVsbFN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgIGlzVG91Y2hlZCA9IHRydWU7XG4gICAgICBpc1Njcm9sbGluZyA9IHVuZGVmaW5lZDtcbiAgICAgIHdhc1Njcm9sbGVkID0gdW5kZWZpbmVkO1xuICAgICAgaWYgKGUudHlwZSA9PT0gJ3RvdWNoc3RhcnQnKSB0b3VjaElkID0gZS50YXJnZXRUb3VjaGVzWzBdLmlkZW50aWZpZXI7XG4gICAgICB0b3VjaGVzU3RhcnQueCA9IGUudHlwZSA9PT0gJ3RvdWNoc3RhcnQnID8gZS50YXJnZXRUb3VjaGVzWzBdLnBhZ2VYIDogZS5wYWdlWDtcbiAgICAgIHRvdWNoZXNTdGFydC55ID0gZS50eXBlID09PSAndG91Y2hzdGFydCcgPyBlLnRhcmdldFRvdWNoZXNbMF0ucGFnZVkgOiBlLnBhZ2VZO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhbmRsZVRvdWNoTW92ZShlKSB7XG4gICAgICBpZiAoIWlzVG91Y2hlZCkgcmV0dXJuO1xuICAgICAgbGV0IHBhZ2VYO1xuICAgICAgbGV0IHBhZ2VZO1xuICAgICAgbGV0IHRvdWNoO1xuICAgICAgaWYgKGUudHlwZSA9PT0gJ3RvdWNobW92ZScpIHtcbiAgICAgICAgaWYgKHRvdWNoSWQgJiYgZS50b3VjaGVzKSB7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlLnRvdWNoZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGlmIChlLnRvdWNoZXNbaV0uaWRlbnRpZmllciA9PT0gdG91Y2hJZCkge1xuICAgICAgICAgICAgICB0b3VjaCA9IGUudG91Y2hlc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0b3VjaCkgdG91Y2ggPSBlLnRhcmdldFRvdWNoZXNbMF07XG4gICAgICAgIHBhZ2VYID0gdG91Y2gucGFnZVg7XG4gICAgICAgIHBhZ2VZID0gdG91Y2gucGFnZVk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYWdlWCA9IGUucGFnZVg7XG4gICAgICAgIHBhZ2VZID0gZS5wYWdlWTtcbiAgICAgIH1cbiAgICAgIGlmICghcGFnZVggfHwgIXBhZ2VZKSByZXR1cm47XG5cblxuICAgICAgaWYgKHR5cGVvZiBpc1Njcm9sbGluZyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgaXNTY3JvbGxpbmcgPSAhIShpc1Njcm9sbGluZyB8fCBNYXRoLmFicyhwYWdlWSAtIHRvdWNoZXNTdGFydC55KSA+IE1hdGguYWJzKHBhZ2VYIC0gdG91Y2hlc1N0YXJ0LngpKTtcbiAgICAgIH1cbiAgICAgIGlmICghaXNTY3JvbGxpbmcpIHtcbiAgICAgICAgaXNUb3VjaGVkID0gZmFsc2U7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgc2Nyb2xsVG9wID0gJGVsWzBdLnNjcm9sbFRvcDtcbiAgICAgIGlmICh0eXBlb2Ygd2FzU2Nyb2xsZWQgPT09ICd1bmRlZmluZWQnICYmIHNjcm9sbFRvcCAhPT0gMCkgd2FzU2Nyb2xsZWQgPSB0cnVlO1xuXG4gICAgICBpZiAoIWlzTW92ZWQpIHtcbiAgICAgICAgJGVsLnJlbW92ZUNsYXNzKCdwdHItdHJhbnNpdGlvbmluZycpO1xuICAgICAgICBpZiAoc2Nyb2xsVG9wID4gJGVsWzBdLm9mZnNldEhlaWdodCkge1xuICAgICAgICAgIGlzVG91Y2hlZCA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZHluYW1pY1RyaWdnZXJEaXN0YW5jZSkge1xuICAgICAgICAgIHRyaWdnZXJEaXN0YW5jZSA9ICRlbC5hdHRyKCdkYXRhLXB0ci1kaXN0YW5jZScpO1xuICAgICAgICAgIGlmICh0cmlnZ2VyRGlzdGFuY2UuaW5kZXhPZignJScpID49IDApIHRyaWdnZXJEaXN0YW5jZSA9ICgkZWxbMF0ub2Zmc2V0SGVpZ2h0ICogcGFyc2VJbnQodHJpZ2dlckRpc3RhbmNlLCAxMCkpIC8gMTAwO1xuICAgICAgICB9XG4gICAgICAgIHN0YXJ0VHJhbnNsYXRlID0gJGVsLmhhc0NsYXNzKCdwdHItcmVmcmVzaGluZycpID8gdHJpZ2dlckRpc3RhbmNlIDogMDtcbiAgICAgICAgaWYgKCRlbFswXS5zY3JvbGxIZWlnaHQgPT09ICRlbFswXS5vZmZzZXRIZWlnaHQgfHwgRGV2aWNlLm9zICE9PSAnaW9zJyB8fCBpc01hdGVyaWFsKSB7XG4gICAgICAgICAgdXNlVHJhbnNsYXRlID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB1c2VUcmFuc2xhdGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaXNNb3ZlZCA9IHRydWU7XG4gICAgICB0b3VjaGVzRGlmZiA9IHBhZ2VZIC0gdG91Y2hlc1N0YXJ0Lnk7XG5cbiAgICAgIGlmICgodG91Y2hlc0RpZmYgPiAwICYmIHNjcm9sbFRvcCA8PSAwKSB8fCBzY3JvbGxUb3AgPCAwKSB7XG4gICAgICAgIC8vIGlPUyA4IGZpeFxuICAgICAgICBpZiAoRGV2aWNlLm9zID09PSAnaW9zJyAmJiBwYXJzZUludChEZXZpY2Uub3NWZXJzaW9uLnNwbGl0KCcuJylbMF0sIDEwKSA+IDcgJiYgc2Nyb2xsVG9wID09PSAwICYmICF3YXNTY3JvbGxlZCkgdXNlVHJhbnNsYXRlID0gdHJ1ZTtcblxuICAgICAgICBpZiAodXNlVHJhbnNsYXRlKSB7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIHRyYW5zbGF0ZSA9ICh0b3VjaGVzRGlmZiAqKiAwLjg1KSArIHN0YXJ0VHJhbnNsYXRlO1xuICAgICAgICAgIGlmIChpc01hdGVyaWFsKSB7XG4gICAgICAgICAgICAkcHJlbG9hZGVyRWwudHJhbnNmb3JtKGB0cmFuc2xhdGUzZCgwLCR7dHJhbnNsYXRlfXB4LDApYClcbiAgICAgICAgICAgICAgLmZpbmQoJy5wdHItYXJyb3cnKS50cmFuc2Zvcm0oYHJvdGF0ZSgkeygxODAgKiAodG91Y2hlc0RpZmYgLyA2NikpICsgMTAwfWRlZylgKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJGVsLnRyYW5zZm9ybShgdHJhbnNsYXRlM2QoMCwke3RyYW5zbGF0ZX1weCwwKWApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoKHVzZVRyYW5zbGF0ZSAmJiAodG91Y2hlc0RpZmYgKiogMC44NSkgPiB0cmlnZ2VyRGlzdGFuY2UpIHx8ICghdXNlVHJhbnNsYXRlICYmIHRvdWNoZXNEaWZmID49IHRyaWdnZXJEaXN0YW5jZSAqIDIpKSB7XG4gICAgICAgICAgcmVmcmVzaCA9IHRydWU7XG4gICAgICAgICAgJGVsLmFkZENsYXNzKCdwdHItcHVsbC11cCcpLnJlbW92ZUNsYXNzKCdwdHItcHVsbC1kb3duJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVmcmVzaCA9IGZhbHNlO1xuICAgICAgICAgICRlbC5yZW1vdmVDbGFzcygncHRyLXB1bGwtdXAnKS5hZGRDbGFzcygncHRyLXB1bGwtZG93bicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcHVsbFN0YXJ0ZWQpIHtcbiAgICAgICAgICAkZWwudHJpZ2dlcigncHRyOnB1bGxzdGFydCcpO1xuICAgICAgICAgIHB0ci5lbWl0KCdsb2NhbDo6cHVsbFN0YXJ0IHB0clB1bGxTdGFydCcsICRlbFswXSk7XG4gICAgICAgICAgcHVsbFN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgICRlbC50cmlnZ2VyKCdwdHI6cHVsbG1vdmUnLCB7XG4gICAgICAgICAgZXZlbnQ6IGUsXG4gICAgICAgICAgc2Nyb2xsVG9wLFxuICAgICAgICAgIHRyYW5zbGF0ZSxcbiAgICAgICAgICB0b3VjaGVzRGlmZixcbiAgICAgICAgfSk7XG4gICAgICAgIHB0ci5lbWl0KCdsb2NhbDo6cHVsbE1vdmUgcHRyUHVsbE1vdmUnLCAkZWxbMF0sIHtcbiAgICAgICAgICBldmVudDogZSxcbiAgICAgICAgICBzY3JvbGxUb3AsXG4gICAgICAgICAgdHJhbnNsYXRlLFxuICAgICAgICAgIHRvdWNoZXNEaWZmLFxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHB1bGxTdGFydGVkID0gZmFsc2U7XG4gICAgICAgICRlbC5yZW1vdmVDbGFzcygncHRyLXB1bGwtdXAgcHRyLXB1bGwtZG93bicpO1xuICAgICAgICByZWZyZXNoID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhbmRsZVRvdWNoRW5kKGUpIHtcbiAgICAgIGlmIChlLnR5cGUgPT09ICd0b3VjaGVuZCcgJiYgZS5jaGFuZ2VkVG91Y2hlcyAmJiBlLmNoYW5nZWRUb3VjaGVzLmxlbmd0aCA+IDAgJiYgdG91Y2hJZCkge1xuICAgICAgICBpZiAoZS5jaGFuZ2VkVG91Y2hlc1swXS5pZGVudGlmaWVyICE9PSB0b3VjaElkKSB7XG4gICAgICAgICAgaXNUb3VjaGVkID0gZmFsc2U7XG4gICAgICAgICAgaXNTY3JvbGxpbmcgPSBmYWxzZTtcbiAgICAgICAgICBpc01vdmVkID0gZmFsc2U7XG4gICAgICAgICAgdG91Y2hJZCA9IG51bGw7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWlzVG91Y2hlZCB8fCAhaXNNb3ZlZCkge1xuICAgICAgICBpc1RvdWNoZWQgPSBmYWxzZTtcbiAgICAgICAgaXNNb3ZlZCA9IGZhbHNlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodHJhbnNsYXRlKSB7XG4gICAgICAgICRlbC5hZGRDbGFzcygncHRyLXRyYW5zaXRpb25pbmcnKTtcbiAgICAgICAgdHJhbnNsYXRlID0gMDtcbiAgICAgIH1cbiAgICAgIGlmIChpc01hdGVyaWFsKSB7XG4gICAgICAgICRwcmVsb2FkZXJFbC50cmFuc2Zvcm0oJycpXG4gICAgICAgICAgLmZpbmQoJy5wdHItYXJyb3cnKS50cmFuc2Zvcm0oJycpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJGVsLnRyYW5zZm9ybSgnJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWZyZXNoKSB7XG4gICAgICAgICRlbC5hZGRDbGFzcygncHRyLXJlZnJlc2hpbmcnKTtcbiAgICAgICAgJGVsLnRyaWdnZXIoJ3B0cjpyZWZyZXNoJywgcHRyLmRvbmUpO1xuICAgICAgICBwdHIuZW1pdCgnbG9jYWw6OnJlZnJlc2ggcHRyUmVmcmVzaCcsICRlbFswXSwgcHRyLmRvbmUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJGVsLnJlbW92ZUNsYXNzKCdwdHItcHVsbC1kb3duJyk7XG4gICAgICB9XG4gICAgICBpc1RvdWNoZWQgPSBmYWxzZTtcbiAgICAgIGlzTW92ZWQgPSBmYWxzZTtcbiAgICAgIGlmIChwdWxsU3RhcnRlZCkge1xuICAgICAgICAkZWwudHJpZ2dlcigncHRyOnB1bGxlbmQnKTtcbiAgICAgICAgcHRyLmVtaXQoJ2xvY2FsOjpwdWxsRW5kIHB0clB1bGxFbmQnLCAkZWxbMF0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghJHBhZ2VFbC5sZW5ndGggfHwgISRlbC5sZW5ndGgpIHJldHVybiBwdHI7XG5cbiAgICAkZWxbMF0uZjdQdWxsVG9SZWZyZXNoID0gcHRyO1xuXG4gICAgLy8gRXZlbnRzXG4gICAgcHRyLmF0dGFjaEV2ZW50cyA9IGZ1bmN0aW9uIGF0dGFjaEV2ZW50cygpIHtcbiAgICAgIGNvbnN0IHBhc3NpdmUgPSBTdXBwb3J0LnBhc3NpdmVMaXN0ZW5lciA/IHsgcGFzc2l2ZTogdHJ1ZSB9IDogZmFsc2U7XG4gICAgICAkZWwub24oYXBwLnRvdWNoRXZlbnRzLnN0YXJ0LCBoYW5kbGVUb3VjaFN0YXJ0LCBwYXNzaXZlKTtcbiAgICAgIGFwcC5vbigndG91Y2htb3ZlJywgaGFuZGxlVG91Y2hNb3ZlKTtcbiAgICAgIGFwcC5vbigndG91Y2hlbmQ6cGFzc2l2ZScsIGhhbmRsZVRvdWNoRW5kKTtcbiAgICB9O1xuICAgIHB0ci5kZXRhY2hFdmVudHMgPSBmdW5jdGlvbiBkZXRhY2hFdmVudHMoKSB7XG4gICAgICBjb25zdCBwYXNzaXZlID0gU3VwcG9ydC5wYXNzaXZlTGlzdGVuZXIgPyB7IHBhc3NpdmU6IHRydWUgfSA6IGZhbHNlO1xuICAgICAgJGVsLm9mZihhcHAudG91Y2hFdmVudHMuc3RhcnQsIGhhbmRsZVRvdWNoU3RhcnQsIHBhc3NpdmUpO1xuICAgICAgYXBwLm9mZigndG91Y2htb3ZlJywgaGFuZGxlVG91Y2hNb3ZlKTtcbiAgICAgIGFwcC5vZmYoJ3RvdWNoZW5kOnBhc3NpdmUnLCBoYW5kbGVUb3VjaEVuZCk7XG4gICAgfTtcblxuICAgIC8vIEluc3RhbGwgTW9kdWxlc1xuICAgIHB0ci51c2VNb2R1bGVzKCk7XG5cbiAgICAvLyBJbml0XG4gICAgcHRyLmluaXQoKTtcblxuICAgIHJldHVybiBwdHI7XG4gIH1cbiAgaW5pdCgpIHtcbiAgICBjb25zdCBwdHIgPSB0aGlzO1xuICAgIHB0ci5hdHRhY2hFdmVudHMoKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIGxldCBwdHIgPSB0aGlzO1xuICAgIHB0ci5lbWl0KCdsb2NhbDo6YmVmb3JlRGVzdHJveSBwdHJCZWZvcmVEZXN0cm95JywgcHRyKTtcbiAgICBwdHIuJGVsLnRyaWdnZXIoJ3B0cjpiZWZvcmVkZXN0cm95JywgcHRyKTtcbiAgICBkZWxldGUgcHRyLmVsLmY3UHVsbFRvUmVmcmVzaDtcbiAgICBwdHIuZGV0YWNoRXZlbnRzKCk7XG4gICAgVXRpbHMuZGVsZXRlUHJvcHMocHRyKTtcbiAgICBwdHIgPSBudWxsO1xuICB9XG59XG5cbnZhciBQdWxsVG9SZWZyZXNoJDEgPSB7XG4gIG5hbWU6ICdwdWxsVG9SZWZyZXNoJyxcbiAgY3JlYXRlKCkge1xuICAgIGNvbnN0IGFwcCA9IHRoaXM7XG4gICAgYXBwLnB0ciA9IFV0aWxzLmV4dGVuZChcbiAgICAgIENvbnN0cnVjdG9yTWV0aG9kcyh7XG4gICAgICAgIGRlZmF1bHRTZWxlY3RvcjogJy5wdHItY29udGVudCcsXG4gICAgICAgIGNvbnN0cnVjdG9yOiBQdWxsVG9SZWZyZXNoLFxuICAgICAgICBhcHAsXG4gICAgICAgIGRvbVByb3A6ICdmN1B1bGxUb1JlZnJlc2gnLFxuICAgICAgfSksXG4gICAgICB7XG4gICAgICAgIGRvbmUoZWwpIHtcbiAgICAgICAgICBjb25zdCBwdHIgPSBhcHAucHRyLmdldChlbCk7XG4gICAgICAgICAgaWYgKHB0cikgcmV0dXJuIHB0ci5kb25lKCk7XG4gICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfSxcbiAgICAgICAgcmVmcmVzaChlbCkge1xuICAgICAgICAgIGNvbnN0IHB0ciA9IGFwcC5wdHIuZ2V0KGVsKTtcbiAgICAgICAgICBpZiAocHRyKSByZXR1cm4gcHRyLnJlZnJlc2goKTtcbiAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9LFxuICAgICAgfVxuICAgICk7XG4gIH0sXG4gIHN0YXRpYzoge1xuICAgIFB1bGxUb1JlZnJlc2gsXG4gIH0sXG4gIG9uOiB7XG4gICAgdGFiTW91bnRlZCh0YWJFbCkge1xuICAgICAgY29uc3QgYXBwID0gdGhpcztcbiAgICAgIGNvbnN0ICR0YWJFbCA9ICQodGFiRWwpO1xuICAgICAgJHRhYkVsLmZpbmQoJy5wdHItY29udGVudCcpLmVhY2goKGluZGV4LCBlbCkgPT4ge1xuICAgICAgICBhcHAucHRyLmNyZWF0ZShlbCk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIHRhYkJlZm9yZVJlbW92ZSh0YWJFbCkge1xuICAgICAgY29uc3QgJHRhYkVsID0gJCh0YWJFbCk7XG4gICAgICBjb25zdCBhcHAgPSB0aGlzO1xuICAgICAgJHRhYkVsLmZpbmQoJy5wdHItY29udGVudCcpLmVhY2goKGluZGV4LCBlbCkgPT4ge1xuICAgICAgICBhcHAucHRyLmRlc3Ryb3koZWwpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBwYWdlSW5pdChwYWdlKSB7XG4gICAgICBjb25zdCBhcHAgPSB0aGlzO1xuICAgICAgcGFnZS4kZWwuZmluZCgnLnB0ci1jb250ZW50JykuZWFjaCgoaW5kZXgsIGVsKSA9PiB7XG4gICAgICAgIGFwcC5wdHIuY3JlYXRlKGVsKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgcGFnZUJlZm9yZVJlbW92ZShwYWdlKSB7XG4gICAgICBjb25zdCBhcHAgPSB0aGlzO1xuICAgICAgcGFnZS4kZWwuZmluZCgnLnB0ci1jb250ZW50JykuZWFjaCgoaW5kZXgsIGVsKSA9PiB7XG4gICAgICAgIGFwcC5wdHIuZGVzdHJveShlbCk7XG4gICAgICB9KTtcbiAgICB9LFxuICB9LFxufTtcblxuY29uc3QgTGF6eSA9IHtcbiAgZGVzdHJveShwYWdlRWwpIHtcbiAgICBjb25zdCAkcGFnZUVsID0gJChwYWdlRWwpLmNsb3Nlc3QoJy5wYWdlJyk7XG4gICAgaWYgKCEkcGFnZUVsLmxlbmd0aCkgcmV0dXJuO1xuICAgIGlmICgkcGFnZUVsWzBdLmY3TGF6eURlc3Ryb3kpIHtcbiAgICAgICRwYWdlRWxbMF0uZjdMYXp5RGVzdHJveSgpO1xuICAgIH1cbiAgfSxcbiAgY3JlYXRlKHBhZ2VFbCkge1xuICAgIGNvbnN0IGFwcCA9IHRoaXM7XG4gICAgY29uc3QgJHBhZ2VFbCA9ICQocGFnZUVsKS5jbG9zZXN0KCcucGFnZScpLmVxKDApO1xuXG4gICAgLy8gTGF6eSBpbWFnZXNcbiAgICBjb25zdCBsYXp5TG9hZEltYWdlcyA9ICRwYWdlRWwuZmluZCgnLmxhenknKTtcbiAgICBpZiAobGF6eUxvYWRJbWFnZXMubGVuZ3RoID09PSAwICYmICEkcGFnZUVsLmhhc0NsYXNzKCdsYXp5JykpIHJldHVybjtcblxuICAgIC8vIFBsYWNlaG9sZGVyXG4gICAgY29uc3QgcGxhY2Vob2xkZXJTcmMgPSBhcHAucGFyYW1zLmxhenkucGxhY2Vob2xkZXI7XG5cbiAgICBpZiAocGxhY2Vob2xkZXJTcmMgIT09IGZhbHNlKSB7XG4gICAgICBsYXp5TG9hZEltYWdlcy5lYWNoKChpbmRleCwgbGF6eUVsKSA9PiB7XG4gICAgICAgIGlmICgkKGxhenlFbCkuYXR0cignZGF0YS1zcmMnKSAmJiAhJChsYXp5RWwpLmF0dHIoJ3NyYycpKSAkKGxhenlFbCkuYXR0cignc3JjJywgcGxhY2Vob2xkZXJTcmMpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gbG9hZCBpbWFnZVxuICAgIGNvbnN0IGltYWdlc1NlcXVlbmNlID0gW107XG4gICAgbGV0IGltYWdlSXNMb2FkaW5nID0gZmFsc2U7XG5cbiAgICBmdW5jdGlvbiBvbkltYWdlQ29tcGxldGUobGF6eUVsKSB7XG4gICAgICBpZiAoaW1hZ2VzU2VxdWVuY2UuaW5kZXhPZihsYXp5RWwpID49IDApIHtcbiAgICAgICAgaW1hZ2VzU2VxdWVuY2Uuc3BsaWNlKGltYWdlc1NlcXVlbmNlLmluZGV4T2YobGF6eUVsKSwgMSk7XG4gICAgICB9XG4gICAgICBpbWFnZUlzTG9hZGluZyA9IGZhbHNlO1xuICAgICAgaWYgKGFwcC5wYXJhbXMubGF6eS5zZXF1ZW50aWFsICYmIGltYWdlc1NlcXVlbmNlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaW1hZ2VJc0xvYWRpbmcgPSB0cnVlO1xuICAgICAgICBhcHAubGF6eS5sb2FkSW1hZ2UoaW1hZ2VzU2VxdWVuY2VbMF0sIG9uSW1hZ2VDb21wbGV0ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGF6eUhhbmRsZXIoKSB7XG4gICAgICBhcHAubGF6eS5sb2FkKCRwYWdlRWwsIChsYXp5RWwpID0+IHtcbiAgICAgICAgaWYgKGFwcC5wYXJhbXMubGF6eS5zZXF1ZW50aWFsICYmIGltYWdlSXNMb2FkaW5nKSB7XG4gICAgICAgICAgaWYgKGltYWdlc1NlcXVlbmNlLmluZGV4T2YobGF6eUVsKSA8IDApIGltYWdlc1NlcXVlbmNlLnB1c2gobGF6eUVsKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaW1hZ2VJc0xvYWRpbmcgPSB0cnVlO1xuICAgICAgICBhcHAubGF6eS5sb2FkSW1hZ2UobGF6eUVsLCBvbkltYWdlQ29tcGxldGUpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXR0YWNoRXZlbnRzKCkge1xuICAgICAgJHBhZ2VFbFswXS5mN0xhenlBdHRhY2hlZCA9IHRydWU7XG4gICAgICAkcGFnZUVsLm9uKCdsYXp5JywgbGF6eUhhbmRsZXIpO1xuICAgICAgJHBhZ2VFbC5vbignc2Nyb2xsJywgbGF6eUhhbmRsZXIsIHRydWUpO1xuICAgICAgJHBhZ2VFbC5maW5kKCcudGFiJykub24oJ3RhYjptb3VudGVkIHRhYjpzaG93JywgbGF6eUhhbmRsZXIpO1xuICAgICAgYXBwLm9uKCdyZXNpemUnLCBsYXp5SGFuZGxlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRldGFjaEV2ZW50cygpIHtcbiAgICAgICRwYWdlRWxbMF0uZjdMYXp5QXR0YWNoZWQgPSBmYWxzZTtcbiAgICAgIGRlbGV0ZSAkcGFnZUVsWzBdLmY3TGF6eUF0dGFjaGVkO1xuICAgICAgJHBhZ2VFbC5vZmYoJ2xhenknLCBsYXp5SGFuZGxlcik7XG4gICAgICAkcGFnZUVsLm9mZignc2Nyb2xsJywgbGF6eUhhbmRsZXIsIHRydWUpO1xuICAgICAgJHBhZ2VFbC5maW5kKCcudGFiJykub2ZmKCd0YWI6bW91bnRlZCB0YWI6c2hvdycsIGxhenlIYW5kbGVyKTtcbiAgICAgIGFwcC5vZmYoJ3Jlc2l6ZScsIGxhenlIYW5kbGVyKTtcbiAgICB9XG5cbiAgICAvLyBTdG9yZSBkZXRhY2ggZnVuY3Rpb25cbiAgICBpZiAoISRwYWdlRWxbMF0uZjdMYXp5RGVzdHJveSkge1xuICAgICAgJHBhZ2VFbFswXS5mN0xhenlEZXN0cm95ID0gZGV0YWNoRXZlbnRzO1xuICAgIH1cblxuICAgIC8vIEF0dGFjaCBldmVudHNcbiAgICBpZiAoISRwYWdlRWxbMF0uZjdMYXp5QXR0YWNoZWQpIHtcbiAgICAgIGF0dGFjaEV2ZW50cygpO1xuICAgIH1cblxuICAgIC8vIFJ1biBsb2FkZXIgb24gcGFnZSBsb2FkL2luaXRcbiAgICBsYXp5SGFuZGxlcigpO1xuICB9LFxuICBpc0luVmlld3BvcnQobGF6eUVsKSB7XG4gICAgY29uc3QgYXBwID0gdGhpcztcbiAgICBjb25zdCByZWN0ID0gbGF6eUVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGNvbnN0IHRocmVzaG9sZCA9IGFwcC5wYXJhbXMubGF6eS50aHJlc2hvbGQgfHwgMDtcblxuICAgIHJldHVybiAoXG4gICAgICByZWN0LnRvcCA+PSAoMCAtIHRocmVzaG9sZCkgJiZcbiAgICAgIHJlY3QubGVmdCA+PSAoMCAtIHRocmVzaG9sZCkgJiZcbiAgICAgIHJlY3QudG9wIDw9IChhcHAuaGVpZ2h0ICsgdGhyZXNob2xkKSAmJlxuICAgICAgcmVjdC5sZWZ0IDw9IChhcHAud2lkdGggKyB0aHJlc2hvbGQpXG4gICAgKTtcbiAgfSxcbiAgbG9hZEltYWdlKGltYWdlRWwsIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgYXBwID0gdGhpcztcbiAgICBjb25zdCAkaW1hZ2VFbCA9ICQoaW1hZ2VFbCk7XG5cbiAgICBjb25zdCBiZyA9ICRpbWFnZUVsLmF0dHIoJ2RhdGEtYmFja2dyb3VuZCcpO1xuICAgIGNvbnN0IHNyYyA9IGJnIHx8ICRpbWFnZUVsLmF0dHIoJ2RhdGEtc3JjJyk7XG4gICAgaWYgKCFzcmMpIHJldHVybjtcbiAgICBmdW5jdGlvbiBvbkxvYWQoKSB7XG4gICAgICAkaW1hZ2VFbC5yZW1vdmVDbGFzcygnbGF6eScpLmFkZENsYXNzKCdsYXp5LWxvYWRlZCcpO1xuICAgICAgaWYgKGJnKSB7XG4gICAgICAgICRpbWFnZUVsLmNzcygnYmFja2dyb3VuZC1pbWFnZScsIGB1cmwoJHtzcmN9KWApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJGltYWdlRWwuYXR0cignc3JjJywgc3JjKTtcbiAgICAgIH1cbiAgICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2soaW1hZ2VFbCk7XG4gICAgICAkaW1hZ2VFbC50cmlnZ2VyKCdsYXp5OmxvYWRlZCcpO1xuICAgICAgYXBwLmVtaXQoJ2xhenlMb2FkZWQnLCAkaW1hZ2VFbFswXSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25FcnJvcigpIHtcbiAgICAgICRpbWFnZUVsLnJlbW92ZUNsYXNzKCdsYXp5JykuYWRkQ2xhc3MoJ2xhenktbG9hZGVkJyk7XG4gICAgICBpZiAoYmcpIHtcbiAgICAgICAgJGltYWdlRWwuY3NzKCdiYWNrZ3JvdW5kLWltYWdlJywgYHVybCgke2FwcC5wYXJhbXMubGF6eS5wbGFjZWhvbGRlciB8fCAnJ30pYCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAkaW1hZ2VFbC5hdHRyKCdzcmMnLCBhcHAucGFyYW1zLmxhenkucGxhY2Vob2xkZXIgfHwgJycpO1xuICAgICAgfVxuICAgICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjayhpbWFnZUVsKTtcbiAgICAgICRpbWFnZUVsLnRyaWdnZXIoJ2xhenk6ZXJyb3InKTtcbiAgICAgIGFwcC5lbWl0KCdsYXp5RXJyb3InLCAkaW1hZ2VFbFswXSk7XG4gICAgfVxuICAgIGNvbnN0IGltYWdlID0gbmV3IHdpbmRvdyQxLkltYWdlKCk7XG4gICAgaW1hZ2Uub25sb2FkID0gb25Mb2FkO1xuICAgIGltYWdlLm9uZXJyb3IgPSBvbkVycm9yO1xuICAgIGltYWdlLnNyYyA9IHNyYztcblxuICAgICRpbWFnZUVsLnJlbW92ZUF0dHIoJ2RhdGEtc3JjJykucmVtb3ZlQXR0cignZGF0YS1iYWNrZ3JvdW5kJyk7XG5cbiAgICAvLyBBZGQgbG9hZGVkIGNhbGxiYWNrIGFuZCBldmVudHNcbiAgICAkaW1hZ2VFbC50cmlnZ2VyKCdsYXp5OmxvYWQnKTtcbiAgICBhcHAuZW1pdCgnbGF6eUxvYWQnLCAkaW1hZ2VFbFswXSk7XG4gIH0sXG4gIGxvYWQocGFnZUVsLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IGFwcCA9IHRoaXM7XG4gICAgbGV0ICRwYWdlRWwgPSAkKHBhZ2VFbCk7XG4gICAgaWYgKCEkcGFnZUVsLmhhc0NsYXNzKCdwYWdlJykpICRwYWdlRWwgPSAkcGFnZUVsLnBhcmVudHMoJy5wYWdlJykuZXEoMCk7XG4gICAgaWYgKCRwYWdlRWwubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgICRwYWdlRWwuZmluZCgnLmxhenknKS5lYWNoKChpbmRleCwgbGF6eUVsKSA9PiB7XG4gICAgICBjb25zdCAkbGF6eUVsID0gJChsYXp5RWwpO1xuICAgICAgaWYgKCRsYXp5RWwucGFyZW50cygnLnRhYjpub3QoLnRhYi1hY3RpdmUpJykubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoYXBwLmxhenkuaXNJblZpZXdwb3J0KGxhenlFbCkpIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjayhsYXp5RWwpO1xuICAgICAgICBlbHNlIGFwcC5sYXp5LmxvYWRJbWFnZShsYXp5RWwpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG59O1xudmFyIExhenkkMSA9IHtcbiAgbmFtZTogJ2xhenknLFxuICBwYXJhbXM6IHtcbiAgICBsYXp5OiB7XG4gICAgICBwbGFjZWhvbGRlcjogJ2RhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQUVBQUFBQkFRTUFBQUFsMjFiS0FBQUFBMUJNVkVYQ3dzSzU5Mm1rQUFBQUNrbEVRVlFJMTJOZ0FBQUFBZ0FCNGlHOE13QUFBQUJKUlU1RXJrSmdnZz09JyxcbiAgICAgIHRocmVzaG9sZDogMCxcbiAgICAgIHNlcXVlbnRpYWw6IHRydWUsXG4gICAgfSxcbiAgfSxcbiAgY3JlYXRlKCkge1xuICAgIGNvbnN0IGFwcCA9IHRoaXM7XG4gICAgVXRpbHMuZXh0ZW5kKGFwcCwge1xuICAgICAgbGF6eToge1xuICAgICAgICBjcmVhdGU6IExhenkuY3JlYXRlLmJpbmQoYXBwKSxcbiAgICAgICAgZGVzdHJveTogTGF6eS5kZXN0cm95LmJpbmQoYXBwKSxcbiAgICAgICAgbG9hZEltYWdlOiBMYXp5LmxvYWRJbWFnZS5iaW5kKGFwcCksXG4gICAgICAgIGxvYWQ6IExhenkubG9hZC5iaW5kKGFwcCksXG4gICAgICAgIGlzSW5WaWV3cG9ydDogTGF6eS5pc0luVmlld3BvcnQuYmluZChhcHApLFxuICAgICAgfSxcbiAgICB9KTtcbiAgfSxcbiAgb246IHtcbiAgICBwYWdlSW5pdChwYWdlKSB7XG4gICAgICBjb25zdCBhcHAgPSB0aGlzO1xuICAgICAgaWYgKHBhZ2UuJGVsLmZpbmQoJy5sYXp5JykubGVuZ3RoID4gMCB8fCBwYWdlLiRlbC5oYXNDbGFzcygnbGF6eScpKSB7XG4gICAgICAgIGFwcC5sYXp5LmNyZWF0ZShwYWdlLiRlbCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBwYWdlQWZ0ZXJJbihwYWdlKSB7XG4gICAgICBjb25zdCBhcHAgPSB0aGlzO1xuICAgICAgaWYgKHBhZ2UuJGVsLmZpbmQoJy5sYXp5JykubGVuZ3RoID4gMCB8fCBwYWdlLiRlbC5oYXNDbGFzcygnbGF6eScpKSB7XG4gICAgICAgIGFwcC5sYXp5LmNyZWF0ZShwYWdlLiRlbCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBwYWdlQmVmb3JlUmVtb3ZlKHBhZ2UpIHtcbiAgICAgIGNvbnN0IGFwcCA9IHRoaXM7XG4gICAgICBpZiAocGFnZS4kZWwuZmluZCgnLmxhenknKS5sZW5ndGggPiAwIHx8IHBhZ2UuJGVsLmhhc0NsYXNzKCdsYXp5JykpIHtcbiAgICAgICAgYXBwLmxhenkuZGVzdHJveShwYWdlLiRlbCk7XG4gICAgICB9XG4gICAgfSxcbiAgICB0YWJNb3VudGVkKHRhYkVsKSB7XG4gICAgICBjb25zdCBhcHAgPSB0aGlzO1xuICAgICAgY29uc3QgJHRhYkVsID0gJCh0YWJFbCk7XG4gICAgICBpZiAoJHRhYkVsLmZpbmQoJy5sYXp5JykubGVuZ3RoID4gMCB8fCAkdGFiRWwuaGFzQ2xhc3MoJ2xhenknKSkge1xuICAgICAgICBhcHAubGF6eS5jcmVhdGUoJHRhYkVsKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHRhYkJlZm9yZVJlbW92ZSh0YWJFbCkge1xuICAgICAgY29uc3QgYXBwID0gdGhpcztcbiAgICAgIGNvbnN0ICR0YWJFbCA9ICQodGFiRWwpO1xuICAgICAgaWYgKCR0YWJFbC5maW5kKCcubGF6eScpLmxlbmd0aCA+IDAgfHwgJHRhYkVsLmhhc0NsYXNzKCdsYXp5JykpIHtcbiAgICAgICAgYXBwLmxhenkuZGVzdHJveSgkdGFiRWwpO1xuICAgICAgfVxuICAgIH0sXG4gIH0sXG59O1xuXG5jbGFzcyBEYXRhVGFibGUgZXh0ZW5kcyBGcmFtZXdvcms3Q2xhc3Mge1xuICBjb25zdHJ1Y3RvcihhcHAsIHBhcmFtcyA9IHt9KSB7XG4gICAgc3VwZXIocGFyYW1zLCBbYXBwXSk7XG5cbiAgICBjb25zdCB0YWJsZSA9IHRoaXM7XG5cbiAgICBjb25zdCBkZWZhdWx0cyA9IHtcblxuICAgIH07XG5cbiAgICAvLyBFeHRlbmQgZGVmYXVsdHMgd2l0aCBtb2R1bGVzIHBhcmFtc1xuICAgIHRhYmxlLnVzZU1vZHVsZXNQYXJhbXMoZGVmYXVsdHMpO1xuXG4gICAgdGFibGUucGFyYW1zID0gVXRpbHMuZXh0ZW5kKGRlZmF1bHRzLCBwYXJhbXMpO1xuXG4gICAgLy8gRWxcbiAgICBjb25zdCAkZWwgPSAkKHRhYmxlLnBhcmFtcy5lbCk7XG4gICAgaWYgKCRlbC5sZW5ndGggPT09IDApIHJldHVybiB1bmRlZmluZWQ7XG5cbiAgICB0YWJsZS4kZWwgPSAkZWw7XG4gICAgdGFibGUuZWwgPSAkZWxbMF07XG5cbiAgICBpZiAodGFibGUuJGVsWzBdLmY3RGF0YVRhYmxlKSB7XG4gICAgICBjb25zdCBpbnN0YW5jZSA9IHRhYmxlLiRlbFswXS5mN0RhdGFUYWJsZTtcbiAgICAgIHRhYmxlLmRlc3Ryb3koKTtcbiAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICB9XG5cbiAgICB0YWJsZS4kZWxbMF0uZjdEYXRhVGFibGUgPSB0YWJsZTtcblxuICAgIFV0aWxzLmV4dGVuZCh0YWJsZSwge1xuICAgICAgY29sbGFwc2libGU6ICRlbC5oYXNDbGFzcygnZGF0YS10YWJsZS1jb2xsYXBzaWJsZScpLFxuICAgICAgLy8gSGVhZGVyc1xuICAgICAgJGhlYWRlckVsOiAkZWwuZmluZCgnLmRhdGEtdGFibGUtaGVhZGVyJyksXG4gICAgICAkaGVhZGVyU2VsZWN0ZWRFbDogJGVsLmZpbmQoJy5kYXRhLXRhYmxlLWhlYWRlci1zZWxlY3RlZCcpLFxuICAgIH0pO1xuXG4gICAgLy8gRXZlbnRzXG4gICAgZnVuY3Rpb24gaGFuZGxlQ2hhbmdlKGUpIHtcbiAgICAgIGlmIChlLmRldGFpbCAmJiBlLmRldGFpbC5zZW50QnlGN0RhdGFUYWJsZSkge1xuICAgICAgICAvLyBTY3JpcHRlZCBldmVudCwgZG9uJ3QgZG8gYW55dGhpbmdcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgJGlucHV0RWwgPSAkKHRoaXMpO1xuICAgICAgY29uc3QgY2hlY2tlZCA9ICRpbnB1dEVsWzBdLmNoZWNrZWQ7XG4gICAgICBjb25zdCBjb2x1bW5JbmRleCA9ICRpbnB1dEVsLnBhcmVudHMoJ3RkLHRoJykuaW5kZXgoKTtcblxuICAgICAgaWYgKCRpbnB1dEVsLnBhcmVudHMoJ3RoZWFkJykubGVuZ3RoID4gMCkge1xuICAgICAgICBpZiAoY29sdW1uSW5kZXggPT09IDApIHtcbiAgICAgICAgICAkZWxcbiAgICAgICAgICAgIC5maW5kKCd0Ym9keSB0cicpW2NoZWNrZWQgPyAnYWRkQ2xhc3MnIDogJ3JlbW92ZUNsYXNzJ10oJ2RhdGEtdGFibGUtcm93LXNlbGVjdGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgJGVsXG4gICAgICAgICAgLmZpbmQoYHRib2R5IHRyIHRkOm50aC1jaGlsZCgke2NvbHVtbkluZGV4ICsgMX0pIGlucHV0YClcbiAgICAgICAgICAucHJvcCgnY2hlY2tlZCcsIGNoZWNrZWQpXG4gICAgICAgICAgLnRyaWdnZXIoJ2NoYW5nZScsIHsgc2VudEJ5RjdEYXRhVGFibGU6IHRydWUgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoY29sdW1uSW5kZXggPT09IDApIHtcbiAgICAgICAgICAkaW5wdXRFbC5wYXJlbnRzKCd0cicpW2NoZWNrZWQgPyAnYWRkQ2xhc3MnIDogJ3JlbW92ZUNsYXNzJ10oJ2RhdGEtdGFibGUtcm93LXNlbGVjdGVkJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWNoZWNrZWQpIHtcbiAgICAgICAgICAkZWwuZmluZChgdGhlYWQgLmNoZWNrYm94LWNlbGw6bnRoLWNoaWxkKCR7Y29sdW1uSW5kZXggKyAxfSkgaW5wdXRbdHlwZT1cImNoZWNrYm94XCJdYCkucHJvcCgnY2hlY2tlZCcsIGZhbHNlKTtcbiAgICAgICAgfSBlbHNlIGlmICgkZWwuZmluZChgdGJvZHkgLmNoZWNrYm94LWNlbGw6bnRoLWNoaWxkKCR7Y29sdW1uSW5kZXggKyAxfSkgaW5wdXRbdHlwZT1cImNoZWNrYm94XCJdOmNoZWNrZWRgKS5sZW5ndGggPT09ICRlbC5maW5kKCd0Ym9keSB0cicpLmxlbmd0aCkge1xuICAgICAgICAgICRlbC5maW5kKGB0aGVhZCAuY2hlY2tib3gtY2VsbDpudGgtY2hpbGQoJHtjb2x1bW5JbmRleCArIDF9KSBpbnB1dFt0eXBlPVwiY2hlY2tib3hcIl1gKS5wcm9wKCdjaGVja2VkJywgdHJ1ZSkudHJpZ2dlcignY2hhbmdlJywgeyBzZW50QnlGN0RhdGFUYWJsZTogdHJ1ZSB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGFibGUuY2hlY2tTZWxlY3RlZEhlYWRlcigpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoYW5kbGVTb3J0YWJsZUNsaWNrKCkge1xuICAgICAgY29uc3QgJGNlbGxFbCA9ICQodGhpcyk7XG4gICAgICBjb25zdCBpc0FjdGl2ZSA9ICRjZWxsRWwuaGFzQ2xhc3MoJ3NvcnRhYmxlLWNlbGwtYWN0aXZlJyk7XG4gICAgICBjb25zdCBjdXJyZW50U29ydCA9ICRjZWxsRWwuaGFzQ2xhc3MoJ3NvcnRhYmxlLWRlc2MnKSA/ICdkZXNjJyA6ICdhc2MnO1xuICAgICAgbGV0IG5ld1NvcnQ7XG4gICAgICBpZiAoaXNBY3RpdmUpIHtcbiAgICAgICAgbmV3U29ydCA9IGN1cnJlbnRTb3J0ID09PSAnZGVzYycgPyAnYXNjJyA6ICdkZXNjJztcbiAgICAgICAgJGNlbGxFbC5yZW1vdmVDbGFzcygnc29ydGFibGUtZGVzYyBzb3J0YWJsZS1hc2MnKS5hZGRDbGFzcyhgc29ydGFibGUtJHtuZXdTb3J0fWApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJGVsLmZpbmQoJ3RoZWFkIC5zb3J0YWJsZS1jZWxsLWFjdGl2ZScpLnJlbW92ZUNsYXNzKCdzb3J0YWJsZS1jZWxsLWFjdGl2ZScpO1xuICAgICAgICAkY2VsbEVsLmFkZENsYXNzKCdzb3J0YWJsZS1jZWxsLWFjdGl2ZScpO1xuICAgICAgICBuZXdTb3J0ID0gY3VycmVudFNvcnQ7XG4gICAgICB9XG4gICAgICAkY2VsbEVsLnRyaWdnZXIoJ2RhdGF0YWJsZTpzb3J0JywgbmV3U29ydCk7XG4gICAgICB0YWJsZS5lbWl0KCdsb2NhbDo6c29ydCBkYXRhVGFibGVTb3J0JywgdGFibGUsIG5ld1NvcnQpO1xuICAgIH1cbiAgICB0YWJsZS5hdHRhY2hFdmVudHMgPSBmdW5jdGlvbiBhdHRhY2hFdmVudHMoKSB7XG4gICAgICB0YWJsZS4kZWwub24oJ2NoYW5nZScsICcuY2hlY2tib3gtY2VsbCBpbnB1dFt0eXBlPVwiY2hlY2tib3hcIl0nLCBoYW5kbGVDaGFuZ2UpO1xuICAgICAgdGFibGUuJGVsLmZpbmQoJ3RoZWFkIC5zb3J0YWJsZS1jZWxsJykub24oJ2NsaWNrJywgaGFuZGxlU29ydGFibGVDbGljayk7XG4gICAgfTtcbiAgICB0YWJsZS5kZXRhY2hFdmVudHMgPSBmdW5jdGlvbiBkZXRhY2hFdmVudHMoKSB7XG4gICAgICB0YWJsZS4kZWwub2ZmKCdjaGFuZ2UnLCAnLmNoZWNrYm94LWNlbGwgaW5wdXRbdHlwZT1cImNoZWNrYm94XCJdJywgaGFuZGxlQ2hhbmdlKTtcbiAgICAgIHRhYmxlLiRlbC5maW5kKCd0aGVhZCAuc29ydGFibGUtY2VsbCcpLm9mZignY2xpY2snLCBoYW5kbGVTb3J0YWJsZUNsaWNrKTtcbiAgICB9O1xuXG4gICAgLy8gSW5zdGFsbCBNb2R1bGVzXG4gICAgdGFibGUudXNlTW9kdWxlcygpO1xuXG4gICAgLy8gSW5pdFxuICAgIHRhYmxlLmluaXQoKTtcblxuICAgIHJldHVybiB0YWJsZTtcbiAgfVxuICBzZXRDb2xsYXBzaWJsZUxhYmVscygpIHtcbiAgICBjb25zdCB0YWJsZSA9IHRoaXM7XG4gICAgaWYgKCF0YWJsZS5jb2xsYXBzaWJsZSkgcmV0dXJuO1xuICAgIHRhYmxlLiRlbC5maW5kKCd0Ym9keSB0ZDpub3QoLmNoZWNrYm94LWNlbGwpJykuZWFjaCgoaW5kZXgsIGVsKSA9PiB7XG4gICAgICBjb25zdCAkZWwgPSAkKGVsKTtcbiAgICAgIGNvbnN0IGVsSW5kZXggPSAkZWwuaW5kZXgoKTtcbiAgICAgIGNvbnN0IGNvbGxwc2libGVUaXRsZSA9ICRlbC5hdHRyKCdkYXRhLWNvbGxhcHNpYmxlLXRpdGxlJyk7XG4gICAgICBpZiAoIWNvbGxwc2libGVUaXRsZSAmJiBjb2xscHNpYmxlVGl0bGUgIT09ICcnKSB7XG4gICAgICAgICRlbC5hdHRyKCdkYXRhLWNvbGxhcHNpYmxlLXRpdGxlJywgdGFibGUuJGVsLmZpbmQoJ3RoZWFkIHRoJykuZXEoZWxJbmRleCkudGV4dCgpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBjaGVja1NlbGVjdGVkSGVhZGVyKCkge1xuICAgIGNvbnN0IHRhYmxlID0gdGhpcztcbiAgICBpZiAodGFibGUuJGhlYWRlckVsLmxlbmd0aCA+IDAgJiYgdGFibGUuJGhlYWRlclNlbGVjdGVkRWwubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgY2hlY2tlZEl0ZW1zID0gdGFibGUuJGVsLmZpbmQoJ3Rib2R5IC5jaGVja2JveC1jZWxsIGlucHV0OmNoZWNrZWQnKS5sZW5ndGg7XG4gICAgICB0YWJsZS4kZWxbY2hlY2tlZEl0ZW1zID4gMCA/ICdhZGRDbGFzcycgOiAncmVtb3ZlQ2xhc3MnXSgnZGF0YS10YWJsZS1oYXMtY2hlY2tlZCcpO1xuICAgICAgdGFibGUuJGhlYWRlclNlbGVjdGVkRWwuZmluZCgnLmRhdGEtdGFibGUtc2VsZWN0ZWQtY291bnQnKS50ZXh0KGNoZWNrZWRJdGVtcyk7XG4gICAgfVxuICB9XG4gIGluaXQoKSB7XG4gICAgY29uc3QgdGFibGUgPSB0aGlzO1xuICAgIHRhYmxlLmF0dGFjaEV2ZW50cygpO1xuICAgIHRhYmxlLnNldENvbGxhcHNpYmxlTGFiZWxzKCk7XG4gICAgdGFibGUuY2hlY2tTZWxlY3RlZEhlYWRlcigpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgbGV0IHRhYmxlID0gdGhpcztcblxuICAgIHRhYmxlLiRlbC50cmlnZ2VyKCdkYXRhdGFibGU6YmVmb3JlZGVzdHJveScsIHRhYmxlKTtcbiAgICB0YWJsZS5lbWl0KCdsb2NhbDo6YmVmb3JlRGVzdHJveSBkYXRhdGFibGVCZWZvcmVEZXN0cm95JywgdGFibGUpO1xuXG4gICAgdGFibGUuYXR0YWNoRXZlbnRzKCk7XG4gICAgdGFibGUuJGVsWzBdLmY3RGF0YVRhYmxlID0gbnVsbDtcbiAgICBkZWxldGUgdGFibGUuJGVsWzBdLmY3RGF0YVRhYmxlO1xuICAgIFV0aWxzLmRlbGV0ZVByb3BzKHRhYmxlKTtcbiAgICB0YWJsZSA9IG51bGw7XG4gIH1cbn1cblxudmFyIERhdGFUYWJsZSQxID0ge1xuICBuYW1lOiAnZGF0YVRhYmxlJyxcbiAgc3RhdGljOiB7XG4gICAgRGF0YVRhYmxlLFxuICB9LFxuICBjcmVhdGUoKSB7XG4gICAgY29uc3QgYXBwID0gdGhpcztcbiAgICBhcHAuZGF0YVRhYmxlID0gQ29uc3RydWN0b3JNZXRob2RzKHtcbiAgICAgIGRlZmF1bHRTZWxlY3RvcjogJy5kYXRhLXRhYmxlJyxcbiAgICAgIGNvbnN0cnVjdG9yOiBEYXRhVGFibGUsXG4gICAgICBhcHAsXG4gICAgICBkb21Qcm9wOiAnZjdEYXRhVGFibGUnLFxuICAgIH0pO1xuICB9LFxuICBvbjoge1xuICAgIHRhYkJlZm9yZVJlbW92ZSh0YWJFbCkge1xuICAgICAgY29uc3QgYXBwID0gdGhpcztcbiAgICAgICQodGFiRWwpLmZpbmQoJy5kYXRhLXRhYmxlLWluaXQnKS5lYWNoKChpbmRleCwgdGFibGVFbCkgPT4ge1xuICAgICAgICBhcHAuZGF0YVRhYmxlLmRlc3Ryb3kodGFibGVFbCk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIHRhYk1vdW50ZWQodGFiRWwpIHtcbiAgICAgIGNvbnN0IGFwcCA9IHRoaXM7XG4gICAgICAkKHRhYkVsKS5maW5kKCcuZGF0YS10YWJsZS1pbml0JykuZWFjaCgoaW5kZXgsIHRhYmxlRWwpID0+IHtcbiAgICAgICAgYXBwLmRhdGFUYWJsZS5jcmVhdGUoeyBlbDogdGFibGVFbCB9KTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgcGFnZUJlZm9yZVJlbW92ZShwYWdlKSB7XG4gICAgICBjb25zdCBhcHAgPSB0aGlzO1xuICAgICAgcGFnZS4kZWwuZmluZCgnLmRhdGEtdGFibGUtaW5pdCcpLmVhY2goKGluZGV4LCB0YWJsZUVsKSA9PiB7XG4gICAgICAgIGFwcC5kYXRhVGFibGUuZGVzdHJveSh0YWJsZUVsKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgcGFnZUluaXQocGFnZSkge1xuICAgICAgY29uc3QgYXBwID0gdGhpcztcbiAgICAgIHBhZ2UuJGVsLmZpbmQoJy5kYXRhLXRhYmxlLWluaXQnKS5lYWNoKChpbmRleCwgdGFibGVFbCkgPT4ge1xuICAgICAgICBhcHAuZGF0YVRhYmxlLmNyZWF0ZSh7IGVsOiB0YWJsZUVsIH0pO1xuICAgICAgfSk7XG4gICAgfSxcbiAgfSxcbiAgY2xpY2tzOiB7XG5cbiAgfSxcbn07XG5cbmNvbnN0IEZhYiA9IHtcbiAgbW9ycGhPcGVuKGZhYkVsLCB0YXJnZXRFbCkge1xuICAgIGNvbnN0IGFwcCA9IHRoaXM7XG4gICAgY29uc3QgJGZhYkVsID0gJChmYWJFbCk7XG4gICAgY29uc3QgJHRhcmdldEVsID0gJCh0YXJnZXRFbCk7XG4gICAgaWYgKCR0YXJnZXRFbC5sZW5ndGggPT09IDApIHJldHVybjtcblxuICAgICR0YXJnZXRFbC50cmFuc2l0aW9uKDApLmFkZENsYXNzKCdmYWItbW9ycGgtdGFyZ2V0LXZpc2libGUnKTtcbiAgICBjb25zdCB0YXJnZXQgPSB7XG4gICAgICB3aWR0aDogJHRhcmdldEVsWzBdLm9mZnNldFdpZHRoLFxuICAgICAgaGVpZ2h0OiAkdGFyZ2V0RWxbMF0ub2Zmc2V0SGVpZ2h0LFxuICAgICAgb2Zmc2V0OiAkdGFyZ2V0RWwub2Zmc2V0KCksXG4gICAgICBib3JkZXJSYWRpdXM6ICR0YXJnZXRFbC5jc3MoJ2JvcmRlci1yYWRpdXMnKSxcbiAgICAgIHpJbmRleDogJHRhcmdldEVsLmNzcygnei1pbmRleCcpLFxuICAgIH07XG4gICAgY29uc3QgZmFiID0ge1xuICAgICAgd2lkdGg6ICRmYWJFbFswXS5vZmZzZXRXaWR0aCxcbiAgICAgIGhlaWdodDogJGZhYkVsWzBdLm9mZnNldEhlaWdodCxcbiAgICAgIG9mZnNldDogJGZhYkVsLm9mZnNldCgpLFxuICAgICAgdHJhbnNsYXRlWDogVXRpbHMuZ2V0VHJhbnNsYXRlKCRmYWJFbFswXSwgJ3gnKSxcbiAgICAgIHRyYW5zbGF0ZVk6IFV0aWxzLmdldFRyYW5zbGF0ZSgkZmFiRWxbMF0sICd5JyksXG4gICAgfTtcblxuICAgICRmYWJFbFswXS5mN0ZhYk1vcnBoRGF0YSA9IHtcbiAgICAgICR0YXJnZXRFbCxcbiAgICAgIHRhcmdldCxcbiAgICAgIGZhYixcbiAgICB9O1xuXG4gICAgY29uc3QgZGlmZlggPSAoZmFiLm9mZnNldC5sZWZ0ICsgKGZhYi53aWR0aCAvIDIpKSAtXG4gICAgICAgICAgICAgICAgICAodGFyZ2V0Lm9mZnNldC5sZWZ0ICsgKHRhcmdldC53aWR0aCAvIDIpKSAtXG4gICAgICAgICAgICAgICAgICBmYWIudHJhbnNsYXRlWDtcbiAgICBjb25zdCBkaWZmWSA9IChmYWIub2Zmc2V0LnRvcCArIChmYWIuaGVpZ2h0IC8gMikpIC1cbiAgICAgICAgICAgICAgICAgICh0YXJnZXQub2Zmc2V0LnRvcCArICh0YXJnZXQuaGVpZ2h0IC8gMikpIC1cbiAgICAgICAgICAgICAgICAgIGZhYi50cmFuc2xhdGVZO1xuICAgIGNvbnN0IHNjYWxlWCA9IHRhcmdldC53aWR0aCAvIGZhYi53aWR0aDtcbiAgICBjb25zdCBzY2FsZVkgPSB0YXJnZXQuaGVpZ2h0IC8gZmFiLmhlaWdodDtcblxuICAgIGxldCBib3JkZXJSYWRpdXMgPSBNYXRoLmNlaWwocGFyc2VJbnQodGFyZ2V0LmJvcmRlclJhZGl1cywgMTApIC8gTWF0aC5tYXgoc2NhbGVYLCBzY2FsZVkpKTtcbiAgICBpZiAoYm9yZGVyUmFkaXVzID4gMCkgYm9yZGVyUmFkaXVzICs9IDI7XG5cbiAgICAkZmFiRWxbMF0uZjdGYWJNb3JwaFJlc2l6ZUhhbmRsZXIgPSBmdW5jdGlvbiByZXNpemVIYW5kbGVyKCkge1xuICAgICAgJGZhYkVsLnRyYW5zaXRpb24oMCkudHJhbnNmb3JtKCcnKTtcbiAgICAgICR0YXJnZXRFbC50cmFuc2l0aW9uKDApO1xuICAgICAgdGFyZ2V0LndpZHRoID0gJHRhcmdldEVsWzBdLm9mZnNldFdpZHRoO1xuICAgICAgdGFyZ2V0LmhlaWdodCA9ICR0YXJnZXRFbFswXS5vZmZzZXRIZWlnaHQ7XG4gICAgICB0YXJnZXQub2Zmc2V0ID0gJHRhcmdldEVsLm9mZnNldCgpO1xuICAgICAgZmFiLm9mZnNldCA9ICRmYWJFbC5vZmZzZXQoKTtcblxuICAgICAgY29uc3QgZGlmZlhOZXcgPSAoZmFiLm9mZnNldC5sZWZ0ICsgKGZhYi53aWR0aCAvIDIpKSAtXG4gICAgICAgICAgICAgICAgICAgICAgKHRhcmdldC5vZmZzZXQubGVmdCArICh0YXJnZXQud2lkdGggLyAyKSkgLVxuICAgICAgICAgICAgICAgICAgICAgIGZhYi50cmFuc2xhdGVYO1xuICAgICAgY29uc3QgZGlmZllOZXcgPSAoZmFiLm9mZnNldC50b3AgKyAoZmFiLmhlaWdodCAvIDIpKSAtXG4gICAgICAgICAgICAgICAgICAgICAgKHRhcmdldC5vZmZzZXQudG9wICsgKHRhcmdldC5oZWlnaHQgLyAyKSkgLVxuICAgICAgICAgICAgICAgICAgICAgIGZhYi50cmFuc2xhdGVZO1xuICAgICAgY29uc3Qgc2NhbGVYTmV3ID0gdGFyZ2V0LndpZHRoIC8gZmFiLndpZHRoO1xuICAgICAgY29uc3Qgc2NhbGVZTmV3ID0gdGFyZ2V0LmhlaWdodCAvIGZhYi5oZWlnaHQ7XG5cbiAgICAgICRmYWJFbC50cmFuc2Zvcm0oYHRyYW5zbGF0ZTNkKCR7LWRpZmZYTmV3fXB4LCAkey1kaWZmWU5ld31weCwgMCkgc2NhbGUoJHtzY2FsZVhOZXd9LCAke3NjYWxlWU5ld30pYCk7XG4gICAgfTtcblxuICAgICR0YXJnZXRFbFxuICAgICAgLmNzcygnb3BhY2l0eScsIDApXG4gICAgICAudHJhbnNmb3JtKGBzY2FsZSgkezEgLyBzY2FsZVh9LCAkezEgLyBzY2FsZVl9KWApO1xuICAgICRmYWJFbFxuICAgICAgLmFkZENsYXNzKCdmYWItb3BlbmVkJylcbiAgICAgIC5jc3MoJ3otaW5kZXgnLCB0YXJnZXQuekluZGV4IC0gMSlcbiAgICAgIC50cmFuc2Zvcm0oYHRyYW5zbGF0ZTNkKCR7LWRpZmZYfXB4LCAkey1kaWZmWX1weCwgMClgKTtcbiAgICAkZmFiRWwudHJhbnNpdGlvbkVuZCgoKSA9PiB7XG4gICAgICAkdGFyZ2V0RWwudHJhbnNpdGlvbignJyk7XG4gICAgICBVdGlscy5uZXh0VGljaygoKSA9PiB7XG4gICAgICAgICR0YXJnZXRFbC5jc3MoJ29wYWNpdHknLCAxKS50cmFuc2Zvcm0oJ3NjYWxlKDEsMSknKTtcbiAgICAgIH0pO1xuICAgICAgJGZhYkVsLnRyYW5zZm9ybShgdHJhbnNsYXRlM2QoJHstZGlmZlh9cHgsICR7LWRpZmZZfXB4LCAwKSBzY2FsZSgke3NjYWxlWH0sICR7c2NhbGVZfSlgKVxuICAgICAgICAuY3NzKCdib3JkZXItcmFkaXVzJywgYCR7Ym9yZGVyUmFkaXVzfXB4YClcbiAgICAgICAgLmNzcygnYm94LXNoYWRvdycsICdub25lJyk7XG4gICAgICBhcHAub24oJ3Jlc2l6ZScsICRmYWJFbFswXS5mN0ZhYk1vcnBoUmVzaXplSGFuZGxlcik7XG4gICAgICBpZiAoJHRhcmdldEVsLnBhcmVudHMoJy5wYWdlLWNvbnRlbnQnKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICR0YXJnZXRFbC5wYXJlbnRzKCcucGFnZS1jb250ZW50Jykub24oJ3Njcm9sbCcsICRmYWJFbFswXS5mN0ZhYk1vcnBoUmVzaXplSGFuZGxlcik7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG4gIG1vcnBoQ2xvc2UoZmFiRWwpIHtcbiAgICBjb25zdCBhcHAgPSB0aGlzO1xuICAgIGNvbnN0ICRmYWJFbCA9ICQoZmFiRWwpO1xuICAgIGNvbnN0IG1vcnBoRGF0YSA9ICRmYWJFbFswXS5mN0ZhYk1vcnBoRGF0YTtcbiAgICBpZiAoIW1vcnBoRGF0YSkgcmV0dXJuO1xuICAgIGNvbnN0IHsgJHRhcmdldEVsLCB0YXJnZXQsIGZhYiB9ID0gbW9ycGhEYXRhO1xuICAgIGlmICgkdGFyZ2V0RWwubGVuZ3RoID09PSAwKSByZXR1cm47XG5cbiAgICBjb25zdCBkaWZmWCA9IChmYWIub2Zmc2V0LmxlZnQgKyAoZmFiLndpZHRoIC8gMikpIC1cbiAgICAgICAgICAgICAgICAgICh0YXJnZXQub2Zmc2V0LmxlZnQgKyAodGFyZ2V0LndpZHRoIC8gMikpIC1cbiAgICAgICAgICAgICAgICAgIGZhYi50cmFuc2xhdGVYO1xuICAgIGNvbnN0IGRpZmZZID0gKGZhYi5vZmZzZXQudG9wICsgKGZhYi5oZWlnaHQgLyAyKSkgLVxuICAgICAgICAgICAgICAgICAgKHRhcmdldC5vZmZzZXQudG9wICsgKHRhcmdldC5oZWlnaHQgLyAyKSkgLVxuICAgICAgICAgICAgICAgICAgZmFiLnRyYW5zbGF0ZVk7XG4gICAgY29uc3Qgc2NhbGVYID0gdGFyZ2V0LndpZHRoIC8gZmFiLndpZHRoO1xuICAgIGNvbnN0IHNjYWxlWSA9IHRhcmdldC5oZWlnaHQgLyBmYWIuaGVpZ2h0O1xuXG4gICAgYXBwLm9mZigncmVzaXplJywgJGZhYkVsWzBdLmY3RmFiTW9ycGhSZXNpemVIYW5kbGVyKTtcbiAgICBpZiAoJHRhcmdldEVsLnBhcmVudHMoJy5wYWdlLWNvbnRlbnQnKS5sZW5ndGggPiAwKSB7XG4gICAgICAkdGFyZ2V0RWwucGFyZW50cygnLnBhZ2UtY29udGVudCcpLm9mZignc2Nyb2xsJywgJGZhYkVsWzBdLmY3RmFiTW9ycGhSZXNpemVIYW5kbGVyKTtcbiAgICB9XG5cbiAgICAkdGFyZ2V0RWxcbiAgICAgIC5jc3MoJ29wYWNpdHknLCAwKVxuICAgICAgLnRyYW5zZm9ybShgc2NhbGUoJHsxIC8gc2NhbGVYfSwgJHsxIC8gc2NhbGVZfSlgKTtcbiAgICAkZmFiRWxcbiAgICAgIC50cmFuc2l0aW9uKCcnKVxuICAgICAgLmNzcygnYm94LXNoYWRvdycsICcnKVxuICAgICAgLmNzcygnYm9yZGVyLXJhZGl1cycsICcnKVxuICAgICAgLnRyYW5zZm9ybShgdHJhbnNsYXRlM2QoJHstZGlmZlh9cHgsICR7LWRpZmZZfXB4LCAwKWApO1xuICAgICRmYWJFbC50cmFuc2l0aW9uRW5kKCgpID0+IHtcbiAgICAgICRmYWJFbFxuICAgICAgICAuY3NzKCd6LWluZGV4JywgJycpXG4gICAgICAgIC5yZW1vdmVDbGFzcygnZmFiLW9wZW5lZCcpXG4gICAgICAgIC50cmFuc2Zvcm0oJycpO1xuICAgICAgVXRpbHMubmV4dFRpY2soKCkgPT4ge1xuICAgICAgICAkZmFiRWwudHJhbnNpdGlvbkVuZCgoKSA9PiB7XG4gICAgICAgICAgJHRhcmdldEVsXG4gICAgICAgICAgICAucmVtb3ZlQ2xhc3MoJ2ZhYi1tb3JwaC10YXJnZXQtdmlzaWJsZScpXG4gICAgICAgICAgICAuY3NzKCdvcGFjaXR5JywgJycpXG4gICAgICAgICAgICAudHJhbnNmb3JtKCcnKVxuICAgICAgICAgICAgLnRyYW5zaXRpb24oJycpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9LFxuICBvcGVuKGZhYkVsLCB0YXJnZXRFbCkge1xuICAgIGNvbnN0IGFwcCA9IHRoaXM7XG4gICAgY29uc3QgJGZhYkVsID0gJChmYWJFbCkuZXEoMCk7XG4gICAgY29uc3QgJGJ1dHRvbnNFbCA9ICRmYWJFbC5maW5kKCcuZmFiLWJ1dHRvbnMnKTtcbiAgICBpZiAoISRmYWJFbC5sZW5ndGgpIHJldHVybjtcbiAgICBpZiAoJGZhYkVsLmhhc0NsYXNzKCdmYWItb3BlbmVkJykpIHJldHVybjtcbiAgICBpZiAoISRidXR0b25zRWwubGVuZ3RoICYmICEkZmFiRWwuaGFzQ2xhc3MoJ2ZhYi1tb3JwaCcpKSByZXR1cm47XG5cbiAgICBpZiAoYXBwLmZhYi5vcGVuZWRFbCkge1xuICAgICAgaWYgKGFwcC5mYWIub3BlbmVkRWwgPT09ICRmYWJFbFswXSkgcmV0dXJuO1xuICAgICAgYXBwLmZhYi5jbG9zZShhcHAuZmFiLm9wZW5lZEVsKTtcbiAgICB9XG4gICAgYXBwLmZhYi5vcGVuZWRFbCA9ICRmYWJFbFswXTtcbiAgICBpZiAoJGZhYkVsLmhhc0NsYXNzKCdmYWItbW9ycGgnKSkge1xuICAgICAgYXBwLmZhYi5tb3JwaE9wZW4oJGZhYkVsLCB0YXJnZXRFbCB8fCAkZmFiRWwuYXR0cignZGF0YS1tb3JwaC10bycpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgJGZhYkVsLmFkZENsYXNzKCdmYWItb3BlbmVkJyk7XG4gICAgfVxuICAgICRmYWJFbC50cmlnZ2VyKCdmYWI6b3BlbicpO1xuICB9LFxuICBjbG9zZShmYWJFbCA9ICcuZmFiLW9wZW5lZCcpIHtcbiAgICBjb25zdCBhcHAgPSB0aGlzO1xuICAgIGNvbnN0ICRmYWJFbCA9ICQoZmFiRWwpLmVxKDApO1xuICAgIGNvbnN0ICRidXR0b25zRWwgPSAkZmFiRWwuZmluZCgnLmZhYi1idXR0b25zJyk7XG4gICAgaWYgKCEkZmFiRWwubGVuZ3RoKSByZXR1cm47XG4gICAgaWYgKCEkZmFiRWwuaGFzQ2xhc3MoJ2ZhYi1vcGVuZWQnKSkgcmV0dXJuO1xuICAgIGlmICghJGJ1dHRvbnNFbC5sZW5ndGggJiYgISRmYWJFbC5oYXNDbGFzcygnZmFiLW1vcnBoJykpIHJldHVybjtcbiAgICBhcHAuZmFiLm9wZW5lZEVsID0gbnVsbDtcbiAgICBpZiAoJGZhYkVsLmhhc0NsYXNzKCdmYWItbW9ycGgnKSkge1xuICAgICAgYXBwLmZhYi5tb3JwaENsb3NlKCRmYWJFbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICRmYWJFbC5yZW1vdmVDbGFzcygnZmFiLW9wZW5lZCcpO1xuICAgIH1cbiAgICAkZmFiRWwudHJpZ2dlcignZmFiOmNsb3NlJyk7XG4gIH0sXG4gIHRvZ2dsZShmYWJFbCkge1xuICAgIGNvbnN0IGFwcCA9IHRoaXM7XG4gICAgY29uc3QgJGZhYkVsID0gJChmYWJFbCk7XG4gICAgaWYgKCEkZmFiRWwuaGFzQ2xhc3MoJ2ZhYi1vcGVuZWQnKSkgYXBwLmZhYi5vcGVuKGZhYkVsKTtcbiAgICBlbHNlIGFwcC5mYWIuY2xvc2UoZmFiRWwpO1xuICB9LFxufTtcblxudmFyIEZhYiQxID0ge1xuICBuYW1lOiAnZmFiJyxcbiAgY3JlYXRlKCkge1xuICAgIGNvbnN0IGFwcCA9IHRoaXM7XG4gICAgVXRpbHMuZXh0ZW5kKGFwcCwge1xuICAgICAgZmFiOiB7XG4gICAgICAgIG9wZW5lZEVsOiBudWxsLFxuICAgICAgICBtb3JwaE9wZW46IEZhYi5tb3JwaE9wZW4uYmluZChhcHApLFxuICAgICAgICBtb3JwaENsb3NlOiBGYWIubW9ycGhDbG9zZS5iaW5kKGFwcCksXG4gICAgICAgIG9wZW46IEZhYi5vcGVuLmJpbmQoYXBwKSxcbiAgICAgICAgY2xvc2U6IEZhYi5jbG9zZS5iaW5kKGFwcCksXG4gICAgICAgIHRvZ2dsZTogRmFiLnRvZ2dsZS5iaW5kKGFwcCksXG4gICAgICB9LFxuICAgIH0pO1xuICB9LFxuICBjbGlja3M6IHtcbiAgICAnLmZhYiA+IGEnOiBmdW5jdGlvbiBvcGVuKCRjbGlja2VkRWwpIHtcbiAgICAgIGNvbnN0IGFwcCA9IHRoaXM7XG4gICAgICBhcHAuZmFiLnRvZ2dsZSgkY2xpY2tlZEVsLnBhcmVudHMoJy5mYWInKSk7XG4gICAgfSxcbiAgICAnLmZhYi1vcGVuJzogZnVuY3Rpb24gb3BlbigkY2xpY2tlZEVsLCBkYXRhID0ge30pIHtcbiAgICAgIGNvbnN0IGFwcCA9IHRoaXM7XG4gICAgICBhcHAuZmFiLm9wZW4oZGF0YS5mYWIpO1xuICAgIH0sXG4gICAgJy5mYWItY2xvc2UnOiBmdW5jdGlvbiBjbG9zZSgkY2xpY2tlZEVsLCBkYXRhID0ge30pIHtcbiAgICAgIGNvbnN0IGFwcCA9IHRoaXM7XG4gICAgICBhcHAuZmFiLmNsb3NlKGRhdGEuZmFiKTtcbiAgICB9LFxuICB9LFxufTtcblxuY2xhc3MgU2VhcmNoYmFyIGV4dGVuZHMgRnJhbWV3b3JrN0NsYXNzIHtcbiAgY29uc3RydWN0b3IoYXBwLCBwYXJhbXMgPSB7fSkge1xuICAgIHN1cGVyKHBhcmFtcywgW2FwcF0pO1xuXG4gICAgY29uc3Qgc2IgPSB0aGlzO1xuXG4gICAgY29uc3QgZGVmYXVsdHMgPSB7XG4gICAgICBlbDogdW5kZWZpbmVkLFxuICAgICAgaW5wdXRFbDogdW5kZWZpbmVkLFxuICAgICAgZGlzYWJsZUJ1dHRvbjogdHJ1ZSxcbiAgICAgIGRpc2FibGVCdXR0b25FbDogdW5kZWZpbmVkLFxuICAgICAgYmFja2Ryb3BFbDogdW5kZWZpbmVkLFxuICAgICAgc2VhcmNoQ29udGFpbmVyOiB1bmRlZmluZWQsIC8vIGNvbnRhaW5lciB0byBzZWFyY2gsIEhUTUxFbGVtZW50IG9yIENTUyBzZWxlY3RvclxuICAgICAgc2VhcmNoSXRlbTogJ2xpJywgLy8gc2luZ2xlIGl0ZW0gc2VsZWN0b3IsIENTUyBzZWxlY3RvclxuICAgICAgc2VhcmNoSW46IHVuZGVmaW5lZCwgLy8gd2hlcmUgdG8gc2VhcmNoIGluIGl0ZW0sIENTUyBzZWxlY3RvclxuICAgICAgaWdub3JlOiAnLnNlYXJjaGJhci1pZ25vcmUnLFxuICAgICAgZm91bmRFbDogJy5zZWFyY2hiYXItZm91bmQnLFxuICAgICAgbm90Rm91bmRFbDogJy5zZWFyY2hiYXItbm90LWZvdW5kJyxcbiAgICAgIGhpZGVPbkVuYWJsZUVsOiAnLnNlYXJjaGJhci1oaWRlLW9uLWVuYWJsZScsXG4gICAgICBoaWRlT25TZWFyY2hFbDogJy5zZWFyY2hiYXItaGlkZS1vbi1zZWFyY2gnLFxuICAgICAgYmFja2Ryb3A6IHRydWUsXG4gICAgICByZW1vdmVEaWFjcml0aWNzOiB0cnVlLFxuICAgICAgY3VzdG9tU2VhcmNoOiBmYWxzZSxcbiAgICAgIGhpZGVEaXZpZGVyczogdHJ1ZSxcbiAgICAgIGhpZGVHcm91cHM6IHRydWUsXG4gICAgICBkaXNhYmxlT25CYWNrZHJvcENsaWNrOiB0cnVlLFxuICAgICAgZXhwYW5kYWJsZTogZmFsc2UsXG4gICAgfTtcblxuICAgIC8vIEV4dGVuZCBkZWZhdWx0cyB3aXRoIG1vZHVsZXMgcGFyYW1zXG4gICAgc2IudXNlTW9kdWxlc1BhcmFtcyhkZWZhdWx0cyk7XG5cbiAgICBzYi5wYXJhbXMgPSBVdGlscy5leHRlbmQoZGVmYXVsdHMsIHBhcmFtcyk7XG5cbiAgICBjb25zdCAkZWwgPSAkKHNiLnBhcmFtcy5lbCk7XG4gICAgaWYgKCRlbC5sZW5ndGggPT09IDApIHJldHVybiBzYjtcblxuICAgICRlbFswXS5mN1NlYXJjaGJhciA9IHNiO1xuXG4gICAgbGV0ICRwYWdlRWw7XG4gICAgbGV0ICRuYXZiYXJFbDtcbiAgICBpZiAoJGVsLnBhcmVudHMoJy5wYWdlJykubGVuZ3RoID4gMCkge1xuICAgICAgJHBhZ2VFbCA9ICRlbC5wYXJlbnRzKCcucGFnZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICAkbmF2YmFyRWwgPSAkZWwucGFyZW50cygnLm5hdmJhci1pbm5lcicpO1xuICAgICAgaWYgKCRuYXZiYXJFbC5sZW5ndGggPiAwKSB7XG4gICAgICAgIGlmICgkbmF2YmFyRWxbMF0uZjdQYWdlKSB7XG4gICAgICAgICAgJHBhZ2VFbCA9ICRuYXZiYXJFbFswXS5mN1BhZ2UuJGVsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0ICRjdXJyZW50UGFnZUVsID0gJGVsLnBhcmVudHMoJy52aWV3JykuZmluZCgnLnBhZ2UtY3VycmVudCcpO1xuICAgICAgICAgIGlmICgkY3VycmVudFBhZ2VFbFswXSAmJiAkY3VycmVudFBhZ2VFbFswXS5mN1BhZ2UgJiYgJGN1cnJlbnRQYWdlRWxbMF0uZjdQYWdlLm5hdmJhckVsID09PSAkbmF2YmFyRWxbMF0pIHtcbiAgICAgICAgICAgICRwYWdlRWwgPSAkY3VycmVudFBhZ2VFbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgJGZvdW5kRWw7XG4gICAgaWYgKHBhcmFtcy5mb3VuZEVsKSB7XG4gICAgICAkZm91bmRFbCA9ICQocGFyYW1zLmZvdW5kRWwpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHNiLnBhcmFtcy5mb3VuZEVsID09PSAnc3RyaW5nJyAmJiAkcGFnZUVsKSB7XG4gICAgICAkZm91bmRFbCA9ICRwYWdlRWwuZmluZChzYi5wYXJhbXMuZm91bmRFbCk7XG4gICAgfVxuXG4gICAgbGV0ICRub3RGb3VuZEVsO1xuICAgIGlmIChwYXJhbXMubm90Rm91bmRFbCkge1xuICAgICAgJG5vdEZvdW5kRWwgPSAkKHBhcmFtcy5ub3RGb3VuZEVsKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBzYi5wYXJhbXMubm90Rm91bmRFbCA9PT0gJ3N0cmluZycgJiYgJHBhZ2VFbCkge1xuICAgICAgJG5vdEZvdW5kRWwgPSAkcGFnZUVsLmZpbmQoc2IucGFyYW1zLm5vdEZvdW5kRWwpO1xuICAgIH1cblxuICAgIGxldCAkaGlkZU9uRW5hYmxlRWw7XG4gICAgaWYgKHBhcmFtcy5oaWRlT25FbmFibGVFbCkge1xuICAgICAgJGhpZGVPbkVuYWJsZUVsID0gJChwYXJhbXMuaGlkZU9uRW5hYmxlRWwpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHNiLnBhcmFtcy5oaWRlT25FbmFibGVFbCA9PT0gJ3N0cmluZycgJiYgJHBhZ2VFbCkge1xuICAgICAgJGhpZGVPbkVuYWJsZUVsID0gJHBhZ2VFbC5maW5kKHNiLnBhcmFtcy5oaWRlT25FbmFibGVFbCk7XG4gICAgfVxuXG4gICAgbGV0ICRoaWRlT25TZWFyY2hFbDtcbiAgICBpZiAocGFyYW1zLmhpZGVPblNlYXJjaEVsKSB7XG4gICAgICAkaGlkZU9uU2VhcmNoRWwgPSAkKHBhcmFtcy5oaWRlT25TZWFyY2hFbCk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygc2IucGFyYW1zLmhpZGVPblNlYXJjaEVsID09PSAnc3RyaW5nJyAmJiAkcGFnZUVsKSB7XG4gICAgICAkaGlkZU9uU2VhcmNoRWwgPSAkcGFnZUVsLmZpbmQoc2IucGFyYW1zLmhpZGVPblNlYXJjaEVsKTtcbiAgICB9XG5cbiAgICBsZXQgJGJhY2tkcm9wRWw7XG4gICAgaWYgKHNiLnBhcmFtcy5iYWNrZHJvcCkge1xuICAgICAgaWYgKHNiLnBhcmFtcy5iYWNrZHJvcEVsKSB7XG4gICAgICAgICRiYWNrZHJvcEVsID0gJChzYi5wYXJhbXMuYmFja2Ryb3BFbCk7XG4gICAgICB9IGVsc2UgaWYgKCRwYWdlRWwgJiYgJHBhZ2VFbC5sZW5ndGggPiAwKSB7XG4gICAgICAgICRiYWNrZHJvcEVsID0gJHBhZ2VFbC5maW5kKCcuc2VhcmNoYmFyLWJhY2tkcm9wJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAkYmFja2Ryb3BFbCA9ICRlbC5zaWJsaW5ncygnLnNlYXJjaGJhci1iYWNrZHJvcCcpO1xuICAgICAgfVxuICAgICAgaWYgKCRiYWNrZHJvcEVsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAkYmFja2Ryb3BFbCA9ICQoJzxkaXYgY2xhc3M9XCJzZWFyY2hiYXItYmFja2Ryb3BcIj48L2Rpdj4nKTtcbiAgICAgICAgaWYgKCRwYWdlRWwgJiYgJHBhZ2VFbC5sZW5ndGgpIHtcbiAgICAgICAgICBpZiAoJGVsLnBhcmVudHMoJHBhZ2VFbCkubGVuZ3RoID4gMCAmJiAkbmF2YmFyRWwgJiYgJGVsLnBhcmVudHMoJG5hdmJhckVsKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICRiYWNrZHJvcEVsLmluc2VydEJlZm9yZSgkZWwpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAkYmFja2Ryb3BFbC5pbnNlcnRCZWZvcmUoJHBhZ2VFbC5maW5kKCcucGFnZS1jb250ZW50JykuZXEoMCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAkYmFja2Ryb3BFbC5pbnNlcnRCZWZvcmUoJGVsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGxldCAkc2VhcmNoQ29udGFpbmVyO1xuICAgIGlmIChzYi5wYXJhbXMuc2VhcmNoQ29udGFpbmVyKSB7XG4gICAgICAkc2VhcmNoQ29udGFpbmVyID0gJChzYi5wYXJhbXMuc2VhcmNoQ29udGFpbmVyKTtcbiAgICB9XG5cbiAgICBsZXQgJGlucHV0RWw7XG4gICAgaWYgKHNiLnBhcmFtcy5pbnB1dEVsKSB7XG4gICAgICAkaW5wdXRFbCA9ICQoc2IucGFyYW1zLmlucHV0RWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICAkaW5wdXRFbCA9ICRlbC5maW5kKCdpbnB1dFt0eXBlPVwic2VhcmNoXCJdJykuZXEoMCk7XG4gICAgfVxuXG4gICAgbGV0ICRkaXNhYmxlQnV0dG9uRWw7XG4gICAgaWYgKHNiLnBhcmFtcy5kaXNhYmxlQnV0dG9uKSB7XG4gICAgICBpZiAoc2IucGFyYW1zLmRpc2FibGVCdXR0b25FbCkge1xuICAgICAgICAkZGlzYWJsZUJ1dHRvbkVsID0gJChzYi5wYXJhbXMuZGlzYWJsZUJ1dHRvbkVsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICRkaXNhYmxlQnV0dG9uRWwgPSAkZWwuZmluZCgnLnNlYXJjaGJhci1kaXNhYmxlLWJ1dHRvbicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIFV0aWxzLmV4dGVuZChzYiwge1xuICAgICAgYXBwLFxuICAgICAgdmlldzogYXBwLnZpZXdzLmdldCgkZWwucGFyZW50cygnLnZpZXcnKSksXG4gICAgICAkZWwsXG4gICAgICBlbDogJGVsWzBdLFxuICAgICAgJGJhY2tkcm9wRWwsXG4gICAgICBiYWNrZHJvcEVsOiAkYmFja2Ryb3BFbCAmJiAkYmFja2Ryb3BFbFswXSxcbiAgICAgICRzZWFyY2hDb250YWluZXIsXG4gICAgICBzZWFyY2hDb250YWluZXI6ICRzZWFyY2hDb250YWluZXIgJiYgJHNlYXJjaENvbnRhaW5lclswXSxcbiAgICAgICRpbnB1dEVsLFxuICAgICAgaW5wdXRFbDogJGlucHV0RWxbMF0sXG4gICAgICAkZGlzYWJsZUJ1dHRvbkVsLFxuICAgICAgZGlzYWJsZUJ1dHRvbkVsOiAkZGlzYWJsZUJ1dHRvbkVsICYmICRkaXNhYmxlQnV0dG9uRWxbMF0sXG4gICAgICBkaXNhYmxlQnV0dG9uSGFzTWFyZ2luOiBmYWxzZSxcbiAgICAgICRwYWdlRWwsXG4gICAgICBwYWdlRWw6ICRwYWdlRWwgJiYgJHBhZ2VFbFswXSxcbiAgICAgICRuYXZiYXJFbCxcbiAgICAgIG5hdmJhckVsOiAkbmF2YmFyRWwgJiYgJG5hdmJhckVsWzBdLFxuICAgICAgJGZvdW5kRWwsXG4gICAgICBmb3VuZEVsOiAkZm91bmRFbCAmJiAkZm91bmRFbFswXSxcbiAgICAgICRub3RGb3VuZEVsLFxuICAgICAgbm90Rm91bmRFbDogJG5vdEZvdW5kRWwgJiYgJG5vdEZvdW5kRWxbMF0sXG4gICAgICAkaGlkZU9uRW5hYmxlRWwsXG4gICAgICBoaWRlT25FbmFibGVFbDogJGhpZGVPbkVuYWJsZUVsICYmICRoaWRlT25FbmFibGVFbFswXSxcbiAgICAgICRoaWRlT25TZWFyY2hFbCxcbiAgICAgIGhpZGVPblNlYXJjaEVsOiAkaGlkZU9uU2VhcmNoRWwgJiYgJGhpZGVPblNlYXJjaEVsWzBdLFxuICAgICAgcHJldmlvdXNRdWVyeTogJycsXG4gICAgICBxdWVyeTogJycsXG4gICAgICBpc1ZpcnR1YWxMaXN0OiAkc2VhcmNoQ29udGFpbmVyICYmICRzZWFyY2hDb250YWluZXIuaGFzQ2xhc3MoJ3ZpcnR1YWwtbGlzdCcpLFxuICAgICAgdmlydHVhbExpc3Q6IHVuZGVmaW5lZCxcbiAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgZXhwYW5kYWJsZTogc2IucGFyYW1zLmV4cGFuZGFibGUgfHwgJGVsLmhhc0NsYXNzKCdzZWFyY2hiYXItZXhwYW5kYWJsZScpLFxuICAgIH0pO1xuXG4gICAgLy8gRXZlbnRzXG4gICAgZnVuY3Rpb24gcHJldmVudFN1Ym1pdChlKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uSW5wdXRGb2N1cyhlKSB7XG4gICAgICBzYi5lbmFibGUoZSk7XG4gICAgICBzYi4kZWwuYWRkQ2xhc3MoJ3NlYXJjaGJhci1mb2N1c2VkJyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uSW5wdXRCbHVyKCkge1xuICAgICAgc2IuJGVsLnJlbW92ZUNsYXNzKCdzZWFyY2hiYXItZm9jdXNlZCcpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvbklucHV0Q2hhbmdlKCkge1xuICAgICAgY29uc3QgdmFsdWUgPSBzYi4kaW5wdXRFbC52YWwoKS50cmltKCk7XG4gICAgICBpZiAoXG4gICAgICAgIChcbiAgICAgICAgICAoc2IuJHNlYXJjaENvbnRhaW5lciAmJiBzYi4kc2VhcmNoQ29udGFpbmVyLmxlbmd0aCA+IDApICYmXG4gICAgICAgICAgKHNiLnBhcmFtcy5zZWFyY2hJbiB8fCBzYi5pc1ZpcnR1YWxMaXN0IHx8IHNiLnBhcmFtcy5zZWFyY2hJbiA9PT0gc2IucGFyYW1zLnNlYXJjaEl0ZW0pXG4gICAgICAgICkgfHxcbiAgICAgICAgc2IucGFyYW1zLmN1c3RvbVNlYXJjaFxuICAgICAgKSB7XG4gICAgICAgIHNiLnNlYXJjaCh2YWx1ZSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uSW5wdXRDbGVhcihlLCBwcmV2aW91c1ZhbHVlKSB7XG4gICAgICBzYi4kZWwudHJpZ2dlcignc2VhcmNoYmFyOmNsZWFyJywgcHJldmlvdXNWYWx1ZSk7XG4gICAgICBzYi5lbWl0KCdsb2NhbDo6Y2xlYXIgc2VhcmNoYmFyQ2xlYXInLCBzYiwgcHJldmlvdXNWYWx1ZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRpc2FibGVPbkNsaWNrKGUpIHtcbiAgICAgIHNiLmRpc2FibGUoZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uUGFnZUJlZm9yZU91dCgpIHtcbiAgICAgIGlmICghc2IgfHwgKHNiICYmICFzYi4kZWwpKSByZXR1cm47XG4gICAgICBpZiAoc2IuZW5hYmxlZCkge1xuICAgICAgICBzYi4kZWwucmVtb3ZlQ2xhc3MoJ3NlYXJjaGJhci1lbmFibGVkJyk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uUGFnZUJlZm9yZUluKCkge1xuICAgICAgaWYgKCFzYiB8fCAoc2IgJiYgIXNiLiRlbCkpIHJldHVybjtcbiAgICAgIGlmIChzYi5lbmFibGVkKSB7XG4gICAgICAgIHNiLiRlbC5hZGRDbGFzcygnc2VhcmNoYmFyLWVuYWJsZWQnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgc2IuYXR0YWNoRXZlbnRzID0gZnVuY3Rpb24gYXR0YWNoRXZlbnRzKCkge1xuICAgICAgJGVsLm9uKCdzdWJtaXQnLCBwcmV2ZW50U3VibWl0KTtcbiAgICAgIGlmIChzYi5wYXJhbXMuZGlzYWJsZUJ1dHRvbikge1xuICAgICAgICBzYi4kZGlzYWJsZUJ1dHRvbkVsLm9uKCdjbGljaycsIGRpc2FibGVPbkNsaWNrKTtcbiAgICAgIH1cbiAgICAgIGlmIChzYi5wYXJhbXMuZGlzYWJsZU9uQmFja2Ryb3BDbGljayAmJiBzYi4kYmFja2Ryb3BFbCkge1xuICAgICAgICBzYi4kYmFja2Ryb3BFbC5vbignY2xpY2snLCBkaXNhYmxlT25DbGljayk7XG4gICAgICB9XG4gICAgICBpZiAoc2IuZXhwYW5kYWJsZSAmJiBhcHAudGhlbWUgPT09ICdpb3MnICYmIHNiLnZpZXcgJiYgJG5hdmJhckVsICYmIHNiLiRwYWdlRWwpIHtcbiAgICAgICAgc2IuJHBhZ2VFbC5vbigncGFnZTpiZWZvcmVvdXQnLCBvblBhZ2VCZWZvcmVPdXQpO1xuICAgICAgICBzYi4kcGFnZUVsLm9uKCdwYWdlOmJlZm9yZWluJywgb25QYWdlQmVmb3JlSW4pO1xuICAgICAgfVxuICAgICAgc2IuJGlucHV0RWwub24oJ2ZvY3VzJywgb25JbnB1dEZvY3VzKTtcbiAgICAgIHNiLiRpbnB1dEVsLm9uKCdibHVyJywgb25JbnB1dEJsdXIpO1xuICAgICAgc2IuJGlucHV0RWwub24oJ2NoYW5nZSBpbnB1dCBjb21wb3NpdGlvbmVuZCcsIG9uSW5wdXRDaGFuZ2UpO1xuICAgICAgc2IuJGlucHV0RWwub24oJ2lucHV0OmNsZWFyJywgb25JbnB1dENsZWFyKTtcbiAgICB9O1xuICAgIHNiLmRldGFjaEV2ZW50cyA9IGZ1bmN0aW9uIGRldGFjaEV2ZW50cygpIHtcbiAgICAgICRlbC5vZmYoJ3N1Ym1pdCcsIHByZXZlbnRTdWJtaXQpO1xuICAgICAgaWYgKHNiLnBhcmFtcy5kaXNhYmxlQnV0dG9uKSB7XG4gICAgICAgIHNiLiRkaXNhYmxlQnV0dG9uRWwub2ZmKCdjbGljaycsIGRpc2FibGVPbkNsaWNrKTtcbiAgICAgIH1cbiAgICAgIGlmIChzYi5wYXJhbXMuZGlzYWJsZU9uQmFja2Ryb3BDbGljayAmJiBzYi4kYmFja2Ryb3BFbCkge1xuICAgICAgICBzYi4kYmFja2Ryb3BFbC5vZmYoJ2NsaWNrJywgZGlzYWJsZU9uQ2xpY2spO1xuICAgICAgfVxuICAgICAgaWYgKHNiLmV4cGFuZGFibGUgJiYgYXBwLnRoZW1lID09PSAnaW9zJyAmJiBzYi52aWV3ICYmICRuYXZiYXJFbCAmJiBzYi4kcGFnZUVsKSB7XG4gICAgICAgIHNiLiRwYWdlRWwub24oJ3BhZ2U6YmVmb3Jlb3V0Jywgb25QYWdlQmVmb3JlT3V0KTtcbiAgICAgICAgc2IuJHBhZ2VFbC5vbigncGFnZTpiZWZvcmVpbicsIG9uUGFnZUJlZm9yZUluKTtcbiAgICAgIH1cbiAgICAgIHNiLiRpbnB1dEVsLm9mZignZm9jdXMnLCBvbklucHV0Rm9jdXMpO1xuICAgICAgc2IuJGlucHV0RWwub2ZmKCdibHVyJywgb25JbnB1dEJsdXIpO1xuICAgICAgc2IuJGlucHV0RWwub2ZmKCdjaGFuZ2UgaW5wdXQgY29tcG9zaXRpb25lbmQnLCBvbklucHV0Q2hhbmdlKTtcbiAgICAgIHNiLiRpbnB1dEVsLm9mZignaW5wdXQ6Y2xlYXInLCBvbklucHV0Q2xlYXIpO1xuICAgIH07XG5cbiAgICAvLyBJbnN0YWxsIE1vZHVsZXNcbiAgICBzYi51c2VNb2R1bGVzKCk7XG5cbiAgICAvLyBJbml0XG4gICAgc2IuaW5pdCgpO1xuXG4gICAgcmV0dXJuIHNiO1xuICB9XG4gIGNsZWFyKGUpIHtcbiAgICBjb25zdCBzYiA9IHRoaXM7XG4gICAgaWYgKCFzYi5xdWVyeSAmJiBlICYmICQoZS50YXJnZXQpLmhhc0NsYXNzKCdzZWFyY2hiYXItY2xlYXInKSkge1xuICAgICAgc2IuZGlzYWJsZSgpO1xuICAgICAgcmV0dXJuIHNiO1xuICAgIH1cbiAgICBjb25zdCBwcmV2aW91c1F1ZXJ5ID0gc2IudmFsdWU7XG4gICAgc2IuJGlucHV0RWwudmFsKCcnKS50cmlnZ2VyKCdjaGFuZ2UnKS5mb2N1cygpO1xuICAgIHNiLiRlbC50cmlnZ2VyKCdzZWFyY2hiYXI6Y2xlYXInLCBwcmV2aW91c1F1ZXJ5KTtcbiAgICBzYi5lbWl0KCdsb2NhbDo6Y2xlYXIgc2VhcmNoYmFyQ2xlYXInLCBzYiwgcHJldmlvdXNRdWVyeSk7XG4gICAgcmV0dXJuIHNiO1xuICB9XG4gIHNldERpc2FibGVCdXR0b25NYXJnaW4oKSB7XG4gICAgY29uc3Qgc2IgPSB0aGlzO1xuICAgIGlmIChzYi5leHBhbmRhYmxlKSByZXR1cm47XG4gICAgY29uc3QgYXBwID0gc2IuYXBwO1xuICAgIHNiLiRkaXNhYmxlQnV0dG9uRWwudHJhbnNpdGlvbigwKS5zaG93KCk7XG4gICAgc2IuJGRpc2FibGVCdXR0b25FbC5jc3MoYG1hcmdpbi0ke2FwcC5ydGwgPyAnbGVmdCcgOiAncmlnaHQnfWAsIGAkey1zYi5kaXNhYmxlQnV0dG9uRWwub2Zmc2V0V2lkdGh9cHhgKTtcbiAgICAvKiBlc2xpbnQgbm8tdW5kZXJzY29yZS1kYW5nbGU6IFtcImVycm9yXCIsIHsgXCJhbGxvd1wiOiBbXCJfY2xpZW50TGVmdFwiXSB9XSAqL1xuICAgIHNiLl9jbGllbnRMZWZ0ID0gc2IuJGRpc2FibGVCdXR0b25FbFswXS5jbGllbnRMZWZ0O1xuICAgIHNiLiRkaXNhYmxlQnV0dG9uRWwudHJhbnNpdGlvbignJyk7XG4gICAgc2IuZGlzYWJsZUJ1dHRvbkhhc01hcmdpbiA9IHRydWU7XG4gIH1cbiAgZW5hYmxlKHNldEZvY3VzKSB7XG4gICAgY29uc3Qgc2IgPSB0aGlzO1xuICAgIGlmIChzYi5lbmFibGVkKSByZXR1cm4gc2I7XG4gICAgY29uc3QgYXBwID0gc2IuYXBwO1xuICAgIHNiLmVuYWJsZWQgPSB0cnVlO1xuICAgIGZ1bmN0aW9uIGVuYWJsZSgpIHtcbiAgICAgIGlmIChzYi4kYmFja2Ryb3BFbCAmJiAoKHNiLiRzZWFyY2hDb250YWluZXIgJiYgc2IuJHNlYXJjaENvbnRhaW5lci5sZW5ndGgpIHx8IHNiLnBhcmFtcy5jdXN0b21TZWFyY2gpICYmICFzYi4kZWwuaGFzQ2xhc3MoJ3NlYXJjaGJhci1lbmFibGVkJykgJiYgIXNiLnF1ZXJ5KSB7XG4gICAgICAgIHNiLmJhY2tkcm9wU2hvdygpO1xuICAgICAgfVxuICAgICAgc2IuJGVsLmFkZENsYXNzKCdzZWFyY2hiYXItZW5hYmxlZCcpO1xuICAgICAgaWYgKCFzYi5leHBhbmRhYmxlICYmIHNiLiRkaXNhYmxlQnV0dG9uRWwgJiYgc2IuJGRpc2FibGVCdXR0b25FbC5sZW5ndGggPiAwICYmIGFwcC50aGVtZSA9PT0gJ2lvcycpIHtcbiAgICAgICAgaWYgKCFzYi5kaXNhYmxlQnV0dG9uSGFzTWFyZ2luKSB7XG4gICAgICAgICAgc2Iuc2V0RGlzYWJsZUJ1dHRvbk1hcmdpbigpO1xuICAgICAgICB9XG4gICAgICAgIHNiLiRkaXNhYmxlQnV0dG9uRWwuY3NzKGBtYXJnaW4tJHthcHAucnRsID8gJ2xlZnQnIDogJ3JpZ2h0J31gLCAnMHB4Jyk7XG4gICAgICB9XG4gICAgICBpZiAoc2IuJGhpZGVPbkVuYWJsZUVsKSBzYi4kaGlkZU9uRW5hYmxlRWwuYWRkQ2xhc3MoJ2hpZGRlbi1ieS1zZWFyY2hiYXInKTtcbiAgICAgIHNiLiRlbC50cmlnZ2VyKCdzZWFyY2hiYXI6ZW5hYmxlJyk7XG4gICAgICBzYi5lbWl0KCdsb2NhbDo6ZW5hYmxlIHNlYXJjaGJhckVuYWJsZScsIHNiKTtcbiAgICB9XG4gICAgbGV0IG5lZWRzRm9jdXMgPSBmYWxzZTtcbiAgICBpZiAoc2V0Rm9jdXMgPT09IHRydWUpIHtcbiAgICAgIGlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50ICE9PSBzYi5pbnB1dEVsKSB7XG4gICAgICAgIG5lZWRzRm9jdXMgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBpc0lvcyA9IGFwcC5kZXZpY2UuaW9zICYmIGFwcC50aGVtZSA9PT0gJ2lvcyc7XG4gICAgaWYgKGlzSW9zKSB7XG4gICAgICBpZiAoc2IuZXhwYW5kYWJsZSkge1xuICAgICAgICBpZiAobmVlZHNGb2N1cykgc2IuJGlucHV0RWwuZm9jdXMoKTtcbiAgICAgICAgZW5hYmxlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAobmVlZHNGb2N1cykgc2IuJGlucHV0RWwuZm9jdXMoKTtcbiAgICAgICAgaWYgKHNldEZvY3VzICYmIChzZXRGb2N1cy50eXBlID09PSAnZm9jdXMnIHx8IHNldEZvY3VzID09PSB0cnVlKSkge1xuICAgICAgICAgIFV0aWxzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgICAgIGVuYWJsZSgpO1xuICAgICAgICAgIH0sIDQwMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZW5hYmxlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG5lZWRzRm9jdXMpIHNiLiRpbnB1dEVsLmZvY3VzKCk7XG4gICAgICBpZiAoYXBwLnRoZW1lID09PSAnbWQnICYmIHNiLmV4cGFuZGFibGUpIHtcbiAgICAgICAgc2IuJGVsLnBhcmVudHMoJy5uYXZiYXItaW5uZXInKS5zY3JvbGxMZWZ0KDApO1xuICAgICAgfVxuICAgICAgZW5hYmxlKCk7XG4gICAgfVxuICAgIHJldHVybiBzYjtcbiAgfVxuICBkaXNhYmxlKCkge1xuICAgIGNvbnN0IHNiID0gdGhpcztcbiAgICBpZiAoIXNiLmVuYWJsZWQpIHJldHVybiBzYjtcbiAgICBjb25zdCBhcHAgPSBzYi5hcHA7XG4gICAgc2IuJGlucHV0RWwudmFsKCcnKS50cmlnZ2VyKCdjaGFuZ2UnKTtcbiAgICBzYi4kZWwucmVtb3ZlQ2xhc3MoJ3NlYXJjaGJhci1lbmFibGVkJyk7XG4gICAgc2IuJGVsLnJlbW92ZUNsYXNzKCdzZWFyY2hiYXItZm9jdXNlZCcpO1xuICAgIGlmICghc2IuZXhwYW5kYWJsZSAmJiBzYi4kZGlzYWJsZUJ1dHRvbkVsICYmIHNiLiRkaXNhYmxlQnV0dG9uRWwubGVuZ3RoID4gMCAmJiBhcHAudGhlbWUgPT09ICdpb3MnKSB7XG4gICAgICBzYi4kZGlzYWJsZUJ1dHRvbkVsLmNzcyhgbWFyZ2luLSR7YXBwLnJ0bCA/ICdsZWZ0JyA6ICdyaWdodCd9YCwgYCR7LXNiLmRpc2FibGVCdXR0b25FbC5vZmZzZXRXaWR0aH1weGApO1xuICAgIH1cblxuICAgIGlmIChzYi4kYmFja2Ryb3BFbCAmJiAoKHNiLiRzZWFyY2hDb250YWluZXIgJiYgc2IuJHNlYXJjaENvbnRhaW5lci5sZW5ndGgpIHx8IHNiLnBhcmFtcy5jdXN0b21TZWFyY2gpKSB7XG4gICAgICBzYi5iYWNrZHJvcEhpZGUoKTtcbiAgICB9XG5cbiAgICBzYi5lbmFibGVkID0gZmFsc2U7XG5cbiAgICBzYi4kaW5wdXRFbC5ibHVyKCk7XG5cbiAgICBpZiAoc2IuJGhpZGVPbkVuYWJsZUVsKSBzYi4kaGlkZU9uRW5hYmxlRWwucmVtb3ZlQ2xhc3MoJ2hpZGRlbi1ieS1zZWFyY2hiYXInKTtcblxuICAgIHNiLiRlbC50cmlnZ2VyKCdzZWFyY2hiYXI6ZGlzYWJsZScpO1xuICAgIHNiLmVtaXQoJ2xvY2FsOjpkaXNhYmxlIHNlYXJjaGJhckRpc2FibGUnLCBzYik7XG4gICAgcmV0dXJuIHNiO1xuICB9XG4gIHRvZ2dsZSgpIHtcbiAgICBjb25zdCBzYiA9IHRoaXM7XG4gICAgaWYgKHNiLmVuYWJsZWQpIHNiLmRpc2FibGUoKTtcbiAgICBlbHNlIHNiLmVuYWJsZSh0cnVlKTtcbiAgICByZXR1cm4gc2I7XG4gIH1cbiAgYmFja2Ryb3BTaG93KCkge1xuICAgIGNvbnN0IHNiID0gdGhpcztcbiAgICBpZiAoc2IuJGJhY2tkcm9wRWwpIHtcbiAgICAgIHNiLiRiYWNrZHJvcEVsLmFkZENsYXNzKCdzZWFyY2hiYXItYmFja2Ryb3AtaW4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHNiO1xuICB9XG4gIGJhY2tkcm9wSGlkZSgpIHtcbiAgICBjb25zdCBzYiA9IHRoaXM7XG4gICAgaWYgKHNiLiRiYWNrZHJvcEVsKSB7XG4gICAgICBzYi4kYmFja2Ryb3BFbC5yZW1vdmVDbGFzcygnc2VhcmNoYmFyLWJhY2tkcm9wLWluJyk7XG4gICAgfVxuICAgIHJldHVybiBzYjtcbiAgfVxuICBzZWFyY2gocXVlcnksIGludGVybmFsKSB7XG4gICAgY29uc3Qgc2IgPSB0aGlzO1xuICAgIGlmIChzYi5wcmV2aW91c1F1ZXJ5ICYmIHF1ZXJ5LnRyaW0oKSA9PT0gc2IucHJldmlvdXNRdWVyeSkgcmV0dXJuIHNiO1xuICAgIGlmICh0eXBlb2YgKHNiLnByZXZpb3VzUXVlcnkpICE9PSAndW5kZWZpbmVkJyAmJiBzYi5wcmV2aW91c1F1ZXJ5LnRyaW0oKSA9PT0gJycgJiYgcXVlcnkudHJpbSgpID09PSAnJykgcmV0dXJuIHNiO1xuICAgIHNiLnByZXZpb3VzUXVlcnkgPSBxdWVyeS50cmltKCk7XG5cbiAgICBpZiAoIWludGVybmFsKSB7XG4gICAgICBpZiAoIXNiLmVuYWJsZWQpIHtcbiAgICAgICAgc2IuZW5hYmxlKCk7XG4gICAgICB9XG4gICAgICBzYi4kaW5wdXRFbC52YWwocXVlcnkpO1xuICAgIH1cbiAgICBzYi5xdWVyeSA9IHF1ZXJ5O1xuICAgIHNiLnZhbHVlID0gcXVlcnk7XG5cbiAgICBjb25zdCB7ICRzZWFyY2hDb250YWluZXIsICRlbCwgJGJhY2tkcm9wRWwsICRmb3VuZEVsLCAkbm90Rm91bmRFbCwgJGhpZGVPblNlYXJjaEVsLCBpc1ZpcnR1YWxMaXN0IH0gPSBzYjtcblxuICAgIC8vIEhpZGUgb24gc2VhcmNoIGVsZW1lbnRcbiAgICBpZiAocXVlcnkubGVuZ3RoID4gMCAmJiAkaGlkZU9uU2VhcmNoRWwpIHtcbiAgICAgICRoaWRlT25TZWFyY2hFbC5hZGRDbGFzcygnaGlkZGVuLWJ5LXNlYXJjaGJhcicpO1xuICAgIH0gZWxzZSBpZiAoJGhpZGVPblNlYXJjaEVsKSB7XG4gICAgICAkaGlkZU9uU2VhcmNoRWwucmVtb3ZlQ2xhc3MoJ2hpZGRlbi1ieS1zZWFyY2hiYXInKTtcbiAgICB9XG4gICAgLy8gQWRkIGFjdGl2ZS9pbmFjdGl2ZSBjbGFzc2VzIG9uIG92ZXJsYXlcbiAgICBpZiAocXVlcnkubGVuZ3RoID09PSAwKSB7XG4gICAgICBpZiAoJHNlYXJjaENvbnRhaW5lciAmJiAkc2VhcmNoQ29udGFpbmVyLmxlbmd0aCAmJiAkZWwuaGFzQ2xhc3MoJ3NlYXJjaGJhci1lbmFibGVkJykgJiYgJGJhY2tkcm9wRWwpIHNiLmJhY2tkcm9wU2hvdygpO1xuICAgIH0gZWxzZSBpZiAoJHNlYXJjaENvbnRhaW5lciAmJiAkc2VhcmNoQ29udGFpbmVyLmxlbmd0aCAmJiAkZWwuaGFzQ2xhc3MoJ3NlYXJjaGJhci1lbmFibGVkJykpIHtcbiAgICAgIHNiLmJhY2tkcm9wSGlkZSgpO1xuICAgIH1cblxuICAgIGlmIChzYi5wYXJhbXMuY3VzdG9tU2VhcmNoKSB7XG4gICAgICAkZWwudHJpZ2dlcignc2VhcmNoYmFyOnNlYXJjaCcsIHF1ZXJ5LCBzYi5wcmV2aW91c1F1ZXJ5KTtcbiAgICAgIHNiLmVtaXQoJ2xvY2FsOjpzZWFyY2ggc2VhcmNoYmFyU2VhcmNoJywgc2IsIHF1ZXJ5LCBzYi5wcmV2aW91c1F1ZXJ5KTtcbiAgICAgIHJldHVybiBzYjtcbiAgICB9XG5cbiAgICBsZXQgZm91bmRJdGVtcyA9IFtdO1xuICAgIGxldCB2bFF1ZXJ5O1xuICAgIGlmIChpc1ZpcnR1YWxMaXN0KSB7XG4gICAgICBzYi52aXJ0dWFsTGlzdCA9ICRzZWFyY2hDb250YWluZXJbMF0uZjdWaXJ0dWFsTGlzdDtcbiAgICAgIGlmIChxdWVyeS50cmltKCkgPT09ICcnKSB7XG4gICAgICAgIHNiLnZpcnR1YWxMaXN0LnJlc2V0RmlsdGVyKCk7XG4gICAgICAgIGlmICgkbm90Rm91bmRFbCkgJG5vdEZvdW5kRWwuaGlkZSgpO1xuICAgICAgICBpZiAoJGZvdW5kRWwpICRmb3VuZEVsLnNob3coKTtcbiAgICAgICAgcmV0dXJuIHNiO1xuICAgICAgfVxuICAgICAgdmxRdWVyeSA9IHNiLnBhcmFtcy5yZW1vdmVEaWFjcml0aWNzID8gVXRpbHMucmVtb3ZlRGlhY3JpdGljcyhxdWVyeSkgOiBxdWVyeTtcbiAgICAgIGlmIChzYi52aXJ0dWFsTGlzdC5wYXJhbXMuc2VhcmNoQWxsKSB7XG4gICAgICAgIGZvdW5kSXRlbXMgPSBzYi52aXJ0dWFsTGlzdC5wYXJhbXMuc2VhcmNoQWxsKHZsUXVlcnksIHNiLnZpcnR1YWxMaXN0Lml0ZW1zKSB8fCBbXTtcbiAgICAgIH0gZWxzZSBpZiAoc2IudmlydHVhbExpc3QucGFyYW1zLnNlYXJjaEJ5SXRlbSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNiLnZpcnR1YWxMaXN0Lml0ZW1zLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgaWYgKHNiLnZpcnR1YWxMaXN0LnBhcmFtcy5zZWFyY2hCeUl0ZW0odmxRdWVyeSwgc2IudmlydHVhbExpc3QucGFyYW1zLml0ZW1zW2ldLCBpKSkge1xuICAgICAgICAgICAgZm91bmRJdGVtcy5wdXNoKGkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgdmFsdWVzO1xuICAgICAgaWYgKHNiLnBhcmFtcy5yZW1vdmVEaWFjcml0aWNzKSB2YWx1ZXMgPSBVdGlscy5yZW1vdmVEaWFjcml0aWNzKHF1ZXJ5LnRyaW0oKS50b0xvd2VyQ2FzZSgpKS5zcGxpdCgnICcpO1xuICAgICAgZWxzZSB7XG4gICAgICAgIHZhbHVlcyA9IHF1ZXJ5LnRyaW0oKS50b0xvd2VyQ2FzZSgpLnNwbGl0KCcgJyk7XG4gICAgICB9XG4gICAgICAkc2VhcmNoQ29udGFpbmVyLmZpbmQoc2IucGFyYW1zLnNlYXJjaEl0ZW0pLnJlbW92ZUNsYXNzKCdoaWRkZW4tYnktc2VhcmNoYmFyJykuZWFjaCgoaXRlbUluZGV4LCBpdGVtRWwpID0+IHtcbiAgICAgICAgY29uc3QgJGl0ZW1FbCA9ICQoaXRlbUVsKTtcbiAgICAgICAgbGV0IGNvbXBhcmVXaXRoVGV4dCA9IFtdO1xuICAgICAgICBsZXQgJHNlYXJjaEluID0gc2IucGFyYW1zLnNlYXJjaEluID8gJGl0ZW1FbC5maW5kKHNiLnBhcmFtcy5zZWFyY2hJbikgOiAkaXRlbUVsO1xuICAgICAgICBpZiAoc2IucGFyYW1zLnNlYXJjaEluID09PSBzYi5wYXJhbXMuc2VhcmNoSXRlbSkge1xuICAgICAgICAgICRzZWFyY2hJbiA9ICRpdGVtRWw7XG4gICAgICAgIH1cbiAgICAgICAgJHNlYXJjaEluLmVhY2goKHNlYXJjaEluSW5kZXgsIHNlYXJjaEluRWwpID0+IHtcbiAgICAgICAgICBsZXQgaXRlbVRleHQgPSAkKHNlYXJjaEluRWwpLnRleHQoKS50cmltKCkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICBpZiAoc2IucGFyYW1zLnJlbW92ZURpYWNyaXRpY3MpIGl0ZW1UZXh0ID0gVXRpbHMucmVtb3ZlRGlhY3JpdGljcyhpdGVtVGV4dCk7XG4gICAgICAgICAgY29tcGFyZVdpdGhUZXh0LnB1c2goaXRlbVRleHQpO1xuICAgICAgICB9KTtcbiAgICAgICAgY29tcGFyZVdpdGhUZXh0ID0gY29tcGFyZVdpdGhUZXh0LmpvaW4oJyAnKTtcbiAgICAgICAgbGV0IHdvcmRzTWF0Y2ggPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgIGlmIChjb21wYXJlV2l0aFRleHQuaW5kZXhPZih2YWx1ZXNbaV0pID49IDApIHdvcmRzTWF0Y2ggKz0gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAod29yZHNNYXRjaCAhPT0gdmFsdWVzLmxlbmd0aCAmJiAhKHNiLnBhcmFtcy5pZ25vcmUgJiYgJGl0ZW1FbC5pcyhzYi5wYXJhbXMuaWdub3JlKSkpIHtcbiAgICAgICAgICAkaXRlbUVsLmFkZENsYXNzKCdoaWRkZW4tYnktc2VhcmNoYmFyJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm91bmRJdGVtcy5wdXNoKCRpdGVtRWxbMF0pO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKHNiLnBhcmFtcy5oaWRlRGl2aWRlcnMpIHtcbiAgICAgICAgJHNlYXJjaENvbnRhaW5lci5maW5kKCcuaXRlbS1kaXZpZGVyLCAubGlzdC1ncm91cC10aXRsZScpLmVhY2goKHRpdGxlSW5kZXgsIHRpdGxlRWwpID0+IHtcbiAgICAgICAgICBjb25zdCAkdGl0bGVFbCA9ICQodGl0bGVFbCk7XG4gICAgICAgICAgY29uc3QgJG5leHRFbGVtZW50cyA9ICR0aXRsZUVsLm5leHRBbGwoJ2xpJyk7XG4gICAgICAgICAgbGV0IGhpZGUgPSB0cnVlO1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgJG5leHRFbGVtZW50cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgY29uc3QgJG5leHRFbCA9ICRuZXh0RWxlbWVudHMuZXEoaSk7XG4gICAgICAgICAgICBpZiAoJG5leHRFbC5oYXNDbGFzcygnbGlzdC1ncm91cC10aXRsZScpIHx8ICRuZXh0RWwuaGFzQ2xhc3MoJ2l0ZW0tZGl2aWRlcicpKSBicmVhaztcbiAgICAgICAgICAgIGlmICghJG5leHRFbC5oYXNDbGFzcygnaGlkZGVuLWJ5LXNlYXJjaGJhcicpKSB7XG4gICAgICAgICAgICAgIGhpZGUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgaWdub3JlID0gc2IucGFyYW1zLmlnbm9yZSAmJiAkdGl0bGVFbC5pcyhzYi5wYXJhbXMuaWdub3JlKTtcbiAgICAgICAgICBpZiAoaGlkZSAmJiAhaWdub3JlKSAkdGl0bGVFbC5hZGRDbGFzcygnaGlkZGVuLWJ5LXNlYXJjaGJhcicpO1xuICAgICAgICAgIGVsc2UgJHRpdGxlRWwucmVtb3ZlQ2xhc3MoJ2hpZGRlbi1ieS1zZWFyY2hiYXInKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoc2IucGFyYW1zLmhpZGVHcm91cHMpIHtcbiAgICAgICAgJHNlYXJjaENvbnRhaW5lci5maW5kKCcubGlzdC1ncm91cCcpLmVhY2goKGdyb3VwSW5kZXgsIGdyb3VwRWwpID0+IHtcbiAgICAgICAgICBjb25zdCAkZ3JvdXBFbCA9ICQoZ3JvdXBFbCk7XG4gICAgICAgICAgY29uc3QgaWdub3JlID0gc2IucGFyYW1zLmlnbm9yZSAmJiAkZ3JvdXBFbC5pcyhzYi5wYXJhbXMuaWdub3JlKTtcbiAgICAgICAgICBjb25zdCBub3RIaWRkZW4gPSAkZ3JvdXBFbC5maW5kKCdsaTpub3QoLmhpZGRlbi1ieS1zZWFyY2hiYXIpJyk7XG4gICAgICAgICAgaWYgKG5vdEhpZGRlbi5sZW5ndGggPT09IDAgJiYgIWlnbm9yZSkge1xuICAgICAgICAgICAgJGdyb3VwRWwuYWRkQ2xhc3MoJ2hpZGRlbi1ieS1zZWFyY2hiYXInKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJGdyb3VwRWwucmVtb3ZlQ2xhc3MoJ2hpZGRlbi1ieS1zZWFyY2hiYXInKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChmb3VuZEl0ZW1zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgaWYgKCRub3RGb3VuZEVsKSAkbm90Rm91bmRFbC5zaG93KCk7XG4gICAgICBpZiAoJGZvdW5kRWwpICRmb3VuZEVsLmhpZGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCRub3RGb3VuZEVsKSAkbm90Rm91bmRFbC5oaWRlKCk7XG4gICAgICBpZiAoJGZvdW5kRWwpICRmb3VuZEVsLnNob3coKTtcbiAgICB9XG4gICAgaWYgKGlzVmlydHVhbExpc3QgJiYgc2IudmlydHVhbExpc3QpIHtcbiAgICAgIHNiLnZpcnR1YWxMaXN0LmZpbHRlckl0ZW1zKGZvdW5kSXRlbXMpO1xuICAgIH1cblxuICAgICRlbC50cmlnZ2VyKCdzZWFyY2hiYXI6c2VhcmNoJywgcXVlcnksIHNiLnByZXZpb3VzUXVlcnksIGZvdW5kSXRlbXMpO1xuICAgIHNiLmVtaXQoJ2xvY2FsOjpzZWFyY2ggc2VhcmNoYmFyU2VhcmNoJywgc2IsIHF1ZXJ5LCBzYi5wcmV2aW91c1F1ZXJ5LCBmb3VuZEl0ZW1zKTtcblxuICAgIHJldHVybiBzYjtcbiAgfVxuICBpbml0KCkge1xuICAgIGNvbnN0IHNiID0gdGhpcztcbiAgICBzYi5hdHRhY2hFdmVudHMoKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIGNvbnN0IHNiID0gdGhpcztcbiAgICBzYi5lbWl0KCdsb2NhbDo6YmVmb3JlRGVzdHJveSBzZWFyY2hiYXJCZWZvcmVEZXN0cm95Jywgc2IpO1xuICAgIHNiLiRlbC50cmlnZ2VyKCdzZWFyY2hiYXI6YmVmb3JlZGVzdHJveScsIHNiKTtcbiAgICBzYi5kZXRhY2hFdmVudHMoKTtcbiAgICBkZWxldGUgc2IuJGVsLmY3U2VhcmNoYmFyO1xuICAgIFV0aWxzLmRlbGV0ZVByb3BzKHNiKTtcbiAgfVxufVxuXG52YXIgU2VhcmNoYmFyJDEgPSB7XG4gIG5hbWU6ICdzZWFyY2hiYXInLFxuICBzdGF0aWM6IHtcbiAgICBTZWFyY2hiYXIsXG4gIH0sXG4gIGNyZWF0ZSgpIHtcbiAgICBjb25zdCBhcHAgPSB0aGlzO1xuICAgIGFwcC5zZWFyY2hiYXIgPSBDb25zdHJ1Y3Rvck1ldGhvZHMoe1xuICAgICAgZGVmYXVsdFNlbGVjdG9yOiAnLnNlYXJjaGJhcicsXG4gICAgICBjb25zdHJ1Y3RvcjogU2VhcmNoYmFyLFxuICAgICAgYXBwLFxuICAgICAgZG9tUHJvcDogJ2Y3U2VhcmNoYmFyJyxcbiAgICAgIGFkZE1ldGhvZHM6ICdjbGVhciBlbmFibGUgZGlzYWJsZSB0b2dnbGUgc2VhcmNoJy5zcGxpdCgnICcpLFxuICAgIH0pO1xuICB9LFxuICBvbjoge1xuICAgIHRhYk1vdW50ZWQodGFiRWwpIHtcbiAgICAgIGNvbnN0IGFwcCA9IHRoaXM7XG4gICAgICAkKHRhYkVsKS5maW5kKCcuc2VhcmNoYmFyLWluaXQnKS5lYWNoKChpbmRleCwgc2VhcmNoYmFyRWwpID0+IHtcbiAgICAgICAgY29uc3QgJHNlYXJjaGJhckVsID0gJChzZWFyY2hiYXJFbCk7XG4gICAgICAgIGFwcC5zZWFyY2hiYXIuY3JlYXRlKFV0aWxzLmV4dGVuZCgkc2VhcmNoYmFyRWwuZGF0YXNldCgpLCB7IGVsOiBzZWFyY2hiYXJFbCB9KSk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIHRhYkJlZm9yZVJlbW92ZSh0YWJFbCkge1xuICAgICAgJCh0YWJFbCkuZmluZCgnLnNlYXJjaGJhci1pbml0JykuZWFjaCgoaW5kZXgsIHNlYXJjaGJhckVsKSA9PiB7XG4gICAgICAgIGlmIChzZWFyY2hiYXJFbC5mN1NlYXJjaGJhciAmJiBzZWFyY2hiYXJFbC5mN1NlYXJjaGJhci5kZXN0cm95KSB7XG4gICAgICAgICAgc2VhcmNoYmFyRWwuZjdTZWFyY2hiYXIuZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LFxuICAgIHBhZ2VJbml0KHBhZ2UpIHtcbiAgICAgIGNvbnN0IGFwcCA9IHRoaXM7XG4gICAgICBwYWdlLiRlbC5maW5kKCcuc2VhcmNoYmFyLWluaXQnKS5lYWNoKChpbmRleCwgc2VhcmNoYmFyRWwpID0+IHtcbiAgICAgICAgY29uc3QgJHNlYXJjaGJhckVsID0gJChzZWFyY2hiYXJFbCk7XG4gICAgICAgIGFwcC5zZWFyY2hiYXIuY3JlYXRlKFV0aWxzLmV4dGVuZCgkc2VhcmNoYmFyRWwuZGF0YXNldCgpLCB7IGVsOiBzZWFyY2hiYXJFbCB9KSk7XG4gICAgICB9KTtcbiAgICAgIGlmIChhcHAudGhlbWUgPT09ICdpb3MnICYmIHBhZ2UudmlldyAmJiBwYWdlLnZpZXcucm91dGVyLnNlcGFyYXRlTmF2YmFyICYmIHBhZ2UuJG5hdmJhckVsICYmIHBhZ2UuJG5hdmJhckVsLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcGFnZS4kbmF2YmFyRWwuZmluZCgnLnNlYXJjaGJhci1pbml0JykuZWFjaCgoaW5kZXgsIHNlYXJjaGJhckVsKSA9PiB7XG4gICAgICAgICAgY29uc3QgJHNlYXJjaGJhckVsID0gJChzZWFyY2hiYXJFbCk7XG4gICAgICAgICAgYXBwLnNlYXJjaGJhci5jcmVhdGUoVXRpbHMuZXh0ZW5kKCRzZWFyY2hiYXJFbC5kYXRhc2V0KCksIHsgZWw6IHNlYXJjaGJhckVsIH0pKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBwYWdlQmVmb3JlUmVtb3ZlKHBhZ2UpIHtcbiAgICAgIGNvbnN0IGFwcCA9IHRoaXM7XG4gICAgICBwYWdlLiRlbC5maW5kKCcuc2VhcmNoYmFyLWluaXQnKS5lYWNoKChpbmRleCwgc2VhcmNoYmFyRWwpID0+IHtcbiAgICAgICAgaWYgKHNlYXJjaGJhckVsLmY3U2VhcmNoYmFyICYmIHNlYXJjaGJhckVsLmY3U2VhcmNoYmFyLmRlc3Ryb3kpIHtcbiAgICAgICAgICBzZWFyY2hiYXJFbC5mN1NlYXJjaGJhci5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKGFwcC50aGVtZSA9PT0gJ2lvcycgJiYgcGFnZS52aWV3ICYmIHBhZ2Uudmlldy5yb3V0ZXIuc2VwYXJhdGVOYXZiYXIgJiYgcGFnZS4kbmF2YmFyRWwgJiYgcGFnZS4kbmF2YmFyRWwubGVuZ3RoID4gMCkge1xuICAgICAgICBwYWdlLiRuYXZiYXJFbC5maW5kKCcuc2VhcmNoYmFyLWluaXQnKS5lYWNoKChpbmRleCwgc2VhcmNoYmFyRWwpID0+IHtcbiAgICAgICAgICBpZiAoc2VhcmNoYmFyRWwuZjdTZWFyY2hiYXIgJiYgc2VhcmNoYmFyRWwuZjdTZWFyY2hiYXIuZGVzdHJveSkge1xuICAgICAgICAgICAgc2VhcmNoYmFyRWwuZjdTZWFyY2hiYXIuZGVzdHJveSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgfSxcbiAgY2xpY2tzOiB7XG4gICAgJy5zZWFyY2hiYXItY2xlYXInOiBmdW5jdGlvbiBjbGVhcigkY2xpY2tlZEVsLCBkYXRhID0ge30pIHtcbiAgICAgIGNvbnN0IGFwcCA9IHRoaXM7XG4gICAgICBjb25zdCBzYiA9IGFwcC5zZWFyY2hiYXIuZ2V0KGRhdGEuc2VhcmNoYmFyKTtcbiAgICAgIGlmIChzYikgc2IuY2xlYXIoKTtcbiAgICB9LFxuICAgICcuc2VhcmNoYmFyLWVuYWJsZSc6IGZ1bmN0aW9uIGVuYWJsZSgkY2xpY2tlZEVsLCBkYXRhID0ge30pIHtcbiAgICAgIGNvbnN0IGFwcCA9IHRoaXM7XG4gICAgICBjb25zdCBzYiA9IGFwcC5zZWFyY2hiYXIuZ2V0KGRhdGEuc2VhcmNoYmFyKTtcbiAgICAgIGlmIChzYikgc2IuZW5hYmxlKHRydWUpO1xuICAgIH0sXG4gICAgJy5zZWFyY2hiYXItZGlzYWJsZSc6IGZ1bmN0aW9uIGRpc2FibGUoJGNsaWNrZWRFbCwgZGF0YSA9IHt9KSB7XG4gICAgICBjb25zdCBhcHAgPSB0aGlzO1xuICAgICAgY29uc3Qgc2IgPSBhcHAuc2VhcmNoYmFyLmdldChkYXRhLnNlYXJjaGJhcik7XG4gICAgICBpZiAoc2IpIHNiLmRpc2FibGUoKTtcbiAgICB9LFxuICAgICcuc2VhcmNoYmFyLXRvZ2dsZSc6IGZ1bmN0aW9uIHRvZ2dsZSgkY2xpY2tlZEVsLCBkYXRhID0ge30pIHtcbiAgICAgIGNvbnN0IGFwcCA9IHRoaXM7XG4gICAgICBjb25zdCBzYiA9IGFwcC5zZWFyY2hiYXIuZ2V0KGRhdGEuc2VhcmNoYmFyKTtcbiAgICAgIGlmIChzYikgc2IudG9nZ2xlKCk7XG4gICAgfSxcbiAgfSxcbn07XG5cbmNsYXNzIE1lc3NhZ2VzIGV4dGVuZHMgRnJhbWV3b3JrN0NsYXNzIHtcbiAgY29uc3RydWN0b3IoYXBwLCBwYXJhbXMgPSB7fSkge1xuICAgIHN1cGVyKHBhcmFtcywgW2FwcF0pO1xuXG4gICAgY29uc3QgbSA9IHRoaXM7XG5cbiAgICBjb25zdCBkZWZhdWx0cyA9IHtcbiAgICAgIGF1dG9MYXlvdXQ6IHRydWUsXG4gICAgICBtZXNzYWdlczogW10sXG4gICAgICBuZXdNZXNzYWdlc0ZpcnN0OiBmYWxzZSxcbiAgICAgIHNjcm9sbE1lc3NhZ2VzOiB0cnVlLFxuICAgICAgc2Nyb2xsTWVzc2FnZXNPbkVkZ2U6IHRydWUsXG4gICAgICBmaXJzdE1lc3NhZ2VSdWxlOiB1bmRlZmluZWQsXG4gICAgICBsYXN0TWVzc2FnZVJ1bGU6IHVuZGVmaW5lZCxcbiAgICAgIHRhaWxNZXNzYWdlUnVsZTogdW5kZWZpbmVkLFxuICAgICAgc2FtZU5hbWVNZXNzYWdlUnVsZTogdW5kZWZpbmVkLFxuICAgICAgc2FtZUhlYWRlck1lc3NhZ2VSdWxlOiB1bmRlZmluZWQsXG4gICAgICBzYW1lRm9vdGVyTWVzc2FnZVJ1bGU6IHVuZGVmaW5lZCxcbiAgICAgIHNhbWVBdmF0YXJNZXNzYWdlUnVsZTogdW5kZWZpbmVkLFxuICAgICAgY3VzdG9tQ2xhc3NNZXNzYWdlUnVsZTogdW5kZWZpbmVkLFxuICAgICAgcmVuZGVyTWVzc2FnZTogdW5kZWZpbmVkLFxuICAgIH07XG5cbiAgICAvLyBFeHRlbmQgZGVmYXVsdHMgd2l0aCBtb2R1bGVzIHBhcmFtc1xuICAgIG0udXNlTW9kdWxlc1BhcmFtcyhkZWZhdWx0cyk7XG5cbiAgICBtLnBhcmFtcyA9IFV0aWxzLmV4dGVuZChkZWZhdWx0cywgcGFyYW1zKTtcblxuICAgIGNvbnN0ICRlbCA9ICQocGFyYW1zLmVsKS5lcSgwKTtcbiAgICBpZiAoJGVsLmxlbmd0aCA9PT0gMCkgcmV0dXJuIG07XG5cbiAgICAkZWxbMF0uZjdNZXNzYWdlcyA9IG07XG5cbiAgICBjb25zdCAkcGFnZUNvbnRlbnRFbCA9ICRlbC5jbG9zZXN0KCcucGFnZS1jb250ZW50JykuZXEoMCk7XG5cbiAgICBVdGlscy5leHRlbmQobSwge1xuICAgICAgbWVzc2FnZXM6IG0ucGFyYW1zLm1lc3NhZ2VzLFxuICAgICAgJGVsLFxuICAgICAgZWw6ICRlbFswXSxcbiAgICAgICRwYWdlQ29udGVudEVsLFxuICAgICAgcGFnZUNvbnRlbnRFbDogJHBhZ2VDb250ZW50RWxbMF0sXG5cbiAgICB9KTtcbiAgICAvLyBJbnN0YWxsIE1vZHVsZXNcbiAgICBtLnVzZU1vZHVsZXMoKTtcblxuICAgIC8vIEluaXRcbiAgICBtLmluaXQoKTtcblxuICAgIHJldHVybiBtO1xuICB9XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICBnZXRNZXNzYWdlRGF0YShtZXNzYWdlRWwpIHtcbiAgICBjb25zdCAkbWVzc2FnZUVsID0gJChtZXNzYWdlRWwpO1xuICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICBuYW1lOiAkbWVzc2FnZUVsLmZpbmQoJy5tZXNzYWdlLW5hbWUnKS5odG1sKCksXG4gICAgICBoZWFkZXI6ICRtZXNzYWdlRWwuZmluZCgnLm1lc3NhZ2UtaGVhZGVyJykuaHRtbCgpLFxuICAgICAgdGV4dEhlYWRlcjogJG1lc3NhZ2VFbC5maW5kKCcubWVzc2FnZS10ZXh0LWhlYWRlcicpLmh0bWwoKSxcbiAgICAgIHRleHRGb290ZXI6ICRtZXNzYWdlRWwuZmluZCgnLm1lc3NhZ2UtdGV4dC1mb290ZXInKS5odG1sKCksXG4gICAgICBmb290ZXI6ICRtZXNzYWdlRWwuZmluZCgnLm1lc3NhZ2UtZm9vdGVyJykuaHRtbCgpLFxuICAgICAgaXNUaXRsZTogJG1lc3NhZ2VFbC5oYXNDbGFzcygnbWVzc2FnZXMtdGl0bGUnKSxcbiAgICAgIHR5cGU6ICRtZXNzYWdlRWwuaGFzQ2xhc3MoJ21lc3NhZ2Utc2VudCcpID8gJ3NlbnQnIDogJ3JlY2VpdmVkJyxcbiAgICAgIHRleHQ6ICRtZXNzYWdlRWwuZmluZCgnLm1lc3NhZ2UtdGV4dCcpLmh0bWwoKSxcbiAgICAgIGltYWdlOiAkbWVzc2FnZUVsLmZpbmQoJy5tZXNzYWdlLWltYWdlJykuaHRtbCgpLFxuICAgICAgaW1hZ2VTcmM6ICRtZXNzYWdlRWwuZmluZCgnLm1lc3NhZ2UtaW1hZ2UgaW1nJykuYXR0cignc3JjJyksXG4gICAgICB0eXBpbmc6ICRtZXNzYWdlRWwuaGFzQ2xhc3MoJ21lc3NhZ2UtdHlwaW5nJyksXG4gICAgfTtcbiAgICBpZiAoZGF0YS5pc1RpdGxlKSB7XG4gICAgICBkYXRhLnRleHQgPSAkbWVzc2FnZUVsLmh0bWwoKTtcbiAgICB9XG4gICAgaWYgKGRhdGEudGV4dCAmJiBkYXRhLnRleHRIZWFkZXIpIHtcbiAgICAgIGRhdGEudGV4dCA9IGRhdGEudGV4dC5yZXBsYWNlKGA8ZGl2IGNsYXNzPVwibWVzc2FnZS10ZXh0LWhlYWRlclwiPiR7ZGF0YS50ZXh0SGVhZGVyfTwvZGl2PmAsICcnKTtcbiAgICB9XG4gICAgaWYgKGRhdGEudGV4dCAmJiBkYXRhLnRleHRGb290ZXIpIHtcbiAgICAgIGRhdGEudGV4dCA9IGRhdGEudGV4dC5yZXBsYWNlKGA8ZGl2IGNsYXNzPVwibWVzc2FnZS10ZXh0LWZvb3RlclwiPiR7ZGF0YS50ZXh0Rm9vdGVyfTwvZGl2PmAsICcnKTtcbiAgICB9XG4gICAgbGV0IGF2YXRhciA9ICRtZXNzYWdlRWwuZmluZCgnLm1lc3NhZ2UtYXZhdGFyJykuY3NzKCdiYWNrZ3JvdW5kLWltYWdlJyk7XG4gICAgaWYgKGF2YXRhciA9PT0gJ25vbmUnIHx8IGF2YXRhciA9PT0gJycpIGF2YXRhciA9IHVuZGVmaW5lZDtcbiAgICBpZiAoYXZhdGFyICYmIHR5cGVvZiBhdmF0YXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICBhdmF0YXIgPSBhdmF0YXIucmVwbGFjZSgndXJsKCcsICcnKS5yZXBsYWNlKCcpJywgJycpLnJlcGxhY2UoL1wiL2csICcnKS5yZXBsYWNlKC8nL2csICcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXZhdGFyID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBkYXRhLmF2YXRhciA9IGF2YXRhcjtcblxuICAgIHJldHVybiBkYXRhO1xuICB9XG4gIGdldE1lc3NhZ2VzRGF0YSgpIHtcbiAgICBjb25zdCBtID0gdGhpcztcbiAgICBjb25zdCBkYXRhID0gW107XG4gICAgbS4kZWwuZmluZCgnLm1lc3NhZ2UsIC5tZXNzYWdlcy10aXRsZScpLmVhY2goKGluZGV4LCBtZXNzYWdlRWwpID0+IHtcbiAgICAgIGRhdGEucHVzaChtLmdldE1lc3NhZ2VEYXRhKG1lc3NhZ2VFbCkpO1xuICAgIH0pO1xuICAgIHJldHVybiBkYXRhO1xuICB9XG4gIHJlbmRlck1lc3NhZ2UobWVzc2FnZVRvUmVuZGVyKSB7XG4gICAgY29uc3QgbSA9IHRoaXM7XG4gICAgY29uc3QgbWVzc2FnZSA9IFV0aWxzLmV4dGVuZCh7XG4gICAgICB0eXBlOiAnc2VudCcsXG4gICAgfSwgbWVzc2FnZVRvUmVuZGVyKTtcbiAgICBpZiAobS5wYXJhbXMucmVuZGVyTWVzc2FnZSkge1xuICAgICAgcmV0dXJuIG0ucGFyYW1zLnJlbmRlck1lc3NhZ2UuY2FsbChtLCBtZXNzYWdlKTtcbiAgICB9XG4gICAgaWYgKG1lc3NhZ2UuaXNUaXRsZSkge1xuICAgICAgcmV0dXJuIGA8ZGl2IGNsYXNzPVwibWVzc2FnZXMtdGl0bGVcIj4ke21lc3NhZ2UudGV4dH08L2Rpdj5gO1xuICAgIH1cbiAgICByZXR1cm4gYFxuICAgICAgPGRpdiBjbGFzcz1cIm1lc3NhZ2UgbWVzc2FnZS0ke21lc3NhZ2UudHlwZX0gJHttZXNzYWdlLmlzVHlwaW5nID8gJ21lc3NhZ2UtdHlwaW5nJyA6ICcnfVwiPlxuICAgICAgICAke21lc3NhZ2UuYXZhdGFyID8gYFxuICAgICAgICA8ZGl2IGNsYXNzPVwibWVzc2FnZS1hdmF0YXJcIiBzdHlsZT1cImJhY2tncm91bmQtaW1hZ2U6dXJsKCR7bWVzc2FnZS5hdmF0YXJ9KVwiPjwvZGl2PlxuICAgICAgICBgIDogJyd9XG4gICAgICAgIDxkaXYgY2xhc3M9XCJtZXNzYWdlLWNvbnRlbnRcIj5cbiAgICAgICAgICAke21lc3NhZ2UubmFtZSA/IGA8ZGl2IGNsYXNzPVwibWVzc2FnZS1uYW1lXCI+JHttZXNzYWdlLm5hbWV9PC9kaXY+YCA6ICcnfVxuICAgICAgICAgICR7bWVzc2FnZS5oZWFkZXIgPyBgPGRpdiBjbGFzcz1cIm1lc3NhZ2UtaGVhZGVyXCI+JHttZXNzYWdlLmhlYWRlcn08L2Rpdj5gIDogJyd9XG4gICAgICAgICAgPGRpdiBjbGFzcz1cIm1lc3NhZ2UtYnViYmxlXCI+XG4gICAgICAgICAgICAke21lc3NhZ2UudGV4dEhlYWRlciA/IGA8ZGl2IGNsYXNzPVwibWVzc2FnZS10ZXh0LWhlYWRlclwiPiR7bWVzc2FnZS50ZXh0SGVhZGVyfTwvZGl2PmAgOiAnJ31cbiAgICAgICAgICAgICR7bWVzc2FnZS5pbWFnZSA/IGA8ZGl2IGNsYXNzPVwibWVzc2FnZS1pbWFnZVwiPiR7bWVzc2FnZS5pbWFnZX08L2Rpdj5gIDogJyd9XG4gICAgICAgICAgICAke21lc3NhZ2UuaW1hZ2VTcmMgJiYgIW1lc3NhZ2UuaW1hZ2UgPyBgPGRpdiBjbGFzcz1cIm1lc3NhZ2UtaW1hZ2VcIj48aW1nIHNyYz1cIiR7bWVzc2FnZS5pbWFnZVNyY31cIj48L2Rpdj5gIDogJyd9XG4gICAgICAgICAgICAke21lc3NhZ2UudGV4dCB8fCBtZXNzYWdlLmlzVHlwaW5nID8gYDxkaXYgY2xhc3M9XCJtZXNzYWdlLXRleHRcIj4ke21lc3NhZ2UudGV4dCB8fCAnJ30ke21lc3NhZ2UuaXNUeXBpbmcgPyAnPGRpdiBjbGFzcz1cIm1lc3NhZ2UtdHlwaW5nLWluZGljYXRvclwiPjxkaXY+PC9kaXY+PGRpdj48L2Rpdj48ZGl2PjwvZGl2PjwvZGl2PicgOiAnJ308L2Rpdj5gIDogJyd9XG4gICAgICAgICAgICAke21lc3NhZ2UudGV4dEZvb3RlciA/IGA8ZGl2IGNsYXNzPVwibWVzc2FnZS10ZXh0LWZvb3RlclwiPiR7bWVzc2FnZS50ZXh0Rm9vdGVyfTwvZGl2PmAgOiAnJ31cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAke21lc3NhZ2UuZm9vdGVyID8gYDxkaXYgY2xhc3M9XCJtZXNzYWdlLWZvb3RlclwiPiR7bWVzc2FnZS5mb290ZXJ9PC9kaXY+YCA6ICcnfVxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIGA7XG4gIH1cbiAgcmVuZGVyTWVzc2FnZXMobWVzc2FnZXNUb1JlbmRlciA9IHRoaXMubWVzc2FnZXMsIG1ldGhvZCA9IHRoaXMucGFyYW1zLm5ld01lc3NhZ2VzRmlyc3QgPyAncHJlcGVuZCcgOiAnYXBwZW5kJykge1xuICAgIGNvbnN0IG0gPSB0aGlzO1xuICAgIGNvbnN0IGh0bWwgPSBtZXNzYWdlc1RvUmVuZGVyLm1hcChtZXNzYWdlID0+IG0ucmVuZGVyTWVzc2FnZShtZXNzYWdlKSkuam9pbignJyk7XG4gICAgbS4kZWxbbWV0aG9kXShodG1sKTtcbiAgfVxuICBpc0ZpcnN0TWVzc2FnZSguLi5hcmdzKSB7XG4gICAgY29uc3QgbSA9IHRoaXM7XG4gICAgaWYgKG0ucGFyYW1zLmZpcnN0TWVzc2FnZVJ1bGUpIHJldHVybiBtLnBhcmFtcy5maXJzdE1lc3NhZ2VSdWxlKC4uLmFyZ3MpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpc0xhc3RNZXNzYWdlKC4uLmFyZ3MpIHtcbiAgICBjb25zdCBtID0gdGhpcztcbiAgICBpZiAobS5wYXJhbXMubGFzdE1lc3NhZ2VSdWxlKSByZXR1cm4gbS5wYXJhbXMubGFzdE1lc3NhZ2VSdWxlKC4uLmFyZ3MpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpc1RhaWxNZXNzYWdlKC4uLmFyZ3MpIHtcbiAgICBjb25zdCBtID0gdGhpcztcbiAgICBpZiAobS5wYXJhbXMudGFpbE1lc3NhZ2VSdWxlKSByZXR1cm4gbS5wYXJhbXMudGFpbE1lc3NhZ2VSdWxlKC4uLmFyZ3MpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpc1NhbWVOYW1lTWVzc2FnZSguLi5hcmdzKSB7XG4gICAgY29uc3QgbSA9IHRoaXM7XG4gICAgaWYgKG0ucGFyYW1zLnNhbWVOYW1lTWVzc2FnZVJ1bGUpIHJldHVybiBtLnBhcmFtcy5zYW1lTmFtZU1lc3NhZ2VSdWxlKC4uLmFyZ3MpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpc1NhbWVIZWFkZXJNZXNzYWdlKC4uLmFyZ3MpIHtcbiAgICBjb25zdCBtID0gdGhpcztcbiAgICBpZiAobS5wYXJhbXMuc2FtZUhlYWRlck1lc3NhZ2VSdWxlKSByZXR1cm4gbS5wYXJhbXMuc2FtZUhlYWRlck1lc3NhZ2VSdWxlKC4uLmFyZ3MpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpc1NhbWVGb290ZXJNZXNzYWdlKC4uLmFyZ3MpIHtcbiAgICBjb25zdCBtID0gdGhpcztcbiAgICBpZiAobS5wYXJhbXMuc2FtZUZvb3Rlck1lc3NhZ2VSdWxlKSByZXR1cm4gbS5wYXJhbXMuc2FtZUZvb3Rlck1lc3NhZ2VSdWxlKC4uLmFyZ3MpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpc1NhbWVBdmF0YXJNZXNzYWdlKC4uLmFyZ3MpIHtcbiAgICBjb25zdCBtID0gdGhpcztcbiAgICBpZiAobS5wYXJhbXMuc2FtZUF2YXRhck1lc3NhZ2VSdWxlKSByZXR1cm4gbS5wYXJhbXMuc2FtZUF2YXRhck1lc3NhZ2VSdWxlKC4uLmFyZ3MpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpc0N1c3RvbUNsYXNzTWVzc2FnZSguLi5hcmdzKSB7XG4gICAgY29uc3QgbSA9IHRoaXM7XG4gICAgaWYgKG0ucGFyYW1zLmN1c3RvbUNsYXNzTWVzc2FnZVJ1bGUpIHJldHVybiBtLnBhcmFtcy5jdXN0b21DbGFzc01lc3NhZ2VSdWxlKC4uLmFyZ3MpO1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgbGF5b3V0KCkge1xuICAgIGNvbnN0IG0gPSB0aGlzO1xuICAgIG0uJGVsLmZpbmQoJy5tZXNzYWdlLCAubWVzc2FnZXMtdGl0bGUnKS5lYWNoKChpbmRleCwgbWVzc2FnZUVsKSA9PiB7XG4gICAgICBjb25zdCAkbWVzc2FnZUVsID0gJChtZXNzYWdlRWwpO1xuICAgICAgaWYgKCFtLm1lc3NhZ2VzKSB7XG4gICAgICAgIG0ubWVzc2FnZXMgPSBtLmdldE1lc3NhZ2VzRGF0YSgpO1xuICAgICAgfVxuICAgICAgY29uc3QgY2xhc3NlcyA9IFtdO1xuICAgICAgY29uc3QgbWVzc2FnZSA9IG0ubWVzc2FnZXNbaW5kZXhdO1xuICAgICAgY29uc3QgcHJldmlvdXNNZXNzYWdlID0gbS5tZXNzYWdlc1tpbmRleCAtIDFdO1xuICAgICAgY29uc3QgbmV4dE1lc3NhZ2UgPSBtLm1lc3NhZ2VzW2luZGV4ICsgMV07XG4gICAgICBpZiAobS5pc0ZpcnN0TWVzc2FnZShtZXNzYWdlLCBwcmV2aW91c01lc3NhZ2UsIG5leHRNZXNzYWdlKSkge1xuICAgICAgICBjbGFzc2VzLnB1c2goJ21lc3NhZ2UtZmlyc3QnKTtcbiAgICAgIH1cbiAgICAgIGlmIChtLmlzTGFzdE1lc3NhZ2UobWVzc2FnZSwgcHJldmlvdXNNZXNzYWdlLCBuZXh0TWVzc2FnZSkpIHtcbiAgICAgICAgY2xhc3Nlcy5wdXNoKCdtZXNzYWdlLWxhc3QnKTtcbiAgICAgIH1cbiAgICAgIGlmIChtLmlzVGFpbE1lc3NhZ2UobWVzc2FnZSwgcHJldmlvdXNNZXNzYWdlLCBuZXh0TWVzc2FnZSkpIHtcbiAgICAgICAgY2xhc3Nlcy5wdXNoKCdtZXNzYWdlLXRhaWwnKTtcbiAgICAgIH1cbiAgICAgIGlmIChtLmlzU2FtZU5hbWVNZXNzYWdlKG1lc3NhZ2UsIHByZXZpb3VzTWVzc2FnZSwgbmV4dE1lc3NhZ2UpKSB7XG4gICAgICAgIGNsYXNzZXMucHVzaCgnbWVzc2FnZS1zYW1lLW5hbWUnKTtcbiAgICAgIH1cbiAgICAgIGlmIChtLmlzU2FtZUhlYWRlck1lc3NhZ2UobWVzc2FnZSwgcHJldmlvdXNNZXNzYWdlLCBuZXh0TWVzc2FnZSkpIHtcbiAgICAgICAgY2xhc3Nlcy5wdXNoKCdtZXNzYWdlLXNhbWUtaGVhZGVyJyk7XG4gICAgICB9XG4gICAgICBpZiAobS5pc1NhbWVGb290ZXJNZXNzYWdlKG1lc3NhZ2UsIHByZXZpb3VzTWVzc2FnZSwgbmV4dE1lc3NhZ2UpKSB7XG4gICAgICAgIGNsYXNzZXMucHVzaCgnbWVzc2FnZS1zYW1lLWZvb3RlcicpO1xuICAgICAgfVxuICAgICAgaWYgKG0uaXNTYW1lQXZhdGFyTWVzc2FnZShtZXNzYWdlLCBwcmV2aW91c01lc3NhZ2UsIG5leHRNZXNzYWdlKSkge1xuICAgICAgICBjbGFzc2VzLnB1c2goJ21lc3NhZ2Utc2FtZS1hdmF0YXInKTtcbiAgICAgIH1cbiAgICAgIGxldCBjdXN0b21NZXNzYWdlQ2xhc3NlcyA9IG0uaXNDdXN0b21DbGFzc01lc3NhZ2UobWVzc2FnZSwgcHJldmlvdXNNZXNzYWdlLCBuZXh0TWVzc2FnZSk7XG4gICAgICBpZiAoY3VzdG9tTWVzc2FnZUNsYXNzZXMgJiYgY3VzdG9tTWVzc2FnZUNsYXNzZXMubGVuZ3RoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY3VzdG9tTWVzc2FnZUNsYXNzZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgY3VzdG9tTWVzc2FnZUNsYXNzZXMgPSBjdXN0b21NZXNzYWdlQ2xhc3Nlcy5zcGxpdCgnICcpO1xuICAgICAgICB9XG4gICAgICAgIGN1c3RvbU1lc3NhZ2VDbGFzc2VzLmZvckVhY2goKGN1c3RvbUNsYXNzKSA9PiB7XG4gICAgICAgICAgY2xhc3Nlcy5wdXNoKGN1c3RvbUNsYXNzKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICAkbWVzc2FnZUVsLnJlbW92ZUNsYXNzKCdtZXNzYWdlLWZpcnN0IG1lc3NhZ2UtbGFzdCBtZXNzYWdlLXRhaWwgbWVzc2FnZS1zYW1lLW5hbWUgbWVzc2FnZS1zYW1lLWhlYWRlciBtZXNzYWdlLXNhbWUtZm9vdGVyIG1lc3NhZ2Utc2FtZS1hdmF0YXInKTtcbiAgICAgIGNsYXNzZXMuZm9yRWFjaCgoY2xhc3NOYW1lKSA9PiB7XG4gICAgICAgICRtZXNzYWdlRWwuYWRkQ2xhc3MoY2xhc3NOYW1lKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIGNsZWFyKCkge1xuICAgIGNvbnN0IG0gPSB0aGlzO1xuICAgIG0ubWVzc2FnZXMgPSBbXTtcbiAgICBtLiRlbC5odG1sKCcnKTtcbiAgfVxuICByZW1vdmVNZXNzYWdlKG1lc3NhZ2VUb1JlbW92ZSwgbGF5b3V0ID0gdHJ1ZSkge1xuICAgIGNvbnN0IG0gPSB0aGlzO1xuICAgIC8vIEluZGV4IG9yIEVsXG4gICAgbGV0IGluZGV4O1xuICAgIGxldCAkZWw7XG4gICAgaWYgKHR5cGVvZiBtZXNzYWdlVG9SZW1vdmUgPT09ICdudW1iZXInKSB7XG4gICAgICBpbmRleCA9IG1lc3NhZ2VUb1JlbW92ZTtcbiAgICAgICRlbCA9IG0uJGVsLmZpbmQoJy5tZXNzYWdlLCAubWVzc2FnZXMtdGl0bGUnKS5lcShpbmRleCk7XG4gICAgfSBlbHNlIGlmIChtLm1lc3NhZ2VzICYmIG0ubWVzc2FnZXMuaW5kZXhPZihtZXNzYWdlVG9SZW1vdmUpID49IDApIHtcbiAgICAgIGluZGV4ID0gbS5tZXNzYWdlcy5pbmRleE9mKG1lc3NhZ2VUb1JlbW92ZSk7XG4gICAgICAkZWwgPSBtLiRlbC5jaGlsZHJlbigpLmVxKGluZGV4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgJGVsID0gJChtZXNzYWdlVG9SZW1vdmUpO1xuICAgICAgaW5kZXggPSAkZWwuaW5kZXgoKTtcbiAgICB9XG4gICAgaWYgKCRlbC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBtO1xuICAgIH1cbiAgICAkZWwucmVtb3ZlKCk7XG4gICAgbS5tZXNzYWdlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIGlmIChtLnBhcmFtcy5hdXRvTGF5b3V0ICYmIGxheW91dCkgbS5sYXlvdXQoKTtcbiAgICByZXR1cm4gbTtcbiAgfVxuICByZW1vdmVNZXNzYWdlcyhtZXNzYWdlc1RvUmVtb3ZlLCBsYXlvdXQgPSB0cnVlKSB7XG4gICAgY29uc3QgbSA9IHRoaXM7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobWVzc2FnZXNUb1JlbW92ZSkpIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2VzVG9SZW1vdmVFbHMgPSBbXTtcbiAgICAgIG1lc3NhZ2VzVG9SZW1vdmUuZm9yRWFjaCgobWVzc2FnZVRvUmVtb3ZlSW5kZXgpID0+IHtcbiAgICAgICAgbWVzc2FnZXNUb1JlbW92ZUVscy5wdXNoKG0uJGVsLmZpbmQoJy5tZXNzYWdlLCAubWVzc2FnZXMtdGl0bGUnKS5lcShtZXNzYWdlVG9SZW1vdmVJbmRleCkpO1xuICAgICAgfSk7XG4gICAgICBtZXNzYWdlc1RvUmVtb3ZlRWxzLmZvckVhY2goKG1lc3NhZ2VUb1JlbW92ZSkgPT4ge1xuICAgICAgICBtLnJlbW92ZU1lc3NhZ2UobWVzc2FnZVRvUmVtb3ZlLCBmYWxzZSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgJChtZXNzYWdlc1RvUmVtb3ZlKS5lYWNoKChpbmRleCwgbWVzc2FnZVRvUmVtb3ZlKSA9PiB7XG4gICAgICAgIG0ucmVtb3ZlTWVzc2FnZShtZXNzYWdlVG9SZW1vdmUsIGZhbHNlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAobS5wYXJhbXMuYXV0b0xheW91dCAmJiBsYXlvdXQpIG0ubGF5b3V0KCk7XG4gICAgcmV0dXJuIG07XG4gIH1cblxuICBhZGRNZXNzYWdlKC4uLmFyZ3MpIHtcbiAgICBjb25zdCBtID0gdGhpcztcbiAgICBsZXQgbWVzc2FnZVRvQWRkO1xuICAgIGxldCBhbmltYXRlO1xuICAgIGxldCBtZXRob2Q7XG4gICAgaWYgKHR5cGVvZiBhcmdzWzFdID09PSAnYm9vbGVhbicpIHtcbiAgICAgIFttZXNzYWdlVG9BZGQsIGFuaW1hdGUsIG1ldGhvZF0gPSBhcmdzO1xuICAgIH0gZWxzZSB7XG4gICAgICBbbWVzc2FnZVRvQWRkLCBtZXRob2QsIGFuaW1hdGVdID0gYXJncztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBhbmltYXRlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgYW5pbWF0ZSA9IHRydWU7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgbWV0aG9kID09PSAndW5kZWZpbmVkJykge1xuICAgICAgbWV0aG9kID0gbS5wYXJhbXMubmV3TWVzc2FnZXNGaXJzdCA/ICdwcmVwZW5kJyA6ICdhcHBlbmQnO1xuICAgIH1cblxuICAgIHJldHVybiBtLmFkZE1lc3NhZ2VzKFttZXNzYWdlVG9BZGRdLCBhbmltYXRlLCBtZXRob2QpO1xuICB9XG4gIGFkZE1lc3NhZ2VzKC4uLmFyZ3MpIHtcbiAgICBjb25zdCBtID0gdGhpcztcbiAgICBsZXQgbWVzc2FnZXNUb0FkZDtcbiAgICBsZXQgYW5pbWF0ZTtcbiAgICBsZXQgbWV0aG9kO1xuICAgIGlmICh0eXBlb2YgYXJnc1sxXSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICBbbWVzc2FnZXNUb0FkZCwgYW5pbWF0ZSwgbWV0aG9kXSA9IGFyZ3M7XG4gICAgfSBlbHNlIHtcbiAgICAgIFttZXNzYWdlc1RvQWRkLCBtZXRob2QsIGFuaW1hdGVdID0gYXJncztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBhbmltYXRlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgYW5pbWF0ZSA9IHRydWU7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgbWV0aG9kID09PSAndW5kZWZpbmVkJykge1xuICAgICAgbWV0aG9kID0gbS5wYXJhbXMubmV3TWVzc2FnZXNGaXJzdCA/ICdwcmVwZW5kJyA6ICdhcHBlbmQnO1xuICAgIH1cblxuICAgIC8vIERlZmluZSBzY3JvbGwgcG9zaXRpb25zIGJlZm9yZSBuZXcgbWVzc2FnZXMgYWRkZWRcbiAgICBjb25zdCBzY3JvbGxIZWlnaHRCZWZvcmUgPSBtLnBhZ2VDb250ZW50RWwuc2Nyb2xsSGVpZ2h0O1xuICAgIGNvbnN0IGhlaWdodEJlZm9yZSA9IG0ucGFnZUNvbnRlbnRFbC5vZmZzZXRIZWlnaHQ7XG4gICAgY29uc3Qgc2Nyb2xsQmVmb3JlID0gbS5wYWdlQ29udGVudEVsLnNjcm9sbFRvcDtcblxuICAgIC8vIEFkZCBtZXNzYWdlIHRvIERPTSBhbmQgZGF0YVxuICAgIGxldCBtZXNzYWdlc0hUTUwgPSAnJztcbiAgICBjb25zdCB0eXBpbmdNZXNzYWdlID0gbS5tZXNzYWdlcy5maWx0ZXIoZWwgPT4gZWwuaXNUeXBpbmcpWzBdO1xuICAgIG1lc3NhZ2VzVG9BZGQuZm9yRWFjaCgobWVzc2FnZVRvQWRkKSA9PiB7XG4gICAgICBpZiAodHlwaW5nTWVzc2FnZSkge1xuICAgICAgICBpZiAobWV0aG9kID09PSAnYXBwZW5kJykge1xuICAgICAgICAgIG0ubWVzc2FnZXMuc3BsaWNlKG0ubWVzc2FnZXMuaW5kZXhPZih0eXBpbmdNZXNzYWdlKSwgMCwgbWVzc2FnZVRvQWRkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtLm1lc3NhZ2VzLnNwbGljZShtLm1lc3NhZ2VzLmluZGV4T2YodHlwaW5nTWVzc2FnZSkgKyAxLCAwLCBtZXNzYWdlVG9BZGQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtLm1lc3NhZ2VzW21ldGhvZCA9PT0gJ2FwcGVuZCcgPyAncHVzaCcgOiAndW5zaGlmdCddKG1lc3NhZ2VUb0FkZCk7XG4gICAgICB9XG4gICAgICBtZXNzYWdlc0hUTUwgKz0gbS5yZW5kZXJNZXNzYWdlKG1lc3NhZ2VUb0FkZCk7XG4gICAgfSk7XG4gICAgY29uc3QgJG1lc3NhZ2VzRWxzID0gJChtZXNzYWdlc0hUTUwpO1xuICAgIGlmIChhbmltYXRlKSB7XG4gICAgICBpZiAobWV0aG9kID09PSAnYXBwZW5kJyAmJiAhbS5wYXJhbXMubmV3TWVzc2FnZXNGaXJzdCkge1xuICAgICAgICAkbWVzc2FnZXNFbHMuYWRkQ2xhc3MoJ21lc3NhZ2UtYXBwZWFyLWZyb20tYm90dG9tJyk7XG4gICAgICB9XG4gICAgICBpZiAobWV0aG9kID09PSAncHJlcGVuZCcgJiYgbS5wYXJhbXMubmV3TWVzc2FnZXNGaXJzdCkge1xuICAgICAgICAkbWVzc2FnZXNFbHMuYWRkQ2xhc3MoJ21lc3NhZ2UtYXBwZWFyLWZyb20tdG9wJyk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBpbmdNZXNzYWdlKSB7XG4gICAgICBpZiAobWV0aG9kID09PSAnYXBwZW5kJykge1xuICAgICAgICAkbWVzc2FnZXNFbHMuaW5zZXJ0QmVmb3JlKG0uJGVsLmZpbmQoJy5tZXNzYWdlLXR5cGluZycpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICRtZXNzYWdlc0Vscy5pbnNlcnRBZnRlcihtLiRlbC5maW5kKCcubWVzc2FnZS10eXBpbmcnKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG0uJGVsW21ldGhvZF0oJG1lc3NhZ2VzRWxzKTtcbiAgICB9XG5cbiAgICAvLyBMYXlvdXRcbiAgICBpZiAobS5wYXJhbXMuYXV0b0xheW91dCkgbS5sYXlvdXQoKTtcblxuICAgIGlmIChtZXRob2QgPT09ICdwcmVwZW5kJyAmJiAhdHlwaW5nTWVzc2FnZSkge1xuICAgICAgbS5wYWdlQ29udGVudEVsLnNjcm9sbFRvcCA9IHNjcm9sbEJlZm9yZSArIChtLnBhZ2VDb250ZW50RWwuc2Nyb2xsSGVpZ2h0IC0gc2Nyb2xsSGVpZ2h0QmVmb3JlKTtcbiAgICB9XG5cbiAgICBpZiAobS5wYXJhbXMuc2Nyb2xsTWVzc2FnZXMgJiYgKChtZXRob2QgPT09ICdhcHBlbmQnICYmICFtLnBhcmFtcy5uZXdNZXNzYWdlc0ZpcnN0KSB8fCAobWV0aG9kID09PSAncHJlcGVuZCcgJiYgbS5wYXJhbXMubmV3TWVzc2FnZXNGaXJzdCAmJiAhdHlwaW5nTWVzc2FnZSkpKSB7XG4gICAgICBpZiAobS5wYXJhbXMuc2Nyb2xsTWVzc2FnZXNPbkVkZ2UpIHtcbiAgICAgICAgbGV0IG9uRWRnZSA9IGZhbHNlO1xuICAgICAgICBpZiAobS5wYXJhbXMubmV3TWVzc2FnZXNGaXJzdCAmJiBzY3JvbGxCZWZvcmUgPT09IDApIHtcbiAgICAgICAgICBvbkVkZ2UgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbS5wYXJhbXMubmV3TWVzc2FnZXNGaXJzdCAmJiAoc2Nyb2xsQmVmb3JlIC0gKHNjcm9sbEhlaWdodEJlZm9yZSAtIGhlaWdodEJlZm9yZSkgPj0gLTEwKSkge1xuICAgICAgICAgIG9uRWRnZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uRWRnZSkgbS5zY3JvbGwoYW5pbWF0ZSA/IHVuZGVmaW5lZCA6IDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbS5zY3JvbGwoYW5pbWF0ZSA/IHVuZGVmaW5lZCA6IDApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtO1xuICB9XG4gIHNob3dUeXBpbmcobWVzc2FnZSA9IHt9KSB7XG4gICAgY29uc3QgbSA9IHRoaXM7XG4gICAgY29uc3QgdHlwaW5nTWVzc2FnZSA9IG0ubWVzc2FnZXMuZmlsdGVyKGVsID0+IGVsLmlzVHlwaW5nKVswXTtcbiAgICBpZiAodHlwaW5nTWVzc2FnZSkge1xuICAgICAgbS5yZW1vdmVNZXNzYWdlKG0ubWVzc2FnZXMuaW5kZXhPZih0eXBpbmdNZXNzYWdlKSk7XG4gICAgfVxuICAgIG0uYWRkTWVzc2FnZShVdGlscy5leHRlbmQoe1xuICAgICAgdHlwZTogJ3JlY2VpdmVkJyxcbiAgICAgIGlzVHlwaW5nOiB0cnVlLFxuICAgIH0sIG1lc3NhZ2UpKTtcbiAgICByZXR1cm4gbTtcbiAgfVxuICBoaWRlVHlwaW5nKCkge1xuICAgIGNvbnN0IG0gPSB0aGlzO1xuICAgIGxldCB0eXBpbmdNZXNzYWdlSW5kZXg7XG4gICAgbGV0IHR5cGluZ0ZvdW5kO1xuICAgIG0ubWVzc2FnZXMuZm9yRWFjaCgobWVzc2FnZSwgaW5kZXgpID0+IHtcbiAgICAgIGlmIChtZXNzYWdlLmlzVHlwaW5nKSB0eXBpbmdNZXNzYWdlSW5kZXggPSBpbmRleDtcbiAgICB9KTtcbiAgICBpZiAodHlwZW9mIHR5cGluZ01lc3NhZ2VJbmRleCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGlmIChtLiRlbC5maW5kKCcubWVzc2FnZScpLmVxKHR5cGluZ01lc3NhZ2VJbmRleCkuaGFzQ2xhc3MoJ21lc3NhZ2UtdHlwaW5nJykpIHtcbiAgICAgICAgdHlwaW5nRm91bmQgPSB0cnVlO1xuICAgICAgICBtLnJlbW92ZU1lc3NhZ2UodHlwaW5nTWVzc2FnZUluZGV4KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCF0eXBpbmdGb3VuZCkge1xuICAgICAgY29uc3QgJHR5cGluZ01lc3NhZ2VFbCA9IG0uJGVsLmZpbmQoJy5tZXNzYWdlLXR5cGluZycpO1xuICAgICAgaWYgKCR0eXBpbmdNZXNzYWdlRWwubGVuZ3RoKSB7XG4gICAgICAgIG0ucmVtb3ZlTWVzc2FnZSgkdHlwaW5nTWVzc2FnZUVsKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG07XG4gIH1cbiAgc2Nyb2xsKGR1cmF0aW9uID0gMzAwLCBzY3JvbGxUb3ApIHtcbiAgICBjb25zdCBtID0gdGhpcztcbiAgICBjb25zdCBjdXJyZW50U2Nyb2xsID0gbS5wYWdlQ29udGVudEVsLnNjcm9sbFRvcDtcbiAgICBsZXQgbmV3U2Nyb2xsVG9wO1xuICAgIGlmICh0eXBlb2Ygc2Nyb2xsVG9wICE9PSAndW5kZWZpbmVkJykgbmV3U2Nyb2xsVG9wID0gc2Nyb2xsVG9wO1xuICAgIGVsc2Uge1xuICAgICAgbmV3U2Nyb2xsVG9wID0gbS5wYXJhbXMubmV3TWVzc2FnZXNGaXJzdCA/IDAgOiBtLnBhZ2VDb250ZW50RWwuc2Nyb2xsSGVpZ2h0IC0gbS5wYWdlQ29udGVudEVsLm9mZnNldEhlaWdodDtcbiAgICAgIGlmIChuZXdTY3JvbGxUb3AgPT09IGN1cnJlbnRTY3JvbGwpIHJldHVybiBtO1xuICAgIH1cbiAgICBtLiRwYWdlQ29udGVudEVsLnNjcm9sbFRvcChuZXdTY3JvbGxUb3AsIGR1cmF0aW9uKTtcbiAgICByZXR1cm4gbTtcbiAgfVxuICBpbml0KCkge1xuICAgIGNvbnN0IG0gPSB0aGlzO1xuICAgIGlmICghbS5tZXNzYWdlcyB8fCBtLm1lc3NhZ2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgbS5tZXNzYWdlcyA9IG0uZ2V0TWVzc2FnZXNEYXRhKCk7XG4gICAgfVxuICAgIGlmIChtLnBhcmFtcy5tZXNzYWdlcyAmJiBtLnBhcmFtcy5tZXNzYWdlcy5sZW5ndGgpIHtcbiAgICAgIG0ucmVuZGVyTWVzc2FnZXMoKTtcbiAgICB9XG4gICAgaWYgKG0ucGFyYW1zLmF1dG9MYXlvdXQpIG0ubGF5b3V0KCk7XG4gICAgaWYgKG0ucGFyYW1zLnNjcm9sbE1lc3NhZ2VzKSBtLnNjcm9sbCgwKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIGNvbnN0IG0gPSB0aGlzO1xuICAgIG0uZW1pdCgnbG9jYWw6OmJlZm9yZURlc3Ryb3kgbWVzc2FnZXNCZWZvcmVEZXN0cm95JywgbSk7XG4gICAgbS4kZWwudHJpZ2dlcignbWVzc2FnZXM6YmVmb3JlZGVzdHJveScsIG0pO1xuICAgIG0uJGVsWzBdLmY3TWVzc2FnZXMgPSBudWxsO1xuICAgIGRlbGV0ZSBtLiRlbFswXS5mN01lc3NhZ2VzO1xuICAgIFV0aWxzLmRlbGV0ZVByb3BzKG0pO1xuICB9XG59XG5cbnZhciBNZXNzYWdlcyQxID0ge1xuICBuYW1lOiAnbWVzc2FnZXMnLFxuICBzdGF0aWM6IHtcbiAgICBNZXNzYWdlcyxcbiAgfSxcbiAgY3JlYXRlKCkge1xuICAgIGNvbnN0IGFwcCA9IHRoaXM7XG4gICAgYXBwLm1lc3NhZ2VzID0gQ29uc3RydWN0b3JNZXRob2RzKHtcbiAgICAgIGRlZmF1bHRTZWxlY3RvcjogJy5tZXNzYWdlcycsXG4gICAgICBjb25zdHJ1Y3RvcjogTWVzc2FnZXMsXG4gICAgICBhcHAsXG4gICAgICBkb21Qcm9wOiAnZjdNZXNzYWdlcycsXG4gICAgICBhZGRNZXRob2RzOiAncmVuZGVyTWVzc2FnZXMgbGF5b3V0IHNjcm9sbCBjbGVhciByZW1vdmVNZXNzYWdlIHJlbW92ZU1lc3NhZ2VzIGFkZE1lc3NhZ2UgYWRkTWVzc2FnZXMnLnNwbGl0KCcgJyksXG4gICAgfSk7XG4gIH0sXG4gIG9uOiB7XG4gICAgdGFiQmVmb3JlUmVtb3ZlKHRhYkVsKSB7XG4gICAgICBjb25zdCBhcHAgPSB0aGlzO1xuICAgICAgJCh0YWJFbCkuZmluZCgnLm1lc3NhZ2VzLWluaXQnKS5lYWNoKChpbmRleCwgbWVzc2FnZXNFbCkgPT4ge1xuICAgICAgICBhcHAubWVzc2FnZXMuZGVzdHJveShtZXNzYWdlc0VsKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgdGFiTW91bnRlZCh0YWJFbCkge1xuICAgICAgY29uc3QgYXBwID0gdGhpcztcbiAgICAgICQodGFiRWwpLmZpbmQoJy5tZXNzYWdlcy1pbml0JykuZWFjaCgoaW5kZXgsIG1lc3NhZ2VzRWwpID0+IHtcbiAgICAgICAgYXBwLm1lc3NhZ2VzLmNyZWF0ZSh7IGVsOiBtZXNzYWdlc0VsIH0pO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBwYWdlQmVmb3JlUmVtb3ZlKHBhZ2UpIHtcbiAgICAgIGNvbnN0IGFwcCA9IHRoaXM7XG4gICAgICBwYWdlLiRlbC5maW5kKCcubWVzc2FnZXMtaW5pdCcpLmVhY2goKGluZGV4LCBtZXNzYWdlc0VsKSA9PiB7XG4gICAgICAgIGFwcC5tZXNzYWdlcy5kZXN0cm95KG1lc3NhZ2VzRWwpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBwYWdlSW5pdChwYWdlKSB7XG4gICAgICBjb25zdCBhcHAgPSB0aGlzO1xuICAgICAgcGFnZS4kZWwuZmluZCgnLm1lc3NhZ2VzLWluaXQnKS5lYWNoKChpbmRleCwgbWVzc2FnZXNFbCkgPT4ge1xuICAgICAgICBhcHAubWVzc2FnZXMuY3JlYXRlKHsgZWw6IG1lc3NhZ2VzRWwgfSk7XG4gICAgICB9KTtcbiAgICB9LFxuICB9LFxuICBjbGlja3M6IHtcblxuICB9LFxufTtcblxuY2xhc3MgTWVzc2FnZWJhciBleHRlbmRzIEZyYW1ld29yazdDbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGFwcCwgcGFyYW1zID0ge30pIHtcbiAgICBzdXBlcihwYXJhbXMsIFthcHBdKTtcblxuICAgIGNvbnN0IG1lc3NhZ2ViYXIgPSB0aGlzO1xuXG4gICAgY29uc3QgZGVmYXVsdHMgPSB7XG4gICAgICB0b3A6IGZhbHNlLFxuICAgICAgdG9wT2Zmc2V0OiAwLFxuICAgICAgYm90dG9tT2Zmc2V0OiAwLFxuICAgICAgYXR0YWNobWVudHM6IFtdLFxuICAgICAgcmVuZGVyQXR0YWNobWVudHM6IHVuZGVmaW5lZCxcbiAgICAgIHJlbmRlckF0dGFjaG1lbnQ6IHVuZGVmaW5lZCxcbiAgICAgIG1heEhlaWdodDogbnVsbCxcbiAgICAgIHJlc2l6ZVBhZ2U6IHRydWUsXG4gICAgfTtcblxuICAgIC8vIEV4dGVuZCBkZWZhdWx0cyB3aXRoIG1vZHVsZXMgcGFyYW1zXG4gICAgbWVzc2FnZWJhci51c2VNb2R1bGVzUGFyYW1zKGRlZmF1bHRzKTtcblxuICAgIG1lc3NhZ2ViYXIucGFyYW1zID0gVXRpbHMuZXh0ZW5kKGRlZmF1bHRzLCBwYXJhbXMpO1xuXG4gICAgLy8gRWxcbiAgICBjb25zdCAkZWwgPSAkKG1lc3NhZ2ViYXIucGFyYW1zLmVsKTtcbiAgICBpZiAoJGVsLmxlbmd0aCA9PT0gMCkgcmV0dXJuIG1lc3NhZ2ViYXI7XG5cbiAgICAkZWxbMF0uZjdNZXNzYWdlYmFyID0gbWVzc2FnZWJhcjtcblxuICAgIC8vIFBhZ2UgYW5kIFBhZ2VDb250ZW50XG4gICAgY29uc3QgJHBhZ2VFbCA9ICRlbC5wYXJlbnRzKCcucGFnZScpLmVxKDApO1xuICAgIGNvbnN0ICRwYWdlQ29udGVudEVsID0gJHBhZ2VFbC5maW5kKCcucGFnZS1jb250ZW50JykuZXEoMCk7XG5cbiAgICAvLyBBcmVhXG4gICAgY29uc3QgJGFyZWFFbCA9ICRlbC5maW5kKCcubWVzc2FnZWJhci1hcmVhJyk7XG5cbiAgICAvLyBUZXh0YXJlYVxuICAgIGxldCAkdGV4dGFyZWFFbDtcbiAgICBpZiAobWVzc2FnZWJhci5wYXJhbXMudGV4dGFyZWFFbCkge1xuICAgICAgJHRleHRhcmVhRWwgPSAkKG1lc3NhZ2ViYXIucGFyYW1zLnRleHRhcmVhRWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICAkdGV4dGFyZWFFbCA9ICRlbC5maW5kKCd0ZXh0YXJlYScpO1xuICAgIH1cblxuICAgIC8vIEF0dGFjaG1lbnRzICYgTGlicmFyeVxuICAgIGNvbnN0ICRhdHRhY2htZW50c0VsID0gJGVsLmZpbmQoJy5tZXNzYWdlYmFyLWF0dGFjaG1lbnRzJyk7XG4gICAgY29uc3QgJHNoZWV0RWwgPSAkZWwuZmluZCgnLm1lc3NhZ2ViYXItc2hlZXQnKTtcblxuICAgIGlmIChtZXNzYWdlYmFyLnBhcmFtcy50b3ApIHtcbiAgICAgICRlbC5hZGRDbGFzcygnbWVzc2FnZWJhci10b3AnKTtcbiAgICB9XG5cbiAgICBVdGlscy5leHRlbmQobWVzc2FnZWJhciwge1xuICAgICAgJGVsLFxuICAgICAgZWw6ICRlbFswXSxcbiAgICAgICRhcmVhRWwsXG4gICAgICBhcmVhRWw6ICRhcmVhRWxbMF0sXG4gICAgICAkdGV4dGFyZWFFbCxcbiAgICAgIHRleHRhcmVhRWw6ICR0ZXh0YXJlYUVsWzBdLFxuICAgICAgJGF0dGFjaG1lbnRzRWwsXG4gICAgICBhdHRhY2htZW50c0VsOiAkYXR0YWNobWVudHNFbFswXSxcbiAgICAgIGF0dGFjaG1lbnRzVmlzaWJsZTogJGF0dGFjaG1lbnRzRWwuaGFzQ2xhc3MoJ21lc3NhZ2ViYXItYXR0YWNobWVudHMtdmlzaWJsZScpLFxuICAgICAgJHNoZWV0RWwsXG4gICAgICBzaGVldEVsOiAkc2hlZXRFbFswXSxcbiAgICAgIHNoZWV0VmlzaWJsZTogJHNoZWV0RWwuaGFzQ2xhc3MoJ21lc3NhZ2ViYXItc2hlZXQtdmlzaWJsZScpLFxuICAgICAgJHBhZ2VFbCxcbiAgICAgIHBhZ2VFbDogJHBhZ2VFbFswXSxcbiAgICAgICRwYWdlQ29udGVudEVsLFxuICAgICAgcGFnZUNvbnRlbnRFbDogJHBhZ2VDb250ZW50RWwsXG4gICAgICB0b3A6ICRlbC5oYXNDbGFzcygnbWVzc2FnZWJhci10b3AnKSB8fCBtZXNzYWdlYmFyLnBhcmFtcy50b3AsXG4gICAgICBhdHRhY2htZW50czogW10sXG4gICAgfSk7XG5cbiAgICAvLyBFdmVudHNcbiAgICBmdW5jdGlvbiBvbkFwcFJlc2l6ZSgpIHtcbiAgICAgIGlmIChtZXNzYWdlYmFyLnBhcmFtcy5yZXNpemVQYWdlKSB7XG4gICAgICAgIG1lc3NhZ2ViYXIucmVzaXplUGFnZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBvblN1Ym1pdChlKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uQXR0YWNobWVudENsaWNrKGUpIHtcbiAgICAgIGNvbnN0IGluZGV4ID0gJCh0aGlzKS5pbmRleCgpO1xuICAgICAgaWYgKCQoZS50YXJnZXQpLmNsb3Nlc3QoJy5tZXNzYWdlYmFyLWF0dGFjaG1lbnQtZGVsZXRlJykubGVuZ3RoKSB7XG4gICAgICAgICQodGhpcykudHJpZ2dlcignbWVzc2FnZWJhcjphdHRhY2htZW50ZGVsZXRlJywgaW5kZXgpO1xuICAgICAgICBtZXNzYWdlYmFyLmVtaXQoJ2xvY2FsOjphdHRhY2htZW50RGVsZXRlIG1lc3NhZ2ViYXJBdHRhY2htZW50RGVsZXRlJywgbWVzc2FnZWJhciwgdGhpcywgaW5kZXgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJCh0aGlzKS50cmlnZ2VyKCdtZXNzYWdlYmFyOmF0dGFjaG1lbnRjbGljaycsIGluZGV4KTtcbiAgICAgICAgbWVzc2FnZWJhci5lbWl0KCdsb2NhbDo6YXR0YWNobWVudENsaWNrIG1lc3NhZ2ViYXJBdHRhY2htZW50Q2xpY2snLCBtZXNzYWdlYmFyLCB0aGlzLCBpbmRleCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uVGV4dGFyZWFDaGFuZ2UoKSB7XG4gICAgICBtZXNzYWdlYmFyLmNoZWNrRW1wdHlTdGF0ZSgpO1xuICAgICAgbWVzc2FnZWJhci4kZWwudHJpZ2dlcignbWVzc2FnZWJhcjpjaGFuZ2UnKTtcbiAgICAgIG1lc3NhZ2ViYXIuZW1pdCgnbG9jYWw6OmNoYW5nZSBtZXNzYWdlYmFyQ2hhbmdlJywgbWVzc2FnZWJhcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uVGV4dGFyZWFGb2N1cygpIHtcbiAgICAgIG1lc3NhZ2ViYXIuc2hlZXRIaWRlKCk7XG4gICAgICBtZXNzYWdlYmFyLiRlbC5hZGRDbGFzcygnbWVzc2FnZWJhci1mb2N1c2VkJyk7XG4gICAgICBtZXNzYWdlYmFyLiRlbC50cmlnZ2VyKCdtZXNzYWdlYmFyOmZvY3VzJyk7XG4gICAgICBtZXNzYWdlYmFyLmVtaXQoJ2xvY2FsOjpmb2N1cyBtZXNzYWdlYmFyRm9jdXMnLCBtZXNzYWdlYmFyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gb25UZXh0YXJlYUJsdXIoKSB7XG4gICAgICBtZXNzYWdlYmFyLiRlbC5yZW1vdmVDbGFzcygnbWVzc2FnZWJhci1mb2N1c2VkJyk7XG4gICAgICBtZXNzYWdlYmFyLiRlbC50cmlnZ2VyKCdtZXNzYWdlYmFyOmJsdXInKTtcbiAgICAgIG1lc3NhZ2ViYXIuZW1pdCgnbG9jYWw6OmJsdXIgbWVzc2FnZWJhckJsdXInLCBtZXNzYWdlYmFyKTtcbiAgICB9XG5cbiAgICBtZXNzYWdlYmFyLmF0dGFjaEV2ZW50cyA9IGZ1bmN0aW9uIGF0dGFjaEV2ZW50cygpIHtcbiAgICAgICRlbC5vbigndGV4dGFyZWE6cmVzaXplJywgb25BcHBSZXNpemUpO1xuICAgICAgJGVsLm9uKCdzdWJtaXQnLCBvblN1Ym1pdCk7XG4gICAgICAkZWwub24oJ2NsaWNrJywgJy5tZXNzYWdlYmFyLWF0dGFjaG1lbnQnLCBvbkF0dGFjaG1lbnRDbGljayk7XG4gICAgICAkdGV4dGFyZWFFbC5vbignY2hhbmdlIGlucHV0Jywgb25UZXh0YXJlYUNoYW5nZSk7XG4gICAgICAkdGV4dGFyZWFFbC5vbignZm9jdXMnLCBvblRleHRhcmVhRm9jdXMpO1xuICAgICAgJHRleHRhcmVhRWwub24oJ2JsdXInLCBvblRleHRhcmVhQmx1cik7XG4gICAgICBhcHAub24oJ3Jlc2l6ZScsIG9uQXBwUmVzaXplKTtcbiAgICB9O1xuICAgIG1lc3NhZ2ViYXIuZGV0YWNoRXZlbnRzID0gZnVuY3Rpb24gZGV0YWNoRXZlbnRzKCkge1xuICAgICAgJGVsLm9mZigndGV4dGFyZWE6cmVzaXplJywgb25BcHBSZXNpemUpO1xuICAgICAgJGVsLm9mZignc3VibWl0Jywgb25TdWJtaXQpO1xuICAgICAgJGVsLm9mZignY2xpY2snLCAnLm1lc3NhZ2ViYXItYXR0YWNobWVudCcsIG9uQXR0YWNobWVudENsaWNrKTtcbiAgICAgICR0ZXh0YXJlYUVsLm9mZignY2hhbmdlIGlucHV0Jywgb25UZXh0YXJlYUNoYW5nZSk7XG4gICAgICAkdGV4dGFyZWFFbC5vZmYoJ2ZvY3VzJywgb25UZXh0YXJlYUZvY3VzKTtcbiAgICAgICR0ZXh0YXJlYUVsLm9mZignYmx1cicsIG9uVGV4dGFyZWFCbHVyKTtcbiAgICAgIGFwcC5vZmYoJ3Jlc2l6ZScsIG9uQXBwUmVzaXplKTtcbiAgICB9O1xuXG5cbiAgICAvLyBJbnN0YWxsIE1vZHVsZXNcbiAgICBtZXNzYWdlYmFyLnVzZU1vZHVsZXMoKTtcblxuICAgIC8vIEluaXRcbiAgICBtZXNzYWdlYmFyLmluaXQoKTtcblxuICAgIHJldHVybiBtZXNzYWdlYmFyO1xuICB9XG4gIGZvY3VzKCkge1xuICAgIGNvbnN0IG1lc3NhZ2ViYXIgPSB0aGlzO1xuICAgIG1lc3NhZ2ViYXIuJHRleHRhcmVhRWwuZm9jdXMoKTtcbiAgICByZXR1cm4gbWVzc2FnZWJhcjtcbiAgfVxuICBibHVyKCkge1xuICAgIGNvbnN0IG1lc3NhZ2ViYXIgPSB0aGlzO1xuICAgIG1lc3NhZ2ViYXIuJHRleHRhcmVhRWwuYmx1cigpO1xuICAgIHJldHVybiBtZXNzYWdlYmFyO1xuICB9XG4gIGNsZWFyKCkge1xuICAgIGNvbnN0IG1lc3NhZ2ViYXIgPSB0aGlzO1xuICAgIG1lc3NhZ2ViYXIuJHRleHRhcmVhRWwudmFsKCcnKS50cmlnZ2VyKCdjaGFuZ2UnKTtcbiAgICByZXR1cm4gbWVzc2FnZWJhcjtcbiAgfVxuICBnZXRWYWx1ZSgpIHtcbiAgICBjb25zdCBtZXNzYWdlYmFyID0gdGhpcztcbiAgICByZXR1cm4gbWVzc2FnZWJhci4kdGV4dGFyZWFFbC52YWwoKS50cmltKCk7XG4gIH1cbiAgc2V0VmFsdWUodmFsdWUpIHtcbiAgICBjb25zdCBtZXNzYWdlYmFyID0gdGhpcztcbiAgICBtZXNzYWdlYmFyLiR0ZXh0YXJlYUVsLnZhbCh2YWx1ZSkudHJpZ2dlcignY2hhbmdlJyk7XG4gICAgcmV0dXJuIG1lc3NhZ2ViYXI7XG4gIH1cbiAgc2V0UGxhY2Vob2xkZXIocGxhY2Vob2xkZXIpIHtcbiAgICBjb25zdCBtZXNzYWdlYmFyID0gdGhpcztcbiAgICBtZXNzYWdlYmFyLiR0ZXh0YXJlYUVsLmF0dHIoJ3BsYWNlaG9sZGVyJywgcGxhY2Vob2xkZXIpO1xuICAgIHJldHVybiBtZXNzYWdlYmFyO1xuICB9XG4gIHJlc2l6ZVBhZ2UoKSB7XG4gICAgY29uc3QgbWVzc2FnZWJhciA9IHRoaXM7XG4gICAgY29uc3Qge1xuICAgICAgcGFyYW1zLFxuICAgICAgJGVsLFxuICAgICAgdG9wLFxuICAgICAgJHBhZ2VFbCxcbiAgICAgICRwYWdlQ29udGVudEVsLFxuICAgICAgJGFyZWFFbCxcbiAgICAgICR0ZXh0YXJlYUVsLFxuICAgICAgJHNoZWV0RWwsXG4gICAgICAkYXR0YWNobWVudHNFbCxcbiAgICB9ID0gbWVzc2FnZWJhcjtcbiAgICBjb25zdCBlbEhlaWdodCA9ICRlbFswXS5vZmZzZXRIZWlnaHQ7XG4gICAgbGV0IG1heEhlaWdodCA9IHBhcmFtcy5tYXhIZWlnaHQ7XG4gICAgaWYgKHRvcCkgOyBlbHNlIHtcbiAgICAgIGNvbnN0IGN1cnJlbnRQYWRkaW5nQm90dG9tID0gcGFyc2VJbnQoJHBhZ2VDb250ZW50RWwuY3NzKCdwYWRkaW5nLWJvdHRvbScpLCAxMCk7XG4gICAgICBjb25zdCByZXF1aXJlZFBhZGRpbmdCb3R0b20gPSBlbEhlaWdodCArIHBhcmFtcy5ib3R0b21PZmZzZXQ7XG4gICAgICBpZiAocmVxdWlyZWRQYWRkaW5nQm90dG9tICE9PSBjdXJyZW50UGFkZGluZ0JvdHRvbSAmJiAkcGFnZUNvbnRlbnRFbC5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgY3VycmVudFBhZGRpbmdUb3AgPSBwYXJzZUludCgkcGFnZUNvbnRlbnRFbC5jc3MoJ3BhZGRpbmctdG9wJyksIDEwKTtcbiAgICAgICAgY29uc3QgcGFnZVNjcm9sbEhlaWdodCA9ICRwYWdlQ29udGVudEVsWzBdLnNjcm9sbEhlaWdodDtcbiAgICAgICAgY29uc3QgcGFnZU9mZnNldEhlaWdodCA9ICRwYWdlQ29udGVudEVsWzBdLm9mZnNldEhlaWdodDtcbiAgICAgICAgY29uc3QgcGFnZVNjcm9sbFRvcCA9ICRwYWdlQ29udGVudEVsWzBdLnNjcm9sbFRvcDtcbiAgICAgICAgY29uc3Qgc2Nyb2xsT25Cb3R0b20gPSAocGFnZVNjcm9sbFRvcCA9PT0gcGFnZVNjcm9sbEhlaWdodCAtIHBhZ2VPZmZzZXRIZWlnaHQpO1xuICAgICAgICBpZiAoIW1heEhlaWdodCkge1xuICAgICAgICAgIG1heEhlaWdodCA9ICRwYWdlRWxbMF0ub2Zmc2V0SGVpZ2h0IC0gY3VycmVudFBhZGRpbmdUb3AgLSAkc2hlZXRFbC5vdXRlckhlaWdodCgpIC0gJGF0dGFjaG1lbnRzRWwub3V0ZXJIZWlnaHQoKSAtIHBhcnNlSW50KCRhcmVhRWwuY3NzKCdtYXJnaW4tdG9wJyksIDEwKSAtIHBhcnNlSW50KCRhcmVhRWwuY3NzKCdtYXJnaW4tYm90dG9tJyksIDEwKTtcbiAgICAgICAgfVxuICAgICAgICAkdGV4dGFyZWFFbC5jc3MoJ21heC1oZWlnaHQnLCBgJHttYXhIZWlnaHR9cHhgKTtcbiAgICAgICAgJHBhZ2VDb250ZW50RWwuY3NzKCdwYWRkaW5nLWJvdHRvbScsIGAke3JlcXVpcmVkUGFkZGluZ0JvdHRvbX1weGApO1xuICAgICAgICBpZiAoc2Nyb2xsT25Cb3R0b20pIHtcbiAgICAgICAgICAkcGFnZUNvbnRlbnRFbC5zY3JvbGxUb3AoJHBhZ2VDb250ZW50RWxbMF0uc2Nyb2xsSGVpZ2h0IC0gcGFnZU9mZnNldEhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgJGVsLnRyaWdnZXIoJ21lc3NhZ2ViYXI6cmVzaXplcGFnZScpO1xuICAgICAgICBtZXNzYWdlYmFyLmVtaXQoJ2xvY2FsOjpyZXNpemVQYWdlIG1lc3NhZ2ViYXJSZXNpemVQYWdlJywgbWVzc2FnZWJhcik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNoZWNrRW1wdHlTdGF0ZSgpIHtcbiAgICBjb25zdCBtZXNzYWdlYmFyID0gdGhpcztcbiAgICBjb25zdCB7ICRlbCwgJHRleHRhcmVhRWwgfSA9IG1lc3NhZ2ViYXI7XG4gICAgY29uc3QgdmFsdWUgPSAkdGV4dGFyZWFFbC52YWwoKS50cmltKCk7XG4gICAgaWYgKHZhbHVlICYmIHZhbHVlLmxlbmd0aCkge1xuICAgICAgJGVsLmFkZENsYXNzKCdtZXNzYWdlYmFyLXdpdGgtdmFsdWUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgJGVsLnJlbW92ZUNsYXNzKCdtZXNzYWdlYmFyLXdpdGgtdmFsdWUnKTtcbiAgICB9XG4gIH1cbiAgYXR0YWNobWVudHNDcmVhdGUoaW5uZXJIVE1MID0gJycpIHtcbiAgICBjb25zdCBtZXNzYWdlYmFyID0gdGhpcztcbiAgICBjb25zdCAkYXR0YWNobWVudHNFbCA9ICQoYDxkaXYgY2xhc3M9XCJtZXNzYWdlYmFyLWF0dGFjaG1lbnRzXCI+JHtpbm5lckhUTUx9PC9kaXY+YCk7XG4gICAgJGF0dGFjaG1lbnRzRWwuaW5zZXJ0QmVmb3JlKG1lc3NhZ2ViYXIuJHRleHRhcmVhRWwpO1xuICAgIFV0aWxzLmV4dGVuZChtZXNzYWdlYmFyLCB7XG4gICAgICAkYXR0YWNobWVudHNFbCxcbiAgICAgIGF0dGFjaG1lbnRzRWw6ICRhdHRhY2htZW50c0VsWzBdLFxuICAgIH0pO1xuICAgIHJldHVybiBtZXNzYWdlYmFyO1xuICB9XG4gIGF0dGFjaG1lbnRzU2hvdyhpbm5lckhUTUwgPSAnJykge1xuICAgIGNvbnN0IG1lc3NhZ2ViYXIgPSB0aGlzO1xuICAgIG1lc3NhZ2ViYXIuJGF0dGFjaG1lbnRzRWwgPSBtZXNzYWdlYmFyLiRlbC5maW5kKCcubWVzc2FnZWJhci1hdHRhY2htZW50cycpO1xuICAgIGlmIChtZXNzYWdlYmFyLiRhdHRhY2htZW50c0VsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgbWVzc2FnZWJhci5hdHRhY2htZW50c0NyZWF0ZShpbm5lckhUTUwpO1xuICAgIH1cbiAgICBtZXNzYWdlYmFyLiRlbC5hZGRDbGFzcygnbWVzc2FnZWJhci1hdHRhY2htZW50cy12aXNpYmxlJyk7XG4gICAgbWVzc2FnZWJhci5hdHRhY2htZW50c1Zpc2libGUgPSB0cnVlO1xuICAgIGlmIChtZXNzYWdlYmFyLnBhcmFtcy5yZXNpemVQYWdlKSB7XG4gICAgICBtZXNzYWdlYmFyLnJlc2l6ZVBhZ2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIG1lc3NhZ2ViYXI7XG4gIH1cbiAgYXR0YWNobWVudHNIaWRlKCkge1xuICAgIGNvbnN0IG1lc3NhZ2ViYXIgPSB0aGlzO1xuICAgIG1lc3NhZ2ViYXIuJGVsLnJlbW92ZUNsYXNzKCdtZXNzYWdlYmFyLWF0dGFjaG1lbnRzLXZpc2libGUnKTtcbiAgICBtZXNzYWdlYmFyLmF0dGFjaG1lbnRzVmlzaWJsZSA9IGZhbHNlO1xuICAgIGlmIChtZXNzYWdlYmFyLnBhcmFtcy5yZXNpemVQYWdlKSB7XG4gICAgICBtZXNzYWdlYmFyLnJlc2l6ZVBhZ2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIG1lc3NhZ2ViYXI7XG4gIH1cbiAgYXR0YWNobWVudHNUb2dnbGUoKSB7XG4gICAgY29uc3QgbWVzc2FnZWJhciA9IHRoaXM7XG4gICAgaWYgKG1lc3NhZ2ViYXIuYXR0YWNobWVudHNWaXNpYmxlKSB7XG4gICAgICBtZXNzYWdlYmFyLmF0dGFjaG1lbnRzSGlkZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBtZXNzYWdlYmFyLmF0dGFjaG1lbnRzU2hvdygpO1xuICAgIH1cbiAgICByZXR1cm4gbWVzc2FnZWJhcjtcbiAgfVxuICByZW5kZXJBdHRhY2htZW50KGF0dGFjaG1lbnQpIHtcbiAgICBjb25zdCBtZXNzYWdlYmFyID0gdGhpcztcbiAgICBpZiAobWVzc2FnZWJhci5wYXJhbXMucmVuZGVyQXR0YWNobWVudCkge1xuICAgICAgcmV0dXJuIG1lc3NhZ2ViYXIucGFyYW1zLnJlbmRlckF0dGFjaG1lbnQuY2FsbChtZXNzYWdlYmFyLCBhdHRhY2htZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIGBcbiAgICAgIDxkaXYgY2xhc3M9XCJtZXNzYWdlYmFyLWF0dGFjaG1lbnRcIj5cbiAgICAgICAgPGltZyBzcmM9XCIke2F0dGFjaG1lbnR9XCI+XG4gICAgICAgIDxzcGFuIGNsYXNzPVwibWVzc2FnZWJhci1hdHRhY2htZW50LWRlbGV0ZVwiPjwvc3Bhbj5cbiAgICAgIDwvZGl2PlxuICAgIGA7XG4gIH1cbiAgcmVuZGVyQXR0YWNobWVudHMoKSB7XG4gICAgY29uc3QgbWVzc2FnZWJhciA9IHRoaXM7XG4gICAgbGV0IGh0bWw7XG4gICAgaWYgKG1lc3NhZ2ViYXIucGFyYW1zLnJlbmRlckF0dGFjaG1lbnRzKSB7XG4gICAgICBodG1sID0gbWVzc2FnZWJhci5wYXJhbXMucmVuZGVyQXR0YWNobWVudHMuY2FsbChtZXNzYWdlYmFyLCBtZXNzYWdlYmFyLmF0dGFjaG1lbnRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaHRtbCA9IGAke21lc3NhZ2ViYXIuYXR0YWNobWVudHMubWFwKGF0dGFjaG1lbnQgPT4gbWVzc2FnZWJhci5yZW5kZXJBdHRhY2htZW50KGF0dGFjaG1lbnQpKS5qb2luKCcnKX1gO1xuICAgIH1cbiAgICBpZiAobWVzc2FnZWJhci4kYXR0YWNobWVudHNFbC5sZW5ndGggPT09IDApIHtcbiAgICAgIG1lc3NhZ2ViYXIuYXR0YWNobWVudHNDcmVhdGUoaHRtbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1lc3NhZ2ViYXIuJGF0dGFjaG1lbnRzRWwuaHRtbChodG1sKTtcbiAgICB9XG4gIH1cbiAgc2hlZXRDcmVhdGUoaW5uZXJIVE1MID0gJycpIHtcbiAgICBjb25zdCBtZXNzYWdlYmFyID0gdGhpcztcbiAgICBjb25zdCAkc2hlZXRFbCA9ICQoYDxkaXYgY2xhc3M9XCJtZXNzYWdlYmFyLXNoZWV0XCI+JHtpbm5lckhUTUx9PC9kaXY+YCk7XG4gICAgbWVzc2FnZWJhci4kZWwuYXBwZW5kKCRzaGVldEVsKTtcbiAgICBVdGlscy5leHRlbmQobWVzc2FnZWJhciwge1xuICAgICAgJHNoZWV0RWwsXG4gICAgICBzaGVldEVsOiAkc2hlZXRFbFswXSxcbiAgICB9KTtcbiAgICByZXR1cm4gbWVzc2FnZWJhcjtcbiAgfVxuICBzaGVldFNob3coaW5uZXJIVE1MID0gJycpIHtcbiAgICBjb25zdCBtZXNzYWdlYmFyID0gdGhpcztcbiAgICBtZXNzYWdlYmFyLiRzaGVldEVsID0gbWVzc2FnZWJhci4kZWwuZmluZCgnLm1lc3NhZ2ViYXItc2hlZXQnKTtcbiAgICBpZiAobWVzc2FnZWJhci4kc2hlZXRFbC5sZW5ndGggPT09IDApIHtcbiAgICAgIG1lc3NhZ2ViYXIuc2hlZXRDcmVhdGUoaW5uZXJIVE1MKTtcbiAgICB9XG4gICAgbWVzc2FnZWJhci4kZWwuYWRkQ2xhc3MoJ21lc3NhZ2ViYXItc2hlZXQtdmlzaWJsZScpO1xuICAgIG1lc3NhZ2ViYXIuc2hlZXRWaXNpYmxlID0gdHJ1ZTtcbiAgICBpZiAobWVzc2FnZWJhci5wYXJhbXMucmVzaXplUGFnZSkge1xuICAgICAgbWVzc2FnZWJhci5yZXNpemVQYWdlKCk7XG4gICAgfVxuICAgIHJldHVybiBtZXNzYWdlYmFyO1xuICB9XG4gIHNoZWV0SGlkZSgpIHtcbiAgICBjb25zdCBtZXNzYWdlYmFyID0gdGhpcztcbiAgICBtZXNzYWdlYmFyLiRlbC5yZW1vdmVDbGFzcygnbWVzc2FnZWJhci1zaGVldC12aXNpYmxlJyk7XG4gICAgbWVzc2FnZWJhci5zaGVldFZpc2libGUgPSBmYWxzZTtcbiAgICBpZiAobWVzc2FnZWJhci5wYXJhbXMucmVzaXplUGFnZSkge1xuICAgICAgbWVzc2FnZWJhci5yZXNpemVQYWdlKCk7XG4gICAgfVxuICAgIHJldHVybiBtZXNzYWdlYmFyO1xuICB9XG4gIHNoZWV0VG9nZ2xlKCkge1xuICAgIGNvbnN0IG1lc3NhZ2ViYXIgPSB0aGlzO1xuICAgIGlmIChtZXNzYWdlYmFyLnNoZWV0VmlzaWJsZSkge1xuICAgICAgbWVzc2FnZWJhci5zaGVldEhpZGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWVzc2FnZWJhci5zaGVldFNob3coKTtcbiAgICB9XG4gICAgcmV0dXJuIG1lc3NhZ2ViYXI7XG4gIH1cbiAgaW5pdCgpIHtcbiAgICBjb25zdCBtZXNzYWdlYmFyID0gdGhpcztcbiAgICBtZXNzYWdlYmFyLmF0dGFjaEV2ZW50cygpO1xuICAgIG1lc3NhZ2ViYXIuY2hlY2tFbXB0eVN0YXRlKCk7XG4gICAgcmV0dXJuIG1lc3NhZ2ViYXI7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICBjb25zdCBtZXNzYWdlYmFyID0gdGhpcztcbiAgICBtZXNzYWdlYmFyLmVtaXQoJ2xvY2FsOjpiZWZvcmVEZXN0cm95IG1lc3NhZ2ViYXJCZWZvcmVEZXN0cm95JywgbWVzc2FnZWJhcik7XG4gICAgbWVzc2FnZWJhci4kZWwudHJpZ2dlcignbWVzc2FnZWJhcjpiZWZvcmVkZXN0cm95JywgbWVzc2FnZWJhcik7XG4gICAgbWVzc2FnZWJhci5kZXRhY2hFdmVudHMoKTtcbiAgICBtZXNzYWdlYmFyLiRlbFswXS5mN01lc3NhZ2ViYXIgPSBudWxsO1xuICAgIGRlbGV0ZSBtZXNzYWdlYmFyLiRlbFswXS5mN01lc3NhZ2ViYXI7XG4gICAgVXRpbHMuZGVsZXRlUHJvcHMobWVzc2FnZWJhcik7XG4gIH1cbn1cblxudmFyIE1lc3NhZ2ViYXIkMSA9IHtcbiAgbmFtZTogJ21lc3NhZ2ViYXInLFxuICBzdGF0aWM6IHtcbiAgICBNZXNzYWdlYmFyLFxuICB9LFxuICBjcmVhdGUoKSB7XG4gICAgY29uc3QgYXBwID0gdGhpcztcbiAgICBhcHAubWVzc2FnZWJhciA9IENvbnN0cnVjdG9yTWV0aG9kcyh7XG4gICAgICBkZWZhdWx0U2VsZWN0b3I6ICcubWVzc2FnZWJhcicsXG4gICAgICBjb25zdHJ1Y3RvcjogTWVzc2FnZWJhcixcbiAgICAgIGFwcCxcbiAgICAgIGRvbVByb3A6ICdmN01lc3NhZ2ViYXInLFxuICAgICAgYWRkTWV0aG9kczogJ2NsZWFyIGdldFZhbHVlIHNldFZhbHVlIHNldFBsYWNlaG9sZGVyIHJlc2l6ZVBhZ2UgZm9jdXMgYmx1ciBhdHRhY2htZW50c0NyZWF0ZSBhdHRhY2htZW50c1Nob3cgYXR0YWNobWVudHNIaWRlIGF0dGFjaG1lbnRzVG9nZ2xlIHJlbmRlckF0dGFjaG1lbnRzIHNoZWV0Q3JlYXRlIHNoZWV0U2hvdyBzaGVldEhpZGUgc2hlZXRUb2dnbGUnLnNwbGl0KCcgJyksXG4gICAgfSk7XG4gIH0sXG4gIG9uOiB7XG4gICAgdGFiQmVmb3JlUmVtb3ZlKHRhYkVsKSB7XG4gICAgICBjb25zdCBhcHAgPSB0aGlzO1xuICAgICAgJCh0YWJFbCkuZmluZCgnLm1lc3NhZ2ViYXItaW5pdCcpLmVhY2goKGluZGV4LCBtZXNzYWdlYmFyRWwpID0+IHtcbiAgICAgICAgYXBwLm1lc3NhZ2ViYXIuZGVzdHJveShtZXNzYWdlYmFyRWwpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICB0YWJNb3VudGVkKHRhYkVsKSB7XG4gICAgICBjb25zdCBhcHAgPSB0aGlzO1xuICAgICAgJCh0YWJFbCkuZmluZCgnLm1lc3NhZ2ViYXItaW5pdCcpLmVhY2goKGluZGV4LCBtZXNzYWdlYmFyRWwpID0+IHtcbiAgICAgICAgYXBwLm1lc3NhZ2ViYXIuY3JlYXRlKFV0aWxzLmV4dGVuZCh7IGVsOiBtZXNzYWdlYmFyRWwgfSwgJChtZXNzYWdlYmFyRWwpLmRhdGFzZXQoKSkpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBwYWdlQmVmb3JlUmVtb3ZlKHBhZ2UpIHtcbiAgICAgIGNvbnN0IGFwcCA9IHRoaXM7XG4gICAgICBwYWdlLiRlbC5maW5kKCcubWVzc2FnZWJhci1pbml0JykuZWFjaCgoaW5kZXgsIG1lc3NhZ2ViYXJFbCkgPT4ge1xuICAgICAgICBhcHAubWVzc2FnZWJhci5kZXN0cm95KG1lc3NhZ2ViYXJFbCk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIHBhZ2VJbml0KHBhZ2UpIHtcbiAgICAgIGNvbnN0IGFwcCA9IHRoaXM7XG4gICAgICBwYWdlLiRlbC5maW5kKCcubWVzc2FnZWJhci1pbml0JykuZWFjaCgoaW5kZXgsIG1lc3NhZ2ViYXJFbCkgPT4ge1xuICAgICAgICBhcHAubWVzc2FnZWJhci5jcmVhdGUoVXRpbHMuZXh0ZW5kKHsgZWw6IG1lc3NhZ2ViYXJFbCB9LCAkKG1lc3NhZ2ViYXJFbCkuZGF0YXNldCgpKSk7XG4gICAgICB9KTtcbiAgICB9LFxuICB9LFxufTtcblxuZnVuY3Rpb24gdXBkYXRlU2l6ZSAoKSB7XG4gIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gIGxldCB3aWR0aDtcbiAgbGV0IGhlaWdodDtcbiAgY29uc3QgJGVsID0gc3dpcGVyLiRlbDtcbiAgaWYgKHR5cGVvZiBzd2lwZXIucGFyYW1zLndpZHRoICE9PSAndW5kZWZpbmVkJykge1xuICAgIHdpZHRoID0gc3dpcGVyLnBhcmFtcy53aWR0aDtcbiAgfSBlbHNlIHtcbiAgICB3aWR0aCA9ICRlbFswXS5jbGllbnRXaWR0aDtcbiAgfVxuICBpZiAodHlwZW9mIHN3aXBlci5wYXJhbXMuaGVpZ2h0ICE9PSAndW5kZWZpbmVkJykge1xuICAgIGhlaWdodCA9IHN3aXBlci5wYXJhbXMuaGVpZ2h0O1xuICB9IGVsc2Uge1xuICAgIGhlaWdodCA9ICRlbFswXS5jbGllbnRIZWlnaHQ7XG4gIH1cbiAgaWYgKCh3aWR0aCA9PT0gMCAmJiBzd2lwZXIuaXNIb3Jpem9udGFsKCkpIHx8IChoZWlnaHQgPT09IDAgJiYgc3dpcGVyLmlzVmVydGljYWwoKSkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBTdWJ0cmFjdCBwYWRkaW5nc1xuICB3aWR0aCA9IHdpZHRoIC0gcGFyc2VJbnQoJGVsLmNzcygncGFkZGluZy1sZWZ0JyksIDEwKSAtIHBhcnNlSW50KCRlbC5jc3MoJ3BhZGRpbmctcmlnaHQnKSwgMTApO1xuICBoZWlnaHQgPSBoZWlnaHQgLSBwYXJzZUludCgkZWwuY3NzKCdwYWRkaW5nLXRvcCcpLCAxMCkgLSBwYXJzZUludCgkZWwuY3NzKCdwYWRkaW5nLWJvdHRvbScpLCAxMCk7XG5cbiAgVXRpbHMuZXh0ZW5kKHN3aXBlciwge1xuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICBzaXplOiBzd2lwZXIuaXNIb3Jpem9udGFsKCkgPyB3aWR0aCA6IGhlaWdodCxcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVNsaWRlcyAoKSB7XG4gIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gIGNvbnN0IHBhcmFtcyA9IHN3aXBlci5wYXJhbXM7XG5cbiAgY29uc3Qge1xuICAgICR3cmFwcGVyRWwsIHNpemU6IHN3aXBlclNpemUsIHJ0bFRyYW5zbGF0ZTogcnRsLCB3cm9uZ1JUTCxcbiAgfSA9IHN3aXBlcjtcbiAgY29uc3Qgc2xpZGVzID0gJHdyYXBwZXJFbC5jaGlsZHJlbihgLiR7c3dpcGVyLnBhcmFtcy5zbGlkZUNsYXNzfWApO1xuICBjb25zdCBpc1ZpcnR1YWwgPSBzd2lwZXIudmlydHVhbCAmJiBwYXJhbXMudmlydHVhbC5lbmFibGVkO1xuICBjb25zdCBzbGlkZXNMZW5ndGggPSBpc1ZpcnR1YWwgPyBzd2lwZXIudmlydHVhbC5zbGlkZXMubGVuZ3RoIDogc2xpZGVzLmxlbmd0aDtcbiAgbGV0IHNuYXBHcmlkID0gW107XG4gIGNvbnN0IHNsaWRlc0dyaWQgPSBbXTtcbiAgY29uc3Qgc2xpZGVzU2l6ZXNHcmlkID0gW107XG5cbiAgbGV0IG9mZnNldEJlZm9yZSA9IHBhcmFtcy5zbGlkZXNPZmZzZXRCZWZvcmU7XG4gIGlmICh0eXBlb2Ygb2Zmc2V0QmVmb3JlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgb2Zmc2V0QmVmb3JlID0gcGFyYW1zLnNsaWRlc09mZnNldEJlZm9yZS5jYWxsKHN3aXBlcik7XG4gIH1cblxuICBsZXQgb2Zmc2V0QWZ0ZXIgPSBwYXJhbXMuc2xpZGVzT2Zmc2V0QWZ0ZXI7XG4gIGlmICh0eXBlb2Ygb2Zmc2V0QWZ0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICBvZmZzZXRBZnRlciA9IHBhcmFtcy5zbGlkZXNPZmZzZXRBZnRlci5jYWxsKHN3aXBlcik7XG4gIH1cblxuICBjb25zdCBwcmV2aW91c1NsaWRlc0xlbmd0aCA9IHNsaWRlc0xlbmd0aDtcbiAgY29uc3QgcHJldmlvdXNTbmFwR3JpZExlbmd0aCA9IHN3aXBlci5zbmFwR3JpZC5sZW5ndGg7XG4gIGNvbnN0IHByZXZpb3VzU2xpZGVzR3JpZExlbmd0aCA9IHN3aXBlci5zbmFwR3JpZC5sZW5ndGg7XG5cbiAgbGV0IHNwYWNlQmV0d2VlbiA9IHBhcmFtcy5zcGFjZUJldHdlZW47XG4gIGxldCBzbGlkZVBvc2l0aW9uID0gLW9mZnNldEJlZm9yZTtcbiAgbGV0IHByZXZTbGlkZVNpemUgPSAwO1xuICBsZXQgaW5kZXggPSAwO1xuICBpZiAodHlwZW9mIHN3aXBlclNpemUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICh0eXBlb2Ygc3BhY2VCZXR3ZWVuID09PSAnc3RyaW5nJyAmJiBzcGFjZUJldHdlZW4uaW5kZXhPZignJScpID49IDApIHtcbiAgICBzcGFjZUJldHdlZW4gPSAocGFyc2VGbG9hdChzcGFjZUJldHdlZW4ucmVwbGFjZSgnJScsICcnKSkgLyAxMDApICogc3dpcGVyU2l6ZTtcbiAgfVxuXG4gIHN3aXBlci52aXJ0dWFsU2l6ZSA9IC1zcGFjZUJldHdlZW47XG5cbiAgLy8gcmVzZXQgbWFyZ2luc1xuICBpZiAocnRsKSBzbGlkZXMuY3NzKHsgbWFyZ2luTGVmdDogJycsIG1hcmdpblRvcDogJycgfSk7XG4gIGVsc2Ugc2xpZGVzLmNzcyh7IG1hcmdpblJpZ2h0OiAnJywgbWFyZ2luQm90dG9tOiAnJyB9KTtcblxuICBsZXQgc2xpZGVzTnVtYmVyRXZlblRvUm93cztcbiAgaWYgKHBhcmFtcy5zbGlkZXNQZXJDb2x1bW4gPiAxKSB7XG4gICAgaWYgKE1hdGguZmxvb3Ioc2xpZGVzTGVuZ3RoIC8gcGFyYW1zLnNsaWRlc1BlckNvbHVtbikgPT09IHNsaWRlc0xlbmd0aCAvIHN3aXBlci5wYXJhbXMuc2xpZGVzUGVyQ29sdW1uKSB7XG4gICAgICBzbGlkZXNOdW1iZXJFdmVuVG9Sb3dzID0gc2xpZGVzTGVuZ3RoO1xuICAgIH0gZWxzZSB7XG4gICAgICBzbGlkZXNOdW1iZXJFdmVuVG9Sb3dzID0gTWF0aC5jZWlsKHNsaWRlc0xlbmd0aCAvIHBhcmFtcy5zbGlkZXNQZXJDb2x1bW4pICogcGFyYW1zLnNsaWRlc1BlckNvbHVtbjtcbiAgICB9XG4gICAgaWYgKHBhcmFtcy5zbGlkZXNQZXJWaWV3ICE9PSAnYXV0bycgJiYgcGFyYW1zLnNsaWRlc1BlckNvbHVtbkZpbGwgPT09ICdyb3cnKSB7XG4gICAgICBzbGlkZXNOdW1iZXJFdmVuVG9Sb3dzID0gTWF0aC5tYXgoc2xpZGVzTnVtYmVyRXZlblRvUm93cywgcGFyYW1zLnNsaWRlc1BlclZpZXcgKiBwYXJhbXMuc2xpZGVzUGVyQ29sdW1uKTtcbiAgICB9XG4gIH1cblxuICAvLyBDYWxjIHNsaWRlc1xuICBsZXQgc2xpZGVTaXplO1xuICBjb25zdCBzbGlkZXNQZXJDb2x1bW4gPSBwYXJhbXMuc2xpZGVzUGVyQ29sdW1uO1xuICBjb25zdCBzbGlkZXNQZXJSb3cgPSBzbGlkZXNOdW1iZXJFdmVuVG9Sb3dzIC8gc2xpZGVzUGVyQ29sdW1uO1xuICBjb25zdCBudW1GdWxsQ29sdW1ucyA9IHNsaWRlc1BlclJvdyAtICgocGFyYW1zLnNsaWRlc1BlckNvbHVtbiAqIHNsaWRlc1BlclJvdykgLSBzbGlkZXNMZW5ndGgpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNsaWRlc0xlbmd0aDsgaSArPSAxKSB7XG4gICAgc2xpZGVTaXplID0gMDtcbiAgICBjb25zdCBzbGlkZSA9IHNsaWRlcy5lcShpKTtcbiAgICBpZiAocGFyYW1zLnNsaWRlc1BlckNvbHVtbiA+IDEpIHtcbiAgICAgIC8vIFNldCBzbGlkZXMgb3JkZXJcbiAgICAgIGxldCBuZXdTbGlkZU9yZGVySW5kZXg7XG4gICAgICBsZXQgY29sdW1uO1xuICAgICAgbGV0IHJvdztcbiAgICAgIGlmIChwYXJhbXMuc2xpZGVzUGVyQ29sdW1uRmlsbCA9PT0gJ2NvbHVtbicpIHtcbiAgICAgICAgY29sdW1uID0gTWF0aC5mbG9vcihpIC8gc2xpZGVzUGVyQ29sdW1uKTtcbiAgICAgICAgcm93ID0gaSAtIChjb2x1bW4gKiBzbGlkZXNQZXJDb2x1bW4pO1xuICAgICAgICBpZiAoY29sdW1uID4gbnVtRnVsbENvbHVtbnMgfHwgKGNvbHVtbiA9PT0gbnVtRnVsbENvbHVtbnMgJiYgcm93ID09PSBzbGlkZXNQZXJDb2x1bW4gLSAxKSkge1xuICAgICAgICAgIHJvdyArPSAxO1xuICAgICAgICAgIGlmIChyb3cgPj0gc2xpZGVzUGVyQ29sdW1uKSB7XG4gICAgICAgICAgICByb3cgPSAwO1xuICAgICAgICAgICAgY29sdW1uICs9IDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG5ld1NsaWRlT3JkZXJJbmRleCA9IGNvbHVtbiArICgocm93ICogc2xpZGVzTnVtYmVyRXZlblRvUm93cykgLyBzbGlkZXNQZXJDb2x1bW4pO1xuICAgICAgICBzbGlkZVxuICAgICAgICAgIC5jc3Moe1xuICAgICAgICAgICAgJy13ZWJraXQtYm94LW9yZGluYWwtZ3JvdXAnOiBuZXdTbGlkZU9yZGVySW5kZXgsXG4gICAgICAgICAgICAnLW1vei1ib3gtb3JkaW5hbC1ncm91cCc6IG5ld1NsaWRlT3JkZXJJbmRleCxcbiAgICAgICAgICAgICctbXMtZmxleC1vcmRlcic6IG5ld1NsaWRlT3JkZXJJbmRleCxcbiAgICAgICAgICAgICctd2Via2l0LW9yZGVyJzogbmV3U2xpZGVPcmRlckluZGV4LFxuICAgICAgICAgICAgb3JkZXI6IG5ld1NsaWRlT3JkZXJJbmRleCxcbiAgICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJvdyA9IE1hdGguZmxvb3IoaSAvIHNsaWRlc1BlclJvdyk7XG4gICAgICAgIGNvbHVtbiA9IGkgLSAocm93ICogc2xpZGVzUGVyUm93KTtcbiAgICAgIH1cbiAgICAgIHNsaWRlXG4gICAgICAgIC5jc3MoXG4gICAgICAgICAgYG1hcmdpbi0ke3N3aXBlci5pc0hvcml6b250YWwoKSA/ICd0b3AnIDogJ2xlZnQnfWAsXG4gICAgICAgICAgKHJvdyAhPT0gMCAmJiBwYXJhbXMuc3BhY2VCZXR3ZWVuKSAmJiAoYCR7cGFyYW1zLnNwYWNlQmV0d2Vlbn1weGApXG4gICAgICAgIClcbiAgICAgICAgLmF0dHIoJ2RhdGEtc3dpcGVyLWNvbHVtbicsIGNvbHVtbilcbiAgICAgICAgLmF0dHIoJ2RhdGEtc3dpcGVyLXJvdycsIHJvdyk7XG4gICAgfVxuICAgIGlmIChzbGlkZS5jc3MoJ2Rpc3BsYXknKSA9PT0gJ25vbmUnKSBjb250aW51ZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gICAgaWYgKHBhcmFtcy5zbGlkZXNQZXJWaWV3ID09PSAnYXV0bycpIHtcbiAgICAgIGNvbnN0IHNsaWRlU3R5bGVzID0gd2luZG93JDEuZ2V0Q29tcHV0ZWRTdHlsZShzbGlkZVswXSwgbnVsbCk7XG4gICAgICBjb25zdCBjdXJyZW50VHJhbnNmb3JtID0gc2xpZGVbMF0uc3R5bGUudHJhbnNmb3JtO1xuICAgICAgaWYgKGN1cnJlbnRUcmFuc2Zvcm0pIHtcbiAgICAgICAgc2xpZGVbMF0uc3R5bGUudHJhbnNmb3JtID0gJ25vbmUnO1xuICAgICAgfVxuICAgICAgaWYgKHN3aXBlci5pc0hvcml6b250YWwoKSkge1xuICAgICAgICBzbGlkZVNpemUgPSBzbGlkZVswXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCArXG4gICAgICAgICAgcGFyc2VGbG9hdChzbGlkZVN0eWxlcy5nZXRQcm9wZXJ0eVZhbHVlKCdtYXJnaW4tbGVmdCcpKSArXG4gICAgICAgICAgcGFyc2VGbG9hdChzbGlkZVN0eWxlcy5nZXRQcm9wZXJ0eVZhbHVlKCdtYXJnaW4tcmlnaHQnKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzbGlkZVNpemUgPSBzbGlkZVswXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQgK1xuICAgICAgICAgIHBhcnNlRmxvYXQoc2xpZGVTdHlsZXMuZ2V0UHJvcGVydHlWYWx1ZSgnbWFyZ2luLXRvcCcpKSArXG4gICAgICAgICAgcGFyc2VGbG9hdChzbGlkZVN0eWxlcy5nZXRQcm9wZXJ0eVZhbHVlKCdtYXJnaW4tYm90dG9tJykpO1xuICAgICAgfVxuICAgICAgaWYgKGN1cnJlbnRUcmFuc2Zvcm0pIHtcbiAgICAgICAgc2xpZGVbMF0uc3R5bGUudHJhbnNmb3JtID0gY3VycmVudFRyYW5zZm9ybTtcbiAgICAgIH1cbiAgICAgIGlmIChwYXJhbXMucm91bmRMZW5ndGhzKSBzbGlkZVNpemUgPSBNYXRoLmZsb29yKHNsaWRlU2l6ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNsaWRlU2l6ZSA9IChzd2lwZXJTaXplIC0gKChwYXJhbXMuc2xpZGVzUGVyVmlldyAtIDEpICogc3BhY2VCZXR3ZWVuKSkgLyBwYXJhbXMuc2xpZGVzUGVyVmlldztcbiAgICAgIGlmIChwYXJhbXMucm91bmRMZW5ndGhzKSBzbGlkZVNpemUgPSBNYXRoLmZsb29yKHNsaWRlU2l6ZSk7XG5cbiAgICAgIGlmIChzbGlkZXNbaV0pIHtcbiAgICAgICAgaWYgKHN3aXBlci5pc0hvcml6b250YWwoKSkge1xuICAgICAgICAgIHNsaWRlc1tpXS5zdHlsZS53aWR0aCA9IGAke3NsaWRlU2l6ZX1weGA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2xpZGVzW2ldLnN0eWxlLmhlaWdodCA9IGAke3NsaWRlU2l6ZX1weGA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNsaWRlc1tpXSkge1xuICAgICAgc2xpZGVzW2ldLnN3aXBlclNsaWRlU2l6ZSA9IHNsaWRlU2l6ZTtcbiAgICB9XG4gICAgc2xpZGVzU2l6ZXNHcmlkLnB1c2goc2xpZGVTaXplKTtcblxuXG4gICAgaWYgKHBhcmFtcy5jZW50ZXJlZFNsaWRlcykge1xuICAgICAgc2xpZGVQb3NpdGlvbiA9IHNsaWRlUG9zaXRpb24gKyAoc2xpZGVTaXplIC8gMikgKyAocHJldlNsaWRlU2l6ZSAvIDIpICsgc3BhY2VCZXR3ZWVuO1xuICAgICAgaWYgKHByZXZTbGlkZVNpemUgPT09IDAgJiYgaSAhPT0gMCkgc2xpZGVQb3NpdGlvbiA9IHNsaWRlUG9zaXRpb24gLSAoc3dpcGVyU2l6ZSAvIDIpIC0gc3BhY2VCZXR3ZWVuO1xuICAgICAgaWYgKGkgPT09IDApIHNsaWRlUG9zaXRpb24gPSBzbGlkZVBvc2l0aW9uIC0gKHN3aXBlclNpemUgLyAyKSAtIHNwYWNlQmV0d2VlbjtcbiAgICAgIGlmIChNYXRoLmFicyhzbGlkZVBvc2l0aW9uKSA8IDEgLyAxMDAwKSBzbGlkZVBvc2l0aW9uID0gMDtcbiAgICAgIGlmICgoaW5kZXgpICUgcGFyYW1zLnNsaWRlc1Blckdyb3VwID09PSAwKSBzbmFwR3JpZC5wdXNoKHNsaWRlUG9zaXRpb24pO1xuICAgICAgc2xpZGVzR3JpZC5wdXNoKHNsaWRlUG9zaXRpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoKGluZGV4KSAlIHBhcmFtcy5zbGlkZXNQZXJHcm91cCA9PT0gMCkgc25hcEdyaWQucHVzaChzbGlkZVBvc2l0aW9uKTtcbiAgICAgIHNsaWRlc0dyaWQucHVzaChzbGlkZVBvc2l0aW9uKTtcbiAgICAgIHNsaWRlUG9zaXRpb24gPSBzbGlkZVBvc2l0aW9uICsgc2xpZGVTaXplICsgc3BhY2VCZXR3ZWVuO1xuICAgIH1cblxuICAgIHN3aXBlci52aXJ0dWFsU2l6ZSArPSBzbGlkZVNpemUgKyBzcGFjZUJldHdlZW47XG5cbiAgICBwcmV2U2xpZGVTaXplID0gc2xpZGVTaXplO1xuXG4gICAgaW5kZXggKz0gMTtcbiAgfVxuICBzd2lwZXIudmlydHVhbFNpemUgPSBNYXRoLm1heChzd2lwZXIudmlydHVhbFNpemUsIHN3aXBlclNpemUpICsgb2Zmc2V0QWZ0ZXI7XG4gIGxldCBuZXdTbGlkZXNHcmlkO1xuXG4gIGlmIChcbiAgICBydGwgJiYgd3JvbmdSVEwgJiYgKHBhcmFtcy5lZmZlY3QgPT09ICdzbGlkZScgfHwgcGFyYW1zLmVmZmVjdCA9PT0gJ2NvdmVyZmxvdycpKSB7XG4gICAgJHdyYXBwZXJFbC5jc3MoeyB3aWR0aDogYCR7c3dpcGVyLnZpcnR1YWxTaXplICsgcGFyYW1zLnNwYWNlQmV0d2Vlbn1weGAgfSk7XG4gIH1cbiAgaWYgKCFTdXBwb3J0LmZsZXhib3ggfHwgcGFyYW1zLnNldFdyYXBwZXJTaXplKSB7XG4gICAgaWYgKHN3aXBlci5pc0hvcml6b250YWwoKSkgJHdyYXBwZXJFbC5jc3MoeyB3aWR0aDogYCR7c3dpcGVyLnZpcnR1YWxTaXplICsgcGFyYW1zLnNwYWNlQmV0d2Vlbn1weGAgfSk7XG4gICAgZWxzZSAkd3JhcHBlckVsLmNzcyh7IGhlaWdodDogYCR7c3dpcGVyLnZpcnR1YWxTaXplICsgcGFyYW1zLnNwYWNlQmV0d2Vlbn1weGAgfSk7XG4gIH1cblxuICBpZiAocGFyYW1zLnNsaWRlc1BlckNvbHVtbiA+IDEpIHtcbiAgICBzd2lwZXIudmlydHVhbFNpemUgPSAoc2xpZGVTaXplICsgcGFyYW1zLnNwYWNlQmV0d2VlbikgKiBzbGlkZXNOdW1iZXJFdmVuVG9Sb3dzO1xuICAgIHN3aXBlci52aXJ0dWFsU2l6ZSA9IE1hdGguY2VpbChzd2lwZXIudmlydHVhbFNpemUgLyBwYXJhbXMuc2xpZGVzUGVyQ29sdW1uKSAtIHBhcmFtcy5zcGFjZUJldHdlZW47XG4gICAgaWYgKHN3aXBlci5pc0hvcml6b250YWwoKSkgJHdyYXBwZXJFbC5jc3MoeyB3aWR0aDogYCR7c3dpcGVyLnZpcnR1YWxTaXplICsgcGFyYW1zLnNwYWNlQmV0d2Vlbn1weGAgfSk7XG4gICAgZWxzZSAkd3JhcHBlckVsLmNzcyh7IGhlaWdodDogYCR7c3dpcGVyLnZpcnR1YWxTaXplICsgcGFyYW1zLnNwYWNlQmV0d2Vlbn1weGAgfSk7XG4gICAgaWYgKHBhcmFtcy5jZW50ZXJlZFNsaWRlcykge1xuICAgICAgbmV3U2xpZGVzR3JpZCA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzbmFwR3JpZC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBpZiAoc25hcEdyaWRbaV0gPCBzd2lwZXIudmlydHVhbFNpemUgKyBzbmFwR3JpZFswXSkgbmV3U2xpZGVzR3JpZC5wdXNoKHNuYXBHcmlkW2ldKTtcbiAgICAgIH1cbiAgICAgIHNuYXBHcmlkID0gbmV3U2xpZGVzR3JpZDtcbiAgICB9XG4gIH1cblxuICAvLyBSZW1vdmUgbGFzdCBncmlkIGVsZW1lbnRzIGRlcGVuZGluZyBvbiB3aWR0aFxuICBpZiAoIXBhcmFtcy5jZW50ZXJlZFNsaWRlcykge1xuICAgIG5ld1NsaWRlc0dyaWQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNuYXBHcmlkLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBpZiAoc25hcEdyaWRbaV0gPD0gc3dpcGVyLnZpcnR1YWxTaXplIC0gc3dpcGVyU2l6ZSkge1xuICAgICAgICBuZXdTbGlkZXNHcmlkLnB1c2goc25hcEdyaWRbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICBzbmFwR3JpZCA9IG5ld1NsaWRlc0dyaWQ7XG4gICAgaWYgKE1hdGguZmxvb3Ioc3dpcGVyLnZpcnR1YWxTaXplIC0gc3dpcGVyU2l6ZSkgLSBNYXRoLmZsb29yKHNuYXBHcmlkW3NuYXBHcmlkLmxlbmd0aCAtIDFdKSA+IDEpIHtcbiAgICAgIHNuYXBHcmlkLnB1c2goc3dpcGVyLnZpcnR1YWxTaXplIC0gc3dpcGVyU2l6ZSk7XG4gICAgfVxuICB9XG4gIGlmIChzbmFwR3JpZC5sZW5ndGggPT09IDApIHNuYXBHcmlkID0gWzBdO1xuXG4gIGlmIChwYXJhbXMuc3BhY2VCZXR3ZWVuICE9PSAwKSB7XG4gICAgaWYgKHN3aXBlci5pc0hvcml6b250YWwoKSkge1xuICAgICAgaWYgKHJ0bCkgc2xpZGVzLmNzcyh7IG1hcmdpbkxlZnQ6IGAke3NwYWNlQmV0d2Vlbn1weGAgfSk7XG4gICAgICBlbHNlIHNsaWRlcy5jc3MoeyBtYXJnaW5SaWdodDogYCR7c3BhY2VCZXR3ZWVufXB4YCB9KTtcbiAgICB9IGVsc2Ugc2xpZGVzLmNzcyh7IG1hcmdpbkJvdHRvbTogYCR7c3BhY2VCZXR3ZWVufXB4YCB9KTtcbiAgfVxuXG4gIFV0aWxzLmV4dGVuZChzd2lwZXIsIHtcbiAgICBzbGlkZXMsXG4gICAgc25hcEdyaWQsXG4gICAgc2xpZGVzR3JpZCxcbiAgICBzbGlkZXNTaXplc0dyaWQsXG4gIH0pO1xuXG4gIGlmIChzbGlkZXNMZW5ndGggIT09IHByZXZpb3VzU2xpZGVzTGVuZ3RoKSB7XG4gICAgc3dpcGVyLmVtaXQoJ3NsaWRlc0xlbmd0aENoYW5nZScpO1xuICB9XG4gIGlmIChzbmFwR3JpZC5sZW5ndGggIT09IHByZXZpb3VzU25hcEdyaWRMZW5ndGgpIHtcbiAgICBpZiAoc3dpcGVyLnBhcmFtcy53YXRjaE92ZXJmbG93KSBzd2lwZXIuY2hlY2tPdmVyZmxvdygpO1xuICAgIHN3aXBlci5lbWl0KCdzbmFwR3JpZExlbmd0aENoYW5nZScpO1xuICB9XG4gIGlmIChzbGlkZXNHcmlkLmxlbmd0aCAhPT0gcHJldmlvdXNTbGlkZXNHcmlkTGVuZ3RoKSB7XG4gICAgc3dpcGVyLmVtaXQoJ3NsaWRlc0dyaWRMZW5ndGhDaGFuZ2UnKTtcbiAgfVxuXG4gIGlmIChwYXJhbXMud2F0Y2hTbGlkZXNQcm9ncmVzcyB8fCBwYXJhbXMud2F0Y2hTbGlkZXNWaXNpYmlsaXR5KSB7XG4gICAgc3dpcGVyLnVwZGF0ZVNsaWRlc09mZnNldCgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUF1dG9IZWlnaHQgKHNwZWVkKSB7XG4gIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gIGNvbnN0IGFjdGl2ZVNsaWRlcyA9IFtdO1xuICBsZXQgbmV3SGVpZ2h0ID0gMDtcbiAgbGV0IGk7XG4gIGlmICh0eXBlb2Ygc3BlZWQgPT09ICdudW1iZXInKSB7XG4gICAgc3dpcGVyLnNldFRyYW5zaXRpb24oc3BlZWQpO1xuICB9IGVsc2UgaWYgKHNwZWVkID09PSB0cnVlKSB7XG4gICAgc3dpcGVyLnNldFRyYW5zaXRpb24oc3dpcGVyLnBhcmFtcy5zcGVlZCk7XG4gIH1cbiAgLy8gRmluZCBzbGlkZXMgY3VycmVudGx5IGluIHZpZXdcbiAgaWYgKHN3aXBlci5wYXJhbXMuc2xpZGVzUGVyVmlldyAhPT0gJ2F1dG8nICYmIHN3aXBlci5wYXJhbXMuc2xpZGVzUGVyVmlldyA+IDEpIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgTWF0aC5jZWlsKHN3aXBlci5wYXJhbXMuc2xpZGVzUGVyVmlldyk7IGkgKz0gMSkge1xuICAgICAgY29uc3QgaW5kZXggPSBzd2lwZXIuYWN0aXZlSW5kZXggKyBpO1xuICAgICAgaWYgKGluZGV4ID4gc3dpcGVyLnNsaWRlcy5sZW5ndGgpIGJyZWFrO1xuICAgICAgYWN0aXZlU2xpZGVzLnB1c2goc3dpcGVyLnNsaWRlcy5lcShpbmRleClbMF0pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBhY3RpdmVTbGlkZXMucHVzaChzd2lwZXIuc2xpZGVzLmVxKHN3aXBlci5hY3RpdmVJbmRleClbMF0pO1xuICB9XG5cbiAgLy8gRmluZCBuZXcgaGVpZ2h0IGZyb20gaGlnaGVzdCBzbGlkZSBpbiB2aWV3XG4gIGZvciAoaSA9IDA7IGkgPCBhY3RpdmVTbGlkZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICBpZiAodHlwZW9mIGFjdGl2ZVNsaWRlc1tpXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnN0IGhlaWdodCA9IGFjdGl2ZVNsaWRlc1tpXS5vZmZzZXRIZWlnaHQ7XG4gICAgICBuZXdIZWlnaHQgPSBoZWlnaHQgPiBuZXdIZWlnaHQgPyBoZWlnaHQgOiBuZXdIZWlnaHQ7XG4gICAgfVxuICB9XG5cbiAgLy8gVXBkYXRlIEhlaWdodFxuICBpZiAobmV3SGVpZ2h0KSBzd2lwZXIuJHdyYXBwZXJFbC5jc3MoJ2hlaWdodCcsIGAke25ld0hlaWdodH1weGApO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVTbGlkZXNPZmZzZXQgKCkge1xuICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICBjb25zdCBzbGlkZXMgPSBzd2lwZXIuc2xpZGVzO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNsaWRlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgIHNsaWRlc1tpXS5zd2lwZXJTbGlkZU9mZnNldCA9IHN3aXBlci5pc0hvcml6b250YWwoKSA/IHNsaWRlc1tpXS5vZmZzZXRMZWZ0IDogc2xpZGVzW2ldLm9mZnNldFRvcDtcbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVTbGlkZXNQcm9ncmVzcyAodHJhbnNsYXRlID0gKHRoaXMgJiYgdGhpcy50cmFuc2xhdGUpIHx8IDApIHtcbiAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgY29uc3QgcGFyYW1zID0gc3dpcGVyLnBhcmFtcztcblxuICBjb25zdCB7IHNsaWRlcywgcnRsVHJhbnNsYXRlOiBydGwgfSA9IHN3aXBlcjtcblxuICBpZiAoc2xpZGVzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICBpZiAodHlwZW9mIHNsaWRlc1swXS5zd2lwZXJTbGlkZU9mZnNldCA9PT0gJ3VuZGVmaW5lZCcpIHN3aXBlci51cGRhdGVTbGlkZXNPZmZzZXQoKTtcblxuICBsZXQgb2Zmc2V0Q2VudGVyID0gLXRyYW5zbGF0ZTtcbiAgaWYgKHJ0bCkgb2Zmc2V0Q2VudGVyID0gdHJhbnNsYXRlO1xuXG4gIC8vIFZpc2libGUgU2xpZGVzXG4gIHNsaWRlcy5yZW1vdmVDbGFzcyhwYXJhbXMuc2xpZGVWaXNpYmxlQ2xhc3MpO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2xpZGVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgY29uc3Qgc2xpZGUgPSBzbGlkZXNbaV07XG4gICAgY29uc3Qgc2xpZGVQcm9ncmVzcyA9XG4gICAgICAoXG4gICAgICAgIChvZmZzZXRDZW50ZXIgKyAocGFyYW1zLmNlbnRlcmVkU2xpZGVzID8gc3dpcGVyLm1pblRyYW5zbGF0ZSgpIDogMCkpIC0gc2xpZGUuc3dpcGVyU2xpZGVPZmZzZXRcbiAgICAgICkgLyAoc2xpZGUuc3dpcGVyU2xpZGVTaXplICsgcGFyYW1zLnNwYWNlQmV0d2Vlbik7XG4gICAgaWYgKHBhcmFtcy53YXRjaFNsaWRlc1Zpc2liaWxpdHkpIHtcbiAgICAgIGNvbnN0IHNsaWRlQmVmb3JlID0gLShvZmZzZXRDZW50ZXIgLSBzbGlkZS5zd2lwZXJTbGlkZU9mZnNldCk7XG4gICAgICBjb25zdCBzbGlkZUFmdGVyID0gc2xpZGVCZWZvcmUgKyBzd2lwZXIuc2xpZGVzU2l6ZXNHcmlkW2ldO1xuICAgICAgY29uc3QgaXNWaXNpYmxlID1cbiAgICAgICAgICAgICAgICAoc2xpZGVCZWZvcmUgPj0gMCAmJiBzbGlkZUJlZm9yZSA8IHN3aXBlci5zaXplKSB8fFxuICAgICAgICAgICAgICAgIChzbGlkZUFmdGVyID4gMCAmJiBzbGlkZUFmdGVyIDw9IHN3aXBlci5zaXplKSB8fFxuICAgICAgICAgICAgICAgIChzbGlkZUJlZm9yZSA8PSAwICYmIHNsaWRlQWZ0ZXIgPj0gc3dpcGVyLnNpemUpO1xuICAgICAgaWYgKGlzVmlzaWJsZSkge1xuICAgICAgICBzbGlkZXMuZXEoaSkuYWRkQ2xhc3MocGFyYW1zLnNsaWRlVmlzaWJsZUNsYXNzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgc2xpZGUucHJvZ3Jlc3MgPSBydGwgPyAtc2xpZGVQcm9ncmVzcyA6IHNsaWRlUHJvZ3Jlc3M7XG4gIH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlUHJvZ3Jlc3MgKHRyYW5zbGF0ZSA9ICh0aGlzICYmIHRoaXMudHJhbnNsYXRlKSB8fCAwKSB7XG4gIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gIGNvbnN0IHBhcmFtcyA9IHN3aXBlci5wYXJhbXM7XG5cbiAgY29uc3QgdHJhbnNsYXRlc0RpZmYgPSBzd2lwZXIubWF4VHJhbnNsYXRlKCkgLSBzd2lwZXIubWluVHJhbnNsYXRlKCk7XG4gIGxldCB7IHByb2dyZXNzLCBpc0JlZ2lubmluZywgaXNFbmQgfSA9IHN3aXBlcjtcbiAgY29uc3Qgd2FzQmVnaW5uaW5nID0gaXNCZWdpbm5pbmc7XG4gIGNvbnN0IHdhc0VuZCA9IGlzRW5kO1xuICBpZiAodHJhbnNsYXRlc0RpZmYgPT09IDApIHtcbiAgICBwcm9ncmVzcyA9IDA7XG4gICAgaXNCZWdpbm5pbmcgPSB0cnVlO1xuICAgIGlzRW5kID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICBwcm9ncmVzcyA9ICh0cmFuc2xhdGUgLSBzd2lwZXIubWluVHJhbnNsYXRlKCkpIC8gKHRyYW5zbGF0ZXNEaWZmKTtcbiAgICBpc0JlZ2lubmluZyA9IHByb2dyZXNzIDw9IDA7XG4gICAgaXNFbmQgPSBwcm9ncmVzcyA+PSAxO1xuICB9XG4gIFV0aWxzLmV4dGVuZChzd2lwZXIsIHtcbiAgICBwcm9ncmVzcyxcbiAgICBpc0JlZ2lubmluZyxcbiAgICBpc0VuZCxcbiAgfSk7XG5cbiAgaWYgKHBhcmFtcy53YXRjaFNsaWRlc1Byb2dyZXNzIHx8IHBhcmFtcy53YXRjaFNsaWRlc1Zpc2liaWxpdHkpIHN3aXBlci51cGRhdGVTbGlkZXNQcm9ncmVzcyh0cmFuc2xhdGUpO1xuXG4gIGlmIChpc0JlZ2lubmluZyAmJiAhd2FzQmVnaW5uaW5nKSB7XG4gICAgc3dpcGVyLmVtaXQoJ3JlYWNoQmVnaW5uaW5nIHRvRWRnZScpO1xuICB9XG4gIGlmIChpc0VuZCAmJiAhd2FzRW5kKSB7XG4gICAgc3dpcGVyLmVtaXQoJ3JlYWNoRW5kIHRvRWRnZScpO1xuICB9XG4gIGlmICgod2FzQmVnaW5uaW5nICYmICFpc0JlZ2lubmluZykgfHwgKHdhc0VuZCAmJiAhaXNFbmQpKSB7XG4gICAgc3dpcGVyLmVtaXQoJ2Zyb21FZGdlJyk7XG4gIH1cblxuICBzd2lwZXIuZW1pdCgncHJvZ3Jlc3MnLCBwcm9ncmVzcyk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVNsaWRlc0NsYXNzZXMgKCkge1xuICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuXG4gIGNvbnN0IHtcbiAgICBzbGlkZXMsIHBhcmFtcywgJHdyYXBwZXJFbCwgYWN0aXZlSW5kZXgsIHJlYWxJbmRleCxcbiAgfSA9IHN3aXBlcjtcbiAgY29uc3QgaXNWaXJ0dWFsID0gc3dpcGVyLnZpcnR1YWwgJiYgcGFyYW1zLnZpcnR1YWwuZW5hYmxlZDtcblxuICBzbGlkZXMucmVtb3ZlQ2xhc3MoYCR7cGFyYW1zLnNsaWRlQWN0aXZlQ2xhc3N9ICR7cGFyYW1zLnNsaWRlTmV4dENsYXNzfSAke3BhcmFtcy5zbGlkZVByZXZDbGFzc30gJHtwYXJhbXMuc2xpZGVEdXBsaWNhdGVBY3RpdmVDbGFzc30gJHtwYXJhbXMuc2xpZGVEdXBsaWNhdGVOZXh0Q2xhc3N9ICR7cGFyYW1zLnNsaWRlRHVwbGljYXRlUHJldkNsYXNzfWApO1xuXG4gIGxldCBhY3RpdmVTbGlkZTtcbiAgaWYgKGlzVmlydHVhbCkge1xuICAgIGFjdGl2ZVNsaWRlID0gc3dpcGVyLiR3cmFwcGVyRWwuZmluZChgLiR7cGFyYW1zLnNsaWRlQ2xhc3N9W2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4PVwiJHthY3RpdmVJbmRleH1cIl1gKTtcbiAgfSBlbHNlIHtcbiAgICBhY3RpdmVTbGlkZSA9IHNsaWRlcy5lcShhY3RpdmVJbmRleCk7XG4gIH1cblxuICAvLyBBY3RpdmUgY2xhc3Nlc1xuICBhY3RpdmVTbGlkZS5hZGRDbGFzcyhwYXJhbXMuc2xpZGVBY3RpdmVDbGFzcyk7XG5cbiAgaWYgKHBhcmFtcy5sb29wKSB7XG4gICAgLy8gRHVwbGljYXRlIHRvIGFsbCBsb29wZWQgc2xpZGVzXG4gICAgaWYgKGFjdGl2ZVNsaWRlLmhhc0NsYXNzKHBhcmFtcy5zbGlkZUR1cGxpY2F0ZUNsYXNzKSkge1xuICAgICAgJHdyYXBwZXJFbFxuICAgICAgICAuY2hpbGRyZW4oYC4ke3BhcmFtcy5zbGlkZUNsYXNzfTpub3QoLiR7cGFyYW1zLnNsaWRlRHVwbGljYXRlQ2xhc3N9KVtkYXRhLXN3aXBlci1zbGlkZS1pbmRleD1cIiR7cmVhbEluZGV4fVwiXWApXG4gICAgICAgIC5hZGRDbGFzcyhwYXJhbXMuc2xpZGVEdXBsaWNhdGVBY3RpdmVDbGFzcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICR3cmFwcGVyRWxcbiAgICAgICAgLmNoaWxkcmVuKGAuJHtwYXJhbXMuc2xpZGVDbGFzc30uJHtwYXJhbXMuc2xpZGVEdXBsaWNhdGVDbGFzc31bZGF0YS1zd2lwZXItc2xpZGUtaW5kZXg9XCIke3JlYWxJbmRleH1cIl1gKVxuICAgICAgICAuYWRkQ2xhc3MocGFyYW1zLnNsaWRlRHVwbGljYXRlQWN0aXZlQ2xhc3MpO1xuICAgIH1cbiAgfVxuICAvLyBOZXh0IFNsaWRlXG4gIGxldCBuZXh0U2xpZGUgPSBhY3RpdmVTbGlkZS5uZXh0QWxsKGAuJHtwYXJhbXMuc2xpZGVDbGFzc31gKS5lcSgwKS5hZGRDbGFzcyhwYXJhbXMuc2xpZGVOZXh0Q2xhc3MpO1xuICBpZiAocGFyYW1zLmxvb3AgJiYgbmV4dFNsaWRlLmxlbmd0aCA9PT0gMCkge1xuICAgIG5leHRTbGlkZSA9IHNsaWRlcy5lcSgwKTtcbiAgICBuZXh0U2xpZGUuYWRkQ2xhc3MocGFyYW1zLnNsaWRlTmV4dENsYXNzKTtcbiAgfVxuICAvLyBQcmV2IFNsaWRlXG4gIGxldCBwcmV2U2xpZGUgPSBhY3RpdmVTbGlkZS5wcmV2QWxsKGAuJHtwYXJhbXMuc2xpZGVDbGFzc31gKS5lcSgwKS5hZGRDbGFzcyhwYXJhbXMuc2xpZGVQcmV2Q2xhc3MpO1xuICBpZiAocGFyYW1zLmxvb3AgJiYgcHJldlNsaWRlLmxlbmd0aCA9PT0gMCkge1xuICAgIHByZXZTbGlkZSA9IHNsaWRlcy5lcSgtMSk7XG4gICAgcHJldlNsaWRlLmFkZENsYXNzKHBhcmFtcy5zbGlkZVByZXZDbGFzcyk7XG4gIH1cbiAgaWYgKHBhcmFtcy5sb29wKSB7XG4gICAgLy8gRHVwbGljYXRlIHRvIGFsbCBsb29wZWQgc2xpZGVzXG4gICAgaWYgKG5leHRTbGlkZS5oYXNDbGFzcyhwYXJhbXMuc2xpZGVEdXBsaWNhdGVDbGFzcykpIHtcbiAgICAgICR3cmFwcGVyRWxcbiAgICAgICAgLmNoaWxkcmVuKGAuJHtwYXJhbXMuc2xpZGVDbGFzc306bm90KC4ke3BhcmFtcy5zbGlkZUR1cGxpY2F0ZUNsYXNzfSlbZGF0YS1zd2lwZXItc2xpZGUtaW5kZXg9XCIke25leHRTbGlkZS5hdHRyKCdkYXRhLXN3aXBlci1zbGlkZS1pbmRleCcpfVwiXWApXG4gICAgICAgIC5hZGRDbGFzcyhwYXJhbXMuc2xpZGVEdXBsaWNhdGVOZXh0Q2xhc3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICAkd3JhcHBlckVsXG4gICAgICAgIC5jaGlsZHJlbihgLiR7cGFyYW1zLnNsaWRlQ2xhc3N9LiR7cGFyYW1zLnNsaWRlRHVwbGljYXRlQ2xhc3N9W2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4PVwiJHtuZXh0U2xpZGUuYXR0cignZGF0YS1zd2lwZXItc2xpZGUtaW5kZXgnKX1cIl1gKVxuICAgICAgICAuYWRkQ2xhc3MocGFyYW1zLnNsaWRlRHVwbGljYXRlTmV4dENsYXNzKTtcbiAgICB9XG4gICAgaWYgKHByZXZTbGlkZS5oYXNDbGFzcyhwYXJhbXMuc2xpZGVEdXBsaWNhdGVDbGFzcykpIHtcbiAgICAgICR3cmFwcGVyRWxcbiAgICAgICAgLmNoaWxkcmVuKGAuJHtwYXJhbXMuc2xpZGVDbGFzc306bm90KC4ke3BhcmFtcy5zbGlkZUR1cGxpY2F0ZUNsYXNzfSlbZGF0YS1zd2lwZXItc2xpZGUtaW5kZXg9XCIke3ByZXZTbGlkZS5hdHRyKCdkYXRhLXN3aXBlci1zbGlkZS1pbmRleCcpfVwiXWApXG4gICAgICAgIC5hZGRDbGFzcyhwYXJhbXMuc2xpZGVEdXBsaWNhdGVQcmV2Q2xhc3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICAkd3JhcHBlckVsXG4gICAgICAgIC5jaGlsZHJlbihgLiR7cGFyYW1zLnNsaWRlQ2xhc3N9LiR7cGFyYW1zLnNsaWRlRHVwbGljYXRlQ2xhc3N9W2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4PVwiJHtwcmV2U2xpZGUuYXR0cignZGF0YS1zd2lwZXItc2xpZGUtaW5kZXgnKX1cIl1gKVxuICAgICAgICAuYWRkQ2xhc3MocGFyYW1zLnNsaWRlRHVwbGljYXRlUHJldkNsYXNzKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlQWN0aXZlSW5kZXggKG5ld0FjdGl2ZUluZGV4KSB7XG4gIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gIGNvbnN0IHRyYW5zbGF0ZSA9IHN3aXBlci5ydGxUcmFuc2xhdGUgPyBzd2lwZXIudHJhbnNsYXRlIDogLXN3aXBlci50cmFuc2xhdGU7XG4gIGNvbnN0IHtcbiAgICBzbGlkZXNHcmlkLCBzbmFwR3JpZCwgcGFyYW1zLCBhY3RpdmVJbmRleDogcHJldmlvdXNJbmRleCwgcmVhbEluZGV4OiBwcmV2aW91c1JlYWxJbmRleCwgc25hcEluZGV4OiBwcmV2aW91c1NuYXBJbmRleCxcbiAgfSA9IHN3aXBlcjtcbiAgbGV0IGFjdGl2ZUluZGV4ID0gbmV3QWN0aXZlSW5kZXg7XG4gIGxldCBzbmFwSW5kZXg7XG4gIGlmICh0eXBlb2YgYWN0aXZlSW5kZXggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzbGlkZXNHcmlkLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBpZiAodHlwZW9mIHNsaWRlc0dyaWRbaSArIDFdICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBpZiAodHJhbnNsYXRlID49IHNsaWRlc0dyaWRbaV0gJiYgdHJhbnNsYXRlIDwgc2xpZGVzR3JpZFtpICsgMV0gLSAoKHNsaWRlc0dyaWRbaSArIDFdIC0gc2xpZGVzR3JpZFtpXSkgLyAyKSkge1xuICAgICAgICAgIGFjdGl2ZUluZGV4ID0gaTtcbiAgICAgICAgfSBlbHNlIGlmICh0cmFuc2xhdGUgPj0gc2xpZGVzR3JpZFtpXSAmJiB0cmFuc2xhdGUgPCBzbGlkZXNHcmlkW2kgKyAxXSkge1xuICAgICAgICAgIGFjdGl2ZUluZGV4ID0gaSArIDE7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHJhbnNsYXRlID49IHNsaWRlc0dyaWRbaV0pIHtcbiAgICAgICAgYWN0aXZlSW5kZXggPSBpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBOb3JtYWxpemUgc2xpZGVJbmRleFxuICAgIGlmIChwYXJhbXMubm9ybWFsaXplU2xpZGVJbmRleCkge1xuICAgICAgaWYgKGFjdGl2ZUluZGV4IDwgMCB8fCB0eXBlb2YgYWN0aXZlSW5kZXggPT09ICd1bmRlZmluZWQnKSBhY3RpdmVJbmRleCA9IDA7XG4gICAgfVxuICB9XG4gIGlmIChzbmFwR3JpZC5pbmRleE9mKHRyYW5zbGF0ZSkgPj0gMCkge1xuICAgIHNuYXBJbmRleCA9IHNuYXBHcmlkLmluZGV4T2YodHJhbnNsYXRlKTtcbiAgfSBlbHNlIHtcbiAgICBzbmFwSW5kZXggPSBNYXRoLmZsb29yKGFjdGl2ZUluZGV4IC8gcGFyYW1zLnNsaWRlc1Blckdyb3VwKTtcbiAgfVxuICBpZiAoc25hcEluZGV4ID49IHNuYXBHcmlkLmxlbmd0aCkgc25hcEluZGV4ID0gc25hcEdyaWQubGVuZ3RoIC0gMTtcbiAgaWYgKGFjdGl2ZUluZGV4ID09PSBwcmV2aW91c0luZGV4KSB7XG4gICAgaWYgKHNuYXBJbmRleCAhPT0gcHJldmlvdXNTbmFwSW5kZXgpIHtcbiAgICAgIHN3aXBlci5zbmFwSW5kZXggPSBzbmFwSW5kZXg7XG4gICAgICBzd2lwZXIuZW1pdCgnc25hcEluZGV4Q2hhbmdlJyk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIEdldCByZWFsIGluZGV4XG4gIGNvbnN0IHJlYWxJbmRleCA9IHBhcnNlSW50KHN3aXBlci5zbGlkZXMuZXEoYWN0aXZlSW5kZXgpLmF0dHIoJ2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4JykgfHwgYWN0aXZlSW5kZXgsIDEwKTtcblxuICBVdGlscy5leHRlbmQoc3dpcGVyLCB7XG4gICAgc25hcEluZGV4LFxuICAgIHJlYWxJbmRleCxcbiAgICBwcmV2aW91c0luZGV4LFxuICAgIGFjdGl2ZUluZGV4LFxuICB9KTtcbiAgc3dpcGVyLmVtaXQoJ2FjdGl2ZUluZGV4Q2hhbmdlJyk7XG4gIHN3aXBlci5lbWl0KCdzbmFwSW5kZXhDaGFuZ2UnKTtcbiAgaWYgKHByZXZpb3VzUmVhbEluZGV4ICE9PSByZWFsSW5kZXgpIHtcbiAgICBzd2lwZXIuZW1pdCgncmVhbEluZGV4Q2hhbmdlJyk7XG4gIH1cbiAgc3dpcGVyLmVtaXQoJ3NsaWRlQ2hhbmdlJyk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUNsaWNrZWRTbGlkZSAoZSkge1xuICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICBjb25zdCBwYXJhbXMgPSBzd2lwZXIucGFyYW1zO1xuICBjb25zdCBzbGlkZSA9ICQoZS50YXJnZXQpLmNsb3Nlc3QoYC4ke3BhcmFtcy5zbGlkZUNsYXNzfWApWzBdO1xuICBsZXQgc2xpZGVGb3VuZCA9IGZhbHNlO1xuICBpZiAoc2xpZGUpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN3aXBlci5zbGlkZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGlmIChzd2lwZXIuc2xpZGVzW2ldID09PSBzbGlkZSkgc2xpZGVGb3VuZCA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKHNsaWRlICYmIHNsaWRlRm91bmQpIHtcbiAgICBzd2lwZXIuY2xpY2tlZFNsaWRlID0gc2xpZGU7XG4gICAgaWYgKHN3aXBlci52aXJ0dWFsICYmIHN3aXBlci5wYXJhbXMudmlydHVhbC5lbmFibGVkKSB7XG4gICAgICBzd2lwZXIuY2xpY2tlZEluZGV4ID0gcGFyc2VJbnQoJChzbGlkZSkuYXR0cignZGF0YS1zd2lwZXItc2xpZGUtaW5kZXgnKSwgMTApO1xuICAgIH0gZWxzZSB7XG4gICAgICBzd2lwZXIuY2xpY2tlZEluZGV4ID0gJChzbGlkZSkuaW5kZXgoKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc3dpcGVyLmNsaWNrZWRTbGlkZSA9IHVuZGVmaW5lZDtcbiAgICBzd2lwZXIuY2xpY2tlZEluZGV4ID0gdW5kZWZpbmVkO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAocGFyYW1zLnNsaWRlVG9DbGlja2VkU2xpZGUgJiYgc3dpcGVyLmNsaWNrZWRJbmRleCAhPT0gdW5kZWZpbmVkICYmIHN3aXBlci5jbGlja2VkSW5kZXggIT09IHN3aXBlci5hY3RpdmVJbmRleCkge1xuICAgIHN3aXBlci5zbGlkZVRvQ2xpY2tlZFNsaWRlKCk7XG4gIH1cbn1cblxudmFyIHVwZGF0ZSA9IHtcbiAgdXBkYXRlU2l6ZSxcbiAgdXBkYXRlU2xpZGVzLFxuICB1cGRhdGVBdXRvSGVpZ2h0LFxuICB1cGRhdGVTbGlkZXNPZmZzZXQsXG4gIHVwZGF0ZVNsaWRlc1Byb2dyZXNzLFxuICB1cGRhdGVQcm9ncmVzcyxcbiAgdXBkYXRlU2xpZGVzQ2xhc3NlcyxcbiAgdXBkYXRlQWN0aXZlSW5kZXgsXG4gIHVwZGF0ZUNsaWNrZWRTbGlkZSxcbn07XG5cbmZ1bmN0aW9uIGdldFRyYW5zbGF0ZSAoYXhpcyA9IHRoaXMuaXNIb3Jpem9udGFsKCkgPyAneCcgOiAneScpIHtcbiAgY29uc3Qgc3dpcGVyID0gdGhpcztcblxuICBjb25zdCB7XG4gICAgcGFyYW1zLCBydGxUcmFuc2xhdGU6IHJ0bCwgdHJhbnNsYXRlLCAkd3JhcHBlckVsLFxuICB9ID0gc3dpcGVyO1xuXG4gIGlmIChwYXJhbXMudmlydHVhbFRyYW5zbGF0ZSkge1xuICAgIHJldHVybiBydGwgPyAtdHJhbnNsYXRlIDogdHJhbnNsYXRlO1xuICB9XG5cbiAgbGV0IGN1cnJlbnRUcmFuc2xhdGUgPSBVdGlscy5nZXRUcmFuc2xhdGUoJHdyYXBwZXJFbFswXSwgYXhpcyk7XG4gIGlmIChydGwpIGN1cnJlbnRUcmFuc2xhdGUgPSAtY3VycmVudFRyYW5zbGF0ZTtcblxuICByZXR1cm4gY3VycmVudFRyYW5zbGF0ZSB8fCAwO1xufVxuXG5mdW5jdGlvbiBzZXRUcmFuc2xhdGUgKHRyYW5zbGF0ZSwgYnlDb250cm9sbGVyKSB7XG4gIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gIGNvbnN0IHtcbiAgICBydGxUcmFuc2xhdGU6IHJ0bCwgcGFyYW1zLCAkd3JhcHBlckVsLCBwcm9ncmVzcyxcbiAgfSA9IHN3aXBlcjtcbiAgbGV0IHggPSAwO1xuICBsZXQgeSA9IDA7XG4gIGNvbnN0IHogPSAwO1xuXG4gIGlmIChzd2lwZXIuaXNIb3Jpem9udGFsKCkpIHtcbiAgICB4ID0gcnRsID8gLXRyYW5zbGF0ZSA6IHRyYW5zbGF0ZTtcbiAgfSBlbHNlIHtcbiAgICB5ID0gdHJhbnNsYXRlO1xuICB9XG5cbiAgaWYgKHBhcmFtcy5yb3VuZExlbmd0aHMpIHtcbiAgICB4ID0gTWF0aC5mbG9vcih4KTtcbiAgICB5ID0gTWF0aC5mbG9vcih5KTtcbiAgfVxuXG4gIGlmICghcGFyYW1zLnZpcnR1YWxUcmFuc2xhdGUpIHtcbiAgICBpZiAoU3VwcG9ydC50cmFuc2Zvcm1zM2QpICR3cmFwcGVyRWwudHJhbnNmb3JtKGB0cmFuc2xhdGUzZCgke3h9cHgsICR7eX1weCwgJHt6fXB4KWApO1xuICAgIGVsc2UgJHdyYXBwZXJFbC50cmFuc2Zvcm0oYHRyYW5zbGF0ZSgke3h9cHgsICR7eX1weClgKTtcbiAgfVxuXG4gIHN3aXBlci50cmFuc2xhdGUgPSBzd2lwZXIuaXNIb3Jpem9udGFsKCkgPyB4IDogeTtcblxuICAvLyBDaGVjayBpZiB3ZSBuZWVkIHRvIHVwZGF0ZSBwcm9ncmVzc1xuICBsZXQgbmV3UHJvZ3Jlc3M7XG4gIGNvbnN0IHRyYW5zbGF0ZXNEaWZmID0gc3dpcGVyLm1heFRyYW5zbGF0ZSgpIC0gc3dpcGVyLm1pblRyYW5zbGF0ZSgpO1xuICBpZiAodHJhbnNsYXRlc0RpZmYgPT09IDApIHtcbiAgICBuZXdQcm9ncmVzcyA9IDA7XG4gIH0gZWxzZSB7XG4gICAgbmV3UHJvZ3Jlc3MgPSAodHJhbnNsYXRlIC0gc3dpcGVyLm1pblRyYW5zbGF0ZSgpKSAvICh0cmFuc2xhdGVzRGlmZik7XG4gIH1cbiAgaWYgKG5ld1Byb2dyZXNzICE9PSBwcm9ncmVzcykge1xuICAgIHN3aXBlci51cGRhdGVQcm9ncmVzcyh0cmFuc2xhdGUpO1xuICB9XG5cbiAgc3dpcGVyLmVtaXQoJ3NldFRyYW5zbGF0ZScsIHN3aXBlci50cmFuc2xhdGUsIGJ5Q29udHJvbGxlcik7XG59XG5cbmZ1bmN0aW9uIG1pblRyYW5zbGF0ZSAoKSB7XG4gIHJldHVybiAoLXRoaXMuc25hcEdyaWRbMF0pO1xufVxuXG5mdW5jdGlvbiBtYXhUcmFuc2xhdGUgKCkge1xuICByZXR1cm4gKC10aGlzLnNuYXBHcmlkW3RoaXMuc25hcEdyaWQubGVuZ3RoIC0gMV0pO1xufVxuXG52YXIgdHJhbnNsYXRlID0ge1xuICBnZXRUcmFuc2xhdGUsXG4gIHNldFRyYW5zbGF0ZSxcbiAgbWluVHJhbnNsYXRlLFxuICBtYXhUcmFuc2xhdGUsXG59O1xuXG5mdW5jdGlvbiBzZXRUcmFuc2l0aW9uIChkdXJhdGlvbiwgYnlDb250cm9sbGVyKSB7XG4gIGNvbnN0IHN3aXBlciA9IHRoaXM7XG5cbiAgc3dpcGVyLiR3cmFwcGVyRWwudHJhbnNpdGlvbihkdXJhdGlvbik7XG5cbiAgc3dpcGVyLmVtaXQoJ3NldFRyYW5zaXRpb24nLCBkdXJhdGlvbiwgYnlDb250cm9sbGVyKTtcbn1cblxuZnVuY3Rpb24gdHJhbnNpdGlvblN0YXJ0IChydW5DYWxsYmFja3MgPSB0cnVlLCBkaXJlY3Rpb24pIHtcbiAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgY29uc3QgeyBhY3RpdmVJbmRleCwgcGFyYW1zLCBwcmV2aW91c0luZGV4IH0gPSBzd2lwZXI7XG4gIGlmIChwYXJhbXMuYXV0b0hlaWdodCkge1xuICAgIHN3aXBlci51cGRhdGVBdXRvSGVpZ2h0KCk7XG4gIH1cblxuICBsZXQgZGlyID0gZGlyZWN0aW9uO1xuICBpZiAoIWRpcikge1xuICAgIGlmIChhY3RpdmVJbmRleCA+IHByZXZpb3VzSW5kZXgpIGRpciA9ICduZXh0JztcbiAgICBlbHNlIGlmIChhY3RpdmVJbmRleCA8IHByZXZpb3VzSW5kZXgpIGRpciA9ICdwcmV2JztcbiAgICBlbHNlIGRpciA9ICdyZXNldCc7XG4gIH1cblxuICBzd2lwZXIuZW1pdCgndHJhbnNpdGlvblN0YXJ0Jyk7XG5cbiAgaWYgKHJ1bkNhbGxiYWNrcyAmJiBhY3RpdmVJbmRleCAhPT0gcHJldmlvdXNJbmRleCkge1xuICAgIGlmIChkaXIgPT09ICdyZXNldCcpIHtcbiAgICAgIHN3aXBlci5lbWl0KCdzbGlkZVJlc2V0VHJhbnNpdGlvblN0YXJ0Jyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN3aXBlci5lbWl0KCdzbGlkZUNoYW5nZVRyYW5zaXRpb25TdGFydCcpO1xuICAgIGlmIChkaXIgPT09ICduZXh0Jykge1xuICAgICAgc3dpcGVyLmVtaXQoJ3NsaWRlTmV4dFRyYW5zaXRpb25TdGFydCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzd2lwZXIuZW1pdCgnc2xpZGVQcmV2VHJhbnNpdGlvblN0YXJ0Jyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHRyYW5zaXRpb25FbmQgKHJ1bkNhbGxiYWNrcyA9IHRydWUsIGRpcmVjdGlvbikge1xuICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICBjb25zdCB7IGFjdGl2ZUluZGV4LCBwcmV2aW91c0luZGV4IH0gPSBzd2lwZXI7XG4gIHN3aXBlci5hbmltYXRpbmcgPSBmYWxzZTtcbiAgc3dpcGVyLnNldFRyYW5zaXRpb24oMCk7XG5cbiAgbGV0IGRpciA9IGRpcmVjdGlvbjtcbiAgaWYgKCFkaXIpIHtcbiAgICBpZiAoYWN0aXZlSW5kZXggPiBwcmV2aW91c0luZGV4KSBkaXIgPSAnbmV4dCc7XG4gICAgZWxzZSBpZiAoYWN0aXZlSW5kZXggPCBwcmV2aW91c0luZGV4KSBkaXIgPSAncHJldic7XG4gICAgZWxzZSBkaXIgPSAncmVzZXQnO1xuICB9XG5cbiAgc3dpcGVyLmVtaXQoJ3RyYW5zaXRpb25FbmQnKTtcblxuICBpZiAocnVuQ2FsbGJhY2tzICYmIGFjdGl2ZUluZGV4ICE9PSBwcmV2aW91c0luZGV4KSB7XG4gICAgaWYgKGRpciA9PT0gJ3Jlc2V0Jykge1xuICAgICAgc3dpcGVyLmVtaXQoJ3NsaWRlUmVzZXRUcmFuc2l0aW9uRW5kJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN3aXBlci5lbWl0KCdzbGlkZUNoYW5nZVRyYW5zaXRpb25FbmQnKTtcbiAgICBpZiAoZGlyID09PSAnbmV4dCcpIHtcbiAgICAgIHN3aXBlci5lbWl0KCdzbGlkZU5leHRUcmFuc2l0aW9uRW5kJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN3aXBlci5lbWl0KCdzbGlkZVByZXZUcmFuc2l0aW9uRW5kJyk7XG4gICAgfVxuICB9XG59XG5cbnZhciB0cmFuc2l0aW9uID0ge1xuICBzZXRUcmFuc2l0aW9uLFxuICB0cmFuc2l0aW9uU3RhcnQsXG4gIHRyYW5zaXRpb25FbmQsXG59O1xuXG5mdW5jdGlvbiBzbGlkZVRvIChpbmRleCA9IDAsIHNwZWVkID0gdGhpcy5wYXJhbXMuc3BlZWQsIHJ1bkNhbGxiYWNrcyA9IHRydWUsIGludGVybmFsKSB7XG4gIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gIGxldCBzbGlkZUluZGV4ID0gaW5kZXg7XG4gIGlmIChzbGlkZUluZGV4IDwgMCkgc2xpZGVJbmRleCA9IDA7XG5cbiAgY29uc3Qge1xuICAgIHBhcmFtcywgc25hcEdyaWQsIHNsaWRlc0dyaWQsIHByZXZpb3VzSW5kZXgsIGFjdGl2ZUluZGV4LCBydGxUcmFuc2xhdGU6IHJ0bCxcbiAgfSA9IHN3aXBlcjtcbiAgaWYgKHN3aXBlci5hbmltYXRpbmcgJiYgcGFyYW1zLnByZXZlbnRJbnRlcmNhdGlvbk9uVHJhbnNpdGlvbikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGxldCBzbmFwSW5kZXggPSBNYXRoLmZsb29yKHNsaWRlSW5kZXggLyBwYXJhbXMuc2xpZGVzUGVyR3JvdXApO1xuICBpZiAoc25hcEluZGV4ID49IHNuYXBHcmlkLmxlbmd0aCkgc25hcEluZGV4ID0gc25hcEdyaWQubGVuZ3RoIC0gMTtcblxuICBpZiAoKGFjdGl2ZUluZGV4IHx8IHBhcmFtcy5pbml0aWFsU2xpZGUgfHwgMCkgPT09IChwcmV2aW91c0luZGV4IHx8IDApICYmIHJ1bkNhbGxiYWNrcykge1xuICAgIHN3aXBlci5lbWl0KCdiZWZvcmVTbGlkZUNoYW5nZVN0YXJ0Jyk7XG4gIH1cblxuICBjb25zdCB0cmFuc2xhdGUgPSAtc25hcEdyaWRbc25hcEluZGV4XTtcblxuICAvLyBVcGRhdGUgcHJvZ3Jlc3NcbiAgc3dpcGVyLnVwZGF0ZVByb2dyZXNzKHRyYW5zbGF0ZSk7XG5cbiAgLy8gTm9ybWFsaXplIHNsaWRlSW5kZXhcbiAgaWYgKHBhcmFtcy5ub3JtYWxpemVTbGlkZUluZGV4KSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzbGlkZXNHcmlkLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBpZiAoLU1hdGguZmxvb3IodHJhbnNsYXRlICogMTAwKSA+PSBNYXRoLmZsb29yKHNsaWRlc0dyaWRbaV0gKiAxMDApKSB7XG4gICAgICAgIHNsaWRlSW5kZXggPSBpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvLyBEaXJlY3Rpb25zIGxvY2tzXG4gIGlmIChzd2lwZXIuaW5pdGlhbGl6ZWQgJiYgc2xpZGVJbmRleCAhPT0gYWN0aXZlSW5kZXgpIHtcbiAgICBpZiAoIXN3aXBlci5hbGxvd1NsaWRlTmV4dCAmJiB0cmFuc2xhdGUgPCBzd2lwZXIudHJhbnNsYXRlICYmIHRyYW5zbGF0ZSA8IHN3aXBlci5taW5UcmFuc2xhdGUoKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIXN3aXBlci5hbGxvd1NsaWRlUHJldiAmJiB0cmFuc2xhdGUgPiBzd2lwZXIudHJhbnNsYXRlICYmIHRyYW5zbGF0ZSA+IHN3aXBlci5tYXhUcmFuc2xhdGUoKSkge1xuICAgICAgaWYgKChhY3RpdmVJbmRleCB8fCAwKSAhPT0gc2xpZGVJbmRleCkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGxldCBkaXJlY3Rpb247XG4gIGlmIChzbGlkZUluZGV4ID4gYWN0aXZlSW5kZXgpIGRpcmVjdGlvbiA9ICduZXh0JztcbiAgZWxzZSBpZiAoc2xpZGVJbmRleCA8IGFjdGl2ZUluZGV4KSBkaXJlY3Rpb24gPSAncHJldic7XG4gIGVsc2UgZGlyZWN0aW9uID0gJ3Jlc2V0JztcblxuXG4gIC8vIFVwZGF0ZSBJbmRleFxuICBpZiAoKHJ0bCAmJiAtdHJhbnNsYXRlID09PSBzd2lwZXIudHJhbnNsYXRlKSB8fCAoIXJ0bCAmJiB0cmFuc2xhdGUgPT09IHN3aXBlci50cmFuc2xhdGUpKSB7XG4gICAgc3dpcGVyLnVwZGF0ZUFjdGl2ZUluZGV4KHNsaWRlSW5kZXgpO1xuICAgIC8vIFVwZGF0ZSBIZWlnaHRcbiAgICBpZiAocGFyYW1zLmF1dG9IZWlnaHQpIHtcbiAgICAgIHN3aXBlci51cGRhdGVBdXRvSGVpZ2h0KCk7XG4gICAgfVxuICAgIHN3aXBlci51cGRhdGVTbGlkZXNDbGFzc2VzKCk7XG4gICAgaWYgKHBhcmFtcy5lZmZlY3QgIT09ICdzbGlkZScpIHtcbiAgICAgIHN3aXBlci5zZXRUcmFuc2xhdGUodHJhbnNsYXRlKTtcbiAgICB9XG4gICAgaWYgKGRpcmVjdGlvbiAhPT0gJ3Jlc2V0Jykge1xuICAgICAgc3dpcGVyLnRyYW5zaXRpb25TdGFydChydW5DYWxsYmFja3MsIGRpcmVjdGlvbik7XG4gICAgICBzd2lwZXIudHJhbnNpdGlvbkVuZChydW5DYWxsYmFja3MsIGRpcmVjdGlvbik7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChzcGVlZCA9PT0gMCB8fCAhU3VwcG9ydC50cmFuc2l0aW9uKSB7XG4gICAgc3dpcGVyLnNldFRyYW5zaXRpb24oMCk7XG4gICAgc3dpcGVyLnNldFRyYW5zbGF0ZSh0cmFuc2xhdGUpO1xuICAgIHN3aXBlci51cGRhdGVBY3RpdmVJbmRleChzbGlkZUluZGV4KTtcbiAgICBzd2lwZXIudXBkYXRlU2xpZGVzQ2xhc3NlcygpO1xuICAgIHN3aXBlci5lbWl0KCdiZWZvcmVUcmFuc2l0aW9uU3RhcnQnLCBzcGVlZCwgaW50ZXJuYWwpO1xuICAgIHN3aXBlci50cmFuc2l0aW9uU3RhcnQocnVuQ2FsbGJhY2tzLCBkaXJlY3Rpb24pO1xuICAgIHN3aXBlci50cmFuc2l0aW9uRW5kKHJ1bkNhbGxiYWNrcywgZGlyZWN0aW9uKTtcbiAgfSBlbHNlIHtcbiAgICBzd2lwZXIuc2V0VHJhbnNpdGlvbihzcGVlZCk7XG4gICAgc3dpcGVyLnNldFRyYW5zbGF0ZSh0cmFuc2xhdGUpO1xuICAgIHN3aXBlci51cGRhdGVBY3RpdmVJbmRleChzbGlkZUluZGV4KTtcbiAgICBzd2lwZXIudXBkYXRlU2xpZGVzQ2xhc3NlcygpO1xuICAgIHN3aXBlci5lbWl0KCdiZWZvcmVUcmFuc2l0aW9uU3RhcnQnLCBzcGVlZCwgaW50ZXJuYWwpO1xuICAgIHN3aXBlci50cmFuc2l0aW9uU3RhcnQocnVuQ2FsbGJhY2tzLCBkaXJlY3Rpb24pO1xuICAgIGlmICghc3dpcGVyLmFuaW1hdGluZykge1xuICAgICAgc3dpcGVyLmFuaW1hdGluZyA9IHRydWU7XG4gICAgICBpZiAoIXN3aXBlci5vblNsaWRlVG9XcmFwcGVyVHJhbnNpdGlvbkVuZCkge1xuICAgICAgICBzd2lwZXIub25TbGlkZVRvV3JhcHBlclRyYW5zaXRpb25FbmQgPSBmdW5jdGlvbiB0cmFuc2l0aW9uRW5kKGUpIHtcbiAgICAgICAgICBpZiAoIXN3aXBlciB8fCBzd2lwZXIuZGVzdHJveWVkKSByZXR1cm47XG4gICAgICAgICAgaWYgKGUudGFyZ2V0ICE9PSB0aGlzKSByZXR1cm47XG4gICAgICAgICAgc3dpcGVyLiR3cmFwcGVyRWxbMF0ucmVtb3ZlRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIHN3aXBlci5vblNsaWRlVG9XcmFwcGVyVHJhbnNpdGlvbkVuZCk7XG4gICAgICAgICAgc3dpcGVyLiR3cmFwcGVyRWxbMF0ucmVtb3ZlRXZlbnRMaXN0ZW5lcignd2Via2l0VHJhbnNpdGlvbkVuZCcsIHN3aXBlci5vblNsaWRlVG9XcmFwcGVyVHJhbnNpdGlvbkVuZCk7XG4gICAgICAgICAgc3dpcGVyLnRyYW5zaXRpb25FbmQocnVuQ2FsbGJhY2tzLCBkaXJlY3Rpb24pO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgc3dpcGVyLiR3cmFwcGVyRWxbMF0uYWRkRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIHN3aXBlci5vblNsaWRlVG9XcmFwcGVyVHJhbnNpdGlvbkVuZCk7XG4gICAgICBzd2lwZXIuJHdyYXBwZXJFbFswXS5hZGRFdmVudExpc3RlbmVyKCd3ZWJraXRUcmFuc2l0aW9uRW5kJywgc3dpcGVyLm9uU2xpZGVUb1dyYXBwZXJUcmFuc2l0aW9uRW5kKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gc2xpZGVUb0xvb3AgKGluZGV4ID0gMCwgc3BlZWQgPSB0aGlzLnBhcmFtcy5zcGVlZCwgcnVuQ2FsbGJhY2tzID0gdHJ1ZSwgaW50ZXJuYWwpIHtcbiAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgbGV0IG5ld0luZGV4ID0gaW5kZXg7XG4gIGlmIChzd2lwZXIucGFyYW1zLmxvb3ApIHtcbiAgICBuZXdJbmRleCArPSBzd2lwZXIubG9vcGVkU2xpZGVzO1xuICB9XG5cbiAgcmV0dXJuIHN3aXBlci5zbGlkZVRvKG5ld0luZGV4LCBzcGVlZCwgcnVuQ2FsbGJhY2tzLCBpbnRlcm5hbCk7XG59XG5cbi8qIGVzbGludCBuby11bnVzZWQtdmFyczogXCJvZmZcIiAqL1xuZnVuY3Rpb24gc2xpZGVOZXh0IChzcGVlZCA9IHRoaXMucGFyYW1zLnNwZWVkLCBydW5DYWxsYmFja3MgPSB0cnVlLCBpbnRlcm5hbCkge1xuICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICBjb25zdCB7IHBhcmFtcywgYW5pbWF0aW5nIH0gPSBzd2lwZXI7XG4gIGlmIChwYXJhbXMubG9vcCkge1xuICAgIGlmIChhbmltYXRpbmcpIHJldHVybiBmYWxzZTtcbiAgICBzd2lwZXIubG9vcEZpeCgpO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgIHN3aXBlci5fY2xpZW50TGVmdCA9IHN3aXBlci4kd3JhcHBlckVsWzBdLmNsaWVudExlZnQ7XG4gICAgcmV0dXJuIHN3aXBlci5zbGlkZVRvKHN3aXBlci5hY3RpdmVJbmRleCArIHBhcmFtcy5zbGlkZXNQZXJHcm91cCwgc3BlZWQsIHJ1bkNhbGxiYWNrcywgaW50ZXJuYWwpO1xuICB9XG4gIHJldHVybiBzd2lwZXIuc2xpZGVUbyhzd2lwZXIuYWN0aXZlSW5kZXggKyBwYXJhbXMuc2xpZGVzUGVyR3JvdXAsIHNwZWVkLCBydW5DYWxsYmFja3MsIGludGVybmFsKTtcbn1cblxuLyogZXNsaW50IG5vLXVudXNlZC12YXJzOiBcIm9mZlwiICovXG5mdW5jdGlvbiBzbGlkZVByZXYgKHNwZWVkID0gdGhpcy5wYXJhbXMuc3BlZWQsIHJ1bkNhbGxiYWNrcyA9IHRydWUsIGludGVybmFsKSB7XG4gIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gIGNvbnN0IHtcbiAgICBwYXJhbXMsIGFuaW1hdGluZywgc25hcEdyaWQsIHNsaWRlc0dyaWQsIHJ0bFRyYW5zbGF0ZSxcbiAgfSA9IHN3aXBlcjtcblxuICBpZiAocGFyYW1zLmxvb3ApIHtcbiAgICBpZiAoYW5pbWF0aW5nKSByZXR1cm4gZmFsc2U7XG4gICAgc3dpcGVyLmxvb3BGaXgoKTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICBzd2lwZXIuX2NsaWVudExlZnQgPSBzd2lwZXIuJHdyYXBwZXJFbFswXS5jbGllbnRMZWZ0O1xuICB9XG4gIGNvbnN0IHRyYW5zbGF0ZSA9IHJ0bFRyYW5zbGF0ZSA/IHN3aXBlci50cmFuc2xhdGUgOiAtc3dpcGVyLnRyYW5zbGF0ZTtcbiAgY29uc3QgY3VycmVudFNuYXAgPSBzbmFwR3JpZFtzbmFwR3JpZC5pbmRleE9mKHRyYW5zbGF0ZSldO1xuICBjb25zdCBwcmV2U25hcCA9IHNuYXBHcmlkW3NuYXBHcmlkLmluZGV4T2YodHJhbnNsYXRlKSAtIDFdO1xuICBsZXQgcHJldkluZGV4O1xuXG4gIGlmIChwcmV2U25hcCkge1xuICAgIHByZXZJbmRleCA9IHNsaWRlc0dyaWQuaW5kZXhPZihwcmV2U25hcCk7XG4gICAgaWYgKHByZXZJbmRleCA8IDApIHByZXZJbmRleCA9IHN3aXBlci5hY3RpdmVJbmRleCAtIDE7XG4gIH1cbiAgcmV0dXJuIHN3aXBlci5zbGlkZVRvKHByZXZJbmRleCwgc3BlZWQsIHJ1bkNhbGxiYWNrcywgaW50ZXJuYWwpO1xufVxuXG4vKiBlc2xpbnQgbm8tdW51c2VkLXZhcnM6IFwib2ZmXCIgKi9cbmZ1bmN0aW9uIHNsaWRlUmVzZXQgKHNwZWVkID0gdGhpcy5wYXJhbXMuc3BlZWQsIHJ1bkNhbGxiYWNrcyA9IHRydWUsIGludGVybmFsKSB7XG4gIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gIHJldHVybiBzd2lwZXIuc2xpZGVUbyhzd2lwZXIuYWN0aXZlSW5kZXgsIHNwZWVkLCBydW5DYWxsYmFja3MsIGludGVybmFsKTtcbn1cblxuLyogZXNsaW50IG5vLXVudXNlZC12YXJzOiBcIm9mZlwiICovXG5mdW5jdGlvbiBzbGlkZVRvQ2xvc2VzdCAoc3BlZWQgPSB0aGlzLnBhcmFtcy5zcGVlZCwgcnVuQ2FsbGJhY2tzID0gdHJ1ZSwgaW50ZXJuYWwpIHtcbiAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgbGV0IGluZGV4ID0gc3dpcGVyLmFjdGl2ZUluZGV4O1xuICBjb25zdCBzbmFwSW5kZXggPSBNYXRoLmZsb29yKGluZGV4IC8gc3dpcGVyLnBhcmFtcy5zbGlkZXNQZXJHcm91cCk7XG5cbiAgaWYgKHNuYXBJbmRleCA8IHN3aXBlci5zbmFwR3JpZC5sZW5ndGggLSAxKSB7XG4gICAgY29uc3QgdHJhbnNsYXRlID0gc3dpcGVyLnJ0bFRyYW5zbGF0ZSA/IHN3aXBlci50cmFuc2xhdGUgOiAtc3dpcGVyLnRyYW5zbGF0ZTtcblxuICAgIGNvbnN0IGN1cnJlbnRTbmFwID0gc3dpcGVyLnNuYXBHcmlkW3NuYXBJbmRleF07XG4gICAgY29uc3QgbmV4dFNuYXAgPSBzd2lwZXIuc25hcEdyaWRbc25hcEluZGV4ICsgMV07XG5cbiAgICBpZiAoKHRyYW5zbGF0ZSAtIGN1cnJlbnRTbmFwKSA+IChuZXh0U25hcCAtIGN1cnJlbnRTbmFwKSAvIDIpIHtcbiAgICAgIGluZGV4ID0gc3dpcGVyLnBhcmFtcy5zbGlkZXNQZXJHcm91cDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3dpcGVyLnNsaWRlVG8oaW5kZXgsIHNwZWVkLCBydW5DYWxsYmFja3MsIGludGVybmFsKTtcbn1cblxuZnVuY3Rpb24gc2xpZGVUb0NsaWNrZWRTbGlkZSAoKSB7XG4gIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gIGNvbnN0IHsgcGFyYW1zLCAkd3JhcHBlckVsIH0gPSBzd2lwZXI7XG5cbiAgY29uc3Qgc2xpZGVzUGVyVmlldyA9IHBhcmFtcy5zbGlkZXNQZXJWaWV3ID09PSAnYXV0bycgPyBzd2lwZXIuc2xpZGVzUGVyVmlld0R5bmFtaWMoKSA6IHBhcmFtcy5zbGlkZXNQZXJWaWV3O1xuICBsZXQgc2xpZGVUb0luZGV4ID0gc3dpcGVyLmNsaWNrZWRJbmRleDtcbiAgbGV0IHJlYWxJbmRleDtcbiAgaWYgKHBhcmFtcy5sb29wKSB7XG4gICAgaWYgKHN3aXBlci5hbmltYXRpbmcpIHJldHVybjtcbiAgICByZWFsSW5kZXggPSBwYXJzZUludCgkKHN3aXBlci5jbGlja2VkU2xpZGUpLmF0dHIoJ2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4JyksIDEwKTtcbiAgICBpZiAocGFyYW1zLmNlbnRlcmVkU2xpZGVzKSB7XG4gICAgICBpZiAoXG4gICAgICAgIChzbGlkZVRvSW5kZXggPCBzd2lwZXIubG9vcGVkU2xpZGVzIC0gKHNsaWRlc1BlclZpZXcgLyAyKSkgfHxcbiAgICAgICAgKHNsaWRlVG9JbmRleCA+IChzd2lwZXIuc2xpZGVzLmxlbmd0aCAtIHN3aXBlci5sb29wZWRTbGlkZXMpICsgKHNsaWRlc1BlclZpZXcgLyAyKSlcbiAgICAgICkge1xuICAgICAgICBzd2lwZXIubG9vcEZpeCgpO1xuICAgICAgICBzbGlkZVRvSW5kZXggPSAkd3JhcHBlckVsXG4gICAgICAgICAgLmNoaWxkcmVuKGAuJHtwYXJhbXMuc2xpZGVDbGFzc31bZGF0YS1zd2lwZXItc2xpZGUtaW5kZXg9XCIke3JlYWxJbmRleH1cIl06bm90KC4ke3BhcmFtcy5zbGlkZUR1cGxpY2F0ZUNsYXNzfSlgKVxuICAgICAgICAgIC5lcSgwKVxuICAgICAgICAgIC5pbmRleCgpO1xuXG4gICAgICAgIFV0aWxzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgICBzd2lwZXIuc2xpZGVUbyhzbGlkZVRvSW5kZXgpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN3aXBlci5zbGlkZVRvKHNsaWRlVG9JbmRleCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzbGlkZVRvSW5kZXggPiBzd2lwZXIuc2xpZGVzLmxlbmd0aCAtIHNsaWRlc1BlclZpZXcpIHtcbiAgICAgIHN3aXBlci5sb29wRml4KCk7XG4gICAgICBzbGlkZVRvSW5kZXggPSAkd3JhcHBlckVsXG4gICAgICAgIC5jaGlsZHJlbihgLiR7cGFyYW1zLnNsaWRlQ2xhc3N9W2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4PVwiJHtyZWFsSW5kZXh9XCJdOm5vdCguJHtwYXJhbXMuc2xpZGVEdXBsaWNhdGVDbGFzc30pYClcbiAgICAgICAgLmVxKDApXG4gICAgICAgIC5pbmRleCgpO1xuXG4gICAgICBVdGlscy5uZXh0VGljaygoKSA9PiB7XG4gICAgICAgIHN3aXBlci5zbGlkZVRvKHNsaWRlVG9JbmRleCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3dpcGVyLnNsaWRlVG8oc2xpZGVUb0luZGV4KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc3dpcGVyLnNsaWRlVG8oc2xpZGVUb0luZGV4KTtcbiAgfVxufVxuXG52YXIgc2xpZGUgPSB7XG4gIHNsaWRlVG8sXG4gIHNsaWRlVG9Mb29wLFxuICBzbGlkZU5leHQsXG4gIHNsaWRlUHJldixcbiAgc2xpZGVSZXNldCxcbiAgc2xpZGVUb0Nsb3Nlc3QsXG4gIHNsaWRlVG9DbGlja2VkU2xpZGUsXG59O1xuXG5mdW5jdGlvbiBsb29wQ3JlYXRlICgpIHtcbiAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgY29uc3QgeyBwYXJhbXMsICR3cmFwcGVyRWwgfSA9IHN3aXBlcjtcbiAgLy8gUmVtb3ZlIGR1cGxpY2F0ZWQgc2xpZGVzXG4gICR3cmFwcGVyRWwuY2hpbGRyZW4oYC4ke3BhcmFtcy5zbGlkZUNsYXNzfS4ke3BhcmFtcy5zbGlkZUR1cGxpY2F0ZUNsYXNzfWApLnJlbW92ZSgpO1xuXG4gIGxldCBzbGlkZXMgPSAkd3JhcHBlckVsLmNoaWxkcmVuKGAuJHtwYXJhbXMuc2xpZGVDbGFzc31gKTtcblxuICBpZiAocGFyYW1zLmxvb3BGaWxsR3JvdXBXaXRoQmxhbmspIHtcbiAgICBjb25zdCBibGFua1NsaWRlc051bSA9IHBhcmFtcy5zbGlkZXNQZXJHcm91cCAtIChzbGlkZXMubGVuZ3RoICUgcGFyYW1zLnNsaWRlc1Blckdyb3VwKTtcbiAgICBpZiAoYmxhbmtTbGlkZXNOdW0gIT09IHBhcmFtcy5zbGlkZXNQZXJHcm91cCkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBibGFua1NsaWRlc051bTsgaSArPSAxKSB7XG4gICAgICAgIGNvbnN0IGJsYW5rTm9kZSA9ICQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JykpLmFkZENsYXNzKGAke3BhcmFtcy5zbGlkZUNsYXNzfSAke3BhcmFtcy5zbGlkZUJsYW5rQ2xhc3N9YCk7XG4gICAgICAgICR3cmFwcGVyRWwuYXBwZW5kKGJsYW5rTm9kZSk7XG4gICAgICB9XG4gICAgICBzbGlkZXMgPSAkd3JhcHBlckVsLmNoaWxkcmVuKGAuJHtwYXJhbXMuc2xpZGVDbGFzc31gKTtcbiAgICB9XG4gIH1cblxuICBpZiAocGFyYW1zLnNsaWRlc1BlclZpZXcgPT09ICdhdXRvJyAmJiAhcGFyYW1zLmxvb3BlZFNsaWRlcykgcGFyYW1zLmxvb3BlZFNsaWRlcyA9IHNsaWRlcy5sZW5ndGg7XG5cbiAgc3dpcGVyLmxvb3BlZFNsaWRlcyA9IHBhcnNlSW50KHBhcmFtcy5sb29wZWRTbGlkZXMgfHwgcGFyYW1zLnNsaWRlc1BlclZpZXcsIDEwKTtcbiAgc3dpcGVyLmxvb3BlZFNsaWRlcyArPSBwYXJhbXMubG9vcEFkZGl0aW9uYWxTbGlkZXM7XG4gIGlmIChzd2lwZXIubG9vcGVkU2xpZGVzID4gc2xpZGVzLmxlbmd0aCkge1xuICAgIHN3aXBlci5sb29wZWRTbGlkZXMgPSBzbGlkZXMubGVuZ3RoO1xuICB9XG5cbiAgY29uc3QgcHJlcGVuZFNsaWRlcyA9IFtdO1xuICBjb25zdCBhcHBlbmRTbGlkZXMgPSBbXTtcbiAgc2xpZGVzLmVhY2goKGluZGV4LCBlbCkgPT4ge1xuICAgIGNvbnN0IHNsaWRlID0gJChlbCk7XG4gICAgaWYgKGluZGV4IDwgc3dpcGVyLmxvb3BlZFNsaWRlcykgYXBwZW5kU2xpZGVzLnB1c2goZWwpO1xuICAgIGlmIChpbmRleCA8IHNsaWRlcy5sZW5ndGggJiYgaW5kZXggPj0gc2xpZGVzLmxlbmd0aCAtIHN3aXBlci5sb29wZWRTbGlkZXMpIHByZXBlbmRTbGlkZXMucHVzaChlbCk7XG4gICAgc2xpZGUuYXR0cignZGF0YS1zd2lwZXItc2xpZGUtaW5kZXgnLCBpbmRleCk7XG4gIH0pO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFwcGVuZFNsaWRlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICR3cmFwcGVyRWwuYXBwZW5kKCQoYXBwZW5kU2xpZGVzW2ldLmNsb25lTm9kZSh0cnVlKSkuYWRkQ2xhc3MocGFyYW1zLnNsaWRlRHVwbGljYXRlQ2xhc3MpKTtcbiAgfVxuICBmb3IgKGxldCBpID0gcHJlcGVuZFNsaWRlcy5sZW5ndGggLSAxOyBpID49IDA7IGkgLT0gMSkge1xuICAgICR3cmFwcGVyRWwucHJlcGVuZCgkKHByZXBlbmRTbGlkZXNbaV0uY2xvbmVOb2RlKHRydWUpKS5hZGRDbGFzcyhwYXJhbXMuc2xpZGVEdXBsaWNhdGVDbGFzcykpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGxvb3BGaXggKCkge1xuICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICBjb25zdCB7XG4gICAgcGFyYW1zLCBhY3RpdmVJbmRleCwgc2xpZGVzLCBsb29wZWRTbGlkZXMsIGFsbG93U2xpZGVQcmV2LCBhbGxvd1NsaWRlTmV4dCwgc25hcEdyaWQsIHJ0bFRyYW5zbGF0ZTogcnRsLFxuICB9ID0gc3dpcGVyO1xuICBsZXQgbmV3SW5kZXg7XG4gIHN3aXBlci5hbGxvd1NsaWRlUHJldiA9IHRydWU7XG4gIHN3aXBlci5hbGxvd1NsaWRlTmV4dCA9IHRydWU7XG5cbiAgY29uc3Qgc25hcFRyYW5zbGF0ZSA9IC1zbmFwR3JpZFthY3RpdmVJbmRleF07XG4gIGNvbnN0IGRpZmYgPSBzbmFwVHJhbnNsYXRlIC0gc3dpcGVyLmdldFRyYW5zbGF0ZSgpO1xuXG5cbiAgLy8gRml4IEZvciBOZWdhdGl2ZSBPdmVyc2xpZGluZ1xuICBpZiAoYWN0aXZlSW5kZXggPCBsb29wZWRTbGlkZXMpIHtcbiAgICBuZXdJbmRleCA9IChzbGlkZXMubGVuZ3RoIC0gKGxvb3BlZFNsaWRlcyAqIDMpKSArIGFjdGl2ZUluZGV4O1xuICAgIG5ld0luZGV4ICs9IGxvb3BlZFNsaWRlcztcbiAgICBjb25zdCBzbGlkZUNoYW5nZWQgPSBzd2lwZXIuc2xpZGVUbyhuZXdJbmRleCwgMCwgZmFsc2UsIHRydWUpO1xuICAgIGlmIChzbGlkZUNoYW5nZWQgJiYgZGlmZiAhPT0gMCkge1xuICAgICAgc3dpcGVyLnNldFRyYW5zbGF0ZSgocnRsID8gLXN3aXBlci50cmFuc2xhdGUgOiBzd2lwZXIudHJhbnNsYXRlKSAtIGRpZmYpO1xuICAgIH1cbiAgfSBlbHNlIGlmICgocGFyYW1zLnNsaWRlc1BlclZpZXcgPT09ICdhdXRvJyAmJiBhY3RpdmVJbmRleCA+PSBsb29wZWRTbGlkZXMgKiAyKSB8fCAoYWN0aXZlSW5kZXggPiBzbGlkZXMubGVuZ3RoIC0gKHBhcmFtcy5zbGlkZXNQZXJWaWV3ICogMikpKSB7XG4gICAgLy8gRml4IEZvciBQb3NpdGl2ZSBPdmVyc2xpZGluZ1xuICAgIG5ld0luZGV4ID0gLXNsaWRlcy5sZW5ndGggKyBhY3RpdmVJbmRleCArIGxvb3BlZFNsaWRlcztcbiAgICBuZXdJbmRleCArPSBsb29wZWRTbGlkZXM7XG4gICAgY29uc3Qgc2xpZGVDaGFuZ2VkID0gc3dpcGVyLnNsaWRlVG8obmV3SW5kZXgsIDAsIGZhbHNlLCB0cnVlKTtcbiAgICBpZiAoc2xpZGVDaGFuZ2VkICYmIGRpZmYgIT09IDApIHtcbiAgICAgIHN3aXBlci5zZXRUcmFuc2xhdGUoKHJ0bCA/IC1zd2lwZXIudHJhbnNsYXRlIDogc3dpcGVyLnRyYW5zbGF0ZSkgLSBkaWZmKTtcbiAgICB9XG4gIH1cbiAgc3dpcGVyLmFsbG93U2xpZGVQcmV2ID0gYWxsb3dTbGlkZVByZXY7XG4gIHN3aXBlci5hbGxvd1NsaWRlTmV4dCA9IGFsbG93U2xpZGVOZXh0O1xufVxuXG5mdW5jdGlvbiBsb29wRGVzdHJveSAoKSB7XG4gIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gIGNvbnN0IHsgJHdyYXBwZXJFbCwgcGFyYW1zLCBzbGlkZXMgfSA9IHN3aXBlcjtcbiAgJHdyYXBwZXJFbC5jaGlsZHJlbihgLiR7cGFyYW1zLnNsaWRlQ2xhc3N9LiR7cGFyYW1zLnNsaWRlRHVwbGljYXRlQ2xhc3N9YCkucmVtb3ZlKCk7XG4gIHNsaWRlcy5yZW1vdmVBdHRyKCdkYXRhLXN3aXBlci1zbGlkZS1pbmRleCcpO1xufVxuXG52YXIgbG9vcCA9IHtcbiAgbG9vcENyZWF0ZSxcbiAgbG9vcEZpeCxcbiAgbG9vcERlc3Ryb3ksXG59O1xuXG5mdW5jdGlvbiBzZXRHcmFiQ3Vyc29yIChtb3ZpbmcpIHtcbiAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgaWYgKFN1cHBvcnQudG91Y2ggfHwgIXN3aXBlci5wYXJhbXMuc2ltdWxhdGVUb3VjaCB8fCAoc3dpcGVyLnBhcmFtcy53YXRjaE92ZXJmbG93ICYmIHN3aXBlci5pc0xvY2tlZCkpIHJldHVybjtcbiAgY29uc3QgZWwgPSBzd2lwZXIuZWw7XG4gIGVsLnN0eWxlLmN1cnNvciA9ICdtb3ZlJztcbiAgZWwuc3R5bGUuY3Vyc29yID0gbW92aW5nID8gJy13ZWJraXQtZ3JhYmJpbmcnIDogJy13ZWJraXQtZ3JhYic7XG4gIGVsLnN0eWxlLmN1cnNvciA9IG1vdmluZyA/ICctbW96LWdyYWJiaW4nIDogJy1tb3otZ3JhYic7XG4gIGVsLnN0eWxlLmN1cnNvciA9IG1vdmluZyA/ICdncmFiYmluZycgOiAnZ3JhYic7XG59XG5cbmZ1bmN0aW9uIHVuc2V0R3JhYkN1cnNvciAoKSB7XG4gIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gIGlmIChTdXBwb3J0LnRvdWNoIHx8IChzd2lwZXIucGFyYW1zLndhdGNoT3ZlcmZsb3cgJiYgc3dpcGVyLmlzTG9ja2VkKSkgcmV0dXJuO1xuICBzd2lwZXIuZWwuc3R5bGUuY3Vyc29yID0gJyc7XG59XG5cbnZhciBncmFiQ3Vyc29yID0ge1xuICBzZXRHcmFiQ3Vyc29yLFxuICB1bnNldEdyYWJDdXJzb3IsXG59O1xuXG5mdW5jdGlvbiBhcHBlbmRTbGlkZSAoc2xpZGVzKSB7XG4gIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gIGNvbnN0IHsgJHdyYXBwZXJFbCwgcGFyYW1zIH0gPSBzd2lwZXI7XG4gIGlmIChwYXJhbXMubG9vcCkge1xuICAgIHN3aXBlci5sb29wRGVzdHJveSgpO1xuICB9XG4gIGlmICh0eXBlb2Ygc2xpZGVzID09PSAnb2JqZWN0JyAmJiAnbGVuZ3RoJyBpbiBzbGlkZXMpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNsaWRlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgaWYgKHNsaWRlc1tpXSkgJHdyYXBwZXJFbC5hcHBlbmQoc2xpZGVzW2ldKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgJHdyYXBwZXJFbC5hcHBlbmQoc2xpZGVzKTtcbiAgfVxuICBpZiAocGFyYW1zLmxvb3ApIHtcbiAgICBzd2lwZXIubG9vcENyZWF0ZSgpO1xuICB9XG4gIGlmICghKHBhcmFtcy5vYnNlcnZlciAmJiBTdXBwb3J0Lm9ic2VydmVyKSkge1xuICAgIHN3aXBlci51cGRhdGUoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcmVwZW5kU2xpZGUgKHNsaWRlcykge1xuICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICBjb25zdCB7IHBhcmFtcywgJHdyYXBwZXJFbCwgYWN0aXZlSW5kZXggfSA9IHN3aXBlcjtcblxuICBpZiAocGFyYW1zLmxvb3ApIHtcbiAgICBzd2lwZXIubG9vcERlc3Ryb3koKTtcbiAgfVxuICBsZXQgbmV3QWN0aXZlSW5kZXggPSBhY3RpdmVJbmRleCArIDE7XG4gIGlmICh0eXBlb2Ygc2xpZGVzID09PSAnb2JqZWN0JyAmJiAnbGVuZ3RoJyBpbiBzbGlkZXMpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNsaWRlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgaWYgKHNsaWRlc1tpXSkgJHdyYXBwZXJFbC5wcmVwZW5kKHNsaWRlc1tpXSk7XG4gICAgfVxuICAgIG5ld0FjdGl2ZUluZGV4ID0gYWN0aXZlSW5kZXggKyBzbGlkZXMubGVuZ3RoO1xuICB9IGVsc2Uge1xuICAgICR3cmFwcGVyRWwucHJlcGVuZChzbGlkZXMpO1xuICB9XG4gIGlmIChwYXJhbXMubG9vcCkge1xuICAgIHN3aXBlci5sb29wQ3JlYXRlKCk7XG4gIH1cbiAgaWYgKCEocGFyYW1zLm9ic2VydmVyICYmIFN1cHBvcnQub2JzZXJ2ZXIpKSB7XG4gICAgc3dpcGVyLnVwZGF0ZSgpO1xuICB9XG4gIHN3aXBlci5zbGlkZVRvKG5ld0FjdGl2ZUluZGV4LCAwLCBmYWxzZSk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVNsaWRlIChzbGlkZXNJbmRleGVzKSB7XG4gIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gIGNvbnN0IHsgcGFyYW1zLCAkd3JhcHBlckVsLCBhY3RpdmVJbmRleCB9ID0gc3dpcGVyO1xuXG4gIGlmIChwYXJhbXMubG9vcCkge1xuICAgIHN3aXBlci5sb29wRGVzdHJveSgpO1xuICAgIHN3aXBlci5zbGlkZXMgPSAkd3JhcHBlckVsLmNoaWxkcmVuKGAuJHtwYXJhbXMuc2xpZGVDbGFzc31gKTtcbiAgfVxuICBsZXQgbmV3QWN0aXZlSW5kZXggPSBhY3RpdmVJbmRleDtcbiAgbGV0IGluZGV4VG9SZW1vdmU7XG5cbiAgaWYgKHR5cGVvZiBzbGlkZXNJbmRleGVzID09PSAnb2JqZWN0JyAmJiAnbGVuZ3RoJyBpbiBzbGlkZXNJbmRleGVzKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzbGlkZXNJbmRleGVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBpbmRleFRvUmVtb3ZlID0gc2xpZGVzSW5kZXhlc1tpXTtcbiAgICAgIGlmIChzd2lwZXIuc2xpZGVzW2luZGV4VG9SZW1vdmVdKSBzd2lwZXIuc2xpZGVzLmVxKGluZGV4VG9SZW1vdmUpLnJlbW92ZSgpO1xuICAgICAgaWYgKGluZGV4VG9SZW1vdmUgPCBuZXdBY3RpdmVJbmRleCkgbmV3QWN0aXZlSW5kZXggLT0gMTtcbiAgICB9XG4gICAgbmV3QWN0aXZlSW5kZXggPSBNYXRoLm1heChuZXdBY3RpdmVJbmRleCwgMCk7XG4gIH0gZWxzZSB7XG4gICAgaW5kZXhUb1JlbW92ZSA9IHNsaWRlc0luZGV4ZXM7XG4gICAgaWYgKHN3aXBlci5zbGlkZXNbaW5kZXhUb1JlbW92ZV0pIHN3aXBlci5zbGlkZXMuZXEoaW5kZXhUb1JlbW92ZSkucmVtb3ZlKCk7XG4gICAgaWYgKGluZGV4VG9SZW1vdmUgPCBuZXdBY3RpdmVJbmRleCkgbmV3QWN0aXZlSW5kZXggLT0gMTtcbiAgICBuZXdBY3RpdmVJbmRleCA9IE1hdGgubWF4KG5ld0FjdGl2ZUluZGV4LCAwKTtcbiAgfVxuXG4gIGlmIChwYXJhbXMubG9vcCkge1xuICAgIHN3aXBlci5sb29wQ3JlYXRlKCk7XG4gIH1cblxuICBpZiAoIShwYXJhbXMub2JzZXJ2ZXIgJiYgU3VwcG9ydC5vYnNlcnZlcikpIHtcbiAgICBzd2lwZXIudXBkYXRlKCk7XG4gIH1cbiAgaWYgKHBhcmFtcy5sb29wKSB7XG4gICAgc3dpcGVyLnNsaWRlVG8obmV3QWN0aXZlSW5kZXggKyBzd2lwZXIubG9vcGVkU2xpZGVzLCAwLCBmYWxzZSk7XG4gIH0gZWxzZSB7XG4gICAgc3dpcGVyLnNsaWRlVG8obmV3QWN0aXZlSW5kZXgsIDAsIGZhbHNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZW1vdmVBbGxTbGlkZXMgKCkge1xuICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuXG4gIGNvbnN0IHNsaWRlc0luZGV4ZXMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzd2lwZXIuc2xpZGVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgc2xpZGVzSW5kZXhlcy5wdXNoKGkpO1xuICB9XG4gIHN3aXBlci5yZW1vdmVTbGlkZShzbGlkZXNJbmRleGVzKTtcbn1cblxudmFyIG1hbmlwdWxhdGlvbiA9IHtcbiAgYXBwZW5kU2xpZGUsXG4gIHByZXBlbmRTbGlkZSxcbiAgcmVtb3ZlU2xpZGUsXG4gIHJlbW92ZUFsbFNsaWRlcyxcbn07XG5cbmZ1bmN0aW9uIG9uVG91Y2hTdGFydCAoZXZlbnQpIHtcbiAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgY29uc3QgZGF0YSA9IHN3aXBlci50b3VjaEV2ZW50c0RhdGE7XG4gIGNvbnN0IHsgcGFyYW1zLCB0b3VjaGVzIH0gPSBzd2lwZXI7XG4gIGlmIChzd2lwZXIuYW5pbWF0aW5nICYmIHBhcmFtcy5wcmV2ZW50SW50ZXJjYXRpb25PblRyYW5zaXRpb24pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgbGV0IGUgPSBldmVudDtcbiAgaWYgKGUub3JpZ2luYWxFdmVudCkgZSA9IGUub3JpZ2luYWxFdmVudDtcbiAgZGF0YS5pc1RvdWNoRXZlbnQgPSBlLnR5cGUgPT09ICd0b3VjaHN0YXJ0JztcbiAgaWYgKCFkYXRhLmlzVG91Y2hFdmVudCAmJiAnd2hpY2gnIGluIGUgJiYgZS53aGljaCA9PT0gMykgcmV0dXJuO1xuICBpZiAoZGF0YS5pc1RvdWNoZWQgJiYgZGF0YS5pc01vdmVkKSByZXR1cm47XG4gIGlmIChwYXJhbXMubm9Td2lwaW5nICYmICQoZS50YXJnZXQpLmNsb3Nlc3QocGFyYW1zLm5vU3dpcGluZ1NlbGVjdG9yID8gcGFyYW1zLm5vU3dpcGluZ1NlbGVjdG9yIDogYC4ke3BhcmFtcy5ub1N3aXBpbmdDbGFzc31gKVswXSkge1xuICAgIHN3aXBlci5hbGxvd0NsaWNrID0gdHJ1ZTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHBhcmFtcy5zd2lwZUhhbmRsZXIpIHtcbiAgICBpZiAoISQoZSkuY2xvc2VzdChwYXJhbXMuc3dpcGVIYW5kbGVyKVswXSkgcmV0dXJuO1xuICB9XG5cbiAgdG91Y2hlcy5jdXJyZW50WCA9IGUudHlwZSA9PT0gJ3RvdWNoc3RhcnQnID8gZS50YXJnZXRUb3VjaGVzWzBdLnBhZ2VYIDogZS5wYWdlWDtcbiAgdG91Y2hlcy5jdXJyZW50WSA9IGUudHlwZSA9PT0gJ3RvdWNoc3RhcnQnID8gZS50YXJnZXRUb3VjaGVzWzBdLnBhZ2VZIDogZS5wYWdlWTtcbiAgY29uc3Qgc3RhcnRYID0gdG91Y2hlcy5jdXJyZW50WDtcbiAgY29uc3Qgc3RhcnRZID0gdG91Y2hlcy5jdXJyZW50WTtcblxuICAvLyBEbyBOT1Qgc3RhcnQgaWYgaU9TIGVkZ2Ugc3dpcGUgaXMgZGV0ZWN0ZWQuIE90aGVyd2lzZSBpT1MgYXBwIChVSVdlYlZpZXcpIGNhbm5vdCBzd2lwZS10by1nby1iYWNrIGFueW1vcmVcblxuICBpZiAoXG4gICAgRGV2aWNlLmlvcyAmJlxuICAgICFEZXZpY2UuY29yZG92YSAmJlxuICAgIHBhcmFtcy5pT1NFZGdlU3dpcGVEZXRlY3Rpb24gJiZcbiAgICAoc3RhcnRYIDw9IHBhcmFtcy5pT1NFZGdlU3dpcGVUaHJlc2hvbGQpICYmXG4gICAgKHN0YXJ0WCA+PSB3aW5kb3ckMS5zY3JlZW4ud2lkdGggLSBwYXJhbXMuaU9TRWRnZVN3aXBlVGhyZXNob2xkKVxuICApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBVdGlscy5leHRlbmQoZGF0YSwge1xuICAgIGlzVG91Y2hlZDogdHJ1ZSxcbiAgICBpc01vdmVkOiBmYWxzZSxcbiAgICBhbGxvd1RvdWNoQ2FsbGJhY2tzOiB0cnVlLFxuICAgIGlzU2Nyb2xsaW5nOiB1bmRlZmluZWQsXG4gICAgc3RhcnRNb3Zpbmc6IHVuZGVmaW5lZCxcbiAgfSk7XG5cbiAgdG91Y2hlcy5zdGFydFggPSBzdGFydFg7XG4gIHRvdWNoZXMuc3RhcnRZID0gc3RhcnRZO1xuICBkYXRhLnRvdWNoU3RhcnRUaW1lID0gVXRpbHMubm93KCk7XG4gIHN3aXBlci5hbGxvd0NsaWNrID0gdHJ1ZTtcbiAgc3dpcGVyLnVwZGF0ZVNpemUoKTtcbiAgc3dpcGVyLnN3aXBlRGlyZWN0aW9uID0gdW5kZWZpbmVkO1xuICBpZiAocGFyYW1zLnRocmVzaG9sZCA+IDApIGRhdGEuYWxsb3dUaHJlc2hvbGRNb3ZlID0gZmFsc2U7XG4gIGlmIChlLnR5cGUgIT09ICd0b3VjaHN0YXJ0Jykge1xuICAgIGxldCBwcmV2ZW50RGVmYXVsdCA9IHRydWU7XG4gICAgaWYgKCQoZS50YXJnZXQpLmlzKGRhdGEuZm9ybUVsZW1lbnRzKSkgcHJldmVudERlZmF1bHQgPSBmYWxzZTtcbiAgICBpZiAoXG4gICAgICBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICYmXG4gICAgICAkKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpLmlzKGRhdGEuZm9ybUVsZW1lbnRzKSAmJlxuICAgICAgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAhPT0gZS50YXJnZXRcbiAgICApIHtcbiAgICAgIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQuYmx1cigpO1xuICAgIH1cbiAgICBpZiAocHJldmVudERlZmF1bHQgJiYgc3dpcGVyLmFsbG93VG91Y2hNb3ZlKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICB9XG4gIHN3aXBlci5lbWl0KCd0b3VjaFN0YXJ0JywgZSk7XG59XG5cbmZ1bmN0aW9uIG9uVG91Y2hNb3ZlIChldmVudCkge1xuICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICBjb25zdCBkYXRhID0gc3dpcGVyLnRvdWNoRXZlbnRzRGF0YTtcbiAgY29uc3QgeyBwYXJhbXMsIHRvdWNoZXMsIHJ0bFRyYW5zbGF0ZTogcnRsIH0gPSBzd2lwZXI7XG4gIGxldCBlID0gZXZlbnQ7XG4gIGlmIChlLm9yaWdpbmFsRXZlbnQpIGUgPSBlLm9yaWdpbmFsRXZlbnQ7XG4gIGlmICghZGF0YS5pc1RvdWNoZWQpIHtcbiAgICBpZiAoZGF0YS5zdGFydE1vdmluZyAmJiBkYXRhLmlzU2Nyb2xsaW5nKSB7XG4gICAgICBzd2lwZXIuZW1pdCgndG91Y2hNb3ZlT3Bwb3NpdGUnLCBlKTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChkYXRhLmlzVG91Y2hFdmVudCAmJiBlLnR5cGUgPT09ICdtb3VzZW1vdmUnKSByZXR1cm47XG4gIGNvbnN0IHBhZ2VYID0gZS50eXBlID09PSAndG91Y2htb3ZlJyA/IGUudGFyZ2V0VG91Y2hlc1swXS5wYWdlWCA6IGUucGFnZVg7XG4gIGNvbnN0IHBhZ2VZID0gZS50eXBlID09PSAndG91Y2htb3ZlJyA/IGUudGFyZ2V0VG91Y2hlc1swXS5wYWdlWSA6IGUucGFnZVk7XG4gIGlmIChlLnByZXZlbnRlZEJ5TmVzdGVkU3dpcGVyKSB7XG4gICAgdG91Y2hlcy5zdGFydFggPSBwYWdlWDtcbiAgICB0b3VjaGVzLnN0YXJ0WSA9IHBhZ2VZO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoIXN3aXBlci5hbGxvd1RvdWNoTW92ZSkge1xuICAgIC8vIGlzTW92ZWQgPSB0cnVlO1xuICAgIHN3aXBlci5hbGxvd0NsaWNrID0gZmFsc2U7XG4gICAgaWYgKGRhdGEuaXNUb3VjaGVkKSB7XG4gICAgICBVdGlscy5leHRlbmQodG91Y2hlcywge1xuICAgICAgICBzdGFydFg6IHBhZ2VYLFxuICAgICAgICBzdGFydFk6IHBhZ2VZLFxuICAgICAgICBjdXJyZW50WDogcGFnZVgsXG4gICAgICAgIGN1cnJlbnRZOiBwYWdlWSxcbiAgICAgIH0pO1xuICAgICAgZGF0YS50b3VjaFN0YXJ0VGltZSA9IFV0aWxzLm5vdygpO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGRhdGEuaXNUb3VjaEV2ZW50ICYmIHBhcmFtcy50b3VjaFJlbGVhc2VPbkVkZ2VzICYmICFwYXJhbXMubG9vcCkge1xuICAgIGlmIChzd2lwZXIuaXNWZXJ0aWNhbCgpKSB7XG4gICAgICAvLyBWZXJ0aWNhbFxuICAgICAgaWYgKFxuICAgICAgICAocGFnZVkgPCB0b3VjaGVzLnN0YXJ0WSAmJiBzd2lwZXIudHJhbnNsYXRlIDw9IHN3aXBlci5tYXhUcmFuc2xhdGUoKSkgfHxcbiAgICAgICAgKHBhZ2VZID4gdG91Y2hlcy5zdGFydFkgJiYgc3dpcGVyLnRyYW5zbGF0ZSA+PSBzd2lwZXIubWluVHJhbnNsYXRlKCkpXG4gICAgICApIHtcbiAgICAgICAgZGF0YS5pc1RvdWNoZWQgPSBmYWxzZTtcbiAgICAgICAgZGF0YS5pc01vdmVkID0gZmFsc2U7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKFxuICAgICAgKHBhZ2VYIDwgdG91Y2hlcy5zdGFydFggJiYgc3dpcGVyLnRyYW5zbGF0ZSA8PSBzd2lwZXIubWF4VHJhbnNsYXRlKCkpIHx8XG4gICAgICAocGFnZVggPiB0b3VjaGVzLnN0YXJ0WCAmJiBzd2lwZXIudHJhbnNsYXRlID49IHN3aXBlci5taW5UcmFuc2xhdGUoKSlcbiAgICApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgaWYgKGRhdGEuaXNUb3VjaEV2ZW50ICYmIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpIHtcbiAgICBpZiAoZS50YXJnZXQgPT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgJiYgJChlLnRhcmdldCkuaXMoZGF0YS5mb3JtRWxlbWVudHMpKSB7XG4gICAgICBkYXRhLmlzTW92ZWQgPSB0cnVlO1xuICAgICAgc3dpcGVyLmFsbG93Q2xpY2sgPSBmYWxzZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgaWYgKGRhdGEuYWxsb3dUb3VjaENhbGxiYWNrcykge1xuICAgIHN3aXBlci5lbWl0KCd0b3VjaE1vdmUnLCBlKTtcbiAgfVxuICBpZiAoZS50YXJnZXRUb3VjaGVzICYmIGUudGFyZ2V0VG91Y2hlcy5sZW5ndGggPiAxKSByZXR1cm47XG5cbiAgdG91Y2hlcy5jdXJyZW50WCA9IHBhZ2VYO1xuICB0b3VjaGVzLmN1cnJlbnRZID0gcGFnZVk7XG5cbiAgY29uc3QgZGlmZlggPSB0b3VjaGVzLmN1cnJlbnRYIC0gdG91Y2hlcy5zdGFydFg7XG4gIGNvbnN0IGRpZmZZID0gdG91Y2hlcy5jdXJyZW50WSAtIHRvdWNoZXMuc3RhcnRZO1xuXG4gIGlmICh0eXBlb2YgZGF0YS5pc1Njcm9sbGluZyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBsZXQgdG91Y2hBbmdsZTtcbiAgICBpZiAoKHN3aXBlci5pc0hvcml6b250YWwoKSAmJiB0b3VjaGVzLmN1cnJlbnRZID09PSB0b3VjaGVzLnN0YXJ0WSkgfHwgKHN3aXBlci5pc1ZlcnRpY2FsKCkgJiYgdG91Y2hlcy5jdXJyZW50WCA9PT0gdG91Y2hlcy5zdGFydFgpKSB7XG4gICAgICBkYXRhLmlzU2Nyb2xsaW5nID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgaWYgKChkaWZmWCAqIGRpZmZYKSArIChkaWZmWSAqIGRpZmZZKSA+PSAyNSkge1xuICAgICAgICB0b3VjaEFuZ2xlID0gKE1hdGguYXRhbjIoTWF0aC5hYnMoZGlmZlkpLCBNYXRoLmFicyhkaWZmWCkpICogMTgwKSAvIE1hdGguUEk7XG4gICAgICAgIGRhdGEuaXNTY3JvbGxpbmcgPSBzd2lwZXIuaXNIb3Jpem9udGFsKCkgPyB0b3VjaEFuZ2xlID4gcGFyYW1zLnRvdWNoQW5nbGUgOiAoOTAgLSB0b3VjaEFuZ2xlID4gcGFyYW1zLnRvdWNoQW5nbGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoZGF0YS5pc1Njcm9sbGluZykge1xuICAgIHN3aXBlci5lbWl0KCd0b3VjaE1vdmVPcHBvc2l0ZScsIGUpO1xuICB9XG4gIGlmICh0eXBlb2Ygc3RhcnRNb3ZpbmcgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKHRvdWNoZXMuY3VycmVudFggIT09IHRvdWNoZXMuc3RhcnRYIHx8IHRvdWNoZXMuY3VycmVudFkgIT09IHRvdWNoZXMuc3RhcnRZKSB7XG4gICAgICBkYXRhLnN0YXJ0TW92aW5nID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgaWYgKGRhdGEuaXNTY3JvbGxpbmcpIHtcbiAgICBkYXRhLmlzVG91Y2hlZCA9IGZhbHNlO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoIWRhdGEuc3RhcnRNb3ZpbmcpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgc3dpcGVyLmFsbG93Q2xpY2sgPSBmYWxzZTtcbiAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICBpZiAocGFyYW1zLnRvdWNoTW92ZVN0b3BQcm9wYWdhdGlvbiAmJiAhcGFyYW1zLm5lc3RlZCkge1xuICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIH1cblxuICBpZiAoIWRhdGEuaXNNb3ZlZCkge1xuICAgIGlmIChwYXJhbXMubG9vcCkge1xuICAgICAgc3dpcGVyLmxvb3BGaXgoKTtcbiAgICB9XG4gICAgZGF0YS5zdGFydFRyYW5zbGF0ZSA9IHN3aXBlci5nZXRUcmFuc2xhdGUoKTtcbiAgICBzd2lwZXIuc2V0VHJhbnNpdGlvbigwKTtcbiAgICBpZiAoc3dpcGVyLmFuaW1hdGluZykge1xuICAgICAgc3dpcGVyLiR3cmFwcGVyRWwudHJpZ2dlcignd2Via2l0VHJhbnNpdGlvbkVuZCB0cmFuc2l0aW9uZW5kJyk7XG4gICAgfVxuICAgIGRhdGEuYWxsb3dNb21lbnR1bUJvdW5jZSA9IGZhbHNlO1xuICAgIC8vIEdyYWIgQ3Vyc29yXG4gICAgaWYgKHBhcmFtcy5ncmFiQ3Vyc29yICYmIChzd2lwZXIuYWxsb3dTbGlkZU5leHQgPT09IHRydWUgfHwgc3dpcGVyLmFsbG93U2xpZGVQcmV2ID09PSB0cnVlKSkge1xuICAgICAgc3dpcGVyLnNldEdyYWJDdXJzb3IodHJ1ZSk7XG4gICAgfVxuICAgIHN3aXBlci5lbWl0KCdzbGlkZXJGaXJzdE1vdmUnLCBlKTtcbiAgfVxuICBzd2lwZXIuZW1pdCgnc2xpZGVyTW92ZScsIGUpO1xuICBkYXRhLmlzTW92ZWQgPSB0cnVlO1xuXG4gIGxldCBkaWZmID0gc3dpcGVyLmlzSG9yaXpvbnRhbCgpID8gZGlmZlggOiBkaWZmWTtcbiAgdG91Y2hlcy5kaWZmID0gZGlmZjtcblxuICBkaWZmICo9IHBhcmFtcy50b3VjaFJhdGlvO1xuICBpZiAocnRsKSBkaWZmID0gLWRpZmY7XG5cbiAgc3dpcGVyLnN3aXBlRGlyZWN0aW9uID0gZGlmZiA+IDAgPyAncHJldicgOiAnbmV4dCc7XG4gIGRhdGEuY3VycmVudFRyYW5zbGF0ZSA9IGRpZmYgKyBkYXRhLnN0YXJ0VHJhbnNsYXRlO1xuXG4gIGxldCBkaXNhYmxlUGFyZW50U3dpcGVyID0gdHJ1ZTtcbiAgbGV0IHJlc2lzdGFuY2VSYXRpbyA9IHBhcmFtcy5yZXNpc3RhbmNlUmF0aW87XG4gIGlmIChwYXJhbXMudG91Y2hSZWxlYXNlT25FZGdlcykge1xuICAgIHJlc2lzdGFuY2VSYXRpbyA9IDA7XG4gIH1cbiAgaWYgKChkaWZmID4gMCAmJiBkYXRhLmN1cnJlbnRUcmFuc2xhdGUgPiBzd2lwZXIubWluVHJhbnNsYXRlKCkpKSB7XG4gICAgZGlzYWJsZVBhcmVudFN3aXBlciA9IGZhbHNlO1xuICAgIGlmIChwYXJhbXMucmVzaXN0YW5jZSkgZGF0YS5jdXJyZW50VHJhbnNsYXRlID0gKHN3aXBlci5taW5UcmFuc2xhdGUoKSAtIDEpICsgKCgtc3dpcGVyLm1pblRyYW5zbGF0ZSgpICsgZGF0YS5zdGFydFRyYW5zbGF0ZSArIGRpZmYpICoqIHJlc2lzdGFuY2VSYXRpbyk7XG4gIH0gZWxzZSBpZiAoZGlmZiA8IDAgJiYgZGF0YS5jdXJyZW50VHJhbnNsYXRlIDwgc3dpcGVyLm1heFRyYW5zbGF0ZSgpKSB7XG4gICAgZGlzYWJsZVBhcmVudFN3aXBlciA9IGZhbHNlO1xuICAgIGlmIChwYXJhbXMucmVzaXN0YW5jZSkgZGF0YS5jdXJyZW50VHJhbnNsYXRlID0gKHN3aXBlci5tYXhUcmFuc2xhdGUoKSArIDEpIC0gKChzd2lwZXIubWF4VHJhbnNsYXRlKCkgLSBkYXRhLnN0YXJ0VHJhbnNsYXRlIC0gZGlmZikgKiogcmVzaXN0YW5jZVJhdGlvKTtcbiAgfVxuXG4gIGlmIChkaXNhYmxlUGFyZW50U3dpcGVyKSB7XG4gICAgZS5wcmV2ZW50ZWRCeU5lc3RlZFN3aXBlciA9IHRydWU7XG4gIH1cblxuICAvLyBEaXJlY3Rpb25zIGxvY2tzXG4gIGlmICghc3dpcGVyLmFsbG93U2xpZGVOZXh0ICYmIHN3aXBlci5zd2lwZURpcmVjdGlvbiA9PT0gJ25leHQnICYmIGRhdGEuY3VycmVudFRyYW5zbGF0ZSA8IGRhdGEuc3RhcnRUcmFuc2xhdGUpIHtcbiAgICBkYXRhLmN1cnJlbnRUcmFuc2xhdGUgPSBkYXRhLnN0YXJ0VHJhbnNsYXRlO1xuICB9XG4gIGlmICghc3dpcGVyLmFsbG93U2xpZGVQcmV2ICYmIHN3aXBlci5zd2lwZURpcmVjdGlvbiA9PT0gJ3ByZXYnICYmIGRhdGEuY3VycmVudFRyYW5zbGF0ZSA+IGRhdGEuc3RhcnRUcmFuc2xhdGUpIHtcbiAgICBkYXRhLmN1cnJlbnRUcmFuc2xhdGUgPSBkYXRhLnN0YXJ0VHJhbnNsYXRlO1xuICB9XG5cblxuICAvLyBUaHJlc2hvbGRcbiAgaWYgKHBhcmFtcy50aHJlc2hvbGQgPiAwKSB7XG4gICAgaWYgKE1hdGguYWJzKGRpZmYpID4gcGFyYW1zLnRocmVzaG9sZCB8fCBkYXRhLmFsbG93VGhyZXNob2xkTW92ZSkge1xuICAgICAgaWYgKCFkYXRhLmFsbG93VGhyZXNob2xkTW92ZSkge1xuICAgICAgICBkYXRhLmFsbG93VGhyZXNob2xkTW92ZSA9IHRydWU7XG4gICAgICAgIHRvdWNoZXMuc3RhcnRYID0gdG91Y2hlcy5jdXJyZW50WDtcbiAgICAgICAgdG91Y2hlcy5zdGFydFkgPSB0b3VjaGVzLmN1cnJlbnRZO1xuICAgICAgICBkYXRhLmN1cnJlbnRUcmFuc2xhdGUgPSBkYXRhLnN0YXJ0VHJhbnNsYXRlO1xuICAgICAgICB0b3VjaGVzLmRpZmYgPSBzd2lwZXIuaXNIb3Jpem9udGFsKCkgPyB0b3VjaGVzLmN1cnJlbnRYIC0gdG91Y2hlcy5zdGFydFggOiB0b3VjaGVzLmN1cnJlbnRZIC0gdG91Y2hlcy5zdGFydFk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZGF0YS5jdXJyZW50VHJhbnNsYXRlID0gZGF0YS5zdGFydFRyYW5zbGF0ZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICBpZiAoIXBhcmFtcy5mb2xsb3dGaW5nZXIpIHJldHVybjtcblxuICAvLyBVcGRhdGUgYWN0aXZlIGluZGV4IGluIGZyZWUgbW9kZVxuICBpZiAocGFyYW1zLmZyZWVNb2RlIHx8IHBhcmFtcy53YXRjaFNsaWRlc1Byb2dyZXNzIHx8IHBhcmFtcy53YXRjaFNsaWRlc1Zpc2liaWxpdHkpIHtcbiAgICBzd2lwZXIudXBkYXRlQWN0aXZlSW5kZXgoKTtcbiAgICBzd2lwZXIudXBkYXRlU2xpZGVzQ2xhc3NlcygpO1xuICB9XG4gIGlmIChwYXJhbXMuZnJlZU1vZGUpIHtcbiAgICAvLyBWZWxvY2l0eVxuICAgIGlmIChkYXRhLnZlbG9jaXRpZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICBkYXRhLnZlbG9jaXRpZXMucHVzaCh7XG4gICAgICAgIHBvc2l0aW9uOiB0b3VjaGVzW3N3aXBlci5pc0hvcml6b250YWwoKSA/ICdzdGFydFgnIDogJ3N0YXJ0WSddLFxuICAgICAgICB0aW1lOiBkYXRhLnRvdWNoU3RhcnRUaW1lLFxuICAgICAgfSk7XG4gICAgfVxuICAgIGRhdGEudmVsb2NpdGllcy5wdXNoKHtcbiAgICAgIHBvc2l0aW9uOiB0b3VjaGVzW3N3aXBlci5pc0hvcml6b250YWwoKSA/ICdjdXJyZW50WCcgOiAnY3VycmVudFknXSxcbiAgICAgIHRpbWU6IFV0aWxzLm5vdygpLFxuICAgIH0pO1xuICB9XG4gIC8vIFVwZGF0ZSBwcm9ncmVzc1xuICBzd2lwZXIudXBkYXRlUHJvZ3Jlc3MoZGF0YS5jdXJyZW50VHJhbnNsYXRlKTtcbiAgLy8gVXBkYXRlIHRyYW5zbGF0ZVxuICBzd2lwZXIuc2V0VHJhbnNsYXRlKGRhdGEuY3VycmVudFRyYW5zbGF0ZSk7XG59XG5cbmZ1bmN0aW9uIG9uVG91Y2hFbmQgKGV2ZW50KSB7XG4gIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gIGNvbnN0IGRhdGEgPSBzd2lwZXIudG91Y2hFdmVudHNEYXRhO1xuXG4gIGNvbnN0IHtcbiAgICBwYXJhbXMsIHRvdWNoZXMsIHJ0bFRyYW5zbGF0ZTogcnRsLCAkd3JhcHBlckVsLCBzbGlkZXNHcmlkLCBzbmFwR3JpZCxcbiAgfSA9IHN3aXBlcjtcbiAgbGV0IGUgPSBldmVudDtcbiAgaWYgKGUub3JpZ2luYWxFdmVudCkgZSA9IGUub3JpZ2luYWxFdmVudDtcbiAgaWYgKGRhdGEuYWxsb3dUb3VjaENhbGxiYWNrcykge1xuICAgIHN3aXBlci5lbWl0KCd0b3VjaEVuZCcsIGUpO1xuICB9XG4gIGRhdGEuYWxsb3dUb3VjaENhbGxiYWNrcyA9IGZhbHNlO1xuICBpZiAoIWRhdGEuaXNUb3VjaGVkKSB7XG4gICAgaWYgKGRhdGEuaXNNb3ZlZCAmJiBwYXJhbXMuZ3JhYkN1cnNvcikge1xuICAgICAgc3dpcGVyLnNldEdyYWJDdXJzb3IoZmFsc2UpO1xuICAgIH1cbiAgICBkYXRhLmlzTW92ZWQgPSBmYWxzZTtcbiAgICBkYXRhLnN0YXJ0TW92aW5nID0gZmFsc2U7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIFJldHVybiBHcmFiIEN1cnNvclxuICBpZiAocGFyYW1zLmdyYWJDdXJzb3IgJiYgZGF0YS5pc01vdmVkICYmIGRhdGEuaXNUb3VjaGVkICYmIChzd2lwZXIuYWxsb3dTbGlkZU5leHQgPT09IHRydWUgfHwgc3dpcGVyLmFsbG93U2xpZGVQcmV2ID09PSB0cnVlKSkge1xuICAgIHN3aXBlci5zZXRHcmFiQ3Vyc29yKGZhbHNlKTtcbiAgfVxuXG4gIC8vIFRpbWUgZGlmZlxuICBjb25zdCB0b3VjaEVuZFRpbWUgPSBVdGlscy5ub3coKTtcbiAgY29uc3QgdGltZURpZmYgPSB0b3VjaEVuZFRpbWUgLSBkYXRhLnRvdWNoU3RhcnRUaW1lO1xuXG4gIC8vIFRhcCwgZG91YmxlVGFwLCBDbGlja1xuICBpZiAoc3dpcGVyLmFsbG93Q2xpY2spIHtcbiAgICBzd2lwZXIudXBkYXRlQ2xpY2tlZFNsaWRlKGUpO1xuICAgIHN3aXBlci5lbWl0KCd0YXAnLCBlKTtcbiAgICBpZiAodGltZURpZmYgPCAzMDAgJiYgKHRvdWNoRW5kVGltZSAtIGRhdGEubGFzdENsaWNrVGltZSkgPiAzMDApIHtcbiAgICAgIGlmIChkYXRhLmNsaWNrVGltZW91dCkgY2xlYXJUaW1lb3V0KGRhdGEuY2xpY2tUaW1lb3V0KTtcbiAgICAgIGRhdGEuY2xpY2tUaW1lb3V0ID0gVXRpbHMubmV4dFRpY2soKCkgPT4ge1xuICAgICAgICBpZiAoIXN3aXBlciB8fCBzd2lwZXIuZGVzdHJveWVkKSByZXR1cm47XG4gICAgICAgIHN3aXBlci5lbWl0KCdjbGljaycsIGUpO1xuICAgICAgfSwgMzAwKTtcbiAgICB9XG4gICAgaWYgKHRpbWVEaWZmIDwgMzAwICYmICh0b3VjaEVuZFRpbWUgLSBkYXRhLmxhc3RDbGlja1RpbWUpIDwgMzAwKSB7XG4gICAgICBpZiAoZGF0YS5jbGlja1RpbWVvdXQpIGNsZWFyVGltZW91dChkYXRhLmNsaWNrVGltZW91dCk7XG4gICAgICBzd2lwZXIuZW1pdCgnZG91YmxlVGFwJywgZSk7XG4gICAgfVxuICB9XG5cbiAgZGF0YS5sYXN0Q2xpY2tUaW1lID0gVXRpbHMubm93KCk7XG4gIFV0aWxzLm5leHRUaWNrKCgpID0+IHtcbiAgICBpZiAoIXN3aXBlci5kZXN0cm95ZWQpIHN3aXBlci5hbGxvd0NsaWNrID0gdHJ1ZTtcbiAgfSk7XG5cbiAgaWYgKCFkYXRhLmlzVG91Y2hlZCB8fCAhZGF0YS5pc01vdmVkIHx8ICFzd2lwZXIuc3dpcGVEaXJlY3Rpb24gfHwgdG91Y2hlcy5kaWZmID09PSAwIHx8IGRhdGEuY3VycmVudFRyYW5zbGF0ZSA9PT0gZGF0YS5zdGFydFRyYW5zbGF0ZSkge1xuICAgIGRhdGEuaXNUb3VjaGVkID0gZmFsc2U7XG4gICAgZGF0YS5pc01vdmVkID0gZmFsc2U7XG4gICAgZGF0YS5zdGFydE1vdmluZyA9IGZhbHNlO1xuICAgIHJldHVybjtcbiAgfVxuICBkYXRhLmlzVG91Y2hlZCA9IGZhbHNlO1xuICBkYXRhLmlzTW92ZWQgPSBmYWxzZTtcbiAgZGF0YS5zdGFydE1vdmluZyA9IGZhbHNlO1xuXG4gIGxldCBjdXJyZW50UG9zO1xuICBpZiAocGFyYW1zLmZvbGxvd0Zpbmdlcikge1xuICAgIGN1cnJlbnRQb3MgPSBydGwgPyBzd2lwZXIudHJhbnNsYXRlIDogLXN3aXBlci50cmFuc2xhdGU7XG4gIH0gZWxzZSB7XG4gICAgY3VycmVudFBvcyA9IC1kYXRhLmN1cnJlbnRUcmFuc2xhdGU7XG4gIH1cblxuICBpZiAocGFyYW1zLmZyZWVNb2RlKSB7XG4gICAgaWYgKGN1cnJlbnRQb3MgPCAtc3dpcGVyLm1pblRyYW5zbGF0ZSgpKSB7XG4gICAgICBzd2lwZXIuc2xpZGVUbyhzd2lwZXIuYWN0aXZlSW5kZXgpO1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAoY3VycmVudFBvcyA+IC1zd2lwZXIubWF4VHJhbnNsYXRlKCkpIHtcbiAgICAgIGlmIChzd2lwZXIuc2xpZGVzLmxlbmd0aCA8IHNuYXBHcmlkLmxlbmd0aCkge1xuICAgICAgICBzd2lwZXIuc2xpZGVUbyhzbmFwR3JpZC5sZW5ndGggLSAxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN3aXBlci5zbGlkZVRvKHN3aXBlci5zbGlkZXMubGVuZ3RoIC0gMSk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHBhcmFtcy5mcmVlTW9kZU1vbWVudHVtKSB7XG4gICAgICBpZiAoZGF0YS52ZWxvY2l0aWVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgY29uc3QgbGFzdE1vdmVFdmVudCA9IGRhdGEudmVsb2NpdGllcy5wb3AoKTtcbiAgICAgICAgY29uc3QgdmVsb2NpdHlFdmVudCA9IGRhdGEudmVsb2NpdGllcy5wb3AoKTtcblxuICAgICAgICBjb25zdCBkaXN0YW5jZSA9IGxhc3RNb3ZlRXZlbnQucG9zaXRpb24gLSB2ZWxvY2l0eUV2ZW50LnBvc2l0aW9uO1xuICAgICAgICBjb25zdCB0aW1lID0gbGFzdE1vdmVFdmVudC50aW1lIC0gdmVsb2NpdHlFdmVudC50aW1lO1xuICAgICAgICBzd2lwZXIudmVsb2NpdHkgPSBkaXN0YW5jZSAvIHRpbWU7XG4gICAgICAgIHN3aXBlci52ZWxvY2l0eSAvPSAyO1xuICAgICAgICBpZiAoTWF0aC5hYnMoc3dpcGVyLnZlbG9jaXR5KSA8IHBhcmFtcy5mcmVlTW9kZU1pbmltdW1WZWxvY2l0eSkge1xuICAgICAgICAgIHN3aXBlci52ZWxvY2l0eSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGhpcyBpbXBsaWVzIHRoYXQgdGhlIHVzZXIgc3RvcHBlZCBtb3ZpbmcgYSBmaW5nZXIgdGhlbiByZWxlYXNlZC5cbiAgICAgICAgLy8gVGhlcmUgd291bGQgYmUgbm8gZXZlbnRzIHdpdGggZGlzdGFuY2UgemVybywgc28gdGhlIGxhc3QgZXZlbnQgaXMgc3RhbGUuXG4gICAgICAgIGlmICh0aW1lID4gMTUwIHx8IChVdGlscy5ub3coKSAtIGxhc3RNb3ZlRXZlbnQudGltZSkgPiAzMDApIHtcbiAgICAgICAgICBzd2lwZXIudmVsb2NpdHkgPSAwO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzd2lwZXIudmVsb2NpdHkgPSAwO1xuICAgICAgfVxuICAgICAgc3dpcGVyLnZlbG9jaXR5ICo9IHBhcmFtcy5mcmVlTW9kZU1vbWVudHVtVmVsb2NpdHlSYXRpbztcblxuICAgICAgZGF0YS52ZWxvY2l0aWVzLmxlbmd0aCA9IDA7XG4gICAgICBsZXQgbW9tZW50dW1EdXJhdGlvbiA9IDEwMDAgKiBwYXJhbXMuZnJlZU1vZGVNb21lbnR1bVJhdGlvO1xuICAgICAgY29uc3QgbW9tZW50dW1EaXN0YW5jZSA9IHN3aXBlci52ZWxvY2l0eSAqIG1vbWVudHVtRHVyYXRpb247XG5cbiAgICAgIGxldCBuZXdQb3NpdGlvbiA9IHN3aXBlci50cmFuc2xhdGUgKyBtb21lbnR1bURpc3RhbmNlO1xuICAgICAgaWYgKHJ0bCkgbmV3UG9zaXRpb24gPSAtbmV3UG9zaXRpb247XG5cbiAgICAgIGxldCBkb0JvdW5jZSA9IGZhbHNlO1xuICAgICAgbGV0IGFmdGVyQm91bmNlUG9zaXRpb247XG4gICAgICBjb25zdCBib3VuY2VBbW91bnQgPSBNYXRoLmFicyhzd2lwZXIudmVsb2NpdHkpICogMjAgKiBwYXJhbXMuZnJlZU1vZGVNb21lbnR1bUJvdW5jZVJhdGlvO1xuICAgICAgbGV0IG5lZWRzTG9vcEZpeDtcbiAgICAgIGlmIChuZXdQb3NpdGlvbiA8IHN3aXBlci5tYXhUcmFuc2xhdGUoKSkge1xuICAgICAgICBpZiAocGFyYW1zLmZyZWVNb2RlTW9tZW50dW1Cb3VuY2UpIHtcbiAgICAgICAgICBpZiAobmV3UG9zaXRpb24gKyBzd2lwZXIubWF4VHJhbnNsYXRlKCkgPCAtYm91bmNlQW1vdW50KSB7XG4gICAgICAgICAgICBuZXdQb3NpdGlvbiA9IHN3aXBlci5tYXhUcmFuc2xhdGUoKSAtIGJvdW5jZUFtb3VudDtcbiAgICAgICAgICB9XG4gICAgICAgICAgYWZ0ZXJCb3VuY2VQb3NpdGlvbiA9IHN3aXBlci5tYXhUcmFuc2xhdGUoKTtcbiAgICAgICAgICBkb0JvdW5jZSA9IHRydWU7XG4gICAgICAgICAgZGF0YS5hbGxvd01vbWVudHVtQm91bmNlID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXdQb3NpdGlvbiA9IHN3aXBlci5tYXhUcmFuc2xhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyYW1zLmxvb3AgJiYgcGFyYW1zLmNlbnRlcmVkU2xpZGVzKSBuZWVkc0xvb3BGaXggPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChuZXdQb3NpdGlvbiA+IHN3aXBlci5taW5UcmFuc2xhdGUoKSkge1xuICAgICAgICBpZiAocGFyYW1zLmZyZWVNb2RlTW9tZW50dW1Cb3VuY2UpIHtcbiAgICAgICAgICBpZiAobmV3UG9zaXRpb24gLSBzd2lwZXIubWluVHJhbnNsYXRlKCkgPiBib3VuY2VBbW91bnQpIHtcbiAgICAgICAgICAgIG5ld1Bvc2l0aW9uID0gc3dpcGVyLm1pblRyYW5zbGF0ZSgpICsgYm91bmNlQW1vdW50O1xuICAgICAgICAgIH1cbiAgICAgICAgICBhZnRlckJvdW5jZVBvc2l0aW9uID0gc3dpcGVyLm1pblRyYW5zbGF0ZSgpO1xuICAgICAgICAgIGRvQm91bmNlID0gdHJ1ZTtcbiAgICAgICAgICBkYXRhLmFsbG93TW9tZW50dW1Cb3VuY2UgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld1Bvc2l0aW9uID0gc3dpcGVyLm1pblRyYW5zbGF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJhbXMubG9vcCAmJiBwYXJhbXMuY2VudGVyZWRTbGlkZXMpIG5lZWRzTG9vcEZpeCA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHBhcmFtcy5mcmVlTW9kZVN0aWNreSkge1xuICAgICAgICBsZXQgbmV4dFNsaWRlO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHNuYXBHcmlkLmxlbmd0aDsgaiArPSAxKSB7XG4gICAgICAgICAgaWYgKHNuYXBHcmlkW2pdID4gLW5ld1Bvc2l0aW9uKSB7XG4gICAgICAgICAgICBuZXh0U2xpZGUgPSBqO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKE1hdGguYWJzKHNuYXBHcmlkW25leHRTbGlkZV0gLSBuZXdQb3NpdGlvbikgPCBNYXRoLmFicyhzbmFwR3JpZFtuZXh0U2xpZGUgLSAxXSAtIG5ld1Bvc2l0aW9uKSB8fCBzd2lwZXIuc3dpcGVEaXJlY3Rpb24gPT09ICduZXh0Jykge1xuICAgICAgICAgIG5ld1Bvc2l0aW9uID0gc25hcEdyaWRbbmV4dFNsaWRlXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXdQb3NpdGlvbiA9IHNuYXBHcmlkW25leHRTbGlkZSAtIDFdO1xuICAgICAgICB9XG4gICAgICAgIG5ld1Bvc2l0aW9uID0gLW5ld1Bvc2l0aW9uO1xuICAgICAgfVxuICAgICAgaWYgKG5lZWRzTG9vcEZpeCkge1xuICAgICAgICBzd2lwZXIub25jZSgndHJhbnNpdGlvbkVuZCcsICgpID0+IHtcbiAgICAgICAgICBzd2lwZXIubG9vcEZpeCgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIC8vIEZpeCBkdXJhdGlvblxuICAgICAgaWYgKHN3aXBlci52ZWxvY2l0eSAhPT0gMCkge1xuICAgICAgICBpZiAocnRsKSB7XG4gICAgICAgICAgbW9tZW50dW1EdXJhdGlvbiA9IE1hdGguYWJzKCgtbmV3UG9zaXRpb24gLSBzd2lwZXIudHJhbnNsYXRlKSAvIHN3aXBlci52ZWxvY2l0eSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbW9tZW50dW1EdXJhdGlvbiA9IE1hdGguYWJzKChuZXdQb3NpdGlvbiAtIHN3aXBlci50cmFuc2xhdGUpIC8gc3dpcGVyLnZlbG9jaXR5KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwYXJhbXMuZnJlZU1vZGVTdGlja3kpIHtcbiAgICAgICAgc3dpcGVyLnNsaWRlVG9DbG9zZXN0KCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHBhcmFtcy5mcmVlTW9kZU1vbWVudHVtQm91bmNlICYmIGRvQm91bmNlKSB7XG4gICAgICAgIHN3aXBlci51cGRhdGVQcm9ncmVzcyhhZnRlckJvdW5jZVBvc2l0aW9uKTtcbiAgICAgICAgc3dpcGVyLnNldFRyYW5zaXRpb24obW9tZW50dW1EdXJhdGlvbik7XG4gICAgICAgIHN3aXBlci5zZXRUcmFuc2xhdGUobmV3UG9zaXRpb24pO1xuICAgICAgICBzd2lwZXIudHJhbnNpdGlvblN0YXJ0KHRydWUsIHN3aXBlci5zd2lwZURpcmVjdGlvbik7XG4gICAgICAgIHN3aXBlci5hbmltYXRpbmcgPSB0cnVlO1xuICAgICAgICAkd3JhcHBlckVsLnRyYW5zaXRpb25FbmQoKCkgPT4ge1xuICAgICAgICAgIGlmICghc3dpcGVyIHx8IHN3aXBlci5kZXN0cm95ZWQgfHwgIWRhdGEuYWxsb3dNb21lbnR1bUJvdW5jZSkgcmV0dXJuO1xuICAgICAgICAgIHN3aXBlci5lbWl0KCdtb21lbnR1bUJvdW5jZScpO1xuXG4gICAgICAgICAgc3dpcGVyLnNldFRyYW5zaXRpb24ocGFyYW1zLnNwZWVkKTtcbiAgICAgICAgICBzd2lwZXIuc2V0VHJhbnNsYXRlKGFmdGVyQm91bmNlUG9zaXRpb24pO1xuICAgICAgICAgICR3cmFwcGVyRWwudHJhbnNpdGlvbkVuZCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXN3aXBlciB8fCBzd2lwZXIuZGVzdHJveWVkKSByZXR1cm47XG4gICAgICAgICAgICBzd2lwZXIudHJhbnNpdGlvbkVuZCgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoc3dpcGVyLnZlbG9jaXR5KSB7XG4gICAgICAgIHN3aXBlci51cGRhdGVQcm9ncmVzcyhuZXdQb3NpdGlvbik7XG4gICAgICAgIHN3aXBlci5zZXRUcmFuc2l0aW9uKG1vbWVudHVtRHVyYXRpb24pO1xuICAgICAgICBzd2lwZXIuc2V0VHJhbnNsYXRlKG5ld1Bvc2l0aW9uKTtcbiAgICAgICAgc3dpcGVyLnRyYW5zaXRpb25TdGFydCh0cnVlLCBzd2lwZXIuc3dpcGVEaXJlY3Rpb24pO1xuICAgICAgICBpZiAoIXN3aXBlci5hbmltYXRpbmcpIHtcbiAgICAgICAgICBzd2lwZXIuYW5pbWF0aW5nID0gdHJ1ZTtcbiAgICAgICAgICAkd3JhcHBlckVsLnRyYW5zaXRpb25FbmQoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFzd2lwZXIgfHwgc3dpcGVyLmRlc3Ryb3llZCkgcmV0dXJuO1xuICAgICAgICAgICAgc3dpcGVyLnRyYW5zaXRpb25FbmQoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3dpcGVyLnVwZGF0ZVByb2dyZXNzKG5ld1Bvc2l0aW9uKTtcbiAgICAgIH1cblxuICAgICAgc3dpcGVyLnVwZGF0ZUFjdGl2ZUluZGV4KCk7XG4gICAgICBzd2lwZXIudXBkYXRlU2xpZGVzQ2xhc3NlcygpO1xuICAgIH0gZWxzZSBpZiAocGFyYW1zLmZyZWVNb2RlU3RpY2t5KSB7XG4gICAgICBzd2lwZXIuc2xpZGVUb0Nsb3Nlc3QoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIXBhcmFtcy5mcmVlTW9kZU1vbWVudHVtIHx8IHRpbWVEaWZmID49IHBhcmFtcy5sb25nU3dpcGVzTXMpIHtcbiAgICAgIHN3aXBlci51cGRhdGVQcm9ncmVzcygpO1xuICAgICAgc3dpcGVyLnVwZGF0ZUFjdGl2ZUluZGV4KCk7XG4gICAgICBzd2lwZXIudXBkYXRlU2xpZGVzQ2xhc3NlcygpO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBGaW5kIGN1cnJlbnQgc2xpZGVcbiAgbGV0IHN0b3BJbmRleCA9IDA7XG4gIGxldCBncm91cFNpemUgPSBzd2lwZXIuc2xpZGVzU2l6ZXNHcmlkWzBdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNsaWRlc0dyaWQubGVuZ3RoOyBpICs9IHBhcmFtcy5zbGlkZXNQZXJHcm91cCkge1xuICAgIGlmICh0eXBlb2Ygc2xpZGVzR3JpZFtpICsgcGFyYW1zLnNsaWRlc1Blckdyb3VwXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGlmIChjdXJyZW50UG9zID49IHNsaWRlc0dyaWRbaV0gJiYgY3VycmVudFBvcyA8IHNsaWRlc0dyaWRbaSArIHBhcmFtcy5zbGlkZXNQZXJHcm91cF0pIHtcbiAgICAgICAgc3RvcEluZGV4ID0gaTtcbiAgICAgICAgZ3JvdXBTaXplID0gc2xpZGVzR3JpZFtpICsgcGFyYW1zLnNsaWRlc1Blckdyb3VwXSAtIHNsaWRlc0dyaWRbaV07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjdXJyZW50UG9zID49IHNsaWRlc0dyaWRbaV0pIHtcbiAgICAgIHN0b3BJbmRleCA9IGk7XG4gICAgICBncm91cFNpemUgPSBzbGlkZXNHcmlkW3NsaWRlc0dyaWQubGVuZ3RoIC0gMV0gLSBzbGlkZXNHcmlkW3NsaWRlc0dyaWQubGVuZ3RoIC0gMl07XG4gICAgfVxuICB9XG5cbiAgLy8gRmluZCBjdXJyZW50IHNsaWRlIHNpemVcbiAgY29uc3QgcmF0aW8gPSAoY3VycmVudFBvcyAtIHNsaWRlc0dyaWRbc3RvcEluZGV4XSkgLyBncm91cFNpemU7XG5cbiAgaWYgKHRpbWVEaWZmID4gcGFyYW1zLmxvbmdTd2lwZXNNcykge1xuICAgIC8vIExvbmcgdG91Y2hlc1xuICAgIGlmICghcGFyYW1zLmxvbmdTd2lwZXMpIHtcbiAgICAgIHN3aXBlci5zbGlkZVRvKHN3aXBlci5hY3RpdmVJbmRleCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChzd2lwZXIuc3dpcGVEaXJlY3Rpb24gPT09ICduZXh0Jykge1xuICAgICAgaWYgKHJhdGlvID49IHBhcmFtcy5sb25nU3dpcGVzUmF0aW8pIHN3aXBlci5zbGlkZVRvKHN0b3BJbmRleCArIHBhcmFtcy5zbGlkZXNQZXJHcm91cCk7XG4gICAgICBlbHNlIHN3aXBlci5zbGlkZVRvKHN0b3BJbmRleCk7XG4gICAgfVxuICAgIGlmIChzd2lwZXIuc3dpcGVEaXJlY3Rpb24gPT09ICdwcmV2Jykge1xuICAgICAgaWYgKHJhdGlvID4gKDEgLSBwYXJhbXMubG9uZ1N3aXBlc1JhdGlvKSkgc3dpcGVyLnNsaWRlVG8oc3RvcEluZGV4ICsgcGFyYW1zLnNsaWRlc1Blckdyb3VwKTtcbiAgICAgIGVsc2Ugc3dpcGVyLnNsaWRlVG8oc3RvcEluZGV4KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gU2hvcnQgc3dpcGVzXG4gICAgaWYgKCFwYXJhbXMuc2hvcnRTd2lwZXMpIHtcbiAgICAgIHN3aXBlci5zbGlkZVRvKHN3aXBlci5hY3RpdmVJbmRleCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChzd2lwZXIuc3dpcGVEaXJlY3Rpb24gPT09ICduZXh0Jykge1xuICAgICAgc3dpcGVyLnNsaWRlVG8oc3RvcEluZGV4ICsgcGFyYW1zLnNsaWRlc1Blckdyb3VwKTtcbiAgICB9XG4gICAgaWYgKHN3aXBlci5zd2lwZURpcmVjdGlvbiA9PT0gJ3ByZXYnKSB7XG4gICAgICBzd2lwZXIuc2xpZGVUbyhzdG9wSW5kZXgpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBvblJlc2l6ZSAoKSB7XG4gIGNvbnN0IHN3aXBlciA9IHRoaXM7XG5cbiAgY29uc3QgeyBwYXJhbXMsIGVsIH0gPSBzd2lwZXI7XG5cbiAgaWYgKGVsICYmIGVsLm9mZnNldFdpZHRoID09PSAwKSByZXR1cm47XG5cbiAgLy8gQnJlYWtwb2ludHNcbiAgaWYgKHBhcmFtcy5icmVha3BvaW50cykge1xuICAgIHN3aXBlci5zZXRCcmVha3BvaW50KCk7XG4gIH1cblxuICAvLyBTYXZlIGxvY2tzXG4gIGNvbnN0IHsgYWxsb3dTbGlkZU5leHQsIGFsbG93U2xpZGVQcmV2LCBzbmFwR3JpZCB9ID0gc3dpcGVyO1xuXG4gIC8vIERpc2FibGUgbG9ja3Mgb24gcmVzaXplXG4gIHN3aXBlci5hbGxvd1NsaWRlTmV4dCA9IHRydWU7XG4gIHN3aXBlci5hbGxvd1NsaWRlUHJldiA9IHRydWU7XG5cbiAgc3dpcGVyLnVwZGF0ZVNpemUoKTtcbiAgc3dpcGVyLnVwZGF0ZVNsaWRlcygpO1xuXG4gIGlmIChwYXJhbXMuZnJlZU1vZGUpIHtcbiAgICBjb25zdCBuZXdUcmFuc2xhdGUgPSBNYXRoLm1pbihNYXRoLm1heChzd2lwZXIudHJhbnNsYXRlLCBzd2lwZXIubWF4VHJhbnNsYXRlKCkpLCBzd2lwZXIubWluVHJhbnNsYXRlKCkpO1xuICAgIHN3aXBlci5zZXRUcmFuc2xhdGUobmV3VHJhbnNsYXRlKTtcbiAgICBzd2lwZXIudXBkYXRlQWN0aXZlSW5kZXgoKTtcbiAgICBzd2lwZXIudXBkYXRlU2xpZGVzQ2xhc3NlcygpO1xuXG4gICAgaWYgKHBhcmFtcy5hdXRvSGVpZ2h0KSB7XG4gICAgICBzd2lwZXIudXBkYXRlQXV0b0hlaWdodCgpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBzd2lwZXIudXBkYXRlU2xpZGVzQ2xhc3NlcygpO1xuICAgIGlmICgocGFyYW1zLnNsaWRlc1BlclZpZXcgPT09ICdhdXRvJyB8fCBwYXJhbXMuc2xpZGVzUGVyVmlldyA+IDEpICYmIHN3aXBlci5pc0VuZCAmJiAhc3dpcGVyLnBhcmFtcy5jZW50ZXJlZFNsaWRlcykge1xuICAgICAgc3dpcGVyLnNsaWRlVG8oc3dpcGVyLnNsaWRlcy5sZW5ndGggLSAxLCAwLCBmYWxzZSwgdHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN3aXBlci5zbGlkZVRvKHN3aXBlci5hY3RpdmVJbmRleCwgMCwgZmFsc2UsIHRydWUpO1xuICAgIH1cbiAgfVxuICAvLyBSZXR1cm4gbG9ja3MgYWZ0ZXIgcmVzaXplXG4gIHN3aXBlci5hbGxvd1NsaWRlUHJldiA9IGFsbG93U2xpZGVQcmV2O1xuICBzd2lwZXIuYWxsb3dTbGlkZU5leHQgPSBhbGxvd1NsaWRlTmV4dDtcblxuICBpZiAoc3dpcGVyLnBhcmFtcy53YXRjaE92ZXJmbG93ICYmIHNuYXBHcmlkICE9PSBzd2lwZXIuc25hcEdyaWQpIHtcbiAgICBzd2lwZXIuY2hlY2tPdmVyZmxvdygpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG9uQ2xpY2sgKGUpIHtcbiAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgaWYgKCFzd2lwZXIuYWxsb3dDbGljaykge1xuICAgIGlmIChzd2lwZXIucGFyYW1zLnByZXZlbnRDbGlja3MpIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBpZiAoc3dpcGVyLnBhcmFtcy5wcmV2ZW50Q2xpY2tzUHJvcGFnYXRpb24gJiYgc3dpcGVyLmFuaW1hdGluZykge1xuICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGF0dGFjaEV2ZW50cygpIHtcbiAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgY29uc3Qge1xuICAgIHBhcmFtcywgdG91Y2hFdmVudHMsIGVsLCB3cmFwcGVyRWwsXG4gIH0gPSBzd2lwZXI7XG5cbiAge1xuICAgIHN3aXBlci5vblRvdWNoU3RhcnQgPSBvblRvdWNoU3RhcnQuYmluZChzd2lwZXIpO1xuICAgIHN3aXBlci5vblRvdWNoTW92ZSA9IG9uVG91Y2hNb3ZlLmJpbmQoc3dpcGVyKTtcbiAgICBzd2lwZXIub25Ub3VjaEVuZCA9IG9uVG91Y2hFbmQuYmluZChzd2lwZXIpO1xuICB9XG5cbiAgc3dpcGVyLm9uQ2xpY2sgPSBvbkNsaWNrLmJpbmQoc3dpcGVyKTtcblxuICBjb25zdCB0YXJnZXQgPSBwYXJhbXMudG91Y2hFdmVudHNUYXJnZXQgPT09ICdjb250YWluZXInID8gZWwgOiB3cmFwcGVyRWw7XG4gIGNvbnN0IGNhcHR1cmUgPSAhIXBhcmFtcy5uZXN0ZWQ7XG5cbiAgLy8gVG91Y2ggRXZlbnRzXG4gIHtcbiAgICBpZiAoIVN1cHBvcnQudG91Y2ggJiYgKFN1cHBvcnQucG9pbnRlckV2ZW50cyB8fCBTdXBwb3J0LnByZWZpeGVkUG9pbnRlckV2ZW50cykpIHtcbiAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKHRvdWNoRXZlbnRzLnN0YXJ0LCBzd2lwZXIub25Ub3VjaFN0YXJ0LCBmYWxzZSk7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKHRvdWNoRXZlbnRzLm1vdmUsIHN3aXBlci5vblRvdWNoTW92ZSwgY2FwdHVyZSk7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKHRvdWNoRXZlbnRzLmVuZCwgc3dpcGVyLm9uVG91Y2hFbmQsIGZhbHNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKFN1cHBvcnQudG91Y2gpIHtcbiAgICAgICAgY29uc3QgcGFzc2l2ZUxpc3RlbmVyID0gdG91Y2hFdmVudHMuc3RhcnQgPT09ICd0b3VjaHN0YXJ0JyAmJiBTdXBwb3J0LnBhc3NpdmVMaXN0ZW5lciAmJiBwYXJhbXMucGFzc2l2ZUxpc3RlbmVycyA/IHsgcGFzc2l2ZTogdHJ1ZSwgY2FwdHVyZTogZmFsc2UgfSA6IGZhbHNlO1xuICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcih0b3VjaEV2ZW50cy5zdGFydCwgc3dpcGVyLm9uVG91Y2hTdGFydCwgcGFzc2l2ZUxpc3RlbmVyKTtcbiAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIodG91Y2hFdmVudHMubW92ZSwgc3dpcGVyLm9uVG91Y2hNb3ZlLCBTdXBwb3J0LnBhc3NpdmVMaXN0ZW5lciA/IHsgcGFzc2l2ZTogZmFsc2UsIGNhcHR1cmUgfSA6IGNhcHR1cmUpO1xuICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcih0b3VjaEV2ZW50cy5lbmQsIHN3aXBlci5vblRvdWNoRW5kLCBwYXNzaXZlTGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgaWYgKChwYXJhbXMuc2ltdWxhdGVUb3VjaCAmJiAhRGV2aWNlLmlvcyAmJiAhRGV2aWNlLmFuZHJvaWQpIHx8IChwYXJhbXMuc2ltdWxhdGVUb3VjaCAmJiAhU3VwcG9ydC50b3VjaCAmJiBEZXZpY2UuaW9zKSkge1xuICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgc3dpcGVyLm9uVG91Y2hTdGFydCwgZmFsc2UpO1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBzd2lwZXIub25Ub3VjaE1vdmUsIGNhcHR1cmUpO1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgc3dpcGVyLm9uVG91Y2hFbmQsIGZhbHNlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gUHJldmVudCBMaW5rcyBDbGlja3NcbiAgICBpZiAocGFyYW1zLnByZXZlbnRDbGlja3MgfHwgcGFyYW1zLnByZXZlbnRDbGlja3NQcm9wYWdhdGlvbikge1xuICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgc3dpcGVyLm9uQ2xpY2ssIHRydWUpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFJlc2l6ZSBoYW5kbGVyXG4gIHN3aXBlci5vbigncmVzaXplIG9ic2VydmVyVXBkYXRlJywgb25SZXNpemUsIHRydWUpO1xufVxuXG5mdW5jdGlvbiBkZXRhY2hFdmVudHMoKSB7XG4gIGNvbnN0IHN3aXBlciA9IHRoaXM7XG5cbiAgY29uc3Qge1xuICAgIHBhcmFtcywgdG91Y2hFdmVudHMsIGVsLCB3cmFwcGVyRWwsXG4gIH0gPSBzd2lwZXI7XG5cbiAgY29uc3QgdGFyZ2V0ID0gcGFyYW1zLnRvdWNoRXZlbnRzVGFyZ2V0ID09PSAnY29udGFpbmVyJyA/IGVsIDogd3JhcHBlckVsO1xuICBjb25zdCBjYXB0dXJlID0gISFwYXJhbXMubmVzdGVkO1xuXG4gIC8vIFRvdWNoIEV2ZW50c1xuICB7XG4gICAgaWYgKCFTdXBwb3J0LnRvdWNoICYmIChTdXBwb3J0LnBvaW50ZXJFdmVudHMgfHwgU3VwcG9ydC5wcmVmaXhlZFBvaW50ZXJFdmVudHMpKSB7XG4gICAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0b3VjaEV2ZW50cy5zdGFydCwgc3dpcGVyLm9uVG91Y2hTdGFydCwgZmFsc2UpO1xuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0b3VjaEV2ZW50cy5tb3ZlLCBzd2lwZXIub25Ub3VjaE1vdmUsIGNhcHR1cmUpO1xuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0b3VjaEV2ZW50cy5lbmQsIHN3aXBlci5vblRvdWNoRW5kLCBmYWxzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChTdXBwb3J0LnRvdWNoKSB7XG4gICAgICAgIGNvbnN0IHBhc3NpdmVMaXN0ZW5lciA9IHRvdWNoRXZlbnRzLnN0YXJ0ID09PSAnb25Ub3VjaFN0YXJ0JyAmJiBTdXBwb3J0LnBhc3NpdmVMaXN0ZW5lciAmJiBwYXJhbXMucGFzc2l2ZUxpc3RlbmVycyA/IHsgcGFzc2l2ZTogdHJ1ZSwgY2FwdHVyZTogZmFsc2UgfSA6IGZhbHNlO1xuICAgICAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0b3VjaEV2ZW50cy5zdGFydCwgc3dpcGVyLm9uVG91Y2hTdGFydCwgcGFzc2l2ZUxpc3RlbmVyKTtcbiAgICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIodG91Y2hFdmVudHMubW92ZSwgc3dpcGVyLm9uVG91Y2hNb3ZlLCBjYXB0dXJlKTtcbiAgICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIodG91Y2hFdmVudHMuZW5kLCBzd2lwZXIub25Ub3VjaEVuZCwgcGFzc2l2ZUxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIGlmICgocGFyYW1zLnNpbXVsYXRlVG91Y2ggJiYgIURldmljZS5pb3MgJiYgIURldmljZS5hbmRyb2lkKSB8fCAocGFyYW1zLnNpbXVsYXRlVG91Y2ggJiYgIVN1cHBvcnQudG91Y2ggJiYgRGV2aWNlLmlvcykpIHtcbiAgICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHN3aXBlci5vblRvdWNoU3RhcnQsIGZhbHNlKTtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgc3dpcGVyLm9uVG91Y2hNb3ZlLCBjYXB0dXJlKTtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHN3aXBlci5vblRvdWNoRW5kLCBmYWxzZSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIFByZXZlbnQgTGlua3MgQ2xpY2tzXG4gICAgaWYgKHBhcmFtcy5wcmV2ZW50Q2xpY2tzIHx8IHBhcmFtcy5wcmV2ZW50Q2xpY2tzUHJvcGFnYXRpb24pIHtcbiAgICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHN3aXBlci5vbkNsaWNrLCB0cnVlKTtcbiAgICB9XG4gIH1cblxuICAvLyBSZXNpemUgaGFuZGxlclxuICBzd2lwZXIub2ZmKCdyZXNpemUgb2JzZXJ2ZXJVcGRhdGUnLCBvblJlc2l6ZSk7XG59XG5cbnZhciBldmVudHMgPSB7XG4gIGF0dGFjaEV2ZW50cyxcbiAgZGV0YWNoRXZlbnRzLFxufTtcblxuZnVuY3Rpb24gc2V0QnJlYWtwb2ludCAoKSB7XG4gIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gIGNvbnN0IHtcbiAgICBhY3RpdmVJbmRleCwgaW5pdGlhbGl6ZWQsIGxvb3BlZFNsaWRlcyA9IDAsIHBhcmFtcyxcbiAgfSA9IHN3aXBlcjtcbiAgY29uc3QgYnJlYWtwb2ludHMgPSBwYXJhbXMuYnJlYWtwb2ludHM7XG4gIGlmICghYnJlYWtwb2ludHMgfHwgKGJyZWFrcG9pbnRzICYmIE9iamVjdC5rZXlzKGJyZWFrcG9pbnRzKS5sZW5ndGggPT09IDApKSByZXR1cm47XG4gIC8vIFNldCBicmVha3BvaW50IGZvciB3aW5kb3cgd2lkdGggYW5kIHVwZGF0ZSBwYXJhbWV0ZXJzXG4gIGNvbnN0IGJyZWFrcG9pbnQgPSBzd2lwZXIuZ2V0QnJlYWtwb2ludChicmVha3BvaW50cyk7XG4gIGlmIChicmVha3BvaW50ICYmIHN3aXBlci5jdXJyZW50QnJlYWtwb2ludCAhPT0gYnJlYWtwb2ludCkge1xuICAgIGNvbnN0IGJyZWFrUG9pbnRzUGFyYW1zID0gYnJlYWtwb2ludCBpbiBicmVha3BvaW50cyA/IGJyZWFrcG9pbnRzW2JyZWFrcG9pbnRdIDogc3dpcGVyLm9yaWdpbmFsUGFyYW1zO1xuICAgIGNvbnN0IG5lZWRzUmVMb29wID0gcGFyYW1zLmxvb3AgJiYgKGJyZWFrUG9pbnRzUGFyYW1zLnNsaWRlc1BlclZpZXcgIT09IHBhcmFtcy5zbGlkZXNQZXJWaWV3KTtcblxuICAgIFV0aWxzLmV4dGVuZChzd2lwZXIucGFyYW1zLCBicmVha1BvaW50c1BhcmFtcyk7XG5cbiAgICBVdGlscy5leHRlbmQoc3dpcGVyLCB7XG4gICAgICBhbGxvd1RvdWNoTW92ZTogc3dpcGVyLnBhcmFtcy5hbGxvd1RvdWNoTW92ZSxcbiAgICAgIGFsbG93U2xpZGVOZXh0OiBzd2lwZXIucGFyYW1zLmFsbG93U2xpZGVOZXh0LFxuICAgICAgYWxsb3dTbGlkZVByZXY6IHN3aXBlci5wYXJhbXMuYWxsb3dTbGlkZVByZXYsXG4gICAgfSk7XG5cbiAgICBzd2lwZXIuY3VycmVudEJyZWFrcG9pbnQgPSBicmVha3BvaW50O1xuXG4gICAgaWYgKG5lZWRzUmVMb29wICYmIGluaXRpYWxpemVkKSB7XG4gICAgICBzd2lwZXIubG9vcERlc3Ryb3koKTtcbiAgICAgIHN3aXBlci5sb29wQ3JlYXRlKCk7XG4gICAgICBzd2lwZXIudXBkYXRlU2xpZGVzKCk7XG4gICAgICBzd2lwZXIuc2xpZGVUbygoYWN0aXZlSW5kZXggLSBsb29wZWRTbGlkZXMpICsgc3dpcGVyLmxvb3BlZFNsaWRlcywgMCwgZmFsc2UpO1xuICAgIH1cbiAgICBzd2lwZXIuZW1pdCgnYnJlYWtwb2ludCcsIGJyZWFrUG9pbnRzUGFyYW1zKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRCcmVha3BvaW50IChicmVha3BvaW50cykge1xuICAvLyBHZXQgYnJlYWtwb2ludCBmb3Igd2luZG93IHdpZHRoXG4gIGlmICghYnJlYWtwb2ludHMpIHJldHVybiB1bmRlZmluZWQ7XG4gIGxldCBicmVha3BvaW50ID0gZmFsc2U7XG4gIGNvbnN0IHBvaW50cyA9IFtdO1xuICBPYmplY3Qua2V5cyhicmVha3BvaW50cykuZm9yRWFjaCgocG9pbnQpID0+IHtcbiAgICBwb2ludHMucHVzaChwb2ludCk7XG4gIH0pO1xuICBwb2ludHMuc29ydCgoYSwgYikgPT4gcGFyc2VJbnQoYSwgMTApIC0gcGFyc2VJbnQoYiwgMTApKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICBjb25zdCBwb2ludCA9IHBvaW50c1tpXTtcbiAgICBpZiAocG9pbnQgPj0gd2luZG93JDEuaW5uZXJXaWR0aCAmJiAhYnJlYWtwb2ludCkge1xuICAgICAgYnJlYWtwb2ludCA9IHBvaW50O1xuICAgIH1cbiAgfVxuICByZXR1cm4gYnJlYWtwb2ludCB8fCAnbWF4Jztcbn1cblxudmFyIGJyZWFrcG9pbnRzID0geyBzZXRCcmVha3BvaW50LCBnZXRCcmVha3BvaW50IH07XG5cbmNvbnN0IEJyb3dzZXIgPSAoZnVuY3Rpb24gQnJvd3NlcigpIHtcbiAgZnVuY3Rpb24gaXNTYWZhcmkoKSB7XG4gICAgY29uc3QgdWEgPSB3aW5kb3ckMS5uYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCk7XG4gICAgcmV0dXJuICh1YS5pbmRleE9mKCdzYWZhcmknKSA+PSAwICYmIHVhLmluZGV4T2YoJ2Nocm9tZScpIDwgMCAmJiB1YS5pbmRleE9mKCdhbmRyb2lkJykgPCAwKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGlzSUU6ICEhd2luZG93JDEubmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvVHJpZGVudC9nKSB8fCAhIXdpbmRvdyQxLm5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL01TSUUvZyksXG4gICAgaXNTYWZhcmk6IGlzU2FmYXJpKCksXG4gICAgaXNVaVdlYlZpZXc6IC8oaVBob25lfGlQb2R8aVBhZCkuKkFwcGxlV2ViS2l0KD8hLipTYWZhcmkpL2kudGVzdCh3aW5kb3ckMS5uYXZpZ2F0b3IudXNlckFnZW50KSxcbiAgfTtcbn0oKSk7XG5cbmZ1bmN0aW9uIGFkZENsYXNzZXMgKCkge1xuICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICBjb25zdCB7XG4gICAgY2xhc3NOYW1lcywgcGFyYW1zLCBydGwsICRlbCxcbiAgfSA9IHN3aXBlcjtcbiAgY29uc3Qgc3VmZml4ZXMgPSBbXTtcblxuICBzdWZmaXhlcy5wdXNoKHBhcmFtcy5kaXJlY3Rpb24pO1xuXG4gIGlmIChwYXJhbXMuZnJlZU1vZGUpIHtcbiAgICBzdWZmaXhlcy5wdXNoKCdmcmVlLW1vZGUnKTtcbiAgfVxuICBpZiAoIVN1cHBvcnQuZmxleGJveCkge1xuICAgIHN1ZmZpeGVzLnB1c2goJ25vLWZsZXhib3gnKTtcbiAgfVxuICBpZiAocGFyYW1zLmF1dG9IZWlnaHQpIHtcbiAgICBzdWZmaXhlcy5wdXNoKCdhdXRvaGVpZ2h0Jyk7XG4gIH1cbiAgaWYgKHJ0bCkge1xuICAgIHN1ZmZpeGVzLnB1c2goJ3J0bCcpO1xuICB9XG4gIGlmIChwYXJhbXMuc2xpZGVzUGVyQ29sdW1uID4gMSkge1xuICAgIHN1ZmZpeGVzLnB1c2goJ211bHRpcm93Jyk7XG4gIH1cbiAgaWYgKERldmljZS5hbmRyb2lkKSB7XG4gICAgc3VmZml4ZXMucHVzaCgnYW5kcm9pZCcpO1xuICB9XG4gIGlmIChEZXZpY2UuaW9zKSB7XG4gICAgc3VmZml4ZXMucHVzaCgnaW9zJyk7XG4gIH1cbiAgLy8gV1A4IFRvdWNoIEV2ZW50cyBGaXhcbiAgaWYgKEJyb3dzZXIuaXNJRSAmJiAoU3VwcG9ydC5wb2ludGVyRXZlbnRzIHx8IFN1cHBvcnQucHJlZml4ZWRQb2ludGVyRXZlbnRzKSkge1xuICAgIHN1ZmZpeGVzLnB1c2goYHdwOC0ke3BhcmFtcy5kaXJlY3Rpb259YCk7XG4gIH1cblxuICBzdWZmaXhlcy5mb3JFYWNoKChzdWZmaXgpID0+IHtcbiAgICBjbGFzc05hbWVzLnB1c2gocGFyYW1zLmNvbnRhaW5lck1vZGlmaWVyQ2xhc3MgKyBzdWZmaXgpO1xuICB9KTtcblxuICAkZWwuYWRkQ2xhc3MoY2xhc3NOYW1lcy5qb2luKCcgJykpO1xufVxuXG5mdW5jdGlvbiByZW1vdmVDbGFzc2VzICgpIHtcbiAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgY29uc3QgeyAkZWwsIGNsYXNzTmFtZXMgfSA9IHN3aXBlcjtcblxuICAkZWwucmVtb3ZlQ2xhc3MoY2xhc3NOYW1lcy5qb2luKCcgJykpO1xufVxuXG52YXIgY2xhc3NlcyA9IHsgYWRkQ2xhc3NlcywgcmVtb3ZlQ2xhc3NlcyB9O1xuXG5mdW5jdGlvbiBsb2FkSW1hZ2UgKGltYWdlRWwsIHNyYywgc3Jjc2V0LCBzaXplcywgY2hlY2tGb3JDb21wbGV0ZSwgY2FsbGJhY2spIHtcbiAgbGV0IGltYWdlO1xuICBmdW5jdGlvbiBvblJlYWR5KCkge1xuICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2soKTtcbiAgfVxuICBpZiAoIWltYWdlRWwuY29tcGxldGUgfHwgIWNoZWNrRm9yQ29tcGxldGUpIHtcbiAgICBpZiAoc3JjKSB7XG4gICAgICBpbWFnZSA9IG5ldyB3aW5kb3ckMS5JbWFnZSgpO1xuICAgICAgaW1hZ2Uub25sb2FkID0gb25SZWFkeTtcbiAgICAgIGltYWdlLm9uZXJyb3IgPSBvblJlYWR5O1xuICAgICAgaWYgKHNpemVzKSB7XG4gICAgICAgIGltYWdlLnNpemVzID0gc2l6ZXM7XG4gICAgICB9XG4gICAgICBpZiAoc3Jjc2V0KSB7XG4gICAgICAgIGltYWdlLnNyY3NldCA9IHNyY3NldDtcbiAgICAgIH1cbiAgICAgIGlmIChzcmMpIHtcbiAgICAgICAgaW1hZ2Uuc3JjID0gc3JjO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBvblJlYWR5KCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIGltYWdlIGFscmVhZHkgbG9hZGVkLi4uXG4gICAgb25SZWFkeSgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByZWxvYWRJbWFnZXMgKCkge1xuICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICBzd2lwZXIuaW1hZ2VzVG9Mb2FkID0gc3dpcGVyLiRlbC5maW5kKCdpbWcnKTtcbiAgZnVuY3Rpb24gb25SZWFkeSgpIHtcbiAgICBpZiAodHlwZW9mIHN3aXBlciA9PT0gJ3VuZGVmaW5lZCcgfHwgc3dpcGVyID09PSBudWxsIHx8ICFzd2lwZXIgfHwgc3dpcGVyLmRlc3Ryb3llZCkgcmV0dXJuO1xuICAgIGlmIChzd2lwZXIuaW1hZ2VzTG9hZGVkICE9PSB1bmRlZmluZWQpIHN3aXBlci5pbWFnZXNMb2FkZWQgKz0gMTtcbiAgICBpZiAoc3dpcGVyLmltYWdlc0xvYWRlZCA9PT0gc3dpcGVyLmltYWdlc1RvTG9hZC5sZW5ndGgpIHtcbiAgICAgIGlmIChzd2lwZXIucGFyYW1zLnVwZGF0ZU9uSW1hZ2VzUmVhZHkpIHN3aXBlci51cGRhdGUoKTtcbiAgICAgIHN3aXBlci5lbWl0KCdpbWFnZXNSZWFkeScpO1xuICAgIH1cbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IHN3aXBlci5pbWFnZXNUb0xvYWQubGVuZ3RoOyBpICs9IDEpIHtcbiAgICBjb25zdCBpbWFnZUVsID0gc3dpcGVyLmltYWdlc1RvTG9hZFtpXTtcbiAgICBzd2lwZXIubG9hZEltYWdlKFxuICAgICAgaW1hZ2VFbCxcbiAgICAgIGltYWdlRWwuY3VycmVudFNyYyB8fCBpbWFnZUVsLmdldEF0dHJpYnV0ZSgnc3JjJyksXG4gICAgICBpbWFnZUVsLnNyY3NldCB8fCBpbWFnZUVsLmdldEF0dHJpYnV0ZSgnc3Jjc2V0JyksXG4gICAgICBpbWFnZUVsLnNpemVzIHx8IGltYWdlRWwuZ2V0QXR0cmlidXRlKCdzaXplcycpLFxuICAgICAgdHJ1ZSxcbiAgICAgIG9uUmVhZHlcbiAgICApO1xuICB9XG59XG5cbnZhciBpbWFnZXMgPSB7XG4gIGxvYWRJbWFnZSxcbiAgcHJlbG9hZEltYWdlcyxcbn07XG5cbmZ1bmN0aW9uIGNoZWNrT3ZlcmZsb3coKSB7XG4gIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gIGNvbnN0IHdhc0xvY2tlZCA9IHN3aXBlci5pc0xvY2tlZDtcblxuICBzd2lwZXIuaXNMb2NrZWQgPSBzd2lwZXIuc25hcEdyaWQubGVuZ3RoID09PSAxO1xuICBzd2lwZXIuYWxsb3dTbGlkZU5leHQgPSAhc3dpcGVyLmlzTG9ja2VkO1xuICBzd2lwZXIuYWxsb3dTbGlkZVByZXYgPSAhc3dpcGVyLmlzTG9ja2VkO1xuXG4gIC8vIGV2ZW50c1xuICBpZiAod2FzTG9ja2VkICE9PSBzd2lwZXIuaXNMb2NrZWQpIHN3aXBlci5lbWl0KHN3aXBlci5pc0xvY2tlZCA/ICdsb2NrJyA6ICd1bmxvY2snKTtcblxuICBpZiAod2FzTG9ja2VkICYmIHdhc0xvY2tlZCAhPT0gc3dpcGVyLmlzTG9ja2VkKSB7XG4gICAgc3dpcGVyLmlzRW5kID0gZmFsc2U7XG4gICAgc3dpcGVyLm5hdmlnYXRpb24udXBkYXRlKCk7XG4gIH1cbn1cblxudmFyIGNoZWNrT3ZlcmZsb3ckMSA9IHsgY2hlY2tPdmVyZmxvdyB9O1xuXG52YXIgZGVmYXVsdHMgPSB7XG4gIGluaXQ6IHRydWUsXG4gIGRpcmVjdGlvbjogJ2hvcml6b250YWwnLFxuICB0b3VjaEV2ZW50c1RhcmdldDogJ2NvbnRhaW5lcicsXG4gIGluaXRpYWxTbGlkZTogMCxcbiAgc3BlZWQ6IDMwMCxcbiAgLy9cbiAgcHJldmVudEludGVyY2F0aW9uT25UcmFuc2l0aW9uOiBmYWxzZSxcblxuICAvLyBUbyBzdXBwb3J0IGlPUydzIHN3aXBlLXRvLWdvLWJhY2sgZ2VzdHVyZSAod2hlbiBiZWluZyB1c2VkIGluLWFwcCwgd2l0aCBVSVdlYlZpZXcpLlxuICBpT1NFZGdlU3dpcGVEZXRlY3Rpb246IGZhbHNlLFxuICBpT1NFZGdlU3dpcGVUaHJlc2hvbGQ6IDIwLFxuXG4gIC8vIEZyZWUgbW9kZVxuICBmcmVlTW9kZTogZmFsc2UsXG4gIGZyZWVNb2RlTW9tZW50dW06IHRydWUsXG4gIGZyZWVNb2RlTW9tZW50dW1SYXRpbzogMSxcbiAgZnJlZU1vZGVNb21lbnR1bUJvdW5jZTogdHJ1ZSxcbiAgZnJlZU1vZGVNb21lbnR1bUJvdW5jZVJhdGlvOiAxLFxuICBmcmVlTW9kZU1vbWVudHVtVmVsb2NpdHlSYXRpbzogMSxcbiAgZnJlZU1vZGVTdGlja3k6IGZhbHNlLFxuICBmcmVlTW9kZU1pbmltdW1WZWxvY2l0eTogMC4wMixcblxuICAvLyBBdXRvaGVpZ2h0XG4gIGF1dG9IZWlnaHQ6IGZhbHNlLFxuXG4gIC8vIFNldCB3cmFwcGVyIHdpZHRoXG4gIHNldFdyYXBwZXJTaXplOiBmYWxzZSxcblxuICAvLyBWaXJ0dWFsIFRyYW5zbGF0ZVxuICB2aXJ0dWFsVHJhbnNsYXRlOiBmYWxzZSxcblxuICAvLyBFZmZlY3RzXG4gIGVmZmVjdDogJ3NsaWRlJywgLy8gJ3NsaWRlJyBvciAnZmFkZScgb3IgJ2N1YmUnIG9yICdjb3ZlcmZsb3cnIG9yICdmbGlwJ1xuXG4gIC8vIEJyZWFrcG9pbnRzXG4gIGJyZWFrcG9pbnRzOiB1bmRlZmluZWQsXG5cbiAgLy8gU2xpZGVzIGdyaWRcbiAgc3BhY2VCZXR3ZWVuOiAwLFxuICBzbGlkZXNQZXJWaWV3OiAxLFxuICBzbGlkZXNQZXJDb2x1bW46IDEsXG4gIHNsaWRlc1BlckNvbHVtbkZpbGw6ICdjb2x1bW4nLFxuICBzbGlkZXNQZXJHcm91cDogMSxcbiAgY2VudGVyZWRTbGlkZXM6IGZhbHNlLFxuICBzbGlkZXNPZmZzZXRCZWZvcmU6IDAsIC8vIGluIHB4XG4gIHNsaWRlc09mZnNldEFmdGVyOiAwLCAvLyBpbiBweFxuICBub3JtYWxpemVTbGlkZUluZGV4OiB0cnVlLFxuXG4gIC8vIERpc2FibGUgc3dpcGVyIGFuZCBoaWRlIG5hdmlnYXRpb24gd2hlbiBjb250YWluZXIgbm90IG92ZXJmbG93XG4gIHdhdGNoT3ZlcmZsb3c6IGZhbHNlLFxuXG4gIC8vIFJvdW5kIGxlbmd0aFxuICByb3VuZExlbmd0aHM6IGZhbHNlLFxuXG4gIC8vIFRvdWNoZXNcbiAgdG91Y2hSYXRpbzogMSxcbiAgdG91Y2hBbmdsZTogNDUsXG4gIHNpbXVsYXRlVG91Y2g6IHRydWUsXG4gIHNob3J0U3dpcGVzOiB0cnVlLFxuICBsb25nU3dpcGVzOiB0cnVlLFxuICBsb25nU3dpcGVzUmF0aW86IDAuNSxcbiAgbG9uZ1N3aXBlc01zOiAzMDAsXG4gIGZvbGxvd0ZpbmdlcjogdHJ1ZSxcbiAgYWxsb3dUb3VjaE1vdmU6IHRydWUsXG4gIHRocmVzaG9sZDogMCxcbiAgdG91Y2hNb3ZlU3RvcFByb3BhZ2F0aW9uOiB0cnVlLFxuICB0b3VjaFJlbGVhc2VPbkVkZ2VzOiBmYWxzZSxcblxuICAvLyBVbmlxdWUgTmF2aWdhdGlvbiBFbGVtZW50c1xuICB1bmlxdWVOYXZFbGVtZW50czogdHJ1ZSxcblxuICAvLyBSZXNpc3RhbmNlXG4gIHJlc2lzdGFuY2U6IHRydWUsXG4gIHJlc2lzdGFuY2VSYXRpbzogMC44NSxcblxuICAvLyBQcm9ncmVzc1xuICB3YXRjaFNsaWRlc1Byb2dyZXNzOiBmYWxzZSxcbiAgd2F0Y2hTbGlkZXNWaXNpYmlsaXR5OiBmYWxzZSxcblxuICAvLyBDdXJzb3JcbiAgZ3JhYkN1cnNvcjogZmFsc2UsXG5cbiAgLy8gQ2xpY2tzXG4gIHByZXZlbnRDbGlja3M6IHRydWUsXG4gIHByZXZlbnRDbGlja3NQcm9wYWdhdGlvbjogdHJ1ZSxcbiAgc2xpZGVUb0NsaWNrZWRTbGlkZTogZmFsc2UsXG5cbiAgLy8gSW1hZ2VzXG4gIHByZWxvYWRJbWFnZXM6IHRydWUsXG4gIHVwZGF0ZU9uSW1hZ2VzUmVhZHk6IHRydWUsXG5cbiAgLy8gbG9vcFxuICBsb29wOiBmYWxzZSxcbiAgbG9vcEFkZGl0aW9uYWxTbGlkZXM6IDAsXG4gIGxvb3BlZFNsaWRlczogbnVsbCxcbiAgbG9vcEZpbGxHcm91cFdpdGhCbGFuazogZmFsc2UsXG5cbiAgLy8gU3dpcGluZy9ubyBzd2lwaW5nXG4gIGFsbG93U2xpZGVQcmV2OiB0cnVlLFxuICBhbGxvd1NsaWRlTmV4dDogdHJ1ZSxcbiAgc3dpcGVIYW5kbGVyOiBudWxsLCAvLyAnLnN3aXBlLWhhbmRsZXInLFxuICBub1N3aXBpbmc6IHRydWUsXG4gIG5vU3dpcGluZ0NsYXNzOiAnc3dpcGVyLW5vLXN3aXBpbmcnLFxuICBub1N3aXBpbmdTZWxlY3RvcjogbnVsbCxcblxuICAvLyBQYXNzaXZlIExpc3RlbmVyc1xuICBwYXNzaXZlTGlzdGVuZXJzOiB0cnVlLFxuXG4gIC8vIE5TXG4gIGNvbnRhaW5lck1vZGlmaWVyQ2xhc3M6ICdzd2lwZXItY29udGFpbmVyLScsIC8vIE5FV1xuICBzbGlkZUNsYXNzOiAnc3dpcGVyLXNsaWRlJyxcbiAgc2xpZGVCbGFua0NsYXNzOiAnc3dpcGVyLXNsaWRlLWludmlzaWJsZS1ibGFuaycsXG4gIHNsaWRlQWN0aXZlQ2xhc3M6ICdzd2lwZXItc2xpZGUtYWN0aXZlJyxcbiAgc2xpZGVEdXBsaWNhdGVBY3RpdmVDbGFzczogJ3N3aXBlci1zbGlkZS1kdXBsaWNhdGUtYWN0aXZlJyxcbiAgc2xpZGVWaXNpYmxlQ2xhc3M6ICdzd2lwZXItc2xpZGUtdmlzaWJsZScsXG4gIHNsaWRlRHVwbGljYXRlQ2xhc3M6ICdzd2lwZXItc2xpZGUtZHVwbGljYXRlJyxcbiAgc2xpZGVOZXh0Q2xhc3M6ICdzd2lwZXItc2xpZGUtbmV4dCcsXG4gIHNsaWRlRHVwbGljYXRlTmV4dENsYXNzOiAnc3dpcGVyLXNsaWRlLWR1cGxpY2F0ZS1uZXh0JyxcbiAgc2xpZGVQcmV2Q2xhc3M6ICdzd2lwZXItc2xpZGUtcHJldicsXG4gIHNsaWRlRHVwbGljYXRlUHJldkNsYXNzOiAnc3dpcGVyLXNsaWRlLWR1cGxpY2F0ZS1wcmV2JyxcbiAgd3JhcHBlckNsYXNzOiAnc3dpcGVyLXdyYXBwZXInLFxuXG4gIC8vIENhbGxiYWNrc1xuICBydW5DYWxsYmFja3NPbkluaXQ6IHRydWUsXG59O1xuXG5jb25zdCBwcm90b3R5cGVzID0ge1xuICB1cGRhdGUsXG4gIHRyYW5zbGF0ZSxcbiAgdHJhbnNpdGlvbixcbiAgc2xpZGUsXG4gIGxvb3AsXG4gIGdyYWJDdXJzb3IsXG4gIG1hbmlwdWxhdGlvbixcbiAgZXZlbnRzLFxuICBicmVha3BvaW50cyxcbiAgY2hlY2tPdmVyZmxvdzogY2hlY2tPdmVyZmxvdyQxLFxuICBjbGFzc2VzLFxuICBpbWFnZXMsXG59O1xuXG5jb25zdCBleHRlbmRlZERlZmF1bHRzID0ge307XG5cbmNsYXNzIFN3aXBlciBleHRlbmRzIEZyYW1ld29yazdDbGFzcyB7XG4gIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICBsZXQgZWw7XG4gICAgbGV0IHBhcmFtcztcbiAgICBpZiAoYXJncy5sZW5ndGggPT09IDEgJiYgYXJnc1swXS5jb25zdHJ1Y3RvciAmJiBhcmdzWzBdLmNvbnN0cnVjdG9yID09PSBPYmplY3QpIHtcbiAgICAgIHBhcmFtcyA9IGFyZ3NbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIFtlbCwgcGFyYW1zXSA9IGFyZ3M7XG4gICAgfVxuICAgIGlmICghcGFyYW1zKSBwYXJhbXMgPSB7fTtcblxuICAgIHBhcmFtcyA9IFV0aWxzLmV4dGVuZCh7fSwgcGFyYW1zKTtcbiAgICBpZiAoZWwgJiYgIXBhcmFtcy5lbCkgcGFyYW1zLmVsID0gZWw7XG5cbiAgICBzdXBlcihwYXJhbXMpO1xuXG4gICAgT2JqZWN0LmtleXMocHJvdG90eXBlcykuZm9yRWFjaCgocHJvdG90eXBlR3JvdXApID0+IHtcbiAgICAgIE9iamVjdC5rZXlzKHByb3RvdHlwZXNbcHJvdG90eXBlR3JvdXBdKS5mb3JFYWNoKChwcm90b01ldGhvZCkgPT4ge1xuICAgICAgICBpZiAoIVN3aXBlci5wcm90b3R5cGVbcHJvdG9NZXRob2RdKSB7XG4gICAgICAgICAgU3dpcGVyLnByb3RvdHlwZVtwcm90b01ldGhvZF0gPSBwcm90b3R5cGVzW3Byb3RvdHlwZUdyb3VwXVtwcm90b01ldGhvZF07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLy8gU3dpcGVyIEluc3RhbmNlXG4gICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICBpZiAodHlwZW9mIHN3aXBlci5tb2R1bGVzID09PSAndW5kZWZpbmVkJykge1xuICAgICAgc3dpcGVyLm1vZHVsZXMgPSB7fTtcbiAgICB9XG4gICAgT2JqZWN0LmtleXMoc3dpcGVyLm1vZHVsZXMpLmZvckVhY2goKG1vZHVsZU5hbWUpID0+IHtcbiAgICAgIGNvbnN0IG1vZHVsZSA9IHN3aXBlci5tb2R1bGVzW21vZHVsZU5hbWVdO1xuICAgICAgaWYgKG1vZHVsZS5wYXJhbXMpIHtcbiAgICAgICAgY29uc3QgbW9kdWxlUGFyYW1OYW1lID0gT2JqZWN0LmtleXMobW9kdWxlLnBhcmFtcylbMF07XG4gICAgICAgIGNvbnN0IG1vZHVsZVBhcmFtcyA9IG1vZHVsZS5wYXJhbXNbbW9kdWxlUGFyYW1OYW1lXTtcbiAgICAgICAgaWYgKHR5cGVvZiBtb2R1bGVQYXJhbXMgIT09ICdvYmplY3QnKSByZXR1cm47XG4gICAgICAgIGlmICghKG1vZHVsZVBhcmFtTmFtZSBpbiBwYXJhbXMgJiYgJ2VuYWJsZWQnIGluIG1vZHVsZVBhcmFtcykpIHJldHVybjtcbiAgICAgICAgaWYgKHBhcmFtc1ttb2R1bGVQYXJhbU5hbWVdID09PSB0cnVlKSB7XG4gICAgICAgICAgcGFyYW1zW21vZHVsZVBhcmFtTmFtZV0gPSB7IGVuYWJsZWQ6IHRydWUgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoXG4gICAgICAgICAgdHlwZW9mIHBhcmFtc1ttb2R1bGVQYXJhbU5hbWVdID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICEoJ2VuYWJsZWQnIGluIHBhcmFtc1ttb2R1bGVQYXJhbU5hbWVdKVxuICAgICAgICApIHtcbiAgICAgICAgICBwYXJhbXNbbW9kdWxlUGFyYW1OYW1lXS5lbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXBhcmFtc1ttb2R1bGVQYXJhbU5hbWVdKSBwYXJhbXNbbW9kdWxlUGFyYW1OYW1lXSA9IHsgZW5hYmxlZDogZmFsc2UgfTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIEV4dGVuZCBkZWZhdWx0cyB3aXRoIG1vZHVsZXMgcGFyYW1zXG4gICAgY29uc3Qgc3dpcGVyUGFyYW1zID0gVXRpbHMuZXh0ZW5kKHt9LCBkZWZhdWx0cyk7XG4gICAgc3dpcGVyLnVzZU1vZHVsZXNQYXJhbXMoc3dpcGVyUGFyYW1zKTtcblxuICAgIC8vIEV4dGVuZCBkZWZhdWx0cyB3aXRoIHBhc3NlZCBwYXJhbXNcbiAgICBzd2lwZXIucGFyYW1zID0gVXRpbHMuZXh0ZW5kKHt9LCBzd2lwZXJQYXJhbXMsIGV4dGVuZGVkRGVmYXVsdHMsIHBhcmFtcyk7XG4gICAgc3dpcGVyLm9yaWdpbmFsUGFyYW1zID0gVXRpbHMuZXh0ZW5kKHt9LCBzd2lwZXIucGFyYW1zKTtcbiAgICBzd2lwZXIucGFzc2VkUGFyYW1zID0gVXRpbHMuZXh0ZW5kKHt9LCBwYXJhbXMpO1xuXG4gICAgLy8gU2F2ZSBEb20gbGliXG4gICAgc3dpcGVyLiQgPSAkO1xuXG4gICAgLy8gRmluZCBlbFxuICAgIGNvbnN0ICRlbCA9ICQoc3dpcGVyLnBhcmFtcy5lbCk7XG4gICAgZWwgPSAkZWxbMF07XG5cbiAgICBpZiAoIWVsKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGlmICgkZWwubGVuZ3RoID4gMSkge1xuICAgICAgY29uc3Qgc3dpcGVycyA9IFtdO1xuICAgICAgJGVsLmVhY2goKGluZGV4LCBjb250YWluZXJFbCkgPT4ge1xuICAgICAgICBjb25zdCBuZXdQYXJhbXMgPSBVdGlscy5leHRlbmQoe30sIHBhcmFtcywgeyBlbDogY29udGFpbmVyRWwgfSk7XG4gICAgICAgIHN3aXBlcnMucHVzaChuZXcgU3dpcGVyKG5ld1BhcmFtcykpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gc3dpcGVycztcbiAgICB9XG5cbiAgICBlbC5zd2lwZXIgPSBzd2lwZXI7XG4gICAgJGVsLmRhdGEoJ3N3aXBlcicsIHN3aXBlcik7XG5cbiAgICAvLyBGaW5kIFdyYXBwZXJcbiAgICBjb25zdCAkd3JhcHBlckVsID0gJGVsLmNoaWxkcmVuKGAuJHtzd2lwZXIucGFyYW1zLndyYXBwZXJDbGFzc31gKTtcblxuICAgIC8vIEV4dGVuZCBTd2lwZXJcbiAgICBVdGlscy5leHRlbmQoc3dpcGVyLCB7XG4gICAgICAkZWwsXG4gICAgICBlbCxcbiAgICAgICR3cmFwcGVyRWwsXG4gICAgICB3cmFwcGVyRWw6ICR3cmFwcGVyRWxbMF0sXG5cbiAgICAgIC8vIENsYXNzZXNcbiAgICAgIGNsYXNzTmFtZXM6IFtdLFxuXG4gICAgICAvLyBTbGlkZXNcbiAgICAgIHNsaWRlczogJCgpLFxuICAgICAgc2xpZGVzR3JpZDogW10sXG4gICAgICBzbmFwR3JpZDogW10sXG4gICAgICBzbGlkZXNTaXplc0dyaWQ6IFtdLFxuXG4gICAgICAvLyBpc0RpcmVjdGlvblxuICAgICAgaXNIb3Jpem9udGFsKCkge1xuICAgICAgICByZXR1cm4gc3dpcGVyLnBhcmFtcy5kaXJlY3Rpb24gPT09ICdob3Jpem9udGFsJztcbiAgICAgIH0sXG4gICAgICBpc1ZlcnRpY2FsKCkge1xuICAgICAgICByZXR1cm4gc3dpcGVyLnBhcmFtcy5kaXJlY3Rpb24gPT09ICd2ZXJ0aWNhbCc7XG4gICAgICB9LFxuICAgICAgLy8gUlRMXG4gICAgICBydGw6IChlbC5kaXIudG9Mb3dlckNhc2UoKSA9PT0gJ3J0bCcgfHwgJGVsLmNzcygnZGlyZWN0aW9uJykgPT09ICdydGwnKSxcbiAgICAgIHJ0bFRyYW5zbGF0ZTogc3dpcGVyLnBhcmFtcy5kaXJlY3Rpb24gPT09ICdob3Jpem9udGFsJyAmJiAoZWwuZGlyLnRvTG93ZXJDYXNlKCkgPT09ICdydGwnIHx8ICRlbC5jc3MoJ2RpcmVjdGlvbicpID09PSAncnRsJyksXG4gICAgICB3cm9uZ1JUTDogJHdyYXBwZXJFbC5jc3MoJ2Rpc3BsYXknKSA9PT0gJy13ZWJraXQtYm94JyxcblxuICAgICAgLy8gSW5kZXhlc1xuICAgICAgYWN0aXZlSW5kZXg6IDAsXG4gICAgICByZWFsSW5kZXg6IDAsXG5cbiAgICAgIC8vXG4gICAgICBpc0JlZ2lubmluZzogdHJ1ZSxcbiAgICAgIGlzRW5kOiBmYWxzZSxcblxuICAgICAgLy8gUHJvcHNcbiAgICAgIHRyYW5zbGF0ZTogMCxcbiAgICAgIHByb2dyZXNzOiAwLFxuICAgICAgdmVsb2NpdHk6IDAsXG4gICAgICBhbmltYXRpbmc6IGZhbHNlLFxuXG4gICAgICAvLyBMb2Nrc1xuICAgICAgYWxsb3dTbGlkZU5leHQ6IHN3aXBlci5wYXJhbXMuYWxsb3dTbGlkZU5leHQsXG4gICAgICBhbGxvd1NsaWRlUHJldjogc3dpcGVyLnBhcmFtcy5hbGxvd1NsaWRlUHJldixcblxuICAgICAgLy8gVG91Y2ggRXZlbnRzXG4gICAgICB0b3VjaEV2ZW50czogKGZ1bmN0aW9uIHRvdWNoRXZlbnRzKCkge1xuICAgICAgICBjb25zdCB0b3VjaCA9IFsndG91Y2hzdGFydCcsICd0b3VjaG1vdmUnLCAndG91Y2hlbmQnXTtcbiAgICAgICAgbGV0IGRlc2t0b3AgPSBbJ21vdXNlZG93bicsICdtb3VzZW1vdmUnLCAnbW91c2V1cCddO1xuICAgICAgICBpZiAoU3VwcG9ydC5wb2ludGVyRXZlbnRzKSB7XG4gICAgICAgICAgZGVza3RvcCA9IFsncG9pbnRlcmRvd24nLCAncG9pbnRlcm1vdmUnLCAncG9pbnRlcnVwJ107XG4gICAgICAgIH0gZWxzZSBpZiAoU3VwcG9ydC5wcmVmaXhlZFBvaW50ZXJFdmVudHMpIHtcbiAgICAgICAgICBkZXNrdG9wID0gWydNU1BvaW50ZXJEb3duJywgJ01TUG9pbnRlck1vdmUnLCAnTVNQb2ludGVyVXAnXTtcbiAgICAgICAgfVxuICAgICAgICBzd2lwZXIudG91Y2hFdmVudHNUb3VjaCA9IHtcbiAgICAgICAgICBzdGFydDogdG91Y2hbMF0sXG4gICAgICAgICAgbW92ZTogdG91Y2hbMV0sXG4gICAgICAgICAgZW5kOiB0b3VjaFsyXSxcbiAgICAgICAgfTtcbiAgICAgICAgc3dpcGVyLnRvdWNoRXZlbnRzRGVza3RvcCA9IHtcbiAgICAgICAgICBzdGFydDogZGVza3RvcFswXSxcbiAgICAgICAgICBtb3ZlOiBkZXNrdG9wWzFdLFxuICAgICAgICAgIGVuZDogZGVza3RvcFsyXSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFN1cHBvcnQudG91Y2ggfHwgIXN3aXBlci5wYXJhbXMuc2ltdWxhdGVUb3VjaCA/IHN3aXBlci50b3VjaEV2ZW50c1RvdWNoIDogc3dpcGVyLnRvdWNoRXZlbnRzRGVza3RvcDtcbiAgICAgIH0oKSksXG4gICAgICB0b3VjaEV2ZW50c0RhdGE6IHtcbiAgICAgICAgaXNUb3VjaGVkOiB1bmRlZmluZWQsXG4gICAgICAgIGlzTW92ZWQ6IHVuZGVmaW5lZCxcbiAgICAgICAgYWxsb3dUb3VjaENhbGxiYWNrczogdW5kZWZpbmVkLFxuICAgICAgICB0b3VjaFN0YXJ0VGltZTogdW5kZWZpbmVkLFxuICAgICAgICBpc1Njcm9sbGluZzogdW5kZWZpbmVkLFxuICAgICAgICBjdXJyZW50VHJhbnNsYXRlOiB1bmRlZmluZWQsXG4gICAgICAgIHN0YXJ0VHJhbnNsYXRlOiB1bmRlZmluZWQsXG4gICAgICAgIGFsbG93VGhyZXNob2xkTW92ZTogdW5kZWZpbmVkLFxuICAgICAgICAvLyBGb3JtIGVsZW1lbnRzIHRvIG1hdGNoXG4gICAgICAgIGZvcm1FbGVtZW50czogJ2lucHV0LCBzZWxlY3QsIG9wdGlvbiwgdGV4dGFyZWEsIGJ1dHRvbiwgdmlkZW8nLFxuICAgICAgICAvLyBMYXN0IGNsaWNrIHRpbWVcbiAgICAgICAgbGFzdENsaWNrVGltZTogVXRpbHMubm93KCksXG4gICAgICAgIGNsaWNrVGltZW91dDogdW5kZWZpbmVkLFxuICAgICAgICAvLyBWZWxvY2l0aWVzXG4gICAgICAgIHZlbG9jaXRpZXM6IFtdLFxuICAgICAgICBhbGxvd01vbWVudHVtQm91bmNlOiB1bmRlZmluZWQsXG4gICAgICAgIGlzVG91Y2hFdmVudDogdW5kZWZpbmVkLFxuICAgICAgICBzdGFydE1vdmluZzogdW5kZWZpbmVkLFxuICAgICAgfSxcblxuICAgICAgLy8gQ2xpY2tzXG4gICAgICBhbGxvd0NsaWNrOiB0cnVlLFxuXG4gICAgICAvLyBUb3VjaGVzXG4gICAgICBhbGxvd1RvdWNoTW92ZTogc3dpcGVyLnBhcmFtcy5hbGxvd1RvdWNoTW92ZSxcblxuICAgICAgdG91Y2hlczoge1xuICAgICAgICBzdGFydFg6IDAsXG4gICAgICAgIHN0YXJ0WTogMCxcbiAgICAgICAgY3VycmVudFg6IDAsXG4gICAgICAgIGN1cnJlbnRZOiAwLFxuICAgICAgICBkaWZmOiAwLFxuICAgICAgfSxcblxuICAgICAgLy8gSW1hZ2VzXG4gICAgICBpbWFnZXNUb0xvYWQ6IFtdLFxuICAgICAgaW1hZ2VzTG9hZGVkOiAwLFxuXG4gICAgfSk7XG5cbiAgICAvLyBJbnN0YWxsIE1vZHVsZXNcbiAgICBzd2lwZXIudXNlTW9kdWxlcygpO1xuXG4gICAgLy8gSW5pdFxuICAgIGlmIChzd2lwZXIucGFyYW1zLmluaXQpIHtcbiAgICAgIHN3aXBlci5pbml0KCk7XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIGFwcCBpbnN0YW5jZVxuICAgIHJldHVybiBzd2lwZXI7XG4gIH1cbiAgc2xpZGVzUGVyVmlld0R5bmFtaWMoKSB7XG4gICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICBjb25zdCB7XG4gICAgICBwYXJhbXMsIHNsaWRlcywgc2xpZGVzR3JpZCwgc2l6ZTogc3dpcGVyU2l6ZSwgYWN0aXZlSW5kZXgsXG4gICAgfSA9IHN3aXBlcjtcbiAgICBsZXQgc3B2ID0gMTtcbiAgICBpZiAocGFyYW1zLmNlbnRlcmVkU2xpZGVzKSB7XG4gICAgICBsZXQgc2xpZGVTaXplID0gc2xpZGVzW2FjdGl2ZUluZGV4XS5zd2lwZXJTbGlkZVNpemU7XG4gICAgICBsZXQgYnJlYWtMb29wO1xuICAgICAgZm9yIChsZXQgaSA9IGFjdGl2ZUluZGV4ICsgMTsgaSA8IHNsaWRlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBpZiAoc2xpZGVzW2ldICYmICFicmVha0xvb3ApIHtcbiAgICAgICAgICBzbGlkZVNpemUgKz0gc2xpZGVzW2ldLnN3aXBlclNsaWRlU2l6ZTtcbiAgICAgICAgICBzcHYgKz0gMTtcbiAgICAgICAgICBpZiAoc2xpZGVTaXplID4gc3dpcGVyU2l6ZSkgYnJlYWtMb29wID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yIChsZXQgaSA9IGFjdGl2ZUluZGV4IC0gMTsgaSA+PSAwOyBpIC09IDEpIHtcbiAgICAgICAgaWYgKHNsaWRlc1tpXSAmJiAhYnJlYWtMb29wKSB7XG4gICAgICAgICAgc2xpZGVTaXplICs9IHNsaWRlc1tpXS5zd2lwZXJTbGlkZVNpemU7XG4gICAgICAgICAgc3B2ICs9IDE7XG4gICAgICAgICAgaWYgKHNsaWRlU2l6ZSA+IHN3aXBlclNpemUpIGJyZWFrTG9vcCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChsZXQgaSA9IGFjdGl2ZUluZGV4ICsgMTsgaSA8IHNsaWRlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBpZiAoc2xpZGVzR3JpZFtpXSAtIHNsaWRlc0dyaWRbYWN0aXZlSW5kZXhdIDwgc3dpcGVyU2l6ZSkge1xuICAgICAgICAgIHNwdiArPSAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzcHY7XG4gIH1cbiAgdXBkYXRlKCkge1xuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgaWYgKCFzd2lwZXIgfHwgc3dpcGVyLmRlc3Ryb3llZCkgcmV0dXJuO1xuICAgIGNvbnN0IHsgc25hcEdyaWQsIHBhcmFtcyB9ID0gc3dpcGVyO1xuICAgIC8vIEJyZWFrcG9pbnRzXG4gICAgaWYgKHBhcmFtcy5icmVha3BvaW50cykge1xuICAgICAgc3dpcGVyLnNldEJyZWFrcG9pbnQoKTtcbiAgICB9XG4gICAgc3dpcGVyLnVwZGF0ZVNpemUoKTtcbiAgICBzd2lwZXIudXBkYXRlU2xpZGVzKCk7XG4gICAgc3dpcGVyLnVwZGF0ZVByb2dyZXNzKCk7XG4gICAgc3dpcGVyLnVwZGF0ZVNsaWRlc0NsYXNzZXMoKTtcblxuICAgIGZ1bmN0aW9uIHNldFRyYW5zbGF0ZSgpIHtcbiAgICAgIGNvbnN0IHRyYW5zbGF0ZVZhbHVlID0gc3dpcGVyLnJ0bFRyYW5zbGF0ZSA/IHN3aXBlci50cmFuc2xhdGUgKiAtMSA6IHN3aXBlci50cmFuc2xhdGU7XG4gICAgICBjb25zdCBuZXdUcmFuc2xhdGUgPSBNYXRoLm1pbihNYXRoLm1heCh0cmFuc2xhdGVWYWx1ZSwgc3dpcGVyLm1heFRyYW5zbGF0ZSgpKSwgc3dpcGVyLm1pblRyYW5zbGF0ZSgpKTtcbiAgICAgIHN3aXBlci5zZXRUcmFuc2xhdGUobmV3VHJhbnNsYXRlKTtcbiAgICAgIHN3aXBlci51cGRhdGVBY3RpdmVJbmRleCgpO1xuICAgICAgc3dpcGVyLnVwZGF0ZVNsaWRlc0NsYXNzZXMoKTtcbiAgICB9XG4gICAgbGV0IHRyYW5zbGF0ZWQ7XG4gICAgaWYgKHN3aXBlci5wYXJhbXMuZnJlZU1vZGUpIHtcbiAgICAgIHNldFRyYW5zbGF0ZSgpO1xuICAgICAgaWYgKHN3aXBlci5wYXJhbXMuYXV0b0hlaWdodCkge1xuICAgICAgICBzd2lwZXIudXBkYXRlQXV0b0hlaWdodCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoKHN3aXBlci5wYXJhbXMuc2xpZGVzUGVyVmlldyA9PT0gJ2F1dG8nIHx8IHN3aXBlci5wYXJhbXMuc2xpZGVzUGVyVmlldyA+IDEpICYmIHN3aXBlci5pc0VuZCAmJiAhc3dpcGVyLnBhcmFtcy5jZW50ZXJlZFNsaWRlcykge1xuICAgICAgICB0cmFuc2xhdGVkID0gc3dpcGVyLnNsaWRlVG8oc3dpcGVyLnNsaWRlcy5sZW5ndGggLSAxLCAwLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cmFuc2xhdGVkID0gc3dpcGVyLnNsaWRlVG8oc3dpcGVyLmFjdGl2ZUluZGV4LCAwLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgICBpZiAoIXRyYW5zbGF0ZWQpIHtcbiAgICAgICAgc2V0VHJhbnNsYXRlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwYXJhbXMud2F0Y2hPdmVyZmxvdyAmJiBzbmFwR3JpZCAhPT0gc3dpcGVyLnNuYXBHcmlkKSB7XG4gICAgICBzd2lwZXIuY2hlY2tPdmVyZmxvdygpO1xuICAgIH1cbiAgICBzd2lwZXIuZW1pdCgndXBkYXRlJyk7XG4gIH1cbiAgaW5pdCgpIHtcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgIGlmIChzd2lwZXIuaW5pdGlhbGl6ZWQpIHJldHVybjtcblxuICAgIHN3aXBlci5lbWl0KCdiZWZvcmVJbml0Jyk7XG5cbiAgICAvLyBTZXQgYnJlYWtwb2ludFxuICAgIGlmIChzd2lwZXIucGFyYW1zLmJyZWFrcG9pbnRzKSB7XG4gICAgICBzd2lwZXIuc2V0QnJlYWtwb2ludCgpO1xuICAgIH1cblxuICAgIC8vIEFkZCBDbGFzc2VzXG4gICAgc3dpcGVyLmFkZENsYXNzZXMoKTtcblxuICAgIC8vIENyZWF0ZSBsb29wXG4gICAgaWYgKHN3aXBlci5wYXJhbXMubG9vcCkge1xuICAgICAgc3dpcGVyLmxvb3BDcmVhdGUoKTtcbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgc2l6ZVxuICAgIHN3aXBlci51cGRhdGVTaXplKCk7XG5cbiAgICAvLyBVcGRhdGUgc2xpZGVzXG4gICAgc3dpcGVyLnVwZGF0ZVNsaWRlcygpO1xuXG4gICAgaWYgKHN3aXBlci5wYXJhbXMud2F0Y2hPdmVyZmxvdykge1xuICAgICAgc3dpcGVyLmNoZWNrT3ZlcmZsb3coKTtcbiAgICB9XG5cbiAgICAvLyBTZXQgR3JhYiBDdXJzb3JcbiAgICBpZiAoc3dpcGVyLnBhcmFtcy5ncmFiQ3Vyc29yKSB7XG4gICAgICBzd2lwZXIuc2V0R3JhYkN1cnNvcigpO1xuICAgIH1cblxuICAgIGlmIChzd2lwZXIucGFyYW1zLnByZWxvYWRJbWFnZXMpIHtcbiAgICAgIHN3aXBlci5wcmVsb2FkSW1hZ2VzKCk7XG4gICAgfVxuXG4gICAgLy8gU2xpZGUgVG8gSW5pdGlhbCBTbGlkZVxuICAgIGlmIChzd2lwZXIucGFyYW1zLmxvb3ApIHtcbiAgICAgIHN3aXBlci5zbGlkZVRvKHN3aXBlci5wYXJhbXMuaW5pdGlhbFNsaWRlICsgc3dpcGVyLmxvb3BlZFNsaWRlcywgMCwgc3dpcGVyLnBhcmFtcy5ydW5DYWxsYmFja3NPbkluaXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzd2lwZXIuc2xpZGVUbyhzd2lwZXIucGFyYW1zLmluaXRpYWxTbGlkZSwgMCwgc3dpcGVyLnBhcmFtcy5ydW5DYWxsYmFja3NPbkluaXQpO1xuICAgIH1cblxuICAgIC8vIEF0dGFjaCBldmVudHNcbiAgICBzd2lwZXIuYXR0YWNoRXZlbnRzKCk7XG5cbiAgICAvLyBJbml0IEZsYWdcbiAgICBzd2lwZXIuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuXG4gICAgLy8gRW1pdFxuICAgIHN3aXBlci5lbWl0KCdpbml0Jyk7XG4gIH1cbiAgZGVzdHJveShkZWxldGVJbnN0YW5jZSA9IHRydWUsIGNsZWFuU3R5bGVzID0gdHJ1ZSkge1xuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgY29uc3Qge1xuICAgICAgcGFyYW1zLCAkZWwsICR3cmFwcGVyRWwsIHNsaWRlcyxcbiAgICB9ID0gc3dpcGVyO1xuXG4gICAgaWYgKHR5cGVvZiBzd2lwZXIucGFyYW1zID09PSAndW5kZWZpbmVkJyB8fCBzd2lwZXIuZGVzdHJveWVkKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBzd2lwZXIuZW1pdCgnYmVmb3JlRGVzdHJveScpO1xuXG4gICAgLy8gSW5pdCBGbGFnXG4gICAgc3dpcGVyLmluaXRpYWxpemVkID0gZmFsc2U7XG5cbiAgICAvLyBEZXRhY2ggZXZlbnRzXG4gICAgc3dpcGVyLmRldGFjaEV2ZW50cygpO1xuXG4gICAgLy8gRGVzdHJveSBsb29wXG4gICAgaWYgKHBhcmFtcy5sb29wKSB7XG4gICAgICBzd2lwZXIubG9vcERlc3Ryb3koKTtcbiAgICB9XG5cbiAgICAvLyBDbGVhbnVwIHN0eWxlc1xuICAgIGlmIChjbGVhblN0eWxlcykge1xuICAgICAgc3dpcGVyLnJlbW92ZUNsYXNzZXMoKTtcbiAgICAgICRlbC5yZW1vdmVBdHRyKCdzdHlsZScpO1xuICAgICAgJHdyYXBwZXJFbC5yZW1vdmVBdHRyKCdzdHlsZScpO1xuICAgICAgaWYgKHNsaWRlcyAmJiBzbGlkZXMubGVuZ3RoKSB7XG4gICAgICAgIHNsaWRlc1xuICAgICAgICAgIC5yZW1vdmVDbGFzcyhbXG4gICAgICAgICAgICBwYXJhbXMuc2xpZGVWaXNpYmxlQ2xhc3MsXG4gICAgICAgICAgICBwYXJhbXMuc2xpZGVBY3RpdmVDbGFzcyxcbiAgICAgICAgICAgIHBhcmFtcy5zbGlkZU5leHRDbGFzcyxcbiAgICAgICAgICAgIHBhcmFtcy5zbGlkZVByZXZDbGFzcyxcbiAgICAgICAgICBdLmpvaW4oJyAnKSlcbiAgICAgICAgICAucmVtb3ZlQXR0cignc3R5bGUnKVxuICAgICAgICAgIC5yZW1vdmVBdHRyKCdkYXRhLXN3aXBlci1zbGlkZS1pbmRleCcpXG4gICAgICAgICAgLnJlbW92ZUF0dHIoJ2RhdGEtc3dpcGVyLWNvbHVtbicpXG4gICAgICAgICAgLnJlbW92ZUF0dHIoJ2RhdGEtc3dpcGVyLXJvdycpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN3aXBlci5lbWl0KCdkZXN0cm95Jyk7XG5cbiAgICAvLyBEZXRhY2ggZW1pdHRlciBldmVudHNcbiAgICBPYmplY3Qua2V5cyhzd2lwZXIuZXZlbnRzTGlzdGVuZXJzKS5mb3JFYWNoKChldmVudE5hbWUpID0+IHtcbiAgICAgIHN3aXBlci5vZmYoZXZlbnROYW1lKTtcbiAgICB9KTtcblxuICAgIGlmIChkZWxldGVJbnN0YW5jZSAhPT0gZmFsc2UpIHtcbiAgICAgIHN3aXBlci4kZWxbMF0uc3dpcGVyID0gbnVsbDtcbiAgICAgIHN3aXBlci4kZWwuZGF0YSgnc3dpcGVyJywgbnVsbCk7XG4gICAgICBVdGlscy5kZWxldGVQcm9wcyhzd2lwZXIpO1xuICAgIH1cbiAgICBzd2lwZXIuZGVzdHJveWVkID0gdHJ1ZTtcblxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHN0YXRpYyBleHRlbmREZWZhdWx0cyhuZXdEZWZhdWx0cykge1xuICAgIFV0aWxzLmV4dGVuZChleHRlbmRlZERlZmF1bHRzLCBuZXdEZWZhdWx0cyk7XG4gIH1cbiAgc3RhdGljIGdldCBleHRlbmRlZERlZmF1bHRzKCkge1xuICAgIHJldHVybiBleHRlbmRlZERlZmF1bHRzO1xuICB9XG4gIHN0YXRpYyBnZXQgZGVmYXVsdHMoKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRzO1xuICB9XG4gIHN0YXRpYyBnZXQgQ2xhc3MoKSB7XG4gICAgcmV0dXJuIEZyYW1ld29yazdDbGFzcztcbiAgfVxuICBzdGF0aWMgZ2V0ICQoKSB7XG4gICAgcmV0dXJuICQ7XG4gIH1cbn1cblxudmFyIERldmljZSQxID0ge1xuICBuYW1lOiAnZGV2aWNlJyxcbiAgcHJvdG86IHtcbiAgICBkZXZpY2U6IERldmljZSxcbiAgfSxcbiAgc3RhdGljOiB7XG4gICAgZGV2aWNlOiBEZXZpY2UsXG4gIH0sXG59O1xuXG52YXIgU3VwcG9ydCQxID0ge1xuICBuYW1lOiAnc3VwcG9ydCcsXG4gIHByb3RvOiB7XG4gICAgc3VwcG9ydDogU3VwcG9ydCxcbiAgfSxcbiAgc3RhdGljOiB7XG4gICAgc3VwcG9ydDogU3VwcG9ydCxcbiAgfSxcbn07XG5cbnZhciBCcm93c2VyJDEgPSB7XG4gIG5hbWU6ICdicm93c2VyJyxcbiAgcHJvdG86IHtcbiAgICBicm93c2VyOiBCcm93c2VyLFxuICB9LFxuICBzdGF0aWM6IHtcbiAgICBicm93c2VyOiBCcm93c2VyLFxuICB9LFxufTtcblxudmFyIFJlc2l6ZSA9IHtcbiAgbmFtZTogJ3Jlc2l6ZScsXG4gIGNyZWF0ZSgpIHtcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgIFV0aWxzLmV4dGVuZChzd2lwZXIsIHtcbiAgICAgIHJlc2l6ZToge1xuICAgICAgICByZXNpemVIYW5kbGVyKCkge1xuICAgICAgICAgIGlmICghc3dpcGVyIHx8IHN3aXBlci5kZXN0cm95ZWQgfHwgIXN3aXBlci5pbml0aWFsaXplZCkgcmV0dXJuO1xuICAgICAgICAgIHN3aXBlci5lbWl0KCdiZWZvcmVSZXNpemUnKTtcbiAgICAgICAgICBzd2lwZXIuZW1pdCgncmVzaXplJyk7XG4gICAgICAgIH0sXG4gICAgICAgIG9yaWVudGF0aW9uQ2hhbmdlSGFuZGxlcigpIHtcbiAgICAgICAgICBpZiAoIXN3aXBlciB8fCBzd2lwZXIuZGVzdHJveWVkIHx8ICFzd2lwZXIuaW5pdGlhbGl6ZWQpIHJldHVybjtcbiAgICAgICAgICBzd2lwZXIuZW1pdCgnb3JpZW50YXRpb25jaGFuZ2UnKTtcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgfSk7XG4gIH0sXG4gIG9uOiB7XG4gICAgaW5pdCgpIHtcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgICAvLyBFbWl0IHJlc2l6ZVxuICAgICAgd2luZG93JDEuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgc3dpcGVyLnJlc2l6ZS5yZXNpemVIYW5kbGVyKTtcblxuICAgICAgLy8gRW1pdCBvcmllbnRhdGlvbmNoYW5nZVxuICAgICAgd2luZG93JDEuYWRkRXZlbnRMaXN0ZW5lcignb3JpZW50YXRpb25jaGFuZ2UnLCBzd2lwZXIucmVzaXplLm9yaWVudGF0aW9uQ2hhbmdlSGFuZGxlcik7XG4gICAgfSxcbiAgICBkZXN0cm95KCkge1xuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICAgIHdpbmRvdyQxLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHN3aXBlci5yZXNpemUucmVzaXplSGFuZGxlcik7XG4gICAgICB3aW5kb3ckMS5yZW1vdmVFdmVudExpc3RlbmVyKCdvcmllbnRhdGlvbmNoYW5nZScsIHN3aXBlci5yZXNpemUub3JpZW50YXRpb25DaGFuZ2VIYW5kbGVyKTtcbiAgICB9LFxuICB9LFxufTtcblxuY29uc3QgT2JzZXJ2ZXIgPSB7XG4gIGZ1bmM6IHdpbmRvdyQxLk11dGF0aW9uT2JzZXJ2ZXIgfHwgd2luZG93JDEuV2Via2l0TXV0YXRpb25PYnNlcnZlcixcbiAgYXR0YWNoKHRhcmdldCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3Qgc3dpcGVyID0gdGhpcztcblxuICAgIGNvbnN0IE9ic2VydmVyRnVuYyA9IE9ic2VydmVyLmZ1bmM7XG4gICAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgT2JzZXJ2ZXJGdW5jKChtdXRhdGlvbnMpID0+IHtcbiAgICAgIG11dGF0aW9ucy5mb3JFYWNoKChtdXRhdGlvbikgPT4ge1xuICAgICAgICBzd2lwZXIuZW1pdCgnb2JzZXJ2ZXJVcGRhdGUnLCBtdXRhdGlvbik7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIG9ic2VydmVyLm9ic2VydmUodGFyZ2V0LCB7XG4gICAgICBhdHRyaWJ1dGVzOiB0eXBlb2Ygb3B0aW9ucy5hdHRyaWJ1dGVzID09PSAndW5kZWZpbmVkJyA/IHRydWUgOiBvcHRpb25zLmF0dHJpYnV0ZXMsXG4gICAgICBjaGlsZExpc3Q6IHR5cGVvZiBvcHRpb25zLmNoaWxkTGlzdCA9PT0gJ3VuZGVmaW5lZCcgPyB0cnVlIDogb3B0aW9ucy5jaGlsZExpc3QsXG4gICAgICBjaGFyYWN0ZXJEYXRhOiB0eXBlb2Ygb3B0aW9ucy5jaGFyYWN0ZXJEYXRhID09PSAndW5kZWZpbmVkJyA/IHRydWUgOiBvcHRpb25zLmNoYXJhY3RlckRhdGEsXG4gICAgfSk7XG5cbiAgICBzd2lwZXIub2JzZXJ2ZXIub2JzZXJ2ZXJzLnB1c2gob2JzZXJ2ZXIpO1xuICB9LFxuICBpbml0KCkge1xuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgaWYgKCFTdXBwb3J0Lm9ic2VydmVyIHx8ICFzd2lwZXIucGFyYW1zLm9ic2VydmVyKSByZXR1cm47XG4gICAgaWYgKHN3aXBlci5wYXJhbXMub2JzZXJ2ZVBhcmVudHMpIHtcbiAgICAgIGNvbnN0IGNvbnRhaW5lclBhcmVudHMgPSBzd2lwZXIuJGVsLnBhcmVudHMoKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29udGFpbmVyUGFyZW50cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBzd2lwZXIub2JzZXJ2ZXIuYXR0YWNoKGNvbnRhaW5lclBhcmVudHNbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBPYnNlcnZlIGNvbnRhaW5lclxuICAgIHN3aXBlci5vYnNlcnZlci5hdHRhY2goc3dpcGVyLiRlbFswXSwgeyBjaGlsZExpc3Q6IGZhbHNlIH0pO1xuXG4gICAgLy8gT2JzZXJ2ZSB3cmFwcGVyXG4gICAgc3dpcGVyLm9ic2VydmVyLmF0dGFjaChzd2lwZXIuJHdyYXBwZXJFbFswXSwgeyBhdHRyaWJ1dGVzOiBmYWxzZSB9KTtcbiAgfSxcbiAgZGVzdHJveSgpIHtcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgIHN3aXBlci5vYnNlcnZlci5vYnNlcnZlcnMuZm9yRWFjaCgob2JzZXJ2ZXIpID0+IHtcbiAgICAgIG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICB9KTtcbiAgICBzd2lwZXIub2JzZXJ2ZXIub2JzZXJ2ZXJzID0gW107XG4gIH0sXG59O1xuXG52YXIgT2JzZXJ2ZXIkMSA9IHtcbiAgbmFtZTogJ29ic2VydmVyJyxcbiAgcGFyYW1zOiB7XG4gICAgb2JzZXJ2ZXI6IGZhbHNlLFxuICAgIG9ic2VydmVQYXJlbnRzOiBmYWxzZSxcbiAgfSxcbiAgY3JlYXRlKCkge1xuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgVXRpbHMuZXh0ZW5kKHN3aXBlciwge1xuICAgICAgb2JzZXJ2ZXI6IHtcbiAgICAgICAgaW5pdDogT2JzZXJ2ZXIuaW5pdC5iaW5kKHN3aXBlciksXG4gICAgICAgIGF0dGFjaDogT2JzZXJ2ZXIuYXR0YWNoLmJpbmQoc3dpcGVyKSxcbiAgICAgICAgZGVzdHJveTogT2JzZXJ2ZXIuZGVzdHJveS5iaW5kKHN3aXBlciksXG4gICAgICAgIG9ic2VydmVyczogW10sXG4gICAgICB9LFxuICAgIH0pO1xuICB9LFxuICBvbjoge1xuICAgIGluaXQoKSB7XG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgICAgc3dpcGVyLm9ic2VydmVyLmluaXQoKTtcbiAgICB9LFxuICAgIGRlc3Ryb3koKSB7XG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgICAgc3dpcGVyLm9ic2VydmVyLmRlc3Ryb3koKTtcbiAgICB9LFxuICB9LFxufTtcblxuY29uc3QgVmlydHVhbCA9IHtcbiAgdXBkYXRlKGZvcmNlKSB7XG4gICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICBjb25zdCB7IHNsaWRlc1BlclZpZXcsIHNsaWRlc1Blckdyb3VwLCBjZW50ZXJlZFNsaWRlcyB9ID0gc3dpcGVyLnBhcmFtcztcbiAgICBjb25zdCB7XG4gICAgICBmcm9tOiBwcmV2aW91c0Zyb20sXG4gICAgICB0bzogcHJldmlvdXNUbyxcbiAgICAgIHNsaWRlcyxcbiAgICAgIHNsaWRlc0dyaWQ6IHByZXZpb3VzU2xpZGVzR3JpZCxcbiAgICAgIHJlbmRlclNsaWRlLFxuICAgICAgb2Zmc2V0OiBwcmV2aW91c09mZnNldCxcbiAgICB9ID0gc3dpcGVyLnZpcnR1YWw7XG4gICAgc3dpcGVyLnVwZGF0ZUFjdGl2ZUluZGV4KCk7XG4gICAgY29uc3QgYWN0aXZlSW5kZXggPSBzd2lwZXIuYWN0aXZlSW5kZXggfHwgMDtcblxuICAgIGxldCBvZmZzZXRQcm9wO1xuICAgIGlmIChzd2lwZXIucnRsVHJhbnNsYXRlKSBvZmZzZXRQcm9wID0gJ3JpZ2h0JztcbiAgICBlbHNlIG9mZnNldFByb3AgPSBzd2lwZXIuaXNIb3Jpem9udGFsKCkgPyAnbGVmdCcgOiAndG9wJztcblxuICAgIGxldCBzbGlkZXNBZnRlcjtcbiAgICBsZXQgc2xpZGVzQmVmb3JlO1xuICAgIGlmIChjZW50ZXJlZFNsaWRlcykge1xuICAgICAgc2xpZGVzQWZ0ZXIgPSBNYXRoLmZsb29yKHNsaWRlc1BlclZpZXcgLyAyKSArIHNsaWRlc1Blckdyb3VwO1xuICAgICAgc2xpZGVzQmVmb3JlID0gTWF0aC5mbG9vcihzbGlkZXNQZXJWaWV3IC8gMikgKyBzbGlkZXNQZXJHcm91cDtcbiAgICB9IGVsc2Uge1xuICAgICAgc2xpZGVzQWZ0ZXIgPSBzbGlkZXNQZXJWaWV3ICsgKHNsaWRlc1Blckdyb3VwIC0gMSk7XG4gICAgICBzbGlkZXNCZWZvcmUgPSBzbGlkZXNQZXJHcm91cDtcbiAgICB9XG4gICAgY29uc3QgZnJvbSA9IE1hdGgubWF4KChhY3RpdmVJbmRleCB8fCAwKSAtIHNsaWRlc0JlZm9yZSwgMCk7XG4gICAgY29uc3QgdG8gPSBNYXRoLm1pbigoYWN0aXZlSW5kZXggfHwgMCkgKyBzbGlkZXNBZnRlciwgc2xpZGVzLmxlbmd0aCAtIDEpO1xuICAgIGNvbnN0IG9mZnNldCA9IChzd2lwZXIuc2xpZGVzR3JpZFtmcm9tXSB8fCAwKSAtIChzd2lwZXIuc2xpZGVzR3JpZFswXSB8fCAwKTtcblxuICAgIFV0aWxzLmV4dGVuZChzd2lwZXIudmlydHVhbCwge1xuICAgICAgZnJvbSxcbiAgICAgIHRvLFxuICAgICAgb2Zmc2V0LFxuICAgICAgc2xpZGVzR3JpZDogc3dpcGVyLnNsaWRlc0dyaWQsXG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBvblJlbmRlcmVkKCkge1xuICAgICAgc3dpcGVyLnVwZGF0ZVNsaWRlcygpO1xuICAgICAgc3dpcGVyLnVwZGF0ZVByb2dyZXNzKCk7XG4gICAgICBzd2lwZXIudXBkYXRlU2xpZGVzQ2xhc3NlcygpO1xuICAgICAgaWYgKHN3aXBlci5sYXp5ICYmIHN3aXBlci5wYXJhbXMubGF6eS5lbmFibGVkKSB7XG4gICAgICAgIHN3aXBlci5sYXp5LmxvYWQoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocHJldmlvdXNGcm9tID09PSBmcm9tICYmIHByZXZpb3VzVG8gPT09IHRvICYmICFmb3JjZSkge1xuICAgICAgaWYgKHN3aXBlci5zbGlkZXNHcmlkICE9PSBwcmV2aW91c1NsaWRlc0dyaWQgJiYgb2Zmc2V0ICE9PSBwcmV2aW91c09mZnNldCkge1xuICAgICAgICBzd2lwZXIuc2xpZGVzLmNzcyhvZmZzZXRQcm9wLCBgJHtvZmZzZXR9cHhgKTtcbiAgICAgIH1cbiAgICAgIHN3aXBlci51cGRhdGVQcm9ncmVzcygpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoc3dpcGVyLnBhcmFtcy52aXJ0dWFsLnJlbmRlckV4dGVybmFsKSB7XG4gICAgICBzd2lwZXIucGFyYW1zLnZpcnR1YWwucmVuZGVyRXh0ZXJuYWwuY2FsbChzd2lwZXIsIHtcbiAgICAgICAgb2Zmc2V0LFxuICAgICAgICBmcm9tLFxuICAgICAgICB0byxcbiAgICAgICAgc2xpZGVzOiAoZnVuY3Rpb24gZ2V0U2xpZGVzKCkge1xuICAgICAgICAgIGNvbnN0IHNsaWRlc1RvUmVuZGVyID0gW107XG4gICAgICAgICAgZm9yIChsZXQgaSA9IGZyb207IGkgPD0gdG87IGkgKz0gMSkge1xuICAgICAgICAgICAgc2xpZGVzVG9SZW5kZXIucHVzaChzbGlkZXNbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gc2xpZGVzVG9SZW5kZXI7XG4gICAgICAgIH0oKSksXG4gICAgICB9KTtcbiAgICAgIG9uUmVuZGVyZWQoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcHJlcGVuZEluZGV4ZXMgPSBbXTtcbiAgICBjb25zdCBhcHBlbmRJbmRleGVzID0gW107XG4gICAgaWYgKGZvcmNlKSB7XG4gICAgICBzd2lwZXIuJHdyYXBwZXJFbC5maW5kKGAuJHtzd2lwZXIucGFyYW1zLnNsaWRlQ2xhc3N9YCkucmVtb3ZlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAobGV0IGkgPSBwcmV2aW91c0Zyb207IGkgPD0gcHJldmlvdXNUbzsgaSArPSAxKSB7XG4gICAgICAgIGlmIChpIDwgZnJvbSB8fCBpID4gdG8pIHtcbiAgICAgICAgICBzd2lwZXIuJHdyYXBwZXJFbC5maW5kKGAuJHtzd2lwZXIucGFyYW1zLnNsaWRlQ2xhc3N9W2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4PVwiJHtpfVwiXWApLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2xpZGVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBpZiAoaSA+PSBmcm9tICYmIGkgPD0gdG8pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwcmV2aW91c1RvID09PSAndW5kZWZpbmVkJyB8fCBmb3JjZSkge1xuICAgICAgICAgIGFwcGVuZEluZGV4ZXMucHVzaChpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoaSA+IHByZXZpb3VzVG8pIGFwcGVuZEluZGV4ZXMucHVzaChpKTtcbiAgICAgICAgICBpZiAoaSA8IHByZXZpb3VzRnJvbSkgcHJlcGVuZEluZGV4ZXMucHVzaChpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBhcHBlbmRJbmRleGVzLmZvckVhY2goKGluZGV4KSA9PiB7XG4gICAgICBzd2lwZXIuJHdyYXBwZXJFbC5hcHBlbmQocmVuZGVyU2xpZGUoc2xpZGVzW2luZGV4XSwgaW5kZXgpKTtcbiAgICB9KTtcbiAgICBwcmVwZW5kSW5kZXhlcy5zb3J0KChhLCBiKSA9PiBhIDwgYikuZm9yRWFjaCgoaW5kZXgpID0+IHtcbiAgICAgIHN3aXBlci4kd3JhcHBlckVsLnByZXBlbmQocmVuZGVyU2xpZGUoc2xpZGVzW2luZGV4XSwgaW5kZXgpKTtcbiAgICB9KTtcbiAgICBzd2lwZXIuJHdyYXBwZXJFbC5jaGlsZHJlbignLnN3aXBlci1zbGlkZScpLmNzcyhvZmZzZXRQcm9wLCBgJHtvZmZzZXR9cHhgKTtcbiAgICBvblJlbmRlcmVkKCk7XG4gIH0sXG4gIHJlbmRlclNsaWRlKHNsaWRlLCBpbmRleCkge1xuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgY29uc3QgcGFyYW1zID0gc3dpcGVyLnBhcmFtcy52aXJ0dWFsO1xuICAgIGlmIChwYXJhbXMuY2FjaGUgJiYgc3dpcGVyLnZpcnR1YWwuY2FjaGVbaW5kZXhdKSB7XG4gICAgICByZXR1cm4gc3dpcGVyLnZpcnR1YWwuY2FjaGVbaW5kZXhdO1xuICAgIH1cbiAgICBjb25zdCAkc2xpZGVFbCA9IHBhcmFtcy5yZW5kZXJTbGlkZVxuICAgICAgPyAkKHBhcmFtcy5yZW5kZXJTbGlkZS5jYWxsKHN3aXBlciwgc2xpZGUsIGluZGV4KSlcbiAgICAgIDogJChgPGRpdiBjbGFzcz1cIiR7c3dpcGVyLnBhcmFtcy5zbGlkZUNsYXNzfVwiIGRhdGEtc3dpcGVyLXNsaWRlLWluZGV4PVwiJHtpbmRleH1cIj4ke3NsaWRlfTwvZGl2PmApO1xuICAgIGlmICghJHNsaWRlRWwuYXR0cignZGF0YS1zd2lwZXItc2xpZGUtaW5kZXgnKSkgJHNsaWRlRWwuYXR0cignZGF0YS1zd2lwZXItc2xpZGUtaW5kZXgnLCBpbmRleCk7XG4gICAgaWYgKHBhcmFtcy5jYWNoZSkgc3dpcGVyLnZpcnR1YWwuY2FjaGVbaW5kZXhdID0gJHNsaWRlRWw7XG4gICAgcmV0dXJuICRzbGlkZUVsO1xuICB9LFxuICBhcHBlbmRTbGlkZShzbGlkZSkge1xuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgc3dpcGVyLnZpcnR1YWwuc2xpZGVzLnB1c2goc2xpZGUpO1xuICAgIHN3aXBlci52aXJ0dWFsLnVwZGF0ZSh0cnVlKTtcbiAgfSxcbiAgcHJlcGVuZFNsaWRlKHNsaWRlKSB7XG4gICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICBzd2lwZXIudmlydHVhbC5zbGlkZXMudW5zaGlmdChzbGlkZSk7XG4gICAgaWYgKHN3aXBlci5wYXJhbXMudmlydHVhbC5jYWNoZSkge1xuICAgICAgY29uc3QgY2FjaGUgPSBzd2lwZXIudmlydHVhbC5jYWNoZTtcbiAgICAgIGNvbnN0IG5ld0NhY2hlID0ge307XG4gICAgICBPYmplY3Qua2V5cyhjYWNoZSkuZm9yRWFjaCgoY2FjaGVkSW5kZXgpID0+IHtcbiAgICAgICAgbmV3Q2FjaGVbY2FjaGVkSW5kZXggKyAxXSA9IGNhY2hlW2NhY2hlZEluZGV4XTtcbiAgICAgIH0pO1xuICAgICAgc3dpcGVyLnZpcnR1YWwuY2FjaGUgPSBuZXdDYWNoZTtcbiAgICB9XG4gICAgc3dpcGVyLnZpcnR1YWwudXBkYXRlKHRydWUpO1xuICAgIHN3aXBlci5zbGlkZU5leHQoMCk7XG4gIH0sXG59O1xuXG52YXIgVmlydHVhbCQxID0ge1xuICBuYW1lOiAndmlydHVhbCcsXG4gIHBhcmFtczoge1xuICAgIHZpcnR1YWw6IHtcbiAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgc2xpZGVzOiBbXSxcbiAgICAgIGNhY2hlOiB0cnVlLFxuICAgICAgcmVuZGVyU2xpZGU6IG51bGwsXG4gICAgICByZW5kZXJFeHRlcm5hbDogbnVsbCxcbiAgICB9LFxuICB9LFxuICBjcmVhdGUoKSB7XG4gICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICBVdGlscy5leHRlbmQoc3dpcGVyLCB7XG4gICAgICB2aXJ0dWFsOiB7XG4gICAgICAgIHVwZGF0ZTogVmlydHVhbC51cGRhdGUuYmluZChzd2lwZXIpLFxuICAgICAgICBhcHBlbmRTbGlkZTogVmlydHVhbC5hcHBlbmRTbGlkZS5iaW5kKHN3aXBlciksXG4gICAgICAgIHByZXBlbmRTbGlkZTogVmlydHVhbC5wcmVwZW5kU2xpZGUuYmluZChzd2lwZXIpLFxuICAgICAgICByZW5kZXJTbGlkZTogVmlydHVhbC5yZW5kZXJTbGlkZS5iaW5kKHN3aXBlciksXG4gICAgICAgIHNsaWRlczogc3dpcGVyLnBhcmFtcy52aXJ0dWFsLnNsaWRlcyxcbiAgICAgICAgY2FjaGU6IHt9LFxuICAgICAgfSxcbiAgICB9KTtcbiAgfSxcbiAgb246IHtcbiAgICBiZWZvcmVJbml0KCkge1xuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICAgIGlmICghc3dpcGVyLnBhcmFtcy52aXJ0dWFsLmVuYWJsZWQpIHJldHVybjtcbiAgICAgIHN3aXBlci5jbGFzc05hbWVzLnB1c2goYCR7c3dpcGVyLnBhcmFtcy5jb250YWluZXJNb2RpZmllckNsYXNzfXZpcnR1YWxgKTtcbiAgICAgIGNvbnN0IG92ZXJ3cml0ZVBhcmFtcyA9IHtcbiAgICAgICAgd2F0Y2hTbGlkZXNQcm9ncmVzczogdHJ1ZSxcbiAgICAgIH07XG4gICAgICBVdGlscy5leHRlbmQoc3dpcGVyLnBhcmFtcywgb3ZlcndyaXRlUGFyYW1zKTtcbiAgICAgIFV0aWxzLmV4dGVuZChzd2lwZXIub3JpZ2luYWxQYXJhbXMsIG92ZXJ3cml0ZVBhcmFtcyk7XG5cbiAgICAgIHN3aXBlci52aXJ0dWFsLnVwZGF0ZSgpO1xuICAgIH0sXG4gICAgc2V0VHJhbnNsYXRlKCkge1xuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICAgIGlmICghc3dpcGVyLnBhcmFtcy52aXJ0dWFsLmVuYWJsZWQpIHJldHVybjtcbiAgICAgIHN3aXBlci52aXJ0dWFsLnVwZGF0ZSgpO1xuICAgIH0sXG4gIH0sXG59O1xuXG5jb25zdCBOYXZpZ2F0aW9uID0ge1xuICB1cGRhdGUoKSB7XG4gICAgLy8gVXBkYXRlIE5hdmlnYXRpb24gQnV0dG9uc1xuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgY29uc3QgcGFyYW1zID0gc3dpcGVyLnBhcmFtcy5uYXZpZ2F0aW9uO1xuXG4gICAgaWYgKHN3aXBlci5wYXJhbXMubG9vcCkgcmV0dXJuO1xuICAgIGNvbnN0IHsgJG5leHRFbCwgJHByZXZFbCB9ID0gc3dpcGVyLm5hdmlnYXRpb247XG5cbiAgICBpZiAoJHByZXZFbCAmJiAkcHJldkVsLmxlbmd0aCA+IDApIHtcbiAgICAgIGlmIChzd2lwZXIuaXNCZWdpbm5pbmcpIHtcbiAgICAgICAgJHByZXZFbC5hZGRDbGFzcyhwYXJhbXMuZGlzYWJsZWRDbGFzcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAkcHJldkVsLnJlbW92ZUNsYXNzKHBhcmFtcy5kaXNhYmxlZENsYXNzKTtcbiAgICAgIH1cbiAgICAgICRwcmV2RWxbc3dpcGVyLnBhcmFtcy53YXRjaE92ZXJmbG93ICYmIHN3aXBlci5pc0xvY2tlZCA/ICdhZGRDbGFzcycgOiAncmVtb3ZlQ2xhc3MnXShwYXJhbXMubG9ja0NsYXNzKTtcbiAgICB9XG4gICAgaWYgKCRuZXh0RWwgJiYgJG5leHRFbC5sZW5ndGggPiAwKSB7XG4gICAgICBpZiAoc3dpcGVyLmlzRW5kKSB7XG4gICAgICAgICRuZXh0RWwuYWRkQ2xhc3MocGFyYW1zLmRpc2FibGVkQ2xhc3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJG5leHRFbC5yZW1vdmVDbGFzcyhwYXJhbXMuZGlzYWJsZWRDbGFzcyk7XG4gICAgICB9XG4gICAgICAkbmV4dEVsW3N3aXBlci5wYXJhbXMud2F0Y2hPdmVyZmxvdyAmJiBzd2lwZXIuaXNMb2NrZWQgPyAnYWRkQ2xhc3MnIDogJ3JlbW92ZUNsYXNzJ10ocGFyYW1zLmxvY2tDbGFzcyk7XG4gICAgfVxuICB9LFxuICBpbml0KCkge1xuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgY29uc3QgcGFyYW1zID0gc3dpcGVyLnBhcmFtcy5uYXZpZ2F0aW9uO1xuICAgIGlmICghKHBhcmFtcy5uZXh0RWwgfHwgcGFyYW1zLnByZXZFbCkpIHJldHVybjtcblxuICAgIGxldCAkbmV4dEVsO1xuICAgIGxldCAkcHJldkVsO1xuICAgIGlmIChwYXJhbXMubmV4dEVsKSB7XG4gICAgICAkbmV4dEVsID0gJChwYXJhbXMubmV4dEVsKTtcbiAgICAgIGlmIChcbiAgICAgICAgc3dpcGVyLnBhcmFtcy51bmlxdWVOYXZFbGVtZW50cyAmJlxuICAgICAgICB0eXBlb2YgcGFyYW1zLm5leHRFbCA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgJG5leHRFbC5sZW5ndGggPiAxICYmXG4gICAgICAgIHN3aXBlci4kZWwuZmluZChwYXJhbXMubmV4dEVsKS5sZW5ndGggPT09IDFcbiAgICAgICkge1xuICAgICAgICAkbmV4dEVsID0gc3dpcGVyLiRlbC5maW5kKHBhcmFtcy5uZXh0RWwpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocGFyYW1zLnByZXZFbCkge1xuICAgICAgJHByZXZFbCA9ICQocGFyYW1zLnByZXZFbCk7XG4gICAgICBpZiAoXG4gICAgICAgIHN3aXBlci5wYXJhbXMudW5pcXVlTmF2RWxlbWVudHMgJiZcbiAgICAgICAgdHlwZW9mIHBhcmFtcy5wcmV2RWwgPT09ICdzdHJpbmcnICYmXG4gICAgICAgICRwcmV2RWwubGVuZ3RoID4gMSAmJlxuICAgICAgICBzd2lwZXIuJGVsLmZpbmQocGFyYW1zLnByZXZFbCkubGVuZ3RoID09PSAxXG4gICAgICApIHtcbiAgICAgICAgJHByZXZFbCA9IHN3aXBlci4kZWwuZmluZChwYXJhbXMucHJldkVsKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoJG5leHRFbCAmJiAkbmV4dEVsLmxlbmd0aCA+IDApIHtcbiAgICAgICRuZXh0RWwub24oJ2NsaWNrJywgKGUpID0+IHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBpZiAoc3dpcGVyLmlzRW5kICYmICFzd2lwZXIucGFyYW1zLmxvb3ApIHJldHVybjtcbiAgICAgICAgc3dpcGVyLnNsaWRlTmV4dCgpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICgkcHJldkVsICYmICRwcmV2RWwubGVuZ3RoID4gMCkge1xuICAgICAgJHByZXZFbC5vbignY2xpY2snLCAoZSkgPT4ge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGlmIChzd2lwZXIuaXNCZWdpbm5pbmcgJiYgIXN3aXBlci5wYXJhbXMubG9vcCkgcmV0dXJuO1xuICAgICAgICBzd2lwZXIuc2xpZGVQcmV2KCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBVdGlscy5leHRlbmQoc3dpcGVyLm5hdmlnYXRpb24sIHtcbiAgICAgICRuZXh0RWwsXG4gICAgICBuZXh0RWw6ICRuZXh0RWwgJiYgJG5leHRFbFswXSxcbiAgICAgICRwcmV2RWwsXG4gICAgICBwcmV2RWw6ICRwcmV2RWwgJiYgJHByZXZFbFswXSxcbiAgICB9KTtcbiAgfSxcbiAgZGVzdHJveSgpIHtcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgIGNvbnN0IHsgJG5leHRFbCwgJHByZXZFbCB9ID0gc3dpcGVyLm5hdmlnYXRpb247XG4gICAgaWYgKCRuZXh0RWwgJiYgJG5leHRFbC5sZW5ndGgpIHtcbiAgICAgICRuZXh0RWwub2ZmKCdjbGljaycpO1xuICAgICAgJG5leHRFbC5yZW1vdmVDbGFzcyhzd2lwZXIucGFyYW1zLm5hdmlnYXRpb24uZGlzYWJsZWRDbGFzcyk7XG4gICAgfVxuICAgIGlmICgkcHJldkVsICYmICRwcmV2RWwubGVuZ3RoKSB7XG4gICAgICAkcHJldkVsLm9mZignY2xpY2snKTtcbiAgICAgICRwcmV2RWwucmVtb3ZlQ2xhc3Moc3dpcGVyLnBhcmFtcy5uYXZpZ2F0aW9uLmRpc2FibGVkQ2xhc3MpO1xuICAgIH1cbiAgfSxcbn07XG5cbnZhciBOYXZpZ2F0aW9uJDEgPSB7XG4gIG5hbWU6ICduYXZpZ2F0aW9uJyxcbiAgcGFyYW1zOiB7XG4gICAgbmF2aWdhdGlvbjoge1xuICAgICAgbmV4dEVsOiBudWxsLFxuICAgICAgcHJldkVsOiBudWxsLFxuXG4gICAgICBoaWRlT25DbGljazogZmFsc2UsXG4gICAgICBkaXNhYmxlZENsYXNzOiAnc3dpcGVyLWJ1dHRvbi1kaXNhYmxlZCcsXG4gICAgICBoaWRkZW5DbGFzczogJ3N3aXBlci1idXR0b24taGlkZGVuJyxcbiAgICAgIGxvY2tDbGFzczogJ3N3aXBlci1idXR0b24tbG9jaycsXG4gICAgfSxcbiAgfSxcbiAgY3JlYXRlKCkge1xuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgVXRpbHMuZXh0ZW5kKHN3aXBlciwge1xuICAgICAgbmF2aWdhdGlvbjoge1xuICAgICAgICBpbml0OiBOYXZpZ2F0aW9uLmluaXQuYmluZChzd2lwZXIpLFxuICAgICAgICB1cGRhdGU6IE5hdmlnYXRpb24udXBkYXRlLmJpbmQoc3dpcGVyKSxcbiAgICAgICAgZGVzdHJveTogTmF2aWdhdGlvbi5kZXN0cm95LmJpbmQoc3dpcGVyKSxcbiAgICAgIH0sXG4gICAgfSk7XG4gIH0sXG4gIG9uOiB7XG4gICAgaW5pdCgpIHtcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgICBzd2lwZXIubmF2aWdhdGlvbi5pbml0KCk7XG4gICAgICBzd2lwZXIubmF2aWdhdGlvbi51cGRhdGUoKTtcbiAgICB9LFxuICAgIHRvRWRnZSgpIHtcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgICBzd2lwZXIubmF2aWdhdGlvbi51cGRhdGUoKTtcbiAgICB9LFxuICAgIGZyb21FZGdlKCkge1xuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICAgIHN3aXBlci5uYXZpZ2F0aW9uLnVwZGF0ZSgpO1xuICAgIH0sXG4gICAgZGVzdHJveSgpIHtcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgICBzd2lwZXIubmF2aWdhdGlvbi5kZXN0cm95KCk7XG4gICAgfSxcbiAgICBjbGljayhlKSB7XG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgICAgY29uc3QgeyAkbmV4dEVsLCAkcHJldkVsIH0gPSBzd2lwZXIubmF2aWdhdGlvbjtcbiAgICAgIGlmIChcbiAgICAgICAgc3dpcGVyLnBhcmFtcy5uYXZpZ2F0aW9uLmhpZGVPbkNsaWNrICYmXG4gICAgICAgICEkKGUudGFyZ2V0KS5pcygkcHJldkVsKSAmJlxuICAgICAgICAhJChlLnRhcmdldCkuaXMoJG5leHRFbClcbiAgICAgICkge1xuICAgICAgICBpZiAoJG5leHRFbCkgJG5leHRFbC50b2dnbGVDbGFzcyhzd2lwZXIucGFyYW1zLm5hdmlnYXRpb24uaGlkZGVuQ2xhc3MpO1xuICAgICAgICBpZiAoJHByZXZFbCkgJHByZXZFbC50b2dnbGVDbGFzcyhzd2lwZXIucGFyYW1zLm5hdmlnYXRpb24uaGlkZGVuQ2xhc3MpO1xuICAgICAgfVxuICAgIH0sXG4gIH0sXG59O1xuXG5jb25zdCBQYWdpbmF0aW9uID0ge1xuICB1cGRhdGUoKSB7XG4gICAgLy8gUmVuZGVyIHx8IFVwZGF0ZSBQYWdpbmF0aW9uIGJ1bGxldHMvaXRlbXNcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgIGNvbnN0IHJ0bCA9IHN3aXBlci5ydGw7XG4gICAgY29uc3QgcGFyYW1zID0gc3dpcGVyLnBhcmFtcy5wYWdpbmF0aW9uO1xuICAgIGlmICghcGFyYW1zLmVsIHx8ICFzd2lwZXIucGFnaW5hdGlvbi5lbCB8fCAhc3dpcGVyLnBhZ2luYXRpb24uJGVsIHx8IHN3aXBlci5wYWdpbmF0aW9uLiRlbC5sZW5ndGggPT09IDApIHJldHVybjtcbiAgICBjb25zdCBzbGlkZXNMZW5ndGggPSBzd2lwZXIudmlydHVhbCAmJiBzd2lwZXIucGFyYW1zLnZpcnR1YWwuZW5hYmxlZCA/IHN3aXBlci52aXJ0dWFsLnNsaWRlcy5sZW5ndGggOiBzd2lwZXIuc2xpZGVzLmxlbmd0aDtcbiAgICBjb25zdCAkZWwgPSBzd2lwZXIucGFnaW5hdGlvbi4kZWw7XG4gICAgLy8gQ3VycmVudC9Ub3RhbFxuICAgIGxldCBjdXJyZW50O1xuICAgIGNvbnN0IHRvdGFsID0gc3dpcGVyLnBhcmFtcy5sb29wID8gTWF0aC5jZWlsKChzbGlkZXNMZW5ndGggLSAoc3dpcGVyLmxvb3BlZFNsaWRlcyAqIDIpKSAvIHN3aXBlci5wYXJhbXMuc2xpZGVzUGVyR3JvdXApIDogc3dpcGVyLnNuYXBHcmlkLmxlbmd0aDtcbiAgICBpZiAoc3dpcGVyLnBhcmFtcy5sb29wKSB7XG4gICAgICBjdXJyZW50ID0gTWF0aC5jZWlsKChzd2lwZXIuYWN0aXZlSW5kZXggLSBzd2lwZXIubG9vcGVkU2xpZGVzKSAvIHN3aXBlci5wYXJhbXMuc2xpZGVzUGVyR3JvdXApO1xuICAgICAgaWYgKGN1cnJlbnQgPiBzbGlkZXNMZW5ndGggLSAxIC0gKHN3aXBlci5sb29wZWRTbGlkZXMgKiAyKSkge1xuICAgICAgICBjdXJyZW50IC09IChzbGlkZXNMZW5ndGggLSAoc3dpcGVyLmxvb3BlZFNsaWRlcyAqIDIpKTtcbiAgICAgIH1cbiAgICAgIGlmIChjdXJyZW50ID4gdG90YWwgLSAxKSBjdXJyZW50IC09IHRvdGFsO1xuICAgICAgaWYgKGN1cnJlbnQgPCAwICYmIHN3aXBlci5wYXJhbXMucGFnaW5hdGlvblR5cGUgIT09ICdidWxsZXRzJykgY3VycmVudCA9IHRvdGFsICsgY3VycmVudDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBzd2lwZXIuc25hcEluZGV4ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY3VycmVudCA9IHN3aXBlci5zbmFwSW5kZXg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnQgPSBzd2lwZXIuYWN0aXZlSW5kZXggfHwgMDtcbiAgICB9XG4gICAgLy8gVHlwZXNcbiAgICBpZiAocGFyYW1zLnR5cGUgPT09ICdidWxsZXRzJyAmJiBzd2lwZXIucGFnaW5hdGlvbi5idWxsZXRzICYmIHN3aXBlci5wYWdpbmF0aW9uLmJ1bGxldHMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgYnVsbGV0cyA9IHN3aXBlci5wYWdpbmF0aW9uLmJ1bGxldHM7XG4gICAgICBsZXQgZmlyc3RJbmRleDtcbiAgICAgIGxldCBsYXN0SW5kZXg7XG4gICAgICBsZXQgbWlkSW5kZXg7XG4gICAgICBpZiAocGFyYW1zLmR5bmFtaWNCdWxsZXRzKSB7XG4gICAgICAgIHN3aXBlci5wYWdpbmF0aW9uLmJ1bGxldFNpemUgPSBidWxsZXRzLmVxKDApW3N3aXBlci5pc0hvcml6b250YWwoKSA/ICdvdXRlcldpZHRoJyA6ICdvdXRlckhlaWdodCddKHRydWUpO1xuICAgICAgICAkZWwuY3NzKHN3aXBlci5pc0hvcml6b250YWwoKSA/ICd3aWR0aCcgOiAnaGVpZ2h0JywgYCR7c3dpcGVyLnBhZ2luYXRpb24uYnVsbGV0U2l6ZSAqIChwYXJhbXMuZHluYW1pY01haW5CdWxsZXRzICsgNCl9cHhgKTtcbiAgICAgICAgaWYgKHBhcmFtcy5keW5hbWljTWFpbkJ1bGxldHMgPiAxICYmIHN3aXBlci5wcmV2aW91c0luZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBzd2lwZXIucGFnaW5hdGlvbi5keW5hbWljQnVsbGV0SW5kZXggKz0gKGN1cnJlbnQgLSBzd2lwZXIucHJldmlvdXNJbmRleCk7XG4gICAgICAgICAgaWYgKHN3aXBlci5wYWdpbmF0aW9uLmR5bmFtaWNCdWxsZXRJbmRleCA+IChwYXJhbXMuZHluYW1pY01haW5CdWxsZXRzIC0gMSkpIHtcbiAgICAgICAgICAgIHN3aXBlci5wYWdpbmF0aW9uLmR5bmFtaWNCdWxsZXRJbmRleCA9IHBhcmFtcy5keW5hbWljTWFpbkJ1bGxldHMgLSAxO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc3dpcGVyLnBhZ2luYXRpb24uZHluYW1pY0J1bGxldEluZGV4IDwgMCkge1xuICAgICAgICAgICAgc3dpcGVyLnBhZ2luYXRpb24uZHluYW1pY0J1bGxldEluZGV4ID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZmlyc3RJbmRleCA9IGN1cnJlbnQgLSBzd2lwZXIucGFnaW5hdGlvbi5keW5hbWljQnVsbGV0SW5kZXg7XG4gICAgICAgIGxhc3RJbmRleCA9IGZpcnN0SW5kZXggKyAoTWF0aC5taW4oYnVsbGV0cy5sZW5ndGgsIHBhcmFtcy5keW5hbWljTWFpbkJ1bGxldHMpIC0gMSk7XG4gICAgICAgIG1pZEluZGV4ID0gKGxhc3RJbmRleCArIGZpcnN0SW5kZXgpIC8gMjtcbiAgICAgIH1cbiAgICAgIGJ1bGxldHMucmVtb3ZlQ2xhc3MoYCR7cGFyYW1zLmJ1bGxldEFjdGl2ZUNsYXNzfSAke3BhcmFtcy5idWxsZXRBY3RpdmVDbGFzc30tbmV4dCAke3BhcmFtcy5idWxsZXRBY3RpdmVDbGFzc30tbmV4dC1uZXh0ICR7cGFyYW1zLmJ1bGxldEFjdGl2ZUNsYXNzfS1wcmV2ICR7cGFyYW1zLmJ1bGxldEFjdGl2ZUNsYXNzfS1wcmV2LXByZXYgJHtwYXJhbXMuYnVsbGV0QWN0aXZlQ2xhc3N9LW1haW5gKTtcbiAgICAgIGlmICgkZWwubGVuZ3RoID4gMSkge1xuICAgICAgICBidWxsZXRzLmVhY2goKGluZGV4LCBidWxsZXQpID0+IHtcbiAgICAgICAgICBjb25zdCAkYnVsbGV0ID0gJChidWxsZXQpO1xuICAgICAgICAgIGNvbnN0IGJ1bGxldEluZGV4ID0gJGJ1bGxldC5pbmRleCgpO1xuICAgICAgICAgIGlmIChidWxsZXRJbmRleCA9PT0gY3VycmVudCkge1xuICAgICAgICAgICAgJGJ1bGxldC5hZGRDbGFzcyhwYXJhbXMuYnVsbGV0QWN0aXZlQ2xhc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocGFyYW1zLmR5bmFtaWNCdWxsZXRzKSB7XG4gICAgICAgICAgICBpZiAoYnVsbGV0SW5kZXggPj0gZmlyc3RJbmRleCAmJiBidWxsZXRJbmRleCA8PSBsYXN0SW5kZXgpIHtcbiAgICAgICAgICAgICAgJGJ1bGxldC5hZGRDbGFzcyhgJHtwYXJhbXMuYnVsbGV0QWN0aXZlQ2xhc3N9LW1haW5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChidWxsZXRJbmRleCA9PT0gZmlyc3RJbmRleCkge1xuICAgICAgICAgICAgICAkYnVsbGV0XG4gICAgICAgICAgICAgICAgLnByZXYoKVxuICAgICAgICAgICAgICAgIC5hZGRDbGFzcyhgJHtwYXJhbXMuYnVsbGV0QWN0aXZlQ2xhc3N9LXByZXZgKVxuICAgICAgICAgICAgICAgIC5wcmV2KClcbiAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoYCR7cGFyYW1zLmJ1bGxldEFjdGl2ZUNsYXNzfS1wcmV2LXByZXZgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChidWxsZXRJbmRleCA9PT0gbGFzdEluZGV4KSB7XG4gICAgICAgICAgICAgICRidWxsZXRcbiAgICAgICAgICAgICAgICAubmV4dCgpXG4gICAgICAgICAgICAgICAgLmFkZENsYXNzKGAke3BhcmFtcy5idWxsZXRBY3RpdmVDbGFzc30tbmV4dGApXG4gICAgICAgICAgICAgICAgLm5leHQoKVxuICAgICAgICAgICAgICAgIC5hZGRDbGFzcyhgJHtwYXJhbXMuYnVsbGV0QWN0aXZlQ2xhc3N9LW5leHQtbmV4dGApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCAkYnVsbGV0ID0gYnVsbGV0cy5lcShjdXJyZW50KTtcbiAgICAgICAgJGJ1bGxldC5hZGRDbGFzcyhwYXJhbXMuYnVsbGV0QWN0aXZlQ2xhc3MpO1xuICAgICAgICBpZiAocGFyYW1zLmR5bmFtaWNCdWxsZXRzKSB7XG4gICAgICAgICAgY29uc3QgJGZpcnN0RGlzcGxheWVkQnVsbGV0ID0gYnVsbGV0cy5lcShmaXJzdEluZGV4KTtcbiAgICAgICAgICBjb25zdCAkbGFzdERpc3BsYXllZEJ1bGxldCA9IGJ1bGxldHMuZXEobGFzdEluZGV4KTtcbiAgICAgICAgICBmb3IgKGxldCBpID0gZmlyc3RJbmRleDsgaSA8PSBsYXN0SW5kZXg7IGkgKz0gMSkge1xuICAgICAgICAgICAgYnVsbGV0cy5lcShpKS5hZGRDbGFzcyhgJHtwYXJhbXMuYnVsbGV0QWN0aXZlQ2xhc3N9LW1haW5gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgJGZpcnN0RGlzcGxheWVkQnVsbGV0XG4gICAgICAgICAgICAucHJldigpXG4gICAgICAgICAgICAuYWRkQ2xhc3MoYCR7cGFyYW1zLmJ1bGxldEFjdGl2ZUNsYXNzfS1wcmV2YClcbiAgICAgICAgICAgIC5wcmV2KClcbiAgICAgICAgICAgIC5hZGRDbGFzcyhgJHtwYXJhbXMuYnVsbGV0QWN0aXZlQ2xhc3N9LXByZXYtcHJldmApO1xuICAgICAgICAgICRsYXN0RGlzcGxheWVkQnVsbGV0XG4gICAgICAgICAgICAubmV4dCgpXG4gICAgICAgICAgICAuYWRkQ2xhc3MoYCR7cGFyYW1zLmJ1bGxldEFjdGl2ZUNsYXNzfS1uZXh0YClcbiAgICAgICAgICAgIC5uZXh0KClcbiAgICAgICAgICAgIC5hZGRDbGFzcyhgJHtwYXJhbXMuYnVsbGV0QWN0aXZlQ2xhc3N9LW5leHQtbmV4dGApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocGFyYW1zLmR5bmFtaWNCdWxsZXRzKSB7XG4gICAgICAgIGNvbnN0IGR5bmFtaWNCdWxsZXRzTGVuZ3RoID0gTWF0aC5taW4oYnVsbGV0cy5sZW5ndGgsIHBhcmFtcy5keW5hbWljTWFpbkJ1bGxldHMgKyA0KTtcbiAgICAgICAgY29uc3QgYnVsbGV0c09mZnNldCA9ICgoKHN3aXBlci5wYWdpbmF0aW9uLmJ1bGxldFNpemUgKiBkeW5hbWljQnVsbGV0c0xlbmd0aCkgLSAoc3dpcGVyLnBhZ2luYXRpb24uYnVsbGV0U2l6ZSkpIC8gMikgLSAobWlkSW5kZXggKiBzd2lwZXIucGFnaW5hdGlvbi5idWxsZXRTaXplKTtcbiAgICAgICAgY29uc3Qgb2Zmc2V0UHJvcCA9IHJ0bCA/ICdyaWdodCcgOiAnbGVmdCc7XG4gICAgICAgIGJ1bGxldHMuY3NzKHN3aXBlci5pc0hvcml6b250YWwoKSA/IG9mZnNldFByb3AgOiAndG9wJywgYCR7YnVsbGV0c09mZnNldH1weGApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocGFyYW1zLnR5cGUgPT09ICdmcmFjdGlvbicpIHtcbiAgICAgICRlbC5maW5kKGAuJHtwYXJhbXMuY3VycmVudENsYXNzfWApLnRleHQoY3VycmVudCArIDEpO1xuICAgICAgJGVsLmZpbmQoYC4ke3BhcmFtcy50b3RhbENsYXNzfWApLnRleHQodG90YWwpO1xuICAgIH1cbiAgICBpZiAocGFyYW1zLnR5cGUgPT09ICdwcm9ncmVzc2JhcicpIHtcbiAgICAgIGxldCBwcm9ncmVzc2JhckRpcmVjdGlvbjtcbiAgICAgIGlmIChwYXJhbXMucHJvZ3Jlc3NiYXJPcHBvc2l0ZSkge1xuICAgICAgICBwcm9ncmVzc2JhckRpcmVjdGlvbiA9IHN3aXBlci5pc0hvcml6b250YWwoKSA/ICd2ZXJ0aWNhbCcgOiAnaG9yaXpvbnRhbCc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9ncmVzc2JhckRpcmVjdGlvbiA9IHN3aXBlci5pc0hvcml6b250YWwoKSA/ICdob3Jpem9udGFsJyA6ICd2ZXJ0aWNhbCc7XG4gICAgICB9XG4gICAgICBjb25zdCBzY2FsZSA9IChjdXJyZW50ICsgMSkgLyB0b3RhbDtcbiAgICAgIGxldCBzY2FsZVggPSAxO1xuICAgICAgbGV0IHNjYWxlWSA9IDE7XG4gICAgICBpZiAocHJvZ3Jlc3NiYXJEaXJlY3Rpb24gPT09ICdob3Jpem9udGFsJykge1xuICAgICAgICBzY2FsZVggPSBzY2FsZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNjYWxlWSA9IHNjYWxlO1xuICAgICAgfVxuICAgICAgJGVsLmZpbmQoYC4ke3BhcmFtcy5wcm9ncmVzc2JhckZpbGxDbGFzc31gKS50cmFuc2Zvcm0oYHRyYW5zbGF0ZTNkKDAsMCwwKSBzY2FsZVgoJHtzY2FsZVh9KSBzY2FsZVkoJHtzY2FsZVl9KWApLnRyYW5zaXRpb24oc3dpcGVyLnBhcmFtcy5zcGVlZCk7XG4gICAgfVxuICAgIGlmIChwYXJhbXMudHlwZSA9PT0gJ2N1c3RvbScgJiYgcGFyYW1zLnJlbmRlckN1c3RvbSkge1xuICAgICAgJGVsLmh0bWwocGFyYW1zLnJlbmRlckN1c3RvbShzd2lwZXIsIGN1cnJlbnQgKyAxLCB0b3RhbCkpO1xuICAgICAgc3dpcGVyLmVtaXQoJ3BhZ2luYXRpb25SZW5kZXInLCBzd2lwZXIsICRlbFswXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN3aXBlci5lbWl0KCdwYWdpbmF0aW9uVXBkYXRlJywgc3dpcGVyLCAkZWxbMF0pO1xuICAgIH1cbiAgICAkZWxbc3dpcGVyLnBhcmFtcy53YXRjaE92ZXJmbG93ICYmIHN3aXBlci5pc0xvY2tlZCA/ICdhZGRDbGFzcycgOiAncmVtb3ZlQ2xhc3MnXShwYXJhbXMubG9ja0NsYXNzKTtcbiAgfSxcbiAgcmVuZGVyKCkge1xuICAgIC8vIFJlbmRlciBDb250YWluZXJcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgIGNvbnN0IHBhcmFtcyA9IHN3aXBlci5wYXJhbXMucGFnaW5hdGlvbjtcbiAgICBpZiAoIXBhcmFtcy5lbCB8fCAhc3dpcGVyLnBhZ2luYXRpb24uZWwgfHwgIXN3aXBlci5wYWdpbmF0aW9uLiRlbCB8fCBzd2lwZXIucGFnaW5hdGlvbi4kZWwubGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgY29uc3Qgc2xpZGVzTGVuZ3RoID0gc3dpcGVyLnZpcnR1YWwgJiYgc3dpcGVyLnBhcmFtcy52aXJ0dWFsLmVuYWJsZWQgPyBzd2lwZXIudmlydHVhbC5zbGlkZXMubGVuZ3RoIDogc3dpcGVyLnNsaWRlcy5sZW5ndGg7XG5cbiAgICBjb25zdCAkZWwgPSBzd2lwZXIucGFnaW5hdGlvbi4kZWw7XG4gICAgbGV0IHBhZ2luYXRpb25IVE1MID0gJyc7XG4gICAgaWYgKHBhcmFtcy50eXBlID09PSAnYnVsbGV0cycpIHtcbiAgICAgIGNvbnN0IG51bWJlck9mQnVsbGV0cyA9IHN3aXBlci5wYXJhbXMubG9vcCA/IE1hdGguY2VpbCgoc2xpZGVzTGVuZ3RoIC0gKHN3aXBlci5sb29wZWRTbGlkZXMgKiAyKSkgLyBzd2lwZXIucGFyYW1zLnNsaWRlc1Blckdyb3VwKSA6IHN3aXBlci5zbmFwR3JpZC5sZW5ndGg7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bWJlck9mQnVsbGV0czsgaSArPSAxKSB7XG4gICAgICAgIGlmIChwYXJhbXMucmVuZGVyQnVsbGV0KSB7XG4gICAgICAgICAgcGFnaW5hdGlvbkhUTUwgKz0gcGFyYW1zLnJlbmRlckJ1bGxldC5jYWxsKHN3aXBlciwgaSwgcGFyYW1zLmJ1bGxldENsYXNzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYWdpbmF0aW9uSFRNTCArPSBgPCR7cGFyYW1zLmJ1bGxldEVsZW1lbnR9IGNsYXNzPVwiJHtwYXJhbXMuYnVsbGV0Q2xhc3N9XCI+PC8ke3BhcmFtcy5idWxsZXRFbGVtZW50fT5gO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAkZWwuaHRtbChwYWdpbmF0aW9uSFRNTCk7XG4gICAgICBzd2lwZXIucGFnaW5hdGlvbi5idWxsZXRzID0gJGVsLmZpbmQoYC4ke3BhcmFtcy5idWxsZXRDbGFzc31gKTtcbiAgICB9XG4gICAgaWYgKHBhcmFtcy50eXBlID09PSAnZnJhY3Rpb24nKSB7XG4gICAgICBpZiAocGFyYW1zLnJlbmRlckZyYWN0aW9uKSB7XG4gICAgICAgIHBhZ2luYXRpb25IVE1MID0gcGFyYW1zLnJlbmRlckZyYWN0aW9uLmNhbGwoc3dpcGVyLCBwYXJhbXMuY3VycmVudENsYXNzLCBwYXJhbXMudG90YWxDbGFzcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYWdpbmF0aW9uSFRNTCA9XG4gICAgICAgIGA8c3BhbiBjbGFzcz1cIiR7cGFyYW1zLmN1cnJlbnRDbGFzc31cIj48L3NwYW4+YCArXG4gICAgICAgICcgLyAnICtcbiAgICAgICAgYDxzcGFuIGNsYXNzPVwiJHtwYXJhbXMudG90YWxDbGFzc31cIj48L3NwYW4+YDtcbiAgICAgIH1cbiAgICAgICRlbC5odG1sKHBhZ2luYXRpb25IVE1MKTtcbiAgICB9XG4gICAgaWYgKHBhcmFtcy50eXBlID09PSAncHJvZ3Jlc3NiYXInKSB7XG4gICAgICBpZiAocGFyYW1zLnJlbmRlclByb2dyZXNzYmFyKSB7XG4gICAgICAgIHBhZ2luYXRpb25IVE1MID0gcGFyYW1zLnJlbmRlclByb2dyZXNzYmFyLmNhbGwoc3dpcGVyLCBwYXJhbXMucHJvZ3Jlc3NiYXJGaWxsQ2xhc3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFnaW5hdGlvbkhUTUwgPSBgPHNwYW4gY2xhc3M9XCIke3BhcmFtcy5wcm9ncmVzc2JhckZpbGxDbGFzc31cIj48L3NwYW4+YDtcbiAgICAgIH1cbiAgICAgICRlbC5odG1sKHBhZ2luYXRpb25IVE1MKTtcbiAgICB9XG4gICAgaWYgKHBhcmFtcy50eXBlICE9PSAnY3VzdG9tJykge1xuICAgICAgc3dpcGVyLmVtaXQoJ3BhZ2luYXRpb25SZW5kZXInLCBzd2lwZXIucGFnaW5hdGlvbi4kZWxbMF0pO1xuICAgIH1cbiAgfSxcbiAgaW5pdCgpIHtcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgIGNvbnN0IHBhcmFtcyA9IHN3aXBlci5wYXJhbXMucGFnaW5hdGlvbjtcbiAgICBpZiAoIXBhcmFtcy5lbCkgcmV0dXJuO1xuXG4gICAgbGV0ICRlbCA9ICQocGFyYW1zLmVsKTtcbiAgICBpZiAoJGVsLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuXG4gICAgaWYgKFxuICAgICAgc3dpcGVyLnBhcmFtcy51bmlxdWVOYXZFbGVtZW50cyAmJlxuICAgICAgdHlwZW9mIHBhcmFtcy5lbCA9PT0gJ3N0cmluZycgJiZcbiAgICAgICRlbC5sZW5ndGggPiAxICYmXG4gICAgICBzd2lwZXIuJGVsLmZpbmQocGFyYW1zLmVsKS5sZW5ndGggPT09IDFcbiAgICApIHtcbiAgICAgICRlbCA9IHN3aXBlci4kZWwuZmluZChwYXJhbXMuZWwpO1xuICAgIH1cblxuICAgIGlmIChwYXJhbXMudHlwZSA9PT0gJ2J1bGxldHMnICYmIHBhcmFtcy5jbGlja2FibGUpIHtcbiAgICAgICRlbC5hZGRDbGFzcyhwYXJhbXMuY2xpY2thYmxlQ2xhc3MpO1xuICAgIH1cblxuICAgICRlbC5hZGRDbGFzcyhwYXJhbXMubW9kaWZpZXJDbGFzcyArIHBhcmFtcy50eXBlKTtcblxuICAgIGlmIChwYXJhbXMudHlwZSA9PT0gJ2J1bGxldHMnICYmIHBhcmFtcy5keW5hbWljQnVsbGV0cykge1xuICAgICAgJGVsLmFkZENsYXNzKGAke3BhcmFtcy5tb2RpZmllckNsYXNzfSR7cGFyYW1zLnR5cGV9LWR5bmFtaWNgKTtcbiAgICAgIHN3aXBlci5wYWdpbmF0aW9uLmR5bmFtaWNCdWxsZXRJbmRleCA9IDA7XG4gICAgICBpZiAocGFyYW1zLmR5bmFtaWNNYWluQnVsbGV0cyA8IDEpIHtcbiAgICAgICAgcGFyYW1zLmR5bmFtaWNNYWluQnVsbGV0cyA9IDE7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwYXJhbXMudHlwZSA9PT0gJ3Byb2dyZXNzYmFyJyAmJiBwYXJhbXMucHJvZ3Jlc3NiYXJPcHBvc2l0ZSkge1xuICAgICAgJGVsLmFkZENsYXNzKHBhcmFtcy5wcm9ncmVzc2Jhck9wcG9zaXRlQ2xhc3MpO1xuICAgIH1cblxuICAgIGlmIChwYXJhbXMuY2xpY2thYmxlKSB7XG4gICAgICAkZWwub24oJ2NsaWNrJywgYC4ke3BhcmFtcy5idWxsZXRDbGFzc31gLCBmdW5jdGlvbiBvbkNsaWNrKGUpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBsZXQgaW5kZXggPSAkKHRoaXMpLmluZGV4KCkgKiBzd2lwZXIucGFyYW1zLnNsaWRlc1Blckdyb3VwO1xuICAgICAgICBpZiAoc3dpcGVyLnBhcmFtcy5sb29wKSBpbmRleCArPSBzd2lwZXIubG9vcGVkU2xpZGVzO1xuICAgICAgICBzd2lwZXIuc2xpZGVUbyhpbmRleCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBVdGlscy5leHRlbmQoc3dpcGVyLnBhZ2luYXRpb24sIHtcbiAgICAgICRlbCxcbiAgICAgIGVsOiAkZWxbMF0sXG4gICAgfSk7XG4gIH0sXG4gIGRlc3Ryb3koKSB7XG4gICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICBjb25zdCBwYXJhbXMgPSBzd2lwZXIucGFyYW1zLnBhZ2luYXRpb247XG4gICAgaWYgKCFwYXJhbXMuZWwgfHwgIXN3aXBlci5wYWdpbmF0aW9uLmVsIHx8ICFzd2lwZXIucGFnaW5hdGlvbi4kZWwgfHwgc3dpcGVyLnBhZ2luYXRpb24uJGVsLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgIGNvbnN0ICRlbCA9IHN3aXBlci5wYWdpbmF0aW9uLiRlbDtcblxuICAgICRlbC5yZW1vdmVDbGFzcyhwYXJhbXMuaGlkZGVuQ2xhc3MpO1xuICAgICRlbC5yZW1vdmVDbGFzcyhwYXJhbXMubW9kaWZpZXJDbGFzcyArIHBhcmFtcy50eXBlKTtcbiAgICBpZiAoc3dpcGVyLnBhZ2luYXRpb24uYnVsbGV0cykgc3dpcGVyLnBhZ2luYXRpb24uYnVsbGV0cy5yZW1vdmVDbGFzcyhwYXJhbXMuYnVsbGV0QWN0aXZlQ2xhc3MpO1xuICAgIGlmIChwYXJhbXMuY2xpY2thYmxlKSB7XG4gICAgICAkZWwub2ZmKCdjbGljaycsIGAuJHtwYXJhbXMuYnVsbGV0Q2xhc3N9YCk7XG4gICAgfVxuICB9LFxufTtcblxudmFyIFBhZ2luYXRpb24kMSA9IHtcbiAgbmFtZTogJ3BhZ2luYXRpb24nLFxuICBwYXJhbXM6IHtcbiAgICBwYWdpbmF0aW9uOiB7XG4gICAgICBlbDogbnVsbCxcbiAgICAgIGJ1bGxldEVsZW1lbnQ6ICdzcGFuJyxcbiAgICAgIGNsaWNrYWJsZTogZmFsc2UsXG4gICAgICBoaWRlT25DbGljazogZmFsc2UsXG4gICAgICByZW5kZXJCdWxsZXQ6IG51bGwsXG4gICAgICByZW5kZXJQcm9ncmVzc2JhcjogbnVsbCxcbiAgICAgIHJlbmRlckZyYWN0aW9uOiBudWxsLFxuICAgICAgcmVuZGVyQ3VzdG9tOiBudWxsLFxuICAgICAgcHJvZ3Jlc3NiYXJPcHBvc2l0ZTogZmFsc2UsXG4gICAgICB0eXBlOiAnYnVsbGV0cycsIC8vICdidWxsZXRzJyBvciAncHJvZ3Jlc3NiYXInIG9yICdmcmFjdGlvbicgb3IgJ2N1c3RvbSdcbiAgICAgIGR5bmFtaWNCdWxsZXRzOiBmYWxzZSxcbiAgICAgIGR5bmFtaWNNYWluQnVsbGV0czogMSxcbiAgICAgIGJ1bGxldENsYXNzOiAnc3dpcGVyLXBhZ2luYXRpb24tYnVsbGV0JyxcbiAgICAgIGJ1bGxldEFjdGl2ZUNsYXNzOiAnc3dpcGVyLXBhZ2luYXRpb24tYnVsbGV0LWFjdGl2ZScsXG4gICAgICBtb2RpZmllckNsYXNzOiAnc3dpcGVyLXBhZ2luYXRpb24tJywgLy8gTkVXXG4gICAgICBjdXJyZW50Q2xhc3M6ICdzd2lwZXItcGFnaW5hdGlvbi1jdXJyZW50JyxcbiAgICAgIHRvdGFsQ2xhc3M6ICdzd2lwZXItcGFnaW5hdGlvbi10b3RhbCcsXG4gICAgICBoaWRkZW5DbGFzczogJ3N3aXBlci1wYWdpbmF0aW9uLWhpZGRlbicsXG4gICAgICBwcm9ncmVzc2JhckZpbGxDbGFzczogJ3N3aXBlci1wYWdpbmF0aW9uLXByb2dyZXNzYmFyLWZpbGwnLFxuICAgICAgcHJvZ3Jlc3NiYXJPcHBvc2l0ZUNsYXNzOiAnc3dpcGVyLXBhZ2luYXRpb24tcHJvZ3Jlc3NiYXItb3Bwb3NpdGUnLFxuICAgICAgY2xpY2thYmxlQ2xhc3M6ICdzd2lwZXItcGFnaW5hdGlvbi1jbGlja2FibGUnLCAvLyBORVdcbiAgICAgIGxvY2tDbGFzczogJ3N3aXBlci1wYWdpbmF0aW9uLWxvY2snLFxuICAgIH0sXG4gIH0sXG4gIGNyZWF0ZSgpIHtcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgIFV0aWxzLmV4dGVuZChzd2lwZXIsIHtcbiAgICAgIHBhZ2luYXRpb246IHtcbiAgICAgICAgaW5pdDogUGFnaW5hdGlvbi5pbml0LmJpbmQoc3dpcGVyKSxcbiAgICAgICAgcmVuZGVyOiBQYWdpbmF0aW9uLnJlbmRlci5iaW5kKHN3aXBlciksXG4gICAgICAgIHVwZGF0ZTogUGFnaW5hdGlvbi51cGRhdGUuYmluZChzd2lwZXIpLFxuICAgICAgICBkZXN0cm95OiBQYWdpbmF0aW9uLmRlc3Ryb3kuYmluZChzd2lwZXIpLFxuICAgICAgICBkeW5hbWljQnVsbGV0SW5kZXg6IDAsXG4gICAgICB9LFxuICAgIH0pO1xuICB9LFxuICBvbjoge1xuICAgIGluaXQoKSB7XG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgICAgc3dpcGVyLnBhZ2luYXRpb24uaW5pdCgpO1xuICAgICAgc3dpcGVyLnBhZ2luYXRpb24ucmVuZGVyKCk7XG4gICAgICBzd2lwZXIucGFnaW5hdGlvbi51cGRhdGUoKTtcbiAgICB9LFxuICAgIGFjdGl2ZUluZGV4Q2hhbmdlKCkge1xuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICAgIGlmIChzd2lwZXIucGFyYW1zLmxvb3ApIHtcbiAgICAgICAgc3dpcGVyLnBhZ2luYXRpb24udXBkYXRlKCk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBzd2lwZXIuc25hcEluZGV4ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBzd2lwZXIucGFnaW5hdGlvbi51cGRhdGUoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHNuYXBJbmRleENoYW5nZSgpIHtcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgICBpZiAoIXN3aXBlci5wYXJhbXMubG9vcCkge1xuICAgICAgICBzd2lwZXIucGFnaW5hdGlvbi51cGRhdGUoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHNsaWRlc0xlbmd0aENoYW5nZSgpIHtcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgICBpZiAoc3dpcGVyLnBhcmFtcy5sb29wKSB7XG4gICAgICAgIHN3aXBlci5wYWdpbmF0aW9uLnJlbmRlcigpO1xuICAgICAgICBzd2lwZXIucGFnaW5hdGlvbi51cGRhdGUoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHNuYXBHcmlkTGVuZ3RoQ2hhbmdlKCkge1xuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICAgIGlmICghc3dpcGVyLnBhcmFtcy5sb29wKSB7XG4gICAgICAgIHN3aXBlci5wYWdpbmF0aW9uLnJlbmRlcigpO1xuICAgICAgICBzd2lwZXIucGFnaW5hdGlvbi51cGRhdGUoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGRlc3Ryb3koKSB7XG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgICAgc3dpcGVyLnBhZ2luYXRpb24uZGVzdHJveSgpO1xuICAgIH0sXG4gICAgY2xpY2soZSkge1xuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICAgIGlmIChcbiAgICAgICAgc3dpcGVyLnBhcmFtcy5wYWdpbmF0aW9uLmVsICYmXG4gICAgICAgIHN3aXBlci5wYXJhbXMucGFnaW5hdGlvbi5oaWRlT25DbGljayAmJlxuICAgICAgICBzd2lwZXIucGFnaW5hdGlvbi4kZWwubGVuZ3RoID4gMCAmJlxuICAgICAgICAhJChlLnRhcmdldCkuaGFzQ2xhc3Moc3dpcGVyLnBhcmFtcy5wYWdpbmF0aW9uLmJ1bGxldENsYXNzKVxuICAgICAgKSB7XG4gICAgICAgIHN3aXBlci5wYWdpbmF0aW9uLiRlbC50b2dnbGVDbGFzcyhzd2lwZXIucGFyYW1zLnBhZ2luYXRpb24uaGlkZGVuQ2xhc3MpO1xuICAgICAgfVxuICAgIH0sXG4gIH0sXG59O1xuXG5jb25zdCBTY3JvbGxiYXIgPSB7XG4gIHNldFRyYW5zbGF0ZSgpIHtcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgIGlmICghc3dpcGVyLnBhcmFtcy5zY3JvbGxiYXIuZWwgfHwgIXN3aXBlci5zY3JvbGxiYXIuZWwpIHJldHVybjtcbiAgICBjb25zdCB7IHNjcm9sbGJhciwgcnRsVHJhbnNsYXRlOiBydGwsIHByb2dyZXNzIH0gPSBzd2lwZXI7XG4gICAgY29uc3Qge1xuICAgICAgZHJhZ1NpemUsIHRyYWNrU2l6ZSwgJGRyYWdFbCwgJGVsLFxuICAgIH0gPSBzY3JvbGxiYXI7XG4gICAgY29uc3QgcGFyYW1zID0gc3dpcGVyLnBhcmFtcy5zY3JvbGxiYXI7XG5cbiAgICBsZXQgbmV3U2l6ZSA9IGRyYWdTaXplO1xuICAgIGxldCBuZXdQb3MgPSAodHJhY2tTaXplIC0gZHJhZ1NpemUpICogcHJvZ3Jlc3M7XG4gICAgaWYgKHJ0bCkge1xuICAgICAgbmV3UG9zID0gLW5ld1BvcztcbiAgICAgIGlmIChuZXdQb3MgPiAwKSB7XG4gICAgICAgIG5ld1NpemUgPSBkcmFnU2l6ZSAtIG5ld1BvcztcbiAgICAgICAgbmV3UG9zID0gMDtcbiAgICAgIH0gZWxzZSBpZiAoLW5ld1BvcyArIGRyYWdTaXplID4gdHJhY2tTaXplKSB7XG4gICAgICAgIG5ld1NpemUgPSB0cmFja1NpemUgKyBuZXdQb3M7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChuZXdQb3MgPCAwKSB7XG4gICAgICBuZXdTaXplID0gZHJhZ1NpemUgKyBuZXdQb3M7XG4gICAgICBuZXdQb3MgPSAwO1xuICAgIH0gZWxzZSBpZiAobmV3UG9zICsgZHJhZ1NpemUgPiB0cmFja1NpemUpIHtcbiAgICAgIG5ld1NpemUgPSB0cmFja1NpemUgLSBuZXdQb3M7XG4gICAgfVxuICAgIGlmIChzd2lwZXIuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgIGlmIChTdXBwb3J0LnRyYW5zZm9ybXMzZCkge1xuICAgICAgICAkZHJhZ0VsLnRyYW5zZm9ybShgdHJhbnNsYXRlM2QoJHtuZXdQb3N9cHgsIDAsIDApYCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAkZHJhZ0VsLnRyYW5zZm9ybShgdHJhbnNsYXRlWCgke25ld1Bvc31weClgKTtcbiAgICAgIH1cbiAgICAgICRkcmFnRWxbMF0uc3R5bGUud2lkdGggPSBgJHtuZXdTaXplfXB4YDtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKFN1cHBvcnQudHJhbnNmb3JtczNkKSB7XG4gICAgICAgICRkcmFnRWwudHJhbnNmb3JtKGB0cmFuc2xhdGUzZCgwcHgsICR7bmV3UG9zfXB4LCAwKWApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJGRyYWdFbC50cmFuc2Zvcm0oYHRyYW5zbGF0ZVkoJHtuZXdQb3N9cHgpYCk7XG4gICAgICB9XG4gICAgICAkZHJhZ0VsWzBdLnN0eWxlLmhlaWdodCA9IGAke25ld1NpemV9cHhgO1xuICAgIH1cbiAgICBpZiAocGFyYW1zLmhpZGUpIHtcbiAgICAgIGNsZWFyVGltZW91dChzd2lwZXIuc2Nyb2xsYmFyLnRpbWVvdXQpO1xuICAgICAgJGVsWzBdLnN0eWxlLm9wYWNpdHkgPSAxO1xuICAgICAgc3dpcGVyLnNjcm9sbGJhci50aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICRlbFswXS5zdHlsZS5vcGFjaXR5ID0gMDtcbiAgICAgICAgJGVsLnRyYW5zaXRpb24oNDAwKTtcbiAgICAgIH0sIDEwMDApO1xuICAgIH1cbiAgfSxcbiAgc2V0VHJhbnNpdGlvbihkdXJhdGlvbikge1xuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgaWYgKCFzd2lwZXIucGFyYW1zLnNjcm9sbGJhci5lbCB8fCAhc3dpcGVyLnNjcm9sbGJhci5lbCkgcmV0dXJuO1xuICAgIHN3aXBlci5zY3JvbGxiYXIuJGRyYWdFbC50cmFuc2l0aW9uKGR1cmF0aW9uKTtcbiAgfSxcbiAgdXBkYXRlU2l6ZSgpIHtcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgIGlmICghc3dpcGVyLnBhcmFtcy5zY3JvbGxiYXIuZWwgfHwgIXN3aXBlci5zY3JvbGxiYXIuZWwpIHJldHVybjtcblxuICAgIGNvbnN0IHsgc2Nyb2xsYmFyIH0gPSBzd2lwZXI7XG4gICAgY29uc3QgeyAkZHJhZ0VsLCAkZWwgfSA9IHNjcm9sbGJhcjtcblxuICAgICRkcmFnRWxbMF0uc3R5bGUud2lkdGggPSAnJztcbiAgICAkZHJhZ0VsWzBdLnN0eWxlLmhlaWdodCA9ICcnO1xuICAgIGNvbnN0IHRyYWNrU2l6ZSA9IHN3aXBlci5pc0hvcml6b250YWwoKSA/ICRlbFswXS5vZmZzZXRXaWR0aCA6ICRlbFswXS5vZmZzZXRIZWlnaHQ7XG5cbiAgICBjb25zdCBkaXZpZGVyID0gc3dpcGVyLnNpemUgLyBzd2lwZXIudmlydHVhbFNpemU7XG4gICAgY29uc3QgbW92ZURpdmlkZXIgPSBkaXZpZGVyICogKHRyYWNrU2l6ZSAvIHN3aXBlci5zaXplKTtcbiAgICBsZXQgZHJhZ1NpemU7XG4gICAgaWYgKHN3aXBlci5wYXJhbXMuc2Nyb2xsYmFyLmRyYWdTaXplID09PSAnYXV0bycpIHtcbiAgICAgIGRyYWdTaXplID0gdHJhY2tTaXplICogZGl2aWRlcjtcbiAgICB9IGVsc2Uge1xuICAgICAgZHJhZ1NpemUgPSBwYXJzZUludChzd2lwZXIucGFyYW1zLnNjcm9sbGJhci5kcmFnU2l6ZSwgMTApO1xuICAgIH1cblxuICAgIGlmIChzd2lwZXIuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgICRkcmFnRWxbMF0uc3R5bGUud2lkdGggPSBgJHtkcmFnU2l6ZX1weGA7XG4gICAgfSBlbHNlIHtcbiAgICAgICRkcmFnRWxbMF0uc3R5bGUuaGVpZ2h0ID0gYCR7ZHJhZ1NpemV9cHhgO1xuICAgIH1cblxuICAgIGlmIChkaXZpZGVyID49IDEpIHtcbiAgICAgICRlbFswXS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIH0gZWxzZSB7XG4gICAgICAkZWxbMF0uc3R5bGUuZGlzcGxheSA9ICcnO1xuICAgIH1cbiAgICBpZiAoc3dpcGVyLnBhcmFtcy5zY3JvbGxiYXJIaWRlKSB7XG4gICAgICAkZWxbMF0uc3R5bGUub3BhY2l0eSA9IDA7XG4gICAgfVxuICAgIFV0aWxzLmV4dGVuZChzY3JvbGxiYXIsIHtcbiAgICAgIHRyYWNrU2l6ZSxcbiAgICAgIGRpdmlkZXIsXG4gICAgICBtb3ZlRGl2aWRlcixcbiAgICAgIGRyYWdTaXplLFxuICAgIH0pO1xuICAgIHNjcm9sbGJhci4kZWxbc3dpcGVyLnBhcmFtcy53YXRjaE92ZXJmbG93ICYmIHN3aXBlci5pc0xvY2tlZCA/ICdhZGRDbGFzcycgOiAncmVtb3ZlQ2xhc3MnXShzd2lwZXIucGFyYW1zLnNjcm9sbGJhci5sb2NrQ2xhc3MpO1xuICB9LFxuICBzZXREcmFnUG9zaXRpb24oZSkge1xuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgY29uc3QgeyBzY3JvbGxiYXIsIHJ0bFRyYW5zbGF0ZTogcnRsIH0gPSBzd2lwZXI7XG4gICAgY29uc3QgeyAkZWwsIGRyYWdTaXplLCB0cmFja1NpemUgfSA9IHNjcm9sbGJhcjtcblxuICAgIGxldCBwb2ludGVyUG9zaXRpb247XG4gICAgaWYgKHN3aXBlci5pc0hvcml6b250YWwoKSkge1xuICAgICAgcG9pbnRlclBvc2l0aW9uID0gKChlLnR5cGUgPT09ICd0b3VjaHN0YXJ0JyB8fCBlLnR5cGUgPT09ICd0b3VjaG1vdmUnKSA/IGUudGFyZ2V0VG91Y2hlc1swXS5wYWdlWCA6IGUucGFnZVggfHwgZS5jbGllbnRYKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcG9pbnRlclBvc2l0aW9uID0gKChlLnR5cGUgPT09ICd0b3VjaHN0YXJ0JyB8fCBlLnR5cGUgPT09ICd0b3VjaG1vdmUnKSA/IGUudGFyZ2V0VG91Y2hlc1swXS5wYWdlWSA6IGUucGFnZVkgfHwgZS5jbGllbnRZKTtcbiAgICB9XG4gICAgbGV0IHBvc2l0aW9uUmF0aW87XG4gICAgcG9zaXRpb25SYXRpbyA9ICgocG9pbnRlclBvc2l0aW9uKSAtICRlbC5vZmZzZXQoKVtzd2lwZXIuaXNIb3Jpem9udGFsKCkgPyAnbGVmdCcgOiAndG9wJ10gLSAoZHJhZ1NpemUgLyAyKSkgLyAodHJhY2tTaXplIC0gZHJhZ1NpemUpO1xuICAgIHBvc2l0aW9uUmF0aW8gPSBNYXRoLm1heChNYXRoLm1pbihwb3NpdGlvblJhdGlvLCAxKSwgMCk7XG4gICAgaWYgKHJ0bCkge1xuICAgICAgcG9zaXRpb25SYXRpbyA9IDEgLSBwb3NpdGlvblJhdGlvO1xuICAgIH1cblxuICAgIGNvbnN0IHBvc2l0aW9uID0gc3dpcGVyLm1pblRyYW5zbGF0ZSgpICsgKChzd2lwZXIubWF4VHJhbnNsYXRlKCkgLSBzd2lwZXIubWluVHJhbnNsYXRlKCkpICogcG9zaXRpb25SYXRpbyk7XG5cbiAgICBzd2lwZXIudXBkYXRlUHJvZ3Jlc3MocG9zaXRpb24pO1xuICAgIHN3aXBlci5zZXRUcmFuc2xhdGUocG9zaXRpb24pO1xuICAgIHN3aXBlci51cGRhdGVBY3RpdmVJbmRleCgpO1xuICAgIHN3aXBlci51cGRhdGVTbGlkZXNDbGFzc2VzKCk7XG4gIH0sXG4gIG9uRHJhZ1N0YXJ0KGUpIHtcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgIGNvbnN0IHBhcmFtcyA9IHN3aXBlci5wYXJhbXMuc2Nyb2xsYmFyO1xuICAgIGNvbnN0IHsgc2Nyb2xsYmFyLCAkd3JhcHBlckVsIH0gPSBzd2lwZXI7XG4gICAgY29uc3QgeyAkZWwsICRkcmFnRWwgfSA9IHNjcm9sbGJhcjtcbiAgICBzd2lwZXIuc2Nyb2xsYmFyLmlzVG91Y2hlZCA9IHRydWU7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICAkd3JhcHBlckVsLnRyYW5zaXRpb24oMTAwKTtcbiAgICAkZHJhZ0VsLnRyYW5zaXRpb24oMTAwKTtcbiAgICBzY3JvbGxiYXIuc2V0RHJhZ1Bvc2l0aW9uKGUpO1xuXG4gICAgY2xlYXJUaW1lb3V0KHN3aXBlci5zY3JvbGxiYXIuZHJhZ1RpbWVvdXQpO1xuXG4gICAgJGVsLnRyYW5zaXRpb24oMCk7XG4gICAgaWYgKHBhcmFtcy5oaWRlKSB7XG4gICAgICAkZWwuY3NzKCdvcGFjaXR5JywgMSk7XG4gICAgfVxuICAgIHN3aXBlci5lbWl0KCdzY3JvbGxiYXJEcmFnU3RhcnQnLCBlKTtcbiAgfSxcbiAgb25EcmFnTW92ZShlKSB7XG4gICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICBjb25zdCB7IHNjcm9sbGJhciwgJHdyYXBwZXJFbCB9ID0gc3dpcGVyO1xuICAgIGNvbnN0IHsgJGVsLCAkZHJhZ0VsIH0gPSBzY3JvbGxiYXI7XG5cbiAgICBpZiAoIXN3aXBlci5zY3JvbGxiYXIuaXNUb3VjaGVkKSByZXR1cm47XG4gICAgaWYgKGUucHJldmVudERlZmF1bHQpIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBlbHNlIGUucmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgICBzY3JvbGxiYXIuc2V0RHJhZ1Bvc2l0aW9uKGUpO1xuICAgICR3cmFwcGVyRWwudHJhbnNpdGlvbigwKTtcbiAgICAkZWwudHJhbnNpdGlvbigwKTtcbiAgICAkZHJhZ0VsLnRyYW5zaXRpb24oMCk7XG4gICAgc3dpcGVyLmVtaXQoJ3Njcm9sbGJhckRyYWdNb3ZlJywgZSk7XG4gIH0sXG4gIG9uRHJhZ0VuZChlKSB7XG4gICAgY29uc3Qgc3dpcGVyID0gdGhpcztcblxuICAgIGNvbnN0IHBhcmFtcyA9IHN3aXBlci5wYXJhbXMuc2Nyb2xsYmFyO1xuICAgIGNvbnN0IHsgc2Nyb2xsYmFyIH0gPSBzd2lwZXI7XG4gICAgY29uc3QgeyAkZWwgfSA9IHNjcm9sbGJhcjtcblxuICAgIGlmICghc3dpcGVyLnNjcm9sbGJhci5pc1RvdWNoZWQpIHJldHVybjtcbiAgICBzd2lwZXIuc2Nyb2xsYmFyLmlzVG91Y2hlZCA9IGZhbHNlO1xuICAgIGlmIChwYXJhbXMuaGlkZSkge1xuICAgICAgY2xlYXJUaW1lb3V0KHN3aXBlci5zY3JvbGxiYXIuZHJhZ1RpbWVvdXQpO1xuICAgICAgc3dpcGVyLnNjcm9sbGJhci5kcmFnVGltZW91dCA9IFV0aWxzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgJGVsLmNzcygnb3BhY2l0eScsIDApO1xuICAgICAgICAkZWwudHJhbnNpdGlvbig0MDApO1xuICAgICAgfSwgMTAwMCk7XG4gICAgfVxuICAgIHN3aXBlci5lbWl0KCdzY3JvbGxiYXJEcmFnRW5kJywgZSk7XG4gICAgaWYgKHBhcmFtcy5zbmFwT25SZWxlYXNlKSB7XG4gICAgICBzd2lwZXIuc2xpZGVUb0Nsb3Nlc3QoKTtcbiAgICB9XG4gIH0sXG4gIGVuYWJsZURyYWdnYWJsZSgpIHtcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgIGlmICghc3dpcGVyLnBhcmFtcy5zY3JvbGxiYXIuZWwpIHJldHVybjtcbiAgICBjb25zdCB7XG4gICAgICBzY3JvbGxiYXIsIHRvdWNoRXZlbnRzLCB0b3VjaEV2ZW50c0Rlc2t0b3AsIHBhcmFtcyxcbiAgICB9ID0gc3dpcGVyO1xuICAgIGNvbnN0ICRlbCA9IHNjcm9sbGJhci4kZWw7XG4gICAgY29uc3QgdGFyZ2V0ID0gJGVsWzBdO1xuICAgIGNvbnN0IGFjdGl2ZUxpc3RlbmVyID0gU3VwcG9ydC5wYXNzaXZlTGlzdGVuZXIgJiYgcGFyYW1zLnBhc3NpdmVMaXN0ZW5lciA/IHsgcGFzc2l2ZTogZmFsc2UsIGNhcHR1cmU6IGZhbHNlIH0gOiBmYWxzZTtcbiAgICBjb25zdCBwYXNzaXZlTGlzdGVuZXIgPSBTdXBwb3J0LnBhc3NpdmVMaXN0ZW5lciAmJiBwYXJhbXMucGFzc2l2ZUxpc3RlbmVyID8geyBwYXNzaXZlOiB0cnVlLCBjYXB0dXJlOiBmYWxzZSB9IDogZmFsc2U7XG4gICAgaWYgKCFTdXBwb3J0LnRvdWNoICYmIChTdXBwb3J0LnBvaW50ZXJFdmVudHMgfHwgU3VwcG9ydC5wcmVmaXhlZFBvaW50ZXJFdmVudHMpKSB7XG4gICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcih0b3VjaEV2ZW50c0Rlc2t0b3Auc3RhcnQsIHN3aXBlci5zY3JvbGxiYXIub25EcmFnU3RhcnQsIGFjdGl2ZUxpc3RlbmVyKTtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIodG91Y2hFdmVudHNEZXNrdG9wLm1vdmUsIHN3aXBlci5zY3JvbGxiYXIub25EcmFnTW92ZSwgYWN0aXZlTGlzdGVuZXIpO1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcih0b3VjaEV2ZW50c0Rlc2t0b3AuZW5kLCBzd2lwZXIuc2Nyb2xsYmFyLm9uRHJhZ0VuZCwgcGFzc2l2ZUxpc3RlbmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKFN1cHBvcnQudG91Y2gpIHtcbiAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIodG91Y2hFdmVudHMuc3RhcnQsIHN3aXBlci5zY3JvbGxiYXIub25EcmFnU3RhcnQsIGFjdGl2ZUxpc3RlbmVyKTtcbiAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIodG91Y2hFdmVudHMubW92ZSwgc3dpcGVyLnNjcm9sbGJhci5vbkRyYWdNb3ZlLCBhY3RpdmVMaXN0ZW5lcik7XG4gICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKHRvdWNoRXZlbnRzLmVuZCwgc3dpcGVyLnNjcm9sbGJhci5vbkRyYWdFbmQsIHBhc3NpdmVMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICBpZiAoKHBhcmFtcy5zaW11bGF0ZVRvdWNoICYmICFEZXZpY2UuaW9zICYmICFEZXZpY2UuYW5kcm9pZCkgfHwgKHBhcmFtcy5zaW11bGF0ZVRvdWNoICYmICFTdXBwb3J0LnRvdWNoICYmIERldmljZS5pb3MpKSB7XG4gICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBzd2lwZXIuc2Nyb2xsYmFyLm9uRHJhZ1N0YXJ0LCBhY3RpdmVMaXN0ZW5lcik7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHN3aXBlci5zY3JvbGxiYXIub25EcmFnTW92ZSwgYWN0aXZlTGlzdGVuZXIpO1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgc3dpcGVyLnNjcm9sbGJhci5vbkRyYWdFbmQsIHBhc3NpdmVMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBkaXNhYmxlRHJhZ2dhYmxlKCkge1xuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgaWYgKCFzd2lwZXIucGFyYW1zLnNjcm9sbGJhci5lbCkgcmV0dXJuO1xuICAgIGNvbnN0IHtcbiAgICAgIHNjcm9sbGJhciwgdG91Y2hFdmVudHMsIHRvdWNoRXZlbnRzRGVza3RvcCwgcGFyYW1zLFxuICAgIH0gPSBzd2lwZXI7XG4gICAgY29uc3QgJGVsID0gc2Nyb2xsYmFyLiRlbDtcbiAgICBjb25zdCB0YXJnZXQgPSAkZWxbMF07XG4gICAgY29uc3QgYWN0aXZlTGlzdGVuZXIgPSBTdXBwb3J0LnBhc3NpdmVMaXN0ZW5lciAmJiBwYXJhbXMucGFzc2l2ZUxpc3RlbmVyID8geyBwYXNzaXZlOiBmYWxzZSwgY2FwdHVyZTogZmFsc2UgfSA6IGZhbHNlO1xuICAgIGNvbnN0IHBhc3NpdmVMaXN0ZW5lciA9IFN1cHBvcnQucGFzc2l2ZUxpc3RlbmVyICYmIHBhcmFtcy5wYXNzaXZlTGlzdGVuZXIgPyB7IHBhc3NpdmU6IHRydWUsIGNhcHR1cmU6IGZhbHNlIH0gOiBmYWxzZTtcbiAgICBpZiAoIVN1cHBvcnQudG91Y2ggJiYgKFN1cHBvcnQucG9pbnRlckV2ZW50cyB8fCBTdXBwb3J0LnByZWZpeGVkUG9pbnRlckV2ZW50cykpIHtcbiAgICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKHRvdWNoRXZlbnRzRGVza3RvcC5zdGFydCwgc3dpcGVyLnNjcm9sbGJhci5vbkRyYWdTdGFydCwgYWN0aXZlTGlzdGVuZXIpO1xuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0b3VjaEV2ZW50c0Rlc2t0b3AubW92ZSwgc3dpcGVyLnNjcm9sbGJhci5vbkRyYWdNb3ZlLCBhY3RpdmVMaXN0ZW5lcik7XG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKHRvdWNoRXZlbnRzRGVza3RvcC5lbmQsIHN3aXBlci5zY3JvbGxiYXIub25EcmFnRW5kLCBwYXNzaXZlTGlzdGVuZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoU3VwcG9ydC50b3VjaCkge1xuICAgICAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0b3VjaEV2ZW50cy5zdGFydCwgc3dpcGVyLnNjcm9sbGJhci5vbkRyYWdTdGFydCwgYWN0aXZlTGlzdGVuZXIpO1xuICAgICAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0b3VjaEV2ZW50cy5tb3ZlLCBzd2lwZXIuc2Nyb2xsYmFyLm9uRHJhZ01vdmUsIGFjdGl2ZUxpc3RlbmVyKTtcbiAgICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIodG91Y2hFdmVudHMuZW5kLCBzd2lwZXIuc2Nyb2xsYmFyLm9uRHJhZ0VuZCwgcGFzc2l2ZUxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIGlmICgocGFyYW1zLnNpbXVsYXRlVG91Y2ggJiYgIURldmljZS5pb3MgJiYgIURldmljZS5hbmRyb2lkKSB8fCAocGFyYW1zLnNpbXVsYXRlVG91Y2ggJiYgIVN1cHBvcnQudG91Y2ggJiYgRGV2aWNlLmlvcykpIHtcbiAgICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHN3aXBlci5zY3JvbGxiYXIub25EcmFnU3RhcnQsIGFjdGl2ZUxpc3RlbmVyKTtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgc3dpcGVyLnNjcm9sbGJhci5vbkRyYWdNb3ZlLCBhY3RpdmVMaXN0ZW5lcik7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBzd2lwZXIuc2Nyb2xsYmFyLm9uRHJhZ0VuZCwgcGFzc2l2ZUxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGluaXQoKSB7XG4gICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICBpZiAoIXN3aXBlci5wYXJhbXMuc2Nyb2xsYmFyLmVsKSByZXR1cm47XG4gICAgY29uc3QgeyBzY3JvbGxiYXIsICRlbDogJHN3aXBlckVsIH0gPSBzd2lwZXI7XG4gICAgY29uc3QgcGFyYW1zID0gc3dpcGVyLnBhcmFtcy5zY3JvbGxiYXI7XG5cbiAgICBsZXQgJGVsID0gJChwYXJhbXMuZWwpO1xuICAgIGlmIChzd2lwZXIucGFyYW1zLnVuaXF1ZU5hdkVsZW1lbnRzICYmIHR5cGVvZiBwYXJhbXMuZWwgPT09ICdzdHJpbmcnICYmICRlbC5sZW5ndGggPiAxICYmICRzd2lwZXJFbC5maW5kKHBhcmFtcy5lbCkubGVuZ3RoID09PSAxKSB7XG4gICAgICAkZWwgPSAkc3dpcGVyRWwuZmluZChwYXJhbXMuZWwpO1xuICAgIH1cblxuICAgIGxldCAkZHJhZ0VsID0gJGVsLmZpbmQoYC4ke3N3aXBlci5wYXJhbXMuc2Nyb2xsYmFyLmRyYWdDbGFzc31gKTtcbiAgICBpZiAoJGRyYWdFbC5sZW5ndGggPT09IDApIHtcbiAgICAgICRkcmFnRWwgPSAkKGA8ZGl2IGNsYXNzPVwiJHtzd2lwZXIucGFyYW1zLnNjcm9sbGJhci5kcmFnQ2xhc3N9XCI+PC9kaXY+YCk7XG4gICAgICAkZWwuYXBwZW5kKCRkcmFnRWwpO1xuICAgIH1cblxuICAgIFV0aWxzLmV4dGVuZChzY3JvbGxiYXIsIHtcbiAgICAgICRlbCxcbiAgICAgIGVsOiAkZWxbMF0sXG4gICAgICAkZHJhZ0VsLFxuICAgICAgZHJhZ0VsOiAkZHJhZ0VsWzBdLFxuICAgIH0pO1xuXG4gICAgaWYgKHBhcmFtcy5kcmFnZ2FibGUpIHtcbiAgICAgIHNjcm9sbGJhci5lbmFibGVEcmFnZ2FibGUoKTtcbiAgICB9XG4gIH0sXG4gIGRlc3Ryb3koKSB7XG4gICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICBzd2lwZXIuc2Nyb2xsYmFyLmRpc2FibGVEcmFnZ2FibGUoKTtcbiAgfSxcbn07XG5cbnZhciBTY3JvbGxiYXIkMSA9IHtcbiAgbmFtZTogJ3Njcm9sbGJhcicsXG4gIHBhcmFtczoge1xuICAgIHNjcm9sbGJhcjoge1xuICAgICAgZWw6IG51bGwsXG4gICAgICBkcmFnU2l6ZTogJ2F1dG8nLFxuICAgICAgaGlkZTogZmFsc2UsXG4gICAgICBkcmFnZ2FibGU6IGZhbHNlLFxuICAgICAgc25hcE9uUmVsZWFzZTogdHJ1ZSxcbiAgICAgIGxvY2tDbGFzczogJ3N3aXBlci1zY3JvbGxiYXItbG9jaycsXG4gICAgICBkcmFnQ2xhc3M6ICdzd2lwZXItc2Nyb2xsYmFyLWRyYWcnLFxuICAgIH0sXG4gIH0sXG4gIGNyZWF0ZSgpIHtcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgIFV0aWxzLmV4dGVuZChzd2lwZXIsIHtcbiAgICAgIHNjcm9sbGJhcjoge1xuICAgICAgICBpbml0OiBTY3JvbGxiYXIuaW5pdC5iaW5kKHN3aXBlciksXG4gICAgICAgIGRlc3Ryb3k6IFNjcm9sbGJhci5kZXN0cm95LmJpbmQoc3dpcGVyKSxcbiAgICAgICAgdXBkYXRlU2l6ZTogU2Nyb2xsYmFyLnVwZGF0ZVNpemUuYmluZChzd2lwZXIpLFxuICAgICAgICBzZXRUcmFuc2xhdGU6IFNjcm9sbGJhci5zZXRUcmFuc2xhdGUuYmluZChzd2lwZXIpLFxuICAgICAgICBzZXRUcmFuc2l0aW9uOiBTY3JvbGxiYXIuc2V0VHJhbnNpdGlvbi5iaW5kKHN3aXBlciksXG4gICAgICAgIGVuYWJsZURyYWdnYWJsZTogU2Nyb2xsYmFyLmVuYWJsZURyYWdnYWJsZS5iaW5kKHN3aXBlciksXG4gICAgICAgIGRpc2FibGVEcmFnZ2FibGU6IFNjcm9sbGJhci5kaXNhYmxlRHJhZ2dhYmxlLmJpbmQoc3dpcGVyKSxcbiAgICAgICAgc2V0RHJhZ1Bvc2l0aW9uOiBTY3JvbGxiYXIuc2V0RHJhZ1Bvc2l0aW9uLmJpbmQoc3dpcGVyKSxcbiAgICAgICAgb25EcmFnU3RhcnQ6IFNjcm9sbGJhci5vbkRyYWdTdGFydC5iaW5kKHN3aXBlciksXG4gICAgICAgIG9uRHJhZ01vdmU6IFNjcm9sbGJhci5vbkRyYWdNb3ZlLmJpbmQoc3dpcGVyKSxcbiAgICAgICAgb25EcmFnRW5kOiBTY3JvbGxiYXIub25EcmFnRW5kLmJpbmQoc3dpcGVyKSxcbiAgICAgICAgaXNUb3VjaGVkOiBmYWxzZSxcbiAgICAgICAgdGltZW91dDogbnVsbCxcbiAgICAgICAgZHJhZ1RpbWVvdXQ6IG51bGwsXG4gICAgICB9LFxuICAgIH0pO1xuICB9LFxuICBvbjoge1xuICAgIGluaXQoKSB7XG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgICAgc3dpcGVyLnNjcm9sbGJhci5pbml0KCk7XG4gICAgICBzd2lwZXIuc2Nyb2xsYmFyLnVwZGF0ZVNpemUoKTtcbiAgICAgIHN3aXBlci5zY3JvbGxiYXIuc2V0VHJhbnNsYXRlKCk7XG4gICAgfSxcbiAgICB1cGRhdGUoKSB7XG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgICAgc3dpcGVyLnNjcm9sbGJhci51cGRhdGVTaXplKCk7XG4gICAgfSxcbiAgICByZXNpemUoKSB7XG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgICAgc3dpcGVyLnNjcm9sbGJhci51cGRhdGVTaXplKCk7XG4gICAgfSxcbiAgICBvYnNlcnZlclVwZGF0ZSgpIHtcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgICBzd2lwZXIuc2Nyb2xsYmFyLnVwZGF0ZVNpemUoKTtcbiAgICB9LFxuICAgIHNldFRyYW5zbGF0ZSgpIHtcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgICBzd2lwZXIuc2Nyb2xsYmFyLnNldFRyYW5zbGF0ZSgpO1xuICAgIH0sXG4gICAgc2V0VHJhbnNpdGlvbihkdXJhdGlvbikge1xuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICAgIHN3aXBlci5zY3JvbGxiYXIuc2V0VHJhbnNpdGlvbihkdXJhdGlvbik7XG4gICAgfSxcbiAgICBkZXN0cm95KCkge1xuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICAgIHN3aXBlci5zY3JvbGxiYXIuZGVzdHJveSgpO1xuICAgIH0sXG4gIH0sXG59O1xuXG5jb25zdCBQYXJhbGxheCA9IHtcbiAgc2V0VHJhbnNmb3JtKGVsLCBwcm9ncmVzcykge1xuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgY29uc3QgeyBydGwgfSA9IHN3aXBlcjtcblxuICAgIGNvbnN0ICRlbCA9ICQoZWwpO1xuICAgIGNvbnN0IHJ0bEZhY3RvciA9IHJ0bCA/IC0xIDogMTtcblxuICAgIGNvbnN0IHAgPSAkZWwuYXR0cignZGF0YS1zd2lwZXItcGFyYWxsYXgnKSB8fCAnMCc7XG4gICAgbGV0IHggPSAkZWwuYXR0cignZGF0YS1zd2lwZXItcGFyYWxsYXgteCcpO1xuICAgIGxldCB5ID0gJGVsLmF0dHIoJ2RhdGEtc3dpcGVyLXBhcmFsbGF4LXknKTtcbiAgICBjb25zdCBzY2FsZSA9ICRlbC5hdHRyKCdkYXRhLXN3aXBlci1wYXJhbGxheC1zY2FsZScpO1xuICAgIGNvbnN0IG9wYWNpdHkgPSAkZWwuYXR0cignZGF0YS1zd2lwZXItcGFyYWxsYXgtb3BhY2l0eScpO1xuXG4gICAgaWYgKHggfHwgeSkge1xuICAgICAgeCA9IHggfHwgJzAnO1xuICAgICAgeSA9IHkgfHwgJzAnO1xuICAgIH0gZWxzZSBpZiAoc3dpcGVyLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICB4ID0gcDtcbiAgICAgIHkgPSAnMCc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHkgPSBwO1xuICAgICAgeCA9ICcwJztcbiAgICB9XG5cbiAgICBpZiAoKHgpLmluZGV4T2YoJyUnKSA+PSAwKSB7XG4gICAgICB4ID0gYCR7cGFyc2VJbnQoeCwgMTApICogcHJvZ3Jlc3MgKiBydGxGYWN0b3J9JWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHggPSBgJHt4ICogcHJvZ3Jlc3MgKiBydGxGYWN0b3J9cHhgO1xuICAgIH1cbiAgICBpZiAoKHkpLmluZGV4T2YoJyUnKSA+PSAwKSB7XG4gICAgICB5ID0gYCR7cGFyc2VJbnQoeSwgMTApICogcHJvZ3Jlc3N9JWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHkgPSBgJHt5ICogcHJvZ3Jlc3N9cHhgO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygb3BhY2l0eSAhPT0gJ3VuZGVmaW5lZCcgJiYgb3BhY2l0eSAhPT0gbnVsbCkge1xuICAgICAgY29uc3QgY3VycmVudE9wYWNpdHkgPSBvcGFjaXR5IC0gKChvcGFjaXR5IC0gMSkgKiAoMSAtIE1hdGguYWJzKHByb2dyZXNzKSkpO1xuICAgICAgJGVsWzBdLnN0eWxlLm9wYWNpdHkgPSBjdXJyZW50T3BhY2l0eTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBzY2FsZSA9PT0gJ3VuZGVmaW5lZCcgfHwgc2NhbGUgPT09IG51bGwpIHtcbiAgICAgICRlbC50cmFuc2Zvcm0oYHRyYW5zbGF0ZTNkKCR7eH0sICR7eX0sIDBweClgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgY3VycmVudFNjYWxlID0gc2NhbGUgLSAoKHNjYWxlIC0gMSkgKiAoMSAtIE1hdGguYWJzKHByb2dyZXNzKSkpO1xuICAgICAgJGVsLnRyYW5zZm9ybShgdHJhbnNsYXRlM2QoJHt4fSwgJHt5fSwgMHB4KSBzY2FsZSgke2N1cnJlbnRTY2FsZX0pYCk7XG4gICAgfVxuICB9LFxuICBzZXRUcmFuc2xhdGUoKSB7XG4gICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICBjb25zdCB7XG4gICAgICAkZWwsIHNsaWRlcywgcHJvZ3Jlc3MsIHNuYXBHcmlkLFxuICAgIH0gPSBzd2lwZXI7XG4gICAgJGVsLmNoaWxkcmVuKCdbZGF0YS1zd2lwZXItcGFyYWxsYXhdLCBbZGF0YS1zd2lwZXItcGFyYWxsYXgteF0sIFtkYXRhLXN3aXBlci1wYXJhbGxheC15XScpXG4gICAgICAuZWFjaCgoaW5kZXgsIGVsKSA9PiB7XG4gICAgICAgIHN3aXBlci5wYXJhbGxheC5zZXRUcmFuc2Zvcm0oZWwsIHByb2dyZXNzKTtcbiAgICAgIH0pO1xuICAgIHNsaWRlcy5lYWNoKChzbGlkZUluZGV4LCBzbGlkZUVsKSA9PiB7XG4gICAgICBsZXQgc2xpZGVQcm9ncmVzcyA9IHNsaWRlRWwucHJvZ3Jlc3M7XG4gICAgICBpZiAoc3dpcGVyLnBhcmFtcy5zbGlkZXNQZXJHcm91cCA+IDEgJiYgc3dpcGVyLnBhcmFtcy5zbGlkZXNQZXJWaWV3ICE9PSAnYXV0bycpIHtcbiAgICAgICAgc2xpZGVQcm9ncmVzcyArPSBNYXRoLmNlaWwoc2xpZGVJbmRleCAvIDIpIC0gKHByb2dyZXNzICogKHNuYXBHcmlkLmxlbmd0aCAtIDEpKTtcbiAgICAgIH1cbiAgICAgIHNsaWRlUHJvZ3Jlc3MgPSBNYXRoLm1pbihNYXRoLm1heChzbGlkZVByb2dyZXNzLCAtMSksIDEpO1xuICAgICAgJChzbGlkZUVsKS5maW5kKCdbZGF0YS1zd2lwZXItcGFyYWxsYXhdLCBbZGF0YS1zd2lwZXItcGFyYWxsYXgteF0sIFtkYXRhLXN3aXBlci1wYXJhbGxheC15XScpXG4gICAgICAgIC5lYWNoKChpbmRleCwgZWwpID0+IHtcbiAgICAgICAgICBzd2lwZXIucGFyYWxsYXguc2V0VHJhbnNmb3JtKGVsLCBzbGlkZVByb2dyZXNzKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gIH0sXG4gIHNldFRyYW5zaXRpb24oZHVyYXRpb24gPSB0aGlzLnBhcmFtcy5zcGVlZCkge1xuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgY29uc3QgeyAkZWwgfSA9IHN3aXBlcjtcbiAgICAkZWwuZmluZCgnW2RhdGEtc3dpcGVyLXBhcmFsbGF4XSwgW2RhdGEtc3dpcGVyLXBhcmFsbGF4LXhdLCBbZGF0YS1zd2lwZXItcGFyYWxsYXgteV0nKVxuICAgICAgLmVhY2goKGluZGV4LCBwYXJhbGxheEVsKSA9PiB7XG4gICAgICAgIGNvbnN0ICRwYXJhbGxheEVsID0gJChwYXJhbGxheEVsKTtcbiAgICAgICAgbGV0IHBhcmFsbGF4RHVyYXRpb24gPSBwYXJzZUludCgkcGFyYWxsYXhFbC5hdHRyKCdkYXRhLXN3aXBlci1wYXJhbGxheC1kdXJhdGlvbicpLCAxMCkgfHwgZHVyYXRpb247XG4gICAgICAgIGlmIChkdXJhdGlvbiA9PT0gMCkgcGFyYWxsYXhEdXJhdGlvbiA9IDA7XG4gICAgICAgICRwYXJhbGxheEVsLnRyYW5zaXRpb24ocGFyYWxsYXhEdXJhdGlvbik7XG4gICAgICB9KTtcbiAgfSxcbn07XG5cbnZhciBQYXJhbGxheCQxID0ge1xuICBuYW1lOiAncGFyYWxsYXgnLFxuICBwYXJhbXM6IHtcbiAgICBwYXJhbGxheDoge1xuICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgfSxcbiAgfSxcbiAgY3JlYXRlKCkge1xuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgVXRpbHMuZXh0ZW5kKHN3aXBlciwge1xuICAgICAgcGFyYWxsYXg6IHtcbiAgICAgICAgc2V0VHJhbnNmb3JtOiBQYXJhbGxheC5zZXRUcmFuc2Zvcm0uYmluZChzd2lwZXIpLFxuICAgICAgICBzZXRUcmFuc2xhdGU6IFBhcmFsbGF4LnNldFRyYW5zbGF0ZS5iaW5kKHN3aXBlciksXG4gICAgICAgIHNldFRyYW5zaXRpb246IFBhcmFsbGF4LnNldFRyYW5zaXRpb24uYmluZChzd2lwZXIpLFxuICAgICAgfSxcbiAgICB9KTtcbiAgfSxcbiAgb246IHtcbiAgICBiZWZvcmVJbml0KCkge1xuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICAgIGlmICghc3dpcGVyLnBhcmFtcy5wYXJhbGxheC5lbmFibGVkKSByZXR1cm47XG4gICAgICBzd2lwZXIucGFyYW1zLndhdGNoU2xpZGVzUHJvZ3Jlc3MgPSB0cnVlO1xuICAgIH0sXG4gICAgaW5pdCgpIHtcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgICBpZiAoIXN3aXBlci5wYXJhbXMucGFyYWxsYXgpIHJldHVybjtcbiAgICAgIHN3aXBlci5wYXJhbGxheC5zZXRUcmFuc2xhdGUoKTtcbiAgICB9LFxuICAgIHNldFRyYW5zbGF0ZSgpIHtcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgICBpZiAoIXN3aXBlci5wYXJhbXMucGFyYWxsYXgpIHJldHVybjtcbiAgICAgIHN3aXBlci5wYXJhbGxheC5zZXRUcmFuc2xhdGUoKTtcbiAgICB9LFxuICAgIHNldFRyYW5zaXRpb24oZHVyYXRpb24pIHtcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgICBpZiAoIXN3aXBlci5wYXJhbXMucGFyYWxsYXgpIHJldHVybjtcbiAgICAgIHN3aXBlci5wYXJhbGxheC5zZXRUcmFuc2l0aW9uKGR1cmF0aW9uKTtcbiAgICB9LFxuICB9LFxufTtcblxuY29uc3QgWm9vbSA9IHtcbiAgLy8gQ2FsYyBTY2FsZSBGcm9tIE11bHRpLXRvdWNoZXNcbiAgZ2V0RGlzdGFuY2VCZXR3ZWVuVG91Y2hlcyhlKSB7XG4gICAgaWYgKGUudGFyZ2V0VG91Y2hlcy5sZW5ndGggPCAyKSByZXR1cm4gMTtcbiAgICBjb25zdCB4MSA9IGUudGFyZ2V0VG91Y2hlc1swXS5wYWdlWDtcbiAgICBjb25zdCB5MSA9IGUudGFyZ2V0VG91Y2hlc1swXS5wYWdlWTtcbiAgICBjb25zdCB4MiA9IGUudGFyZ2V0VG91Y2hlc1sxXS5wYWdlWDtcbiAgICBjb25zdCB5MiA9IGUudGFyZ2V0VG91Y2hlc1sxXS5wYWdlWTtcbiAgICBjb25zdCBkaXN0YW5jZSA9IE1hdGguc3FydCgoKHgyIC0geDEpICoqIDIpICsgKCh5MiAtIHkxKSAqKiAyKSk7XG4gICAgcmV0dXJuIGRpc3RhbmNlO1xuICB9LFxuICAvLyBFdmVudHNcbiAgb25HZXN0dXJlU3RhcnQoZSkge1xuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgY29uc3QgcGFyYW1zID0gc3dpcGVyLnBhcmFtcy56b29tO1xuICAgIGNvbnN0IHpvb20gPSBzd2lwZXIuem9vbTtcbiAgICBjb25zdCB7IGdlc3R1cmUgfSA9IHpvb207XG4gICAgem9vbS5mYWtlR2VzdHVyZVRvdWNoZWQgPSBmYWxzZTtcbiAgICB6b29tLmZha2VHZXN0dXJlTW92ZWQgPSBmYWxzZTtcbiAgICBpZiAoIVN1cHBvcnQuZ2VzdHVyZXMpIHtcbiAgICAgIGlmIChlLnR5cGUgIT09ICd0b3VjaHN0YXJ0JyB8fCAoZS50eXBlID09PSAndG91Y2hzdGFydCcgJiYgZS50YXJnZXRUb3VjaGVzLmxlbmd0aCA8IDIpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHpvb20uZmFrZUdlc3R1cmVUb3VjaGVkID0gdHJ1ZTtcbiAgICAgIGdlc3R1cmUuc2NhbGVTdGFydCA9IFpvb20uZ2V0RGlzdGFuY2VCZXR3ZWVuVG91Y2hlcyhlKTtcbiAgICB9XG4gICAgaWYgKCFnZXN0dXJlLiRzbGlkZUVsIHx8ICFnZXN0dXJlLiRzbGlkZUVsLmxlbmd0aCkge1xuICAgICAgZ2VzdHVyZS4kc2xpZGVFbCA9ICQoZS50YXJnZXQpLmNsb3Nlc3QoJy5zd2lwZXItc2xpZGUnKTtcbiAgICAgIGlmIChnZXN0dXJlLiRzbGlkZUVsLmxlbmd0aCA9PT0gMCkgZ2VzdHVyZS4kc2xpZGVFbCA9IHN3aXBlci5zbGlkZXMuZXEoc3dpcGVyLmFjdGl2ZUluZGV4KTtcbiAgICAgIGdlc3R1cmUuJGltYWdlRWwgPSBnZXN0dXJlLiRzbGlkZUVsLmZpbmQoJ2ltZywgc3ZnLCBjYW52YXMnKTtcbiAgICAgIGdlc3R1cmUuJGltYWdlV3JhcEVsID0gZ2VzdHVyZS4kaW1hZ2VFbC5wYXJlbnQoYC4ke3BhcmFtcy5jb250YWluZXJDbGFzc31gKTtcbiAgICAgIGdlc3R1cmUubWF4UmF0aW8gPSBnZXN0dXJlLiRpbWFnZVdyYXBFbC5hdHRyKCdkYXRhLXN3aXBlci16b29tJykgfHwgcGFyYW1zLm1heFJhdGlvO1xuICAgICAgaWYgKGdlc3R1cmUuJGltYWdlV3JhcEVsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBnZXN0dXJlLiRpbWFnZUVsID0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGdlc3R1cmUuJGltYWdlRWwudHJhbnNpdGlvbigwKTtcbiAgICBzd2lwZXIuem9vbS5pc1NjYWxpbmcgPSB0cnVlO1xuICB9LFxuICBvbkdlc3R1cmVDaGFuZ2UoZSkge1xuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgY29uc3QgcGFyYW1zID0gc3dpcGVyLnBhcmFtcy56b29tO1xuICAgIGNvbnN0IHpvb20gPSBzd2lwZXIuem9vbTtcbiAgICBjb25zdCB7IGdlc3R1cmUgfSA9IHpvb207XG4gICAgaWYgKCFTdXBwb3J0Lmdlc3R1cmVzKSB7XG4gICAgICBpZiAoZS50eXBlICE9PSAndG91Y2htb3ZlJyB8fCAoZS50eXBlID09PSAndG91Y2htb3ZlJyAmJiBlLnRhcmdldFRvdWNoZXMubGVuZ3RoIDwgMikpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgem9vbS5mYWtlR2VzdHVyZU1vdmVkID0gdHJ1ZTtcbiAgICAgIGdlc3R1cmUuc2NhbGVNb3ZlID0gWm9vbS5nZXREaXN0YW5jZUJldHdlZW5Ub3VjaGVzKGUpO1xuICAgIH1cbiAgICBpZiAoIWdlc3R1cmUuJGltYWdlRWwgfHwgZ2VzdHVyZS4kaW1hZ2VFbC5sZW5ndGggPT09IDApIHJldHVybjtcbiAgICBpZiAoU3VwcG9ydC5nZXN0dXJlcykge1xuICAgICAgc3dpcGVyLnpvb20uc2NhbGUgPSBlLnNjYWxlICogem9vbS5jdXJyZW50U2NhbGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHpvb20uc2NhbGUgPSAoZ2VzdHVyZS5zY2FsZU1vdmUgLyBnZXN0dXJlLnNjYWxlU3RhcnQpICogem9vbS5jdXJyZW50U2NhbGU7XG4gICAgfVxuICAgIGlmICh6b29tLnNjYWxlID4gZ2VzdHVyZS5tYXhSYXRpbykge1xuICAgICAgem9vbS5zY2FsZSA9IChnZXN0dXJlLm1heFJhdGlvIC0gMSkgKyAoKCh6b29tLnNjYWxlIC0gZ2VzdHVyZS5tYXhSYXRpbykgKyAxKSAqKiAwLjUpO1xuICAgIH1cbiAgICBpZiAoem9vbS5zY2FsZSA8IHBhcmFtcy5taW5SYXRpbykge1xuICAgICAgem9vbS5zY2FsZSA9IChwYXJhbXMubWluUmF0aW8gKyAxKSAtICgoKHBhcmFtcy5taW5SYXRpbyAtIHpvb20uc2NhbGUpICsgMSkgKiogMC41KTtcbiAgICB9XG4gICAgZ2VzdHVyZS4kaW1hZ2VFbC50cmFuc2Zvcm0oYHRyYW5zbGF0ZTNkKDAsMCwwKSBzY2FsZSgke3pvb20uc2NhbGV9KWApO1xuICB9LFxuICBvbkdlc3R1cmVFbmQoZSkge1xuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgY29uc3QgcGFyYW1zID0gc3dpcGVyLnBhcmFtcy56b29tO1xuICAgIGNvbnN0IHpvb20gPSBzd2lwZXIuem9vbTtcbiAgICBjb25zdCB7IGdlc3R1cmUgfSA9IHpvb207XG4gICAgaWYgKCFTdXBwb3J0Lmdlc3R1cmVzKSB7XG4gICAgICBpZiAoIXpvb20uZmFrZUdlc3R1cmVUb3VjaGVkIHx8ICF6b29tLmZha2VHZXN0dXJlTW92ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGUudHlwZSAhPT0gJ3RvdWNoZW5kJyB8fCAoZS50eXBlID09PSAndG91Y2hlbmQnICYmIGUuY2hhbmdlZFRvdWNoZXMubGVuZ3RoIDwgMiAmJiAhRGV2aWNlLmFuZHJvaWQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHpvb20uZmFrZUdlc3R1cmVUb3VjaGVkID0gZmFsc2U7XG4gICAgICB6b29tLmZha2VHZXN0dXJlTW92ZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFnZXN0dXJlLiRpbWFnZUVsIHx8IGdlc3R1cmUuJGltYWdlRWwubGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgem9vbS5zY2FsZSA9IE1hdGgubWF4KE1hdGgubWluKHpvb20uc2NhbGUsIGdlc3R1cmUubWF4UmF0aW8pLCBwYXJhbXMubWluUmF0aW8pO1xuICAgIGdlc3R1cmUuJGltYWdlRWwudHJhbnNpdGlvbihzd2lwZXIucGFyYW1zLnNwZWVkKS50cmFuc2Zvcm0oYHRyYW5zbGF0ZTNkKDAsMCwwKSBzY2FsZSgke3pvb20uc2NhbGV9KWApO1xuICAgIHpvb20uY3VycmVudFNjYWxlID0gem9vbS5zY2FsZTtcbiAgICB6b29tLmlzU2NhbGluZyA9IGZhbHNlO1xuICAgIGlmICh6b29tLnNjYWxlID09PSAxKSBnZXN0dXJlLiRzbGlkZUVsID0gdW5kZWZpbmVkO1xuICB9LFxuICBvblRvdWNoU3RhcnQoZSkge1xuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgY29uc3Qgem9vbSA9IHN3aXBlci56b29tO1xuICAgIGNvbnN0IHsgZ2VzdHVyZSwgaW1hZ2UgfSA9IHpvb207XG4gICAgaWYgKCFnZXN0dXJlLiRpbWFnZUVsIHx8IGdlc3R1cmUuJGltYWdlRWwubGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgaWYgKGltYWdlLmlzVG91Y2hlZCkgcmV0dXJuO1xuICAgIGlmIChEZXZpY2UuYW5kcm9pZCkgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGltYWdlLmlzVG91Y2hlZCA9IHRydWU7XG4gICAgaW1hZ2UudG91Y2hlc1N0YXJ0LnggPSBlLnR5cGUgPT09ICd0b3VjaHN0YXJ0JyA/IGUudGFyZ2V0VG91Y2hlc1swXS5wYWdlWCA6IGUucGFnZVg7XG4gICAgaW1hZ2UudG91Y2hlc1N0YXJ0LnkgPSBlLnR5cGUgPT09ICd0b3VjaHN0YXJ0JyA/IGUudGFyZ2V0VG91Y2hlc1swXS5wYWdlWSA6IGUucGFnZVk7XG4gIH0sXG4gIG9uVG91Y2hNb3ZlKGUpIHtcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgIGNvbnN0IHpvb20gPSBzd2lwZXIuem9vbTtcbiAgICBjb25zdCB7IGdlc3R1cmUsIGltYWdlLCB2ZWxvY2l0eSB9ID0gem9vbTtcbiAgICBpZiAoIWdlc3R1cmUuJGltYWdlRWwgfHwgZ2VzdHVyZS4kaW1hZ2VFbC5sZW5ndGggPT09IDApIHJldHVybjtcbiAgICBzd2lwZXIuYWxsb3dDbGljayA9IGZhbHNlO1xuICAgIGlmICghaW1hZ2UuaXNUb3VjaGVkIHx8ICFnZXN0dXJlLiRzbGlkZUVsKSByZXR1cm47XG5cbiAgICBpZiAoIWltYWdlLmlzTW92ZWQpIHtcbiAgICAgIGltYWdlLndpZHRoID0gZ2VzdHVyZS4kaW1hZ2VFbFswXS5vZmZzZXRXaWR0aDtcbiAgICAgIGltYWdlLmhlaWdodCA9IGdlc3R1cmUuJGltYWdlRWxbMF0ub2Zmc2V0SGVpZ2h0O1xuICAgICAgaW1hZ2Uuc3RhcnRYID0gVXRpbHMuZ2V0VHJhbnNsYXRlKGdlc3R1cmUuJGltYWdlV3JhcEVsWzBdLCAneCcpIHx8IDA7XG4gICAgICBpbWFnZS5zdGFydFkgPSBVdGlscy5nZXRUcmFuc2xhdGUoZ2VzdHVyZS4kaW1hZ2VXcmFwRWxbMF0sICd5JykgfHwgMDtcbiAgICAgIGdlc3R1cmUuc2xpZGVXaWR0aCA9IGdlc3R1cmUuJHNsaWRlRWxbMF0ub2Zmc2V0V2lkdGg7XG4gICAgICBnZXN0dXJlLnNsaWRlSGVpZ2h0ID0gZ2VzdHVyZS4kc2xpZGVFbFswXS5vZmZzZXRIZWlnaHQ7XG4gICAgICBnZXN0dXJlLiRpbWFnZVdyYXBFbC50cmFuc2l0aW9uKDApO1xuICAgICAgaWYgKHN3aXBlci5ydGwpIHtcbiAgICAgICAgaW1hZ2Uuc3RhcnRYID0gLWltYWdlLnN0YXJ0WDtcbiAgICAgICAgaW1hZ2Uuc3RhcnRZID0gLWltYWdlLnN0YXJ0WTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gRGVmaW5lIGlmIHdlIG5lZWQgaW1hZ2UgZHJhZ1xuICAgIGNvbnN0IHNjYWxlZFdpZHRoID0gaW1hZ2Uud2lkdGggKiB6b29tLnNjYWxlO1xuICAgIGNvbnN0IHNjYWxlZEhlaWdodCA9IGltYWdlLmhlaWdodCAqIHpvb20uc2NhbGU7XG5cbiAgICBpZiAoc2NhbGVkV2lkdGggPCBnZXN0dXJlLnNsaWRlV2lkdGggJiYgc2NhbGVkSGVpZ2h0IDwgZ2VzdHVyZS5zbGlkZUhlaWdodCkgcmV0dXJuO1xuXG4gICAgaW1hZ2UubWluWCA9IE1hdGgubWluKCgoZ2VzdHVyZS5zbGlkZVdpZHRoIC8gMikgLSAoc2NhbGVkV2lkdGggLyAyKSksIDApO1xuICAgIGltYWdlLm1heFggPSAtaW1hZ2UubWluWDtcbiAgICBpbWFnZS5taW5ZID0gTWF0aC5taW4oKChnZXN0dXJlLnNsaWRlSGVpZ2h0IC8gMikgLSAoc2NhbGVkSGVpZ2h0IC8gMikpLCAwKTtcbiAgICBpbWFnZS5tYXhZID0gLWltYWdlLm1pblk7XG5cbiAgICBpbWFnZS50b3VjaGVzQ3VycmVudC54ID0gZS50eXBlID09PSAndG91Y2htb3ZlJyA/IGUudGFyZ2V0VG91Y2hlc1swXS5wYWdlWCA6IGUucGFnZVg7XG4gICAgaW1hZ2UudG91Y2hlc0N1cnJlbnQueSA9IGUudHlwZSA9PT0gJ3RvdWNobW92ZScgPyBlLnRhcmdldFRvdWNoZXNbMF0ucGFnZVkgOiBlLnBhZ2VZO1xuXG4gICAgaWYgKCFpbWFnZS5pc01vdmVkICYmICF6b29tLmlzU2NhbGluZykge1xuICAgICAgaWYgKFxuICAgICAgICBzd2lwZXIuaXNIb3Jpem9udGFsKCkgJiZcbiAgICAgICAgKFxuICAgICAgICAgIChNYXRoLmZsb29yKGltYWdlLm1pblgpID09PSBNYXRoLmZsb29yKGltYWdlLnN0YXJ0WCkgJiYgaW1hZ2UudG91Y2hlc0N1cnJlbnQueCA8IGltYWdlLnRvdWNoZXNTdGFydC54KSB8fFxuICAgICAgICAgIChNYXRoLmZsb29yKGltYWdlLm1heFgpID09PSBNYXRoLmZsb29yKGltYWdlLnN0YXJ0WCkgJiYgaW1hZ2UudG91Y2hlc0N1cnJlbnQueCA+IGltYWdlLnRvdWNoZXNTdGFydC54KVxuICAgICAgICApXG4gICAgICApIHtcbiAgICAgICAgaW1hZ2UuaXNUb3VjaGVkID0gZmFsc2U7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICFzd2lwZXIuaXNIb3Jpem9udGFsKCkgJiZcbiAgICAgICAgKFxuICAgICAgICAgIChNYXRoLmZsb29yKGltYWdlLm1pblkpID09PSBNYXRoLmZsb29yKGltYWdlLnN0YXJ0WSkgJiYgaW1hZ2UudG91Y2hlc0N1cnJlbnQueSA8IGltYWdlLnRvdWNoZXNTdGFydC55KSB8fFxuICAgICAgICAgIChNYXRoLmZsb29yKGltYWdlLm1heFkpID09PSBNYXRoLmZsb29yKGltYWdlLnN0YXJ0WSkgJiYgaW1hZ2UudG91Y2hlc0N1cnJlbnQueSA+IGltYWdlLnRvdWNoZXNTdGFydC55KVxuICAgICAgICApXG4gICAgICApIHtcbiAgICAgICAgaW1hZ2UuaXNUb3VjaGVkID0gZmFsc2U7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICBpbWFnZS5pc01vdmVkID0gdHJ1ZTtcbiAgICBpbWFnZS5jdXJyZW50WCA9IChpbWFnZS50b3VjaGVzQ3VycmVudC54IC0gaW1hZ2UudG91Y2hlc1N0YXJ0LngpICsgaW1hZ2Uuc3RhcnRYO1xuICAgIGltYWdlLmN1cnJlbnRZID0gKGltYWdlLnRvdWNoZXNDdXJyZW50LnkgLSBpbWFnZS50b3VjaGVzU3RhcnQueSkgKyBpbWFnZS5zdGFydFk7XG5cbiAgICBpZiAoaW1hZ2UuY3VycmVudFggPCBpbWFnZS5taW5YKSB7XG4gICAgICBpbWFnZS5jdXJyZW50WCA9IChpbWFnZS5taW5YICsgMSkgLSAoKChpbWFnZS5taW5YIC0gaW1hZ2UuY3VycmVudFgpICsgMSkgKiogMC44KTtcbiAgICB9XG4gICAgaWYgKGltYWdlLmN1cnJlbnRYID4gaW1hZ2UubWF4WCkge1xuICAgICAgaW1hZ2UuY3VycmVudFggPSAoaW1hZ2UubWF4WCAtIDEpICsgKCgoaW1hZ2UuY3VycmVudFggLSBpbWFnZS5tYXhYKSArIDEpICoqIDAuOCk7XG4gICAgfVxuXG4gICAgaWYgKGltYWdlLmN1cnJlbnRZIDwgaW1hZ2UubWluWSkge1xuICAgICAgaW1hZ2UuY3VycmVudFkgPSAoaW1hZ2UubWluWSArIDEpIC0gKCgoaW1hZ2UubWluWSAtIGltYWdlLmN1cnJlbnRZKSArIDEpICoqIDAuOCk7XG4gICAgfVxuICAgIGlmIChpbWFnZS5jdXJyZW50WSA+IGltYWdlLm1heFkpIHtcbiAgICAgIGltYWdlLmN1cnJlbnRZID0gKGltYWdlLm1heFkgLSAxKSArICgoKGltYWdlLmN1cnJlbnRZIC0gaW1hZ2UubWF4WSkgKyAxKSAqKiAwLjgpO1xuICAgIH1cblxuICAgIC8vIFZlbG9jaXR5XG4gICAgaWYgKCF2ZWxvY2l0eS5wcmV2UG9zaXRpb25YKSB2ZWxvY2l0eS5wcmV2UG9zaXRpb25YID0gaW1hZ2UudG91Y2hlc0N1cnJlbnQueDtcbiAgICBpZiAoIXZlbG9jaXR5LnByZXZQb3NpdGlvblkpIHZlbG9jaXR5LnByZXZQb3NpdGlvblkgPSBpbWFnZS50b3VjaGVzQ3VycmVudC55O1xuICAgIGlmICghdmVsb2NpdHkucHJldlRpbWUpIHZlbG9jaXR5LnByZXZUaW1lID0gRGF0ZS5ub3coKTtcbiAgICB2ZWxvY2l0eS54ID0gKGltYWdlLnRvdWNoZXNDdXJyZW50LnggLSB2ZWxvY2l0eS5wcmV2UG9zaXRpb25YKSAvIChEYXRlLm5vdygpIC0gdmVsb2NpdHkucHJldlRpbWUpIC8gMjtcbiAgICB2ZWxvY2l0eS55ID0gKGltYWdlLnRvdWNoZXNDdXJyZW50LnkgLSB2ZWxvY2l0eS5wcmV2UG9zaXRpb25ZKSAvIChEYXRlLm5vdygpIC0gdmVsb2NpdHkucHJldlRpbWUpIC8gMjtcbiAgICBpZiAoTWF0aC5hYnMoaW1hZ2UudG91Y2hlc0N1cnJlbnQueCAtIHZlbG9jaXR5LnByZXZQb3NpdGlvblgpIDwgMikgdmVsb2NpdHkueCA9IDA7XG4gICAgaWYgKE1hdGguYWJzKGltYWdlLnRvdWNoZXNDdXJyZW50LnkgLSB2ZWxvY2l0eS5wcmV2UG9zaXRpb25ZKSA8IDIpIHZlbG9jaXR5LnkgPSAwO1xuICAgIHZlbG9jaXR5LnByZXZQb3NpdGlvblggPSBpbWFnZS50b3VjaGVzQ3VycmVudC54O1xuICAgIHZlbG9jaXR5LnByZXZQb3NpdGlvblkgPSBpbWFnZS50b3VjaGVzQ3VycmVudC55O1xuICAgIHZlbG9jaXR5LnByZXZUaW1lID0gRGF0ZS5ub3coKTtcblxuICAgIGdlc3R1cmUuJGltYWdlV3JhcEVsLnRyYW5zZm9ybShgdHJhbnNsYXRlM2QoJHtpbWFnZS5jdXJyZW50WH1weCwgJHtpbWFnZS5jdXJyZW50WX1weCwwKWApO1xuICB9LFxuICBvblRvdWNoRW5kKCkge1xuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgY29uc3Qgem9vbSA9IHN3aXBlci56b29tO1xuICAgIGNvbnN0IHsgZ2VzdHVyZSwgaW1hZ2UsIHZlbG9jaXR5IH0gPSB6b29tO1xuICAgIGlmICghZ2VzdHVyZS4kaW1hZ2VFbCB8fCBnZXN0dXJlLiRpbWFnZUVsLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgIGlmICghaW1hZ2UuaXNUb3VjaGVkIHx8ICFpbWFnZS5pc01vdmVkKSB7XG4gICAgICBpbWFnZS5pc1RvdWNoZWQgPSBmYWxzZTtcbiAgICAgIGltYWdlLmlzTW92ZWQgPSBmYWxzZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaW1hZ2UuaXNUb3VjaGVkID0gZmFsc2U7XG4gICAgaW1hZ2UuaXNNb3ZlZCA9IGZhbHNlO1xuICAgIGxldCBtb21lbnR1bUR1cmF0aW9uWCA9IDMwMDtcbiAgICBsZXQgbW9tZW50dW1EdXJhdGlvblkgPSAzMDA7XG4gICAgY29uc3QgbW9tZW50dW1EaXN0YW5jZVggPSB2ZWxvY2l0eS54ICogbW9tZW50dW1EdXJhdGlvblg7XG4gICAgY29uc3QgbmV3UG9zaXRpb25YID0gaW1hZ2UuY3VycmVudFggKyBtb21lbnR1bURpc3RhbmNlWDtcbiAgICBjb25zdCBtb21lbnR1bURpc3RhbmNlWSA9IHZlbG9jaXR5LnkgKiBtb21lbnR1bUR1cmF0aW9uWTtcbiAgICBjb25zdCBuZXdQb3NpdGlvblkgPSBpbWFnZS5jdXJyZW50WSArIG1vbWVudHVtRGlzdGFuY2VZO1xuXG4gICAgLy8gRml4IGR1cmF0aW9uXG4gICAgaWYgKHZlbG9jaXR5LnggIT09IDApIG1vbWVudHVtRHVyYXRpb25YID0gTWF0aC5hYnMoKG5ld1Bvc2l0aW9uWCAtIGltYWdlLmN1cnJlbnRYKSAvIHZlbG9jaXR5LngpO1xuICAgIGlmICh2ZWxvY2l0eS55ICE9PSAwKSBtb21lbnR1bUR1cmF0aW9uWSA9IE1hdGguYWJzKChuZXdQb3NpdGlvblkgLSBpbWFnZS5jdXJyZW50WSkgLyB2ZWxvY2l0eS55KTtcbiAgICBjb25zdCBtb21lbnR1bUR1cmF0aW9uID0gTWF0aC5tYXgobW9tZW50dW1EdXJhdGlvblgsIG1vbWVudHVtRHVyYXRpb25ZKTtcblxuICAgIGltYWdlLmN1cnJlbnRYID0gbmV3UG9zaXRpb25YO1xuICAgIGltYWdlLmN1cnJlbnRZID0gbmV3UG9zaXRpb25ZO1xuXG4gICAgLy8gRGVmaW5lIGlmIHdlIG5lZWQgaW1hZ2UgZHJhZ1xuICAgIGNvbnN0IHNjYWxlZFdpZHRoID0gaW1hZ2Uud2lkdGggKiB6b29tLnNjYWxlO1xuICAgIGNvbnN0IHNjYWxlZEhlaWdodCA9IGltYWdlLmhlaWdodCAqIHpvb20uc2NhbGU7XG4gICAgaW1hZ2UubWluWCA9IE1hdGgubWluKCgoZ2VzdHVyZS5zbGlkZVdpZHRoIC8gMikgLSAoc2NhbGVkV2lkdGggLyAyKSksIDApO1xuICAgIGltYWdlLm1heFggPSAtaW1hZ2UubWluWDtcbiAgICBpbWFnZS5taW5ZID0gTWF0aC5taW4oKChnZXN0dXJlLnNsaWRlSGVpZ2h0IC8gMikgLSAoc2NhbGVkSGVpZ2h0IC8gMikpLCAwKTtcbiAgICBpbWFnZS5tYXhZID0gLWltYWdlLm1pblk7XG4gICAgaW1hZ2UuY3VycmVudFggPSBNYXRoLm1heChNYXRoLm1pbihpbWFnZS5jdXJyZW50WCwgaW1hZ2UubWF4WCksIGltYWdlLm1pblgpO1xuICAgIGltYWdlLmN1cnJlbnRZID0gTWF0aC5tYXgoTWF0aC5taW4oaW1hZ2UuY3VycmVudFksIGltYWdlLm1heFkpLCBpbWFnZS5taW5ZKTtcblxuICAgIGdlc3R1cmUuJGltYWdlV3JhcEVsLnRyYW5zaXRpb24obW9tZW50dW1EdXJhdGlvbikudHJhbnNmb3JtKGB0cmFuc2xhdGUzZCgke2ltYWdlLmN1cnJlbnRYfXB4LCAke2ltYWdlLmN1cnJlbnRZfXB4LDApYCk7XG4gIH0sXG4gIG9uVHJhbnNpdGlvbkVuZCgpIHtcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgIGNvbnN0IHpvb20gPSBzd2lwZXIuem9vbTtcbiAgICBjb25zdCB7IGdlc3R1cmUgfSA9IHpvb207XG4gICAgaWYgKGdlc3R1cmUuJHNsaWRlRWwgJiYgc3dpcGVyLnByZXZpb3VzSW5kZXggIT09IHN3aXBlci5hY3RpdmVJbmRleCkge1xuICAgICAgZ2VzdHVyZS4kaW1hZ2VFbC50cmFuc2Zvcm0oJ3RyYW5zbGF0ZTNkKDAsMCwwKSBzY2FsZSgxKScpO1xuICAgICAgZ2VzdHVyZS4kaW1hZ2VXcmFwRWwudHJhbnNmb3JtKCd0cmFuc2xhdGUzZCgwLDAsMCknKTtcbiAgICAgIGdlc3R1cmUuJHNsaWRlRWwgPSB1bmRlZmluZWQ7XG4gICAgICBnZXN0dXJlLiRpbWFnZUVsID0gdW5kZWZpbmVkO1xuICAgICAgZ2VzdHVyZS4kaW1hZ2VXcmFwRWwgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHpvb20uc2NhbGUgPSAxO1xuICAgICAgem9vbS5jdXJyZW50U2NhbGUgPSAxO1xuICAgIH1cbiAgfSxcbiAgLy8gVG9nZ2xlIFpvb21cbiAgdG9nZ2xlKGUpIHtcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgIGNvbnN0IHpvb20gPSBzd2lwZXIuem9vbTtcblxuICAgIGlmICh6b29tLnNjYWxlICYmIHpvb20uc2NhbGUgIT09IDEpIHtcbiAgICAgIC8vIFpvb20gT3V0XG4gICAgICB6b29tLm91dCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBab29tIEluXG4gICAgICB6b29tLmluKGUpO1xuICAgIH1cbiAgfSxcbiAgaW4oZSkge1xuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG5cbiAgICBjb25zdCB6b29tID0gc3dpcGVyLnpvb207XG4gICAgY29uc3QgcGFyYW1zID0gc3dpcGVyLnBhcmFtcy56b29tO1xuICAgIGNvbnN0IHsgZ2VzdHVyZSwgaW1hZ2UgfSA9IHpvb207XG5cbiAgICBpZiAoIWdlc3R1cmUuJHNsaWRlRWwpIHtcbiAgICAgIGdlc3R1cmUuJHNsaWRlRWwgPSBzd2lwZXIuY2xpY2tlZFNsaWRlID8gJChzd2lwZXIuY2xpY2tlZFNsaWRlKSA6IHN3aXBlci5zbGlkZXMuZXEoc3dpcGVyLmFjdGl2ZUluZGV4KTtcbiAgICAgIGdlc3R1cmUuJGltYWdlRWwgPSBnZXN0dXJlLiRzbGlkZUVsLmZpbmQoJ2ltZywgc3ZnLCBjYW52YXMnKTtcbiAgICAgIGdlc3R1cmUuJGltYWdlV3JhcEVsID0gZ2VzdHVyZS4kaW1hZ2VFbC5wYXJlbnQoYC4ke3BhcmFtcy5jb250YWluZXJDbGFzc31gKTtcbiAgICB9XG4gICAgaWYgKCFnZXN0dXJlLiRpbWFnZUVsIHx8IGdlc3R1cmUuJGltYWdlRWwubGVuZ3RoID09PSAwKSByZXR1cm47XG5cbiAgICBnZXN0dXJlLiRzbGlkZUVsLmFkZENsYXNzKGAke3BhcmFtcy56b29tZWRTbGlkZUNsYXNzfWApO1xuXG4gICAgbGV0IHRvdWNoWDtcbiAgICBsZXQgdG91Y2hZO1xuICAgIGxldCBvZmZzZXRYO1xuICAgIGxldCBvZmZzZXRZO1xuICAgIGxldCBkaWZmWDtcbiAgICBsZXQgZGlmZlk7XG4gICAgbGV0IHRyYW5zbGF0ZVg7XG4gICAgbGV0IHRyYW5zbGF0ZVk7XG4gICAgbGV0IGltYWdlV2lkdGg7XG4gICAgbGV0IGltYWdlSGVpZ2h0O1xuICAgIGxldCBzY2FsZWRXaWR0aDtcbiAgICBsZXQgc2NhbGVkSGVpZ2h0O1xuICAgIGxldCB0cmFuc2xhdGVNaW5YO1xuICAgIGxldCB0cmFuc2xhdGVNaW5ZO1xuICAgIGxldCB0cmFuc2xhdGVNYXhYO1xuICAgIGxldCB0cmFuc2xhdGVNYXhZO1xuICAgIGxldCBzbGlkZVdpZHRoO1xuICAgIGxldCBzbGlkZUhlaWdodDtcblxuICAgIGlmICh0eXBlb2YgaW1hZ2UudG91Y2hlc1N0YXJ0LnggPT09ICd1bmRlZmluZWQnICYmIGUpIHtcbiAgICAgIHRvdWNoWCA9IGUudHlwZSA9PT0gJ3RvdWNoZW5kJyA/IGUuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVggOiBlLnBhZ2VYO1xuICAgICAgdG91Y2hZID0gZS50eXBlID09PSAndG91Y2hlbmQnID8gZS5jaGFuZ2VkVG91Y2hlc1swXS5wYWdlWSA6IGUucGFnZVk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRvdWNoWCA9IGltYWdlLnRvdWNoZXNTdGFydC54O1xuICAgICAgdG91Y2hZID0gaW1hZ2UudG91Y2hlc1N0YXJ0Lnk7XG4gICAgfVxuXG4gICAgem9vbS5zY2FsZSA9IGdlc3R1cmUuJGltYWdlV3JhcEVsLmF0dHIoJ2RhdGEtc3dpcGVyLXpvb20nKSB8fCBwYXJhbXMubWF4UmF0aW87XG4gICAgem9vbS5jdXJyZW50U2NhbGUgPSBnZXN0dXJlLiRpbWFnZVdyYXBFbC5hdHRyKCdkYXRhLXN3aXBlci16b29tJykgfHwgcGFyYW1zLm1heFJhdGlvO1xuICAgIGlmIChlKSB7XG4gICAgICBzbGlkZVdpZHRoID0gZ2VzdHVyZS4kc2xpZGVFbFswXS5vZmZzZXRXaWR0aDtcbiAgICAgIHNsaWRlSGVpZ2h0ID0gZ2VzdHVyZS4kc2xpZGVFbFswXS5vZmZzZXRIZWlnaHQ7XG4gICAgICBvZmZzZXRYID0gZ2VzdHVyZS4kc2xpZGVFbC5vZmZzZXQoKS5sZWZ0O1xuICAgICAgb2Zmc2V0WSA9IGdlc3R1cmUuJHNsaWRlRWwub2Zmc2V0KCkudG9wO1xuICAgICAgZGlmZlggPSAob2Zmc2V0WCArIChzbGlkZVdpZHRoIC8gMikpIC0gdG91Y2hYO1xuICAgICAgZGlmZlkgPSAob2Zmc2V0WSArIChzbGlkZUhlaWdodCAvIDIpKSAtIHRvdWNoWTtcblxuICAgICAgaW1hZ2VXaWR0aCA9IGdlc3R1cmUuJGltYWdlRWxbMF0ub2Zmc2V0V2lkdGg7XG4gICAgICBpbWFnZUhlaWdodCA9IGdlc3R1cmUuJGltYWdlRWxbMF0ub2Zmc2V0SGVpZ2h0O1xuICAgICAgc2NhbGVkV2lkdGggPSBpbWFnZVdpZHRoICogem9vbS5zY2FsZTtcbiAgICAgIHNjYWxlZEhlaWdodCA9IGltYWdlSGVpZ2h0ICogem9vbS5zY2FsZTtcblxuICAgICAgdHJhbnNsYXRlTWluWCA9IE1hdGgubWluKCgoc2xpZGVXaWR0aCAvIDIpIC0gKHNjYWxlZFdpZHRoIC8gMikpLCAwKTtcbiAgICAgIHRyYW5zbGF0ZU1pblkgPSBNYXRoLm1pbigoKHNsaWRlSGVpZ2h0IC8gMikgLSAoc2NhbGVkSGVpZ2h0IC8gMikpLCAwKTtcbiAgICAgIHRyYW5zbGF0ZU1heFggPSAtdHJhbnNsYXRlTWluWDtcbiAgICAgIHRyYW5zbGF0ZU1heFkgPSAtdHJhbnNsYXRlTWluWTtcblxuICAgICAgdHJhbnNsYXRlWCA9IGRpZmZYICogem9vbS5zY2FsZTtcbiAgICAgIHRyYW5zbGF0ZVkgPSBkaWZmWSAqIHpvb20uc2NhbGU7XG5cbiAgICAgIGlmICh0cmFuc2xhdGVYIDwgdHJhbnNsYXRlTWluWCkge1xuICAgICAgICB0cmFuc2xhdGVYID0gdHJhbnNsYXRlTWluWDtcbiAgICAgIH1cbiAgICAgIGlmICh0cmFuc2xhdGVYID4gdHJhbnNsYXRlTWF4WCkge1xuICAgICAgICB0cmFuc2xhdGVYID0gdHJhbnNsYXRlTWF4WDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRyYW5zbGF0ZVkgPCB0cmFuc2xhdGVNaW5ZKSB7XG4gICAgICAgIHRyYW5zbGF0ZVkgPSB0cmFuc2xhdGVNaW5ZO1xuICAgICAgfVxuICAgICAgaWYgKHRyYW5zbGF0ZVkgPiB0cmFuc2xhdGVNYXhZKSB7XG4gICAgICAgIHRyYW5zbGF0ZVkgPSB0cmFuc2xhdGVNYXhZO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0cmFuc2xhdGVYID0gMDtcbiAgICAgIHRyYW5zbGF0ZVkgPSAwO1xuICAgIH1cbiAgICBnZXN0dXJlLiRpbWFnZVdyYXBFbC50cmFuc2l0aW9uKDMwMCkudHJhbnNmb3JtKGB0cmFuc2xhdGUzZCgke3RyYW5zbGF0ZVh9cHgsICR7dHJhbnNsYXRlWX1weCwwKWApO1xuICAgIGdlc3R1cmUuJGltYWdlRWwudHJhbnNpdGlvbigzMDApLnRyYW5zZm9ybShgdHJhbnNsYXRlM2QoMCwwLDApIHNjYWxlKCR7em9vbS5zY2FsZX0pYCk7XG4gIH0sXG4gIG91dCgpIHtcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuXG4gICAgY29uc3Qgem9vbSA9IHN3aXBlci56b29tO1xuICAgIGNvbnN0IHBhcmFtcyA9IHN3aXBlci5wYXJhbXMuem9vbTtcbiAgICBjb25zdCB7IGdlc3R1cmUgfSA9IHpvb207XG5cbiAgICBpZiAoIWdlc3R1cmUuJHNsaWRlRWwpIHtcbiAgICAgIGdlc3R1cmUuJHNsaWRlRWwgPSBzd2lwZXIuY2xpY2tlZFNsaWRlID8gJChzd2lwZXIuY2xpY2tlZFNsaWRlKSA6IHN3aXBlci5zbGlkZXMuZXEoc3dpcGVyLmFjdGl2ZUluZGV4KTtcbiAgICAgIGdlc3R1cmUuJGltYWdlRWwgPSBnZXN0dXJlLiRzbGlkZUVsLmZpbmQoJ2ltZywgc3ZnLCBjYW52YXMnKTtcbiAgICAgIGdlc3R1cmUuJGltYWdlV3JhcEVsID0gZ2VzdHVyZS4kaW1hZ2VFbC5wYXJlbnQoYC4ke3BhcmFtcy5jb250YWluZXJDbGFzc31gKTtcbiAgICB9XG4gICAgaWYgKCFnZXN0dXJlLiRpbWFnZUVsIHx8IGdlc3R1cmUuJGltYWdlRWwubGVuZ3RoID09PSAwKSByZXR1cm47XG5cbiAgICB6b29tLnNjYWxlID0gMTtcbiAgICB6b29tLmN1cnJlbnRTY2FsZSA9IDE7XG4gICAgZ2VzdHVyZS4kaW1hZ2VXcmFwRWwudHJhbnNpdGlvbigzMDApLnRyYW5zZm9ybSgndHJhbnNsYXRlM2QoMCwwLDApJyk7XG4gICAgZ2VzdHVyZS4kaW1hZ2VFbC50cmFuc2l0aW9uKDMwMCkudHJhbnNmb3JtKCd0cmFuc2xhdGUzZCgwLDAsMCkgc2NhbGUoMSknKTtcbiAgICBnZXN0dXJlLiRzbGlkZUVsLnJlbW92ZUNsYXNzKGAke3BhcmFtcy56b29tZWRTbGlkZUNsYXNzfWApO1xuICAgIGdlc3R1cmUuJHNsaWRlRWwgPSB1bmRlZmluZWQ7XG4gIH0sXG4gIC8vIEF0dGFjaC9EZXRhY2ggRXZlbnRzXG4gIGVuYWJsZSgpIHtcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgIGNvbnN0IHpvb20gPSBzd2lwZXIuem9vbTtcbiAgICBpZiAoem9vbS5lbmFibGVkKSByZXR1cm47XG4gICAgem9vbS5lbmFibGVkID0gdHJ1ZTtcblxuICAgIGNvbnN0IHBhc3NpdmVMaXN0ZW5lciA9IHN3aXBlci50b3VjaEV2ZW50cy5zdGFydCA9PT0gJ3RvdWNoc3RhcnQnICYmIFN1cHBvcnQucGFzc2l2ZUxpc3RlbmVyICYmIHN3aXBlci5wYXJhbXMucGFzc2l2ZUxpc3RlbmVycyA/IHsgcGFzc2l2ZTogdHJ1ZSwgY2FwdHVyZTogZmFsc2UgfSA6IGZhbHNlO1xuXG4gICAgLy8gU2NhbGUgaW1hZ2VcbiAgICBpZiAoU3VwcG9ydC5nZXN0dXJlcykge1xuICAgICAgc3dpcGVyLiR3cmFwcGVyRWwub24oJ2dlc3R1cmVzdGFydCcsICcuc3dpcGVyLXNsaWRlJywgem9vbS5vbkdlc3R1cmVTdGFydCwgcGFzc2l2ZUxpc3RlbmVyKTtcbiAgICAgIHN3aXBlci4kd3JhcHBlckVsLm9uKCdnZXN0dXJlY2hhbmdlJywgJy5zd2lwZXItc2xpZGUnLCB6b29tLm9uR2VzdHVyZUNoYW5nZSwgcGFzc2l2ZUxpc3RlbmVyKTtcbiAgICAgIHN3aXBlci4kd3JhcHBlckVsLm9uKCdnZXN0dXJlZW5kJywgJy5zd2lwZXItc2xpZGUnLCB6b29tLm9uR2VzdHVyZUVuZCwgcGFzc2l2ZUxpc3RlbmVyKTtcbiAgICB9IGVsc2UgaWYgKHN3aXBlci50b3VjaEV2ZW50cy5zdGFydCA9PT0gJ3RvdWNoc3RhcnQnKSB7XG4gICAgICBzd2lwZXIuJHdyYXBwZXJFbC5vbihzd2lwZXIudG91Y2hFdmVudHMuc3RhcnQsICcuc3dpcGVyLXNsaWRlJywgem9vbS5vbkdlc3R1cmVTdGFydCwgcGFzc2l2ZUxpc3RlbmVyKTtcbiAgICAgIHN3aXBlci4kd3JhcHBlckVsLm9uKHN3aXBlci50b3VjaEV2ZW50cy5tb3ZlLCAnLnN3aXBlci1zbGlkZScsIHpvb20ub25HZXN0dXJlQ2hhbmdlLCBwYXNzaXZlTGlzdGVuZXIpO1xuICAgICAgc3dpcGVyLiR3cmFwcGVyRWwub24oc3dpcGVyLnRvdWNoRXZlbnRzLmVuZCwgJy5zd2lwZXItc2xpZGUnLCB6b29tLm9uR2VzdHVyZUVuZCwgcGFzc2l2ZUxpc3RlbmVyKTtcbiAgICB9XG5cbiAgICAvLyBNb3ZlIGltYWdlXG4gICAgc3dpcGVyLiR3cmFwcGVyRWwub24oc3dpcGVyLnRvdWNoRXZlbnRzLm1vdmUsIGAuJHtzd2lwZXIucGFyYW1zLnpvb20uY29udGFpbmVyQ2xhc3N9YCwgem9vbS5vblRvdWNoTW92ZSk7XG4gIH0sXG4gIGRpc2FibGUoKSB7XG4gICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICBjb25zdCB6b29tID0gc3dpcGVyLnpvb207XG4gICAgaWYgKCF6b29tLmVuYWJsZWQpIHJldHVybjtcblxuICAgIHN3aXBlci56b29tLmVuYWJsZWQgPSBmYWxzZTtcblxuICAgIGNvbnN0IHBhc3NpdmVMaXN0ZW5lciA9IHN3aXBlci50b3VjaEV2ZW50cy5zdGFydCA9PT0gJ3RvdWNoc3RhcnQnICYmIFN1cHBvcnQucGFzc2l2ZUxpc3RlbmVyICYmIHN3aXBlci5wYXJhbXMucGFzc2l2ZUxpc3RlbmVycyA/IHsgcGFzc2l2ZTogdHJ1ZSwgY2FwdHVyZTogZmFsc2UgfSA6IGZhbHNlO1xuXG4gICAgLy8gU2NhbGUgaW1hZ2VcbiAgICBpZiAoU3VwcG9ydC5nZXN0dXJlcykge1xuICAgICAgc3dpcGVyLiR3cmFwcGVyRWwub2ZmKCdnZXN0dXJlc3RhcnQnLCAnLnN3aXBlci1zbGlkZScsIHpvb20ub25HZXN0dXJlU3RhcnQsIHBhc3NpdmVMaXN0ZW5lcik7XG4gICAgICBzd2lwZXIuJHdyYXBwZXJFbC5vZmYoJ2dlc3R1cmVjaGFuZ2UnLCAnLnN3aXBlci1zbGlkZScsIHpvb20ub25HZXN0dXJlQ2hhbmdlLCBwYXNzaXZlTGlzdGVuZXIpO1xuICAgICAgc3dpcGVyLiR3cmFwcGVyRWwub2ZmKCdnZXN0dXJlZW5kJywgJy5zd2lwZXItc2xpZGUnLCB6b29tLm9uR2VzdHVyZUVuZCwgcGFzc2l2ZUxpc3RlbmVyKTtcbiAgICB9IGVsc2UgaWYgKHN3aXBlci50b3VjaEV2ZW50cy5zdGFydCA9PT0gJ3RvdWNoc3RhcnQnKSB7XG4gICAgICBzd2lwZXIuJHdyYXBwZXJFbC5vZmYoc3dpcGVyLnRvdWNoRXZlbnRzLnN0YXJ0LCAnLnN3aXBlci1zbGlkZScsIHpvb20ub25HZXN0dXJlU3RhcnQsIHBhc3NpdmVMaXN0ZW5lcik7XG4gICAgICBzd2lwZXIuJHdyYXBwZXJFbC5vZmYoc3dpcGVyLnRvdWNoRXZlbnRzLm1vdmUsICcuc3dpcGVyLXNsaWRlJywgem9vbS5vbkdlc3R1cmVDaGFuZ2UsIHBhc3NpdmVMaXN0ZW5lcik7XG4gICAgICBzd2lwZXIuJHdyYXBwZXJFbC5vZmYoc3dpcGVyLnRvdWNoRXZlbnRzLmVuZCwgJy5zd2lwZXItc2xpZGUnLCB6b29tLm9uR2VzdHVyZUVuZCwgcGFzc2l2ZUxpc3RlbmVyKTtcbiAgICB9XG5cbiAgICAvLyBNb3ZlIGltYWdlXG4gICAgc3dpcGVyLiR3cmFwcGVyRWwub2ZmKHN3aXBlci50b3VjaEV2ZW50cy5tb3ZlLCBgLiR7c3dpcGVyLnBhcmFtcy56b29tLmNvbnRhaW5lckNsYXNzfWAsIHpvb20ub25Ub3VjaE1vdmUpO1xuICB9LFxufTtcblxudmFyIFpvb20kMSA9IHtcbiAgbmFtZTogJ3pvb20nLFxuICBwYXJhbXM6IHtcbiAgICB6b29tOiB7XG4gICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgIG1heFJhdGlvOiAzLFxuICAgICAgbWluUmF0aW86IDEsXG4gICAgICB0b2dnbGU6IHRydWUsXG4gICAgICBjb250YWluZXJDbGFzczogJ3N3aXBlci16b29tLWNvbnRhaW5lcicsXG4gICAgICB6b29tZWRTbGlkZUNsYXNzOiAnc3dpcGVyLXNsaWRlLXpvb21lZCcsXG4gICAgfSxcbiAgfSxcbiAgY3JlYXRlKCkge1xuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgY29uc3Qgem9vbSA9IHtcbiAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgc2NhbGU6IDEsXG4gICAgICBjdXJyZW50U2NhbGU6IDEsXG4gICAgICBpc1NjYWxpbmc6IGZhbHNlLFxuICAgICAgZ2VzdHVyZToge1xuICAgICAgICAkc2xpZGVFbDogdW5kZWZpbmVkLFxuICAgICAgICBzbGlkZVdpZHRoOiB1bmRlZmluZWQsXG4gICAgICAgIHNsaWRlSGVpZ2h0OiB1bmRlZmluZWQsXG4gICAgICAgICRpbWFnZUVsOiB1bmRlZmluZWQsXG4gICAgICAgICRpbWFnZVdyYXBFbDogdW5kZWZpbmVkLFxuICAgICAgICBtYXhSYXRpbzogMyxcbiAgICAgIH0sXG4gICAgICBpbWFnZToge1xuICAgICAgICBpc1RvdWNoZWQ6IHVuZGVmaW5lZCxcbiAgICAgICAgaXNNb3ZlZDogdW5kZWZpbmVkLFxuICAgICAgICBjdXJyZW50WDogdW5kZWZpbmVkLFxuICAgICAgICBjdXJyZW50WTogdW5kZWZpbmVkLFxuICAgICAgICBtaW5YOiB1bmRlZmluZWQsXG4gICAgICAgIG1pblk6IHVuZGVmaW5lZCxcbiAgICAgICAgbWF4WDogdW5kZWZpbmVkLFxuICAgICAgICBtYXhZOiB1bmRlZmluZWQsXG4gICAgICAgIHdpZHRoOiB1bmRlZmluZWQsXG4gICAgICAgIGhlaWdodDogdW5kZWZpbmVkLFxuICAgICAgICBzdGFydFg6IHVuZGVmaW5lZCxcbiAgICAgICAgc3RhcnRZOiB1bmRlZmluZWQsXG4gICAgICAgIHRvdWNoZXNTdGFydDoge30sXG4gICAgICAgIHRvdWNoZXNDdXJyZW50OiB7fSxcbiAgICAgIH0sXG4gICAgICB2ZWxvY2l0eToge1xuICAgICAgICB4OiB1bmRlZmluZWQsXG4gICAgICAgIHk6IHVuZGVmaW5lZCxcbiAgICAgICAgcHJldlBvc2l0aW9uWDogdW5kZWZpbmVkLFxuICAgICAgICBwcmV2UG9zaXRpb25ZOiB1bmRlZmluZWQsXG4gICAgICAgIHByZXZUaW1lOiB1bmRlZmluZWQsXG4gICAgICB9LFxuICAgIH07XG4gICAgKCdvbkdlc3R1cmVTdGFydCBvbkdlc3R1cmVDaGFuZ2Ugb25HZXN0dXJlRW5kIG9uVG91Y2hTdGFydCBvblRvdWNoTW92ZSBvblRvdWNoRW5kIG9uVHJhbnNpdGlvbkVuZCB0b2dnbGUgZW5hYmxlIGRpc2FibGUgaW4gb3V0Jykuc3BsaXQoJyAnKS5mb3JFYWNoKChtZXRob2ROYW1lKSA9PiB7XG4gICAgICB6b29tW21ldGhvZE5hbWVdID0gWm9vbVttZXRob2ROYW1lXS5iaW5kKHN3aXBlcik7XG4gICAgfSk7XG4gICAgVXRpbHMuZXh0ZW5kKHN3aXBlciwge1xuICAgICAgem9vbSxcbiAgICB9KTtcbiAgfSxcbiAgb246IHtcbiAgICBpbml0KCkge1xuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICAgIGlmIChzd2lwZXIucGFyYW1zLnpvb20uZW5hYmxlZCkge1xuICAgICAgICBzd2lwZXIuem9vbS5lbmFibGUoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGRlc3Ryb3koKSB7XG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgICAgc3dpcGVyLnpvb20uZGlzYWJsZSgpO1xuICAgIH0sXG4gICAgdG91Y2hTdGFydChlKSB7XG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgICAgaWYgKCFzd2lwZXIuem9vbS5lbmFibGVkKSByZXR1cm47XG4gICAgICBzd2lwZXIuem9vbS5vblRvdWNoU3RhcnQoZSk7XG4gICAgfSxcbiAgICB0b3VjaEVuZChlKSB7XG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgICAgaWYgKCFzd2lwZXIuem9vbS5lbmFibGVkKSByZXR1cm47XG4gICAgICBzd2lwZXIuem9vbS5vblRvdWNoRW5kKGUpO1xuICAgIH0sXG4gICAgZG91YmxlVGFwKGUpIHtcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgICBpZiAoc3dpcGVyLnBhcmFtcy56b29tLmVuYWJsZWQgJiYgc3dpcGVyLnpvb20uZW5hYmxlZCAmJiBzd2lwZXIucGFyYW1zLnpvb20udG9nZ2xlKSB7XG4gICAgICAgIHN3aXBlci56b29tLnRvZ2dsZShlKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHRyYW5zaXRpb25FbmQoKSB7XG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgICAgaWYgKHN3aXBlci56b29tLmVuYWJsZWQgJiYgc3dpcGVyLnBhcmFtcy56b29tLmVuYWJsZWQpIHtcbiAgICAgICAgc3dpcGVyLnpvb20ub25UcmFuc2l0aW9uRW5kKCk7XG4gICAgICB9XG4gICAgfSxcbiAgfSxcbn07XG5cbmNvbnN0IExhenkkMiA9IHtcbiAgbG9hZEluU2xpZGUoaW5kZXgsIGxvYWRJbkR1cGxpY2F0ZSA9IHRydWUpIHtcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgIGNvbnN0IHBhcmFtcyA9IHN3aXBlci5wYXJhbXMubGF6eTtcbiAgICBpZiAodHlwZW9mIGluZGV4ID09PSAndW5kZWZpbmVkJykgcmV0dXJuO1xuICAgIGlmIChzd2lwZXIuc2xpZGVzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgIGNvbnN0IGlzVmlydHVhbCA9IHN3aXBlci52aXJ0dWFsICYmIHN3aXBlci5wYXJhbXMudmlydHVhbC5lbmFibGVkO1xuXG4gICAgY29uc3QgJHNsaWRlRWwgPSBpc1ZpcnR1YWxcbiAgICAgID8gc3dpcGVyLiR3cmFwcGVyRWwuY2hpbGRyZW4oYC4ke3N3aXBlci5wYXJhbXMuc2xpZGVDbGFzc31bZGF0YS1zd2lwZXItc2xpZGUtaW5kZXg9XCIke2luZGV4fVwiXWApXG4gICAgICA6IHN3aXBlci5zbGlkZXMuZXEoaW5kZXgpO1xuXG4gICAgbGV0ICRpbWFnZXMgPSAkc2xpZGVFbC5maW5kKGAuJHtwYXJhbXMuZWxlbWVudENsYXNzfTpub3QoLiR7cGFyYW1zLmxvYWRlZENsYXNzfSk6bm90KC4ke3BhcmFtcy5sb2FkaW5nQ2xhc3N9KWApO1xuICAgIGlmICgkc2xpZGVFbC5oYXNDbGFzcyhwYXJhbXMuZWxlbWVudENsYXNzKSAmJiAhJHNsaWRlRWwuaGFzQ2xhc3MocGFyYW1zLmxvYWRlZENsYXNzKSAmJiAhJHNsaWRlRWwuaGFzQ2xhc3MocGFyYW1zLmxvYWRpbmdDbGFzcykpIHtcbiAgICAgICRpbWFnZXMgPSAkaW1hZ2VzLmFkZCgkc2xpZGVFbFswXSk7XG4gICAgfVxuICAgIGlmICgkaW1hZ2VzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuXG4gICAgJGltYWdlcy5lYWNoKChpbWFnZUluZGV4LCBpbWFnZUVsKSA9PiB7XG4gICAgICBjb25zdCAkaW1hZ2VFbCA9ICQoaW1hZ2VFbCk7XG4gICAgICAkaW1hZ2VFbC5hZGRDbGFzcyhwYXJhbXMubG9hZGluZ0NsYXNzKTtcblxuICAgICAgY29uc3QgYmFja2dyb3VuZCA9ICRpbWFnZUVsLmF0dHIoJ2RhdGEtYmFja2dyb3VuZCcpO1xuICAgICAgY29uc3Qgc3JjID0gJGltYWdlRWwuYXR0cignZGF0YS1zcmMnKTtcbiAgICAgIGNvbnN0IHNyY3NldCA9ICRpbWFnZUVsLmF0dHIoJ2RhdGEtc3Jjc2V0Jyk7XG4gICAgICBjb25zdCBzaXplcyA9ICRpbWFnZUVsLmF0dHIoJ2RhdGEtc2l6ZXMnKTtcblxuICAgICAgc3dpcGVyLmxvYWRJbWFnZSgkaW1hZ2VFbFswXSwgKHNyYyB8fCBiYWNrZ3JvdW5kKSwgc3Jjc2V0LCBzaXplcywgZmFsc2UsICgpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzd2lwZXIgPT09ICd1bmRlZmluZWQnIHx8IHN3aXBlciA9PT0gbnVsbCB8fCAhc3dpcGVyIHx8IChzd2lwZXIgJiYgIXN3aXBlci5wYXJhbXMpIHx8IHN3aXBlci5kZXN0cm95ZWQpIHJldHVybjtcbiAgICAgICAgaWYgKGJhY2tncm91bmQpIHtcbiAgICAgICAgICAkaW1hZ2VFbC5jc3MoJ2JhY2tncm91bmQtaW1hZ2UnLCBgdXJsKFwiJHtiYWNrZ3JvdW5kfVwiKWApO1xuICAgICAgICAgICRpbWFnZUVsLnJlbW92ZUF0dHIoJ2RhdGEtYmFja2dyb3VuZCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChzcmNzZXQpIHtcbiAgICAgICAgICAgICRpbWFnZUVsLmF0dHIoJ3NyY3NldCcsIHNyY3NldCk7XG4gICAgICAgICAgICAkaW1hZ2VFbC5yZW1vdmVBdHRyKCdkYXRhLXNyY3NldCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc2l6ZXMpIHtcbiAgICAgICAgICAgICRpbWFnZUVsLmF0dHIoJ3NpemVzJywgc2l6ZXMpO1xuICAgICAgICAgICAgJGltYWdlRWwucmVtb3ZlQXR0cignZGF0YS1zaXplcycpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3JjKSB7XG4gICAgICAgICAgICAkaW1hZ2VFbC5hdHRyKCdzcmMnLCBzcmMpO1xuICAgICAgICAgICAgJGltYWdlRWwucmVtb3ZlQXR0cignZGF0YS1zcmMnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAkaW1hZ2VFbC5hZGRDbGFzcyhwYXJhbXMubG9hZGVkQ2xhc3MpLnJlbW92ZUNsYXNzKHBhcmFtcy5sb2FkaW5nQ2xhc3MpO1xuICAgICAgICAkc2xpZGVFbC5maW5kKGAuJHtwYXJhbXMucHJlbG9hZGVyQ2xhc3N9YCkucmVtb3ZlKCk7XG4gICAgICAgIGlmIChzd2lwZXIucGFyYW1zLmxvb3AgJiYgbG9hZEluRHVwbGljYXRlKSB7XG4gICAgICAgICAgY29uc3Qgc2xpZGVPcmlnaW5hbEluZGV4ID0gJHNsaWRlRWwuYXR0cignZGF0YS1zd2lwZXItc2xpZGUtaW5kZXgnKTtcbiAgICAgICAgICBpZiAoJHNsaWRlRWwuaGFzQ2xhc3Moc3dpcGVyLnBhcmFtcy5zbGlkZUR1cGxpY2F0ZUNsYXNzKSkge1xuICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxTbGlkZSA9IHN3aXBlci4kd3JhcHBlckVsLmNoaWxkcmVuKGBbZGF0YS1zd2lwZXItc2xpZGUtaW5kZXg9XCIke3NsaWRlT3JpZ2luYWxJbmRleH1cIl06bm90KC4ke3N3aXBlci5wYXJhbXMuc2xpZGVEdXBsaWNhdGVDbGFzc30pYCk7XG4gICAgICAgICAgICBzd2lwZXIubGF6eS5sb2FkSW5TbGlkZShvcmlnaW5hbFNsaWRlLmluZGV4KCksIGZhbHNlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgZHVwbGljYXRlZFNsaWRlID0gc3dpcGVyLiR3cmFwcGVyRWwuY2hpbGRyZW4oYC4ke3N3aXBlci5wYXJhbXMuc2xpZGVEdXBsaWNhdGVDbGFzc31bZGF0YS1zd2lwZXItc2xpZGUtaW5kZXg9XCIke3NsaWRlT3JpZ2luYWxJbmRleH1cIl1gKTtcbiAgICAgICAgICAgIHN3aXBlci5sYXp5LmxvYWRJblNsaWRlKGR1cGxpY2F0ZWRTbGlkZS5pbmRleCgpLCBmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN3aXBlci5lbWl0KCdsYXp5SW1hZ2VSZWFkeScsICRzbGlkZUVsWzBdLCAkaW1hZ2VFbFswXSk7XG4gICAgICB9KTtcblxuICAgICAgc3dpcGVyLmVtaXQoJ2xhenlJbWFnZUxvYWQnLCAkc2xpZGVFbFswXSwgJGltYWdlRWxbMF0pO1xuICAgIH0pO1xuICB9LFxuICBsb2FkKCkge1xuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgY29uc3Qge1xuICAgICAgJHdyYXBwZXJFbCwgcGFyYW1zOiBzd2lwZXJQYXJhbXMsIHNsaWRlcywgYWN0aXZlSW5kZXgsXG4gICAgfSA9IHN3aXBlcjtcbiAgICBjb25zdCBpc1ZpcnR1YWwgPSBzd2lwZXIudmlydHVhbCAmJiBzd2lwZXJQYXJhbXMudmlydHVhbC5lbmFibGVkO1xuICAgIGNvbnN0IHBhcmFtcyA9IHN3aXBlclBhcmFtcy5sYXp5O1xuXG4gICAgbGV0IHNsaWRlc1BlclZpZXcgPSBzd2lwZXJQYXJhbXMuc2xpZGVzUGVyVmlldztcbiAgICBpZiAoc2xpZGVzUGVyVmlldyA9PT0gJ2F1dG8nKSB7XG4gICAgICBzbGlkZXNQZXJWaWV3ID0gMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzbGlkZUV4aXN0KGluZGV4KSB7XG4gICAgICBpZiAoaXNWaXJ0dWFsKSB7XG4gICAgICAgIGlmICgkd3JhcHBlckVsLmNoaWxkcmVuKGAuJHtzd2lwZXJQYXJhbXMuc2xpZGVDbGFzc31bZGF0YS1zd2lwZXItc2xpZGUtaW5kZXg9XCIke2luZGV4fVwiXWApLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHNsaWRlc1tpbmRleF0pIHJldHVybiB0cnVlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzbGlkZUluZGV4KHNsaWRlRWwpIHtcbiAgICAgIGlmIChpc1ZpcnR1YWwpIHtcbiAgICAgICAgcmV0dXJuICQoc2xpZGVFbCkuYXR0cignZGF0YS1zd2lwZXItc2xpZGUtaW5kZXgnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAkKHNsaWRlRWwpLmluZGV4KCk7XG4gICAgfVxuXG4gICAgaWYgKCFzd2lwZXIubGF6eS5pbml0aWFsSW1hZ2VMb2FkZWQpIHN3aXBlci5sYXp5LmluaXRpYWxJbWFnZUxvYWRlZCA9IHRydWU7XG4gICAgaWYgKHN3aXBlci5wYXJhbXMud2F0Y2hTbGlkZXNWaXNpYmlsaXR5KSB7XG4gICAgICAkd3JhcHBlckVsLmNoaWxkcmVuKGAuJHtzd2lwZXJQYXJhbXMuc2xpZGVWaXNpYmxlQ2xhc3N9YCkuZWFjaCgoZWxJbmRleCwgc2xpZGVFbCkgPT4ge1xuICAgICAgICBjb25zdCBpbmRleCA9IGlzVmlydHVhbCA/ICQoc2xpZGVFbCkuYXR0cignZGF0YS1zd2lwZXItc2xpZGUtaW5kZXgnKSA6ICQoc2xpZGVFbCkuaW5kZXgoKTtcbiAgICAgICAgc3dpcGVyLmxhenkubG9hZEluU2xpZGUoaW5kZXgpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChzbGlkZXNQZXJWaWV3ID4gMSkge1xuICAgICAgZm9yIChsZXQgaSA9IGFjdGl2ZUluZGV4OyBpIDwgYWN0aXZlSW5kZXggKyBzbGlkZXNQZXJWaWV3OyBpICs9IDEpIHtcbiAgICAgICAgaWYgKHNsaWRlRXhpc3QoaSkpIHN3aXBlci5sYXp5LmxvYWRJblNsaWRlKGkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzd2lwZXIubGF6eS5sb2FkSW5TbGlkZShhY3RpdmVJbmRleCk7XG4gICAgfVxuICAgIGlmIChwYXJhbXMubG9hZFByZXZOZXh0KSB7XG4gICAgICBpZiAoc2xpZGVzUGVyVmlldyA+IDEgfHwgKHBhcmFtcy5sb2FkUHJldk5leHRBbW91bnQgJiYgcGFyYW1zLmxvYWRQcmV2TmV4dEFtb3VudCA+IDEpKSB7XG4gICAgICAgIGNvbnN0IGFtb3VudCA9IHBhcmFtcy5sb2FkUHJldk5leHRBbW91bnQ7XG4gICAgICAgIGNvbnN0IHNwdiA9IHNsaWRlc1BlclZpZXc7XG4gICAgICAgIGNvbnN0IG1heEluZGV4ID0gTWF0aC5taW4oYWN0aXZlSW5kZXggKyBzcHYgKyBNYXRoLm1heChhbW91bnQsIHNwdiksIHNsaWRlcy5sZW5ndGgpO1xuICAgICAgICBjb25zdCBtaW5JbmRleCA9IE1hdGgubWF4KGFjdGl2ZUluZGV4IC0gTWF0aC5tYXgoc3B2LCBhbW91bnQpLCAwKTtcbiAgICAgICAgLy8gTmV4dCBTbGlkZXNcbiAgICAgICAgZm9yIChsZXQgaSA9IGFjdGl2ZUluZGV4ICsgc2xpZGVzUGVyVmlldzsgaSA8IG1heEluZGV4OyBpICs9IDEpIHtcbiAgICAgICAgICBpZiAoc2xpZGVFeGlzdChpKSkgc3dpcGVyLmxhenkubG9hZEluU2xpZGUoaSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUHJldiBTbGlkZXNcbiAgICAgICAgZm9yIChsZXQgaSA9IG1pbkluZGV4OyBpIDwgYWN0aXZlSW5kZXg7IGkgKz0gMSkge1xuICAgICAgICAgIGlmIChzbGlkZUV4aXN0KGkpKSBzd2lwZXIubGF6eS5sb2FkSW5TbGlkZShpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgbmV4dFNsaWRlID0gJHdyYXBwZXJFbC5jaGlsZHJlbihgLiR7c3dpcGVyUGFyYW1zLnNsaWRlTmV4dENsYXNzfWApO1xuICAgICAgICBpZiAobmV4dFNsaWRlLmxlbmd0aCA+IDApIHN3aXBlci5sYXp5LmxvYWRJblNsaWRlKHNsaWRlSW5kZXgobmV4dFNsaWRlKSk7XG5cbiAgICAgICAgY29uc3QgcHJldlNsaWRlID0gJHdyYXBwZXJFbC5jaGlsZHJlbihgLiR7c3dpcGVyUGFyYW1zLnNsaWRlUHJldkNsYXNzfWApO1xuICAgICAgICBpZiAocHJldlNsaWRlLmxlbmd0aCA+IDApIHN3aXBlci5sYXp5LmxvYWRJblNsaWRlKHNsaWRlSW5kZXgocHJldlNsaWRlKSk7XG4gICAgICB9XG4gICAgfVxuICB9LFxufTtcblxudmFyIExhenkkMyA9IHtcbiAgbmFtZTogJ2xhenknLFxuICBwYXJhbXM6IHtcbiAgICBsYXp5OiB7XG4gICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgIGxvYWRQcmV2TmV4dDogZmFsc2UsXG4gICAgICBsb2FkUHJldk5leHRBbW91bnQ6IDEsXG4gICAgICBsb2FkT25UcmFuc2l0aW9uU3RhcnQ6IGZhbHNlLFxuXG4gICAgICBlbGVtZW50Q2xhc3M6ICdzd2lwZXItbGF6eScsXG4gICAgICBsb2FkaW5nQ2xhc3M6ICdzd2lwZXItbGF6eS1sb2FkaW5nJyxcbiAgICAgIGxvYWRlZENsYXNzOiAnc3dpcGVyLWxhenktbG9hZGVkJyxcbiAgICAgIHByZWxvYWRlckNsYXNzOiAnc3dpcGVyLWxhenktcHJlbG9hZGVyJyxcbiAgICB9LFxuICB9LFxuICBjcmVhdGUoKSB7XG4gICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICBVdGlscy5leHRlbmQoc3dpcGVyLCB7XG4gICAgICBsYXp5OiB7XG4gICAgICAgIGluaXRpYWxJbWFnZUxvYWRlZDogZmFsc2UsXG4gICAgICAgIGxvYWQ6IExhenkkMi5sb2FkLmJpbmQoc3dpcGVyKSxcbiAgICAgICAgbG9hZEluU2xpZGU6IExhenkkMi5sb2FkSW5TbGlkZS5iaW5kKHN3aXBlciksXG4gICAgICB9LFxuICAgIH0pO1xuICB9LFxuICBvbjoge1xuICAgIGJlZm9yZUluaXQoKSB7XG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgICAgaWYgKHN3aXBlci5wYXJhbXMubGF6eS5lbmFibGVkICYmIHN3aXBlci5wYXJhbXMucHJlbG9hZEltYWdlcykge1xuICAgICAgICBzd2lwZXIucGFyYW1zLnByZWxvYWRJbWFnZXMgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGluaXQoKSB7XG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgICAgaWYgKHN3aXBlci5wYXJhbXMubGF6eS5lbmFibGVkICYmICFzd2lwZXIucGFyYW1zLmxvb3AgJiYgc3dpcGVyLnBhcmFtcy5pbml0aWFsU2xpZGUgPT09IDApIHtcbiAgICAgICAgc3dpcGVyLmxhenkubG9hZCgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgc2Nyb2xsKCkge1xuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICAgIGlmIChzd2lwZXIucGFyYW1zLmZyZWVNb2RlICYmICFzd2lwZXIucGFyYW1zLmZyZWVNb2RlU3RpY2t5KSB7XG4gICAgICAgIHN3aXBlci5sYXp5LmxvYWQoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHJlc2l6ZSgpIHtcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgICBpZiAoc3dpcGVyLnBhcmFtcy5sYXp5LmVuYWJsZWQpIHtcbiAgICAgICAgc3dpcGVyLmxhenkubG9hZCgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgc2Nyb2xsYmFyRHJhZ01vdmUoKSB7XG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgICAgaWYgKHN3aXBlci5wYXJhbXMubGF6eS5lbmFibGVkKSB7XG4gICAgICAgIHN3aXBlci5sYXp5LmxvYWQoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHRyYW5zaXRpb25TdGFydCgpIHtcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgICBpZiAoc3dpcGVyLnBhcmFtcy5sYXp5LmVuYWJsZWQpIHtcbiAgICAgICAgaWYgKHN3aXBlci5wYXJhbXMubGF6eS5sb2FkT25UcmFuc2l0aW9uU3RhcnQgfHwgKCFzd2lwZXIucGFyYW1zLmxhenkubG9hZE9uVHJhbnNpdGlvblN0YXJ0ICYmICFzd2lwZXIubGF6eS5pbml0aWFsSW1hZ2VMb2FkZWQpKSB7XG4gICAgICAgICAgc3dpcGVyLmxhenkubG9hZCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICB0cmFuc2l0aW9uRW5kKCkge1xuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICAgIGlmIChzd2lwZXIucGFyYW1zLmxhenkuZW5hYmxlZCAmJiAhc3dpcGVyLnBhcmFtcy5sYXp5LmxvYWRPblRyYW5zaXRpb25TdGFydCkge1xuICAgICAgICBzd2lwZXIubGF6eS5sb2FkKCk7XG4gICAgICB9XG4gICAgfSxcbiAgfSxcbn07XG5cbi8qIGVzbGludCBuby1iaXR3aXNlOiBbXCJlcnJvclwiLCB7IFwiYWxsb3dcIjogW1wiPj5cIl0gfV0gKi9cblxuY29uc3QgQ29udHJvbGxlciA9IHtcbiAgTGluZWFyU3BsaW5lOiBmdW5jdGlvbiBMaW5lYXJTcGxpbmUoeCwgeSkge1xuICAgIGNvbnN0IGJpbmFyeVNlYXJjaCA9IChmdW5jdGlvbiBzZWFyY2goKSB7XG4gICAgICBsZXQgbWF4SW5kZXg7XG4gICAgICBsZXQgbWluSW5kZXg7XG4gICAgICBsZXQgZ3Vlc3M7XG4gICAgICByZXR1cm4gKGFycmF5LCB2YWwpID0+IHtcbiAgICAgICAgbWluSW5kZXggPSAtMTtcbiAgICAgICAgbWF4SW5kZXggPSBhcnJheS5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChtYXhJbmRleCAtIG1pbkluZGV4ID4gMSkge1xuICAgICAgICAgIGd1ZXNzID0gbWF4SW5kZXggKyBtaW5JbmRleCA+PiAxO1xuICAgICAgICAgIGlmIChhcnJheVtndWVzc10gPD0gdmFsKSB7XG4gICAgICAgICAgICBtaW5JbmRleCA9IGd1ZXNzO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtYXhJbmRleCA9IGd1ZXNzO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWF4SW5kZXg7XG4gICAgICB9O1xuICAgIH0oKSk7XG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuICAgIHRoaXMubGFzdEluZGV4ID0geC5sZW5ndGggLSAxO1xuICAgIC8vIEdpdmVuIGFuIHggdmFsdWUgKHgyKSwgcmV0dXJuIHRoZSBleHBlY3RlZCB5MiB2YWx1ZTpcbiAgICAvLyAoeDEseTEpIGlzIHRoZSBrbm93biBwb2ludCBiZWZvcmUgZ2l2ZW4gdmFsdWUsXG4gICAgLy8gKHgzLHkzKSBpcyB0aGUga25vd24gcG9pbnQgYWZ0ZXIgZ2l2ZW4gdmFsdWUuXG4gICAgbGV0IGkxO1xuICAgIGxldCBpMztcblxuICAgIHRoaXMuaW50ZXJwb2xhdGUgPSBmdW5jdGlvbiBpbnRlcnBvbGF0ZSh4Mikge1xuICAgICAgaWYgKCF4MikgcmV0dXJuIDA7XG5cbiAgICAgIC8vIEdldCB0aGUgaW5kZXhlcyBvZiB4MSBhbmQgeDMgKHRoZSBhcnJheSBpbmRleGVzIGJlZm9yZSBhbmQgYWZ0ZXIgZ2l2ZW4geDIpOlxuICAgICAgaTMgPSBiaW5hcnlTZWFyY2godGhpcy54LCB4Mik7XG4gICAgICBpMSA9IGkzIC0gMTtcblxuICAgICAgLy8gV2UgaGF2ZSBvdXIgaW5kZXhlcyBpMSAmIGkzLCBzbyB3ZSBjYW4gY2FsY3VsYXRlIGFscmVhZHk6XG4gICAgICAvLyB5MiA6PSAoKHgy4oiSeDEpIMOXICh5M+KIknkxKSkgw7cgKHgz4oiSeDEpICsgeTFcbiAgICAgIHJldHVybiAoKCh4MiAtIHRoaXMueFtpMV0pICogKHRoaXMueVtpM10gLSB0aGlzLnlbaTFdKSkgLyAodGhpcy54W2kzXSAtIHRoaXMueFtpMV0pKSArIHRoaXMueVtpMV07XG4gICAgfTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgLy8geHh4OiBmb3Igbm93IGkgd2lsbCBqdXN0IHNhdmUgb25lIHNwbGluZSBmdW5jdGlvbiB0byB0b1xuICBnZXRJbnRlcnBvbGF0ZUZ1bmN0aW9uKGMpIHtcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgIGlmICghc3dpcGVyLmNvbnRyb2xsZXIuc3BsaW5lKSB7XG4gICAgICBzd2lwZXIuY29udHJvbGxlci5zcGxpbmUgPSBzd2lwZXIucGFyYW1zLmxvb3AgP1xuICAgICAgICBuZXcgQ29udHJvbGxlci5MaW5lYXJTcGxpbmUoc3dpcGVyLnNsaWRlc0dyaWQsIGMuc2xpZGVzR3JpZCkgOlxuICAgICAgICBuZXcgQ29udHJvbGxlci5MaW5lYXJTcGxpbmUoc3dpcGVyLnNuYXBHcmlkLCBjLnNuYXBHcmlkKTtcbiAgICB9XG4gIH0sXG4gIHNldFRyYW5zbGF0ZShzZXRUcmFuc2xhdGUsIGJ5Q29udHJvbGxlcikge1xuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgY29uc3QgY29udHJvbGxlZCA9IHN3aXBlci5jb250cm9sbGVyLmNvbnRyb2w7XG4gICAgbGV0IG11bHRpcGxpZXI7XG4gICAgbGV0IGNvbnRyb2xsZWRUcmFuc2xhdGU7XG4gICAgZnVuY3Rpb24gc2V0Q29udHJvbGxlZFRyYW5zbGF0ZShjKSB7XG4gICAgICAvLyB0aGlzIHdpbGwgY3JlYXRlIGFuIEludGVycG9sYXRlIGZ1bmN0aW9uIGJhc2VkIG9uIHRoZSBzbmFwR3JpZHNcbiAgICAgIC8vIHggaXMgdGhlIEdyaWQgb2YgdGhlIHNjcm9sbGVkIHNjcm9sbGVyIGFuZCB5IHdpbGwgYmUgdGhlIGNvbnRyb2xsZWQgc2Nyb2xsZXJcbiAgICAgIC8vIGl0IG1ha2VzIHNlbnNlIHRvIGNyZWF0ZSB0aGlzIG9ubHkgb25jZSBhbmQgcmVjYWxsIGl0IGZvciB0aGUgaW50ZXJwb2xhdGlvblxuICAgICAgLy8gdGhlIGZ1bmN0aW9uIGRvZXMgYSBsb3Qgb2YgdmFsdWUgY2FjaGluZyBmb3IgcGVyZm9ybWFuY2VcbiAgICAgIGNvbnN0IHRyYW5zbGF0ZSA9IHN3aXBlci5ydGxUcmFuc2xhdGUgPyAtc3dpcGVyLnRyYW5zbGF0ZSA6IHN3aXBlci50cmFuc2xhdGU7XG4gICAgICBpZiAoc3dpcGVyLnBhcmFtcy5jb250cm9sbGVyLmJ5ID09PSAnc2xpZGUnKSB7XG4gICAgICAgIHN3aXBlci5jb250cm9sbGVyLmdldEludGVycG9sYXRlRnVuY3Rpb24oYyk7XG4gICAgICAgIC8vIGkgYW0gbm90IHN1cmUgd2h5IHRoZSB2YWx1ZXMgaGF2ZSB0byBiZSBtdWx0aXBsaWNhdGVkIHRoaXMgd2F5LCB0cmllZCB0byBpbnZlcnQgdGhlIHNuYXBHcmlkXG4gICAgICAgIC8vIGJ1dCBpdCBkaWQgbm90IHdvcmsgb3V0XG4gICAgICAgIGNvbnRyb2xsZWRUcmFuc2xhdGUgPSAtc3dpcGVyLmNvbnRyb2xsZXIuc3BsaW5lLmludGVycG9sYXRlKC10cmFuc2xhdGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWNvbnRyb2xsZWRUcmFuc2xhdGUgfHwgc3dpcGVyLnBhcmFtcy5jb250cm9sbGVyLmJ5ID09PSAnY29udGFpbmVyJykge1xuICAgICAgICBtdWx0aXBsaWVyID0gKGMubWF4VHJhbnNsYXRlKCkgLSBjLm1pblRyYW5zbGF0ZSgpKSAvIChzd2lwZXIubWF4VHJhbnNsYXRlKCkgLSBzd2lwZXIubWluVHJhbnNsYXRlKCkpO1xuICAgICAgICBjb250cm9sbGVkVHJhbnNsYXRlID0gKCh0cmFuc2xhdGUgLSBzd2lwZXIubWluVHJhbnNsYXRlKCkpICogbXVsdGlwbGllcikgKyBjLm1pblRyYW5zbGF0ZSgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3dpcGVyLnBhcmFtcy5jb250cm9sbGVyLmludmVyc2UpIHtcbiAgICAgICAgY29udHJvbGxlZFRyYW5zbGF0ZSA9IGMubWF4VHJhbnNsYXRlKCkgLSBjb250cm9sbGVkVHJhbnNsYXRlO1xuICAgICAgfVxuICAgICAgYy51cGRhdGVQcm9ncmVzcyhjb250cm9sbGVkVHJhbnNsYXRlKTtcbiAgICAgIGMuc2V0VHJhbnNsYXRlKGNvbnRyb2xsZWRUcmFuc2xhdGUsIHN3aXBlcik7XG4gICAgICBjLnVwZGF0ZUFjdGl2ZUluZGV4KCk7XG4gICAgICBjLnVwZGF0ZVNsaWRlc0NsYXNzZXMoKTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY29udHJvbGxlZCkpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29udHJvbGxlZC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBpZiAoY29udHJvbGxlZFtpXSAhPT0gYnlDb250cm9sbGVyICYmIGNvbnRyb2xsZWRbaV0gaW5zdGFuY2VvZiBTd2lwZXIpIHtcbiAgICAgICAgICBzZXRDb250cm9sbGVkVHJhbnNsYXRlKGNvbnRyb2xsZWRbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjb250cm9sbGVkIGluc3RhbmNlb2YgU3dpcGVyICYmIGJ5Q29udHJvbGxlciAhPT0gY29udHJvbGxlZCkge1xuICAgICAgc2V0Q29udHJvbGxlZFRyYW5zbGF0ZShjb250cm9sbGVkKTtcbiAgICB9XG4gIH0sXG4gIHNldFRyYW5zaXRpb24oZHVyYXRpb24sIGJ5Q29udHJvbGxlcikge1xuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgY29uc3QgY29udHJvbGxlZCA9IHN3aXBlci5jb250cm9sbGVyLmNvbnRyb2w7XG4gICAgbGV0IGk7XG4gICAgZnVuY3Rpb24gc2V0Q29udHJvbGxlZFRyYW5zaXRpb24oYykge1xuICAgICAgYy5zZXRUcmFuc2l0aW9uKGR1cmF0aW9uLCBzd2lwZXIpO1xuICAgICAgaWYgKGR1cmF0aW9uICE9PSAwKSB7XG4gICAgICAgIGMudHJhbnNpdGlvblN0YXJ0KCk7XG4gICAgICAgIGMuJHdyYXBwZXJFbC50cmFuc2l0aW9uRW5kKCgpID0+IHtcbiAgICAgICAgICBpZiAoIWNvbnRyb2xsZWQpIHJldHVybjtcbiAgICAgICAgICBpZiAoYy5wYXJhbXMubG9vcCAmJiBzd2lwZXIucGFyYW1zLmNvbnRyb2xsZXIuYnkgPT09ICdzbGlkZScpIHtcbiAgICAgICAgICAgIGMubG9vcEZpeCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjLnRyYW5zaXRpb25FbmQoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KGNvbnRyb2xsZWQpKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgY29udHJvbGxlZC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBpZiAoY29udHJvbGxlZFtpXSAhPT0gYnlDb250cm9sbGVyICYmIGNvbnRyb2xsZWRbaV0gaW5zdGFuY2VvZiBTd2lwZXIpIHtcbiAgICAgICAgICBzZXRDb250cm9sbGVkVHJhbnNpdGlvbihjb250cm9sbGVkW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY29udHJvbGxlZCBpbnN0YW5jZW9mIFN3aXBlciAmJiBieUNvbnRyb2xsZXIgIT09IGNvbnRyb2xsZWQpIHtcbiAgICAgIHNldENvbnRyb2xsZWRUcmFuc2l0aW9uKGNvbnRyb2xsZWQpO1xuICAgIH1cbiAgfSxcbn07XG52YXIgQ29udHJvbGxlciQxID0ge1xuICBuYW1lOiAnY29udHJvbGxlcicsXG4gIHBhcmFtczoge1xuICAgIGNvbnRyb2xsZXI6IHtcbiAgICAgIGNvbnRyb2w6IHVuZGVmaW5lZCxcbiAgICAgIGludmVyc2U6IGZhbHNlLFxuICAgICAgYnk6ICdzbGlkZScsIC8vIG9yICdjb250YWluZXInXG4gICAgfSxcbiAgfSxcbiAgY3JlYXRlKCkge1xuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgVXRpbHMuZXh0ZW5kKHN3aXBlciwge1xuICAgICAgY29udHJvbGxlcjoge1xuICAgICAgICBjb250cm9sOiBzd2lwZXIucGFyYW1zLmNvbnRyb2xsZXIuY29udHJvbCxcbiAgICAgICAgZ2V0SW50ZXJwb2xhdGVGdW5jdGlvbjogQ29udHJvbGxlci5nZXRJbnRlcnBvbGF0ZUZ1bmN0aW9uLmJpbmQoc3dpcGVyKSxcbiAgICAgICAgc2V0VHJhbnNsYXRlOiBDb250cm9sbGVyLnNldFRyYW5zbGF0ZS5iaW5kKHN3aXBlciksXG4gICAgICAgIHNldFRyYW5zaXRpb246IENvbnRyb2xsZXIuc2V0VHJhbnNpdGlvbi5iaW5kKHN3aXBlciksXG4gICAgICB9LFxuICAgIH0pO1xuICB9LFxuICBvbjoge1xuICAgIHVwZGF0ZSgpIHtcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgICBpZiAoIXN3aXBlci5jb250cm9sbGVyLmNvbnRyb2wpIHJldHVybjtcbiAgICAgIGlmIChzd2lwZXIuY29udHJvbGxlci5zcGxpbmUpIHtcbiAgICAgICAgc3dpcGVyLmNvbnRyb2xsZXIuc3BsaW5lID0gdW5kZWZpbmVkO1xuICAgICAgICBkZWxldGUgc3dpcGVyLmNvbnRyb2xsZXIuc3BsaW5lO1xuICAgICAgfVxuICAgIH0sXG4gICAgcmVzaXplKCkge1xuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICAgIGlmICghc3dpcGVyLmNvbnRyb2xsZXIuY29udHJvbCkgcmV0dXJuO1xuICAgICAgaWYgKHN3aXBlci5jb250cm9sbGVyLnNwbGluZSkge1xuICAgICAgICBzd2lwZXIuY29udHJvbGxlci5zcGxpbmUgPSB1bmRlZmluZWQ7XG4gICAgICAgIGRlbGV0ZSBzd2lwZXIuY29udHJvbGxlci5zcGxpbmU7XG4gICAgICB9XG4gICAgfSxcbiAgICBvYnNlcnZlclVwZGF0ZSgpIHtcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgICBpZiAoIXN3aXBlci5jb250cm9sbGVyLmNvbnRyb2wpIHJldHVybjtcbiAgICAgIGlmIChzd2lwZXIuY29udHJvbGxlci5zcGxpbmUpIHtcbiAgICAgICAgc3dpcGVyLmNvbnRyb2xsZXIuc3BsaW5lID0gdW5kZWZpbmVkO1xuICAgICAgICBkZWxldGUgc3dpcGVyLmNvbnRyb2xsZXIuc3BsaW5lO1xuICAgICAgfVxuICAgIH0sXG4gICAgc2V0VHJhbnNsYXRlKHRyYW5zbGF0ZSwgYnlDb250cm9sbGVyKSB7XG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgICAgaWYgKCFzd2lwZXIuY29udHJvbGxlci5jb250cm9sKSByZXR1cm47XG4gICAgICBzd2lwZXIuY29udHJvbGxlci5zZXRUcmFuc2xhdGUodHJhbnNsYXRlLCBieUNvbnRyb2xsZXIpO1xuICAgIH0sXG4gICAgc2V0VHJhbnNpdGlvbihkdXJhdGlvbiwgYnlDb250cm9sbGVyKSB7XG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgICAgaWYgKCFzd2lwZXIuY29udHJvbGxlci5jb250cm9sKSByZXR1cm47XG4gICAgICBzd2lwZXIuY29udHJvbGxlci5zZXRUcmFuc2l0aW9uKGR1cmF0aW9uLCBieUNvbnRyb2xsZXIpO1xuICAgIH0sXG4gIH0sXG59O1xuXG5jb25zdCBhMTF5ID0ge1xuICBtYWtlRWxGb2N1c2FibGUoJGVsKSB7XG4gICAgJGVsLmF0dHIoJ3RhYkluZGV4JywgJzAnKTtcbiAgICByZXR1cm4gJGVsO1xuICB9LFxuICBhZGRFbFJvbGUoJGVsLCByb2xlKSB7XG4gICAgJGVsLmF0dHIoJ3JvbGUnLCByb2xlKTtcbiAgICByZXR1cm4gJGVsO1xuICB9LFxuICBhZGRFbExhYmVsKCRlbCwgbGFiZWwpIHtcbiAgICAkZWwuYXR0cignYXJpYS1sYWJlbCcsIGxhYmVsKTtcbiAgICByZXR1cm4gJGVsO1xuICB9LFxuICBkaXNhYmxlRWwoJGVsKSB7XG4gICAgJGVsLmF0dHIoJ2FyaWEtZGlzYWJsZWQnLCB0cnVlKTtcbiAgICByZXR1cm4gJGVsO1xuICB9LFxuICBlbmFibGVFbCgkZWwpIHtcbiAgICAkZWwuYXR0cignYXJpYS1kaXNhYmxlZCcsIGZhbHNlKTtcbiAgICByZXR1cm4gJGVsO1xuICB9LFxuICBvbkVudGVyS2V5KGUpIHtcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgIGNvbnN0IHBhcmFtcyA9IHN3aXBlci5wYXJhbXMuYTExeTtcbiAgICBpZiAoZS5rZXlDb2RlICE9PSAxMykgcmV0dXJuO1xuICAgIGNvbnN0ICR0YXJnZXRFbCA9ICQoZS50YXJnZXQpO1xuICAgIGlmIChzd2lwZXIubmF2aWdhdGlvbiAmJiBzd2lwZXIubmF2aWdhdGlvbi4kbmV4dEVsICYmICR0YXJnZXRFbC5pcyhzd2lwZXIubmF2aWdhdGlvbi4kbmV4dEVsKSkge1xuICAgICAgaWYgKCEoc3dpcGVyLmlzRW5kICYmICFzd2lwZXIucGFyYW1zLmxvb3ApKSB7XG4gICAgICAgIHN3aXBlci5zbGlkZU5leHQoKTtcbiAgICAgIH1cbiAgICAgIGlmIChzd2lwZXIuaXNFbmQpIHtcbiAgICAgICAgc3dpcGVyLmExMXkubm90aWZ5KHBhcmFtcy5sYXN0U2xpZGVNZXNzYWdlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN3aXBlci5hMTF5Lm5vdGlmeShwYXJhbXMubmV4dFNsaWRlTWVzc2FnZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzd2lwZXIubmF2aWdhdGlvbiAmJiBzd2lwZXIubmF2aWdhdGlvbi4kcHJldkVsICYmICR0YXJnZXRFbC5pcyhzd2lwZXIubmF2aWdhdGlvbi4kcHJldkVsKSkge1xuICAgICAgaWYgKCEoc3dpcGVyLmlzQmVnaW5uaW5nICYmICFzd2lwZXIucGFyYW1zLmxvb3ApKSB7XG4gICAgICAgIHN3aXBlci5zbGlkZVByZXYoKTtcbiAgICAgIH1cbiAgICAgIGlmIChzd2lwZXIuaXNCZWdpbm5pbmcpIHtcbiAgICAgICAgc3dpcGVyLmExMXkubm90aWZ5KHBhcmFtcy5maXJzdFNsaWRlTWVzc2FnZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzd2lwZXIuYTExeS5ub3RpZnkocGFyYW1zLnByZXZTbGlkZU1lc3NhZ2UpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc3dpcGVyLnBhZ2luYXRpb24gJiYgJHRhcmdldEVsLmlzKGAuJHtzd2lwZXIucGFyYW1zLnBhZ2luYXRpb24uYnVsbGV0Q2xhc3N9YCkpIHtcbiAgICAgICR0YXJnZXRFbFswXS5jbGljaygpO1xuICAgIH1cbiAgfSxcbiAgbm90aWZ5KG1lc3NhZ2UpIHtcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgIGNvbnN0IG5vdGlmaWNhdGlvbiA9IHN3aXBlci5hMTF5LmxpdmVSZWdpb247XG4gICAgaWYgKG5vdGlmaWNhdGlvbi5sZW5ndGggPT09IDApIHJldHVybjtcbiAgICBub3RpZmljYXRpb24uaHRtbCgnJyk7XG4gICAgbm90aWZpY2F0aW9uLmh0bWwobWVzc2FnZSk7XG4gIH0sXG4gIHVwZGF0ZU5hdmlnYXRpb24oKSB7XG4gICAgY29uc3Qgc3dpcGVyID0gdGhpcztcblxuICAgIGlmIChzd2lwZXIucGFyYW1zLmxvb3ApIHJldHVybjtcbiAgICBjb25zdCB7ICRuZXh0RWwsICRwcmV2RWwgfSA9IHN3aXBlci5uYXZpZ2F0aW9uO1xuXG4gICAgaWYgKCRwcmV2RWwgJiYgJHByZXZFbC5sZW5ndGggPiAwKSB7XG4gICAgICBpZiAoc3dpcGVyLmlzQmVnaW5uaW5nKSB7XG4gICAgICAgIHN3aXBlci5hMTF5LmRpc2FibGVFbCgkcHJldkVsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN3aXBlci5hMTF5LmVuYWJsZUVsKCRwcmV2RWwpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoJG5leHRFbCAmJiAkbmV4dEVsLmxlbmd0aCA+IDApIHtcbiAgICAgIGlmIChzd2lwZXIuaXNFbmQpIHtcbiAgICAgICAgc3dpcGVyLmExMXkuZGlzYWJsZUVsKCRuZXh0RWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3dpcGVyLmExMXkuZW5hYmxlRWwoJG5leHRFbCk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICB1cGRhdGVQYWdpbmF0aW9uKCkge1xuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgY29uc3QgcGFyYW1zID0gc3dpcGVyLnBhcmFtcy5hMTF5O1xuICAgIGlmIChzd2lwZXIucGFnaW5hdGlvbiAmJiBzd2lwZXIucGFyYW1zLnBhZ2luYXRpb24uY2xpY2thYmxlICYmIHN3aXBlci5wYWdpbmF0aW9uLmJ1bGxldHMgJiYgc3dpcGVyLnBhZ2luYXRpb24uYnVsbGV0cy5sZW5ndGgpIHtcbiAgICAgIHN3aXBlci5wYWdpbmF0aW9uLmJ1bGxldHMuZWFjaCgoYnVsbGV0SW5kZXgsIGJ1bGxldEVsKSA9PiB7XG4gICAgICAgIGNvbnN0ICRidWxsZXRFbCA9ICQoYnVsbGV0RWwpO1xuICAgICAgICBzd2lwZXIuYTExeS5tYWtlRWxGb2N1c2FibGUoJGJ1bGxldEVsKTtcbiAgICAgICAgc3dpcGVyLmExMXkuYWRkRWxSb2xlKCRidWxsZXRFbCwgJ2J1dHRvbicpO1xuICAgICAgICBzd2lwZXIuYTExeS5hZGRFbExhYmVsKCRidWxsZXRFbCwgcGFyYW1zLnBhZ2luYXRpb25CdWxsZXRNZXNzYWdlLnJlcGxhY2UoL3t7aW5kZXh9fS8sICRidWxsZXRFbC5pbmRleCgpICsgMSkpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LFxuICBpbml0KCkge1xuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG5cbiAgICBzd2lwZXIuJGVsLmFwcGVuZChzd2lwZXIuYTExeS5saXZlUmVnaW9uKTtcblxuICAgIC8vIE5hdmlnYXRpb25cbiAgICBjb25zdCBwYXJhbXMgPSBzd2lwZXIucGFyYW1zLmExMXk7XG4gICAgbGV0ICRuZXh0RWw7XG4gICAgbGV0ICRwcmV2RWw7XG4gICAgaWYgKHN3aXBlci5uYXZpZ2F0aW9uICYmIHN3aXBlci5uYXZpZ2F0aW9uLiRuZXh0RWwpIHtcbiAgICAgICRuZXh0RWwgPSBzd2lwZXIubmF2aWdhdGlvbi4kbmV4dEVsO1xuICAgIH1cbiAgICBpZiAoc3dpcGVyLm5hdmlnYXRpb24gJiYgc3dpcGVyLm5hdmlnYXRpb24uJHByZXZFbCkge1xuICAgICAgJHByZXZFbCA9IHN3aXBlci5uYXZpZ2F0aW9uLiRwcmV2RWw7XG4gICAgfVxuICAgIGlmICgkbmV4dEVsKSB7XG4gICAgICBzd2lwZXIuYTExeS5tYWtlRWxGb2N1c2FibGUoJG5leHRFbCk7XG4gICAgICBzd2lwZXIuYTExeS5hZGRFbFJvbGUoJG5leHRFbCwgJ2J1dHRvbicpO1xuICAgICAgc3dpcGVyLmExMXkuYWRkRWxMYWJlbCgkbmV4dEVsLCBwYXJhbXMubmV4dFNsaWRlTWVzc2FnZSk7XG4gICAgICAkbmV4dEVsLm9uKCdrZXlkb3duJywgc3dpcGVyLmExMXkub25FbnRlcktleSk7XG4gICAgfVxuICAgIGlmICgkcHJldkVsKSB7XG4gICAgICBzd2lwZXIuYTExeS5tYWtlRWxGb2N1c2FibGUoJHByZXZFbCk7XG4gICAgICBzd2lwZXIuYTExeS5hZGRFbFJvbGUoJHByZXZFbCwgJ2J1dHRvbicpO1xuICAgICAgc3dpcGVyLmExMXkuYWRkRWxMYWJlbCgkcHJldkVsLCBwYXJhbXMucHJldlNsaWRlTWVzc2FnZSk7XG4gICAgICAkcHJldkVsLm9uKCdrZXlkb3duJywgc3dpcGVyLmExMXkub25FbnRlcktleSk7XG4gICAgfVxuXG4gICAgLy8gUGFnaW5hdGlvblxuICAgIGlmIChzd2lwZXIucGFnaW5hdGlvbiAmJiBzd2lwZXIucGFyYW1zLnBhZ2luYXRpb24uY2xpY2thYmxlICYmIHN3aXBlci5wYWdpbmF0aW9uLmJ1bGxldHMgJiYgc3dpcGVyLnBhZ2luYXRpb24uYnVsbGV0cy5sZW5ndGgpIHtcbiAgICAgIHN3aXBlci5wYWdpbmF0aW9uLiRlbC5vbigna2V5ZG93bicsIGAuJHtzd2lwZXIucGFyYW1zLnBhZ2luYXRpb24uYnVsbGV0Q2xhc3N9YCwgc3dpcGVyLmExMXkub25FbnRlcktleSk7XG4gICAgfVxuICB9LFxuICBkZXN0cm95KCkge1xuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgaWYgKHN3aXBlci5hMTF5LmxpdmVSZWdpb24gJiYgc3dpcGVyLmExMXkubGl2ZVJlZ2lvbi5sZW5ndGggPiAwKSBzd2lwZXIuYTExeS5saXZlUmVnaW9uLnJlbW92ZSgpO1xuXG4gICAgbGV0ICRuZXh0RWw7XG4gICAgbGV0ICRwcmV2RWw7XG4gICAgaWYgKHN3aXBlci5uYXZpZ2F0aW9uICYmIHN3aXBlci5uYXZpZ2F0aW9uLiRuZXh0RWwpIHtcbiAgICAgICRuZXh0RWwgPSBzd2lwZXIubmF2aWdhdGlvbi4kbmV4dEVsO1xuICAgIH1cbiAgICBpZiAoc3dpcGVyLm5hdmlnYXRpb24gJiYgc3dpcGVyLm5hdmlnYXRpb24uJHByZXZFbCkge1xuICAgICAgJHByZXZFbCA9IHN3aXBlci5uYXZpZ2F0aW9uLiRwcmV2RWw7XG4gICAgfVxuICAgIGlmICgkbmV4dEVsKSB7XG4gICAgICAkbmV4dEVsLm9mZigna2V5ZG93bicsIHN3aXBlci5hMTF5Lm9uRW50ZXJLZXkpO1xuICAgIH1cbiAgICBpZiAoJHByZXZFbCkge1xuICAgICAgJHByZXZFbC5vZmYoJ2tleWRvd24nLCBzd2lwZXIuYTExeS5vbkVudGVyS2V5KTtcbiAgICB9XG5cbiAgICAvLyBQYWdpbmF0aW9uXG4gICAgaWYgKHN3aXBlci5wYWdpbmF0aW9uICYmIHN3aXBlci5wYXJhbXMucGFnaW5hdGlvbi5jbGlja2FibGUgJiYgc3dpcGVyLnBhZ2luYXRpb24uYnVsbGV0cyAmJiBzd2lwZXIucGFnaW5hdGlvbi5idWxsZXRzLmxlbmd0aCkge1xuICAgICAgc3dpcGVyLnBhZ2luYXRpb24uJGVsLm9mZigna2V5ZG93bicsIGAuJHtzd2lwZXIucGFyYW1zLnBhZ2luYXRpb24uYnVsbGV0Q2xhc3N9YCwgc3dpcGVyLmExMXkub25FbnRlcktleSk7XG4gICAgfVxuICB9LFxufTtcbnZhciBBMTF5ID0ge1xuICBuYW1lOiAnYTExeScsXG4gIHBhcmFtczoge1xuICAgIGExMXk6IHtcbiAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICBub3RpZmljYXRpb25DbGFzczogJ3N3aXBlci1ub3RpZmljYXRpb24nLFxuICAgICAgcHJldlNsaWRlTWVzc2FnZTogJ1ByZXZpb3VzIHNsaWRlJyxcbiAgICAgIG5leHRTbGlkZU1lc3NhZ2U6ICdOZXh0IHNsaWRlJyxcbiAgICAgIGZpcnN0U2xpZGVNZXNzYWdlOiAnVGhpcyBpcyB0aGUgZmlyc3Qgc2xpZGUnLFxuICAgICAgbGFzdFNsaWRlTWVzc2FnZTogJ1RoaXMgaXMgdGhlIGxhc3Qgc2xpZGUnLFxuICAgICAgcGFnaW5hdGlvbkJ1bGxldE1lc3NhZ2U6ICdHbyB0byBzbGlkZSB7e2luZGV4fX0nLFxuICAgIH0sXG4gIH0sXG4gIGNyZWF0ZSgpIHtcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgIFV0aWxzLmV4dGVuZChzd2lwZXIsIHtcbiAgICAgIGExMXk6IHtcbiAgICAgICAgbGl2ZVJlZ2lvbjogJChgPHNwYW4gY2xhc3M9XCIke3N3aXBlci5wYXJhbXMuYTExeS5ub3RpZmljYXRpb25DbGFzc31cIiBhcmlhLWxpdmU9XCJhc3NlcnRpdmVcIiBhcmlhLWF0b21pYz1cInRydWVcIj48L3NwYW4+YCksXG4gICAgICB9LFxuICAgIH0pO1xuICAgIE9iamVjdC5rZXlzKGExMXkpLmZvckVhY2goKG1ldGhvZE5hbWUpID0+IHtcbiAgICAgIHN3aXBlci5hMTF5W21ldGhvZE5hbWVdID0gYTExeVttZXRob2ROYW1lXS5iaW5kKHN3aXBlcik7XG4gICAgfSk7XG4gIH0sXG4gIG9uOiB7XG4gICAgaW5pdCgpIHtcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgICBpZiAoIXN3aXBlci5wYXJhbXMuYTExeS5lbmFibGVkKSByZXR1cm47XG4gICAgICBzd2lwZXIuYTExeS5pbml0KCk7XG4gICAgICBzd2lwZXIuYTExeS51cGRhdGVOYXZpZ2F0aW9uKCk7XG4gICAgfSxcbiAgICB0b0VkZ2UoKSB7XG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgICAgaWYgKCFzd2lwZXIucGFyYW1zLmExMXkuZW5hYmxlZCkgcmV0dXJuO1xuICAgICAgc3dpcGVyLmExMXkudXBkYXRlTmF2aWdhdGlvbigpO1xuICAgIH0sXG4gICAgZnJvbUVkZ2UoKSB7XG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgICAgaWYgKCFzd2lwZXIucGFyYW1zLmExMXkuZW5hYmxlZCkgcmV0dXJuO1xuICAgICAgc3dpcGVyLmExMXkudXBkYXRlTmF2aWdhdGlvbigpO1xuICAgIH0sXG4gICAgcGFnaW5hdGlvblVwZGF0ZSgpIHtcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgICBpZiAoIXN3aXBlci5wYXJhbXMuYTExeS5lbmFibGVkKSByZXR1cm47XG4gICAgICBzd2lwZXIuYTExeS51cGRhdGVQYWdpbmF0aW9uKCk7XG4gICAgfSxcbiAgICBkZXN0cm95KCkge1xuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICAgIGlmICghc3dpcGVyLnBhcmFtcy5hMTF5LmVuYWJsZWQpIHJldHVybjtcbiAgICAgIHN3aXBlci5hMTF5LmRlc3Ryb3koKTtcbiAgICB9LFxuICB9LFxufTtcblxuLyogZXNsaW50IG5vLXVuZGVyc2NvcmUtZGFuZ2xlOiBcIm9mZlwiICovXG5cbmNvbnN0IEF1dG9wbGF5ID0ge1xuICBydW4oKSB7XG4gICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICBjb25zdCAkYWN0aXZlU2xpZGVFbCA9IHN3aXBlci5zbGlkZXMuZXEoc3dpcGVyLmFjdGl2ZUluZGV4KTtcbiAgICBsZXQgZGVsYXkgPSBzd2lwZXIucGFyYW1zLmF1dG9wbGF5LmRlbGF5O1xuICAgIGlmICgkYWN0aXZlU2xpZGVFbC5hdHRyKCdkYXRhLXN3aXBlci1hdXRvcGxheScpKSB7XG4gICAgICBkZWxheSA9ICRhY3RpdmVTbGlkZUVsLmF0dHIoJ2RhdGEtc3dpcGVyLWF1dG9wbGF5JykgfHwgc3dpcGVyLnBhcmFtcy5hdXRvcGxheS5kZWxheTtcbiAgICB9XG4gICAgc3dpcGVyLmF1dG9wbGF5LnRpbWVvdXQgPSBVdGlscy5uZXh0VGljaygoKSA9PiB7XG4gICAgICBpZiAoc3dpcGVyLnBhcmFtcy5hdXRvcGxheS5yZXZlcnNlRGlyZWN0aW9uKSB7XG4gICAgICAgIGlmIChzd2lwZXIucGFyYW1zLmxvb3ApIHtcbiAgICAgICAgICBzd2lwZXIubG9vcEZpeCgpO1xuICAgICAgICAgIHN3aXBlci5zbGlkZVByZXYoc3dpcGVyLnBhcmFtcy5zcGVlZCwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICAgc3dpcGVyLmVtaXQoJ2F1dG9wbGF5Jyk7XG4gICAgICAgIH0gZWxzZSBpZiAoIXN3aXBlci5pc0JlZ2lubmluZykge1xuICAgICAgICAgIHN3aXBlci5zbGlkZVByZXYoc3dpcGVyLnBhcmFtcy5zcGVlZCwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICAgc3dpcGVyLmVtaXQoJ2F1dG9wbGF5Jyk7XG4gICAgICAgIH0gZWxzZSBpZiAoIXN3aXBlci5wYXJhbXMuYXV0b3BsYXkuc3RvcE9uTGFzdFNsaWRlKSB7XG4gICAgICAgICAgc3dpcGVyLnNsaWRlVG8oc3dpcGVyLnNsaWRlcy5sZW5ndGggLSAxLCBzd2lwZXIucGFyYW1zLnNwZWVkLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICBzd2lwZXIuZW1pdCgnYXV0b3BsYXknKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzd2lwZXIuYXV0b3BsYXkuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHN3aXBlci5wYXJhbXMubG9vcCkge1xuICAgICAgICBzd2lwZXIubG9vcEZpeCgpO1xuICAgICAgICBzd2lwZXIuc2xpZGVOZXh0KHN3aXBlci5wYXJhbXMuc3BlZWQsIHRydWUsIHRydWUpO1xuICAgICAgICBzd2lwZXIuZW1pdCgnYXV0b3BsYXknKTtcbiAgICAgIH0gZWxzZSBpZiAoIXN3aXBlci5pc0VuZCkge1xuICAgICAgICBzd2lwZXIuc2xpZGVOZXh0KHN3aXBlci5wYXJhbXMuc3BlZWQsIHRydWUsIHRydWUpO1xuICAgICAgICBzd2lwZXIuZW1pdCgnYXV0b3BsYXknKTtcbiAgICAgIH0gZWxzZSBpZiAoIXN3aXBlci5wYXJhbXMuYXV0b3BsYXkuc3RvcE9uTGFzdFNsaWRlKSB7XG4gICAgICAgIHN3aXBlci5zbGlkZVRvKDAsIHN3aXBlci5wYXJhbXMuc3BlZWQsIHRydWUsIHRydWUpO1xuICAgICAgICBzd2lwZXIuZW1pdCgnYXV0b3BsYXknKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN3aXBlci5hdXRvcGxheS5zdG9wKCk7XG4gICAgICB9XG4gICAgfSwgZGVsYXkpO1xuICB9LFxuICBzdGFydCgpIHtcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgIGlmICh0eXBlb2Ygc3dpcGVyLmF1dG9wbGF5LnRpbWVvdXQgIT09ICd1bmRlZmluZWQnKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHN3aXBlci5hdXRvcGxheS5ydW5uaW5nKSByZXR1cm4gZmFsc2U7XG4gICAgc3dpcGVyLmF1dG9wbGF5LnJ1bm5pbmcgPSB0cnVlO1xuICAgIHN3aXBlci5lbWl0KCdhdXRvcGxheVN0YXJ0Jyk7XG4gICAgc3dpcGVyLmF1dG9wbGF5LnJ1bigpO1xuICAgIHJldHVybiB0cnVlO1xuICB9LFxuICBzdG9wKCkge1xuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgaWYgKCFzd2lwZXIuYXV0b3BsYXkucnVubmluZykgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh0eXBlb2Ygc3dpcGVyLmF1dG9wbGF5LnRpbWVvdXQgPT09ICd1bmRlZmluZWQnKSByZXR1cm4gZmFsc2U7XG5cbiAgICBpZiAoc3dpcGVyLmF1dG9wbGF5LnRpbWVvdXQpIHtcbiAgICAgIGNsZWFyVGltZW91dChzd2lwZXIuYXV0b3BsYXkudGltZW91dCk7XG4gICAgICBzd2lwZXIuYXV0b3BsYXkudGltZW91dCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgc3dpcGVyLmF1dG9wbGF5LnJ1bm5pbmcgPSBmYWxzZTtcbiAgICBzd2lwZXIuZW1pdCgnYXV0b3BsYXlTdG9wJyk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG4gIHBhdXNlKHNwZWVkKSB7XG4gICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICBpZiAoIXN3aXBlci5hdXRvcGxheS5ydW5uaW5nKSByZXR1cm47XG4gICAgaWYgKHN3aXBlci5hdXRvcGxheS5wYXVzZWQpIHJldHVybjtcbiAgICBpZiAoc3dpcGVyLmF1dG9wbGF5LnRpbWVvdXQpIGNsZWFyVGltZW91dChzd2lwZXIuYXV0b3BsYXkudGltZW91dCk7XG4gICAgc3dpcGVyLmF1dG9wbGF5LnBhdXNlZCA9IHRydWU7XG4gICAgaWYgKHNwZWVkID09PSAwIHx8ICFzd2lwZXIucGFyYW1zLmF1dG9wbGF5LndhaXRGb3JUcmFuc2l0aW9uKSB7XG4gICAgICBzd2lwZXIuYXV0b3BsYXkucGF1c2VkID0gZmFsc2U7XG4gICAgICBzd2lwZXIuYXV0b3BsYXkucnVuKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN3aXBlci4kd3JhcHBlckVsWzBdLmFkZEV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCBzd2lwZXIuYXV0b3BsYXkub25UcmFuc2l0aW9uRW5kKTtcbiAgICAgIHN3aXBlci4kd3JhcHBlckVsWzBdLmFkZEV2ZW50TGlzdGVuZXIoJ3dlYmtpdFRyYW5zaXRpb25FbmQnLCBzd2lwZXIuYXV0b3BsYXkub25UcmFuc2l0aW9uRW5kKTtcbiAgICB9XG4gIH0sXG59O1xuXG52YXIgQXV0b3BsYXkkMSA9IHtcbiAgbmFtZTogJ2F1dG9wbGF5JyxcbiAgcGFyYW1zOiB7XG4gICAgYXV0b3BsYXk6IHtcbiAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgZGVsYXk6IDMwMDAsXG4gICAgICB3YWl0Rm9yVHJhbnNpdGlvbjogdHJ1ZSxcbiAgICAgIGRpc2FibGVPbkludGVyYWN0aW9uOiB0cnVlLFxuICAgICAgc3RvcE9uTGFzdFNsaWRlOiBmYWxzZSxcbiAgICAgIHJldmVyc2VEaXJlY3Rpb246IGZhbHNlLFxuICAgIH0sXG4gIH0sXG4gIGNyZWF0ZSgpIHtcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgIFV0aWxzLmV4dGVuZChzd2lwZXIsIHtcbiAgICAgIGF1dG9wbGF5OiB7XG4gICAgICAgIHJ1bm5pbmc6IGZhbHNlLFxuICAgICAgICBwYXVzZWQ6IGZhbHNlLFxuICAgICAgICBydW46IEF1dG9wbGF5LnJ1bi5iaW5kKHN3aXBlciksXG4gICAgICAgIHN0YXJ0OiBBdXRvcGxheS5zdGFydC5iaW5kKHN3aXBlciksXG4gICAgICAgIHN0b3A6IEF1dG9wbGF5LnN0b3AuYmluZChzd2lwZXIpLFxuICAgICAgICBwYXVzZTogQXV0b3BsYXkucGF1c2UuYmluZChzd2lwZXIpLFxuICAgICAgICBvblRyYW5zaXRpb25FbmQoZSkge1xuICAgICAgICAgIGlmICghc3dpcGVyIHx8IHN3aXBlci5kZXN0cm95ZWQgfHwgIXN3aXBlci4kd3JhcHBlckVsKSByZXR1cm47XG4gICAgICAgICAgaWYgKGUudGFyZ2V0ICE9PSB0aGlzKSByZXR1cm47XG4gICAgICAgICAgc3dpcGVyLiR3cmFwcGVyRWxbMF0ucmVtb3ZlRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIHN3aXBlci5hdXRvcGxheS5vblRyYW5zaXRpb25FbmQpO1xuICAgICAgICAgIHN3aXBlci4kd3JhcHBlckVsWzBdLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3dlYmtpdFRyYW5zaXRpb25FbmQnLCBzd2lwZXIuYXV0b3BsYXkub25UcmFuc2l0aW9uRW5kKTtcbiAgICAgICAgICBzd2lwZXIuYXV0b3BsYXkucGF1c2VkID0gZmFsc2U7XG4gICAgICAgICAgaWYgKCFzd2lwZXIuYXV0b3BsYXkucnVubmluZykge1xuICAgICAgICAgICAgc3dpcGVyLmF1dG9wbGF5LnN0b3AoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3dpcGVyLmF1dG9wbGF5LnJ1bigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgfSk7XG4gIH0sXG4gIG9uOiB7XG4gICAgaW5pdCgpIHtcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgICBpZiAoc3dpcGVyLnBhcmFtcy5hdXRvcGxheS5lbmFibGVkKSB7XG4gICAgICAgIHN3aXBlci5hdXRvcGxheS5zdGFydCgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgYmVmb3JlVHJhbnNpdGlvblN0YXJ0KHNwZWVkLCBpbnRlcm5hbCkge1xuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICAgIGlmIChzd2lwZXIuYXV0b3BsYXkucnVubmluZykge1xuICAgICAgICBpZiAoaW50ZXJuYWwgfHwgIXN3aXBlci5wYXJhbXMuYXV0b3BsYXkuZGlzYWJsZU9uSW50ZXJhY3Rpb24pIHtcbiAgICAgICAgICBzd2lwZXIuYXV0b3BsYXkucGF1c2Uoc3BlZWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN3aXBlci5hdXRvcGxheS5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIHNsaWRlckZpcnN0TW92ZSgpIHtcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgICBpZiAoc3dpcGVyLmF1dG9wbGF5LnJ1bm5pbmcpIHtcbiAgICAgICAgaWYgKHN3aXBlci5wYXJhbXMuYXV0b3BsYXkuZGlzYWJsZU9uSW50ZXJhY3Rpb24pIHtcbiAgICAgICAgICBzd2lwZXIuYXV0b3BsYXkuc3RvcCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN3aXBlci5hdXRvcGxheS5wYXVzZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBkZXN0cm95KCkge1xuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICAgIGlmIChzd2lwZXIuYXV0b3BsYXkucnVubmluZykge1xuICAgICAgICBzd2lwZXIuYXV0b3BsYXkuc3RvcCgpO1xuICAgICAgfVxuICAgIH0sXG4gIH0sXG59O1xuXG5jb25zdCBGYWRlID0ge1xuICBzZXRUcmFuc2xhdGUoKSB7XG4gICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICBjb25zdCB7IHNsaWRlcyB9ID0gc3dpcGVyO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2xpZGVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBjb25zdCAkc2xpZGVFbCA9IHN3aXBlci5zbGlkZXMuZXEoaSk7XG4gICAgICBjb25zdCBvZmZzZXQgPSAkc2xpZGVFbFswXS5zd2lwZXJTbGlkZU9mZnNldDtcbiAgICAgIGxldCB0eCA9IC1vZmZzZXQ7XG4gICAgICBpZiAoIXN3aXBlci5wYXJhbXMudmlydHVhbFRyYW5zbGF0ZSkgdHggLT0gc3dpcGVyLnRyYW5zbGF0ZTtcbiAgICAgIGxldCB0eSA9IDA7XG4gICAgICBpZiAoIXN3aXBlci5pc0hvcml6b250YWwoKSkge1xuICAgICAgICB0eSA9IHR4O1xuICAgICAgICB0eCA9IDA7XG4gICAgICB9XG4gICAgICBjb25zdCBzbGlkZU9wYWNpdHkgPSBzd2lwZXIucGFyYW1zLmZhZGVFZmZlY3QuY3Jvc3NGYWRlID9cbiAgICAgICAgTWF0aC5tYXgoMSAtIE1hdGguYWJzKCRzbGlkZUVsWzBdLnByb2dyZXNzKSwgMCkgOlxuICAgICAgICAxICsgTWF0aC5taW4oTWF0aC5tYXgoJHNsaWRlRWxbMF0ucHJvZ3Jlc3MsIC0xKSwgMCk7XG4gICAgICAkc2xpZGVFbFxuICAgICAgICAuY3NzKHtcbiAgICAgICAgICBvcGFjaXR5OiBzbGlkZU9wYWNpdHksXG4gICAgICAgIH0pXG4gICAgICAgIC50cmFuc2Zvcm0oYHRyYW5zbGF0ZTNkKCR7dHh9cHgsICR7dHl9cHgsIDBweClgKTtcbiAgICB9XG4gIH0sXG4gIHNldFRyYW5zaXRpb24oZHVyYXRpb24pIHtcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgIGNvbnN0IHsgc2xpZGVzLCAkd3JhcHBlckVsIH0gPSBzd2lwZXI7XG4gICAgc2xpZGVzLnRyYW5zaXRpb24oZHVyYXRpb24pO1xuICAgIGlmIChzd2lwZXIucGFyYW1zLnZpcnR1YWxUcmFuc2xhdGUgJiYgZHVyYXRpb24gIT09IDApIHtcbiAgICAgIGxldCBldmVudFRyaWdnZXJlZCA9IGZhbHNlO1xuICAgICAgc2xpZGVzLnRyYW5zaXRpb25FbmQoKCkgPT4ge1xuICAgICAgICBpZiAoZXZlbnRUcmlnZ2VyZWQpIHJldHVybjtcbiAgICAgICAgaWYgKCFzd2lwZXIgfHwgc3dpcGVyLmRlc3Ryb3llZCkgcmV0dXJuO1xuICAgICAgICBldmVudFRyaWdnZXJlZCA9IHRydWU7XG4gICAgICAgIHN3aXBlci5hbmltYXRpbmcgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgdHJpZ2dlckV2ZW50cyA9IFsnd2Via2l0VHJhbnNpdGlvbkVuZCcsICd0cmFuc2l0aW9uZW5kJ107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHJpZ2dlckV2ZW50cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICR3cmFwcGVyRWwudHJpZ2dlcih0cmlnZ2VyRXZlbnRzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9LFxufTtcblxudmFyIEVmZmVjdEZhZGUgPSB7XG4gIG5hbWU6ICdlZmZlY3QtZmFkZScsXG4gIHBhcmFtczoge1xuICAgIGZhZGVFZmZlY3Q6IHtcbiAgICAgIGNyb3NzRmFkZTogZmFsc2UsXG4gICAgfSxcbiAgfSxcbiAgY3JlYXRlKCkge1xuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgVXRpbHMuZXh0ZW5kKHN3aXBlciwge1xuICAgICAgZmFkZUVmZmVjdDoge1xuICAgICAgICBzZXRUcmFuc2xhdGU6IEZhZGUuc2V0VHJhbnNsYXRlLmJpbmQoc3dpcGVyKSxcbiAgICAgICAgc2V0VHJhbnNpdGlvbjogRmFkZS5zZXRUcmFuc2l0aW9uLmJpbmQoc3dpcGVyKSxcbiAgICAgIH0sXG4gICAgfSk7XG4gIH0sXG4gIG9uOiB7XG4gICAgYmVmb3JlSW5pdCgpIHtcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgICBpZiAoc3dpcGVyLnBhcmFtcy5lZmZlY3QgIT09ICdmYWRlJykgcmV0dXJuO1xuICAgICAgc3dpcGVyLmNsYXNzTmFtZXMucHVzaChgJHtzd2lwZXIucGFyYW1zLmNvbnRhaW5lck1vZGlmaWVyQ2xhc3N9ZmFkZWApO1xuICAgICAgY29uc3Qgb3ZlcndyaXRlUGFyYW1zID0ge1xuICAgICAgICBzbGlkZXNQZXJWaWV3OiAxLFxuICAgICAgICBzbGlkZXNQZXJDb2x1bW46IDEsXG4gICAgICAgIHNsaWRlc1Blckdyb3VwOiAxLFxuICAgICAgICB3YXRjaFNsaWRlc1Byb2dyZXNzOiB0cnVlLFxuICAgICAgICBzcGFjZUJldHdlZW46IDAsXG4gICAgICAgIHZpcnR1YWxUcmFuc2xhdGU6IHRydWUsXG4gICAgICB9O1xuICAgICAgVXRpbHMuZXh0ZW5kKHN3aXBlci5wYXJhbXMsIG92ZXJ3cml0ZVBhcmFtcyk7XG4gICAgICBVdGlscy5leHRlbmQoc3dpcGVyLm9yaWdpbmFsUGFyYW1zLCBvdmVyd3JpdGVQYXJhbXMpO1xuICAgIH0sXG4gICAgc2V0VHJhbnNsYXRlKCkge1xuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICAgIGlmIChzd2lwZXIucGFyYW1zLmVmZmVjdCAhPT0gJ2ZhZGUnKSByZXR1cm47XG4gICAgICBzd2lwZXIuZmFkZUVmZmVjdC5zZXRUcmFuc2xhdGUoKTtcbiAgICB9LFxuICAgIHNldFRyYW5zaXRpb24oZHVyYXRpb24pIHtcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgICBpZiAoc3dpcGVyLnBhcmFtcy5lZmZlY3QgIT09ICdmYWRlJykgcmV0dXJuO1xuICAgICAgc3dpcGVyLmZhZGVFZmZlY3Quc2V0VHJhbnNpdGlvbihkdXJhdGlvbik7XG4gICAgfSxcbiAgfSxcbn07XG5cbmNvbnN0IEN1YmUgPSB7XG4gIHNldFRyYW5zbGF0ZSgpIHtcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgIGNvbnN0IHtcbiAgICAgICRlbCwgJHdyYXBwZXJFbCwgc2xpZGVzLCB3aWR0aDogc3dpcGVyV2lkdGgsIGhlaWdodDogc3dpcGVySGVpZ2h0LCBydGxUcmFuc2xhdGU6IHJ0bCwgc2l6ZTogc3dpcGVyU2l6ZSxcbiAgICB9ID0gc3dpcGVyO1xuICAgIGNvbnN0IHBhcmFtcyA9IHN3aXBlci5wYXJhbXMuY3ViZUVmZmVjdDtcbiAgICBjb25zdCBpc0hvcml6b250YWwgPSBzd2lwZXIuaXNIb3Jpem9udGFsKCk7XG4gICAgY29uc3QgaXNWaXJ0dWFsID0gc3dpcGVyLnZpcnR1YWwgJiYgc3dpcGVyLnBhcmFtcy52aXJ0dWFsLmVuYWJsZWQ7XG4gICAgbGV0IHdyYXBwZXJSb3RhdGUgPSAwO1xuICAgIGxldCAkY3ViZVNoYWRvd0VsO1xuICAgIGlmIChwYXJhbXMuc2hhZG93KSB7XG4gICAgICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICAgICRjdWJlU2hhZG93RWwgPSAkd3JhcHBlckVsLmZpbmQoJy5zd2lwZXItY3ViZS1zaGFkb3cnKTtcbiAgICAgICAgaWYgKCRjdWJlU2hhZG93RWwubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgJGN1YmVTaGFkb3dFbCA9ICQoJzxkaXYgY2xhc3M9XCJzd2lwZXItY3ViZS1zaGFkb3dcIj48L2Rpdj4nKTtcbiAgICAgICAgICAkd3JhcHBlckVsLmFwcGVuZCgkY3ViZVNoYWRvd0VsKTtcbiAgICAgICAgfVxuICAgICAgICAkY3ViZVNoYWRvd0VsLmNzcyh7IGhlaWdodDogYCR7c3dpcGVyV2lkdGh9cHhgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJGN1YmVTaGFkb3dFbCA9ICRlbC5maW5kKCcuc3dpcGVyLWN1YmUtc2hhZG93Jyk7XG4gICAgICAgIGlmICgkY3ViZVNoYWRvd0VsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICRjdWJlU2hhZG93RWwgPSAkKCc8ZGl2IGNsYXNzPVwic3dpcGVyLWN1YmUtc2hhZG93XCI+PC9kaXY+Jyk7XG4gICAgICAgICAgJGVsLmFwcGVuZCgkY3ViZVNoYWRvd0VsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNsaWRlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgY29uc3QgJHNsaWRlRWwgPSBzbGlkZXMuZXEoaSk7XG4gICAgICBsZXQgc2xpZGVJbmRleCA9IGk7XG4gICAgICBpZiAoaXNWaXJ0dWFsKSB7XG4gICAgICAgIHNsaWRlSW5kZXggPSBwYXJzZUludCgkc2xpZGVFbC5hdHRyKCdkYXRhLXN3aXBlci1zbGlkZS1pbmRleCcpLCAxMCk7XG4gICAgICB9XG4gICAgICBsZXQgc2xpZGVBbmdsZSA9IHNsaWRlSW5kZXggKiA5MDtcbiAgICAgIGxldCByb3VuZCA9IE1hdGguZmxvb3Ioc2xpZGVBbmdsZSAvIDM2MCk7XG4gICAgICBpZiAocnRsKSB7XG4gICAgICAgIHNsaWRlQW5nbGUgPSAtc2xpZGVBbmdsZTtcbiAgICAgICAgcm91bmQgPSBNYXRoLmZsb29yKC1zbGlkZUFuZ2xlIC8gMzYwKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHByb2dyZXNzID0gTWF0aC5tYXgoTWF0aC5taW4oJHNsaWRlRWxbMF0ucHJvZ3Jlc3MsIDEpLCAtMSk7XG4gICAgICBsZXQgdHggPSAwO1xuICAgICAgbGV0IHR5ID0gMDtcbiAgICAgIGxldCB0eiA9IDA7XG4gICAgICBpZiAoc2xpZGVJbmRleCAlIDQgPT09IDApIHtcbiAgICAgICAgdHggPSAtcm91bmQgKiA0ICogc3dpcGVyU2l6ZTtcbiAgICAgICAgdHogPSAwO1xuICAgICAgfSBlbHNlIGlmICgoc2xpZGVJbmRleCAtIDEpICUgNCA9PT0gMCkge1xuICAgICAgICB0eCA9IDA7XG4gICAgICAgIHR6ID0gLXJvdW5kICogNCAqIHN3aXBlclNpemU7XG4gICAgICB9IGVsc2UgaWYgKChzbGlkZUluZGV4IC0gMikgJSA0ID09PSAwKSB7XG4gICAgICAgIHR4ID0gc3dpcGVyU2l6ZSArIChyb3VuZCAqIDQgKiBzd2lwZXJTaXplKTtcbiAgICAgICAgdHogPSBzd2lwZXJTaXplO1xuICAgICAgfSBlbHNlIGlmICgoc2xpZGVJbmRleCAtIDMpICUgNCA9PT0gMCkge1xuICAgICAgICB0eCA9IC1zd2lwZXJTaXplO1xuICAgICAgICB0eiA9ICgzICogc3dpcGVyU2l6ZSkgKyAoc3dpcGVyU2l6ZSAqIDQgKiByb3VuZCk7XG4gICAgICB9XG4gICAgICBpZiAocnRsKSB7XG4gICAgICAgIHR4ID0gLXR4O1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzSG9yaXpvbnRhbCkge1xuICAgICAgICB0eSA9IHR4O1xuICAgICAgICB0eCA9IDA7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IGByb3RhdGVYKCR7aXNIb3Jpem9udGFsID8gMCA6IC1zbGlkZUFuZ2xlfWRlZykgcm90YXRlWSgke2lzSG9yaXpvbnRhbCA/IHNsaWRlQW5nbGUgOiAwfWRlZykgdHJhbnNsYXRlM2QoJHt0eH1weCwgJHt0eX1weCwgJHt0en1weClgO1xuICAgICAgaWYgKHByb2dyZXNzIDw9IDEgJiYgcHJvZ3Jlc3MgPiAtMSkge1xuICAgICAgICB3cmFwcGVyUm90YXRlID0gKHNsaWRlSW5kZXggKiA5MCkgKyAocHJvZ3Jlc3MgKiA5MCk7XG4gICAgICAgIGlmIChydGwpIHdyYXBwZXJSb3RhdGUgPSAoLXNsaWRlSW5kZXggKiA5MCkgLSAocHJvZ3Jlc3MgKiA5MCk7XG4gICAgICB9XG4gICAgICAkc2xpZGVFbC50cmFuc2Zvcm0odHJhbnNmb3JtKTtcbiAgICAgIGlmIChwYXJhbXMuc2xpZGVTaGFkb3dzKSB7XG4gICAgICAgIC8vIFNldCBzaGFkb3dzXG4gICAgICAgIGxldCBzaGFkb3dCZWZvcmUgPSBpc0hvcml6b250YWwgPyAkc2xpZGVFbC5maW5kKCcuc3dpcGVyLXNsaWRlLXNoYWRvdy1sZWZ0JykgOiAkc2xpZGVFbC5maW5kKCcuc3dpcGVyLXNsaWRlLXNoYWRvdy10b3AnKTtcbiAgICAgICAgbGV0IHNoYWRvd0FmdGVyID0gaXNIb3Jpem9udGFsID8gJHNsaWRlRWwuZmluZCgnLnN3aXBlci1zbGlkZS1zaGFkb3ctcmlnaHQnKSA6ICRzbGlkZUVsLmZpbmQoJy5zd2lwZXItc2xpZGUtc2hhZG93LWJvdHRvbScpO1xuICAgICAgICBpZiAoc2hhZG93QmVmb3JlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHNoYWRvd0JlZm9yZSA9ICQoYDxkaXYgY2xhc3M9XCJzd2lwZXItc2xpZGUtc2hhZG93LSR7aXNIb3Jpem9udGFsID8gJ2xlZnQnIDogJ3RvcCd9XCI+PC9kaXY+YCk7XG4gICAgICAgICAgJHNsaWRlRWwuYXBwZW5kKHNoYWRvd0JlZm9yZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNoYWRvd0FmdGVyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHNoYWRvd0FmdGVyID0gJChgPGRpdiBjbGFzcz1cInN3aXBlci1zbGlkZS1zaGFkb3ctJHtpc0hvcml6b250YWwgPyAncmlnaHQnIDogJ2JvdHRvbSd9XCI+PC9kaXY+YCk7XG4gICAgICAgICAgJHNsaWRlRWwuYXBwZW5kKHNoYWRvd0FmdGVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hhZG93QmVmb3JlLmxlbmd0aCkgc2hhZG93QmVmb3JlWzBdLnN0eWxlLm9wYWNpdHkgPSBNYXRoLm1heCgtcHJvZ3Jlc3MsIDApO1xuICAgICAgICBpZiAoc2hhZG93QWZ0ZXIubGVuZ3RoKSBzaGFkb3dBZnRlclswXS5zdHlsZS5vcGFjaXR5ID0gTWF0aC5tYXgocHJvZ3Jlc3MsIDApO1xuICAgICAgfVxuICAgIH1cbiAgICAkd3JhcHBlckVsLmNzcyh7XG4gICAgICAnLXdlYmtpdC10cmFuc2Zvcm0tb3JpZ2luJzogYDUwJSA1MCUgLSR7c3dpcGVyU2l6ZSAvIDJ9cHhgLFxuICAgICAgJy1tb3otdHJhbnNmb3JtLW9yaWdpbic6IGA1MCUgNTAlIC0ke3N3aXBlclNpemUgLyAyfXB4YCxcbiAgICAgICctbXMtdHJhbnNmb3JtLW9yaWdpbic6IGA1MCUgNTAlIC0ke3N3aXBlclNpemUgLyAyfXB4YCxcbiAgICAgICd0cmFuc2Zvcm0tb3JpZ2luJzogYDUwJSA1MCUgLSR7c3dpcGVyU2l6ZSAvIDJ9cHhgLFxuICAgIH0pO1xuXG4gICAgaWYgKHBhcmFtcy5zaGFkb3cpIHtcbiAgICAgIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAgICAgJGN1YmVTaGFkb3dFbC50cmFuc2Zvcm0oYHRyYW5zbGF0ZTNkKDBweCwgJHsoc3dpcGVyV2lkdGggLyAyKSArIHBhcmFtcy5zaGFkb3dPZmZzZXR9cHgsICR7LXN3aXBlcldpZHRoIC8gMn1weCkgcm90YXRlWCg5MGRlZykgcm90YXRlWigwZGVnKSBzY2FsZSgke3BhcmFtcy5zaGFkb3dTY2FsZX0pYCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBzaGFkb3dBbmdsZSA9IE1hdGguYWJzKHdyYXBwZXJSb3RhdGUpIC0gKE1hdGguZmxvb3IoTWF0aC5hYnMod3JhcHBlclJvdGF0ZSkgLyA5MCkgKiA5MCk7XG4gICAgICAgIGNvbnN0IG11bHRpcGxpZXIgPSAxLjUgLSAoXG4gICAgICAgICAgKE1hdGguc2luKChzaGFkb3dBbmdsZSAqIDIgKiBNYXRoLlBJKSAvIDM2MCkgLyAyKSArXG4gICAgICAgICAgKE1hdGguY29zKChzaGFkb3dBbmdsZSAqIDIgKiBNYXRoLlBJKSAvIDM2MCkgLyAyKVxuICAgICAgICApO1xuICAgICAgICBjb25zdCBzY2FsZTEgPSBwYXJhbXMuc2hhZG93U2NhbGU7XG4gICAgICAgIGNvbnN0IHNjYWxlMiA9IHBhcmFtcy5zaGFkb3dTY2FsZSAvIG11bHRpcGxpZXI7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHBhcmFtcy5zaGFkb3dPZmZzZXQ7XG4gICAgICAgICRjdWJlU2hhZG93RWwudHJhbnNmb3JtKGBzY2FsZTNkKCR7c2NhbGUxfSwgMSwgJHtzY2FsZTJ9KSB0cmFuc2xhdGUzZCgwcHgsICR7KHN3aXBlckhlaWdodCAvIDIpICsgb2Zmc2V0fXB4LCAkey1zd2lwZXJIZWlnaHQgLyAyIC8gc2NhbGUyfXB4KSByb3RhdGVYKC05MGRlZylgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgekZhY3RvciA9IChCcm93c2VyLmlzU2FmYXJpIHx8IEJyb3dzZXIuaXNVaVdlYlZpZXcpID8gKC1zd2lwZXJTaXplIC8gMikgOiAwO1xuICAgICR3cmFwcGVyRWxcbiAgICAgIC50cmFuc2Zvcm0oYHRyYW5zbGF0ZTNkKDBweCwwLCR7ekZhY3Rvcn1weCkgcm90YXRlWCgke3N3aXBlci5pc0hvcml6b250YWwoKSA/IDAgOiB3cmFwcGVyUm90YXRlfWRlZykgcm90YXRlWSgke3N3aXBlci5pc0hvcml6b250YWwoKSA/IC13cmFwcGVyUm90YXRlIDogMH1kZWcpYCk7XG4gIH0sXG4gIHNldFRyYW5zaXRpb24oZHVyYXRpb24pIHtcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgIGNvbnN0IHsgJGVsLCBzbGlkZXMgfSA9IHN3aXBlcjtcbiAgICBzbGlkZXNcbiAgICAgIC50cmFuc2l0aW9uKGR1cmF0aW9uKVxuICAgICAgLmZpbmQoJy5zd2lwZXItc2xpZGUtc2hhZG93LXRvcCwgLnN3aXBlci1zbGlkZS1zaGFkb3ctcmlnaHQsIC5zd2lwZXItc2xpZGUtc2hhZG93LWJvdHRvbSwgLnN3aXBlci1zbGlkZS1zaGFkb3ctbGVmdCcpXG4gICAgICAudHJhbnNpdGlvbihkdXJhdGlvbik7XG4gICAgaWYgKHN3aXBlci5wYXJhbXMuY3ViZUVmZmVjdC5zaGFkb3cgJiYgIXN3aXBlci5pc0hvcml6b250YWwoKSkge1xuICAgICAgJGVsLmZpbmQoJy5zd2lwZXItY3ViZS1zaGFkb3cnKS50cmFuc2l0aW9uKGR1cmF0aW9uKTtcbiAgICB9XG4gIH0sXG59O1xuXG52YXIgRWZmZWN0Q3ViZSA9IHtcbiAgbmFtZTogJ2VmZmVjdC1jdWJlJyxcbiAgcGFyYW1zOiB7XG4gICAgY3ViZUVmZmVjdDoge1xuICAgICAgc2xpZGVTaGFkb3dzOiB0cnVlLFxuICAgICAgc2hhZG93OiB0cnVlLFxuICAgICAgc2hhZG93T2Zmc2V0OiAyMCxcbiAgICAgIHNoYWRvd1NjYWxlOiAwLjk0LFxuICAgIH0sXG4gIH0sXG4gIGNyZWF0ZSgpIHtcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgIFV0aWxzLmV4dGVuZChzd2lwZXIsIHtcbiAgICAgIGN1YmVFZmZlY3Q6IHtcbiAgICAgICAgc2V0VHJhbnNsYXRlOiBDdWJlLnNldFRyYW5zbGF0ZS5iaW5kKHN3aXBlciksXG4gICAgICAgIHNldFRyYW5zaXRpb246IEN1YmUuc2V0VHJhbnNpdGlvbi5iaW5kKHN3aXBlciksXG4gICAgICB9LFxuICAgIH0pO1xuICB9LFxuICBvbjoge1xuICAgIGJlZm9yZUluaXQoKSB7XG4gICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgICAgaWYgKHN3aXBlci5wYXJhbXMuZWZmZWN0ICE9PSAnY3ViZScpIHJldHVybjtcbiAgICAgIHN3aXBlci5jbGFzc05hbWVzLnB1c2goYCR7c3dpcGVyLnBhcmFtcy5jb250YWluZXJNb2RpZmllckNsYXNzfWN1YmVgKTtcbiAgICAgIHN3aXBlci5jbGFzc05hbWVzLnB1c2goYCR7c3dpcGVyLnBhcmFtcy5jb250YWluZXJNb2RpZmllckNsYXNzfTNkYCk7XG4gICAgICBjb25zdCBvdmVyd3JpdGVQYXJhbXMgPSB7XG4gICAgICAgIHNsaWRlc1BlclZpZXc6IDEsXG4gICAgICAgIHNsaWRlc1BlckNvbHVtbjogMSxcbiAgICAgICAgc2xpZGVzUGVyR3JvdXA6IDEsXG4gICAgICAgIHdhdGNoU2xpZGVzUHJvZ3Jlc3M6IHRydWUsXG4gICAgICAgIHJlc2lzdGFuY2VSYXRpbzogMCxcbiAgICAgICAgc3BhY2VCZXR3ZWVuOiAwLFxuICAgICAgICBjZW50ZXJlZFNsaWRlczogZmFsc2UsXG4gICAgICAgIHZpcnR1YWxUcmFuc2xhdGU6IHRydWUsXG4gICAgICB9O1xuICAgICAgVXRpbHMuZXh0ZW5kKHN3aXBlci5wYXJhbXMsIG92ZXJ3cml0ZVBhcmFtcyk7XG4gICAgICBVdGlscy5leHRlbmQoc3dpcGVyLm9yaWdpbmFsUGFyYW1zLCBvdmVyd3JpdGVQYXJhbXMpO1xuICAgIH0sXG4gICAgc2V0VHJhbnNsYXRlKCkge1xuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICAgIGlmIChzd2lwZXIucGFyYW1zLmVmZmVjdCAhPT0gJ2N1YmUnKSByZXR1cm47XG4gICAgICBzd2lwZXIuY3ViZUVmZmVjdC5zZXRUcmFuc2xhdGUoKTtcbiAgICB9LFxuICAgIHNldFRyYW5zaXRpb24oZHVyYXRpb24pIHtcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgICBpZiAoc3dpcGVyLnBhcmFtcy5lZmZlY3QgIT09ICdjdWJlJykgcmV0dXJuO1xuICAgICAgc3dpcGVyLmN1YmVFZmZlY3Quc2V0VHJhbnNpdGlvbihkdXJhdGlvbik7XG4gICAgfSxcbiAgfSxcbn07XG5cbmNvbnN0IEZsaXAgPSB7XG4gIHNldFRyYW5zbGF0ZSgpIHtcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgIGNvbnN0IHsgc2xpZGVzLCBydGxUcmFuc2xhdGU6IHJ0bCB9ID0gc3dpcGVyO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2xpZGVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBjb25zdCAkc2xpZGVFbCA9IHNsaWRlcy5lcShpKTtcbiAgICAgIGxldCBwcm9ncmVzcyA9ICRzbGlkZUVsWzBdLnByb2dyZXNzO1xuICAgICAgaWYgKHN3aXBlci5wYXJhbXMuZmxpcEVmZmVjdC5saW1pdFJvdGF0aW9uKSB7XG4gICAgICAgIHByb2dyZXNzID0gTWF0aC5tYXgoTWF0aC5taW4oJHNsaWRlRWxbMF0ucHJvZ3Jlc3MsIDEpLCAtMSk7XG4gICAgICB9XG4gICAgICBjb25zdCBvZmZzZXQgPSAkc2xpZGVFbFswXS5zd2lwZXJTbGlkZU9mZnNldDtcbiAgICAgIGNvbnN0IHJvdGF0ZSA9IC0xODAgKiBwcm9ncmVzcztcbiAgICAgIGxldCByb3RhdGVZID0gcm90YXRlO1xuICAgICAgbGV0IHJvdGF0ZVggPSAwO1xuICAgICAgbGV0IHR4ID0gLW9mZnNldDtcbiAgICAgIGxldCB0eSA9IDA7XG4gICAgICBpZiAoIXN3aXBlci5pc0hvcml6b250YWwoKSkge1xuICAgICAgICB0eSA9IHR4O1xuICAgICAgICB0eCA9IDA7XG4gICAgICAgIHJvdGF0ZVggPSAtcm90YXRlWTtcbiAgICAgICAgcm90YXRlWSA9IDA7XG4gICAgICB9IGVsc2UgaWYgKHJ0bCkge1xuICAgICAgICByb3RhdGVZID0gLXJvdGF0ZVk7XG4gICAgICB9XG5cbiAgICAgICRzbGlkZUVsWzBdLnN0eWxlLnpJbmRleCA9IC1NYXRoLmFicyhNYXRoLnJvdW5kKHByb2dyZXNzKSkgKyBzbGlkZXMubGVuZ3RoO1xuXG4gICAgICBpZiAoc3dpcGVyLnBhcmFtcy5mbGlwRWZmZWN0LnNsaWRlU2hhZG93cykge1xuICAgICAgICAvLyBTZXQgc2hhZG93c1xuICAgICAgICBsZXQgc2hhZG93QmVmb3JlID0gc3dpcGVyLmlzSG9yaXpvbnRhbCgpID8gJHNsaWRlRWwuZmluZCgnLnN3aXBlci1zbGlkZS1zaGFkb3ctbGVmdCcpIDogJHNsaWRlRWwuZmluZCgnLnN3aXBlci1zbGlkZS1zaGFkb3ctdG9wJyk7XG4gICAgICAgIGxldCBzaGFkb3dBZnRlciA9IHN3aXBlci5pc0hvcml6b250YWwoKSA/ICRzbGlkZUVsLmZpbmQoJy5zd2lwZXItc2xpZGUtc2hhZG93LXJpZ2h0JykgOiAkc2xpZGVFbC5maW5kKCcuc3dpcGVyLXNsaWRlLXNoYWRvdy1ib3R0b20nKTtcbiAgICAgICAgaWYgKHNoYWRvd0JlZm9yZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBzaGFkb3dCZWZvcmUgPSAkKGA8ZGl2IGNsYXNzPVwic3dpcGVyLXNsaWRlLXNoYWRvdy0ke3N3aXBlci5pc0hvcml6b250YWwoKSA/ICdsZWZ0JyA6ICd0b3AnfVwiPjwvZGl2PmApO1xuICAgICAgICAgICRzbGlkZUVsLmFwcGVuZChzaGFkb3dCZWZvcmUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaGFkb3dBZnRlci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBzaGFkb3dBZnRlciA9ICQoYDxkaXYgY2xhc3M9XCJzd2lwZXItc2xpZGUtc2hhZG93LSR7c3dpcGVyLmlzSG9yaXpvbnRhbCgpID8gJ3JpZ2h0JyA6ICdib3R0b20nfVwiPjwvZGl2PmApO1xuICAgICAgICAgICRzbGlkZUVsLmFwcGVuZChzaGFkb3dBZnRlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNoYWRvd0JlZm9yZS5sZW5ndGgpIHNoYWRvd0JlZm9yZVswXS5zdHlsZS5vcGFjaXR5ID0gTWF0aC5tYXgoLXByb2dyZXNzLCAwKTtcbiAgICAgICAgaWYgKHNoYWRvd0FmdGVyLmxlbmd0aCkgc2hhZG93QWZ0ZXJbMF0uc3R5bGUub3BhY2l0eSA9IE1hdGgubWF4KHByb2dyZXNzLCAwKTtcbiAgICAgIH1cbiAgICAgICRzbGlkZUVsXG4gICAgICAgIC50cmFuc2Zvcm0oYHRyYW5zbGF0ZTNkKCR7dHh9cHgsICR7dHl9cHgsIDBweCkgcm90YXRlWCgke3JvdGF0ZVh9ZGVnKSByb3RhdGVZKCR7cm90YXRlWX1kZWcpYCk7XG4gICAgfVxuICB9LFxuICBzZXRUcmFuc2l0aW9uKGR1cmF0aW9uKSB7XG4gICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICBjb25zdCB7IHNsaWRlcywgYWN0aXZlSW5kZXgsICR3cmFwcGVyRWwgfSA9IHN3aXBlcjtcbiAgICBzbGlkZXNcbiAgICAgIC50cmFuc2l0aW9uKGR1cmF0aW9uKVxuICAgICAgLmZpbmQoJy5zd2lwZXItc2xpZGUtc2hhZG93LXRvcCwgLnN3aXBlci1zbGlkZS1zaGFkb3ctcmlnaHQsIC5zd2lwZXItc2xpZGUtc2hhZG93LWJvdHRvbSwgLnN3aXBlci1zbGlkZS1zaGFkb3ctbGVmdCcpXG4gICAgICAudHJhbnNpdGlvbihkdXJhdGlvbik7XG4gICAgaWYgKHN3aXBlci5wYXJhbXMudmlydHVhbFRyYW5zbGF0ZSAmJiBkdXJhdGlvbiAhPT0gMCkge1xuICAgICAgbGV0IGV2ZW50VHJpZ2dlcmVkID0gZmFsc2U7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgIHNsaWRlcy5lcShhY3RpdmVJbmRleCkudHJhbnNpdGlvbkVuZChmdW5jdGlvbiBvblRyYW5zaXRpb25FbmQoKSB7XG4gICAgICAgIGlmIChldmVudFRyaWdnZXJlZCkgcmV0dXJuO1xuICAgICAgICBpZiAoIXN3aXBlciB8fCBzd2lwZXIuZGVzdHJveWVkKSByZXR1cm47XG4gICAgICAgIC8vIGlmICghJCh0aGlzKS5oYXNDbGFzcyhzd2lwZXIucGFyYW1zLnNsaWRlQWN0aXZlQ2xhc3MpKSByZXR1cm47XG4gICAgICAgIGV2ZW50VHJpZ2dlcmVkID0gdHJ1ZTtcbiAgICAgICAgc3dpcGVyLmFuaW1hdGluZyA9IGZhbHNlO1xuICAgICAgICBjb25zdCB0cmlnZ2VyRXZlbnRzID0gWyd3ZWJraXRUcmFuc2l0aW9uRW5kJywgJ3RyYW5zaXRpb25lbmQnXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0cmlnZ2VyRXZlbnRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgJHdyYXBwZXJFbC50cmlnZ2VyKHRyaWdnZXJFdmVudHNbaV0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG59O1xuXG52YXIgRWZmZWN0RmxpcCA9IHtcbiAgbmFtZTogJ2VmZmVjdC1mbGlwJyxcbiAgcGFyYW1zOiB7XG4gICAgZmxpcEVmZmVjdDoge1xuICAgICAgc2xpZGVTaGFkb3dzOiB0cnVlLFxuICAgICAgbGltaXRSb3RhdGlvbjogdHJ1ZSxcbiAgICB9LFxuICB9LFxuICBjcmVhdGUoKSB7XG4gICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICBVdGlscy5leHRlbmQoc3dpcGVyLCB7XG4gICAgICBmbGlwRWZmZWN0OiB7XG4gICAgICAgIHNldFRyYW5zbGF0ZTogRmxpcC5zZXRUcmFuc2xhdGUuYmluZChzd2lwZXIpLFxuICAgICAgICBzZXRUcmFuc2l0aW9uOiBGbGlwLnNldFRyYW5zaXRpb24uYmluZChzd2lwZXIpLFxuICAgICAgfSxcbiAgICB9KTtcbiAgfSxcbiAgb246IHtcbiAgICBiZWZvcmVJbml0KCkge1xuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICAgIGlmIChzd2lwZXIucGFyYW1zLmVmZmVjdCAhPT0gJ2ZsaXAnKSByZXR1cm47XG4gICAgICBzd2lwZXIuY2xhc3NOYW1lcy5wdXNoKGAke3N3aXBlci5wYXJhbXMuY29udGFpbmVyTW9kaWZpZXJDbGFzc31mbGlwYCk7XG4gICAgICBzd2lwZXIuY2xhc3NOYW1lcy5wdXNoKGAke3N3aXBlci5wYXJhbXMuY29udGFpbmVyTW9kaWZpZXJDbGFzc30zZGApO1xuICAgICAgY29uc3Qgb3ZlcndyaXRlUGFyYW1zID0ge1xuICAgICAgICBzbGlkZXNQZXJWaWV3OiAxLFxuICAgICAgICBzbGlkZXNQZXJDb2x1bW46IDEsXG4gICAgICAgIHNsaWRlc1Blckdyb3VwOiAxLFxuICAgICAgICB3YXRjaFNsaWRlc1Byb2dyZXNzOiB0cnVlLFxuICAgICAgICBzcGFjZUJldHdlZW46IDAsXG4gICAgICAgIHZpcnR1YWxUcmFuc2xhdGU6IHRydWUsXG4gICAgICB9O1xuICAgICAgVXRpbHMuZXh0ZW5kKHN3aXBlci5wYXJhbXMsIG92ZXJ3cml0ZVBhcmFtcyk7XG4gICAgICBVdGlscy5leHRlbmQoc3dpcGVyLm9yaWdpbmFsUGFyYW1zLCBvdmVyd3JpdGVQYXJhbXMpO1xuICAgIH0sXG4gICAgc2V0VHJhbnNsYXRlKCkge1xuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICAgIGlmIChzd2lwZXIucGFyYW1zLmVmZmVjdCAhPT0gJ2ZsaXAnKSByZXR1cm47XG4gICAgICBzd2lwZXIuZmxpcEVmZmVjdC5zZXRUcmFuc2xhdGUoKTtcbiAgICB9LFxuICAgIHNldFRyYW5zaXRpb24oZHVyYXRpb24pIHtcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgICBpZiAoc3dpcGVyLnBhcmFtcy5lZmZlY3QgIT09ICdmbGlwJykgcmV0dXJuO1xuICAgICAgc3dpcGVyLmZsaXBFZmZlY3Quc2V0VHJhbnNpdGlvbihkdXJhdGlvbik7XG4gICAgfSxcbiAgfSxcbn07XG5cbmNvbnN0IENvdmVyZmxvdyA9IHtcbiAgc2V0VHJhbnNsYXRlKCkge1xuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgY29uc3Qge1xuICAgICAgd2lkdGg6IHN3aXBlcldpZHRoLCBoZWlnaHQ6IHN3aXBlckhlaWdodCwgc2xpZGVzLCAkd3JhcHBlckVsLCBzbGlkZXNTaXplc0dyaWQsXG4gICAgfSA9IHN3aXBlcjtcbiAgICBjb25zdCBwYXJhbXMgPSBzd2lwZXIucGFyYW1zLmNvdmVyZmxvd0VmZmVjdDtcbiAgICBjb25zdCBpc0hvcml6b250YWwgPSBzd2lwZXIuaXNIb3Jpem9udGFsKCk7XG4gICAgY29uc3QgdHJhbnNmb3JtID0gc3dpcGVyLnRyYW5zbGF0ZTtcbiAgICBjb25zdCBjZW50ZXIgPSBpc0hvcml6b250YWwgPyAtdHJhbnNmb3JtICsgKHN3aXBlcldpZHRoIC8gMikgOiAtdHJhbnNmb3JtICsgKHN3aXBlckhlaWdodCAvIDIpO1xuICAgIGNvbnN0IHJvdGF0ZSA9IGlzSG9yaXpvbnRhbCA/IHBhcmFtcy5yb3RhdGUgOiAtcGFyYW1zLnJvdGF0ZTtcbiAgICBjb25zdCB0cmFuc2xhdGUgPSBwYXJhbXMuZGVwdGg7XG4gICAgLy8gRWFjaCBzbGlkZSBvZmZzZXQgZnJvbSBjZW50ZXJcbiAgICBmb3IgKGxldCBpID0gMCwgbGVuZ3RoID0gc2xpZGVzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBjb25zdCAkc2xpZGVFbCA9IHNsaWRlcy5lcShpKTtcbiAgICAgIGNvbnN0IHNsaWRlU2l6ZSA9IHNsaWRlc1NpemVzR3JpZFtpXTtcbiAgICAgIGNvbnN0IHNsaWRlT2Zmc2V0ID0gJHNsaWRlRWxbMF0uc3dpcGVyU2xpZGVPZmZzZXQ7XG4gICAgICBjb25zdCBvZmZzZXRNdWx0aXBsaWVyID0gKChjZW50ZXIgLSBzbGlkZU9mZnNldCAtIChzbGlkZVNpemUgLyAyKSkgLyBzbGlkZVNpemUpICogcGFyYW1zLm1vZGlmaWVyO1xuXG4gICAgICBsZXQgcm90YXRlWSA9IGlzSG9yaXpvbnRhbCA/IHJvdGF0ZSAqIG9mZnNldE11bHRpcGxpZXIgOiAwO1xuICAgICAgbGV0IHJvdGF0ZVggPSBpc0hvcml6b250YWwgPyAwIDogcm90YXRlICogb2Zmc2V0TXVsdGlwbGllcjtcbiAgICAgIC8vIHZhciByb3RhdGVaID0gMFxuICAgICAgbGV0IHRyYW5zbGF0ZVogPSAtdHJhbnNsYXRlICogTWF0aC5hYnMob2Zmc2V0TXVsdGlwbGllcik7XG5cbiAgICAgIGxldCB0cmFuc2xhdGVZID0gaXNIb3Jpem9udGFsID8gMCA6IHBhcmFtcy5zdHJldGNoICogKG9mZnNldE11bHRpcGxpZXIpO1xuICAgICAgbGV0IHRyYW5zbGF0ZVggPSBpc0hvcml6b250YWwgPyBwYXJhbXMuc3RyZXRjaCAqIChvZmZzZXRNdWx0aXBsaWVyKSA6IDA7XG5cbiAgICAgIC8vIEZpeCBmb3IgdWx0cmEgc21hbGwgdmFsdWVzXG4gICAgICBpZiAoTWF0aC5hYnModHJhbnNsYXRlWCkgPCAwLjAwMSkgdHJhbnNsYXRlWCA9IDA7XG4gICAgICBpZiAoTWF0aC5hYnModHJhbnNsYXRlWSkgPCAwLjAwMSkgdHJhbnNsYXRlWSA9IDA7XG4gICAgICBpZiAoTWF0aC5hYnModHJhbnNsYXRlWikgPCAwLjAwMSkgdHJhbnNsYXRlWiA9IDA7XG4gICAgICBpZiAoTWF0aC5hYnMocm90YXRlWSkgPCAwLjAwMSkgcm90YXRlWSA9IDA7XG4gICAgICBpZiAoTWF0aC5hYnMocm90YXRlWCkgPCAwLjAwMSkgcm90YXRlWCA9IDA7XG5cbiAgICAgIGNvbnN0IHNsaWRlVHJhbnNmb3JtID0gYHRyYW5zbGF0ZTNkKCR7dHJhbnNsYXRlWH1weCwke3RyYW5zbGF0ZVl9cHgsJHt0cmFuc2xhdGVafXB4KSAgcm90YXRlWCgke3JvdGF0ZVh9ZGVnKSByb3RhdGVZKCR7cm90YXRlWX1kZWcpYDtcblxuICAgICAgJHNsaWRlRWwudHJhbnNmb3JtKHNsaWRlVHJhbnNmb3JtKTtcbiAgICAgICRzbGlkZUVsWzBdLnN0eWxlLnpJbmRleCA9IC1NYXRoLmFicyhNYXRoLnJvdW5kKG9mZnNldE11bHRpcGxpZXIpKSArIDE7XG4gICAgICBpZiAocGFyYW1zLnNsaWRlU2hhZG93cykge1xuICAgICAgICAvLyBTZXQgc2hhZG93c1xuICAgICAgICBsZXQgJHNoYWRvd0JlZm9yZUVsID0gaXNIb3Jpem9udGFsID8gJHNsaWRlRWwuZmluZCgnLnN3aXBlci1zbGlkZS1zaGFkb3ctbGVmdCcpIDogJHNsaWRlRWwuZmluZCgnLnN3aXBlci1zbGlkZS1zaGFkb3ctdG9wJyk7XG4gICAgICAgIGxldCAkc2hhZG93QWZ0ZXJFbCA9IGlzSG9yaXpvbnRhbCA/ICRzbGlkZUVsLmZpbmQoJy5zd2lwZXItc2xpZGUtc2hhZG93LXJpZ2h0JykgOiAkc2xpZGVFbC5maW5kKCcuc3dpcGVyLXNsaWRlLXNoYWRvdy1ib3R0b20nKTtcbiAgICAgICAgaWYgKCRzaGFkb3dCZWZvcmVFbC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAkc2hhZG93QmVmb3JlRWwgPSAkKGA8ZGl2IGNsYXNzPVwic3dpcGVyLXNsaWRlLXNoYWRvdy0ke2lzSG9yaXpvbnRhbCA/ICdsZWZ0JyA6ICd0b3AnfVwiPjwvZGl2PmApO1xuICAgICAgICAgICRzbGlkZUVsLmFwcGVuZCgkc2hhZG93QmVmb3JlRWwpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgkc2hhZG93QWZ0ZXJFbC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAkc2hhZG93QWZ0ZXJFbCA9ICQoYDxkaXYgY2xhc3M9XCJzd2lwZXItc2xpZGUtc2hhZG93LSR7aXNIb3Jpem9udGFsID8gJ3JpZ2h0JyA6ICdib3R0b20nfVwiPjwvZGl2PmApO1xuICAgICAgICAgICRzbGlkZUVsLmFwcGVuZCgkc2hhZG93QWZ0ZXJFbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCRzaGFkb3dCZWZvcmVFbC5sZW5ndGgpICRzaGFkb3dCZWZvcmVFbFswXS5zdHlsZS5vcGFjaXR5ID0gb2Zmc2V0TXVsdGlwbGllciA+IDAgPyBvZmZzZXRNdWx0aXBsaWVyIDogMDtcbiAgICAgICAgaWYgKCRzaGFkb3dBZnRlckVsLmxlbmd0aCkgJHNoYWRvd0FmdGVyRWxbMF0uc3R5bGUub3BhY2l0eSA9ICgtb2Zmc2V0TXVsdGlwbGllcikgPiAwID8gLW9mZnNldE11bHRpcGxpZXIgOiAwO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFNldCBjb3JyZWN0IHBlcnNwZWN0aXZlIGZvciBJRTEwXG4gICAgaWYgKFN1cHBvcnQucG9pbnRlckV2ZW50cyB8fCBTdXBwb3J0LnByZWZpeGVkUG9pbnRlckV2ZW50cykge1xuICAgICAgY29uc3Qgd3MgPSAkd3JhcHBlckVsWzBdLnN0eWxlO1xuICAgICAgd3MucGVyc3BlY3RpdmVPcmlnaW4gPSBgJHtjZW50ZXJ9cHggNTAlYDtcbiAgICB9XG4gIH0sXG4gIHNldFRyYW5zaXRpb24oZHVyYXRpb24pIHtcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgIHN3aXBlci5zbGlkZXNcbiAgICAgIC50cmFuc2l0aW9uKGR1cmF0aW9uKVxuICAgICAgLmZpbmQoJy5zd2lwZXItc2xpZGUtc2hhZG93LXRvcCwgLnN3aXBlci1zbGlkZS1zaGFkb3ctcmlnaHQsIC5zd2lwZXItc2xpZGUtc2hhZG93LWJvdHRvbSwgLnN3aXBlci1zbGlkZS1zaGFkb3ctbGVmdCcpXG4gICAgICAudHJhbnNpdGlvbihkdXJhdGlvbik7XG4gIH0sXG59O1xuXG52YXIgRWZmZWN0Q292ZXJmbG93ID0ge1xuICBuYW1lOiAnZWZmZWN0LWNvdmVyZmxvdycsXG4gIHBhcmFtczoge1xuICAgIGNvdmVyZmxvd0VmZmVjdDoge1xuICAgICAgcm90YXRlOiA1MCxcbiAgICAgIHN0cmV0Y2g6IDAsXG4gICAgICBkZXB0aDogMTAwLFxuICAgICAgbW9kaWZpZXI6IDEsXG4gICAgICBzbGlkZVNoYWRvd3M6IHRydWUsXG4gICAgfSxcbiAgfSxcbiAgY3JlYXRlKCkge1xuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgVXRpbHMuZXh0ZW5kKHN3aXBlciwge1xuICAgICAgY292ZXJmbG93RWZmZWN0OiB7XG4gICAgICAgIHNldFRyYW5zbGF0ZTogQ292ZXJmbG93LnNldFRyYW5zbGF0ZS5iaW5kKHN3aXBlciksXG4gICAgICAgIHNldFRyYW5zaXRpb246IENvdmVyZmxvdy5zZXRUcmFuc2l0aW9uLmJpbmQoc3dpcGVyKSxcbiAgICAgIH0sXG4gICAgfSk7XG4gIH0sXG4gIG9uOiB7XG4gICAgYmVmb3JlSW5pdCgpIHtcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgICBpZiAoc3dpcGVyLnBhcmFtcy5lZmZlY3QgIT09ICdjb3ZlcmZsb3cnKSByZXR1cm47XG5cbiAgICAgIHN3aXBlci5jbGFzc05hbWVzLnB1c2goYCR7c3dpcGVyLnBhcmFtcy5jb250YWluZXJNb2RpZmllckNsYXNzfWNvdmVyZmxvd2ApO1xuICAgICAgc3dpcGVyLmNsYXNzTmFtZXMucHVzaChgJHtzd2lwZXIucGFyYW1zLmNvbnRhaW5lck1vZGlmaWVyQ2xhc3N9M2RgKTtcblxuICAgICAgc3dpcGVyLnBhcmFtcy53YXRjaFNsaWRlc1Byb2dyZXNzID0gdHJ1ZTtcbiAgICAgIHN3aXBlci5vcmlnaW5hbFBhcmFtcy53YXRjaFNsaWRlc1Byb2dyZXNzID0gdHJ1ZTtcbiAgICB9LFxuICAgIHNldFRyYW5zbGF0ZSgpIHtcbiAgICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgICBpZiAoc3dpcGVyLnBhcmFtcy5lZmZlY3QgIT09ICdjb3ZlcmZsb3cnKSByZXR1cm47XG4gICAgICBzd2lwZXIuY292ZXJmbG93RWZmZWN0LnNldFRyYW5zbGF0ZSgpO1xuICAgIH0sXG4gICAgc2V0VHJhbnNpdGlvbihkdXJhdGlvbikge1xuICAgICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICAgIGlmIChzd2lwZXIucGFyYW1zLmVmZmVjdCAhPT0gJ2NvdmVyZmxvdycpIHJldHVybjtcbiAgICAgIHN3aXBlci5jb3ZlcmZsb3dFZmZlY3Quc2V0VHJhbnNpdGlvbihkdXJhdGlvbik7XG4gICAgfSxcbiAgfSxcbn07XG5cbi8vIFN3aXBlciBDbGFzc1xuXG5Td2lwZXIudXNlKFtcbiAgRGV2aWNlJDEsXG4gIEJyb3dzZXIkMSxcbiAgU3VwcG9ydCQxLFxuICBSZXNpemUsXG4gIE9ic2VydmVyJDEsXG4gIFZpcnR1YWwkMSxcbiAgTmF2aWdhdGlvbiQxLFxuICBQYWdpbmF0aW9uJDEsXG4gIFNjcm9sbGJhciQxLFxuICBQYXJhbGxheCQxLFxuICBab29tJDEsXG4gIExhenkkMyxcbiAgQ29udHJvbGxlciQxLFxuICBBMTF5LFxuICBBdXRvcGxheSQxLFxuICBFZmZlY3RGYWRlLFxuICBFZmZlY3RDdWJlLFxuICBFZmZlY3RGbGlwLFxuICBFZmZlY3RDb3ZlcmZsb3csXG5dKTtcblxuZnVuY3Rpb24gaW5pdFN3aXBlcnMoc3dpcGVyRWwpIHtcbiAgY29uc3QgYXBwID0gdGhpcztcbiAgY29uc3QgJHN3aXBlckVsID0gJChzd2lwZXJFbCk7XG4gIGlmICgkc3dpcGVyRWwubGVuZ3RoID09PSAwKSByZXR1cm47XG4gIGlmICgkc3dpcGVyRWxbMF0uc3dpcGVyKSByZXR1cm47XG4gIGxldCBpbml0aWFsU2xpZGU7XG4gIGxldCBwYXJhbXMgPSB7fTtcbiAgbGV0IGlzVGFicztcbiAgbGV0IGlzUm91dGFibGVUYWJzO1xuICBpZiAoJHN3aXBlckVsLmhhc0NsYXNzKCd0YWJzLXN3aXBlYWJsZS13cmFwJykpIHtcbiAgICAkc3dpcGVyRWxcbiAgICAgIC5hZGRDbGFzcygnc3dpcGVyLWNvbnRhaW5lcicpXG4gICAgICAuY2hpbGRyZW4oJy50YWJzJylcbiAgICAgIC5hZGRDbGFzcygnc3dpcGVyLXdyYXBwZXInKVxuICAgICAgLmNoaWxkcmVuKCcudGFiJylcbiAgICAgIC5hZGRDbGFzcygnc3dpcGVyLXNsaWRlJyk7XG4gICAgaW5pdGlhbFNsaWRlID0gJHN3aXBlckVsLmNoaWxkcmVuKCcudGFicycpLmNoaWxkcmVuKCcudGFiLWFjdGl2ZScpLmluZGV4KCk7XG4gICAgaXNUYWJzID0gdHJ1ZTtcbiAgICBpc1JvdXRhYmxlVGFicyA9ICRzd2lwZXJFbC5maW5kKCcudGFicy1yb3V0YWJsZScpLmxlbmd0aCA+IDA7XG4gIH1cbiAgaWYgKCRzd2lwZXJFbC5hdHRyKCdkYXRhLXN3aXBlcicpKSB7XG4gICAgcGFyYW1zID0gSlNPTi5wYXJzZSgkc3dpcGVyRWwuYXR0cignZGF0YS1zd2lwZXInKSk7XG4gIH0gZWxzZSB7XG4gICAgcGFyYW1zID0gJHN3aXBlckVsLmRhdGFzZXQoKTtcbiAgICBPYmplY3Qua2V5cyhwYXJhbXMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgY29uc3QgdmFsdWUgPSBwYXJhbXNba2V5XTtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHZhbHVlLmluZGV4T2YoJ3snKSA9PT0gMCAmJiB2YWx1ZS5pbmRleE9mKCd9JykgPiAwKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcGFyYW1zW2tleV0gPSBKU09OLnBhcnNlKHZhbHVlKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIC8vIG5vdCBKU09OXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBpZiAodHlwZW9mIHBhcmFtcy5pbml0aWFsU2xpZGUgPT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBpbml0aWFsU2xpZGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcGFyYW1zLmluaXRpYWxTbGlkZSA9IGluaXRpYWxTbGlkZTtcbiAgfVxuXG4gIGNvbnN0IHN3aXBlciA9IGFwcC5zd2lwZXIuY3JlYXRlKCRzd2lwZXJFbFswXSwgcGFyYW1zKTtcbiAgaWYgKGlzVGFicykge1xuICAgIHN3aXBlci5vbignc2xpZGVDaGFuZ2UnLCAoKSA9PiB7XG4gICAgICBpZiAoaXNSb3V0YWJsZVRhYnMpIHtcbiAgICAgICAgbGV0IHZpZXcgPSBhcHAudmlld3MuZ2V0KCRzd2lwZXJFbC5wYXJlbnRzKCcudmlldycpKTtcbiAgICAgICAgaWYgKCF2aWV3KSB2aWV3ID0gYXBwLnZpZXdzLm1haW47XG4gICAgICAgIGNvbnN0IHJvdXRlciA9IHZpZXcucm91dGVyO1xuICAgICAgICBjb25zdCB0YWJSb3V0ZSA9IHJvdXRlci5maW5kVGFiUm91dGUoc3dpcGVyLnNsaWRlcy5lcShzd2lwZXIuYWN0aXZlSW5kZXgpWzBdKTtcbiAgICAgICAgaWYgKHRhYlJvdXRlKSByb3V0ZXIubmF2aWdhdGUodGFiUm91dGUucGF0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhcHAudGFiLnNob3coe1xuICAgICAgICAgIHRhYkVsOiBzd2lwZXIuc2xpZGVzLmVxKHN3aXBlci5hY3RpdmVJbmRleCksXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbnZhciBTd2lwZXIkMSA9IHtcbiAgbmFtZTogJ3N3aXBlcicsXG4gIHN0YXRpYzoge1xuICAgIFN3aXBlcixcbiAgfSxcbiAgY3JlYXRlKCkge1xuICAgIGNvbnN0IGFwcCA9IHRoaXM7XG4gICAgYXBwLnN3aXBlciA9IENvbnN0cnVjdG9yTWV0aG9kcyh7XG4gICAgICBkZWZhdWx0U2VsZWN0b3I6ICcuc3dpcGVyLWNvbnRhaW5lcicsXG4gICAgICBjb25zdHJ1Y3RvcjogU3dpcGVyLFxuICAgICAgZG9tUHJvcDogJ3N3aXBlcicsXG4gICAgfSk7XG4gIH0sXG4gIG9uOiB7XG4gICAgcGFnZUJlZm9yZVJlbW92ZShwYWdlKSB7XG4gICAgICBjb25zdCBhcHAgPSB0aGlzO1xuICAgICAgcGFnZS4kZWwuZmluZCgnLnN3aXBlci1pbml0LCAudGFicy1zd2lwZWFibGUtd3JhcCcpLmVhY2goKGluZGV4LCBzd2lwZXJFbCkgPT4ge1xuICAgICAgICBhcHAuc3dpcGVyLmRlc3Ryb3koc3dpcGVyRWwpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBwYWdlTW91bnRlZChwYWdlKSB7XG4gICAgICBjb25zdCBhcHAgPSB0aGlzO1xuICAgICAgcGFnZS4kZWwuZmluZCgnLnRhYnMtc3dpcGVhYmxlLXdyYXAnKS5lYWNoKChpbmRleCwgc3dpcGVyRWwpID0+IHtcbiAgICAgICAgaW5pdFN3aXBlcnMuY2FsbChhcHAsIHN3aXBlckVsKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgcGFnZUluaXQocGFnZSkge1xuICAgICAgY29uc3QgYXBwID0gdGhpcztcbiAgICAgIHBhZ2UuJGVsLmZpbmQoJy5zd2lwZXItaW5pdCwgLnRhYnMtc3dpcGVhYmxlLXdyYXAnKS5lYWNoKChpbmRleCwgc3dpcGVyRWwpID0+IHtcbiAgICAgICAgaW5pdFN3aXBlcnMuY2FsbChhcHAsIHN3aXBlckVsKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgcGFnZVJlaW5pdChwYWdlKSB7XG4gICAgICBjb25zdCBhcHAgPSB0aGlzO1xuICAgICAgcGFnZS4kZWwuZmluZCgnLnN3aXBlci1pbml0LCAudGFicy1zd2lwZWFibGUtd3JhcCcpLmVhY2goKGluZGV4LCBzd2lwZXJFbCkgPT4ge1xuICAgICAgICBjb25zdCBzd2lwZXIgPSBhcHAuc3dpcGVyLmdldChzd2lwZXJFbCk7XG4gICAgICAgIGlmIChzd2lwZXIgJiYgc3dpcGVyLnVwZGF0ZSkgc3dpcGVyLnVwZGF0ZSgpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICB0YWJNb3VudGVkKHRhYkVsKSB7XG4gICAgICBjb25zdCBhcHAgPSB0aGlzO1xuICAgICAgJCh0YWJFbCkuZmluZCgnLnN3aXBlci1pbml0LCAudGFicy1zd2lwZWFibGUtd3JhcCcpLmVhY2goKGluZGV4LCBzd2lwZXJFbCkgPT4ge1xuICAgICAgICBpbml0U3dpcGVycy5jYWxsKGFwcCwgc3dpcGVyRWwpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICB0YWJTaG93KHRhYkVsKSB7XG4gICAgICBjb25zdCBhcHAgPSB0aGlzO1xuICAgICAgJCh0YWJFbCkuZmluZCgnLnN3aXBlci1pbml0LCAudGFicy1zd2lwZWFibGUtd3JhcCcpLmVhY2goKGluZGV4LCBzd2lwZXJFbCkgPT4ge1xuICAgICAgICBjb25zdCBzd2lwZXIgPSBhcHAuc3dpcGVyLmdldChzd2lwZXJFbCk7XG4gICAgICAgIGlmIChzd2lwZXIgJiYgc3dpcGVyLnVwZGF0ZSkgc3dpcGVyLnVwZGF0ZSgpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICB0YWJCZWZvcmVSZW1vdmUodGFiRWwpIHtcbiAgICAgIGNvbnN0IGFwcCA9IHRoaXM7XG4gICAgICAkKHRhYkVsKS5maW5kKCcuc3dpcGVyLWluaXQsIC50YWJzLXN3aXBlYWJsZS13cmFwJykuZWFjaCgoaW5kZXgsIHN3aXBlckVsKSA9PiB7XG4gICAgICAgIGFwcC5zd2lwZXIuZGVzdHJveShzd2lwZXJFbCk7XG4gICAgICB9KTtcbiAgICB9LFxuICB9LFxufTtcblxuLyogZXNsaW50IGluZGVudDogW1wib2ZmXCJdICovXG5cbmNsYXNzIFBob3RvQnJvd3NlciBleHRlbmRzIEZyYW1ld29yazdDbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGFwcCwgcGFyYW1zID0ge30pIHtcbiAgICBzdXBlcihwYXJhbXMsIFthcHBdKTtcblxuICAgIGNvbnN0IHBiID0gdGhpcztcbiAgICBwYi5hcHAgPSBhcHA7XG5cbiAgICBjb25zdCBkZWZhdWx0cyA9IFV0aWxzLmV4dGVuZCh7XG4gICAgICBvbjoge30sXG4gICAgfSwgYXBwLnBhcmFtcy5waG90b0Jyb3dzZXIpO1xuXG4gICAgLy8gRXh0ZW5kIGRlZmF1bHRzIHdpdGggbW9kdWxlcyBwYXJhbXNcbiAgICBwYi51c2VNb2R1bGVzUGFyYW1zKGRlZmF1bHRzKTtcblxuICAgIHBiLnBhcmFtcyA9IFV0aWxzLmV4dGVuZChkZWZhdWx0cywgcGFyYW1zKTtcblxuICAgIFV0aWxzLmV4dGVuZChwYiwge1xuICAgICAgZXhwb3NlZDogZmFsc2UsXG4gICAgICBvcGVuZWQ6IGZhbHNlLFxuICAgICAgYWN0aXZlSW5kZXg6IHBiLnBhcmFtcy5zd2lwZXIuaW5pdGlhbFNsaWRlLFxuICAgICAgdXJsOiBwYi5wYXJhbXMudXJsLFxuICAgICAgdmlldzogcGIucGFyYW1zLnZpZXcgfHwgYXBwLnZpZXdzLm1haW4sXG4gICAgICBzd2lwZVRvQ2xvc2U6IHtcbiAgICAgICAgYWxsb3c6IHRydWUsXG4gICAgICAgIGlzVG91Y2hlZDogZmFsc2UsXG4gICAgICAgIGRpZmY6IHVuZGVmaW5lZCxcbiAgICAgICAgc3RhcnQ6IHVuZGVmaW5lZCxcbiAgICAgICAgY3VycmVudDogdW5kZWZpbmVkLFxuICAgICAgICBzdGFydGVkOiBmYWxzZSxcbiAgICAgICAgYWN0aXZlU2xpZGU6IHVuZGVmaW5lZCxcbiAgICAgICAgdGltZVN0YXJ0OiB1bmRlZmluZWQsXG4gICAgICB9LFxuICAgIH0pO1xuXG4gICAgLy8gSW5zdGFsbCBNb2R1bGVzXG4gICAgcGIudXNlTW9kdWxlcygpO1xuXG4gICAgLy8gSW5pdFxuICAgIHBiLmluaXQoKTtcbiAgfVxuICBvblNsaWRlQ2hhbmdlKHN3aXBlcikge1xuICAgIGNvbnN0IHBiID0gdGhpcztcbiAgICBwYi5hY3RpdmVJbmRleCA9IHN3aXBlci5hY3RpdmVJbmRleDtcblxuICAgIGxldCBjdXJyZW50ID0gc3dpcGVyLmFjdGl2ZUluZGV4ICsgMTtcbiAgICBsZXQgdG90YWwgPSBwYi5wYXJhbXMudmlydHVhbFNsaWRlcyA/IHBiLnBhcmFtcy5waG90b3MubGVuZ3RoIDogc3dpcGVyLnNsaWRlcy5sZW5ndGg7XG4gICAgaWYgKHN3aXBlci5wYXJhbXMubG9vcCkge1xuICAgICAgdG90YWwgLT0gMjtcbiAgICAgIGN1cnJlbnQgLT0gc3dpcGVyLmxvb3BlZFNsaWRlcztcbiAgICAgIGlmIChjdXJyZW50IDwgMSkgY3VycmVudCA9IHRvdGFsICsgY3VycmVudDtcbiAgICAgIGlmIChjdXJyZW50ID4gdG90YWwpIGN1cnJlbnQgLT0gdG90YWw7XG4gICAgfVxuXG4gICAgY29uc3QgJGFjdGl2ZVNsaWRlRWwgPSBwYi5wYXJhbXMudmlydHVhbFNsaWRlc1xuICAgICAgPyBzd2lwZXIuJHdyYXBwZXJFbC5maW5kKGAuc3dpcGVyLXNsaWRlW2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4PVwiJHtzd2lwZXIuYWN0aXZlSW5kZXh9XCJdYClcbiAgICAgIDogc3dpcGVyLnNsaWRlcy5lcShzd2lwZXIuYWN0aXZlSW5kZXgpO1xuICAgIGNvbnN0ICRwcmV2aW91c1NsaWRlRWwgPSBwYi5wYXJhbXMudmlydHVhbFNsaWRlc1xuICAgICAgPyBzd2lwZXIuJHdyYXBwZXJFbC5maW5kKGAuc3dpcGVyLXNsaWRlW2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4PVwiJHtzd2lwZXIucHJldmlvdXNJbmRleH1cIl1gKVxuICAgICAgOiBzd2lwZXIuc2xpZGVzLmVxKHN3aXBlci5wcmV2aW91c0luZGV4KTtcblxuICAgIGxldCAkY3VycmVudEVsID0gcGIuJGVsLmZpbmQoJy5waG90by1icm93c2VyLWN1cnJlbnQnKTtcbiAgICBsZXQgJHRvdGFsRWwgPSBwYi4kZWwuZmluZCgnLnBob3RvLWJyb3dzZXItdG90YWwnKTtcbiAgICBpZiAocGIucGFyYW1zLnR5cGUgPT09ICdwYWdlJyAmJiBwYi5wYXJhbXMubmF2YmFyICYmICRjdXJyZW50RWwubGVuZ3RoID09PSAwICYmIHBiLmFwcC50aGVtZSA9PT0gJ2lvcycpIHtcbiAgICAgIGNvbnN0IG5hdmJhckVsID0gcGIuYXBwLm5hdmJhci5nZXRFbEJ5UGFnZShwYi4kZWwpO1xuICAgICAgaWYgKG5hdmJhckVsKSB7XG4gICAgICAgICRjdXJyZW50RWwgPSAkKG5hdmJhckVsKS5maW5kKCcucGhvdG8tYnJvd3Nlci1jdXJyZW50Jyk7XG4gICAgICAgICR0b3RhbEVsID0gJChuYXZiYXJFbCkuZmluZCgnLnBob3RvLWJyb3dzZXItdG90YWwnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgJGN1cnJlbnRFbC50ZXh0KGN1cnJlbnQpO1xuICAgICR0b3RhbEVsLnRleHQodG90YWwpO1xuXG4gICAgLy8gVXBkYXRlIGNhcHRpb25zXG4gICAgaWYgKHBiLmNhcHRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGNhcHRpb25JbmRleCA9IHN3aXBlci5wYXJhbXMubG9vcCA/ICRhY3RpdmVTbGlkZUVsLmF0dHIoJ2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4JykgOiBwYi5hY3RpdmVJbmRleDtcbiAgICAgIHBiLiRjYXB0aW9uc0NvbnRhaW5lckVsLmZpbmQoJy5waG90by1icm93c2VyLWNhcHRpb24tYWN0aXZlJykucmVtb3ZlQ2xhc3MoJ3Bob3RvLWJyb3dzZXItY2FwdGlvbi1hY3RpdmUnKTtcbiAgICAgIHBiLiRjYXB0aW9uc0NvbnRhaW5lckVsLmZpbmQoYFtkYXRhLWNhcHRpb24taW5kZXg9XCIke2NhcHRpb25JbmRleH1cIl1gKS5hZGRDbGFzcygncGhvdG8tYnJvd3Nlci1jYXB0aW9uLWFjdGl2ZScpO1xuICAgIH1cblxuICAgIC8vIFN0b3AgVmlkZW9cbiAgICBjb25zdCBwcmV2aW91c1NsaWRlVmlkZW8gPSAkcHJldmlvdXNTbGlkZUVsLmZpbmQoJ3ZpZGVvJyk7XG4gICAgaWYgKHByZXZpb3VzU2xpZGVWaWRlby5sZW5ndGggPiAwKSB7XG4gICAgICBpZiAoJ3BhdXNlJyBpbiBwcmV2aW91c1NsaWRlVmlkZW9bMF0pIHByZXZpb3VzU2xpZGVWaWRlb1swXS5wYXVzZSgpO1xuICAgIH1cbiAgfVxuICBvblRvdWNoU3RhcnQoKSB7XG4gICAgY29uc3QgcGIgPSB0aGlzO1xuICAgIGNvbnN0IHN3aXBlVG9DbG9zZSA9IHBiLnN3aXBlVG9DbG9zZTtcbiAgICBpZiAoIXN3aXBlVG9DbG9zZS5hbGxvdykgcmV0dXJuO1xuICAgIHN3aXBlVG9DbG9zZS5pc1RvdWNoZWQgPSB0cnVlO1xuICB9XG4gIG9uVG91Y2hNb3ZlKGUpIHtcbiAgICBjb25zdCBwYiA9IHRoaXM7XG4gICAgY29uc3Qgc3dpcGVUb0Nsb3NlID0gcGIuc3dpcGVUb0Nsb3NlO1xuXG4gICAgaWYgKCFzd2lwZVRvQ2xvc2UuaXNUb3VjaGVkKSByZXR1cm47XG4gICAgaWYgKCFzd2lwZVRvQ2xvc2Uuc3RhcnRlZCkge1xuICAgICAgc3dpcGVUb0Nsb3NlLnN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgc3dpcGVUb0Nsb3NlLnN0YXJ0ID0gZS50eXBlID09PSAndG91Y2htb3ZlJyA/IGUudGFyZ2V0VG91Y2hlc1swXS5wYWdlWSA6IGUucGFnZVk7XG4gICAgICBpZiAocGIucGFyYW1zLnZpcnR1YWxTbGlkZXMpIHtcbiAgICAgICAgc3dpcGVUb0Nsb3NlLmFjdGl2ZVNsaWRlID0gcGIuc3dpcGVyLiR3cmFwcGVyRWwuY2hpbGRyZW4oJy5zd2lwZXItc2xpZGUtYWN0aXZlJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzd2lwZVRvQ2xvc2UuYWN0aXZlU2xpZGUgPSBwYi5zd2lwZXIuc2xpZGVzLmVxKHBiLnN3aXBlci5hY3RpdmVJbmRleCk7XG4gICAgICB9XG4gICAgICBzd2lwZVRvQ2xvc2UudGltZVN0YXJ0ID0gVXRpbHMubm93KCk7XG4gICAgfVxuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBzd2lwZVRvQ2xvc2UuY3VycmVudCA9IGUudHlwZSA9PT0gJ3RvdWNobW92ZScgPyBlLnRhcmdldFRvdWNoZXNbMF0ucGFnZVkgOiBlLnBhZ2VZO1xuICAgIHN3aXBlVG9DbG9zZS5kaWZmID0gc3dpcGVUb0Nsb3NlLnN0YXJ0IC0gc3dpcGVUb0Nsb3NlLmN1cnJlbnQ7XG4gICAgY29uc3Qgb3BhY2l0eSA9IDEgLSAoTWF0aC5hYnMoc3dpcGVUb0Nsb3NlLmRpZmYpIC8gMzAwKTtcbiAgICBjb25zdCBjb2xvciA9IHBiLmV4cG9zZWQgfHwgcGIucGFyYW1zLnRoZW1lID09PSAnZGFyaycgPyAwIDogMjU1O1xuICAgIHN3aXBlVG9DbG9zZS5hY3RpdmVTbGlkZS50cmFuc2Zvcm0oYHRyYW5zbGF0ZTNkKDAsJHstc3dpcGVUb0Nsb3NlLmRpZmZ9cHgsMClgKTtcbiAgICBwYi5zd2lwZXIuJGVsLmNzcygnYmFja2dyb3VuZC1jb2xvcicsIGByZ2JhKCR7Y29sb3J9LCAke2NvbG9yfSwgJHtjb2xvcn0sICR7b3BhY2l0eX0pYCkudHJhbnNpdGlvbigwKTtcbiAgfVxuICBvblRvdWNoRW5kKCkge1xuICAgIGNvbnN0IHBiID0gdGhpcztcbiAgICBjb25zdCBzd2lwZVRvQ2xvc2UgPSBwYi5zd2lwZVRvQ2xvc2U7XG4gICAgc3dpcGVUb0Nsb3NlLmlzVG91Y2hlZCA9IGZhbHNlO1xuICAgIGlmICghc3dpcGVUb0Nsb3NlLnN0YXJ0ZWQpIHtcbiAgICAgIHN3aXBlVG9DbG9zZS5zdGFydGVkID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN3aXBlVG9DbG9zZS5zdGFydGVkID0gZmFsc2U7XG4gICAgc3dpcGVUb0Nsb3NlLmFsbG93ID0gZmFsc2U7XG4gICAgY29uc3QgZGlmZiA9IE1hdGguYWJzKHN3aXBlVG9DbG9zZS5kaWZmKTtcbiAgICBjb25zdCB0aW1lRGlmZiA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCkgLSBzd2lwZVRvQ2xvc2UudGltZVN0YXJ0O1xuICAgIGlmICgodGltZURpZmYgPCAzMDAgJiYgZGlmZiA+IDIwKSB8fCAodGltZURpZmYgPj0gMzAwICYmIGRpZmYgPiAxMDApKSB7XG4gICAgICBVdGlscy5uZXh0VGljaygoKSA9PiB7XG4gICAgICAgIGlmIChwYi4kZWwpIHtcbiAgICAgICAgICBpZiAoc3dpcGVUb0Nsb3NlLmRpZmYgPCAwKSBwYi4kZWwuYWRkQ2xhc3MoJ3N3aXBlLWNsb3NlLXRvLWJvdHRvbScpO1xuICAgICAgICAgIGVsc2UgcGIuJGVsLmFkZENsYXNzKCdzd2lwZS1jbG9zZS10by10b3AnKTtcbiAgICAgICAgfVxuICAgICAgICBwYi5lbWl0KCdsb2NhbDo6c3dpcGVUb0Nsb3NlJywgcGIpO1xuICAgICAgICBwYi5jbG9zZSgpO1xuICAgICAgICBzd2lwZVRvQ2xvc2UuYWxsb3cgPSB0cnVlO1xuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChkaWZmICE9PSAwKSB7XG4gICAgICBzd2lwZVRvQ2xvc2UuYWN0aXZlU2xpZGUuYWRkQ2xhc3MoJ3Bob3RvLWJyb3dzZXItdHJhbnNpdGlvbmluZycpLnRyYW5zaXRpb25FbmQoKCkgPT4ge1xuICAgICAgICBzd2lwZVRvQ2xvc2UuYWxsb3cgPSB0cnVlO1xuICAgICAgICBzd2lwZVRvQ2xvc2UuYWN0aXZlU2xpZGUucmVtb3ZlQ2xhc3MoJ3Bob3RvLWJyb3dzZXItdHJhbnNpdGlvbmluZycpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN3aXBlVG9DbG9zZS5hbGxvdyA9IHRydWU7XG4gICAgfVxuICAgIHBiLnN3aXBlci4kZWwudHJhbnNpdGlvbignJykuY3NzKCdiYWNrZ3JvdW5kLWNvbG9yJywgJycpO1xuICAgIHN3aXBlVG9DbG9zZS5hY3RpdmVTbGlkZS50cmFuc2Zvcm0oJycpO1xuICB9XG5cbiAgLy8gUmVuZGVyIEZ1bmN0aW9uc1xuICByZW5kZXJOYXZiYXIoKSB7XG4gICAgY29uc3QgcGIgPSB0aGlzO1xuICAgIGlmIChwYi5wYXJhbXMucmVuZGVyTmF2YmFyKSByZXR1cm4gcGIucGFyYW1zLnJlbmRlck5hdmJhci5jYWxsKHBiKTtcblxuICAgIGxldCBpY29uc0NvbG9yID0gcGIucGFyYW1zLmljb25zQ29sb3I7XG4gICAgaWYgKCFwYi5wYXJhbXMuaWNvbnNDb2xvciAmJiBwYi5wYXJhbXMudGhlbWUgPT09ICdkYXJrJykgaWNvbnNDb2xvciA9ICd3aGl0ZSc7XG5cbiAgICBjb25zdCBiYWNrTGlua1RleHQgPSBwYi5hcHAudGhlbWUgPT09ICdpb3MnICYmIHBiLnBhcmFtcy5iYWNrTGlua1RleHQgPyBwYi5wYXJhbXMuYmFja0xpbmtUZXh0IDogJyc7XG5cbiAgICBjb25zdCBpc1BvcHVwID0gcGIucGFyYW1zLnR5cGUgIT09ICdwYWdlJztcbiAgICBjb25zdCBuYXZiYXJIdG1sID0gYFxuICAgICAgPGRpdiBjbGFzcz1cIm5hdmJhclwiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwibmF2YmFyLWlubmVyIHNsaWRpbmdcIj5cbiAgICAgICAgICA8ZGl2IGNsYXNzPVwibGVmdFwiPlxuICAgICAgICAgICAgPGEgaHJlZj1cIiNcIiBjbGFzcz1cImxpbmsgJHtpc1BvcHVwID8gJ3BvcHVwLWNsb3NlJyA6ICcnfSAkeyFiYWNrTGlua1RleHQgPyAnaWNvbi1vbmx5JyA6ICcnfSAkeyFpc1BvcHVwID8gJ2JhY2snIDogJyd9XCIgJHtpc1BvcHVwID8gJ2RhdGEtcG9wdXA9XCIucGhvdG8tYnJvd3Nlci1wb3B1cFwiJyA6ICcnfT5cbiAgICAgICAgICAgICAgPGkgY2xhc3M9XCJpY29uIGljb24tYmFjayAke2ljb25zQ29sb3IgPyBgY29sb3ItJHtpY29uc0NvbG9yfWAgOiAnJ31cIj48L2k+XG4gICAgICAgICAgICAgICR7YmFja0xpbmtUZXh0ID8gYDxzcGFuPiR7YmFja0xpbmtUZXh0fTwvc3Bhbj5gIDogJyd9XG4gICAgICAgICAgICA8L2E+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cInRpdGxlXCI+XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cInBob3RvLWJyb3dzZXItY3VycmVudFwiPjwvc3Bhbj5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwicGhvdG8tYnJvd3Nlci1vZlwiPiR7cGIucGFyYW1zLm5hdmJhck9mVGV4dH08L3NwYW4+XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cInBob3RvLWJyb3dzZXItdG90YWxcIj48L3NwYW4+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cInJpZ2h0XCI+PC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgYC50cmltKCk7XG4gICAgcmV0dXJuIG5hdmJhckh0bWw7XG4gIH1cbiAgcmVuZGVyVG9vbGJhcigpIHtcbiAgICBjb25zdCBwYiA9IHRoaXM7XG4gICAgaWYgKHBiLnBhcmFtcy5yZW5kZXJUb29sYmFyKSByZXR1cm4gcGIucGFyYW1zLnJlbmRlclRvb2xiYXIuY2FsbChwYik7XG5cbiAgICBsZXQgaWNvbnNDb2xvciA9IHBiLnBhcmFtcy5pY29uc0NvbG9yO1xuICAgIGlmICghcGIucGFyYW1zLmljb25zQ29sb3IgJiYgcGIucGFyYW1zLnRoZW1lID09PSAnZGFyaycpIGljb25zQ29sb3IgPSAnd2hpdGUnO1xuXG4gICAgY29uc3QgdG9vbGJhckh0bWwgPSBgXG4gICAgICA8ZGl2IGNsYXNzPVwidG9vbGJhciB0YWJiYXIgdG9vbGJhci1ib3R0b20tbWRcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cInRvb2xiYXItaW5uZXJcIj5cbiAgICAgICAgICA8YSBocmVmPVwiI1wiIGNsYXNzPVwibGluayBwaG90by1icm93c2VyLXByZXZcIj5cbiAgICAgICAgICAgIDxpIGNsYXNzPVwiaWNvbiBpY29uLWJhY2sgJHtpY29uc0NvbG9yID8gYGNvbG9yLSR7aWNvbnNDb2xvcn1gIDogJyd9XCI+PC9pPlxuICAgICAgICAgIDwvYT5cbiAgICAgICAgICA8YSBocmVmPVwiI1wiIGNsYXNzPVwibGluayBwaG90by1icm93c2VyLW5leHRcIj5cbiAgICAgICAgICAgIDxpIGNsYXNzPVwiaWNvbiBpY29uLWZvcndhcmQgJHtpY29uc0NvbG9yID8gYGNvbG9yLSR7aWNvbnNDb2xvcn1gIDogJyd9XCI+PC9pPlxuICAgICAgICAgIDwvYT5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICBgLnRyaW0oKTtcbiAgICByZXR1cm4gdG9vbGJhckh0bWw7XG4gIH1cbiAgcmVuZGVyQ2FwdGlvbihjYXB0aW9uLCBpbmRleCkge1xuICAgIGNvbnN0IHBiID0gdGhpcztcbiAgICBpZiAocGIucGFyYW1zLnJlbmRlckNhcHRpb24pIHJldHVybiBwYi5wYXJhbXMucmVuZGVyQ2FwdGlvbi5jYWxsKHBiLCBjYXB0aW9uLCBpbmRleCk7XG4gICAgY29uc3QgY2FwdGlvbkh0bWwgPSBgXG4gICAgICA8ZGl2IGNsYXNzPVwicGhvdG8tYnJvd3Nlci1jYXB0aW9uXCIgZGF0YS1jYXB0aW9uLWluZGV4PVwiJHtpbmRleH1cIj5cbiAgICAgICAgJHtjYXB0aW9ufVxuICAgICAgPC9kaXY+XG4gICAgYC50cmltKCk7XG4gICAgcmV0dXJuIGNhcHRpb25IdG1sO1xuICB9XG4gIHJlbmRlck9iamVjdChwaG90bywgaW5kZXgpIHtcbiAgICBjb25zdCBwYiA9IHRoaXM7XG4gICAgaWYgKHBiLnBhcmFtcy5yZW5kZXJPYmplY3QpIHJldHVybiBwYi5wYXJhbXMucmVuZGVyT2JqZWN0LmNhbGwocGIsIHBob3RvLCBpbmRleCk7XG4gICAgY29uc3Qgb2JqSHRtbCA9IGBcbiAgICAgIDxkaXYgY2xhc3M9XCJwaG90by1icm93c2VyLXNsaWRlIHBob3RvLWJyb3dzZXItb2JqZWN0LXNsaWRlIHN3aXBlci1zbGlkZVwiIGRhdGEtc3dpcGVyLXNsaWRlLWluZGV4PVwiJHtpbmRleH1cIj4ke3Bob3RvLmh0bWwgPyBwaG90by5odG1sIDogcGhvdG99PC9kaXY+XG4gICAgYDtcbiAgICByZXR1cm4gb2JqSHRtbDtcbiAgfVxuICByZW5kZXJMYXp5UGhvdG8ocGhvdG8sIGluZGV4KSB7XG4gICAgY29uc3QgcGIgPSB0aGlzO1xuICAgIGlmIChwYi5wYXJhbXMucmVuZGVyTGF6eVBob3RvKSByZXR1cm4gcGIucGFyYW1zLnJlbmRlckxhenlQaG90by5jYWxsKHBiLCBwaG90bywgaW5kZXgpO1xuICAgIGNvbnN0IHBob3RvSHRtbCA9IGBcbiAgICAgIDxkaXYgY2xhc3M9XCJwaG90by1icm93c2VyLXNsaWRlIHBob3RvLWJyb3dzZXItc2xpZGUtbGF6eSBzd2lwZXItc2xpZGVcIiBkYXRhLXN3aXBlci1zbGlkZS1pbmRleD1cIiR7aW5kZXh9XCI+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cInByZWxvYWRlciBzd2lwZXItbGF6eS1wcmVsb2FkZXIgJHtwYi5wYXJhbXMudGhlbWUgPT09ICdkYXJrJyA/ICdjb2xvci13aGl0ZScgOiAnJ31cIj4ke3BiLmFwcC50aGVtZSA9PT0gJ21kJyA/IFV0aWxzLm1kUHJlbG9hZGVyQ29udGVudCA6ICcnfTwvZGl2PlxuICAgICAgICAgIDxzcGFuIGNsYXNzPVwic3dpcGVyLXpvb20tY29udGFpbmVyXCI+XG4gICAgICAgICAgICAgIDxpbWcgZGF0YS1zcmM9XCIke3Bob3RvLnVybCA/IHBob3RvLnVybCA6IHBob3RvfVwiIGNsYXNzPVwic3dpcGVyLWxhenlcIj5cbiAgICAgICAgICA8L3NwYW4+XG4gICAgICA8L2Rpdj5cbiAgICBgLnRyaW0oKTtcbiAgICByZXR1cm4gcGhvdG9IdG1sO1xuICB9XG4gIHJlbmRlclBob3RvKHBob3RvLCBpbmRleCkge1xuICAgIGNvbnN0IHBiID0gdGhpcztcbiAgICBpZiAocGIucGFyYW1zLnJlbmRlclBob3RvKSByZXR1cm4gcGIucGFyYW1zLnJlbmRlclBob3RvLmNhbGwocGIsIHBob3RvLCBpbmRleCk7XG4gICAgY29uc3QgcGhvdG9IdG1sID0gYFxuICAgICAgPGRpdiBjbGFzcz1cInBob3RvLWJyb3dzZXItc2xpZGUgc3dpcGVyLXNsaWRlXCIgZGF0YS1zd2lwZXItc2xpZGUtaW5kZXg9XCIke2luZGV4fVwiPlxuICAgICAgICA8c3BhbiBjbGFzcz1cInN3aXBlci16b29tLWNvbnRhaW5lclwiPlxuICAgICAgICAgIDxpbWcgc3JjPVwiJHtwaG90by51cmwgPyBwaG90by51cmwgOiBwaG90b31cIj5cbiAgICAgICAgPC9zcGFuPlxuICAgICAgPC9kaXY+XG4gICAgYC50cmltKCk7XG4gICAgcmV0dXJuIHBob3RvSHRtbDtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgcGIgPSB0aGlzO1xuICAgIGlmIChwYi5wYXJhbXMucmVuZGVyKSByZXR1cm4gcGIucGFyYW1zLnJlbmRlci5jYWxsKHBiLCBwYi5wYXJhbXMpO1xuICAgIGNvbnN0IGh0bWwgPSBgXG4gICAgICA8ZGl2IGNsYXNzPVwicGhvdG8tYnJvd3NlciBwaG90by1icm93c2VyLSR7cGIucGFyYW1zLnRoZW1lfVwiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwidmlld1wiPlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJwYWdlIHBob3RvLWJyb3dzZXItcGFnZSBwaG90by1icm93c2VyLXBhZ2UtJHtwYi5wYXJhbXMudGhlbWV9IG5vLXRvb2xiYXIgJHshcGIucGFyYW1zLm5hdmJhciA/ICduby1uYXZiYXInIDogJyd9XCIgZGF0YS1uYW1lPVwicGhvdG8tYnJvd3Nlci1wYWdlXCI+XG4gICAgICAgICAgICAke3BiLnBhcmFtcy5uYXZiYXIgPyBwYi5yZW5kZXJOYXZiYXIoKSA6ICcnfVxuICAgICAgICAgICAgJHtwYi5wYXJhbXMudG9vbGJhciA/IHBiLnJlbmRlclRvb2xiYXIoKSA6ICcnfVxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cInBob3RvLWJyb3dzZXItY2FwdGlvbnMgcGhvdG8tYnJvd3Nlci1jYXB0aW9ucy0ke3BiLnBhcmFtcy5jYXB0aW9uc1RoZW1lIHx8IHBiLnBhcmFtcy50aGVtZX1cIj5cbiAgICAgICAgICAgICAgJHtwYi5wYXJhbXMucGhvdG9zLm1hcCgocGhvdG8sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHBob3RvLmNhcHRpb24pIHJldHVybiBwYi5yZW5kZXJDYXB0aW9uKHBob3RvLmNhcHRpb24sIGluZGV4KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICAgIH0pLmpvaW4oJyAnKX1cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cInBob3RvLWJyb3dzZXItc3dpcGVyLWNvbnRhaW5lciBzd2lwZXItY29udGFpbmVyXCI+XG4gICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJwaG90by1icm93c2VyLXN3aXBlci13cmFwcGVyIHN3aXBlci13cmFwcGVyXCI+XG4gICAgICAgICAgICAgICAgJHtwYi5wYXJhbXMudmlydHVhbFNsaWRlcyA/ICcnIDogcGIucGFyYW1zLnBob3Rvcy5tYXAoKHBob3RvLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgICAgaWYgKHBob3RvLmh0bWwgfHwgKCh0eXBlb2YgcGhvdG8gPT09ICdzdHJpbmcnIHx8IHBob3RvIGluc3RhbmNlb2YgU3RyaW5nKSAmJiBwaG90by5pbmRleE9mKCc8JykgPj0gMCAmJiBwaG90by5pbmRleE9mKCc+JykgPj0gMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBiLnJlbmRlck9iamVjdChwaG90bywgaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwYi5wYXJhbXMuc3dpcGVyLmxhenkgPT09IHRydWUgfHwgKHBiLnBhcmFtcy5zd2lwZXIubGF6eSAmJiBwYi5wYXJhbXMuc3dpcGVyLmxhenkuZW5hYmxlZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBiLnJlbmRlckxhenlQaG90byhwaG90bywgaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHBiLnJlbmRlclBob3RvKHBob3RvLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgfSkuam9pbignICcpfVxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIGAudHJpbSgpO1xuICAgIHJldHVybiBodG1sO1xuICB9XG4gIHJlbmRlclN0YW5kYWxvbmUoKSB7XG4gICAgY29uc3QgcGIgPSB0aGlzO1xuICAgIGlmIChwYi5wYXJhbXMucmVuZGVyU3RhbmRhbG9uZSkgcmV0dXJuIHBiLnBhcmFtcy5yZW5kZXJTdGFuZGFsb25lLmNhbGwocGIpO1xuICAgIGNvbnN0IHN0YW5kYWxvbmVIdG1sID0gYDxkaXYgY2xhc3M9XCJwb3B1cCBwaG90by1icm93c2VyLXBvcHVwIHBob3RvLWJyb3dzZXItc3RhbmRhbG9uZSBwb3B1cC10YWJsZXQtZnVsbHNjcmVlblwiPiR7cGIucmVuZGVyKCl9PC9kaXY+YDtcbiAgICByZXR1cm4gc3RhbmRhbG9uZUh0bWw7XG4gIH1cbiAgcmVuZGVyUGFnZSgpIHtcbiAgICBjb25zdCBwYiA9IHRoaXM7XG4gICAgaWYgKHBiLnBhcmFtcy5yZW5kZXJQYWdlKSByZXR1cm4gcGIucGFyYW1zLnJlbmRlclBhZ2UuY2FsbChwYik7XG4gICAgY29uc3QgcGFnZUh0bWwgPSBwYi5yZW5kZXIoKTtcblxuICAgIHJldHVybiBwYWdlSHRtbDtcbiAgfVxuICByZW5kZXJQb3B1cCgpIHtcbiAgICBjb25zdCBwYiA9IHRoaXM7XG4gICAgaWYgKHBiLnBhcmFtcy5yZW5kZXJQb3B1cCkgcmV0dXJuIHBiLnBhcmFtcy5yZW5kZXJQb3B1cC5jYWxsKHBiKTtcbiAgICBjb25zdCBwb3B1cEh0bWwgPSBgPGRpdiBjbGFzcz1cInBvcHVwIHBob3RvLWJyb3dzZXItcG9wdXBcIj4ke3BiLnJlbmRlcigpfTwvZGl2PmA7XG5cbiAgICByZXR1cm4gcG9wdXBIdG1sO1xuICB9XG5cbiAgLy8gQ2FsbGJhY2tzXG4gIG9uT3Blbih0eXBlLCBlbCkge1xuICAgIGNvbnN0IHBiID0gdGhpcztcbiAgICBjb25zdCBhcHAgPSBwYi5hcHA7XG4gICAgY29uc3QgJGVsID0gJChlbCk7XG5cbiAgICAkZWxbMF0uZjdQaG90b0Jyb3dzZXIgPSBwYjtcblxuICAgIHBiLiRlbCA9ICRlbDtcbiAgICBwYi5lbCA9ICRlbFswXTtcbiAgICBwYi5vcGVuZWRJbiA9IHR5cGU7XG4gICAgcGIub3BlbmVkID0gdHJ1ZTtcblxuICAgIHBiLiRzd2lwZXJDb250YWluZXJFbCA9IHBiLiRlbC5maW5kKCcucGhvdG8tYnJvd3Nlci1zd2lwZXItY29udGFpbmVyJyk7XG4gICAgcGIuJHN3aXBlcldyYXBwZXJFbCA9IHBiLiRlbC5maW5kKCcucGhvdG8tYnJvd3Nlci1zd2lwZXItd3JhcHBlcicpO1xuICAgIHBiLnNsaWRlcyA9IHBiLiRlbC5maW5kKCcucGhvdG8tYnJvd3Nlci1zbGlkZScpO1xuICAgIHBiLiRjYXB0aW9uc0NvbnRhaW5lckVsID0gcGIuJGVsLmZpbmQoJy5waG90by1icm93c2VyLWNhcHRpb25zJyk7XG4gICAgcGIuY2FwdGlvbnMgPSBwYi4kZWwuZmluZCgnLnBob3RvLWJyb3dzZXItY2FwdGlvbicpO1xuXG4gICAgLy8gSW5pdCBTd2lwZXJcbiAgICBjb25zdCBzd2lwZXJQYXJhbXMgPSBVdGlscy5leHRlbmQoe30sIHBiLnBhcmFtcy5zd2lwZXIsIHtcbiAgICAgIGluaXRpYWxTbGlkZTogcGIuYWN0aXZlSW5kZXgsXG4gICAgICBvbjoge1xuICAgICAgICB0YXAoZSkge1xuICAgICAgICAgIHBiLmVtaXQoJ2xvY2FsOjp0YXAnLCBlKTtcbiAgICAgICAgfSxcbiAgICAgICAgY2xpY2soZSkge1xuICAgICAgICAgIGlmIChwYi5wYXJhbXMuZXhwb3NpdGlvbikge1xuICAgICAgICAgICAgcGIuZXhwb3NpdGlvblRvZ2dsZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwYi5lbWl0KCdsb2NhbDo6Y2xpY2snLCBlKTtcbiAgICAgICAgfSxcbiAgICAgICAgZG91YmxlVGFwKGUpIHtcbiAgICAgICAgICBwYi5lbWl0KCdsb2NhbDo6ZG91YmxlVGFwJywgZSk7XG4gICAgICAgIH0sXG4gICAgICAgIHNsaWRlQ2hhbmdlKC4uLmFyZ3MpIHtcbiAgICAgICAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgICAgICAgIHBiLm9uU2xpZGVDaGFuZ2Uoc3dpcGVyKTtcbiAgICAgICAgICBwYi5lbWl0KCdsb2NhbDo6c2xpZGVDaGFuZ2UnLCAuLi5hcmdzKTtcbiAgICAgICAgfSxcbiAgICAgICAgdHJhbnNpdGlvblN0YXJ0KC4uLmFyZ3MpIHtcbiAgICAgICAgICBwYi5lbWl0KCdsb2NhbDo6dHJhbnNpdGlvblN0YXJ0JywgLi4uYXJncyk7XG4gICAgICAgIH0sXG4gICAgICAgIHRyYW5zaXRpb25FbmQoLi4uYXJncykge1xuICAgICAgICAgIHBiLmVtaXQoJ2xvY2FsOjp0cmFuc2l0aW9uRW5kJywgLi4uYXJncyk7XG4gICAgICAgIH0sXG4gICAgICAgIHNsaWRlQ2hhbmdlU3RhcnQoLi4uYXJncykge1xuICAgICAgICAgIHBiLmVtaXQoJ2xvY2FsOjpzbGlkZUNoYW5nZVRyYW5zaXRpb25TdGFydCcsIC4uLmFyZ3MpO1xuICAgICAgICB9LFxuICAgICAgICBzbGlkZUNoYW5nZUVuZCguLi5hcmdzKSB7XG4gICAgICAgICAgcGIuZW1pdCgnbG9jYWw6OnNsaWRlQ2hhbmdlVHJhbnNpdGlvbkVuZCcsIC4uLmFyZ3MpO1xuICAgICAgICB9LFxuICAgICAgICBsYXp5SW1hZ2VMb2FkKC4uLmFyZ3MpIHtcbiAgICAgICAgICBwYi5lbWl0KCdsb2NhbDo6bGF6eUltYWdlTG9hZCcsIC4uLmFyZ3MpO1xuICAgICAgICB9LFxuICAgICAgICBsYXp5SW1hZ2VSZWFkeSguLi5hcmdzKSB7XG4gICAgICAgICAgY29uc3Qgc2xpZGVFbCA9IGFyZ3NbMF07XG4gICAgICAgICAgJChzbGlkZUVsKS5yZW1vdmVDbGFzcygncGhvdG8tYnJvd3Nlci1zbGlkZS1sYXp5Jyk7XG4gICAgICAgICAgcGIuZW1pdCgnbG9jYWw6OmxhenlJbWFnZVJlYWR5JywgLi4uYXJncyk7XG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIH0pO1xuICAgIGlmIChwYi5wYXJhbXMuc3dpcGVUb0Nsb3NlICYmIHBiLnBhcmFtcy50eXBlICE9PSAncGFnZScpIHtcbiAgICAgIFV0aWxzLmV4dGVuZChzd2lwZXJQYXJhbXMub24sIHtcbiAgICAgICAgdG91Y2hTdGFydChlKSB7XG4gICAgICAgICAgcGIub25Ub3VjaFN0YXJ0KGUpO1xuICAgICAgICAgIHBiLmVtaXQoJ2xvY2FsOjp0b3VjaFN0YXJ0JywgZSk7XG4gICAgICAgIH0sXG4gICAgICAgIHRvdWNoTW92ZU9wcG9zaXRlKGUpIHtcbiAgICAgICAgICBwYi5vblRvdWNoTW92ZShlKTtcbiAgICAgICAgICBwYi5lbWl0KCdsb2NhbDo6dG91Y2hNb3ZlT3Bwb3NpdGUnLCBlKTtcbiAgICAgICAgfSxcbiAgICAgICAgdG91Y2hFbmQoZSkge1xuICAgICAgICAgIHBiLm9uVG91Y2hFbmQoZSk7XG4gICAgICAgICAgcGIuZW1pdCgnbG9jYWw6OnRvdWNoRW5kJywgZSk7XG4gICAgICAgIH0sXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHBiLnBhcmFtcy52aXJ0dWFsU2xpZGVzKSB7XG4gICAgICBVdGlscy5leHRlbmQoc3dpcGVyUGFyYW1zLCB7XG4gICAgICAgIHZpcnR1YWw6IHtcbiAgICAgICAgICBzbGlkZXM6IHBiLnBhcmFtcy5waG90b3MsXG4gICAgICAgICAgcmVuZGVyU2xpZGUocGhvdG8sIGluZGV4KSB7XG4gICAgICAgICAgICBpZiAocGhvdG8uaHRtbCB8fCAoKHR5cGVvZiBwaG90byA9PT0gJ3N0cmluZycgfHwgcGhvdG8gaW5zdGFuY2VvZiBTdHJpbmcpICYmIHBob3RvLmluZGV4T2YoJzwnKSA+PSAwICYmIHBob3RvLmluZGV4T2YoJz4nKSA+PSAwKSkge1xuICAgICAgICAgICAgICByZXR1cm4gcGIucmVuZGVyT2JqZWN0KHBob3RvLCBpbmRleCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBiLnBhcmFtcy5zd2lwZXIubGF6eSA9PT0gdHJ1ZSB8fCAocGIucGFyYW1zLnN3aXBlci5sYXp5ICYmIHBiLnBhcmFtcy5zd2lwZXIubGF6eS5lbmFibGVkKSkge1xuICAgICAgICAgICAgICByZXR1cm4gcGIucmVuZGVyTGF6eVBob3RvKHBob3RvLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcGIucmVuZGVyUGhvdG8ocGhvdG8sIGluZGV4KTtcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcGIuc3dpcGVyID0gYXBwLnN3aXBlci5jcmVhdGUocGIuJHN3aXBlckNvbnRhaW5lckVsLCBzd2lwZXJQYXJhbXMpO1xuXG4gICAgaWYgKHBiLmFjdGl2ZUluZGV4ID09PSAwKSB7XG4gICAgICBwYi5vblNsaWRlQ2hhbmdlKHBiLnN3aXBlcik7XG4gICAgfVxuICAgIGlmIChwYi4kZWwpIHtcbiAgICAgIHBiLiRlbC50cmlnZ2VyKCdwaG90b2Jyb3dzZXI6b3BlbicpO1xuICAgIH1cbiAgICBwYi5lbWl0KCdsb2NhbDo6b3BlbiBwaG90b0Jyb3dzZXJPcGVuJywgcGIpO1xuICB9XG4gIG9uT3BlbmVkKCkge1xuICAgIGNvbnN0IHBiID0gdGhpcztcblxuICAgIGlmIChwYi4kZWwpIHtcbiAgICAgIHBiLiRlbC50cmlnZ2VyKCdwaG90b2Jyb3dzZXI6b3BlbmVkJyk7XG4gICAgfVxuICAgIHBiLmVtaXQoJ2xvY2FsOjpvcGVuZWQgcGhvdG9Ccm93c2VyT3BlbmVkJywgcGIpO1xuICB9XG4gIG9uQ2xvc2UoKSB7XG4gICAgY29uc3QgcGIgPSB0aGlzO1xuICAgIGlmIChwYi5kZXN0cm95ZWQpIHJldHVybjtcblxuICAgIC8vIERlc3Ryb3kgU3dpcGVyXG4gICAgaWYgKHBiLnN3aXBlciAmJiBwYi5zd2lwZXIuZGVzdHJveSkge1xuICAgICAgcGIuc3dpcGVyLmRlc3Ryb3kodHJ1ZSwgZmFsc2UpO1xuICAgICAgcGIuc3dpcGVyID0gbnVsbDtcbiAgICAgIGRlbGV0ZSBwYi5zd2lwZXI7XG4gICAgfVxuICAgIGlmIChwYi4kZWwpIHtcbiAgICAgIHBiLiRlbC50cmlnZ2VyKCdwaG90b2Jyb3dzZXI6Y2xvc2UnKTtcbiAgICB9XG4gICAgcGIuZW1pdCgnbG9jYWw6OmNsb3NlIHBob3RvQnJvd3NlckNsb3NlJywgcGIpO1xuICB9XG4gIG9uQ2xvc2VkKCkge1xuICAgIGNvbnN0IHBiID0gdGhpcztcbiAgICBpZiAocGIuZGVzdHJveWVkKSByZXR1cm47XG4gICAgcGIub3BlbmVkID0gZmFsc2U7XG4gICAgcGIuJGVsID0gbnVsbDtcbiAgICBwYi5lbCA9IG51bGw7XG4gICAgZGVsZXRlIHBiLiRlbDtcbiAgICBkZWxldGUgcGIuZWw7XG4gICAgaWYgKHBiLiRlbCkge1xuICAgICAgcGIuJGVsLnRyaWdnZXIoJ3Bob3RvYnJvd3NlcjpjbG9zZWQnKTtcbiAgICB9XG4gICAgcGIuZW1pdCgnbG9jYWw6OmNsb3NlZCBwaG90b0Jyb3dzZXJDbG9zZWQnLCBwYik7XG4gIH1cblxuICAvLyBPcGVuXG4gIG9wZW5QYWdlKCkge1xuICAgIGNvbnN0IHBiID0gdGhpcztcbiAgICBpZiAocGIub3BlbmVkKSByZXR1cm4gcGI7XG5cbiAgICBjb25zdCBwYWdlSHRtbCA9IHBiLnJlbmRlclBhZ2UoKTtcblxuICAgIHBiLnZpZXcucm91dGVyLm5hdmlnYXRlKHtcbiAgICAgIHVybDogcGIudXJsLFxuICAgICAgcm91dGU6IHtcbiAgICAgICAgY29udGVudDogcGFnZUh0bWwsXG4gICAgICAgIHBhdGg6IHBiLnVybCxcbiAgICAgICAgb246IHtcbiAgICAgICAgICBwYWdlQmVmb3JlSW4oZSwgcGFnZSkge1xuICAgICAgICAgICAgcGIudmlldy4kZWwuYWRkQ2xhc3MoYHdpdGgtcGhvdG8tYnJvd3Nlci1wYWdlIHdpdGgtcGhvdG8tYnJvd3Nlci1wYWdlLSR7cGIucGFyYW1zLnRoZW1lfWApO1xuICAgICAgICAgICAgcGIub25PcGVuKCdwYWdlJywgcGFnZS5lbCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBwYWdlQWZ0ZXJJbihlLCBwYWdlKSB7XG4gICAgICAgICAgICBwYi5vbk9wZW5lZCgncGFnZScsIHBhZ2UuZWwpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgcGFnZUJlZm9yZU91dChlLCBwYWdlKSB7XG4gICAgICAgICAgICBwYi52aWV3LiRlbC5yZW1vdmVDbGFzcyhgd2l0aC1waG90by1icm93c2VyLXBhZ2Ugd2l0aC1waG90by1icm93c2VyLXBhZ2UtZXhwb3NlZCB3aXRoLXBob3RvLWJyb3dzZXItcGFnZS0ke3BiLnBhcmFtcy50aGVtZX1gKTtcbiAgICAgICAgICAgIHBiLm9uQ2xvc2UoJ3BhZ2UnLCBwYWdlLmVsKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHBhZ2VBZnRlck91dChlLCBwYWdlKSB7XG4gICAgICAgICAgICBwYi5vbkNsb3NlZCgncGFnZScsIHBhZ2UuZWwpO1xuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIH0pO1xuICAgIHJldHVybiBwYjtcbiAgfVxuXG4gIG9wZW5TdGFuZGFsb25lKCkge1xuICAgIGNvbnN0IHBiID0gdGhpcztcbiAgICBpZiAocGIub3BlbmVkKSByZXR1cm4gcGI7XG5cbiAgICBjb25zdCBzdGFuZGFsb25lSHRtbCA9IHBiLnJlbmRlclN0YW5kYWxvbmUoKTtcblxuICAgIGNvbnN0IHBvcHVwUGFyYW1zID0ge1xuICAgICAgYmFja2Ryb3A6IGZhbHNlLFxuICAgICAgY29udGVudDogc3RhbmRhbG9uZUh0bWwsXG4gICAgICBvbjoge1xuICAgICAgICBwb3B1cE9wZW4ocG9wdXApIHtcbiAgICAgICAgICBwYi5vbk9wZW4oJ3BvcHVwJywgcG9wdXAuZWwpO1xuICAgICAgICB9LFxuICAgICAgICBwb3B1cE9wZW5lZChwb3B1cCkge1xuICAgICAgICAgIHBiLm9uT3BlbmVkKCdwb3B1cCcsIHBvcHVwLmVsKTtcbiAgICAgICAgfSxcbiAgICAgICAgcG9wdXBDbG9zZShwb3B1cCkge1xuICAgICAgICAgIHBiLm9uQ2xvc2UoJ3BvcHVwJywgcG9wdXAuZWwpO1xuICAgICAgICB9LFxuICAgICAgICBwb3B1cENsb3NlZChwb3B1cCkge1xuICAgICAgICAgIHBiLm9uQ2xvc2VkKCdwb3B1cCcsIHBvcHVwLmVsKTtcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgfTtcblxuICAgIGlmIChwYi5wYXJhbXMucm91dGFibGVNb2RhbHMpIHtcbiAgICAgIHBiLnZpZXcucm91dGVyLm5hdmlnYXRlKHtcbiAgICAgICAgdXJsOiBwYi51cmwsXG4gICAgICAgIHJvdXRlOiB7XG4gICAgICAgICAgcGF0aDogcGIudXJsLFxuICAgICAgICAgIHBvcHVwOiBwb3B1cFBhcmFtcyxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYi5tb2RhbCA9IHBiLmFwcC5wb3B1cC5jcmVhdGUocG9wdXBQYXJhbXMpLm9wZW4oKTtcbiAgICB9XG4gICAgcmV0dXJuIHBiO1xuICB9XG5cbiAgb3BlblBvcHVwKCkge1xuICAgIGNvbnN0IHBiID0gdGhpcztcbiAgICBpZiAocGIub3BlbmVkKSByZXR1cm4gcGI7XG5cbiAgICBjb25zdCBwb3B1cEh0bWwgPSBwYi5yZW5kZXJQb3B1cCgpO1xuXG4gICAgY29uc3QgcG9wdXBQYXJhbXMgPSB7XG4gICAgICBjb250ZW50OiBwb3B1cEh0bWwsXG4gICAgICBvbjoge1xuICAgICAgICBwb3B1cE9wZW4ocG9wdXApIHtcbiAgICAgICAgICBwYi5vbk9wZW4oJ3BvcHVwJywgcG9wdXAuZWwpO1xuICAgICAgICB9LFxuICAgICAgICBwb3B1cE9wZW5lZChwb3B1cCkge1xuICAgICAgICAgIHBiLm9uT3BlbmVkKCdwb3B1cCcsIHBvcHVwLmVsKTtcbiAgICAgICAgfSxcbiAgICAgICAgcG9wdXBDbG9zZShwb3B1cCkge1xuICAgICAgICAgIHBiLm9uQ2xvc2UoJ3BvcHVwJywgcG9wdXAuZWwpO1xuICAgICAgICB9LFxuICAgICAgICBwb3B1cENsb3NlZChwb3B1cCkge1xuICAgICAgICAgIHBiLm9uQ2xvc2VkKCdwb3B1cCcsIHBvcHVwLmVsKTtcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgfTtcblxuICAgIGlmIChwYi5wYXJhbXMucm91dGFibGVNb2RhbHMpIHtcbiAgICAgIHBiLnZpZXcucm91dGVyLm5hdmlnYXRlKHtcbiAgICAgICAgdXJsOiBwYi51cmwsXG4gICAgICAgIHJvdXRlOiB7XG4gICAgICAgICAgcGF0aDogcGIudXJsLFxuICAgICAgICAgIHBvcHVwOiBwb3B1cFBhcmFtcyxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYi5tb2RhbCA9IHBiLmFwcC5wb3B1cC5jcmVhdGUocG9wdXBQYXJhbXMpLm9wZW4oKTtcbiAgICB9XG4gICAgcmV0dXJuIHBiO1xuICB9XG5cbiAgLy8gRXhwb3NpdGlvblxuICBleHBvc2l0aW9uRW5hYmxlKCkge1xuICAgIGNvbnN0IHBiID0gdGhpcztcbiAgICBpZiAocGIucGFyYW1zLnR5cGUgPT09ICdwYWdlJykge1xuICAgICAgcGIudmlldy4kZWwuYWRkQ2xhc3MoJ3dpdGgtcGhvdG8tYnJvd3Nlci1wYWdlLWV4cG9zZWQnKTtcbiAgICB9XG4gICAgaWYgKHBiLiRlbCkgcGIuJGVsLmFkZENsYXNzKCdwaG90by1icm93c2VyLWV4cG9zZWQnKTtcbiAgICBpZiAocGIucGFyYW1zLmV4cG9zaXRpb25IaWRlQ2FwdGlvbnMpIHBiLiRjYXB0aW9uc0NvbnRhaW5lckVsLmFkZENsYXNzKCdwaG90by1icm93c2VyLWNhcHRpb25zLWV4cG9zZWQnKTtcbiAgICBwYi5leHBvc2VkID0gdHJ1ZTtcbiAgICByZXR1cm4gcGI7XG4gIH1cbiAgZXhwb3NpdGlvbkRpc2FibGUoKSB7XG4gICAgY29uc3QgcGIgPSB0aGlzO1xuICAgIGlmIChwYi5wYXJhbXMudHlwZSA9PT0gJ3BhZ2UnKSB7XG4gICAgICBwYi52aWV3LiRlbC5yZW1vdmVDbGFzcygnd2l0aC1waG90by1icm93c2VyLXBhZ2UtZXhwb3NlZCcpO1xuICAgIH1cbiAgICBpZiAocGIuJGVsKSBwYi4kZWwucmVtb3ZlQ2xhc3MoJ3Bob3RvLWJyb3dzZXItZXhwb3NlZCcpO1xuICAgIGlmIChwYi5wYXJhbXMuZXhwb3NpdGlvbkhpZGVDYXB0aW9ucykgcGIuJGNhcHRpb25zQ29udGFpbmVyRWwucmVtb3ZlQ2xhc3MoJ3Bob3RvLWJyb3dzZXItY2FwdGlvbnMtZXhwb3NlZCcpO1xuICAgIHBiLmV4cG9zZWQgPSBmYWxzZTtcbiAgICByZXR1cm4gcGI7XG4gIH1cbiAgZXhwb3NpdGlvblRvZ2dsZSgpIHtcbiAgICBjb25zdCBwYiA9IHRoaXM7XG4gICAgaWYgKHBiLnBhcmFtcy50eXBlID09PSAncGFnZScpIHtcbiAgICAgIHBiLnZpZXcuJGVsLnRvZ2dsZUNsYXNzKCd3aXRoLXBob3RvLWJyb3dzZXItcGFnZS1leHBvc2VkJyk7XG4gICAgfVxuICAgIGlmIChwYi4kZWwpIHBiLiRlbC50b2dnbGVDbGFzcygncGhvdG8tYnJvd3Nlci1leHBvc2VkJyk7XG4gICAgaWYgKHBiLnBhcmFtcy5leHBvc2l0aW9uSGlkZUNhcHRpb25zKSBwYi4kY2FwdGlvbnNDb250YWluZXJFbC50b2dnbGVDbGFzcygncGhvdG8tYnJvd3Nlci1jYXB0aW9ucy1leHBvc2VkJyk7XG4gICAgcGIuZXhwb3NlZCA9ICFwYi5leHBvc2VkO1xuICAgIHJldHVybiBwYjtcbiAgfVxuICBvcGVuKGluZGV4KSB7XG4gICAgY29uc3QgcGIgPSB0aGlzO1xuICAgIGNvbnN0IHR5cGUgPSBwYi5wYXJhbXMudHlwZTtcbiAgICBpZiAocGIub3BlbmVkKSB7XG4gICAgICBpZiAocGIuc3dpcGVyICYmIHR5cGVvZiBpbmRleCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcGIuc3dpcGVyLnNsaWRlVG8ocGFyc2VJbnQoaW5kZXgsIDEwKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGI7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgaW5kZXggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBwYi5hY3RpdmVJbmRleCA9IGluZGV4O1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gJ3N0YW5kYWxvbmUnKSB7XG4gICAgICBwYi5vcGVuU3RhbmRhbG9uZSgpO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gJ3BhZ2UnKSB7XG4gICAgICBwYi5vcGVuUGFnZSgpO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gJ3BvcHVwJykge1xuICAgICAgcGIub3BlblBvcHVwKCk7XG4gICAgfVxuICAgIHJldHVybiBwYjtcbiAgfVxuICBjbG9zZSgpIHtcbiAgICBjb25zdCBwYiA9IHRoaXM7XG4gICAgaWYgKCFwYi5vcGVuZWQpIHJldHVybiBwYjtcbiAgICBpZiAocGIucGFyYW1zLnJvdXRhYmxlTW9kYWxzIHx8IHBiLm9wZW5lZEluID09PSAncGFnZScpIHtcbiAgICAgIGlmIChwYi52aWV3KSBwYi52aWV3LnJvdXRlci5iYWNrKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBiLm1vZGFsLm9uY2UoJ21vZGFsQ2xvc2VkJywgKCkgPT4ge1xuICAgICAgICBVdGlscy5uZXh0VGljaygoKSA9PiB7XG4gICAgICAgICAgcGIubW9kYWwuZGVzdHJveSgpO1xuICAgICAgICAgIGRlbGV0ZSBwYi5tb2RhbDtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHBiLm1vZGFsLmNsb3NlKCk7XG4gICAgfVxuICAgIHJldHVybiBwYjtcbiAgfVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgaW5pdCgpIHt9XG4gIGRlc3Ryb3koKSB7XG4gICAgbGV0IHBiID0gdGhpcztcbiAgICBwYi5lbWl0KCdsb2NhbDo6YmVmb3JlRGVzdHJveSBwaG90b0Jyb3dzZXJCZWZvcmVEZXN0cm95JywgcGIpO1xuICAgIGlmIChwYi4kZWwpIHtcbiAgICAgIHBiLiRlbC50cmlnZ2VyKCdwaG90b2Jyb3dzZXI6YmVmb3JlZGVzdHJveScpO1xuICAgICAgZGVsZXRlIHBiLiRlbFswXS5mN1Bob3RvQnJvd3NlcjtcbiAgICB9XG4gICAgVXRpbHMuZGVsZXRlUHJvcHMocGIpO1xuICAgIHBiID0gbnVsbDtcbiAgfVxufVxuXG52YXIgUGhvdG9Ccm93c2VyJDEgPSB7XG4gIG5hbWU6ICdwaG90b0Jyb3dzZXInLFxuICBwYXJhbXM6IHtcbiAgICBwaG90b0Jyb3dzZXI6IHtcbiAgICAgIHBob3RvczogW10sXG4gICAgICBleHBvc2l0aW9uOiB0cnVlLFxuICAgICAgZXhwb3NpdGlvbkhpZGVDYXB0aW9uczogZmFsc2UsXG4gICAgICB0eXBlOiAnc3RhbmRhbG9uZScsXG4gICAgICBuYXZiYXI6IHRydWUsXG4gICAgICB0b29sYmFyOiB0cnVlLFxuICAgICAgdGhlbWU6ICdsaWdodCcsXG4gICAgICBjYXB0aW9uc1RoZW1lOiB1bmRlZmluZWQsXG4gICAgICBpY29uc0NvbG9yOiB1bmRlZmluZWQsXG4gICAgICBzd2lwZVRvQ2xvc2U6IHRydWUsXG4gICAgICBiYWNrTGlua1RleHQ6ICdDbG9zZScsXG4gICAgICBuYXZiYXJPZlRleHQ6ICdvZicsXG4gICAgICB2aWV3OiB1bmRlZmluZWQsXG4gICAgICB1cmw6ICdwaG90b3MvJyxcbiAgICAgIHJvdXRhYmxlTW9kYWxzOiB0cnVlLFxuICAgICAgdmlydHVhbFNsaWRlczogdHJ1ZSxcblxuICAgICAgcmVuZGVyTmF2YmFyOiB1bmRlZmluZWQsXG4gICAgICByZW5kZXJUb29sYmFyOiB1bmRlZmluZWQsXG4gICAgICByZW5kZXJDYXB0aW9uOiB1bmRlZmluZWQsXG4gICAgICByZW5kZXJPYmplY3Q6IHVuZGVmaW5lZCxcbiAgICAgIHJlbmRlckxhenlQaG90bzogdW5kZWZpbmVkLFxuICAgICAgcmVuZGVyUGhvdG86IHVuZGVmaW5lZCxcbiAgICAgIHJlbmRlclBhZ2U6IHVuZGVmaW5lZCxcbiAgICAgIHJlbmRlclBvcHVwOiB1bmRlZmluZWQsXG4gICAgICByZW5kZXJTdGFuZGFsb25lOiB1bmRlZmluZWQsXG5cbiAgICAgIHN3aXBlcjoge1xuICAgICAgICBpbml0aWFsU2xpZGU6IDAsXG4gICAgICAgIHNwYWNlQmV0d2VlbjogMjAsXG4gICAgICAgIHNwZWVkOiAzMDAsXG4gICAgICAgIGxvb3A6IGZhbHNlLFxuICAgICAgICBwcmVsb2FkSW1hZ2VzOiB0cnVlLFxuICAgICAgICBuYXZpZ2F0aW9uOiB7XG4gICAgICAgICAgbmV4dEVsOiAnLnBob3RvLWJyb3dzZXItbmV4dCcsXG4gICAgICAgICAgcHJldkVsOiAnLnBob3RvLWJyb3dzZXItcHJldicsXG4gICAgICAgIH0sXG4gICAgICAgIHpvb206IHtcbiAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgIG1heFJhdGlvOiAzLFxuICAgICAgICAgIG1pblJhdGlvOiAxLFxuICAgICAgICB9LFxuICAgICAgICBsYXp5OiB7XG4gICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgfSxcbiAgfSxcbiAgY3JlYXRlKCkge1xuICAgIGNvbnN0IGFwcCA9IHRoaXM7XG4gICAgYXBwLnBob3RvQnJvd3NlciA9IENvbnN0cnVjdG9yTWV0aG9kcyh7XG4gICAgICBkZWZhdWx0U2VsZWN0b3I6ICcucGhvdG8tYnJvd3NlcicsXG4gICAgICBjb25zdHJ1Y3RvcjogUGhvdG9Ccm93c2VyLFxuICAgICAgYXBwLFxuICAgICAgZG9tUHJvcDogJ2Y3UGhvdG9Ccm93c2VyJyxcbiAgICB9KTtcbiAgfSxcbiAgc3RhdGljOiB7XG4gICAgUGhvdG9Ccm93c2VyLFxuICB9LFxufTtcblxuY2xhc3MgTm90aWZpY2F0aW9uIGV4dGVuZHMgTW9kYWwge1xuICBjb25zdHJ1Y3RvcihhcHAsIHBhcmFtcykge1xuICAgIGNvbnN0IGV4dGVuZGVkUGFyYW1zID0gVXRpbHMuZXh0ZW5kKHtcbiAgICAgIG9uOiB7fSxcbiAgICB9LCBhcHAucGFyYW1zLm5vdGlmaWNhdGlvbiwgcGFyYW1zKTtcblxuICAgIC8vIEV4dGVuZHMgd2l0aCBvcGVuL2Nsb3NlIE1vZGFsIG1ldGhvZHM7XG4gICAgc3VwZXIoYXBwLCBleHRlbmRlZFBhcmFtcyk7XG5cbiAgICBjb25zdCBub3RpZmljYXRpb24gPSB0aGlzO1xuXG4gICAgbm90aWZpY2F0aW9uLmFwcCA9IGFwcDtcblxuICAgIG5vdGlmaWNhdGlvbi5wYXJhbXMgPSBleHRlbmRlZFBhcmFtcztcblxuICAgIGNvbnN0IHtcbiAgICAgIGljb24sXG4gICAgICB0aXRsZSxcbiAgICAgIHRpdGxlUmlnaHRUZXh0LFxuICAgICAgc3VidGl0bGUsXG4gICAgICB0ZXh0LFxuICAgICAgY2xvc2VCdXR0b24sXG4gICAgICBjbG9zZVRpbWVvdXQsXG4gICAgICBjc3NDbGFzcyxcbiAgICAgIGNsb3NlT25DbGljayxcbiAgICB9ID0gbm90aWZpY2F0aW9uLnBhcmFtcztcblxuICAgIGxldCAkZWw7XG4gICAgaWYgKCFub3RpZmljYXRpb24ucGFyYW1zLmVsKSB7XG4gICAgICAvLyBGaW5kIEVsZW1lbnRcbiAgICAgIGNvbnN0IG5vdGlmaWNhdGlvbkh0bWwgPSBub3RpZmljYXRpb24ucmVuZGVyKHtcbiAgICAgICAgaWNvbixcbiAgICAgICAgdGl0bGUsXG4gICAgICAgIHRpdGxlUmlnaHRUZXh0LFxuICAgICAgICBzdWJ0aXRsZSxcbiAgICAgICAgdGV4dCxcbiAgICAgICAgY2xvc2VCdXR0b24sXG4gICAgICAgIGNzc0NsYXNzLFxuICAgICAgfSk7XG5cbiAgICAgICRlbCA9ICQobm90aWZpY2F0aW9uSHRtbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICRlbCA9ICQobm90aWZpY2F0aW9uLnBhcmFtcy5lbCk7XG4gICAgfVxuXG4gICAgaWYgKCRlbCAmJiAkZWwubGVuZ3RoID4gMCAmJiAkZWxbMF0uZjdNb2RhbCkge1xuICAgICAgcmV0dXJuICRlbFswXS5mN01vZGFsO1xuICAgIH1cblxuICAgIGlmICgkZWwubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gbm90aWZpY2F0aW9uLmRlc3Ryb3koKTtcbiAgICB9XG5cbiAgICBVdGlscy5leHRlbmQobm90aWZpY2F0aW9uLCB7XG4gICAgICAkZWwsXG4gICAgICBlbDogJGVsWzBdLFxuICAgICAgdHlwZTogJ25vdGlmaWNhdGlvbicsXG4gICAgfSk7XG5cbiAgICAkZWxbMF0uZjdNb2RhbCA9IG5vdGlmaWNhdGlvbjtcblxuICAgIGlmIChjbG9zZUJ1dHRvbikge1xuICAgICAgJGVsLmZpbmQoJy5ub3RpZmljYXRpb24tY2xvc2UtYnV0dG9uJykub24oJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgICBub3RpZmljYXRpb24uY2xvc2UoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAkZWwub24oJ2NsaWNrJywgKGUpID0+IHtcbiAgICAgIGlmIChjbG9zZUJ1dHRvbiAmJiAkKGUudGFyZ2V0KS5jbG9zZXN0KCcubm90aWZpY2F0aW9uLWNsb3NlLWJ1dHRvbicpLmxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBub3RpZmljYXRpb24uZW1pdCgnbG9jYWw6OmNsaWNrIG5vdGlmaWNhdGlvbkNsaWNrJywgbm90aWZpY2F0aW9uKTtcbiAgICAgIGlmIChjbG9zZU9uQ2xpY2spIG5vdGlmaWNhdGlvbi5jbG9zZSgpO1xuICAgIH0pO1xuXG4gICAgbm90aWZpY2F0aW9uLm9uKCdiZWZvcmVEZXN0cm95JywgKCkgPT4ge1xuICAgICAgJGVsLm9mZignY2xpY2snKTtcbiAgICB9KTtcblxuICAgIC8qIFRvdWNoIEV2ZW50cyAqL1xuICAgIGxldCBpc1RvdWNoZWQ7XG4gICAgbGV0IGlzTW92ZWQ7XG4gICAgbGV0IGlzU2Nyb2xsaW5nO1xuICAgIGxldCB0b3VjaGVzRGlmZjtcbiAgICBsZXQgdG91Y2hTdGFydFRpbWU7XG4gICAgbGV0IG5vdGlmaWNhdGlvbkhlaWdodDtcbiAgICBjb25zdCB0b3VjaGVzU3RhcnQgPSB7fTtcbiAgICBmdW5jdGlvbiBoYW5kbGVUb3VjaFN0YXJ0KGUpIHtcbiAgICAgIGlmIChpc1RvdWNoZWQpIHJldHVybjtcbiAgICAgIGlzVG91Y2hlZCA9IHRydWU7XG4gICAgICBpc01vdmVkID0gZmFsc2U7XG4gICAgICBpc1Njcm9sbGluZyA9IHVuZGVmaW5lZDtcbiAgICAgIHRvdWNoU3RhcnRUaW1lID0gVXRpbHMubm93KCk7XG4gICAgICB0b3VjaGVzU3RhcnQueCA9IGUudHlwZSA9PT0gJ3RvdWNoc3RhcnQnID8gZS50YXJnZXRUb3VjaGVzWzBdLnBhZ2VYIDogZS5wYWdlWDtcbiAgICAgIHRvdWNoZXNTdGFydC55ID0gZS50eXBlID09PSAndG91Y2hzdGFydCcgPyBlLnRhcmdldFRvdWNoZXNbMF0ucGFnZVkgOiBlLnBhZ2VZO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoYW5kbGVUb3VjaE1vdmUoZSkge1xuICAgICAgaWYgKCFpc1RvdWNoZWQpIHJldHVybjtcbiAgICAgIGNvbnN0IHBhZ2VYID0gZS50eXBlID09PSAndG91Y2htb3ZlJyA/IGUudGFyZ2V0VG91Y2hlc1swXS5wYWdlWCA6IGUucGFnZVg7XG4gICAgICBjb25zdCBwYWdlWSA9IGUudHlwZSA9PT0gJ3RvdWNobW92ZScgPyBlLnRhcmdldFRvdWNoZXNbMF0ucGFnZVkgOiBlLnBhZ2VZO1xuICAgICAgaWYgKHR5cGVvZiBpc1Njcm9sbGluZyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgaXNTY3JvbGxpbmcgPSAhIShpc1Njcm9sbGluZyB8fCBNYXRoLmFicyhwYWdlWSAtIHRvdWNoZXNTdGFydC55KSA8IE1hdGguYWJzKHBhZ2VYIC0gdG91Y2hlc1N0YXJ0LngpKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1Njcm9sbGluZykge1xuICAgICAgICBpc1RvdWNoZWQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgaWYgKCFpc01vdmVkKSB7XG4gICAgICAgIG5vdGlmaWNhdGlvbi4kZWwucmVtb3ZlQ2xhc3MoJ25vdGlmaWNhdGlvbi10cmFuc2l0aW9uaW5nJyk7XG4gICAgICAgIG5vdGlmaWNhdGlvbi4kZWwudHJhbnNpdGlvbigwKTtcbiAgICAgICAgbm90aWZpY2F0aW9uSGVpZ2h0ID0gbm90aWZpY2F0aW9uLiRlbFswXS5vZmZzZXRIZWlnaHQgLyAyO1xuICAgICAgfVxuICAgICAgaXNNb3ZlZCA9IHRydWU7XG4gICAgICB0b3VjaGVzRGlmZiA9IChwYWdlWSAtIHRvdWNoZXNTdGFydC55KTtcbiAgICAgIGxldCBuZXdUcmFuc2xhdGUgPSB0b3VjaGVzRGlmZjtcbiAgICAgIGlmICh0b3VjaGVzRGlmZiA+IDApIHtcbiAgICAgICAgbmV3VHJhbnNsYXRlID0gdG91Y2hlc0RpZmYgKiogMC44O1xuICAgICAgfVxuICAgICAgbm90aWZpY2F0aW9uLiRlbC50cmFuc2Zvcm0oYHRyYW5zbGF0ZTNkKDAsICR7bmV3VHJhbnNsYXRlfXB4LCAwKWApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoYW5kbGVUb3VjaEVuZCgpIHtcbiAgICAgIGlmICghaXNUb3VjaGVkIHx8ICFpc01vdmVkKSB7XG4gICAgICAgIGlzVG91Y2hlZCA9IGZhbHNlO1xuICAgICAgICBpc01vdmVkID0gZmFsc2U7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlzVG91Y2hlZCA9IGZhbHNlO1xuICAgICAgaXNNb3ZlZCA9IGZhbHNlO1xuICAgICAgaWYgKHRvdWNoZXNEaWZmID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdGltZURpZmYgPSBVdGlscy5ub3coKSAtIHRvdWNoU3RhcnRUaW1lO1xuICAgICAgbm90aWZpY2F0aW9uLiRlbC50cmFuc2l0aW9uKCcnKTtcbiAgICAgIG5vdGlmaWNhdGlvbi4kZWwuYWRkQ2xhc3MoJ25vdGlmaWNhdGlvbi10cmFuc2l0aW9uaW5nJyk7XG4gICAgICBub3RpZmljYXRpb24uJGVsLnRyYW5zZm9ybSgnJyk7XG5cbiAgICAgIGlmIChcbiAgICAgICAgKHRvdWNoZXNEaWZmIDwgLTEwICYmIHRpbWVEaWZmIDwgMzAwKSB8fFxuICAgICAgICAoLXRvdWNoZXNEaWZmID49IG5vdGlmaWNhdGlvbkhlaWdodCAvIDEpXG4gICAgICApIHtcbiAgICAgICAgbm90aWZpY2F0aW9uLmNsb3NlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXR0YWNoVG91Y2hFdmVudHMoKSB7XG4gICAgICB7XG4gICAgICAgIG5vdGlmaWNhdGlvbi4kZWwub24oYXBwLnRvdWNoRXZlbnRzLnN0YXJ0LCBoYW5kbGVUb3VjaFN0YXJ0LCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gICAgICAgIGFwcC5vbigndG91Y2htb3ZlOmFjdGl2ZScsIGhhbmRsZVRvdWNoTW92ZSk7XG4gICAgICAgIGFwcC5vbigndG91Y2hlbmQ6cGFzc2l2ZScsIGhhbmRsZVRvdWNoRW5kKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZGV0YWNoVG91Y2hFdmVudHMoKSB7XG4gICAgICB7XG4gICAgICAgIG5vdGlmaWNhdGlvbi4kZWwub2ZmKGFwcC50b3VjaEV2ZW50cy5zdGFydCwgaGFuZGxlVG91Y2hTdGFydCwgeyBwYXNzaXZlOiB0cnVlIH0pO1xuICAgICAgICBhcHAub2ZmKCd0b3VjaG1vdmU6YWN0aXZlJywgaGFuZGxlVG91Y2hNb3ZlKTtcbiAgICAgICAgYXBwLm9mZigndG91Y2hlbmQ6cGFzc2l2ZScsIGhhbmRsZVRvdWNoRW5kKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgdGltZW91dElkO1xuICAgIGZ1bmN0aW9uIGNsb3NlT25UaW1lb3V0KCkge1xuICAgICAgdGltZW91dElkID0gVXRpbHMubmV4dFRpY2soKCkgPT4ge1xuICAgICAgICBpZiAoaXNUb3VjaGVkICYmIGlzTW92ZWQpIHtcbiAgICAgICAgICBjbG9zZU9uVGltZW91dCgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBub3RpZmljYXRpb24uY2xvc2UoKTtcbiAgICAgIH0sIGNsb3NlVGltZW91dCk7XG4gICAgfVxuICAgIG5vdGlmaWNhdGlvbi5vbignb3BlbicsICgpID0+IHtcbiAgICAgIGlmIChub3RpZmljYXRpb24ucGFyYW1zLnN3aXBlVG9DbG9zZSkge1xuICAgICAgICBhdHRhY2hUb3VjaEV2ZW50cygpO1xuICAgICAgfVxuICAgICAgJCgnLm5vdGlmaWNhdGlvbi5tb2RhbC1pbicpLmVhY2goKGluZGV4LCBvcGVuZWRFbCkgPT4ge1xuICAgICAgICBjb25zdCBub3RpZmljYXRpb25JbnN0YW5jZSA9IGFwcC5ub3RpZmljYXRpb24uZ2V0KG9wZW5lZEVsKTtcbiAgICAgICAgaWYgKG9wZW5lZEVsICE9PSBub3RpZmljYXRpb24uZWwgJiYgbm90aWZpY2F0aW9uSW5zdGFuY2UpIHtcbiAgICAgICAgICBub3RpZmljYXRpb25JbnN0YW5jZS5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmIChjbG9zZVRpbWVvdXQpIHtcbiAgICAgICAgY2xvc2VPblRpbWVvdXQoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBub3RpZmljYXRpb24ub24oJ2Nsb3NlIGJlZm9yZURlc3Ryb3knLCAoKSA9PiB7XG4gICAgICBpZiAobm90aWZpY2F0aW9uLnBhcmFtcy5zd2lwZVRvQ2xvc2UpIHtcbiAgICAgICAgZGV0YWNoVG91Y2hFdmVudHMoKTtcbiAgICAgIH1cbiAgICAgIHdpbmRvdyQxLmNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIG5vdGlmaWNhdGlvbjtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgY29uc3Qgbm90aWZpY2F0aW9uID0gdGhpcztcbiAgICBpZiAobm90aWZpY2F0aW9uLnBhcmFtcy5yZW5kZXIpIHJldHVybiBub3RpZmljYXRpb24ucGFyYW1zLnJlbmRlci5jYWxsKG5vdGlmaWNhdGlvbiwgbm90aWZpY2F0aW9uKTtcbiAgICBjb25zdCB7IGljb24sIHRpdGxlLCB0aXRsZVJpZ2h0VGV4dCwgc3VidGl0bGUsIHRleHQsIGNsb3NlQnV0dG9uLCBjc3NDbGFzcyB9ID0gbm90aWZpY2F0aW9uLnBhcmFtcztcbiAgICByZXR1cm4gYFxuICAgICAgPGRpdiBjbGFzcz1cIm5vdGlmaWNhdGlvbiAke2Nzc0NsYXNzIHx8ICcnfVwiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwibm90aWZpY2F0aW9uLWhlYWRlclwiPlxuICAgICAgICAgICR7aWNvbiA/IGA8ZGl2IGNsYXNzPVwibm90aWZpY2F0aW9uLWljb25cIj4ke2ljb259PC9kaXY+YCA6ICcnfVxuICAgICAgICAgICR7dGl0bGUgPyBgPGRpdiBjbGFzcz1cIm5vdGlmaWNhdGlvbi10aXRsZVwiPiR7dGl0bGV9PC9kaXY+YCA6ICcnfVxuICAgICAgICAgICR7dGl0bGVSaWdodFRleHQgPyBgPGRpdiBjbGFzcz1cIm5vdGlmaWNhdGlvbi10aXRsZS1yaWdodC10ZXh0XCI+JHt0aXRsZVJpZ2h0VGV4dH08L2Rpdj5gIDogJyd9XG4gICAgICAgICAgJHtjbG9zZUJ1dHRvbiA/ICc8c3BhbiBjbGFzcz1cIm5vdGlmaWNhdGlvbi1jbG9zZS1idXR0b25cIj48L3NwYW4+JyA6ICcnfVxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzcz1cIm5vdGlmaWNhdGlvbi1jb250ZW50XCI+XG4gICAgICAgICAgJHtzdWJ0aXRsZSA/IGA8ZGl2IGNsYXNzPVwibm90aWZpY2F0aW9uLXN1YnRpdGxlXCI+JHtzdWJ0aXRsZX08L2Rpdj5gIDogJyd9XG4gICAgICAgICAgJHt0ZXh0ID8gYDxkaXYgY2xhc3M9XCJub3RpZmljYXRpb24tdGV4dFwiPiR7dGV4dH08L2Rpdj5gIDogJyd9XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgYC50cmltKCk7XG4gIH1cbn1cblxudmFyIE5vdGlmaWNhdGlvbiQxID0ge1xuICBuYW1lOiAnbm90aWZpY2F0aW9uJyxcbiAgc3RhdGljOiB7XG4gICAgTm90aWZpY2F0aW9uLFxuICB9LFxuICBjcmVhdGUoKSB7XG4gICAgY29uc3QgYXBwID0gdGhpcztcbiAgICBhcHAubm90aWZpY2F0aW9uID0gVXRpbHMuZXh0ZW5kKFxuICAgICAge30sXG4gICAgICBNb2RhbE1ldGhvZHMoe1xuICAgICAgICBhcHAsXG4gICAgICAgIGNvbnN0cnVjdG9yOiBOb3RpZmljYXRpb24sXG4gICAgICAgIGRlZmF1bHRTZWxlY3RvcjogJy5ub3RpZmljYXRpb24ubW9kYWwtaW4nLFxuICAgICAgfSlcbiAgICApO1xuICB9LFxuICBwYXJhbXM6IHtcbiAgICBub3RpZmljYXRpb246IHtcbiAgICAgIGljb246IG51bGwsXG4gICAgICB0aXRsZTogbnVsbCxcbiAgICAgIHRpdGxlUmlnaHRUZXh0OiBudWxsLFxuICAgICAgc3VidGl0bGU6IG51bGwsXG4gICAgICB0ZXh0OiBudWxsLFxuICAgICAgY2xvc2VCdXR0b246IGZhbHNlLFxuICAgICAgY2xvc2VUaW1lb3V0OiBudWxsLFxuICAgICAgY2xvc2VPbkNsaWNrOiBmYWxzZSxcbiAgICAgIHN3aXBlVG9DbG9zZTogdHJ1ZSxcbiAgICAgIGNzc0NsYXNzOiBudWxsLFxuICAgICAgcmVuZGVyOiBudWxsLFxuICAgIH0sXG4gIH0sXG59O1xuXG4vKiBlc2xpbnQgXCJuby11c2VsZXNzLWVzY2FwZVwiOiBcIm9mZlwiICovXG5cbmNsYXNzIEF1dG9jb21wbGV0ZSBleHRlbmRzIEZyYW1ld29yazdDbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGFwcCwgcGFyYW1zID0ge30pIHtcbiAgICBzdXBlcihwYXJhbXMsIFthcHBdKTtcblxuICAgIGNvbnN0IGFjID0gdGhpcztcbiAgICBhYy5hcHAgPSBhcHA7XG5cbiAgICBjb25zdCBkZWZhdWx0cyA9IFV0aWxzLmV4dGVuZCh7XG4gICAgICBvbjoge30sXG4gICAgfSwgYXBwLnBhcmFtcy5hdXRvY29tcGxldGUpO1xuXG5cbiAgICAvLyBFeHRlbmQgZGVmYXVsdHMgd2l0aCBtb2R1bGVzIHBhcmFtc1xuICAgIGFjLnVzZU1vZHVsZXNQYXJhbXMoZGVmYXVsdHMpO1xuXG4gICAgYWMucGFyYW1zID0gVXRpbHMuZXh0ZW5kKGRlZmF1bHRzLCBwYXJhbXMpO1xuXG4gICAgbGV0ICRvcGVuZXJFbDtcbiAgICBpZiAoYWMucGFyYW1zLm9wZW5lckVsKSB7XG4gICAgICAkb3BlbmVyRWwgPSAkKGFjLnBhcmFtcy5vcGVuZXJFbCk7XG4gICAgICBpZiAoJG9wZW5lckVsLmxlbmd0aCkgJG9wZW5lckVsWzBdLmY3QXV0b2NvbXBsZXRlID0gYWM7XG4gICAgfVxuXG4gICAgbGV0ICRpbnB1dEVsO1xuICAgIGlmIChhYy5wYXJhbXMuaW5wdXRFbCkge1xuICAgICAgJGlucHV0RWwgPSAkKGFjLnBhcmFtcy5pbnB1dEVsKTtcbiAgICAgIGlmICgkaW5wdXRFbC5sZW5ndGgpICRpbnB1dEVsWzBdLmY3QXV0b2NvbXBsZXRlID0gYWM7XG4gICAgfVxuXG4gICAgbGV0IHZpZXc7XG4gICAgaWYgKGFjLnBhcmFtcy52aWV3KSB7XG4gICAgICB2aWV3ID0gYWMucGFyYW1zLnZpZXc7XG4gICAgfSBlbHNlIGlmICgkb3BlbmVyRWwgfHwgJGlucHV0RWwpIHtcbiAgICAgIHZpZXcgPSBhcHAudmlld3MuZ2V0KCRvcGVuZXJFbCB8fCAkaW5wdXRFbCk7XG4gICAgfVxuICAgIGlmICghdmlldykgdmlldyA9IGFwcC52aWV3cy5tYWluO1xuXG4gICAgY29uc3QgaWQgPSBVdGlscy5ub3coKTtcblxuICAgIGxldCB1cmwgPSBwYXJhbXMudXJsO1xuICAgIGlmICghdXJsICYmICRvcGVuZXJFbCAmJiAkb3BlbmVyRWwubGVuZ3RoKSB7XG4gICAgICBpZiAoJG9wZW5lckVsLmF0dHIoJ2hyZWYnKSkgdXJsID0gJG9wZW5lckVsLmF0dHIoJ2hyZWYnKTtcbiAgICAgIGVsc2UgaWYgKCRvcGVuZXJFbC5maW5kKCdhJykubGVuZ3RoID4gMCkge1xuICAgICAgICB1cmwgPSAkb3BlbmVyRWwuZmluZCgnYScpLmF0dHIoJ2hyZWYnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCF1cmwgfHwgdXJsID09PSAnIycgfHwgdXJsID09PSAnJykgdXJsID0gYWMucGFyYW1zLnVybDtcblxuICAgIGNvbnN0IGlucHV0VHlwZSA9IGFjLnBhcmFtcy5tdWx0aXBsZSA/ICdjaGVja2JveCcgOiAncmFkaW8nO1xuXG4gICAgVXRpbHMuZXh0ZW5kKGFjLCB7XG4gICAgICAkb3BlbmVyRWwsXG4gICAgICBvcGVuZXJFbDogJG9wZW5lckVsICYmICRvcGVuZXJFbFswXSxcbiAgICAgICRpbnB1dEVsLFxuICAgICAgaW5wdXRFbDogJGlucHV0RWwgJiYgJGlucHV0RWxbMF0sXG4gICAgICBpZCxcbiAgICAgIHZpZXcsXG4gICAgICB1cmwsXG4gICAgICB2YWx1ZTogYWMucGFyYW1zLnZhbHVlIHx8IFtdLFxuICAgICAgaW5wdXRUeXBlLFxuICAgICAgaW5wdXROYW1lOiBgJHtpbnB1dFR5cGV9LSR7aWR9YCxcbiAgICAgICRtb2RhbEVsOiB1bmRlZmluZWQsXG4gICAgICAkZHJvcGRvd25FbDogdW5kZWZpbmVkLFxuICAgIH0pO1xuXG4gICAgbGV0IHByZXZpb3VzUXVlcnkgPSAnJztcbiAgICBmdW5jdGlvbiBvbklucHV0Q2hhbmdlKCkge1xuICAgICAgbGV0IHF1ZXJ5ID0gYWMuJGlucHV0RWwudmFsKCkudHJpbSgpO1xuXG4gICAgICBpZiAoIWFjLnBhcmFtcy5zb3VyY2UpIHJldHVybjtcbiAgICAgIGFjLnBhcmFtcy5zb3VyY2UuY2FsbChhYywgcXVlcnksIChpdGVtcykgPT4ge1xuICAgICAgICBsZXQgaXRlbXNIVE1MID0gJyc7XG4gICAgICAgIGNvbnN0IGxpbWl0ID0gYWMucGFyYW1zLmxpbWl0ID8gTWF0aC5taW4oYWMucGFyYW1zLmxpbWl0LCBpdGVtcy5sZW5ndGgpIDogaXRlbXMubGVuZ3RoO1xuICAgICAgICBhYy5pdGVtcyA9IGl0ZW1zO1xuICAgICAgICBsZXQgcmVnRXhwO1xuICAgICAgICBpZiAoYWMucGFyYW1zLmhpZ2hsaWdodE1hdGNoZXMpIHtcbiAgICAgICAgICBxdWVyeSA9IHF1ZXJ5LnJlcGxhY2UoL1tcXC1cXFtcXF1cXC9cXHtcXH1cXChcXClcXCpcXCtcXD9cXC5cXFxcXFxeXFwkXFx8XS9nLCAnXFxcXCQmJyk7XG4gICAgICAgICAgcmVnRXhwID0gbmV3IFJlZ0V4cChgKCR7cXVlcnl9KWAsICdpJyk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgZmlyc3RWYWx1ZTtcbiAgICAgICAgbGV0IGZpcnN0SXRlbTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW1pdDsgaSArPSAxKSB7XG4gICAgICAgICAgY29uc3QgaXRlbVZhbHVlID0gdHlwZW9mIGl0ZW1zW2ldID09PSAnb2JqZWN0JyA/IGl0ZW1zW2ldW2FjLnBhcmFtcy52YWx1ZVByb3BlcnR5XSA6IGl0ZW1zW2ldO1xuICAgICAgICAgIGNvbnN0IGl0ZW1UZXh0ID0gdHlwZW9mIGl0ZW1zW2ldID09PSAnb2JqZWN0JyA/IGl0ZW1zW2ldW2FjLnBhcmFtcy50ZXh0UHJvcGVydHldIDogaXRlbXNbaV07XG4gICAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgIGZpcnN0VmFsdWUgPSBpdGVtVmFsdWU7XG4gICAgICAgICAgICBmaXJzdEl0ZW0gPSBhYy5pdGVtc1tpXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaXRlbXNIVE1MICs9IGFjLnJlbmRlckl0ZW0oe1xuICAgICAgICAgICAgdmFsdWU6IGl0ZW1WYWx1ZSxcbiAgICAgICAgICAgIHRleHQ6IGFjLnBhcmFtcy5oaWdobGlnaHRNYXRjaGVzID8gaXRlbVRleHQucmVwbGFjZShyZWdFeHAsICc8Yj4kMTwvYj4nKSA6IGl0ZW1UZXh0LFxuICAgICAgICAgIH0sIGkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpdGVtc0hUTUwgPT09ICcnICYmIHF1ZXJ5ID09PSAnJyAmJiBhYy5wYXJhbXMuZHJvcGRvd25QbGFjZWhvbGRlclRleHQpIHtcbiAgICAgICAgICBpdGVtc0hUTUwgKz0gYWMucmVuZGVySXRlbSh7XG4gICAgICAgICAgICBwbGFjZWhvbGRlcjogdHJ1ZSxcbiAgICAgICAgICAgIHRleHQ6IGFjLnBhcmFtcy5kcm9wZG93blBsYWNlaG9sZGVyVGV4dCxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBhYy4kZHJvcGRvd25FbC5maW5kKCd1bCcpLmh0bWwoaXRlbXNIVE1MKTtcbiAgICAgICAgaWYgKGFjLnBhcmFtcy50eXBlYWhlYWQpIHtcbiAgICAgICAgICBpZiAoIWZpcnN0VmFsdWUgfHwgIWZpcnN0SXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZmlyc3RWYWx1ZS50b0xvd2VyQ2FzZSgpLmluZGV4T2YocXVlcnkudG9Mb3dlckNhc2UoKSkgIT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHByZXZpb3VzUXVlcnkudG9Mb3dlckNhc2UoKSA9PT0gcXVlcnkudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgYWMudmFsdWUgPSBbXTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocHJldmlvdXNRdWVyeS50b0xvd2VyQ2FzZSgpLmluZGV4T2YocXVlcnkudG9Mb3dlckNhc2UoKSkgPT09IDApIHtcbiAgICAgICAgICAgIHByZXZpb3VzUXVlcnkgPSBxdWVyeTtcbiAgICAgICAgICAgIGFjLnZhbHVlID0gW107XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgICRpbnB1dEVsLnZhbChmaXJzdFZhbHVlKTtcbiAgICAgICAgICAkaW5wdXRFbFswXS5zZXRTZWxlY3Rpb25SYW5nZShxdWVyeS5sZW5ndGgsIGZpcnN0VmFsdWUubGVuZ3RoKTtcblxuICAgICAgICAgIGNvbnN0IHByZXZpb3VzVmFsdWUgPSB0eXBlb2YgYWMudmFsdWVbMF0gPT09ICdvYmplY3QnID8gYWMudmFsdWVbMF1bYWMucGFyYW1zLnZhbHVlUHJvcGVydHldIDogYWMudmFsdWVbMF07XG4gICAgICAgICAgaWYgKCFwcmV2aW91c1ZhbHVlIHx8IGZpcnN0VmFsdWUudG9Mb3dlckNhc2UoKSAhPT0gcHJldmlvdXNWYWx1ZS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICBhYy52YWx1ZSA9IFtmaXJzdEl0ZW1dO1xuICAgICAgICAgICAgYWMuZW1pdCgnbG9jYWw6OmNoYW5nZSBhdXRvY29tcGxldGVDaGFuZ2UnLCBbZmlyc3RJdGVtXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcHJldmlvdXNRdWVyeSA9IHF1ZXJ5O1xuICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uUGFnZUlucHV0Q2hhbmdlKCkge1xuICAgICAgY29uc3QgaW5wdXQgPSB0aGlzO1xuICAgICAgY29uc3QgdmFsdWUgPSBpbnB1dC52YWx1ZTtcbiAgICAgIGNvbnN0IGlzVmFsdWVzID0gJChpbnB1dCkucGFyZW50cygnLmF1dG9jb21wbGV0ZS12YWx1ZXMnKS5sZW5ndGggPiAwO1xuICAgICAgbGV0IGl0ZW07XG4gICAgICBsZXQgaXRlbVZhbHVlO1xuICAgICAgbGV0IGFWYWx1ZTtcbiAgICAgIGlmIChpc1ZhbHVlcykge1xuICAgICAgICBpZiAoYWMuaW5wdXRUeXBlID09PSAnY2hlY2tib3gnICYmICFpbnB1dC5jaGVja2VkKSB7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhYy52YWx1ZS5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgYVZhbHVlID0gdHlwZW9mIGFjLnZhbHVlW2ldID09PSAnc3RyaW5nJyA/IGFjLnZhbHVlW2ldIDogYWMudmFsdWVbaV1bYWMucGFyYW1zLnZhbHVlUHJvcGVydHldO1xuICAgICAgICAgICAgaWYgKGFWYWx1ZSA9PT0gdmFsdWUgfHwgYVZhbHVlICogMSA9PT0gdmFsdWUgKiAxKSB7XG4gICAgICAgICAgICAgIGFjLnZhbHVlLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYWMudXBkYXRlVmFsdWVzKCk7XG4gICAgICAgICAgYWMuZW1pdCgnbG9jYWw6OmNoYW5nZSBhdXRvY29tcGxldGVDaGFuZ2UnLCBhYy52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBGaW5kIFJlbGF0ZWQgSXRlbVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhYy5pdGVtcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBpdGVtVmFsdWUgPSB0eXBlb2YgYWMuaXRlbXNbaV0gPT09ICdvYmplY3QnID8gYWMuaXRlbXNbaV1bYWMucGFyYW1zLnZhbHVlUHJvcGVydHldIDogYWMuaXRlbXNbaV07XG4gICAgICAgIGlmIChpdGVtVmFsdWUgPT09IHZhbHVlIHx8IGl0ZW1WYWx1ZSAqIDEgPT09IHZhbHVlICogMSkgaXRlbSA9IGFjLml0ZW1zW2ldO1xuICAgICAgfVxuICAgICAgaWYgKGFjLmlucHV0VHlwZSA9PT0gJ3JhZGlvJykge1xuICAgICAgICBhYy52YWx1ZSA9IFtpdGVtXTtcbiAgICAgIH0gZWxzZSBpZiAoaW5wdXQuY2hlY2tlZCkge1xuICAgICAgICBhYy52YWx1ZS5wdXNoKGl0ZW0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhYy52YWx1ZS5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgIGFWYWx1ZSA9IHR5cGVvZiBhYy52YWx1ZVtpXSA9PT0gJ29iamVjdCcgPyBhYy52YWx1ZVtpXVthYy5wYXJhbXMudmFsdWVQcm9wZXJ0eV0gOiBhYy52YWx1ZVtpXTtcbiAgICAgICAgICBpZiAoYVZhbHVlID09PSB2YWx1ZSB8fCBhVmFsdWUgKiAxID09PSB2YWx1ZSAqIDEpIHtcbiAgICAgICAgICAgIGFjLnZhbHVlLnNwbGljZShpLCAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVXBkYXRlIFZhbHVlcyBCbG9ja1xuICAgICAgYWMudXBkYXRlVmFsdWVzKCk7XG5cbiAgICAgIC8vIE9uIFNlbGVjdCBDYWxsYmFja1xuICAgICAgaWYgKCgoYWMuaW5wdXRUeXBlID09PSAncmFkaW8nICYmIGlucHV0LmNoZWNrZWQpIHx8IGFjLmlucHV0VHlwZSA9PT0gJ2NoZWNrYm94JykpIHtcbiAgICAgICAgYWMuZW1pdCgnbG9jYWw6OmNoYW5nZSBhdXRvY29tcGxldGVDaGFuZ2UnLCBhYy52YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uSHRtbENsaWNrKGUpIHtcbiAgICAgIGNvbnN0ICR0YXJnZXRFbCA9ICQoZS50YXJnZXQpO1xuICAgICAgaWYgKCR0YXJnZXRFbC5pcyhhYy4kaW5wdXRFbFswXSkgfHwgKGFjLiRkcm9wZG93bkVsICYmICR0YXJnZXRFbC5jbG9zZXN0KGFjLiRkcm9wZG93bkVsWzBdKS5sZW5ndGgpKSByZXR1cm47XG4gICAgICBhYy5jbG9zZSgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvbk9wZW5lckNsaWNrKCkge1xuICAgICAgYWMub3BlbigpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvbklucHV0Rm9jdXMoKSB7XG4gICAgICBhYy5vcGVuKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uSW5wdXRCbHVyKCkge1xuICAgICAgaWYgKGFjLiRkcm9wZG93bkVsLmZpbmQoJ2xhYmVsLmFjdGl2ZS1zdGF0ZScpLmxlbmd0aCA+IDApIHJldHVybjtcbiAgICAgIGFjLmNsb3NlKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uUmVzaXplKCkge1xuICAgICAgYWMucG9zaXRpb25Ecm9wRG93bigpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uS2V5RG93bihlKSB7XG4gICAgICBpZiAoYWMub3BlbmVkICYmIGUua2V5Q29kZSA9PT0gMTMpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBhYy4kaW5wdXRFbC5ibHVyKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uRHJvcGRvd25jbGljaygpIHtcbiAgICAgIGNvbnN0ICRjbGlja2VkRWwgPSAkKHRoaXMpO1xuICAgICAgbGV0IGNsaWNrZWRJdGVtO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhYy5pdGVtcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBjb25zdCBpdGVtVmFsdWUgPSB0eXBlb2YgYWMuaXRlbXNbaV0gPT09ICdvYmplY3QnID8gYWMuaXRlbXNbaV1bYWMucGFyYW1zLnZhbHVlUHJvcGVydHldIDogYWMuaXRlbXNbaV07XG4gICAgICAgIGNvbnN0IHZhbHVlID0gJGNsaWNrZWRFbC5hdHRyKCdkYXRhLXZhbHVlJyk7XG4gICAgICAgIGlmIChpdGVtVmFsdWUgPT09IHZhbHVlIHx8IGl0ZW1WYWx1ZSAqIDEgPT09IHZhbHVlICogMSkge1xuICAgICAgICAgIGNsaWNrZWRJdGVtID0gYWMuaXRlbXNbaV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChhYy5wYXJhbXMudXBkYXRlSW5wdXRWYWx1ZU9uU2VsZWN0KSB7XG4gICAgICAgIGFjLiRpbnB1dEVsLnZhbCh0eXBlb2YgY2xpY2tlZEl0ZW0gPT09ICdvYmplY3QnID8gY2xpY2tlZEl0ZW1bYWMucGFyYW1zLnZhbHVlUHJvcGVydHldIDogY2xpY2tlZEl0ZW0pO1xuICAgICAgICBhYy4kaW5wdXRFbC50cmlnZ2VyKCdpbnB1dCBjaGFuZ2UnKTtcbiAgICAgIH1cbiAgICAgIGFjLnZhbHVlID0gW2NsaWNrZWRJdGVtXTtcbiAgICAgIGFjLmVtaXQoJ2xvY2FsOjpjaGFuZ2UgYXV0b2NvbXBsZXRlQ2hhbmdlJywgW2NsaWNrZWRJdGVtXSk7XG5cbiAgICAgIGFjLmNsb3NlKCk7XG4gICAgfVxuXG4gICAgYWMuYXR0YWNoRXZlbnRzID0gZnVuY3Rpb24gYXR0YWNoRXZlbnRzKCkge1xuICAgICAgaWYgKGFjLnBhcmFtcy5vcGVuSW4gIT09ICdkcm9wZG93bicgJiYgYWMuJG9wZW5lckVsKSB7XG4gICAgICAgIGFjLiRvcGVuZXJFbC5vbignY2xpY2snLCBvbk9wZW5lckNsaWNrKTtcbiAgICAgIH1cbiAgICAgIGlmIChhYy5wYXJhbXMub3BlbkluID09PSAnZHJvcGRvd24nICYmIGFjLiRpbnB1dEVsKSB7XG4gICAgICAgIGFjLiRpbnB1dEVsLm9uKCdmb2N1cycsIG9uSW5wdXRGb2N1cyk7XG4gICAgICAgIGFjLiRpbnB1dEVsLm9uKGFjLnBhcmFtcy5pbnB1dEV2ZW50cywgb25JbnB1dENoYW5nZSk7XG4gICAgICAgIGlmIChhcHAuZGV2aWNlLmFuZHJvaWQpIHtcbiAgICAgICAgICAkKCdodG1sJykub24oJ2NsaWNrJywgb25IdG1sQ2xpY2spO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFjLiRpbnB1dEVsLm9uKCdibHVyJywgb25JbnB1dEJsdXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhYy5wYXJhbXMudHlwZWFoZWFkKSB7XG4gICAgICAgICAgYWMuJGlucHV0RWwub24oJ2tleWRvd24nLCBvbktleURvd24pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBhYy5kZXRhY2hFdmVudHMgPSBmdW5jdGlvbiBhdHRhY2hFdmVudHMoKSB7XG4gICAgICBpZiAoYWMucGFyYW1zLm9wZW5JbiAhPT0gJ2Ryb3Bkb3duJyAmJiBhYy4kb3BlbmVyRWwpIHtcbiAgICAgICAgYWMuJG9wZW5lckVsLm9mZignY2xpY2snLCBvbk9wZW5lckNsaWNrKTtcbiAgICAgIH1cbiAgICAgIGlmIChhYy5wYXJhbXMub3BlbkluID09PSAnZHJvcGRvd24nICYmIGFjLiRpbnB1dEVsKSB7XG4gICAgICAgIGFjLiRpbnB1dEVsLm9mZignZm9jdXMnLCBvbklucHV0Rm9jdXMpO1xuICAgICAgICBhYy4kaW5wdXRFbC5vZmYoYWMucGFyYW1zLmlucHV0RXZlbnRzLCBvbklucHV0Q2hhbmdlKTtcbiAgICAgICAgaWYgKGFwcC5kZXZpY2UuYW5kcm9pZCkge1xuICAgICAgICAgICQoJ2h0bWwnKS5vZmYoJ2NsaWNrJywgb25IdG1sQ2xpY2spO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFjLiRpbnB1dEVsLm9mZignYmx1cicsIG9uSW5wdXRCbHVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWMucGFyYW1zLnR5cGVhaGVhZCkge1xuICAgICAgICAgIGFjLiRpbnB1dEVsLm9mZigna2V5ZG93bicsIG9uS2V5RG93bik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGFjLmF0dGFjaERyb3Bkb3duRXZlbnRzID0gZnVuY3Rpb24gYXR0YWNoRHJvcGRvd25FdmVudHMoKSB7XG4gICAgICBhYy4kZHJvcGRvd25FbC5vbignY2xpY2snLCAnbGFiZWwnLCBvbkRyb3Bkb3duY2xpY2spO1xuICAgICAgYXBwLm9uKCdyZXNpemUnLCBvblJlc2l6ZSk7XG4gICAgfTtcbiAgICBhYy5kZXRhY2hEcm9wZG93bkV2ZW50cyA9IGZ1bmN0aW9uIGRldGFjaERyb3Bkb3duRXZlbnRzKCkge1xuICAgICAgYWMuJGRyb3Bkb3duRWwub2ZmKCdjbGljaycsICdsYWJlbCcsIG9uRHJvcGRvd25jbGljayk7XG4gICAgICBhcHAub2ZmKCdyZXNpemUnLCBvblJlc2l6ZSk7XG4gICAgfTtcblxuICAgIGFjLmF0dGFjaFBhZ2VFdmVudHMgPSBmdW5jdGlvbiBhdHRhY2hQYWdlRXZlbnRzKCkge1xuICAgICAgYWMuJGVsLm9uKCdjaGFuZ2UnLCAnaW5wdXRbdHlwZT1cInJhZGlvXCJdLCBpbnB1dFt0eXBlPVwiY2hlY2tib3hcIl0nLCBvblBhZ2VJbnB1dENoYW5nZSk7XG4gICAgICBpZiAoYWMucGFyYW1zLmNsb3NlT25TZWxlY3QgJiYgIWFjLnBhcmFtcy5tdWx0aXBsZSkge1xuICAgICAgICBhYy4kZWwub25jZSgnY2xpY2snLCAnLmxpc3QgbGFiZWwnLCAoKSA9PiB7XG4gICAgICAgICAgVXRpbHMubmV4dFRpY2soKCkgPT4ge1xuICAgICAgICAgICAgYWMuY2xvc2UoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBhYy5kZXRhY2hQYWdlRXZlbnRzID0gZnVuY3Rpb24gZGV0YWNoUGFnZUV2ZW50cygpIHtcbiAgICAgIGFjLiRlbC5vZmYoJ2NoYW5nZScsICdpbnB1dFt0eXBlPVwicmFkaW9cIl0sIGlucHV0W3R5cGU9XCJjaGVja2JveFwiXScsIG9uUGFnZUlucHV0Q2hhbmdlKTtcbiAgICB9O1xuXG4gICAgLy8gSW5zdGFsbCBNb2R1bGVzXG4gICAgYWMudXNlTW9kdWxlcygpO1xuXG4gICAgLy8gSW5pdFxuICAgIGFjLmluaXQoKTtcblxuICAgIHJldHVybiBhYztcbiAgfVxuICBwb3NpdGlvbkRyb3BEb3duKCkge1xuICAgIGNvbnN0IGFjID0gdGhpcztcbiAgICBjb25zdCB7ICRpbnB1dEVsLCBhcHAsICRkcm9wZG93bkVsIH0gPSBhYztcblxuICAgIGNvbnN0ICRwYWdlQ29udGVudEVsID0gJGlucHV0RWwucGFyZW50cygnLnBhZ2UtY29udGVudCcpO1xuICAgIGlmICgkcGFnZUNvbnRlbnRFbC5sZW5ndGggPT09IDApIHJldHVybjtcbiAgICBjb25zdCBpbnB1dE9mZnNldCA9ICRpbnB1dEVsLm9mZnNldCgpO1xuICAgIGNvbnN0IGlucHV0T2Zmc2V0V2lkdGggPSAkaW5wdXRFbFswXS5vZmZzZXRXaWR0aDtcbiAgICBjb25zdCBpbnB1dE9mZnNldEhlaWdodCA9ICRpbnB1dEVsWzBdLm9mZnNldEhlaWdodDtcbiAgICBjb25zdCAkbGlzdEVsID0gJGlucHV0RWwucGFyZW50cygnLmxpc3QnKTtcbiAgICBjb25zdCBsaXN0T2Zmc2V0ID0gJGxpc3RFbC5vZmZzZXQoKTtcbiAgICBjb25zdCBwYWRkaW5nQm90dG9tID0gcGFyc2VJbnQoJHBhZ2VDb250ZW50RWwuY3NzKCdwYWRkaW5nLWJvdHRvbScpLCAxMCk7XG4gICAgY29uc3QgbGlzdE9mZnNldExlZnQgPSAkbGlzdEVsLmxlbmd0aCA+IDAgPyBsaXN0T2Zmc2V0LmxlZnQgLSAkbGlzdEVsLnBhcmVudCgpLm9mZnNldCgpLmxlZnQgOiAwO1xuICAgIGNvbnN0IGlucHV0T2Zmc2V0TGVmdCA9IGlucHV0T2Zmc2V0LmxlZnQgLSAoJGxpc3RFbC5sZW5ndGggPiAwID8gbGlzdE9mZnNldC5sZWZ0IDogMCkgLSAoYXBwLnJ0bCA/IDAgOiAwKTtcbiAgICBjb25zdCBpbnB1dE9mZnNldFRvcCA9IGlucHV0T2Zmc2V0LnRvcCAtICgkcGFnZUNvbnRlbnRFbC5vZmZzZXQoKS50b3AgLSAkcGFnZUNvbnRlbnRFbFswXS5zY3JvbGxUb3ApO1xuXG4gICAgY29uc3QgbWF4SGVpZ2h0ID0gJHBhZ2VDb250ZW50RWxbMF0uc2Nyb2xsSGVpZ2h0IC0gcGFkZGluZ0JvdHRvbSAtIChpbnB1dE9mZnNldFRvcCArICRwYWdlQ29udGVudEVsWzBdLnNjcm9sbFRvcCkgLSAkaW5wdXRFbFswXS5vZmZzZXRIZWlnaHQ7XG5cbiAgICBjb25zdCBwYWRkaW5nUHJvcCA9IGFwcC5ydGwgPyAncGFkZGluZy1yaWdodCcgOiAncGFkZGluZy1sZWZ0JztcbiAgICBsZXQgcGFkZGluZ1ZhbHVlO1xuICAgIGlmICgkbGlzdEVsLmxlbmd0aCAmJiAhYWMucGFyYW1zLmV4cGFuZElucHV0KSB7XG4gICAgICBwYWRkaW5nVmFsdWUgPSAoYXBwLnJ0bCA/ICRsaXN0RWxbMF0ub2Zmc2V0V2lkdGggLSBpbnB1dE9mZnNldExlZnQgLSBpbnB1dE9mZnNldFdpZHRoIDogaW5wdXRPZmZzZXRMZWZ0KSAtIChhcHAudGhlbWUgPT09ICdtZCcgPyAxNiA6IDE1KTtcbiAgICB9XG5cblxuICAgICRkcm9wZG93bkVsLmNzcyh7XG4gICAgICBsZWZ0OiBgJHskbGlzdEVsLmxlbmd0aCA+IDAgPyBsaXN0T2Zmc2V0TGVmdCA6IGlucHV0T2Zmc2V0TGVmdH1weGAsXG4gICAgICB0b3A6IGAke2lucHV0T2Zmc2V0VG9wICsgJHBhZ2VDb250ZW50RWxbMF0uc2Nyb2xsVG9wICsgaW5wdXRPZmZzZXRIZWlnaHR9cHhgLFxuICAgICAgd2lkdGg6IGAkeyRsaXN0RWwubGVuZ3RoID4gMCA/ICRsaXN0RWxbMF0ub2Zmc2V0V2lkdGggOiBpbnB1dE9mZnNldFdpZHRofXB4YCxcbiAgICB9KTtcbiAgICAkZHJvcGRvd25FbC5jaGlsZHJlbignLmF1dG9jb21wbGV0ZS1kcm9wZG93bi1pbm5lcicpLmNzcyh7XG4gICAgICBtYXhIZWlnaHQ6IGAke21heEhlaWdodH1weGAsXG4gICAgICBbcGFkZGluZ1Byb3BdOiAkbGlzdEVsLmxlbmd0aCA+IDAgJiYgIWFjLnBhcmFtcy5leHBhbmRJbnB1dCA/IGAke3BhZGRpbmdWYWx1ZX1weGAgOiAnJyxcbiAgICB9KTtcbiAgfVxuICBmb2N1cygpIHtcbiAgICBjb25zdCBhYyA9IHRoaXM7XG4gICAgYWMuJGVsLmZpbmQoJ2lucHV0W3R5cGU9c2VhcmNoXScpLmZvY3VzKCk7XG4gIH1cbiAgc291cmNlKHF1ZXJ5KSB7XG4gICAgY29uc3QgYWMgPSB0aGlzO1xuICAgIGlmICghYWMucGFyYW1zLnNvdXJjZSkgcmV0dXJuO1xuXG4gICAgY29uc3QgeyAkZWwgfSA9IGFjO1xuXG4gICAgYWMucGFyYW1zLnNvdXJjZS5jYWxsKGFjLCBxdWVyeSwgKGl0ZW1zKSA9PiB7XG4gICAgICBsZXQgaXRlbXNIVE1MID0gJyc7XG4gICAgICBjb25zdCBsaW1pdCA9IGFjLnBhcmFtcy5saW1pdCA/IE1hdGgubWluKGFjLnBhcmFtcy5saW1pdCwgaXRlbXMubGVuZ3RoKSA6IGl0ZW1zLmxlbmd0aDtcbiAgICAgIGFjLml0ZW1zID0gaXRlbXM7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbWl0OyBpICs9IDEpIHtcbiAgICAgICAgbGV0IHNlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IGl0ZW1WYWx1ZSA9IHR5cGVvZiBpdGVtc1tpXSA9PT0gJ29iamVjdCcgPyBpdGVtc1tpXVthYy5wYXJhbXMudmFsdWVQcm9wZXJ0eV0gOiBpdGVtc1tpXTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBhYy52YWx1ZS5sZW5ndGg7IGogKz0gMSkge1xuICAgICAgICAgIGNvbnN0IGFWYWx1ZSA9IHR5cGVvZiBhYy52YWx1ZVtqXSA9PT0gJ29iamVjdCcgPyBhYy52YWx1ZVtqXVthYy5wYXJhbXMudmFsdWVQcm9wZXJ0eV0gOiBhYy52YWx1ZVtqXTtcbiAgICAgICAgICBpZiAoYVZhbHVlID09PSBpdGVtVmFsdWUgfHwgYVZhbHVlICogMSA9PT0gaXRlbVZhbHVlICogMSkgc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGl0ZW1zSFRNTCArPSBhYy5yZW5kZXJJdGVtKHtcbiAgICAgICAgICB2YWx1ZTogaXRlbVZhbHVlLFxuICAgICAgICAgIHRleHQ6IHR5cGVvZiBpdGVtc1tpXSA9PT0gJ29iamVjdCcgPyBpdGVtc1tpXVthYy5wYXJhbXMudGV4dFByb3BlcnR5XSA6IGl0ZW1zW2ldLFxuICAgICAgICAgIGlucHV0VHlwZTogYWMuaW5wdXRUeXBlLFxuICAgICAgICAgIGlkOiBhYy5pZCxcbiAgICAgICAgICBpbnB1dE5hbWU6IGFjLmlucHV0TmFtZSxcbiAgICAgICAgICBzZWxlY3RlZCxcbiAgICAgICAgfSwgaSk7XG4gICAgICB9XG4gICAgICAkZWwuZmluZCgnLmF1dG9jb21wbGV0ZS1mb3VuZCB1bCcpLmh0bWwoaXRlbXNIVE1MKTtcbiAgICAgIGlmIChpdGVtcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgaWYgKHF1ZXJ5Lmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICRlbC5maW5kKCcuYXV0b2NvbXBsZXRlLW5vdC1mb3VuZCcpLnNob3coKTtcbiAgICAgICAgICAkZWwuZmluZCgnLmF1dG9jb21wbGV0ZS1mb3VuZCwgLmF1dG9jb21wbGV0ZS12YWx1ZXMnKS5oaWRlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgJGVsLmZpbmQoJy5hdXRvY29tcGxldGUtdmFsdWVzJykuc2hvdygpO1xuICAgICAgICAgICRlbC5maW5kKCcuYXV0b2NvbXBsZXRlLWZvdW5kLCAuYXV0b2NvbXBsZXRlLW5vdC1mb3VuZCcpLmhpZGUoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJGVsLmZpbmQoJy5hdXRvY29tcGxldGUtZm91bmQnKS5zaG93KCk7XG4gICAgICAgICRlbC5maW5kKCcuYXV0b2NvbXBsZXRlLW5vdC1mb3VuZCwgLmF1dG9jb21wbGV0ZS12YWx1ZXMnKS5oaWRlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgdXBkYXRlVmFsdWVzKCkge1xuICAgIGNvbnN0IGFjID0gdGhpcztcbiAgICBsZXQgdmFsdWVzSFRNTCA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWMudmFsdWUubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIHZhbHVlc0hUTUwgKz0gYWMucmVuZGVySXRlbSh7XG4gICAgICAgIHZhbHVlOiB0eXBlb2YgYWMudmFsdWVbaV0gPT09ICdvYmplY3QnID8gYWMudmFsdWVbaV1bYWMucGFyYW1zLnZhbHVlUHJvcGVydHldIDogYWMudmFsdWVbaV0sXG4gICAgICAgIHRleHQ6IHR5cGVvZiBhYy52YWx1ZVtpXSA9PT0gJ29iamVjdCcgPyBhYy52YWx1ZVtpXVthYy5wYXJhbXMudGV4dFByb3BlcnR5XSA6IGFjLnZhbHVlW2ldLFxuICAgICAgICBpbnB1dFR5cGU6IGFjLmlucHV0VHlwZSxcbiAgICAgICAgaWQ6IGFjLmlkLFxuICAgICAgICBpbnB1dE5hbWU6IGAke2FjLmlucHV0TmFtZX0tY2hlY2tlZH1gLFxuICAgICAgICBzZWxlY3RlZDogdHJ1ZSxcbiAgICAgIH0sIGkpO1xuICAgIH1cbiAgICBhYy4kZWwuZmluZCgnLmF1dG9jb21wbGV0ZS12YWx1ZXMgdWwnKS5odG1sKHZhbHVlc0hUTUwpO1xuICB9XG4gIHByZWxvYWRlckhpZGUoKSB7XG4gICAgY29uc3QgYWMgPSB0aGlzO1xuICAgIGlmIChhYy5wYXJhbXMub3BlbkluID09PSAnZHJvcGRvd24nICYmIGFjLiRkcm9wZG93bkVsKSB7XG4gICAgICBhYy4kZHJvcGRvd25FbC5maW5kKCcuYXV0b2NvbXBsZXRlLXByZWxvYWRlcicpLnJlbW92ZUNsYXNzKCdhdXRvY29tcGxldGUtcHJlbG9hZGVyLXZpc2libGUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgJCgnLmF1dG9jb21wbGV0ZS1wcmVsb2FkZXInKS5yZW1vdmVDbGFzcygnYXV0b2NvbXBsZXRlLXByZWxvYWRlci12aXNpYmxlJyk7XG4gICAgfVxuICB9XG4gIHByZWxvYWRlclNob3coKSB7XG4gICAgY29uc3QgYWMgPSB0aGlzO1xuICAgIGlmIChhYy5wYXJhbXMub3BlbkluID09PSAnZHJvcGRvd24nICYmIGFjLiRkcm9wZG93bkVsKSB7XG4gICAgICBhYy4kZHJvcGRvd25FbC5maW5kKCcuYXV0b2NvbXBsZXRlLXByZWxvYWRlcicpLmFkZENsYXNzKCdhdXRvY29tcGxldGUtcHJlbG9hZGVyLXZpc2libGUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgJCgnLmF1dG9jb21wbGV0ZS1wcmVsb2FkZXInKS5hZGRDbGFzcygnYXV0b2NvbXBsZXRlLXByZWxvYWRlci12aXNpYmxlJyk7XG4gICAgfVxuICB9XG4gIHJlbmRlclByZWxvYWRlcigpIHtcbiAgICBjb25zdCBhYyA9IHRoaXM7XG4gICAgcmV0dXJuIGBcbiAgICAgIDxkaXYgY2xhc3M9XCJhdXRvY29tcGxldGUtcHJlbG9hZGVyIHByZWxvYWRlciAke2FjLnBhcmFtcy5wcmVsb2FkZXJDb2xvciA/IGBjb2xvci0ke2FjLnBhcmFtcy5wcmVsb2FkZXJDb2xvcn1gIDogJyd9XCI+JHthYy5hcHAudGhlbWUgPT09ICdtZCcgPyBVdGlscy5tZFByZWxvYWRlckNvbnRlbnQgOiAnJ308L2Rpdj5cbiAgICBgLnRyaW0oKTtcbiAgfVxuICByZW5kZXJTZWFyY2hiYXIoKSB7XG4gICAgY29uc3QgYWMgPSB0aGlzO1xuICAgIGlmIChhYy5wYXJhbXMucmVuZGVyU2VhcmNoYmFyKSByZXR1cm4gYWMucGFyYW1zLnJlbmRlclNlYXJjaGJhci5jYWxsKGFjKTtcbiAgICBjb25zdCBzZWFyY2hiYXJIVE1MID0gYFxuICAgICAgPGZvcm0gY2xhc3M9XCJzZWFyY2hiYXJcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cInNlYXJjaGJhci1pbm5lclwiPlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJzZWFyY2hiYXItaW5wdXQtd3JhcFwiPlxuICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJzZWFyY2hcIiBwbGFjZWhvbGRlcj1cIiR7YWMucGFyYW1zLnNlYXJjaGJhclBsYWNlaG9sZGVyfVwiLz5cbiAgICAgICAgICAgIDxpIGNsYXNzPVwic2VhcmNoYmFyLWljb25cIj48L2k+XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cImlucHV0LWNsZWFyLWJ1dHRvblwiPjwvc3Bhbj5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8c3BhbiBjbGFzcz1cInNlYXJjaGJhci1kaXNhYmxlLWJ1dHRvblwiPiR7YWMucGFyYW1zLnNlYXJjaGJhckRpc2FibGVUZXh0fTwvc3Bhbj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Zvcm0+XG4gICAgYC50cmltKCk7XG4gICAgcmV0dXJuIHNlYXJjaGJhckhUTUw7XG4gIH1cbiAgcmVuZGVySXRlbShpdGVtLCBpbmRleCkge1xuICAgIGNvbnN0IGFjID0gdGhpcztcbiAgICBpZiAoYWMucGFyYW1zLnJlbmRlckl0ZW0pIHJldHVybiBhYy5wYXJhbXMucmVuZGVySXRlbS5jYWxsKGFjLCBpdGVtLCBpbmRleCk7XG4gICAgbGV0IGl0ZW1IdG1sO1xuICAgIGlmIChhYy5wYXJhbXMub3BlbkluICE9PSAnZHJvcGRvd24nKSB7XG4gICAgICBpdGVtSHRtbCA9IGBcbiAgICAgICAgPGxpPlxuICAgICAgICAgIDxsYWJlbCBjbGFzcz1cIml0ZW0tJHtpdGVtLmlucHV0VHlwZX0gaXRlbS1jb250ZW50XCI+XG4gICAgICAgICAgICA8aW5wdXQgdHlwZT1cIiR7aXRlbS5pbnB1dFR5cGV9XCIgbmFtZT1cIiR7aXRlbS5pbnB1dE5hbWV9XCIgdmFsdWU9XCIke2l0ZW0udmFsdWV9XCIgJHtpdGVtLnNlbGVjdGVkID8gJ2NoZWNrZWQnIDogJyd9PlxuICAgICAgICAgICAgPGkgY2xhc3M9XCJpY29uIGljb24tJHtpdGVtLmlucHV0VHlwZX1cIj48L2k+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiaXRlbS1pbm5lclwiPlxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiaXRlbS10aXRsZVwiPiR7aXRlbS50ZXh0fTwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPC9sYWJlbD5cbiAgICAgICAgPC9saT5cbiAgICAgIGA7XG4gICAgfSBlbHNlIGlmICghaXRlbS5wbGFjZWhvbGRlcikge1xuICAgICAgLy8gRHJvcGRvd25cbiAgICAgIGl0ZW1IdG1sID0gYFxuICAgICAgICA8bGk+XG4gICAgICAgICAgPGxhYmVsIGNsYXNzPVwiaXRlbS1yYWRpbyBpdGVtLWNvbnRlbnRcIiBkYXRhLXZhbHVlPVwiJHtpdGVtLnZhbHVlfVwiPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cIml0ZW0taW5uZXJcIj5cbiAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIml0ZW0tdGl0bGVcIj4ke2l0ZW0udGV4dH08L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDwvbGFiZWw+XG4gICAgICAgIDwvbGk+XG4gICAgICBgO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBEcm9wd2Rvd24gcGxhY2Vob2xkZXJcbiAgICAgIGl0ZW1IdG1sID0gYFxuICAgICAgICA8bGkgY2xhc3M9XCJhdXRvY29tcGxldGUtZHJvcGRvd24tcGxhY2Vob2xkZXJcIj5cbiAgICAgICAgICA8ZGl2IGNsYXNzPVwiaXRlbS1jb250ZW50XCI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiaXRlbS1pbm5lclwiPlxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiaXRlbS10aXRsZVwiPiR7aXRlbS50ZXh0fTwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPC9sYWJlbD5cbiAgICAgICAgPC9saT5cbiAgICAgIGA7XG4gICAgfVxuICAgIHJldHVybiBpdGVtSHRtbC50cmltKCk7XG4gIH1cblxuICByZW5kZXJOYXZiYXIoKSB7XG4gICAgY29uc3QgYWMgPSB0aGlzO1xuICAgIGlmIChhYy5wYXJhbXMucmVuZGVyTmF2YmFyKSByZXR1cm4gYWMucGFyYW1zLnJlbmRlck5hdmJhci5jYWxsKGFjKTtcbiAgICBsZXQgcGFnZVRpdGxlID0gYWMucGFyYW1zLnBhZ2VUaXRsZTtcbiAgICBpZiAodHlwZW9mIHBhZ2VUaXRsZSA9PT0gJ3VuZGVmaW5lZCcgJiYgYWMuJG9wZW5lckVsICYmIGFjLiRvcGVuZXJFbC5sZW5ndGgpIHtcbiAgICAgIHBhZ2VUaXRsZSA9IGFjLiRvcGVuZXJFbC5maW5kKCcuaXRlbS10aXRsZScpLnRleHQoKS50cmltKCk7XG4gICAgfVxuICAgIGNvbnN0IG5hdmJhckh0bWwgPSBgXG4gICAgICA8ZGl2IGNsYXNzPVwibmF2YmFyICR7YWMucGFyYW1zLm5hdmJhckNvbG9yVGhlbWUgPyBgY29sb3ItdGhlbWUtJHthYy5wYXJhbXMubmF2YmFyQ29sb3JUaGVtZX1gIDogJyd9XCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJuYXZiYXItaW5uZXIgJHthYy5wYXJhbXMubmF2YmFyQ29sb3JUaGVtZSA/IGBjb2xvci10aGVtZS0ke2FjLnBhcmFtcy5uYXZiYXJDb2xvclRoZW1lfWAgOiAnJ31cIj5cbiAgICAgICAgICA8ZGl2IGNsYXNzPVwibGVmdCBzbGlkaW5nXCI+XG4gICAgICAgICAgICA8YSBocmVmPVwiI1wiIGNsYXNzPVwibGluayAke2FjLnBhcmFtcy5vcGVuSW4gPT09ICdwYWdlJyA/ICdiYWNrJyA6ICdwb3B1cC1jbG9zZSd9XCIgJHthYy5wYXJhbXMub3BlbkluID09PSAncG9wdXAnID8gJ2RhdGEtcG9wdXA9XCIuYXV0b2NvbXBsZXRlLXBvcHVwXCInIDogJyd9PlxuICAgICAgICAgICAgICA8aSBjbGFzcz1cImljb24gaWNvbi1iYWNrXCI+PC9pPlxuICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImlvcy1vbmx5XCI+JHthYy5wYXJhbXMub3BlbkluID09PSAncGFnZScgPyBhYy5wYXJhbXMucGFnZUJhY2tMaW5rVGV4dCA6IGFjLnBhcmFtcy5wb3B1cENsb3NlTGlua1RleHR9PC9zcGFuPlxuICAgICAgICAgICAgPC9hPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICR7cGFnZVRpdGxlID8gYDxkaXYgY2xhc3M9XCJ0aXRsZSBzbGlkaW5nXCI+JHtwYWdlVGl0bGV9PC9kaXY+YCA6ICcnfVxuICAgICAgICAgICR7YWMucGFyYW1zLnByZWxvYWRlciA/IGBcbiAgICAgICAgICA8ZGl2IGNsYXNzPVwicmlnaHRcIj5cbiAgICAgICAgICAgICR7YWMucmVuZGVyUHJlbG9hZGVyKCl9XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgYCA6ICcnfVxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJzdWJuYXZiYXIgc2xpZGluZ1wiPiR7YWMucmVuZGVyU2VhcmNoYmFyKCl9PC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgYC50cmltKCk7XG4gICAgcmV0dXJuIG5hdmJhckh0bWw7XG4gIH1cbiAgcmVuZGVyRHJvcGRvd24oKSB7XG4gICAgY29uc3QgYWMgPSB0aGlzO1xuICAgIGlmIChhYy5wYXJhbXMucmVuZGVyRHJvcGRvd24pIHJldHVybiBhYy5wYXJhbXMucmVuZGVyRHJvcGRvd24uY2FsbChhYywgYWMuaXRlbXMpO1xuICAgIGNvbnN0IGRyb3Bkb3duSHRtbCA9IGBcbiAgICAgIDxkaXYgY2xhc3M9XCJhdXRvY29tcGxldGUtZHJvcGRvd25cIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImF1dG9jb21wbGV0ZS1kcm9wZG93bi1pbm5lclwiPlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJsaXN0ICR7IWFjLnBhcmFtcy5leHBhbmRJbnB1dCA/ICduby1pb3MtZWRnZScgOiAnJ31cIj5cbiAgICAgICAgICAgIDx1bD48L3VsPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgJHthYy5wYXJhbXMucHJlbG9hZGVyID8gYWMucmVuZGVyUHJlbG9hZGVyKCkgOiAnJ31cbiAgICAgIDwvZGl2PlxuICAgIGAudHJpbSgpO1xuICAgIHJldHVybiBkcm9wZG93bkh0bWw7XG4gIH1cbiAgcmVuZGVyUGFnZSgpIHtcbiAgICBjb25zdCBhYyA9IHRoaXM7XG4gICAgaWYgKGFjLnBhcmFtcy5yZW5kZXJQYWdlKSByZXR1cm4gYWMucGFyYW1zLnJlbmRlclBhZ2UuY2FsbChhYywgYWMuaXRlbXMpO1xuXG4gICAgY29uc3QgcGFnZUh0bWwgPSBgXG4gICAgICA8ZGl2IGNsYXNzPVwicGFnZSBwYWdlLXdpdGgtc3VibmF2YmFyIGF1dG9jb21wbGV0ZS1wYWdlXCIgZGF0YS1uYW1lPVwiYXV0b2NvbXBsZXRlLXBhZ2VcIj5cbiAgICAgICAgJHthYy5yZW5kZXJOYXZiYXIoKX1cbiAgICAgICAgPGRpdiBjbGFzcz1cInNlYXJjaGJhci1iYWNrZHJvcFwiPjwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzPVwicGFnZS1jb250ZW50XCI+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cImxpc3QgYXV0b2NvbXBsZXRlLWxpc3QgYXV0b2NvbXBsZXRlLWZvdW5kIGF1dG9jb21wbGV0ZS1saXN0LSR7YWMuaWR9ICR7YWMucGFyYW1zLmZvcm1Db2xvclRoZW1lID8gYGNvbG9yLXRoZW1lLSR7YWMucGFyYW1zLmZvcm1Db2xvclRoZW1lfWAgOiAnJ31cIj5cbiAgICAgICAgICAgIDx1bD48L3VsPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJsaXN0IGF1dG9jb21wbGV0ZS1ub3QtZm91bmRcIj5cbiAgICAgICAgICAgIDx1bD5cbiAgICAgICAgICAgICAgPGxpIGNsYXNzPVwiaXRlbS1jb250ZW50XCI+PGRpdiBjbGFzcz1cIml0ZW0taW5uZXJcIj48ZGl2IGNsYXNzPVwiaXRlbS10aXRsZVwiPiR7YWMucGFyYW1zLm5vdEZvdW5kVGV4dH08L2Rpdj48L2Rpdj48L2xpPlxuICAgICAgICAgICAgPC91bD5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8ZGl2IGNsYXNzPVwibGlzdCBhdXRvY29tcGxldGUtdmFsdWVzXCI+XG4gICAgICAgICAgICA8dWw+PC91bD5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICBgLnRyaW0oKTtcbiAgICByZXR1cm4gcGFnZUh0bWw7XG4gIH1cbiAgcmVuZGVyUG9wdXAoKSB7XG4gICAgY29uc3QgYWMgPSB0aGlzO1xuICAgIGlmIChhYy5wYXJhbXMucmVuZGVyUG9wdXApIHJldHVybiBhYy5wYXJhbXMucmVuZGVyUG9wdXAuY2FsbChhYywgYWMuaXRlbXMpO1xuICAgIGNvbnN0IHBvcHVwSHRtbCA9IGBcbiAgICAgIDxkaXYgY2xhc3M9XCJwb3B1cCBhdXRvY29tcGxldGUtcG9wdXBcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cInZpZXdcIj5cbiAgICAgICAgICAke2FjLnJlbmRlclBhZ2UoKX07XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgYC50cmltKCk7XG4gICAgcmV0dXJuIHBvcHVwSHRtbDtcbiAgfVxuICBvbk9wZW4odHlwZSwgZWwpIHtcbiAgICBjb25zdCBhYyA9IHRoaXM7XG4gICAgY29uc3QgYXBwID0gYWMuYXBwO1xuICAgIGNvbnN0ICRlbCA9ICQoZWwpO1xuICAgIGFjLiRlbCA9ICRlbDtcbiAgICBhYy5lbCA9ICRlbFswXTtcbiAgICBhYy5vcGVuZWRJbiA9IHR5cGU7XG4gICAgYWMub3BlbmVkID0gdHJ1ZTtcblxuICAgIGlmIChhYy5wYXJhbXMub3BlbkluID09PSAnZHJvcGRvd24nKSB7XG4gICAgICBhYy5hdHRhY2hEcm9wZG93bkV2ZW50cygpO1xuXG4gICAgICBhYy4kZHJvcGRvd25FbC5hZGRDbGFzcygnYXV0b2NvbXBsZXRlLWRyb3Bkb3duLWluJyk7XG4gICAgICBhYy4kaW5wdXRFbC50cmlnZ2VyKCdpbnB1dCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJbml0IFNCXG4gICAgICBsZXQgJHNlYXJjaGJhckVsID0gJGVsLmZpbmQoJy5zZWFyY2hiYXInKTtcbiAgICAgIGlmIChhYy5wYXJhbXMub3BlbkluID09PSAncGFnZScgJiYgYXBwLnRoZW1lID09PSAnaW9zJyAmJiAkc2VhcmNoYmFyRWwubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICRzZWFyY2hiYXJFbCA9ICQoYXBwLm5hdmJhci5nZXRFbEJ5UGFnZSgkZWwpKS5maW5kKCcuc2VhcmNoYmFyJyk7XG4gICAgICB9XG4gICAgICBhYy5zZWFyY2hiYXIgPSBhcHAuc2VhcmNoYmFyLmNyZWF0ZSh7XG4gICAgICAgIGVsOiAkc2VhcmNoYmFyRWwsXG4gICAgICAgIGJhY2tkcm9wRWw6ICRlbC5maW5kKCcuc2VhcmNoYmFyLWJhY2tkcm9wJyksXG4gICAgICAgIGN1c3RvbVNlYXJjaDogdHJ1ZSxcbiAgICAgICAgb246IHtcbiAgICAgICAgICBzZWFyY2hiYXJTZWFyY2goc2IsIHF1ZXJ5KSB7XG4gICAgICAgICAgICBpZiAocXVlcnkubGVuZ3RoID09PSAwICYmIGFjLnNlYXJjaGJhci5lbmFibGVkKSB7XG4gICAgICAgICAgICAgIGFjLnNlYXJjaGJhci5iYWNrZHJvcFNob3coKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGFjLnNlYXJjaGJhci5iYWNrZHJvcEhpZGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFjLnNvdXJjZShxdWVyeSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuXG4gICAgICAvLyBBdHRhY2ggcGFnZSBldmVudHNcbiAgICAgIGFjLmF0dGFjaFBhZ2VFdmVudHMoKTtcblxuICAgICAgLy8gVXBkYXRlIFZhbHVlcyBPbiBQYWdlIEluaXRcbiAgICAgIGFjLnVwZGF0ZVZhbHVlcygpO1xuXG4gICAgICAvLyBTb3VyY2Ugb24gbG9hZFxuICAgICAgaWYgKGFjLnBhcmFtcy5yZXF1ZXN0U291cmNlT25PcGVuKSBhYy5zb3VyY2UoJycpO1xuICAgIH1cblxuICAgIGFjLmVtaXQoJ2xvY2FsOjpvcGVuIGF1dG9jb21wbGV0ZU9wZW4nLCBhYyk7XG4gIH1cbiAgb25PcGVuZWQoKSB7XG4gICAgY29uc3QgYWMgPSB0aGlzO1xuICAgIGlmIChhYy5wYXJhbXMub3BlbkluICE9PSAnZHJvcGRvd24nICYmIGFjLnBhcmFtcy5hdXRvRm9jdXMpIHtcbiAgICAgIGFjLmF1dG9Gb2N1cygpO1xuICAgIH1cbiAgICBhYy5lbWl0KCdsb2NhbDo6b3BlbmVkIGF1dG9jb21wbGV0ZU9wZW5lZCcsIGFjKTtcbiAgfVxuICBvbkNsb3NlKCkge1xuICAgIGNvbnN0IGFjID0gdGhpcztcbiAgICBpZiAoYWMuZGVzdHJveWVkKSByZXR1cm47XG5cbiAgICAvLyBEZXN0cm95IFNCXG4gICAgaWYgKGFjLnNlYXJjaGJhciAmJiBhYy5zZWFyY2hiYXIuZGVzdHJveSkge1xuICAgICAgYWMuc2VhcmNoYmFyLmRlc3Ryb3koKTtcbiAgICAgIGFjLnNlYXJjaGJhciA9IG51bGw7XG4gICAgICBkZWxldGUgYWMuc2VhcmNoYmFyO1xuICAgIH1cblxuICAgIGlmIChhYy5wYXJhbXMub3BlbkluID09PSAnZHJvcGRvd24nKSB7XG4gICAgICBhYy5kZXRhY2hEcm9wZG93bkV2ZW50cygpO1xuICAgICAgYWMuJGRyb3Bkb3duRWwucmVtb3ZlQ2xhc3MoJ2F1dG9jb21wbGV0ZS1kcm9wZG93bi1pbicpLnJlbW92ZSgpO1xuICAgICAgYWMuJGlucHV0RWwucGFyZW50cygnLml0ZW0tY29udGVudC1kcm9wZG93bi1leHBhbmRlZCcpLnJlbW92ZUNsYXNzKCdpdGVtLWNvbnRlbnQtZHJvcGRvd24tZXhwYW5kZWQnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWMuZGV0YWNoUGFnZUV2ZW50cygpO1xuICAgIH1cblxuICAgIGFjLmVtaXQoJ2xvY2FsOjpjbG9zZSBhdXRvY29tcGxldGVDbG9zZScsIGFjKTtcbiAgfVxuICBvbkNsb3NlZCgpIHtcbiAgICBjb25zdCBhYyA9IHRoaXM7XG4gICAgaWYgKGFjLmRlc3Ryb3llZCkgcmV0dXJuO1xuICAgIGFjLm9wZW5lZCA9IGZhbHNlO1xuICAgIGFjLiRlbCA9IG51bGw7XG4gICAgYWMuZWwgPSBudWxsO1xuICAgIGRlbGV0ZSBhYy4kZWw7XG4gICAgZGVsZXRlIGFjLmVsO1xuXG4gICAgYWMuZW1pdCgnbG9jYWw6OmNsb3NlZCBhdXRvY29tcGxldGVDbG9zZWQnLCBhYyk7XG4gIH1cbiAgb3BlblBhZ2UoKSB7XG4gICAgY29uc3QgYWMgPSB0aGlzO1xuICAgIGlmIChhYy5vcGVuZWQpIHJldHVybiBhYztcbiAgICBjb25zdCBwYWdlSHRtbCA9IGFjLnJlbmRlclBhZ2UoKTtcbiAgICBhYy52aWV3LnJvdXRlci5uYXZpZ2F0ZSh7XG4gICAgICB1cmw6IGFjLnVybCxcbiAgICAgIHJvdXRlOiB7XG4gICAgICAgIGNvbnRlbnQ6IHBhZ2VIdG1sLFxuICAgICAgICBwYXRoOiBhYy51cmwsXG4gICAgICAgIG9uOiB7XG4gICAgICAgICAgcGFnZUJlZm9yZUluKGUsIHBhZ2UpIHtcbiAgICAgICAgICAgIGFjLm9uT3BlbigncGFnZScsIHBhZ2UuZWwpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgcGFnZUFmdGVySW4oZSwgcGFnZSkge1xuICAgICAgICAgICAgYWMub25PcGVuZWQoJ3BhZ2UnLCBwYWdlLmVsKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHBhZ2VCZWZvcmVPdXQoZSwgcGFnZSkge1xuICAgICAgICAgICAgYWMub25DbG9zZSgncGFnZScsIHBhZ2UuZWwpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgcGFnZUFmdGVyT3V0KGUsIHBhZ2UpIHtcbiAgICAgICAgICAgIGFjLm9uQ2xvc2VkKCdwYWdlJywgcGFnZS5lbCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgIGFuaW1hdGU6IGFjLnBhcmFtcy5hbmltYXRlLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9KTtcbiAgICByZXR1cm4gYWM7XG4gIH1cbiAgb3BlblBvcHVwKCkge1xuICAgIGNvbnN0IGFjID0gdGhpcztcbiAgICBpZiAoYWMub3BlbmVkKSByZXR1cm4gYWM7XG4gICAgY29uc3QgcG9wdXBIdG1sID0gYWMucmVuZGVyUG9wdXAoKTtcblxuICAgIGNvbnN0IHBvcHVwUGFyYW1zID0ge1xuICAgICAgY29udGVudDogcG9wdXBIdG1sLFxuICAgICAgYW5pbWF0ZTogYWMucGFyYW1zLmFuaW1hdGUsXG4gICAgICBvbjoge1xuICAgICAgICBwb3B1cE9wZW4ocG9wdXApIHtcbiAgICAgICAgICBhYy5vbk9wZW4oJ3BvcHVwJywgcG9wdXAuZWwpO1xuICAgICAgICB9LFxuICAgICAgICBwb3B1cE9wZW5lZChwb3B1cCkge1xuICAgICAgICAgIGFjLm9uT3BlbmVkKCdwb3B1cCcsIHBvcHVwLmVsKTtcbiAgICAgICAgfSxcbiAgICAgICAgcG9wdXBDbG9zZShwb3B1cCkge1xuICAgICAgICAgIGFjLm9uQ2xvc2UoJ3BvcHVwJywgcG9wdXAuZWwpO1xuICAgICAgICB9LFxuICAgICAgICBwb3B1cENsb3NlZChwb3B1cCkge1xuICAgICAgICAgIGFjLm9uQ2xvc2VkKCdwb3B1cCcsIHBvcHVwLmVsKTtcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgfTtcblxuICAgIGlmIChhYy5wYXJhbXMucm91dGFibGVNb2RhbHMpIHtcbiAgICAgIGFjLnZpZXcucm91dGVyLm5hdmlnYXRlKHtcbiAgICAgICAgdXJsOiBhYy51cmwsXG4gICAgICAgIHJvdXRlOiB7XG4gICAgICAgICAgcGF0aDogYWMudXJsLFxuICAgICAgICAgIHBvcHVwOiBwb3B1cFBhcmFtcyxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBhYy5tb2RhbCA9IGFjLmFwcC5wb3B1cC5jcmVhdGUocG9wdXBQYXJhbXMpLm9wZW4oYWMucGFyYW1zLmFuaW1hdGUpO1xuICAgIH1cbiAgICByZXR1cm4gYWM7XG4gIH1cbiAgb3BlbkRyb3Bkb3duKCkge1xuICAgIGNvbnN0IGFjID0gdGhpcztcblxuICAgIGlmICghYWMuJGRyb3Bkb3duRWwpIHtcbiAgICAgIGFjLiRkcm9wZG93bkVsID0gJChhYy5yZW5kZXJEcm9wZG93bigpKTtcbiAgICB9XG4gICAgY29uc3QgJGxpc3RFbCA9IGFjLiRpbnB1dEVsLnBhcmVudHMoJy5saXN0Jyk7XG4gICAgaWYgKCRsaXN0RWwubGVuZ3RoICYmIGFjLiRpbnB1dEVsLnBhcmVudHMoJy5pdGVtLWNvbnRlbnQnKS5sZW5ndGggPiAwICYmIGFjLnBhcmFtcy5leHBhbmRJbnB1dCkge1xuICAgICAgYWMuJGlucHV0RWwucGFyZW50cygnLml0ZW0tY29udGVudCcpLmFkZENsYXNzKCdpdGVtLWNvbnRlbnQtZHJvcGRvd24tZXhwYW5kZWQnKTtcbiAgICB9XG4gICAgYWMucG9zaXRpb25Ecm9wRG93bigpO1xuICAgIGNvbnN0ICRwYWdlQ29udGVudEVsID0gYWMuJGlucHV0RWwucGFyZW50cygnLnBhZ2UtY29udGVudCcpO1xuICAgIGlmIChhYy5wYXJhbXMuZHJvcGRvd25lbCkge1xuICAgICAgJChhYy5wYXJhbXMuZHJvcGRvd25lbCkuYXBwZW5kKGFjLiRkcm9wZG93bkVsKTtcbiAgICB9IGVsc2UgaWYgKCRwYWdlQ29udGVudEVsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgYWMuJGRyb3Bkb3duRWwuaW5zZXJ0QWZ0ZXIoYWMuJGlucHV0RWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICAkcGFnZUNvbnRlbnRFbC5hcHBlbmQoYWMuJGRyb3Bkb3duRWwpO1xuICAgIH1cbiAgICBhYy5vbk9wZW4oJ2Ryb3Bkb3duJywgYWMuJGRyb3Bkb3duRWwpO1xuICAgIGFjLm9uT3BlbmVkKCdkcm9wZG93bicsIGFjLiRkcm9wZG93bkVsKTtcbiAgfVxuICBvcGVuKCkge1xuICAgIGNvbnN0IGFjID0gdGhpcztcbiAgICBpZiAoYWMub3BlbmVkKSByZXR1cm4gYWM7XG4gICAgY29uc3Qgb3BlbkluID0gYWMucGFyYW1zLm9wZW5JbjtcbiAgICBhY1tgb3BlbiR7b3BlbkluLnNwbGl0KCcnKS5tYXAoKGVsLCBpbmRleCkgPT4ge1xuICAgICAgaWYgKGluZGV4ID09PSAwKSByZXR1cm4gZWwudG9VcHBlckNhc2UoKTtcbiAgICAgIHJldHVybiBlbDtcbiAgICB9KS5qb2luKCcnKX1gXSgpO1xuICAgIHJldHVybiBhYztcbiAgfVxuICBjbG9zZSgpIHtcbiAgICBjb25zdCBhYyA9IHRoaXM7XG4gICAgaWYgKCFhYy5vcGVuZWQpIHJldHVybiBhYztcbiAgICBpZiAoYWMucGFyYW1zLm9wZW5JbiA9PT0gJ2Ryb3Bkb3duJykge1xuICAgICAgYWMub25DbG9zZSgpO1xuICAgICAgYWMub25DbG9zZWQoKTtcbiAgICB9IGVsc2UgaWYgKGFjLnBhcmFtcy5yb3V0YWJsZU1vZGFscyB8fCBhYy5vcGVuZWRJbiA9PT0gJ3BhZ2UnKSB7XG4gICAgICBhYy52aWV3LnJvdXRlci5iYWNrKHsgYW5pbWF0ZTogYWMucGFyYW1zLmFuaW1hdGUgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFjLm1vZGFsLm9uY2UoJ21vZGFsQ2xvc2VkJywgKCkgPT4ge1xuICAgICAgICBVdGlscy5uZXh0VGljaygoKSA9PiB7XG4gICAgICAgICAgYWMubW9kYWwuZGVzdHJveSgpO1xuICAgICAgICAgIGRlbGV0ZSBhYy5tb2RhbDtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIGFjLm1vZGFsLmNsb3NlKCk7XG4gICAgfVxuICAgIHJldHVybiBhYztcbiAgfVxuICBpbml0KCkge1xuICAgIGNvbnN0IGFjID0gdGhpcztcbiAgICBhYy5hdHRhY2hFdmVudHMoKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIGNvbnN0IGFjID0gdGhpcztcbiAgICBhYy5lbWl0KCdsb2NhbDo6YmVmb3JlRGVzdHJveSBhdXRvY29tcGxldGVCZWZvcmVEZXN0cm95JywgYWMpO1xuICAgIGFjLmRldGFjaEV2ZW50cygpO1xuICAgIGlmIChhYy4kaW5wdXRFbCAmJiBhYy4kaW5wdXRFbFswXSkge1xuICAgICAgZGVsZXRlIGFjLiRpbnB1dEVsWzBdLmY3QXV0b2NvbXBsZXRlO1xuICAgIH1cbiAgICBpZiAoYWMuJG9wZW5lckVsICYmIGFjLiRvcGVuZXJFbFswXSkge1xuICAgICAgZGVsZXRlIGFjLiRvcGVuZXJFbFswXS5mN0F1dG9jb21wbGV0ZTtcbiAgICB9XG4gICAgVXRpbHMuZGVsZXRlUHJvcHMoYWMpO1xuICAgIGFjLmRlc3Ryb3llZCA9IHRydWU7XG4gIH1cbn1cblxudmFyIEF1dG9jb21wbGV0ZSQxID0ge1xuICBuYW1lOiAnYXV0b2NvbXBsZXRlJyxcbiAgcGFyYW1zOiB7XG4gICAgYXV0b2NvbXBsZXRlOiB7XG4gICAgICBvcGVuZXJFbDogdW5kZWZpbmVkLFxuICAgICAgaW5wdXRFbDogdW5kZWZpbmVkLFxuICAgICAgdmlldzogdW5kZWZpbmVkLFxuXG4gICAgICAvLyBEcm9wRG93blxuICAgICAgZHJvcGRvd25Db250YWluZXJFbDogdW5kZWZpbmVkLFxuICAgICAgZHJvcGRvd25QbGFjZWhvbGRlclRleHQ6IHVuZGVmaW5lZCxcbiAgICAgIHR5cGVhaGVhZDogZmFsc2UsXG4gICAgICBoaWdobGlnaHRNYXRjaGVzOiB0cnVlLFxuICAgICAgZXhwYW5kSW5wdXQ6IGZhbHNlLFxuICAgICAgdXBkYXRlSW5wdXRWYWx1ZU9uU2VsZWN0OiB0cnVlLFxuICAgICAgaW5wdXRFdmVudHM6ICdpbnB1dCcsXG5cbiAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICBtdWx0aXBsZTogZmFsc2UsXG5cbiAgICAgIHNvdXJjZTogdW5kZWZpbmVkLFxuICAgICAgbGltaXQ6IHVuZGVmaW5lZCxcbiAgICAgIHZhbHVlUHJvcGVydHk6ICdpZCcsXG4gICAgICB0ZXh0UHJvcGVydHk6ICd0ZXh0JyxcblxuICAgICAgb3BlbkluOiAncGFnZScsIC8vIG9yICdwb3B1cCcgb3IgJ2Ryb3Bkb3duJ1xuICAgICAgcGFnZUJhY2tMaW5rVGV4dDogJ0JhY2snLFxuICAgICAgcG9wdXBDbG9zZUxpbmtUZXh0OiAnQ2xvc2UnLFxuICAgICAgcGFnZVRpdGxlOiB1bmRlZmluZWQsXG4gICAgICBzZWFyY2hiYXJQbGFjZWhvbGRlcjogJ1NlYXJjaC4uLicsXG4gICAgICBzZWFyY2hiYXJEaXNhYmxlVGV4dDogJ0NhbmNlbCcsXG5cbiAgICAgIGFuaW1hdGU6IHRydWUsXG5cbiAgICAgIGF1dG9Gb2N1czogZmFsc2UsXG4gICAgICBjbG9zZU9uU2VsZWN0OiBmYWxzZSxcbiAgICAgIG5vdEZvdW5kVGV4dDogJ05vdGhpbmcgZm91bmQnLFxuICAgICAgcmVxdWVzdFNvdXJjZU9uT3BlbjogZmFsc2UsXG5cbiAgICAgIC8vIFByZWxvYWRlclxuICAgICAgcHJlbG9hZGVyQ29sb3I6IHVuZGVmaW5lZCxcbiAgICAgIHByZWxvYWRlcjogZmFsc2UsXG5cbiAgICAgIC8vIENvbG9yc1xuICAgICAgZm9ybUNvbG9yVGhlbWU6IHVuZGVmaW5lZCxcbiAgICAgIG5hdmJhckNvbG9yVGhlbWU6IHVuZGVmaW5lZCxcblxuICAgICAgLy8gUm91dGluZ1xuICAgICAgcm91dGFibGVNb2RhbHM6IHRydWUsXG4gICAgICB1cmw6ICdzZWxlY3QvJyxcblxuICAgICAgLy8gQ3VzdG9tIHJlbmRlciBmdW5jdGlvbnNcbiAgICAgIHJlbmRlckRyb3Bkb3duOiB1bmRlZmluZWQsXG4gICAgICByZW5kZXJQYWdlOiB1bmRlZmluZWQsXG4gICAgICByZW5kZXJQb3B1cDogdW5kZWZpbmVkLFxuICAgICAgcmVuZGVySXRlbTogdW5kZWZpbmVkLFxuICAgICAgcmVuZGVyU2VhcmNoYmFyOiB1bmRlZmluZWQsXG4gICAgICByZW5kZXJOYXZiYXI6IHVuZGVmaW5lZCxcblxuICAgIH0sXG4gIH0sXG4gIHN0YXRpYzoge1xuICAgIEF1dG9jb21wbGV0ZSxcbiAgfSxcbiAgY3JlYXRlKCkge1xuICAgIGNvbnN0IGFwcCA9IHRoaXM7XG4gICAgYXBwLmF1dG9jb21wbGV0ZSA9IFV0aWxzLmV4dGVuZChcbiAgICAgIENvbnN0cnVjdG9yTWV0aG9kcyh7XG4gICAgICAgIGRlZmF1bHRTZWxlY3RvcjogdW5kZWZpbmVkLFxuICAgICAgICBjb25zdHJ1Y3RvcjogQXV0b2NvbXBsZXRlLFxuICAgICAgICBhcHAsXG4gICAgICAgIGRvbVByb3A6ICdmN0F1dG9jb21wbGV0ZScsXG4gICAgICB9KSxcbiAgICAgIHtcbiAgICAgICAgb3BlbihhdXRvY29tcGxldGVFbCkge1xuICAgICAgICAgIGNvbnN0IGFjID0gYXBwLmF1dG9jb21wbGV0ZS5nZXQoYXV0b2NvbXBsZXRlRWwpO1xuICAgICAgICAgIGlmIChhYyAmJiBhYy5vcGVuKSByZXR1cm4gYWMub3BlbigpO1xuICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH0sXG4gICAgICAgIGNsb3NlKGF1dG9jb21wbGV0ZUVsKSB7XG4gICAgICAgICAgY29uc3QgYWMgPSBhcHAuYXV0b2NvbXBsZXRlLmdldChhdXRvY29tcGxldGVFbCk7XG4gICAgICAgICAgaWYgKGFjICYmIGFjLmNsb3NlKSByZXR1cm4gYWMuY2xvc2UoKTtcbiAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9LFxuICAgICAgfVxuICAgICk7XG4gIH0sXG59O1xuXG5jbGFzcyBWaUFkIGV4dGVuZHMgRnJhbWV3b3JrN0NsYXNzIHtcbiAgY29uc3RydWN0b3IoYXBwLCBwYXJhbXMgPSB7fSkge1xuICAgIHN1cGVyKHBhcmFtcywgW2FwcF0pO1xuICAgIGNvbnN0IHZpID0gdGhpcztcbiAgICBpZiAoIXdpbmRvdyQxLnZpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Y3OnZpIFNESyBub3QgZm91bmQuJyk7XG4gICAgfVxuXG4gICAgbGV0IG9yaWVudGF0aW9uO1xuICAgIGlmICh0eXBlb2Ygd2luZG93JDEub3JpZW50YXRpb24gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBvcmllbnRhdGlvbiA9IHdpbmRvdyQxLm9yaWVudGF0aW9uID09PSAtOTAgfHwgd2luZG93JDEub3JpZW50YXRpb24gPT09IDkwID8gJ2hvcml6b250YWwnIDogJ3ZlcnRpY2FsJztcbiAgICB9XG4gICAgY29uc3QgZGVmYXVsdHMgPSBVdGlscy5leHRlbmQoXG4gICAgICB7fSxcbiAgICAgIGFwcC5wYXJhbXMudmksXG4gICAgICB7XG4gICAgICAgIGFwcElkOiBhcHAuaWQsXG4gICAgICAgIGFwcFZlcjogYXBwLnZlcnNpb24sXG4gICAgICAgIGxhbmd1YWdlOiBhcHAubGFuZ3VhZ2UsXG4gICAgICAgIHdpZHRoOiBhcHAud2lkdGgsXG4gICAgICAgIGhlaWdodDogYXBwLmhlaWdodCxcbiAgICAgICAgb3M6IERldmljZS5vcyxcbiAgICAgICAgb3NWZXJzaW9uOiBEZXZpY2Uub3NWZXJzaW9uLFxuICAgICAgICBvcmllbnRhdGlvbixcbiAgICAgIH1cbiAgICApO1xuXG4gICAgLy8gRXh0ZW5kIGRlZmF1bHRzIHdpdGggbW9kdWxlcyBwYXJhbXNcbiAgICB2aS51c2VNb2R1bGVzUGFyYW1zKGRlZmF1bHRzKTtcblxuICAgIHZpLnBhcmFtcyA9IFV0aWxzLmV4dGVuZChkZWZhdWx0cywgcGFyYW1zKTtcblxuICAgIGNvbnN0IGFkUGFyYW1zID0ge307XG4gICAgY29uc3Qgc2tpcFBhcmFtcyA9ICgnb24gYXV0b3BsYXkgZmFsbGJhY2tPdmVybGF5IGZhbGxiYWNrT3ZlcmxheVRleHQgZW5hYmxlZCcpLnNwbGl0KCcgJyk7XG4gICAgT2JqZWN0LmtleXModmkucGFyYW1zKS5mb3JFYWNoKChwYXJhbU5hbWUpID0+IHtcbiAgICAgIGlmIChza2lwUGFyYW1zLmluZGV4T2YocGFyYW1OYW1lKSA+PSAwKSByZXR1cm47XG4gICAgICBjb25zdCBwYXJhbVZhbHVlID0gdmkucGFyYW1zW3BhcmFtTmFtZV07XG4gICAgICBpZiAoW251bGwsIHVuZGVmaW5lZF0uaW5kZXhPZihwYXJhbVZhbHVlKSA+PSAwKSByZXR1cm47XG4gICAgICBhZFBhcmFtc1twYXJhbU5hbWVdID0gcGFyYW1WYWx1ZTtcbiAgICB9KTtcblxuICAgIGlmICghdmkucGFyYW1zLmFwcElkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZyYW1ld29yazc6XCJhcHAuaWRcIiBpcyByZXF1aXJlZCB0byBkaXNwbGF5IGFuIGFkLiBNYWtlIHN1cmUgeW91IGhhdmUgc3BlY2lmaWVkIGl0IG9uIGFwcCBpbml0aWFsaXphdGlvbi4nKTtcbiAgICB9XG4gICAgaWYgKCF2aS5wYXJhbXMucGxhY2VtZW50SWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRnJhbWV3b3JrNzpcInBsYWNlbWVudElkXCIgaXMgcmVxdWlyZWQgdG8gZGlzcGxheSBhbiBhZC4nKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvblJlc2l6ZSgpIHtcbiAgICAgIGNvbnN0ICR2aUZyYW1lID0gJCgnaWZyYW1lI3ZpQWQnKTtcbiAgICAgIGlmICgkdmlGcmFtZS5sZW5ndGggPT09IDApIHJldHVybjtcbiAgICAgICR2aUZyYW1lXG4gICAgICAgIC5jc3Moe1xuICAgICAgICAgIHdpZHRoOiBgJHthcHAud2lkdGh9cHhgLFxuICAgICAgICAgIGhlaWdodDogYCR7YXBwLmhlaWdodH1weGAsXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbW92ZU92ZXJsYXkoKSB7XG4gICAgICBpZiAoIXZpLiRvdmVybGF5RWwpIHJldHVybjtcbiAgICAgIHZpLiRvdmVybGF5RWwub2ZmKCdjbGljayB0b3VjaHN0YXJ0Jyk7XG4gICAgICB2aS4kb3ZlcmxheUVsLnJlbW92ZSgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVPdmVybGF5KHZpZGVvRWwpIHtcbiAgICAgIGlmICghdmlkZW9FbCkgcmV0dXJuO1xuICAgICAgdmkuJG92ZXJsYXlFbCA9ICQoYFxuICAgICAgICA8ZGl2IGNsYXNzPVwidmktb3ZlcmxheSBuby1mYXN0Y2xpY2tcIj5cbiAgICAgICAgICAke3ZpLnBhcmFtcy5mYWxsYmFja092ZXJsYXlUZXh0ID8gYDxkaXYgY2xhc3M9XCJ2aS1vdmVybGF5LXRleHRcIj4ke3ZpLnBhcmFtcy5mYWxsYmFja092ZXJsYXlUZXh0fTwvZGl2PmAgOiAnJ31cbiAgICAgICAgICA8ZGl2IGNsYXNzPVwidmktb3ZlcmxheS1wbGF5LWJ1dHRvblwiPjwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgIGAudHJpbSgpKTtcblxuICAgICAgbGV0IHRvdWNoU3RhcnRUaW1lO1xuICAgICAgdmkuJG92ZXJsYXlFbC5vbigndG91Y2hzdGFydCcsICgpID0+IHtcbiAgICAgICAgdG91Y2hTdGFydFRpbWUgPSBVdGlscy5ub3coKTtcbiAgICAgIH0pO1xuICAgICAgdmkuJG92ZXJsYXlFbC5vbignY2xpY2snLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHRpbWVEaWZmID0gVXRpbHMubm93KCkgLSB0b3VjaFN0YXJ0VGltZTtcbiAgICAgICAgaWYgKHRpbWVEaWZmID4gMzAwKSByZXR1cm47XG4gICAgICAgIGlmICh2aWRlb0VsKSB7XG4gICAgICAgICAgdmlkZW9FbC5wbGF5KCk7XG4gICAgICAgICAgcmVtb3ZlT3ZlcmxheSgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2aS5zdGFydCgpO1xuICAgICAgICByZW1vdmVPdmVybGF5KCk7XG4gICAgICB9KTtcbiAgICAgIGFwcC5yb290LmFwcGVuZCh2aS4kb3ZlcmxheUVsKTtcbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgYWRcbiAgICB2aS5hZCA9IG5ldyB3aW5kb3ckMS52aS5BZChhZFBhcmFtcyk7XG5cbiAgICBVdGlscy5leHRlbmQodmkuYWQsIHtcbiAgICAgIG9uQWRSZWFkeSgpIHtcbiAgICAgICAgYXBwLm9uKCdyZXNpemUnLCBvblJlc2l6ZSk7XG4gICAgICAgIHZpLmVtaXQoJ2xvY2FsOjpyZWFkeScpO1xuICAgICAgICBpZiAodmkucGFyYW1zLmF1dG9wbGF5KSB7XG4gICAgICAgICAgdmkuc3RhcnQoKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG9uQWRTdGFydGVkKCkge1xuICAgICAgICB2aS5lbWl0KCdsb2NhbDo6c3RhcnRlZCcpO1xuICAgICAgfSxcbiAgICAgIG9uQWRDbGljayh0YXJnZXRVcmwpIHtcbiAgICAgICAgdmkuZW1pdCgnbG9jYWw6OmNsaWNrJywgdGFyZ2V0VXJsKTtcbiAgICAgIH0sXG4gICAgICBvbkFkSW1wcmVzc2lvbigpIHtcbiAgICAgICAgdmkuZW1pdCgnbG9jYWw6OmltcHJlc3Npb24nKTtcbiAgICAgIH0sXG4gICAgICBvbkFkU3RvcHBlZChyZWFzb24pIHtcbiAgICAgICAgYXBwLm9mZigncmVzaXplJywgb25SZXNpemUpO1xuICAgICAgICByZW1vdmVPdmVybGF5KCk7XG5cbiAgICAgICAgdmkuZW1pdCgnbG9jYWw6OnN0b3BwZWQnLCByZWFzb24pO1xuICAgICAgICBpZiAocmVhc29uID09PSAnY29tcGxldGUnKSB7XG4gICAgICAgICAgdmkuZW1pdCgnbG9jYWw6OmNvbXBsZXRlJyk7XG4gICAgICAgICAgdmkuZW1pdCgnbG9jYWw6OmNvbXBsZXRlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWFzb24gPT09ICd1c2VyZXhpdCcpIHtcbiAgICAgICAgICB2aS5lbWl0KCdsb2NhbDo6dXNlcmV4aXQnKTtcbiAgICAgICAgfVxuICAgICAgICB2aS5kZXN0cm95ZWQgPSB0cnVlO1xuICAgICAgfSxcbiAgICAgIG9uQXV0b1BsYXlGYWlsZWQocmVhc29uLCB2aWRlb0VsKSB7XG4gICAgICAgIHZpLmVtaXQoJ2xvY2FsOjphdXRvcGxheUZhaWxlZCcsIHJlYXNvbiwgdmlkZW9FbCk7XG4gICAgICAgIGlmIChyZWFzb24gJiYgcmVhc29uLm5hbWUgJiYgcmVhc29uLm5hbWUuaW5kZXhPZignTm90QWxsb3dlZEVycm9yJykgIT09IC0xICYmIHZpLnBhcmFtcy5mYWxsYmFja092ZXJsYXkpIHtcbiAgICAgICAgICBjcmVhdGVPdmVybGF5KHZpZGVvRWwpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb25BZEVycm9yKG1zZykge1xuICAgICAgICByZW1vdmVPdmVybGF5KCk7XG4gICAgICAgIGFwcC5vZmYoJ3Jlc2l6ZScsIG9uUmVzaXplKTtcbiAgICAgICAgdmkuZW1pdCgnbG9jYWw6OmVycm9yJywgbXNnKTtcbiAgICAgICAgdmkuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgIH0sXG4gICAgfSk7XG5cbiAgICB2aS5pbml0KCk7XG5cbiAgICBVdGlscy5leHRlbmQodmksIHtcbiAgICAgIGFwcCxcbiAgICB9KTtcbiAgfVxuICBzdGFydCgpIHtcbiAgICBjb25zdCB2aSA9IHRoaXM7XG4gICAgaWYgKHZpLmRlc3Ryb3llZCkgcmV0dXJuO1xuICAgIGlmICh2aS5hZCkgdmkuYWQuc3RhcnRBZCgpO1xuICB9XG4gIHBhdXNlKCkge1xuICAgIGNvbnN0IHZpID0gdGhpcztcbiAgICBpZiAodmkuZGVzdHJveWVkKSByZXR1cm47XG4gICAgaWYgKHZpLmFkKSB2aS5hZC5wYXVzZUFkKCk7XG4gIH1cbiAgcmVzdW1lKCkge1xuICAgIGNvbnN0IHZpID0gdGhpcztcbiAgICBpZiAodmkuZGVzdHJveWVkKSByZXR1cm47XG4gICAgaWYgKHZpLmFkKSB2aS5hZC5yZXN1bWVBZCgpO1xuICB9XG4gIHN0b3AoKSB7XG4gICAgY29uc3QgdmkgPSB0aGlzO1xuICAgIGlmICh2aS5kZXN0cm95ZWQpIHJldHVybjtcbiAgICBpZiAodmkuYWQpIHZpLmFkLnN0b3BBZCgpO1xuICB9XG4gIGluaXQoKSB7XG4gICAgY29uc3QgdmkgPSB0aGlzO1xuICAgIGlmICh2aS5kZXN0cm95ZWQpIHJldHVybjtcbiAgICBpZiAodmkuYWQpIHZpLmFkLmluaXRBZCgpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgY29uc3QgdmkgPSB0aGlzO1xuICAgIHZpLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgdmkuZW1pdCgnbG9jYWw6OmJlZm9yZURlc3Ryb3knKTtcbiAgICBVdGlscy5kZWxldGVQcm9wcyh2aSk7XG4gIH1cbn1cblxudmFyIFZpID0ge1xuICBuYW1lOiAndmknLFxuICBwYXJhbXM6IHtcbiAgICB2aToge1xuICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICBhdXRvcGxheTogdHJ1ZSxcbiAgICAgIGZhbGxiYWNrT3ZlcmxheTogdHJ1ZSxcbiAgICAgIGZhbGxiYWNrT3ZlcmxheVRleHQ6ICdQbGVhc2Ugd2F0Y2ggdGhpcyBhZCcsXG4gICAgICBzaG93TXV0ZTogdHJ1ZSxcbiAgICAgIHN0YXJ0TXV0ZWQ6IChEZXZpY2UuaW9zIHx8IERldmljZS5hbmRyb2lkKSAmJiAhRGV2aWNlLmNvcmRvdmEsXG4gICAgICBhcHBJZDogbnVsbCxcbiAgICAgIGFwcFZlcjogbnVsbCxcbiAgICAgIGxhbmd1YWdlOiBudWxsLFxuICAgICAgd2lkdGg6IG51bGwsXG4gICAgICBoZWlnaHQ6IG51bGwsXG4gICAgICBwbGFjZW1lbnRJZDogJ3BsdGQ0bzdpYmI5cmM2NTN4MTQnLFxuICAgICAgcGxhY2VtZW50VHlwZTogJ2ludGVyc3RpdGlhbCcsXG4gICAgICB2aWRlb1Nsb3Q6IG51bGwsXG4gICAgICBzaG93UHJvZ3Jlc3M6IHRydWUsXG4gICAgICBzaG93QnJhbmRpbmc6IHRydWUsXG4gICAgICBvczogbnVsbCxcbiAgICAgIG9zVmVyc2lvbjogbnVsbCxcbiAgICAgIG9yaWVudGF0aW9uOiBudWxsLFxuICAgICAgYWdlOiBudWxsLFxuICAgICAgZ2VuZGVyOiBudWxsLFxuICAgICAgYWR2ZXJ0aXNlcklkOiBudWxsLFxuICAgICAgbGF0aXR1ZGU6IG51bGwsXG4gICAgICBsb25naXR1ZGU6IG51bGwsXG4gICAgICBhY2N1cmFjeTogbnVsbCxcbiAgICAgIHN0b3JlSWQ6IG51bGwsXG4gICAgICBpcDogbnVsbCxcbiAgICAgIG1hbnVmYWN0dXJlcjogbnVsbCxcbiAgICAgIG1vZGVsOiBudWxsLFxuICAgICAgY29ubmVjdGlvblR5cGU6IG51bGwsXG4gICAgICBjb25uZWN0aW9uUHJvdmlkZXI6IG51bGwsXG4gICAgfSxcbiAgfSxcbiAgY3JlYXRlKCkge1xuICAgIGNvbnN0IGFwcCA9IHRoaXM7XG4gICAgYXBwLnZpID0ge1xuICAgICAgc2RrUmVhZHk6IGZhbHNlLFxuICAgICAgY3JlYXRlQWQoYWRQYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBWaUFkKGFwcCwgYWRQYXJhbXMpO1xuICAgICAgfSxcbiAgICAgIGxvYWRTZGsoKSB7XG4gICAgICAgIGlmIChhcHAudmkuc2tkUmVhZHkpIHJldHVybjtcbiAgICAgICAgY29uc3Qgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgICAgIHNjcmlwdC5vbmxvYWQgPSBmdW5jdGlvbiBvbmxvYWQoKSB7XG4gICAgICAgICAgYXBwLmVtaXQoJ3ZpU2RrUmVhZHknKTtcbiAgICAgICAgICBhcHAudmkuc2tkUmVhZHkgPSB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICBzY3JpcHQuc3JjID0gJ2h0dHBzOi8vYy52aS1zZXJ2ZS5jb20vdmlhZHNodG1sL3ZpLm1pbi5qcyc7XG4gICAgICAgICQoJ2hlYWQnKS5hcHBlbmQoc2NyaXB0KTtcbiAgICAgIH0sXG4gICAgfTtcbiAgfSxcbiAgb246IHtcbiAgICBpbml0KCkge1xuICAgICAgY29uc3QgYXBwID0gdGhpcztcbiAgICAgIGlmIChhcHAucGFyYW1zLnZpLmVuYWJsZWQgfHwgKGFwcC5wYXNzZWRQYXJhbXMudmkgJiYgYXBwLnBhc3NlZFBhcmFtcy52aS5lbmFibGVkICE9PSBmYWxzZSkpIGFwcC52aS5sb2FkU2RrKCk7XG4gICAgfSxcbiAgfSxcbn07XG5cbnZhciBUeXBvZ3JhcGh5ID0ge1xuICBuYW1lOiAndHlwb2dyYXBoeScsXG59O1xuXG4vLyBJbnN0YWxsIENvcmUgTW9kdWxlcyAmIENvbXBvbmVudHNcbkZyYW1ld29yazcudXNlKFtcbiAgRGV2aWNlTW9kdWxlLFxuICBTdXBwb3J0TW9kdWxlLFxuICBVdGlsc01vZHVsZSxcbiAgUmVzaXplTW9kdWxlLFxuICBSZXF1ZXN0TW9kdWxlLFxuICBUb3VjaE1vZHVsZSxcbiAgQ2xpY2tzTW9kdWxlLFxuICBSb3V0ZXIkMSxcbiAgSGlzdG9yeU1vZHVsZSxcbiAgU3RvcmFnZU1vZHVsZSxcbiAgU3RhdHVzYmFyJDEsXG4gIFZpZXckMSxcbiAgTmF2YmFyJDEsXG4gIFRvb2xiYXIkMSxcbiAgU3VibmF2YmFyLFxuICBUb3VjaFJpcHBsZSQxLFxuICBNb2RhbCQxLFxuICBEaWFsb2ckMSxcbiAgUG9wdXAkMSxcbiAgTG9naW5TY3JlZW4kMSxcbiAgUG9wb3ZlciQxLFxuICBBY3Rpb25zJDEsXG4gIFNoZWV0JDEsXG4gIFRvYXN0JDEsXG4gIFByZWxvYWRlciQxLFxuICBQcm9ncmVzc2JhciQxLFxuICBTb3J0YWJsZSQxLFxuICBTd2lwZW91dCQxLFxuICBBY2NvcmRpb24kMSxcbiAgVmlydHVhbExpc3QkMSxcbiAgTGlzdEluZGV4JDEsXG4gIFRpbWVsaW5lLFxuICBUYWJzLFxuICBQYW5lbCQxLFxuICBDYXJkLFxuICBDaGlwLFxuICBGb3JtLFxuICBJbnB1dCQxLFxuICBDaGVja2JveCxcbiAgUmFkaW8sXG4gIFRvZ2dsZSQxLFxuICBSYW5nZSQxLFxuICBTdGVwcGVyJDEsXG4gIFNtYXJ0U2VsZWN0JDEsXG4gIEdyaWQsXG4gIENhbGVuZGFyJDEsXG4gIFBpY2tlciQxLFxuICBJbmZpbml0ZVNjcm9sbCQxLFxuICBQdWxsVG9SZWZyZXNoJDEsXG4gIExhenkkMSxcbiAgRGF0YVRhYmxlJDEsXG4gIEZhYiQxLFxuICBTZWFyY2hiYXIkMSxcbiAgTWVzc2FnZXMkMSxcbiAgTWVzc2FnZWJhciQxLFxuICBTd2lwZXIkMSxcbiAgUGhvdG9Ccm93c2VyJDEsXG4gIE5vdGlmaWNhdGlvbiQxLFxuICBBdXRvY29tcGxldGUkMSxcbiAgVmksXG4gIFR5cG9ncmFwaHlcbl0pO1xuXG5leHBvcnQgZGVmYXVsdCBGcmFtZXdvcms3O1xuZXhwb3J0IHsgUmVxdWVzdCwgVXRpbHMsIERldmljZSwgU3VwcG9ydCB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZnJhbWV3b3JrNy9kaXN0L2ZyYW1ld29yazcuZXNtLmJ1bmRsZS5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZnJhbWV3b3JrNy9kaXN0L2ZyYW1ld29yazcuZXNtLmJ1bmRsZS5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxuICogRXhwb3NlIGBwYXRoVG9SZWdleHBgLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IHBhdGhUb1JlZ2V4cFxubW9kdWxlLmV4cG9ydHMucGFyc2UgPSBwYXJzZVxubW9kdWxlLmV4cG9ydHMuY29tcGlsZSA9IGNvbXBpbGVcbm1vZHVsZS5leHBvcnRzLnRva2Vuc1RvRnVuY3Rpb24gPSB0b2tlbnNUb0Z1bmN0aW9uXG5tb2R1bGUuZXhwb3J0cy50b2tlbnNUb1JlZ0V4cCA9IHRva2Vuc1RvUmVnRXhwXG5cbi8qKlxuICogRGVmYXVsdCBjb25maWdzLlxuICovXG52YXIgREVGQVVMVF9ERUxJTUlURVIgPSAnLydcbnZhciBERUZBVUxUX0RFTElNSVRFUlMgPSAnLi8nXG5cbi8qKlxuICogVGhlIG1haW4gcGF0aCBtYXRjaGluZyByZWdleHAgdXRpbGl0eS5cbiAqXG4gKiBAdHlwZSB7UmVnRXhwfVxuICovXG52YXIgUEFUSF9SRUdFWFAgPSBuZXcgUmVnRXhwKFtcbiAgLy8gTWF0Y2ggZXNjYXBlZCBjaGFyYWN0ZXJzIHRoYXQgd291bGQgb3RoZXJ3aXNlIGFwcGVhciBpbiBmdXR1cmUgbWF0Y2hlcy5cbiAgLy8gVGhpcyBhbGxvd3MgdGhlIHVzZXIgdG8gZXNjYXBlIHNwZWNpYWwgY2hhcmFjdGVycyB0aGF0IHdvbid0IHRyYW5zZm9ybS5cbiAgJyhcXFxcXFxcXC4pJyxcbiAgLy8gTWF0Y2ggRXhwcmVzcy1zdHlsZSBwYXJhbWV0ZXJzIGFuZCB1bi1uYW1lZCBwYXJhbWV0ZXJzIHdpdGggYSBwcmVmaXhcbiAgLy8gYW5kIG9wdGlvbmFsIHN1ZmZpeGVzLiBNYXRjaGVzIGFwcGVhciBhczpcbiAgLy9cbiAgLy8gXCIvOnRlc3QoXFxcXGQrKT9cIiA9PiBbXCIvXCIsIFwidGVzdFwiLCBcIlxcZCtcIiwgdW5kZWZpbmVkLCBcIj9cIl1cbiAgLy8gXCIvcm91dGUoXFxcXGQrKVwiICA9PiBbdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgXCJcXGQrXCIsIHVuZGVmaW5lZF1cbiAgJyg/OlxcXFw6KFxcXFx3KykoPzpcXFxcKCgoPzpcXFxcXFxcXC58W15cXFxcXFxcXCgpXSkrKVxcXFwpKT98XFxcXCgoKD86XFxcXFxcXFwufFteXFxcXFxcXFwoKV0pKylcXFxcKSkoWysqP10pPydcbl0uam9pbignfCcpLCAnZycpXG5cbi8qKlxuICogUGFyc2UgYSBzdHJpbmcgZm9yIHRoZSByYXcgdG9rZW5zLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gIHN0clxuICogQHBhcmFtICB7T2JqZWN0PX0gb3B0aW9uc1xuICogQHJldHVybiB7IUFycmF5fVxuICovXG5mdW5jdGlvbiBwYXJzZSAoc3RyLCBvcHRpb25zKSB7XG4gIHZhciB0b2tlbnMgPSBbXVxuICB2YXIga2V5ID0gMFxuICB2YXIgaW5kZXggPSAwXG4gIHZhciBwYXRoID0gJydcbiAgdmFyIGRlZmF1bHREZWxpbWl0ZXIgPSAob3B0aW9ucyAmJiBvcHRpb25zLmRlbGltaXRlcikgfHwgREVGQVVMVF9ERUxJTUlURVJcbiAgdmFyIGRlbGltaXRlcnMgPSAob3B0aW9ucyAmJiBvcHRpb25zLmRlbGltaXRlcnMpIHx8IERFRkFVTFRfREVMSU1JVEVSU1xuICB2YXIgcGF0aEVzY2FwZWQgPSBmYWxzZVxuICB2YXIgcmVzXG5cbiAgd2hpbGUgKChyZXMgPSBQQVRIX1JFR0VYUC5leGVjKHN0cikpICE9PSBudWxsKSB7XG4gICAgdmFyIG0gPSByZXNbMF1cbiAgICB2YXIgZXNjYXBlZCA9IHJlc1sxXVxuICAgIHZhciBvZmZzZXQgPSByZXMuaW5kZXhcbiAgICBwYXRoICs9IHN0ci5zbGljZShpbmRleCwgb2Zmc2V0KVxuICAgIGluZGV4ID0gb2Zmc2V0ICsgbS5sZW5ndGhcblxuICAgIC8vIElnbm9yZSBhbHJlYWR5IGVzY2FwZWQgc2VxdWVuY2VzLlxuICAgIGlmIChlc2NhcGVkKSB7XG4gICAgICBwYXRoICs9IGVzY2FwZWRbMV1cbiAgICAgIHBhdGhFc2NhcGVkID0gdHJ1ZVxuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICB2YXIgcHJldiA9ICcnXG4gICAgdmFyIG5leHQgPSBzdHJbaW5kZXhdXG4gICAgdmFyIG5hbWUgPSByZXNbMl1cbiAgICB2YXIgY2FwdHVyZSA9IHJlc1szXVxuICAgIHZhciBncm91cCA9IHJlc1s0XVxuICAgIHZhciBtb2RpZmllciA9IHJlc1s1XVxuXG4gICAgaWYgKCFwYXRoRXNjYXBlZCAmJiBwYXRoLmxlbmd0aCkge1xuICAgICAgdmFyIGsgPSBwYXRoLmxlbmd0aCAtIDFcblxuICAgICAgaWYgKGRlbGltaXRlcnMuaW5kZXhPZihwYXRoW2tdKSA+IC0xKSB7XG4gICAgICAgIHByZXYgPSBwYXRoW2tdXG4gICAgICAgIHBhdGggPSBwYXRoLnNsaWNlKDAsIGspXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUHVzaCB0aGUgY3VycmVudCBwYXRoIG9udG8gdGhlIHRva2Vucy5cbiAgICBpZiAocGF0aCkge1xuICAgICAgdG9rZW5zLnB1c2gocGF0aClcbiAgICAgIHBhdGggPSAnJ1xuICAgICAgcGF0aEVzY2FwZWQgPSBmYWxzZVxuICAgIH1cblxuICAgIHZhciBwYXJ0aWFsID0gcHJldiAhPT0gJycgJiYgbmV4dCAhPT0gdW5kZWZpbmVkICYmIG5leHQgIT09IHByZXZcbiAgICB2YXIgcmVwZWF0ID0gbW9kaWZpZXIgPT09ICcrJyB8fCBtb2RpZmllciA9PT0gJyonXG4gICAgdmFyIG9wdGlvbmFsID0gbW9kaWZpZXIgPT09ICc/JyB8fCBtb2RpZmllciA9PT0gJyonXG4gICAgdmFyIGRlbGltaXRlciA9IHByZXYgfHwgZGVmYXVsdERlbGltaXRlclxuICAgIHZhciBwYXR0ZXJuID0gY2FwdHVyZSB8fCBncm91cFxuXG4gICAgdG9rZW5zLnB1c2goe1xuICAgICAgbmFtZTogbmFtZSB8fCBrZXkrKyxcbiAgICAgIHByZWZpeDogcHJldixcbiAgICAgIGRlbGltaXRlcjogZGVsaW1pdGVyLFxuICAgICAgb3B0aW9uYWw6IG9wdGlvbmFsLFxuICAgICAgcmVwZWF0OiByZXBlYXQsXG4gICAgICBwYXJ0aWFsOiBwYXJ0aWFsLFxuICAgICAgcGF0dGVybjogcGF0dGVybiA/IGVzY2FwZUdyb3VwKHBhdHRlcm4pIDogJ1teJyArIGVzY2FwZVN0cmluZyhkZWxpbWl0ZXIpICsgJ10rPydcbiAgICB9KVxuICB9XG5cbiAgLy8gUHVzaCBhbnkgcmVtYWluaW5nIGNoYXJhY3RlcnMuXG4gIGlmIChwYXRoIHx8IGluZGV4IDwgc3RyLmxlbmd0aCkge1xuICAgIHRva2Vucy5wdXNoKHBhdGggKyBzdHIuc3Vic3RyKGluZGV4KSlcbiAgfVxuXG4gIHJldHVybiB0b2tlbnNcbn1cblxuLyoqXG4gKiBDb21waWxlIGEgc3RyaW5nIHRvIGEgdGVtcGxhdGUgZnVuY3Rpb24gZm9yIHRoZSBwYXRoLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gICAgICAgICAgICAgc3RyXG4gKiBAcGFyYW0gIHtPYmplY3Q9fSAgICAgICAgICAgIG9wdGlvbnNcbiAqIEByZXR1cm4geyFmdW5jdGlvbihPYmplY3Q9LCBPYmplY3Q9KX1cbiAqL1xuZnVuY3Rpb24gY29tcGlsZSAoc3RyLCBvcHRpb25zKSB7XG4gIHJldHVybiB0b2tlbnNUb0Z1bmN0aW9uKHBhcnNlKHN0ciwgb3B0aW9ucykpXG59XG5cbi8qKlxuICogRXhwb3NlIGEgbWV0aG9kIGZvciB0cmFuc2Zvcm1pbmcgdG9rZW5zIGludG8gdGhlIHBhdGggZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIHRva2Vuc1RvRnVuY3Rpb24gKHRva2Vucykge1xuICAvLyBDb21waWxlIGFsbCB0aGUgdG9rZW5zIGludG8gcmVnZXhwcy5cbiAgdmFyIG1hdGNoZXMgPSBuZXcgQXJyYXkodG9rZW5zLmxlbmd0aClcblxuICAvLyBDb21waWxlIGFsbCB0aGUgcGF0dGVybnMgYmVmb3JlIGNvbXBpbGF0aW9uLlxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgIGlmICh0eXBlb2YgdG9rZW5zW2ldID09PSAnb2JqZWN0Jykge1xuICAgICAgbWF0Y2hlc1tpXSA9IG5ldyBSZWdFeHAoJ14oPzonICsgdG9rZW5zW2ldLnBhdHRlcm4gKyAnKSQnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoZGF0YSwgb3B0aW9ucykge1xuICAgIHZhciBwYXRoID0gJydcbiAgICB2YXIgZW5jb2RlID0gKG9wdGlvbnMgJiYgb3B0aW9ucy5lbmNvZGUpIHx8IGVuY29kZVVSSUNvbXBvbmVudFxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB0b2tlbiA9IHRva2Vuc1tpXVxuXG4gICAgICBpZiAodHlwZW9mIHRva2VuID09PSAnc3RyaW5nJykge1xuICAgICAgICBwYXRoICs9IHRva2VuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIHZhciB2YWx1ZSA9IGRhdGEgPyBkYXRhW3Rva2VuLm5hbWVdIDogdW5kZWZpbmVkXG4gICAgICB2YXIgc2VnbWVudFxuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgaWYgKCF0b2tlbi5yZXBlYXQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBcIicgKyB0b2tlbi5uYW1lICsgJ1wiIHRvIG5vdCByZXBlYXQsIGJ1dCBnb3QgYXJyYXknKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGlmICh0b2tlbi5vcHRpb25hbCkgY29udGludWVcblxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIFwiJyArIHRva2VuLm5hbWUgKyAnXCIgdG8gbm90IGJlIGVtcHR5JylcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdmFsdWUubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBzZWdtZW50ID0gZW5jb2RlKHZhbHVlW2pdLCB0b2tlbilcblxuICAgICAgICAgIGlmICghbWF0Y2hlc1tpXS50ZXN0KHNlZ21lbnQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBhbGwgXCInICsgdG9rZW4ubmFtZSArICdcIiB0byBtYXRjaCBcIicgKyB0b2tlbi5wYXR0ZXJuICsgJ1wiJylcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwYXRoICs9IChqID09PSAwID8gdG9rZW4ucHJlZml4IDogdG9rZW4uZGVsaW1pdGVyKSArIHNlZ21lbnRcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgfHwgdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgc2VnbWVudCA9IGVuY29kZShTdHJpbmcodmFsdWUpLCB0b2tlbilcblxuICAgICAgICBpZiAoIW1hdGNoZXNbaV0udGVzdChzZWdtZW50KSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIFwiJyArIHRva2VuLm5hbWUgKyAnXCIgdG8gbWF0Y2ggXCInICsgdG9rZW4ucGF0dGVybiArICdcIiwgYnV0IGdvdCBcIicgKyBzZWdtZW50ICsgJ1wiJylcbiAgICAgICAgfVxuXG4gICAgICAgIHBhdGggKz0gdG9rZW4ucHJlZml4ICsgc2VnbWVudFxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICBpZiAodG9rZW4ub3B0aW9uYWwpIHtcbiAgICAgICAgLy8gUHJlcGVuZCBwYXJ0aWFsIHNlZ21lbnQgcHJlZml4ZXMuXG4gICAgICAgIGlmICh0b2tlbi5wYXJ0aWFsKSBwYXRoICs9IHRva2VuLnByZWZpeFxuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIFwiJyArIHRva2VuLm5hbWUgKyAnXCIgdG8gYmUgJyArICh0b2tlbi5yZXBlYXQgPyAnYW4gYXJyYXknIDogJ2Egc3RyaW5nJykpXG4gICAgfVxuXG4gICAgcmV0dXJuIHBhdGhcbiAgfVxufVxuXG4vKipcbiAqIEVzY2FwZSBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBzdHJpbmcuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZXNjYXBlU3RyaW5nIChzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC8oWy4rKj89XiE6JHt9KClbXFxdfC9cXFxcXSkvZywgJ1xcXFwkMScpXG59XG5cbi8qKlxuICogRXNjYXBlIHRoZSBjYXB0dXJpbmcgZ3JvdXAgYnkgZXNjYXBpbmcgc3BlY2lhbCBjaGFyYWN0ZXJzIGFuZCBtZWFuaW5nLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gZ3JvdXBcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZXNjYXBlR3JvdXAgKGdyb3VwKSB7XG4gIHJldHVybiBncm91cC5yZXBsYWNlKC8oWz0hOiQvKCldKS9nLCAnXFxcXCQxJylcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGZsYWdzIGZvciBhIHJlZ2V4cCBmcm9tIHRoZSBvcHRpb25zLlxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBmbGFncyAob3B0aW9ucykge1xuICByZXR1cm4gb3B0aW9ucyAmJiBvcHRpb25zLnNlbnNpdGl2ZSA/ICcnIDogJ2knXG59XG5cbi8qKlxuICogUHVsbCBvdXQga2V5cyBmcm9tIGEgcmVnZXhwLlxuICpcbiAqIEBwYXJhbSAgeyFSZWdFeHB9IHBhdGhcbiAqIEBwYXJhbSAge0FycmF5PX0gIGtleXNcbiAqIEByZXR1cm4geyFSZWdFeHB9XG4gKi9cbmZ1bmN0aW9uIHJlZ2V4cFRvUmVnZXhwIChwYXRoLCBrZXlzKSB7XG4gIGlmICgha2V5cykgcmV0dXJuIHBhdGhcblxuICAvLyBVc2UgYSBuZWdhdGl2ZSBsb29rYWhlYWQgdG8gbWF0Y2ggb25seSBjYXB0dXJpbmcgZ3JvdXBzLlxuICB2YXIgZ3JvdXBzID0gcGF0aC5zb3VyY2UubWF0Y2goL1xcKCg/IVxcPykvZylcblxuICBpZiAoZ3JvdXBzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBncm91cHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGtleXMucHVzaCh7XG4gICAgICAgIG5hbWU6IGksXG4gICAgICAgIHByZWZpeDogbnVsbCxcbiAgICAgICAgZGVsaW1pdGVyOiBudWxsLFxuICAgICAgICBvcHRpb25hbDogZmFsc2UsXG4gICAgICAgIHJlcGVhdDogZmFsc2UsXG4gICAgICAgIHBhcnRpYWw6IGZhbHNlLFxuICAgICAgICBwYXR0ZXJuOiBudWxsXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwYXRoXG59XG5cbi8qKlxuICogVHJhbnNmb3JtIGFuIGFycmF5IGludG8gYSByZWdleHAuXG4gKlxuICogQHBhcmFtICB7IUFycmF5fSAgcGF0aFxuICogQHBhcmFtICB7QXJyYXk9fSAga2V5c1xuICogQHBhcmFtICB7T2JqZWN0PX0gb3B0aW9uc1xuICogQHJldHVybiB7IVJlZ0V4cH1cbiAqL1xuZnVuY3Rpb24gYXJyYXlUb1JlZ2V4cCAocGF0aCwga2V5cywgb3B0aW9ucykge1xuICB2YXIgcGFydHMgPSBbXVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xuICAgIHBhcnRzLnB1c2gocGF0aFRvUmVnZXhwKHBhdGhbaV0sIGtleXMsIG9wdGlvbnMpLnNvdXJjZSlcbiAgfVxuXG4gIHJldHVybiBuZXcgUmVnRXhwKCcoPzonICsgcGFydHMuam9pbignfCcpICsgJyknLCBmbGFncyhvcHRpb25zKSlcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBwYXRoIHJlZ2V4cCBmcm9tIHN0cmluZyBpbnB1dC5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9ICBwYXRoXG4gKiBAcGFyYW0gIHtBcnJheT19ICBrZXlzXG4gKiBAcGFyYW0gIHtPYmplY3Q9fSBvcHRpb25zXG4gKiBAcmV0dXJuIHshUmVnRXhwfVxuICovXG5mdW5jdGlvbiBzdHJpbmdUb1JlZ2V4cCAocGF0aCwga2V5cywgb3B0aW9ucykge1xuICByZXR1cm4gdG9rZW5zVG9SZWdFeHAocGFyc2UocGF0aCwgb3B0aW9ucyksIGtleXMsIG9wdGlvbnMpXG59XG5cbi8qKlxuICogRXhwb3NlIGEgZnVuY3Rpb24gZm9yIHRha2luZyB0b2tlbnMgYW5kIHJldHVybmluZyBhIFJlZ0V4cC5cbiAqXG4gKiBAcGFyYW0gIHshQXJyYXl9ICB0b2tlbnNcbiAqIEBwYXJhbSAge0FycmF5PX0gIGtleXNcbiAqIEBwYXJhbSAge09iamVjdD19IG9wdGlvbnNcbiAqIEByZXR1cm4geyFSZWdFeHB9XG4gKi9cbmZ1bmN0aW9uIHRva2Vuc1RvUmVnRXhwICh0b2tlbnMsIGtleXMsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cblxuICB2YXIgc3RyaWN0ID0gb3B0aW9ucy5zdHJpY3RcbiAgdmFyIGVuZCA9IG9wdGlvbnMuZW5kICE9PSBmYWxzZVxuICB2YXIgZGVsaW1pdGVyID0gZXNjYXBlU3RyaW5nKG9wdGlvbnMuZGVsaW1pdGVyIHx8IERFRkFVTFRfREVMSU1JVEVSKVxuICB2YXIgZGVsaW1pdGVycyA9IG9wdGlvbnMuZGVsaW1pdGVycyB8fCBERUZBVUxUX0RFTElNSVRFUlNcbiAgdmFyIGVuZHNXaXRoID0gW10uY29uY2F0KG9wdGlvbnMuZW5kc1dpdGggfHwgW10pLm1hcChlc2NhcGVTdHJpbmcpLmNvbmNhdCgnJCcpLmpvaW4oJ3wnKVxuICB2YXIgcm91dGUgPSAnJ1xuICB2YXIgaXNFbmREZWxpbWl0ZWQgPSB0b2tlbnMubGVuZ3RoID09PSAwXG5cbiAgLy8gSXRlcmF0ZSBvdmVyIHRoZSB0b2tlbnMgYW5kIGNyZWF0ZSBvdXIgcmVnZXhwIHN0cmluZy5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdG9rZW4gPSB0b2tlbnNbaV1cblxuICAgIGlmICh0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICByb3V0ZSArPSBlc2NhcGVTdHJpbmcodG9rZW4pXG4gICAgICBpc0VuZERlbGltaXRlZCA9IGkgPT09IHRva2Vucy5sZW5ndGggLSAxICYmIGRlbGltaXRlcnMuaW5kZXhPZih0b2tlblt0b2tlbi5sZW5ndGggLSAxXSkgPiAtMVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcHJlZml4ID0gZXNjYXBlU3RyaW5nKHRva2VuLnByZWZpeClcbiAgICAgIHZhciBjYXB0dXJlID0gdG9rZW4ucmVwZWF0XG4gICAgICAgID8gJyg/OicgKyB0b2tlbi5wYXR0ZXJuICsgJykoPzonICsgcHJlZml4ICsgJyg/OicgKyB0b2tlbi5wYXR0ZXJuICsgJykpKidcbiAgICAgICAgOiB0b2tlbi5wYXR0ZXJuXG5cbiAgICAgIGlmIChrZXlzKSBrZXlzLnB1c2godG9rZW4pXG5cbiAgICAgIGlmICh0b2tlbi5vcHRpb25hbCkge1xuICAgICAgICBpZiAodG9rZW4ucGFydGlhbCkge1xuICAgICAgICAgIHJvdXRlICs9IHByZWZpeCArICcoJyArIGNhcHR1cmUgKyAnKT8nXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcm91dGUgKz0gJyg/OicgKyBwcmVmaXggKyAnKCcgKyBjYXB0dXJlICsgJykpPydcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcm91dGUgKz0gcHJlZml4ICsgJygnICsgY2FwdHVyZSArICcpJ1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChlbmQpIHtcbiAgICBpZiAoIXN0cmljdCkgcm91dGUgKz0gJyg/OicgKyBkZWxpbWl0ZXIgKyAnKT8nXG5cbiAgICByb3V0ZSArPSBlbmRzV2l0aCA9PT0gJyQnID8gJyQnIDogJyg/PScgKyBlbmRzV2l0aCArICcpJ1xuICB9IGVsc2Uge1xuICAgIGlmICghc3RyaWN0KSByb3V0ZSArPSAnKD86JyArIGRlbGltaXRlciArICcoPz0nICsgZW5kc1dpdGggKyAnKSk/J1xuICAgIGlmICghaXNFbmREZWxpbWl0ZWQpIHJvdXRlICs9ICcoPz0nICsgZGVsaW1pdGVyICsgJ3wnICsgZW5kc1dpdGggKyAnKSdcbiAgfVxuXG4gIHJldHVybiBuZXcgUmVnRXhwKCdeJyArIHJvdXRlLCBmbGFncyhvcHRpb25zKSlcbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgdGhlIGdpdmVuIHBhdGggc3RyaW5nLCByZXR1cm5pbmcgYSByZWd1bGFyIGV4cHJlc3Npb24uXG4gKlxuICogQW4gZW1wdHkgYXJyYXkgY2FuIGJlIHBhc3NlZCBpbiBmb3IgdGhlIGtleXMsIHdoaWNoIHdpbGwgaG9sZCB0aGVcbiAqIHBsYWNlaG9sZGVyIGtleSBkZXNjcmlwdGlvbnMuIEZvciBleGFtcGxlLCB1c2luZyBgL3VzZXIvOmlkYCwgYGtleXNgIHdpbGxcbiAqIGNvbnRhaW4gYFt7IG5hbWU6ICdpZCcsIGRlbGltaXRlcjogJy8nLCBvcHRpb25hbDogZmFsc2UsIHJlcGVhdDogZmFsc2UgfV1gLlxuICpcbiAqIEBwYXJhbSAgeyhzdHJpbmd8UmVnRXhwfEFycmF5KX0gcGF0aFxuICogQHBhcmFtICB7QXJyYXk9fSAgICAgICAgICAgICAgICBrZXlzXG4gKiBAcGFyYW0gIHtPYmplY3Q9fSAgICAgICAgICAgICAgIG9wdGlvbnNcbiAqIEByZXR1cm4geyFSZWdFeHB9XG4gKi9cbmZ1bmN0aW9uIHBhdGhUb1JlZ2V4cCAocGF0aCwga2V5cywgb3B0aW9ucykge1xuICBpZiAocGF0aCBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgIHJldHVybiByZWdleHBUb1JlZ2V4cChwYXRoLCBrZXlzKVxuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkocGF0aCkpIHtcbiAgICByZXR1cm4gYXJyYXlUb1JlZ2V4cCgvKiogQHR5cGUgeyFBcnJheX0gKi8gKHBhdGgpLCBrZXlzLCBvcHRpb25zKVxuICB9XG5cbiAgcmV0dXJuIHN0cmluZ1RvUmVnZXhwKC8qKiBAdHlwZSB7c3RyaW5nfSAqLyAocGF0aCksIGtleXMsIG9wdGlvbnMpXG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9mcmFtZXdvcms3L25vZGVfbW9kdWxlcy9wYXRoLXRvLXJlZ2V4cC9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZnJhbWV3b3JrNy9ub2RlX21vZHVsZXMvcGF0aC10by1yZWdleHAvaW5kZXguanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIoZnVuY3Rpb24gKGdsb2JhbCwgdW5kZWZpbmVkKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBpZiAoZ2xvYmFsLnNldEltbWVkaWF0ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG5leHRIYW5kbGUgPSAxOyAvLyBTcGVjIHNheXMgZ3JlYXRlciB0aGFuIHplcm9cbiAgICB2YXIgdGFza3NCeUhhbmRsZSA9IHt9O1xuICAgIHZhciBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSBmYWxzZTtcbiAgICB2YXIgZG9jID0gZ2xvYmFsLmRvY3VtZW50O1xuICAgIHZhciByZWdpc3RlckltbWVkaWF0ZTtcblxuICAgIGZ1bmN0aW9uIHNldEltbWVkaWF0ZShjYWxsYmFjaykge1xuICAgICAgLy8gQ2FsbGJhY2sgY2FuIGVpdGhlciBiZSBhIGZ1bmN0aW9uIG9yIGEgc3RyaW5nXG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBuZXcgRnVuY3Rpb24oXCJcIiArIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICAgIC8vIENvcHkgZnVuY3Rpb24gYXJndW1lbnRzXG4gICAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2kgKyAxXTtcbiAgICAgIH1cbiAgICAgIC8vIFN0b3JlIGFuZCByZWdpc3RlciB0aGUgdGFza1xuICAgICAgdmFyIHRhc2sgPSB7IGNhbGxiYWNrOiBjYWxsYmFjaywgYXJnczogYXJncyB9O1xuICAgICAgdGFza3NCeUhhbmRsZVtuZXh0SGFuZGxlXSA9IHRhc2s7XG4gICAgICByZWdpc3RlckltbWVkaWF0ZShuZXh0SGFuZGxlKTtcbiAgICAgIHJldHVybiBuZXh0SGFuZGxlKys7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xlYXJJbW1lZGlhdGUoaGFuZGxlKSB7XG4gICAgICAgIGRlbGV0ZSB0YXNrc0J5SGFuZGxlW2hhbmRsZV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcnVuKHRhc2spIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gdGFzay5jYWxsYmFjaztcbiAgICAgICAgdmFyIGFyZ3MgPSB0YXNrLmFyZ3M7XG4gICAgICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBjYWxsYmFjayhhcmdzWzBdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBjYWxsYmFjayhhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBjYWxsYmFjayhhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkodW5kZWZpbmVkLCBhcmdzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcnVuSWZQcmVzZW50KGhhbmRsZSkge1xuICAgICAgICAvLyBGcm9tIHRoZSBzcGVjOiBcIldhaXQgdW50aWwgYW55IGludm9jYXRpb25zIG9mIHRoaXMgYWxnb3JpdGhtIHN0YXJ0ZWQgYmVmb3JlIHRoaXMgb25lIGhhdmUgY29tcGxldGVkLlwiXG4gICAgICAgIC8vIFNvIGlmIHdlJ3JlIGN1cnJlbnRseSBydW5uaW5nIGEgdGFzaywgd2UnbGwgbmVlZCB0byBkZWxheSB0aGlzIGludm9jYXRpb24uXG4gICAgICAgIGlmIChjdXJyZW50bHlSdW5uaW5nQVRhc2spIHtcbiAgICAgICAgICAgIC8vIERlbGF5IGJ5IGRvaW5nIGEgc2V0VGltZW91dC4gc2V0SW1tZWRpYXRlIHdhcyB0cmllZCBpbnN0ZWFkLCBidXQgaW4gRmlyZWZveCA3IGl0IGdlbmVyYXRlZCBhXG4gICAgICAgICAgICAvLyBcInRvbyBtdWNoIHJlY3Vyc2lvblwiIGVycm9yLlxuICAgICAgICAgICAgc2V0VGltZW91dChydW5JZlByZXNlbnQsIDAsIGhhbmRsZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgdGFzayA9IHRhc2tzQnlIYW5kbGVbaGFuZGxlXTtcbiAgICAgICAgICAgIGlmICh0YXNrKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudGx5UnVubmluZ0FUYXNrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBydW4odGFzayk7XG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJJbW1lZGlhdGUoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudGx5UnVubmluZ0FUYXNrID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbE5leHRUaWNrSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHsgcnVuSWZQcmVzZW50KGhhbmRsZSk7IH0pO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNhblVzZVBvc3RNZXNzYWdlKCkge1xuICAgICAgICAvLyBUaGUgdGVzdCBhZ2FpbnN0IGBpbXBvcnRTY3JpcHRzYCBwcmV2ZW50cyB0aGlzIGltcGxlbWVudGF0aW9uIGZyb20gYmVpbmcgaW5zdGFsbGVkIGluc2lkZSBhIHdlYiB3b3JrZXIsXG4gICAgICAgIC8vIHdoZXJlIGBnbG9iYWwucG9zdE1lc3NhZ2VgIG1lYW5zIHNvbWV0aGluZyBjb21wbGV0ZWx5IGRpZmZlcmVudCBhbmQgY2FuJ3QgYmUgdXNlZCBmb3IgdGhpcyBwdXJwb3NlLlxuICAgICAgICBpZiAoZ2xvYmFsLnBvc3RNZXNzYWdlICYmICFnbG9iYWwuaW1wb3J0U2NyaXB0cykge1xuICAgICAgICAgICAgdmFyIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIG9sZE9uTWVzc2FnZSA9IGdsb2JhbC5vbm1lc3NhZ2U7XG4gICAgICAgICAgICBnbG9iYWwub25tZXNzYWdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cyA9IGZhbHNlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShcIlwiLCBcIipcIik7XG4gICAgICAgICAgICBnbG9iYWwub25tZXNzYWdlID0gb2xkT25NZXNzYWdlO1xuICAgICAgICAgICAgcmV0dXJuIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsUG9zdE1lc3NhZ2VJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgLy8gSW5zdGFsbHMgYW4gZXZlbnQgaGFuZGxlciBvbiBgZ2xvYmFsYCBmb3IgdGhlIGBtZXNzYWdlYCBldmVudDogc2VlXG4gICAgICAgIC8vICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vRE9NL3dpbmRvdy5wb3N0TWVzc2FnZVxuICAgICAgICAvLyAqIGh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL2NvbW1zLmh0bWwjY3Jvc3NEb2N1bWVudE1lc3NhZ2VzXG5cbiAgICAgICAgdmFyIG1lc3NhZ2VQcmVmaXggPSBcInNldEltbWVkaWF0ZSRcIiArIE1hdGgucmFuZG9tKCkgKyBcIiRcIjtcbiAgICAgICAgdmFyIG9uR2xvYmFsTWVzc2FnZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoZXZlbnQuc291cmNlID09PSBnbG9iYWwgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgZXZlbnQuZGF0YSA9PT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICAgICAgICAgIGV2ZW50LmRhdGEuaW5kZXhPZihtZXNzYWdlUHJlZml4KSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJ1bklmUHJlc2VudCgrZXZlbnQuZGF0YS5zbGljZShtZXNzYWdlUHJlZml4Lmxlbmd0aCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIG9uR2xvYmFsTWVzc2FnZSwgZmFsc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2xvYmFsLmF0dGFjaEV2ZW50KFwib25tZXNzYWdlXCIsIG9uR2xvYmFsTWVzc2FnZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKG1lc3NhZ2VQcmVmaXggKyBoYW5kbGUsIFwiKlwiKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsTWVzc2FnZUNoYW5uZWxJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgdmFyIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICAgICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgdmFyIGhhbmRsZSA9IGV2ZW50LmRhdGE7XG4gICAgICAgICAgICBydW5JZlByZXNlbnQoaGFuZGxlKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgY2hhbm5lbC5wb3J0Mi5wb3N0TWVzc2FnZShoYW5kbGUpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxSZWFkeVN0YXRlQ2hhbmdlSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHZhciBodG1sID0gZG9jLmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIDxzY3JpcHQ+IGVsZW1lbnQ7IGl0cyByZWFkeXN0YXRlY2hhbmdlIGV2ZW50IHdpbGwgYmUgZmlyZWQgYXN5bmNocm9ub3VzbHkgb25jZSBpdCBpcyBpbnNlcnRlZFxuICAgICAgICAgICAgLy8gaW50byB0aGUgZG9jdW1lbnQuIERvIHNvLCB0aHVzIHF1ZXVpbmcgdXAgdGhlIHRhc2suIFJlbWVtYmVyIHRvIGNsZWFuIHVwIG9uY2UgaXQncyBiZWVuIGNhbGxlZC5cbiAgICAgICAgICAgIHZhciBzY3JpcHQgPSBkb2MuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtcbiAgICAgICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcnVuSWZQcmVzZW50KGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgaHRtbC5yZW1vdmVDaGlsZChzY3JpcHQpO1xuICAgICAgICAgICAgICAgIHNjcmlwdCA9IG51bGw7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaHRtbC5hcHBlbmRDaGlsZChzY3JpcHQpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxTZXRUaW1lb3V0SW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KHJ1bklmUHJlc2VudCwgMCwgaGFuZGxlKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBJZiBzdXBwb3J0ZWQsIHdlIHNob3VsZCBhdHRhY2ggdG8gdGhlIHByb3RvdHlwZSBvZiBnbG9iYWwsIHNpbmNlIHRoYXQgaXMgd2hlcmUgc2V0VGltZW91dCBldCBhbC4gbGl2ZS5cbiAgICB2YXIgYXR0YWNoVG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKGdsb2JhbCk7XG4gICAgYXR0YWNoVG8gPSBhdHRhY2hUbyAmJiBhdHRhY2hUby5zZXRUaW1lb3V0ID8gYXR0YWNoVG8gOiBnbG9iYWw7XG5cbiAgICAvLyBEb24ndCBnZXQgZm9vbGVkIGJ5IGUuZy4gYnJvd3NlcmlmeSBlbnZpcm9ubWVudHMuXG4gICAgaWYgKHt9LnRvU3RyaW5nLmNhbGwoZ2xvYmFsLnByb2Nlc3MpID09PSBcIltvYmplY3QgcHJvY2Vzc11cIikge1xuICAgICAgICAvLyBGb3IgTm9kZS5qcyBiZWZvcmUgMC45XG4gICAgICAgIGluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGNhblVzZVBvc3RNZXNzYWdlKCkpIHtcbiAgICAgICAgLy8gRm9yIG5vbi1JRTEwIG1vZGVybiBicm93c2Vyc1xuICAgICAgICBpbnN0YWxsUG9zdE1lc3NhZ2VJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChnbG9iYWwuTWVzc2FnZUNoYW5uZWwpIHtcbiAgICAgICAgLy8gRm9yIHdlYiB3b3JrZXJzLCB3aGVyZSBzdXBwb3J0ZWRcbiAgICAgICAgaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoZG9jICYmIFwib25yZWFkeXN0YXRlY2hhbmdlXCIgaW4gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIikpIHtcbiAgICAgICAgLy8gRm9yIElFIDbigJM4XG4gICAgICAgIGluc3RhbGxSZWFkeVN0YXRlQ2hhbmdlSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEZvciBvbGRlciBicm93c2Vyc1xuICAgICAgICBpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uKCk7XG4gICAgfVxuXG4gICAgYXR0YWNoVG8uc2V0SW1tZWRpYXRlID0gc2V0SW1tZWRpYXRlO1xuICAgIGF0dGFjaFRvLmNsZWFySW1tZWRpYXRlID0gY2xlYXJJbW1lZGlhdGU7XG59KHR5cGVvZiBzZWxmID09PSBcInVuZGVmaW5lZFwiID8gdHlwZW9mIGdsb2JhbCA9PT0gXCJ1bmRlZmluZWRcIiA/IHRoaXMgOiBnbG9iYWwgOiBzZWxmKSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9zZXRpbW1lZGlhdGUvc2V0SW1tZWRpYXRlLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9zZXRpbW1lZGlhdGUvc2V0SW1tZWRpYXRlLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiBTU1IgV2luZG93IDEuMC4wXG4gKiBCZXR0ZXIgaGFuZGxpbmcgZm9yIHdpbmRvdyBvYmplY3QgaW4gU1NSIGVudmlyb25tZW50XG4gKiBodHRwczovL2dpdGh1Yi5jb20vbm9saW1pdHM0d2ViL3Nzci13aW5kb3dcbiAqXG4gKiBDb3B5cmlnaHQgMjAxOCwgVmxhZGltaXIgS2hhcmxhbXBpZGlcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciBNSVRcbiAqXG4gKiBSZWxlYXNlZCBvbjogRmVicnVhcnkgMTAsIDIwMThcbiAqL1xudmFyIGQ7XG5pZiAodHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJykge1xuICBkID0ge1xuICAgIGJvZHk6IHt9LFxuICAgIGFkZEV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXIoKSB7fSxcbiAgICByZW1vdmVFdmVudExpc3RlbmVyOiBmdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVyKCkge30sXG4gICAgYWN0aXZlRWxlbWVudDoge1xuICAgICAgYmx1cjogZnVuY3Rpb24gYmx1cigpIHt9LFxuICAgICAgbm9kZU5hbWU6ICcnLFxuICAgIH0sXG4gICAgcXVlcnlTZWxlY3RvcjogZnVuY3Rpb24gcXVlcnlTZWxlY3RvcigpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG4gICAgcXVlcnlTZWxlY3RvckFsbDogZnVuY3Rpb24gcXVlcnlTZWxlY3RvckFsbCgpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9LFxuICAgIGdldEVsZW1lbnRCeUlkOiBmdW5jdGlvbiBnZXRFbGVtZW50QnlJZCgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG4gICAgY3JlYXRlRXZlbnQ6IGZ1bmN0aW9uIGNyZWF0ZUV2ZW50KCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaW5pdEV2ZW50OiBmdW5jdGlvbiBpbml0RXZlbnQoKSB7fSxcbiAgICAgIH07XG4gICAgfSxcbiAgICBjcmVhdGVFbGVtZW50OiBmdW5jdGlvbiBjcmVhdGVFbGVtZW50KCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY2hpbGRyZW46IFtdLFxuICAgICAgICBjaGlsZE5vZGVzOiBbXSxcbiAgICAgICAgc3R5bGU6IHt9LFxuICAgICAgICBzZXRBdHRyaWJ1dGU6IGZ1bmN0aW9uIHNldEF0dHJpYnV0ZSgpIHt9LFxuICAgICAgICBnZXRFbGVtZW50c0J5VGFnTmFtZTogZnVuY3Rpb24gZ2V0RWxlbWVudHNCeVRhZ05hbWUoKSB7XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9LFxuICAgICAgfTtcbiAgICB9LFxuICAgIGxvY2F0aW9uOiB7IGhhc2g6ICcnIH0sXG4gIH07XG59IGVsc2Uge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgZCA9IGRvY3VtZW50O1xufVxuXG52YXIgZG9jID0gZDtcblxudmFyIHc7XG5pZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgdyA9IHtcbiAgICBkb2N1bWVudDogZG9jLFxuICAgIG5hdmlnYXRvcjoge1xuICAgICAgdXNlckFnZW50OiAnJyxcbiAgICB9LFxuICAgIGxvY2F0aW9uOiB7fSxcbiAgICBoaXN0b3J5OiB7fSxcbiAgICBDdXN0b21FdmVudDogZnVuY3Rpb24gQ3VzdG9tRXZlbnQoKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGFkZEV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXIoKSB7fSxcbiAgICByZW1vdmVFdmVudExpc3RlbmVyOiBmdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVyKCkge30sXG4gICAgZ2V0Q29tcHV0ZWRTdHlsZTogZnVuY3Rpb24gZ2V0Q29tcHV0ZWRTdHlsZSgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGdldFByb3BlcnR5VmFsdWU6IGZ1bmN0aW9uIGdldFByb3BlcnR5VmFsdWUoKSB7XG4gICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9LFxuICAgICAgfTtcbiAgICB9LFxuICAgIEltYWdlOiBmdW5jdGlvbiBJbWFnZSgpIHt9LFxuICAgIERhdGU6IGZ1bmN0aW9uIERhdGUoKSB7fSxcbiAgICBzY3JlZW46IHt9LFxuICAgIHNldFRpbWVvdXQ6IGZ1bmN0aW9uIHNldFRpbWVvdXQoKSB7fSxcbiAgICBjbGVhclRpbWVvdXQ6IGZ1bmN0aW9uIGNsZWFyVGltZW91dCgpIHt9LFxuICB9O1xufSBlbHNlIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gIHcgPSB3aW5kb3c7XG59XG5cbnZhciB3aW4gPSB3O1xuXG5leHBvcnQgeyB3aW4gYXMgd2luZG93LCBkb2MgYXMgZG9jdW1lbnQgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3Nzci13aW5kb3cvZGlzdC9zc3Itd2luZG93LmVzbS5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvc3NyLXdpbmRvdy9kaXN0L3Nzci13aW5kb3cuZXNtLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiBUZW1wbGF0ZTcgMS4zLjVcbiAqIE1vYmlsZS1maXJzdCBIVE1MIHRlbXBsYXRlIGVuZ2luZVxuICogXG4gKiBodHRwOi8vd3d3LmlkYW5nZXJvLnVzL3RlbXBsYXRlNy9cbiAqIFxuICogQ29weXJpZ2h0IDIwMTgsIFZsYWRpbWlyIEtoYXJsYW1waWRpXG4gKiBUaGUgaURhbmdlcm8udXNcbiAqIGh0dHA6Ly93d3cuaWRhbmdlcm8udXMvXG4gKiBcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVFxuICogXG4gKiBSZWxlYXNlZCBvbjogSmFudWFyeSAyMiwgMjAxOFxuICovXG5sZXQgdDdjdHg7XG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgdDdjdHggPSB3aW5kb3c7XG59IGVsc2UgaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7XG4gIHQ3Y3R4ID0gZ2xvYmFsO1xufSBlbHNlIHtcbiAgdDdjdHggPSB1bmRlZmluZWQ7XG59XG5cbmNvbnN0IFRlbXBsYXRlN0NvbnRleHQgPSB0N2N0eDtcblxuY29uc3QgVGVtcGxhdGU3VXRpbHMgPSB7XG4gIHF1b3RlU2luZ2xlUmV4RXhwOiBuZXcgUmVnRXhwKCdcXCcnLCAnZycpLFxuICBxdW90ZURvdWJsZVJleEV4cDogbmV3IFJlZ0V4cCgnXCInLCAnZycpLFxuICBpc0Z1bmN0aW9uKGZ1bmMpIHtcbiAgICByZXR1cm4gdHlwZW9mIGZ1bmMgPT09ICdmdW5jdGlvbic7XG4gIH0sXG4gIGVzY2FwZShzdHJpbmcpIHtcbiAgICByZXR1cm4gKHR5cGVvZiBUZW1wbGF0ZTdDb250ZXh0ICE9PSAndW5kZWZpbmVkJyAmJiBUZW1wbGF0ZTdDb250ZXh0LmVzY2FwZSkgP1xuICAgICAgVGVtcGxhdGU3Q29udGV4dC5lc2NhcGUoc3RyaW5nKSA6XG4gICAgICBzdHJpbmdcbiAgICAgICAgLnJlcGxhY2UoLyYvZywgJyZhbXA7JylcbiAgICAgICAgLnJlcGxhY2UoLzwvZywgJyZsdDsnKVxuICAgICAgICAucmVwbGFjZSgvPi9nLCAnJmd0OycpXG4gICAgICAgIC5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7Jyk7XG4gIH0sXG4gIGhlbHBlclRvU2xpY2VzKHN0cmluZykge1xuICAgIGNvbnN0IHsgcXVvdGVEb3VibGVSZXhFeHAsIHF1b3RlU2luZ2xlUmV4RXhwIH0gPSBUZW1wbGF0ZTdVdGlscztcbiAgICBjb25zdCBoZWxwZXJQYXJ0cyA9IHN0cmluZy5yZXBsYWNlKC9be30jfV0vZywgJycpLnRyaW0oKS5zcGxpdCgnICcpO1xuICAgIGNvbnN0IHNsaWNlcyA9IFtdO1xuICAgIGxldCBzaGlmdEluZGV4O1xuICAgIGxldCBpO1xuICAgIGxldCBqO1xuICAgIGZvciAoaSA9IDA7IGkgPCBoZWxwZXJQYXJ0cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgbGV0IHBhcnQgPSBoZWxwZXJQYXJ0c1tpXTtcbiAgICAgIGxldCBibG9ja1F1b3RlUmVnRXhwO1xuICAgICAgbGV0IG9wZW5pbmdRdW90ZTtcbiAgICAgIGlmIChpID09PSAwKSBzbGljZXMucHVzaChwYXJ0KTtcbiAgICAgIGVsc2UgaWYgKHBhcnQuaW5kZXhPZignXCInKSA9PT0gMCB8fCBwYXJ0LmluZGV4T2YoJ1xcJycpID09PSAwKSB7XG4gICAgICAgIGJsb2NrUXVvdGVSZWdFeHAgPSBwYXJ0LmluZGV4T2YoJ1wiJykgPT09IDAgPyBxdW90ZURvdWJsZVJleEV4cCA6IHF1b3RlU2luZ2xlUmV4RXhwO1xuICAgICAgICBvcGVuaW5nUXVvdGUgPSBwYXJ0LmluZGV4T2YoJ1wiJykgPT09IDAgPyAnXCInIDogJ1xcJyc7XG4gICAgICAgIC8vIFBsYWluIFN0cmluZ1xuICAgICAgICBpZiAocGFydC5tYXRjaChibG9ja1F1b3RlUmVnRXhwKS5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAvLyBPbmUgd29yZCBzdHJpbmdcbiAgICAgICAgICBzbGljZXMucHVzaChwYXJ0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBGaW5kIGNsb3NlZCBJbmRleFxuICAgICAgICAgIHNoaWZ0SW5kZXggPSAwO1xuICAgICAgICAgIGZvciAoaiA9IGkgKyAxOyBqIDwgaGVscGVyUGFydHMubGVuZ3RoOyBqICs9IDEpIHtcbiAgICAgICAgICAgIHBhcnQgKz0gYCAke2hlbHBlclBhcnRzW2pdfWA7XG4gICAgICAgICAgICBpZiAoaGVscGVyUGFydHNbal0uaW5kZXhPZihvcGVuaW5nUXVvdGUpID49IDApIHtcbiAgICAgICAgICAgICAgc2hpZnRJbmRleCA9IGo7XG4gICAgICAgICAgICAgIHNsaWNlcy5wdXNoKHBhcnQpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNoaWZ0SW5kZXgpIGkgPSBzaGlmdEluZGV4O1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHBhcnQuaW5kZXhPZignPScpID4gMCkge1xuICAgICAgICAvLyBIYXNoXG4gICAgICAgIGNvbnN0IGhhc2hQYXJ0cyA9IHBhcnQuc3BsaXQoJz0nKTtcbiAgICAgICAgY29uc3QgaGFzaE5hbWUgPSBoYXNoUGFydHNbMF07XG4gICAgICAgIGxldCBoYXNoQ29udGVudCA9IGhhc2hQYXJ0c1sxXTtcbiAgICAgICAgaWYgKCFibG9ja1F1b3RlUmVnRXhwKSB7XG4gICAgICAgICAgYmxvY2tRdW90ZVJlZ0V4cCA9IGhhc2hDb250ZW50LmluZGV4T2YoJ1wiJykgPT09IDAgPyBxdW90ZURvdWJsZVJleEV4cCA6IHF1b3RlU2luZ2xlUmV4RXhwO1xuICAgICAgICAgIG9wZW5pbmdRdW90ZSA9IGhhc2hDb250ZW50LmluZGV4T2YoJ1wiJykgPT09IDAgPyAnXCInIDogJ1xcJyc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc2hDb250ZW50Lm1hdGNoKGJsb2NrUXVvdGVSZWdFeHApLmxlbmd0aCAhPT0gMikge1xuICAgICAgICAgIHNoaWZ0SW5kZXggPSAwO1xuICAgICAgICAgIGZvciAoaiA9IGkgKyAxOyBqIDwgaGVscGVyUGFydHMubGVuZ3RoOyBqICs9IDEpIHtcbiAgICAgICAgICAgIGhhc2hDb250ZW50ICs9IGAgJHtoZWxwZXJQYXJ0c1tqXX1gO1xuICAgICAgICAgICAgaWYgKGhlbHBlclBhcnRzW2pdLmluZGV4T2Yob3BlbmluZ1F1b3RlKSA+PSAwKSB7XG4gICAgICAgICAgICAgIHNoaWZ0SW5kZXggPSBqO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNoaWZ0SW5kZXgpIGkgPSBzaGlmdEluZGV4O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhhc2ggPSBbaGFzaE5hbWUsIGhhc2hDb250ZW50LnJlcGxhY2UoYmxvY2tRdW90ZVJlZ0V4cCwgJycpXTtcbiAgICAgICAgc2xpY2VzLnB1c2goaGFzaCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBQbGFpbiB2YXJpYWJsZVxuICAgICAgICBzbGljZXMucHVzaChwYXJ0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNsaWNlcztcbiAgfSxcbiAgc3RyaW5nVG9CbG9ja3Moc3RyaW5nKSB7XG4gICAgY29uc3QgYmxvY2tzID0gW107XG4gICAgbGV0IGk7XG4gICAgbGV0IGo7XG4gICAgaWYgKCFzdHJpbmcpIHJldHVybiBbXTtcbiAgICBjb25zdCBzdHJpbmdCbG9ja3MgPSBzdHJpbmcuc3BsaXQoLyh7e1tee159XSp9fSkvKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgc3RyaW5nQmxvY2tzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBsZXQgYmxvY2sgPSBzdHJpbmdCbG9ja3NbaV07XG4gICAgICBpZiAoYmxvY2sgPT09ICcnKSBjb250aW51ZTtcbiAgICAgIGlmIChibG9jay5pbmRleE9mKCd7eycpIDwgMCkge1xuICAgICAgICBibG9ja3MucHVzaCh7XG4gICAgICAgICAgdHlwZTogJ3BsYWluJyxcbiAgICAgICAgICBjb250ZW50OiBibG9jayxcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoYmxvY2suaW5kZXhPZigney8nKSA+PSAwKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgYmxvY2sgPSBibG9ja1xuICAgICAgICAgIC5yZXBsYWNlKC97eyhbIy9dKSooWyBdKSovLCAne3skMScpXG4gICAgICAgICAgLnJlcGxhY2UoLyhbIF0pKn19LywgJ319Jyk7XG4gICAgICAgIGlmIChibG9jay5pbmRleE9mKCd7IycpIDwgMCAmJiBibG9jay5pbmRleE9mKCcgJykgPCAwICYmIGJsb2NrLmluZGV4T2YoJ2Vsc2UnKSA8IDApIHtcbiAgICAgICAgICAvLyBTaW1wbGUgdmFyaWFibGVcbiAgICAgICAgICBibG9ja3MucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAndmFyaWFibGUnLFxuICAgICAgICAgICAgY29udGV4dE5hbWU6IGJsb2NrLnJlcGxhY2UoL1t7fV0vZywgJycpLFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIEhlbHBlcnNcbiAgICAgICAgY29uc3QgaGVscGVyU2xpY2VzID0gVGVtcGxhdGU3VXRpbHMuaGVscGVyVG9TbGljZXMoYmxvY2spO1xuICAgICAgICBsZXQgaGVscGVyTmFtZSA9IGhlbHBlclNsaWNlc1swXTtcbiAgICAgICAgY29uc3QgaXNQYXJ0aWFsID0gaGVscGVyTmFtZSA9PT0gJz4nO1xuICAgICAgICBjb25zdCBoZWxwZXJDb250ZXh0ID0gW107XG4gICAgICAgIGNvbnN0IGhlbHBlckhhc2ggPSB7fTtcbiAgICAgICAgZm9yIChqID0gMTsgaiA8IGhlbHBlclNsaWNlcy5sZW5ndGg7IGogKz0gMSkge1xuICAgICAgICAgIGNvbnN0IHNsaWNlID0gaGVscGVyU2xpY2VzW2pdO1xuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNsaWNlKSkge1xuICAgICAgICAgICAgLy8gSGFzaFxuICAgICAgICAgICAgaGVscGVySGFzaFtzbGljZVswXV0gPSBzbGljZVsxXSA9PT0gJ2ZhbHNlJyA/IGZhbHNlIDogc2xpY2VbMV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhlbHBlckNvbnRleHQucHVzaChzbGljZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGJsb2NrLmluZGV4T2YoJ3sjJykgPj0gMCkge1xuICAgICAgICAgIC8vIENvbmRpdGlvbi9IZWxwZXJcbiAgICAgICAgICBsZXQgaGVscGVyQ29udGVudCA9ICcnO1xuICAgICAgICAgIGxldCBlbHNlQ29udGVudCA9ICcnO1xuICAgICAgICAgIGxldCB0b1NraXAgPSAwO1xuICAgICAgICAgIGxldCBzaGlmdEluZGV4O1xuICAgICAgICAgIGxldCBmb3VuZENsb3NlZCA9IGZhbHNlO1xuICAgICAgICAgIGxldCBmb3VuZEVsc2UgPSBmYWxzZTtcbiAgICAgICAgICBsZXQgZGVwdGggPSAwO1xuICAgICAgICAgIGZvciAoaiA9IGkgKyAxOyBqIDwgc3RyaW5nQmxvY2tzLmxlbmd0aDsgaiArPSAxKSB7XG4gICAgICAgICAgICBpZiAoc3RyaW5nQmxvY2tzW2pdLmluZGV4T2YoJ3t7IycpID49IDApIHtcbiAgICAgICAgICAgICAgZGVwdGggKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdHJpbmdCbG9ja3Nbal0uaW5kZXhPZigne3svJykgPj0gMCkge1xuICAgICAgICAgICAgICBkZXB0aCAtPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0cmluZ0Jsb2Nrc1tqXS5pbmRleE9mKGB7eyMke2hlbHBlck5hbWV9YCkgPj0gMCkge1xuICAgICAgICAgICAgICBoZWxwZXJDb250ZW50ICs9IHN0cmluZ0Jsb2Nrc1tqXTtcbiAgICAgICAgICAgICAgaWYgKGZvdW5kRWxzZSkgZWxzZUNvbnRlbnQgKz0gc3RyaW5nQmxvY2tzW2pdO1xuICAgICAgICAgICAgICB0b1NraXAgKz0gMTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RyaW5nQmxvY2tzW2pdLmluZGV4T2YoYHt7LyR7aGVscGVyTmFtZX1gKSA+PSAwKSB7XG4gICAgICAgICAgICAgIGlmICh0b1NraXAgPiAwKSB7XG4gICAgICAgICAgICAgICAgdG9Ta2lwIC09IDE7XG4gICAgICAgICAgICAgICAgaGVscGVyQ29udGVudCArPSBzdHJpbmdCbG9ja3Nbal07XG4gICAgICAgICAgICAgICAgaWYgKGZvdW5kRWxzZSkgZWxzZUNvbnRlbnQgKz0gc3RyaW5nQmxvY2tzW2pdO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNoaWZ0SW5kZXggPSBqO1xuICAgICAgICAgICAgICAgIGZvdW5kQ2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChzdHJpbmdCbG9ja3Nbal0uaW5kZXhPZignZWxzZScpID49IDAgJiYgZGVwdGggPT09IDApIHtcbiAgICAgICAgICAgICAgZm91bmRFbHNlID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmICghZm91bmRFbHNlKSBoZWxwZXJDb250ZW50ICs9IHN0cmluZ0Jsb2Nrc1tqXTtcbiAgICAgICAgICAgICAgaWYgKGZvdW5kRWxzZSkgZWxzZUNvbnRlbnQgKz0gc3RyaW5nQmxvY2tzW2pdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZm91bmRDbG9zZWQpIHtcbiAgICAgICAgICAgIGlmIChzaGlmdEluZGV4KSBpID0gc2hpZnRJbmRleDtcbiAgICAgICAgICAgIGlmIChoZWxwZXJOYW1lID09PSAncmF3Jykge1xuICAgICAgICAgICAgICBibG9ja3MucHVzaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3BsYWluJyxcbiAgICAgICAgICAgICAgICBjb250ZW50OiBoZWxwZXJDb250ZW50LFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGJsb2Nrcy5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnaGVscGVyJyxcbiAgICAgICAgICAgICAgICBoZWxwZXJOYW1lLFxuICAgICAgICAgICAgICAgIGNvbnRleHROYW1lOiBoZWxwZXJDb250ZXh0LFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGhlbHBlckNvbnRlbnQsXG4gICAgICAgICAgICAgICAgaW52ZXJzZUNvbnRlbnQ6IGVsc2VDb250ZW50LFxuICAgICAgICAgICAgICAgIGhhc2g6IGhlbHBlckhhc2gsXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChibG9jay5pbmRleE9mKCcgJykgPiAwKSB7XG4gICAgICAgICAgaWYgKGlzUGFydGlhbCkge1xuICAgICAgICAgICAgaGVscGVyTmFtZSA9ICdfcGFydGlhbCc7XG4gICAgICAgICAgICBpZiAoaGVscGVyQ29udGV4dFswXSkge1xuICAgICAgICAgICAgICBpZiAoaGVscGVyQ29udGV4dFswXS5pbmRleE9mKCdbJykgPT09IDApIGhlbHBlckNvbnRleHRbMF0gPSBoZWxwZXJDb250ZXh0WzBdLnJlcGxhY2UoL1tbXFxdXS9nLCAnJyk7XG4gICAgICAgICAgICAgIGVsc2UgaGVscGVyQ29udGV4dFswXSA9IGBcIiR7aGVscGVyQ29udGV4dFswXS5yZXBsYWNlKC9cInwnL2csICcnKX1cImA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJsb2Nrcy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdoZWxwZXInLFxuICAgICAgICAgICAgaGVscGVyTmFtZSxcbiAgICAgICAgICAgIGNvbnRleHROYW1lOiBoZWxwZXJDb250ZXh0LFxuICAgICAgICAgICAgaGFzaDogaGVscGVySGFzaCxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYmxvY2tzO1xuICB9LFxuICBwYXJzZUpzVmFyaWFibGUoZXhwcmVzc2lvbiwgcmVwbGFjZSwgb2JqZWN0KSB7XG4gICAgcmV0dXJuIGV4cHJlc3Npb24uc3BsaXQoLyhbKyAtKi9eXSkvZykubWFwKChwYXJ0KSA9PiB7XG4gICAgICBpZiAocGFydC5pbmRleE9mKHJlcGxhY2UpIDwgMCkgcmV0dXJuIHBhcnQ7XG4gICAgICBpZiAoIW9iamVjdCkgcmV0dXJuIEpTT04uc3RyaW5naWZ5KCcnKTtcbiAgICAgIGxldCB2YXJpYWJsZSA9IG9iamVjdDtcbiAgICAgIGlmIChwYXJ0LmluZGV4T2YoYCR7cmVwbGFjZX0uYCkgPj0gMCkge1xuICAgICAgICBwYXJ0LnNwbGl0KGAke3JlcGxhY2V9LmApWzFdLnNwbGl0KCcuJykuZm9yRWFjaCgocGFydE5hbWUpID0+IHtcbiAgICAgICAgICBpZiAodmFyaWFibGVbcGFydE5hbWVdKSB2YXJpYWJsZSA9IHZhcmlhYmxlW3BhcnROYW1lXTtcbiAgICAgICAgICBlbHNlIHZhcmlhYmxlID0gJ3VuZGVmaW5lZCc7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhcmlhYmxlKTtcbiAgICB9KS5qb2luKCcnKTtcbiAgfSxcbiAgcGFyc2VKc1BhcmVudHMoZXhwcmVzc2lvbiwgcGFyZW50cykge1xuICAgIHJldHVybiBleHByZXNzaW9uLnNwbGl0KC8oWysgLSpeXSkvZykubWFwKChwYXJ0KSA9PiB7XG4gICAgICBpZiAocGFydC5pbmRleE9mKCcuLi8nKSA8IDApIHJldHVybiBwYXJ0O1xuICAgICAgaWYgKCFwYXJlbnRzIHx8IHBhcmVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gSlNPTi5zdHJpbmdpZnkoJycpO1xuICAgICAgY29uc3QgbGV2ZWxzVXAgPSBwYXJ0LnNwbGl0KCcuLi8nKS5sZW5ndGggLSAxO1xuICAgICAgY29uc3QgcGFyZW50RGF0YSA9IGxldmVsc1VwID4gcGFyZW50cy5sZW5ndGggPyBwYXJlbnRzW3BhcmVudHMubGVuZ3RoIC0gMV0gOiBwYXJlbnRzW2xldmVsc1VwIC0gMV07XG5cbiAgICAgIGxldCB2YXJpYWJsZSA9IHBhcmVudERhdGE7XG4gICAgICBjb25zdCBwYXJlbnRQYXJ0ID0gcGFydC5yZXBsYWNlKC8uLlxcLy9nLCAnJyk7XG4gICAgICBwYXJlbnRQYXJ0LnNwbGl0KCcuJykuZm9yRWFjaCgocGFydE5hbWUpID0+IHtcbiAgICAgICAgaWYgKHZhcmlhYmxlW3BhcnROYW1lXSkgdmFyaWFibGUgPSB2YXJpYWJsZVtwYXJ0TmFtZV07XG4gICAgICAgIGVsc2UgdmFyaWFibGUgPSAndW5kZWZpbmVkJztcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhcmlhYmxlKTtcbiAgICB9KS5qb2luKCcnKTtcbiAgfSxcbiAgZ2V0Q29tcGlsZVZhcihuYW1lLCBjdHgsIGRhdGEgPSAnZGF0YV8xJykge1xuICAgIGxldCB2YXJpYWJsZSA9IGN0eDtcbiAgICBsZXQgcGFydHM7XG4gICAgbGV0IGxldmVsc1VwID0gMDtcbiAgICBsZXQgbmV3RGVwdGg7XG4gICAgaWYgKG5hbWUuaW5kZXhPZignLi4vJykgPT09IDApIHtcbiAgICAgIGxldmVsc1VwID0gbmFtZS5zcGxpdCgnLi4vJykubGVuZ3RoIC0gMTtcbiAgICAgIG5ld0RlcHRoID0gdmFyaWFibGUuc3BsaXQoJ18nKVsxXSAtIGxldmVsc1VwO1xuICAgICAgdmFyaWFibGUgPSBgY3R4XyR7bmV3RGVwdGggPj0gMSA/IG5ld0RlcHRoIDogMX1gO1xuICAgICAgcGFydHMgPSBuYW1lLnNwbGl0KCcuLi8nKVtsZXZlbHNVcF0uc3BsaXQoJy4nKTtcbiAgICB9IGVsc2UgaWYgKG5hbWUuaW5kZXhPZignQGdsb2JhbCcpID09PSAwKSB7XG4gICAgICB2YXJpYWJsZSA9ICdUZW1wbGF0ZTcuZ2xvYmFsJztcbiAgICAgIHBhcnRzID0gbmFtZS5zcGxpdCgnQGdsb2JhbC4nKVsxXS5zcGxpdCgnLicpO1xuICAgIH0gZWxzZSBpZiAobmFtZS5pbmRleE9mKCdAcm9vdCcpID09PSAwKSB7XG4gICAgICB2YXJpYWJsZSA9ICdyb290JztcbiAgICAgIHBhcnRzID0gbmFtZS5zcGxpdCgnQHJvb3QuJylbMV0uc3BsaXQoJy4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFydHMgPSBuYW1lLnNwbGl0KCcuJyk7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGNvbnN0IHBhcnQgPSBwYXJ0c1tpXTtcbiAgICAgIGlmIChwYXJ0LmluZGV4T2YoJ0AnKSA9PT0gMCkge1xuICAgICAgICBsZXQgZGF0YUxldmVsID0gZGF0YS5zcGxpdCgnXycpWzFdO1xuICAgICAgICBpZiAobGV2ZWxzVXAgPiAwKSB7XG4gICAgICAgICAgZGF0YUxldmVsID0gbmV3RGVwdGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgdmFyaWFibGUgKz0gYFsoZGF0YV8ke2RhdGFMZXZlbH0gJiYgZGF0YV8ke2RhdGFMZXZlbH0uJHtwYXJ0LnJlcGxhY2UoJ0AnLCAnJyl9KV1gO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhcmlhYmxlID0gYChkYXRhXyR7ZGF0YUxldmVsfSAmJiBkYXRhXyR7ZGF0YUxldmVsfS4ke3BhcnQucmVwbGFjZSgnQCcsICcnKX0pYDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChOdW1iZXIuaXNGaW5pdGUgPyBOdW1iZXIuaXNGaW5pdGUocGFydCkgOiBUZW1wbGF0ZTdDb250ZXh0LmlzRmluaXRlKHBhcnQpKSB7XG4gICAgICAgIHZhcmlhYmxlICs9IGBbJHtwYXJ0fV1gO1xuICAgICAgfSBlbHNlIGlmIChwYXJ0ID09PSAndGhpcycgfHwgcGFydC5pbmRleE9mKCd0aGlzLicpID49IDAgfHwgcGFydC5pbmRleE9mKCd0aGlzWycpID49IDAgfHwgcGFydC5pbmRleE9mKCd0aGlzKCcpID49IDApIHtcbiAgICAgICAgdmFyaWFibGUgPSBwYXJ0LnJlcGxhY2UoJ3RoaXMnLCBjdHgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyaWFibGUgKz0gYC4ke3BhcnR9YDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZhcmlhYmxlO1xuICB9LFxuICBnZXRDb21waWxlZEFyZ3VtZW50cyhjb250ZXh0QXJyYXksIGN0eCwgZGF0YSkge1xuICAgIGNvbnN0IGFyciA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29udGV4dEFycmF5Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBpZiAoL15bJ1wiXS8udGVzdChjb250ZXh0QXJyYXlbaV0pKSBhcnIucHVzaChjb250ZXh0QXJyYXlbaV0pO1xuICAgICAgZWxzZSBpZiAoL14odHJ1ZXxmYWxzZXxcXGQrKSQvLnRlc3QoY29udGV4dEFycmF5W2ldKSkgYXJyLnB1c2goY29udGV4dEFycmF5W2ldKTtcbiAgICAgIGVsc2Uge1xuICAgICAgICBhcnIucHVzaChUZW1wbGF0ZTdVdGlscy5nZXRDb21waWxlVmFyKGNvbnRleHRBcnJheVtpXSwgY3R4LCBkYXRhKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGFyci5qb2luKCcsICcpO1xuICB9LFxufTtcblxuLyogZXNsaW50IG5vLWV2YWw6IFwib2ZmXCIgKi9cbmNvbnN0IFRlbXBsYXRlN0hlbHBlcnMgPSB7XG4gIF9wYXJ0aWFsKHBhcnRpYWxOYW1lLCBvcHRpb25zKSB7XG4gICAgY29uc3QgY3R4ID0gdGhpcztcbiAgICBjb25zdCBwID0gVGVtcGxhdGU3Q2xhc3MucGFydGlhbHNbcGFydGlhbE5hbWVdO1xuICAgIGlmICghcCB8fCAocCAmJiAhcC50ZW1wbGF0ZSkpIHJldHVybiAnJztcbiAgICBpZiAoIXAuY29tcGlsZWQpIHtcbiAgICAgIHAuY29tcGlsZWQgPSBuZXcgVGVtcGxhdGU3Q2xhc3MocC50ZW1wbGF0ZSkuY29tcGlsZSgpO1xuICAgIH1cbiAgICBPYmplY3Qua2V5cyhvcHRpb25zLmhhc2gpLmZvckVhY2goKGhhc2hOYW1lKSA9PiB7XG4gICAgICBjdHhbaGFzaE5hbWVdID0gb3B0aW9ucy5oYXNoW2hhc2hOYW1lXTtcbiAgICB9KTtcbiAgICByZXR1cm4gcC5jb21waWxlZChjdHgsIG9wdGlvbnMuZGF0YSwgb3B0aW9ucy5yb290KTtcbiAgfSxcbiAgZXNjYXBlKGNvbnRleHQpIHtcbiAgICBpZiAodHlwZW9mIGNvbnRleHQgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RlbXBsYXRlNzogUGFzc2VkIGNvbnRleHQgdG8gXCJlc2NhcGVcIiBoZWxwZXIgc2hvdWxkIGJlIGEgc3RyaW5nJyk7XG4gICAgfVxuICAgIHJldHVybiBUZW1wbGF0ZTdVdGlscy5lc2NhcGUoY29udGV4dCk7XG4gIH0sXG4gIGlmKGNvbnRleHQsIG9wdGlvbnMpIHtcbiAgICBsZXQgY3R4ID0gY29udGV4dDtcbiAgICBpZiAoVGVtcGxhdGU3VXRpbHMuaXNGdW5jdGlvbihjdHgpKSB7IGN0eCA9IGN0eC5jYWxsKHRoaXMpOyB9XG4gICAgaWYgKGN0eCkge1xuICAgICAgcmV0dXJuIG9wdGlvbnMuZm4odGhpcywgb3B0aW9ucy5kYXRhKTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3B0aW9ucy5pbnZlcnNlKHRoaXMsIG9wdGlvbnMuZGF0YSk7XG4gIH0sXG4gIHVubGVzcyhjb250ZXh0LCBvcHRpb25zKSB7XG4gICAgbGV0IGN0eCA9IGNvbnRleHQ7XG4gICAgaWYgKFRlbXBsYXRlN1V0aWxzLmlzRnVuY3Rpb24oY3R4KSkgeyBjdHggPSBjdHguY2FsbCh0aGlzKTsgfVxuICAgIGlmICghY3R4KSB7XG4gICAgICByZXR1cm4gb3B0aW9ucy5mbih0aGlzLCBvcHRpb25zLmRhdGEpO1xuICAgIH1cblxuICAgIHJldHVybiBvcHRpb25zLmludmVyc2UodGhpcywgb3B0aW9ucy5kYXRhKTtcbiAgfSxcbiAgZWFjaChjb250ZXh0LCBvcHRpb25zKSB7XG4gICAgbGV0IGN0eCA9IGNvbnRleHQ7XG4gICAgbGV0IHJldCA9ICcnO1xuICAgIGxldCBpID0gMDtcbiAgICBpZiAoVGVtcGxhdGU3VXRpbHMuaXNGdW5jdGlvbihjdHgpKSB7IGN0eCA9IGN0eC5jYWxsKHRoaXMpOyB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY3R4KSkge1xuICAgICAgaWYgKG9wdGlvbnMuaGFzaC5yZXZlcnNlKSB7XG4gICAgICAgIGN0eCA9IGN0eC5yZXZlcnNlKCk7XG4gICAgICB9XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgY3R4Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHJldCArPSBvcHRpb25zLmZuKGN0eFtpXSwgeyBmaXJzdDogaSA9PT0gMCwgbGFzdDogaSA9PT0gY3R4Lmxlbmd0aCAtIDEsIGluZGV4OiBpIH0pO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMuaGFzaC5yZXZlcnNlKSB7XG4gICAgICAgIGN0eCA9IGN0eC5yZXZlcnNlKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgZm9yIChjb25zdCBrZXkgaW4gY3R4KSB7XG4gICAgICAgIGkgKz0gMTtcbiAgICAgICAgcmV0ICs9IG9wdGlvbnMuZm4oY3R4W2tleV0sIHsga2V5IH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaSA+IDApIHJldHVybiByZXQ7XG4gICAgcmV0dXJuIG9wdGlvbnMuaW52ZXJzZSh0aGlzKTtcbiAgfSxcbiAgd2l0aChjb250ZXh0LCBvcHRpb25zKSB7XG4gICAgbGV0IGN0eCA9IGNvbnRleHQ7XG4gICAgaWYgKFRlbXBsYXRlN1V0aWxzLmlzRnVuY3Rpb24oY3R4KSkgeyBjdHggPSBjb250ZXh0LmNhbGwodGhpcyk7IH1cbiAgICByZXR1cm4gb3B0aW9ucy5mbihjdHgpO1xuICB9LFxuICBqb2luKGNvbnRleHQsIG9wdGlvbnMpIHtcbiAgICBsZXQgY3R4ID0gY29udGV4dDtcbiAgICBpZiAoVGVtcGxhdGU3VXRpbHMuaXNGdW5jdGlvbihjdHgpKSB7IGN0eCA9IGN0eC5jYWxsKHRoaXMpOyB9XG4gICAgcmV0dXJuIGN0eC5qb2luKG9wdGlvbnMuaGFzaC5kZWxpbWl0ZXIgfHwgb3B0aW9ucy5oYXNoLmRlbGltZXRlcik7XG4gIH0sXG4gIGpzKGV4cHJlc3Npb24sIG9wdGlvbnMpIHtcbiAgICBjb25zdCBkYXRhID0gb3B0aW9ucy5kYXRhO1xuICAgIGxldCBmdW5jO1xuICAgIGxldCBleGVjdXRlID0gZXhwcmVzc2lvbjtcbiAgICAoJ2luZGV4IGZpcnN0IGxhc3Qga2V5Jykuc3BsaXQoJyAnKS5mb3JFYWNoKChwcm9wKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIGRhdGFbcHJvcF0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbnN0IHJlMSA9IG5ldyBSZWdFeHAoYHRoaXMuQCR7cHJvcH1gLCAnZycpO1xuICAgICAgICBjb25zdCByZTIgPSBuZXcgUmVnRXhwKGBAJHtwcm9wfWAsICdnJyk7XG4gICAgICAgIGV4ZWN1dGUgPSBleGVjdXRlXG4gICAgICAgICAgLnJlcGxhY2UocmUxLCBKU09OLnN0cmluZ2lmeShkYXRhW3Byb3BdKSlcbiAgICAgICAgICAucmVwbGFjZShyZTIsIEpTT04uc3RyaW5naWZ5KGRhdGFbcHJvcF0pKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAob3B0aW9ucy5yb290ICYmIGV4ZWN1dGUuaW5kZXhPZignQHJvb3QnKSA+PSAwKSB7XG4gICAgICBleGVjdXRlID0gVGVtcGxhdGU3VXRpbHMucGFyc2VKc1ZhcmlhYmxlKGV4ZWN1dGUsICdAcm9vdCcsIG9wdGlvbnMucm9vdCk7XG4gICAgfVxuICAgIGlmIChleGVjdXRlLmluZGV4T2YoJ0BnbG9iYWwnKSA+PSAwKSB7XG4gICAgICBleGVjdXRlID0gVGVtcGxhdGU3VXRpbHMucGFyc2VKc1ZhcmlhYmxlKGV4ZWN1dGUsICdAZ2xvYmFsJywgVGVtcGxhdGU3Q29udGV4dC5UZW1wbGF0ZTcuZ2xvYmFsKTtcbiAgICB9XG4gICAgaWYgKGV4ZWN1dGUuaW5kZXhPZignLi4vJykgPj0gMCkge1xuICAgICAgZXhlY3V0ZSA9IFRlbXBsYXRlN1V0aWxzLnBhcnNlSnNQYXJlbnRzKGV4ZWN1dGUsIG9wdGlvbnMucGFyZW50cyk7XG4gICAgfVxuICAgIGlmIChleGVjdXRlLmluZGV4T2YoJ3JldHVybicpID49IDApIHtcbiAgICAgIGZ1bmMgPSBgKGZ1bmN0aW9uKCl7JHtleGVjdXRlfX0pYDtcbiAgICB9IGVsc2Uge1xuICAgICAgZnVuYyA9IGAoZnVuY3Rpb24oKXtyZXR1cm4gKCR7ZXhlY3V0ZX0pfSlgO1xuICAgIH1cbiAgICByZXR1cm4gZXZhbChmdW5jKS5jYWxsKHRoaXMpO1xuICB9LFxuICBqc19pZihleHByZXNzaW9uLCBvcHRpb25zKSB7XG4gICAgY29uc3QgZGF0YSA9IG9wdGlvbnMuZGF0YTtcbiAgICBsZXQgZnVuYztcbiAgICBsZXQgZXhlY3V0ZSA9IGV4cHJlc3Npb247XG4gICAgKCdpbmRleCBmaXJzdCBsYXN0IGtleScpLnNwbGl0KCcgJykuZm9yRWFjaCgocHJvcCkgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBkYXRhW3Byb3BdICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb25zdCByZTEgPSBuZXcgUmVnRXhwKGB0aGlzLkAke3Byb3B9YCwgJ2cnKTtcbiAgICAgICAgY29uc3QgcmUyID0gbmV3IFJlZ0V4cChgQCR7cHJvcH1gLCAnZycpO1xuICAgICAgICBleGVjdXRlID0gZXhlY3V0ZVxuICAgICAgICAgIC5yZXBsYWNlKHJlMSwgSlNPTi5zdHJpbmdpZnkoZGF0YVtwcm9wXSkpXG4gICAgICAgICAgLnJlcGxhY2UocmUyLCBKU09OLnN0cmluZ2lmeShkYXRhW3Byb3BdKSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKG9wdGlvbnMucm9vdCAmJiBleGVjdXRlLmluZGV4T2YoJ0Byb290JykgPj0gMCkge1xuICAgICAgZXhlY3V0ZSA9IFRlbXBsYXRlN1V0aWxzLnBhcnNlSnNWYXJpYWJsZShleGVjdXRlLCAnQHJvb3QnLCBvcHRpb25zLnJvb3QpO1xuICAgIH1cbiAgICBpZiAoZXhlY3V0ZS5pbmRleE9mKCdAZ2xvYmFsJykgPj0gMCkge1xuICAgICAgZXhlY3V0ZSA9IFRlbXBsYXRlN1V0aWxzLnBhcnNlSnNWYXJpYWJsZShleGVjdXRlLCAnQGdsb2JhbCcsIFRlbXBsYXRlN0NsYXNzLmdsb2JhbCk7XG4gICAgfVxuICAgIGlmIChleGVjdXRlLmluZGV4T2YoJy4uLycpID49IDApIHtcbiAgICAgIGV4ZWN1dGUgPSBUZW1wbGF0ZTdVdGlscy5wYXJzZUpzUGFyZW50cyhleGVjdXRlLCBvcHRpb25zLnBhcmVudHMpO1xuICAgIH1cbiAgICBpZiAoZXhlY3V0ZS5pbmRleE9mKCdyZXR1cm4nKSA+PSAwKSB7XG4gICAgICBmdW5jID0gYChmdW5jdGlvbigpeyR7ZXhlY3V0ZX19KWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZ1bmMgPSBgKGZ1bmN0aW9uKCl7cmV0dXJuICgke2V4ZWN1dGV9KX0pYDtcbiAgICB9XG4gICAgY29uc3QgY29uZGl0aW9uID0gZXZhbChmdW5jKS5jYWxsKHRoaXMpO1xuICAgIGlmIChjb25kaXRpb24pIHtcbiAgICAgIHJldHVybiBvcHRpb25zLmZuKHRoaXMsIG9wdGlvbnMuZGF0YSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9wdGlvbnMuaW52ZXJzZSh0aGlzLCBvcHRpb25zLmRhdGEpO1xuICB9LFxufTtcblRlbXBsYXRlN0hlbHBlcnMuanNfY29tcGFyZSA9IFRlbXBsYXRlN0hlbHBlcnMuanNfaWY7XG5cbmNvbnN0IFRlbXBsYXRlN09wdGlvbnMgPSB7fTtcbmNvbnN0IFRlbXBsYXRlN1BhcnRpYWxzID0ge307XG5jb25zdCBzY3JpcHQgPSBUZW1wbGF0ZTdDb250ZXh0LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuVGVtcGxhdGU3Q29udGV4dC5kb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHNjcmlwdCk7XG5cbmNsYXNzIFRlbXBsYXRlN0NsYXNzIHtcbiAgY29uc3RydWN0b3IodGVtcGxhdGUpIHtcbiAgICBjb25zdCB0ID0gdGhpcztcbiAgICB0LnRlbXBsYXRlID0gdGVtcGxhdGU7XG4gIH1cbiAgY29tcGlsZSh0ZW1wbGF0ZSA9IHRoaXMudGVtcGxhdGUsIGRlcHRoID0gMSkge1xuICAgIGNvbnN0IHQgPSB0aGlzO1xuICAgIGlmICh0LmNvbXBpbGVkKSByZXR1cm4gdC5jb21waWxlZDtcblxuICAgIGlmICh0eXBlb2YgdGVtcGxhdGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RlbXBsYXRlNzogVGVtcGxhdGUgbXVzdCBiZSBhIHN0cmluZycpO1xuICAgIH1cbiAgICBjb25zdCB7IHN0cmluZ1RvQmxvY2tzLCBnZXRDb21waWxlVmFyLCBnZXRDb21waWxlZEFyZ3VtZW50cyB9ID0gVGVtcGxhdGU3VXRpbHM7XG5cbiAgICBjb25zdCBibG9ja3MgPSBzdHJpbmdUb0Jsb2Nrcyh0ZW1wbGF0ZSk7XG4gICAgY29uc3QgY3R4ID0gYGN0eF8ke2RlcHRofWA7XG4gICAgY29uc3QgZGF0YSA9IGBkYXRhXyR7ZGVwdGh9YDtcbiAgICBpZiAoYmxvY2tzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIGVtcHR5KCkgeyByZXR1cm4gJyc7IH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0Q29tcGlsZUZuKGJsb2NrLCBuZXdEZXB0aCkge1xuICAgICAgaWYgKGJsb2NrLmNvbnRlbnQpIHJldHVybiB0LmNvbXBpbGUoYmxvY2suY29udGVudCwgbmV3RGVwdGgpO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIGVtcHR5KCkgeyByZXR1cm4gJyc7IH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldENvbXBpbGVJbnZlcnNlKGJsb2NrLCBuZXdEZXB0aCkge1xuICAgICAgaWYgKGJsb2NrLmludmVyc2VDb250ZW50KSByZXR1cm4gdC5jb21waWxlKGJsb2NrLmludmVyc2VDb250ZW50LCBuZXdEZXB0aCk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gZW1wdHkoKSB7IHJldHVybiAnJzsgfTtcbiAgICB9XG5cbiAgICBsZXQgcmVzdWx0U3RyaW5nID0gJyc7XG4gICAgaWYgKGRlcHRoID09PSAxKSB7XG4gICAgICByZXN1bHRTdHJpbmcgKz0gYChmdW5jdGlvbiAoJHtjdHh9LCAke2RhdGF9LCByb290KSB7XFxuYDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0U3RyaW5nICs9IGAoZnVuY3Rpb24gKCR7Y3R4fSwgJHtkYXRhfSkge1xcbmA7XG4gICAgfVxuICAgIGlmIChkZXB0aCA9PT0gMSkge1xuICAgICAgcmVzdWx0U3RyaW5nICs9ICdmdW5jdGlvbiBpc0FycmF5KGFycil7cmV0dXJuIEFycmF5LmlzQXJyYXkoYXJyKTt9XFxuJztcbiAgICAgIHJlc3VsdFN0cmluZyArPSAnZnVuY3Rpb24gaXNGdW5jdGlvbihmdW5jKXtyZXR1cm4gKHR5cGVvZiBmdW5jID09PSBcXCdmdW5jdGlvblxcJyk7fVxcbic7XG4gICAgICByZXN1bHRTdHJpbmcgKz0gJ2Z1bmN0aW9uIGModmFsLCBjdHgpIHtpZiAodHlwZW9mIHZhbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiB2YWwgIT09IG51bGwpIHtpZiAoaXNGdW5jdGlvbih2YWwpKSB7cmV0dXJuIHZhbC5jYWxsKGN0eCk7fSBlbHNlIHJldHVybiB2YWw7fSBlbHNlIHJldHVybiBcIlwiO31cXG4nO1xuICAgICAgcmVzdWx0U3RyaW5nICs9ICdyb290ID0gcm9vdCB8fCBjdHhfMSB8fCB7fTtcXG4nO1xuICAgIH1cbiAgICByZXN1bHRTdHJpbmcgKz0gJ3ZhciByID0gXFwnXFwnO1xcbic7XG4gICAgbGV0IGk7XG4gICAgZm9yIChpID0gMDsgaSA8IGJsb2Nrcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgY29uc3QgYmxvY2sgPSBibG9ja3NbaV07XG4gICAgICAvLyBQbGFpbiBibG9ja1xuICAgICAgaWYgKGJsb2NrLnR5cGUgPT09ICdwbGFpbicpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgIHJlc3VsdFN0cmluZyArPSBgciArPSckeyhibG9jay5jb250ZW50KS5yZXBsYWNlKC9cXHIvZywgJ1xcXFxyJykucmVwbGFjZSgvXFxuL2csICdcXFxcbicpLnJlcGxhY2UoLycvZywgJ1xcXFwnICsgJ1xcJycpfSc7YDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBsZXQgdmFyaWFibGU7XG4gICAgICBsZXQgY29tcGlsZWRBcmd1bWVudHM7XG4gICAgICAvLyBWYXJpYWJsZSBibG9ja1xuICAgICAgaWYgKGJsb2NrLnR5cGUgPT09ICd2YXJpYWJsZScpIHtcbiAgICAgICAgdmFyaWFibGUgPSBnZXRDb21waWxlVmFyKGJsb2NrLmNvbnRleHROYW1lLCBjdHgsIGRhdGEpO1xuICAgICAgICByZXN1bHRTdHJpbmcgKz0gYHIgKz0gYygke3ZhcmlhYmxlfSwgJHtjdHh9KTtgO1xuICAgICAgfVxuICAgICAgLy8gSGVscGVycyBibG9ja1xuICAgICAgaWYgKGJsb2NrLnR5cGUgPT09ICdoZWxwZXInKSB7XG4gICAgICAgIGxldCBwYXJlbnRzO1xuICAgICAgICBpZiAoY3R4ICE9PSAnY3R4XzEnKSB7XG4gICAgICAgICAgY29uc3QgbGV2ZWwgPSBjdHguc3BsaXQoJ18nKVsxXTtcbiAgICAgICAgICBsZXQgcGFyZW50c1N0cmluZyA9IGBjdHhfJHtsZXZlbCAtIDF9YDtcbiAgICAgICAgICBmb3IgKGxldCBqID0gbGV2ZWwgLSAyOyBqID49IDE7IGogLT0gMSkge1xuICAgICAgICAgICAgcGFyZW50c1N0cmluZyArPSBgLCBjdHhfJHtqfWA7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBhcmVudHMgPSBgWyR7cGFyZW50c1N0cmluZ31dYDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXJlbnRzID0gYFske2N0eH1dYDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZHluYW1pY0hlbHBlcjtcbiAgICAgICAgaWYgKGJsb2NrLmhlbHBlck5hbWUuaW5kZXhPZignWycpID09PSAwKSB7XG4gICAgICAgICAgYmxvY2suaGVscGVyTmFtZSA9IGdldENvbXBpbGVWYXIoYmxvY2suaGVscGVyTmFtZS5yZXBsYWNlKC9bW1xcXV0vZywgJycpLCBjdHgsIGRhdGEpO1xuICAgICAgICAgIGR5bmFtaWNIZWxwZXIgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkeW5hbWljSGVscGVyIHx8IGJsb2NrLmhlbHBlck5hbWUgaW4gVGVtcGxhdGU3SGVscGVycykge1xuICAgICAgICAgIGNvbXBpbGVkQXJndW1lbnRzID0gZ2V0Q29tcGlsZWRBcmd1bWVudHMoYmxvY2suY29udGV4dE5hbWUsIGN0eCwgZGF0YSk7XG4gICAgICAgICAgcmVzdWx0U3RyaW5nICs9IGByICs9IChUZW1wbGF0ZTdIZWxwZXJzJHtkeW5hbWljSGVscGVyID8gYFske2Jsb2NrLmhlbHBlck5hbWV9XWAgOiBgLiR7YmxvY2suaGVscGVyTmFtZX1gfSkuY2FsbCgke2N0eH0sICR7Y29tcGlsZWRBcmd1bWVudHMgJiYgKGAke2NvbXBpbGVkQXJndW1lbnRzfSwgYCl9e2hhc2g6JHtKU09OLnN0cmluZ2lmeShibG9jay5oYXNoKX0sIGRhdGE6ICR7ZGF0YX0gfHwge30sIGZuOiAke2dldENvbXBpbGVGbihibG9jaywgZGVwdGggKyAxKX0sIGludmVyc2U6ICR7Z2V0Q29tcGlsZUludmVyc2UoYmxvY2ssIGRlcHRoICsgMSl9LCByb290OiByb290LCBwYXJlbnRzOiAke3BhcmVudHN9fSk7YDtcbiAgICAgICAgfSBlbHNlIGlmIChibG9jay5jb250ZXh0TmFtZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUZW1wbGF0ZTc6IE1pc3NpbmcgaGVscGVyOiBcIiR7YmxvY2suaGVscGVyTmFtZX1cImApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhcmlhYmxlID0gZ2V0Q29tcGlsZVZhcihibG9jay5oZWxwZXJOYW1lLCBjdHgsIGRhdGEpO1xuICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBgaWYgKCR7dmFyaWFibGV9KSB7YDtcbiAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gYGlmIChpc0FycmF5KCR7dmFyaWFibGV9KSkge2A7XG4gICAgICAgICAgcmVzdWx0U3RyaW5nICs9IGByICs9IChUZW1wbGF0ZTdIZWxwZXJzLmVhY2gpLmNhbGwoJHtjdHh9LCAke3ZhcmlhYmxlfSwge2hhc2g6JHtKU09OLnN0cmluZ2lmeShibG9jay5oYXNoKX0sIGRhdGE6ICR7ZGF0YX0gfHwge30sIGZuOiAke2dldENvbXBpbGVGbihibG9jaywgZGVwdGggKyAxKX0sIGludmVyc2U6ICR7Z2V0Q29tcGlsZUludmVyc2UoYmxvY2ssIGRlcHRoICsgMSl9LCByb290OiByb290LCBwYXJlbnRzOiAke3BhcmVudHN9fSk7YDtcbiAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gJ31lbHNlIHsnO1xuICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBgciArPSAoVGVtcGxhdGU3SGVscGVycy53aXRoKS5jYWxsKCR7Y3R4fSwgJHt2YXJpYWJsZX0sIHtoYXNoOiR7SlNPTi5zdHJpbmdpZnkoYmxvY2suaGFzaCl9LCBkYXRhOiAke2RhdGF9IHx8IHt9LCBmbjogJHtnZXRDb21waWxlRm4oYmxvY2ssIGRlcHRoICsgMSl9LCBpbnZlcnNlOiAke2dldENvbXBpbGVJbnZlcnNlKGJsb2NrLCBkZXB0aCArIDEpfSwgcm9vdDogcm9vdCwgcGFyZW50czogJHtwYXJlbnRzfX0pO2A7XG4gICAgICAgICAgcmVzdWx0U3RyaW5nICs9ICd9fSc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0U3RyaW5nICs9ICdcXG5yZXR1cm4gcjt9KSc7XG5cbiAgICBpZiAoZGVwdGggPT09IDEpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgdC5jb21waWxlZCA9IGV2YWwocmVzdWx0U3RyaW5nKTtcbiAgICAgIHJldHVybiB0LmNvbXBpbGVkO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0U3RyaW5nO1xuICB9XG4gIHN0YXRpYyBnZXQgb3B0aW9ucygpIHtcbiAgICByZXR1cm4gVGVtcGxhdGU3T3B0aW9ucztcbiAgfVxuICBzdGF0aWMgZ2V0IHBhcnRpYWxzKCkge1xuICAgIHJldHVybiBUZW1wbGF0ZTdQYXJ0aWFscztcbiAgfVxuICBzdGF0aWMgZ2V0IGhlbHBlcnMoKSB7XG4gICAgcmV0dXJuIFRlbXBsYXRlN0hlbHBlcnM7XG4gIH1cbn1cblxuZnVuY3Rpb24gVGVtcGxhdGU3KC4uLmFyZ3MpIHtcbiAgY29uc3QgW3RlbXBsYXRlLCBkYXRhXSA9IGFyZ3M7XG4gIGlmIChhcmdzLmxlbmd0aCA9PT0gMikge1xuICAgIGxldCBpbnN0YW5jZSA9IG5ldyBUZW1wbGF0ZTdDbGFzcyh0ZW1wbGF0ZSk7XG4gICAgY29uc3QgcmVuZGVyZWQgPSBpbnN0YW5jZS5jb21waWxlKCkoZGF0YSk7XG4gICAgaW5zdGFuY2UgPSBudWxsO1xuICAgIHJldHVybiAocmVuZGVyZWQpO1xuICB9XG4gIHJldHVybiBuZXcgVGVtcGxhdGU3Q2xhc3ModGVtcGxhdGUpO1xufVxuVGVtcGxhdGU3LnJlZ2lzdGVySGVscGVyID0gZnVuY3Rpb24gcmVnaXN0ZXJIZWxwZXIobmFtZSwgZm4pIHtcbiAgVGVtcGxhdGU3Q2xhc3MuaGVscGVyc1tuYW1lXSA9IGZuO1xufTtcblRlbXBsYXRlNy51bnJlZ2lzdGVySGVscGVyID0gZnVuY3Rpb24gdW5yZWdpc3RlckhlbHBlcihuYW1lKSB7XG4gIFRlbXBsYXRlN0NsYXNzLmhlbHBlcnNbbmFtZV0gPSB1bmRlZmluZWQ7XG4gIGRlbGV0ZSBUZW1wbGF0ZTdDbGFzcy5oZWxwZXJzW25hbWVdO1xufTtcblRlbXBsYXRlNy5yZWdpc3RlclBhcnRpYWwgPSBmdW5jdGlvbiByZWdpc3RlclBhcnRpYWwobmFtZSwgdGVtcGxhdGUpIHtcbiAgVGVtcGxhdGU3Q2xhc3MucGFydGlhbHNbbmFtZV0gPSB7IHRlbXBsYXRlIH07XG59O1xuVGVtcGxhdGU3LnVucmVnaXN0ZXJQYXJ0aWFsID0gZnVuY3Rpb24gdW5yZWdpc3RlclBhcnRpYWwobmFtZSkge1xuICBpZiAoVGVtcGxhdGU3Q2xhc3MucGFydGlhbHNbbmFtZV0pIHtcbiAgICBUZW1wbGF0ZTdDbGFzcy5wYXJ0aWFsc1tuYW1lXSA9IHVuZGVmaW5lZDtcbiAgICBkZWxldGUgVGVtcGxhdGU3Q2xhc3MucGFydGlhbHNbbmFtZV07XG4gIH1cbn07XG5UZW1wbGF0ZTcuY29tcGlsZSA9IGZ1bmN0aW9uIGNvbXBpbGUodGVtcGxhdGUsIG9wdGlvbnMpIHtcbiAgY29uc3QgaW5zdGFuY2UgPSBuZXcgVGVtcGxhdGU3Q2xhc3ModGVtcGxhdGUsIG9wdGlvbnMpO1xuICByZXR1cm4gaW5zdGFuY2UuY29tcGlsZSgpO1xufTtcblxuVGVtcGxhdGU3Lm9wdGlvbnMgPSBUZW1wbGF0ZTdDbGFzcy5vcHRpb25zO1xuVGVtcGxhdGU3LmhlbHBlcnMgPSBUZW1wbGF0ZTdDbGFzcy5oZWxwZXJzO1xuVGVtcGxhdGU3LnBhcnRpYWxzID0gVGVtcGxhdGU3Q2xhc3MucGFydGlhbHM7XG5cbmV4cG9ydCBkZWZhdWx0IFRlbXBsYXRlNztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3RlbXBsYXRlNy9kaXN0L3RlbXBsYXRlNy5lc20uanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3RlbXBsYXRlNy9kaXN0L3RlbXBsYXRlNy5lc20uanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgc2NvcGUgPSAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnbG9iYWwpIHx8XG4gICAgICAgICAgICAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZikgfHxcbiAgICAgICAgICAgIHdpbmRvdztcbnZhciBhcHBseSA9IEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseTtcblxuLy8gRE9NIEFQSXMsIGZvciBjb21wbGV0ZW5lc3NcblxuZXhwb3J0cy5zZXRUaW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldFRpbWVvdXQsIHNjb3BlLCBhcmd1bWVudHMpLCBjbGVhclRpbWVvdXQpO1xufTtcbmV4cG9ydHMuc2V0SW50ZXJ2YWwgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0SW50ZXJ2YWwsIHNjb3BlLCBhcmd1bWVudHMpLCBjbGVhckludGVydmFsKTtcbn07XG5leHBvcnRzLmNsZWFyVGltZW91dCA9XG5leHBvcnRzLmNsZWFySW50ZXJ2YWwgPSBmdW5jdGlvbih0aW1lb3V0KSB7XG4gIGlmICh0aW1lb3V0KSB7XG4gICAgdGltZW91dC5jbG9zZSgpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBUaW1lb3V0KGlkLCBjbGVhckZuKSB7XG4gIHRoaXMuX2lkID0gaWQ7XG4gIHRoaXMuX2NsZWFyRm4gPSBjbGVhckZuO1xufVxuVGltZW91dC5wcm90b3R5cGUudW5yZWYgPSBUaW1lb3V0LnByb3RvdHlwZS5yZWYgPSBmdW5jdGlvbigpIHt9O1xuVGltZW91dC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fY2xlYXJGbi5jYWxsKHNjb3BlLCB0aGlzLl9pZCk7XG59O1xuXG4vLyBEb2VzIG5vdCBzdGFydCB0aGUgdGltZSwganVzdCBzZXRzIHVwIHRoZSBtZW1iZXJzIG5lZWRlZC5cbmV4cG9ydHMuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSwgbXNlY3MpIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuICBpdGVtLl9pZGxlVGltZW91dCA9IG1zZWNzO1xufTtcblxuZXhwb3J0cy51bmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuICBpdGVtLl9pZGxlVGltZW91dCA9IC0xO1xufTtcblxuZXhwb3J0cy5fdW5yZWZBY3RpdmUgPSBleHBvcnRzLmFjdGl2ZSA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuXG4gIHZhciBtc2VjcyA9IGl0ZW0uX2lkbGVUaW1lb3V0O1xuICBpZiAobXNlY3MgPj0gMCkge1xuICAgIGl0ZW0uX2lkbGVUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uIG9uVGltZW91dCgpIHtcbiAgICAgIGlmIChpdGVtLl9vblRpbWVvdXQpXG4gICAgICAgIGl0ZW0uX29uVGltZW91dCgpO1xuICAgIH0sIG1zZWNzKTtcbiAgfVxufTtcblxuLy8gc2V0aW1tZWRpYXRlIGF0dGFjaGVzIGl0c2VsZiB0byB0aGUgZ2xvYmFsIG9iamVjdFxucmVxdWlyZShcInNldGltbWVkaWF0ZVwiKTtcbi8vIE9uIHNvbWUgZXhvdGljIGVudmlyb25tZW50cywgaXQncyBub3QgY2xlYXIgd2hpY2ggb2JqZWN0IGBzZXRpbW1lZGlhdGVgIHdhc1xuLy8gYWJsZSB0byBpbnN0YWxsIG9udG8uICBTZWFyY2ggZWFjaCBwb3NzaWJpbGl0eSBpbiB0aGUgc2FtZSBvcmRlciBhcyB0aGVcbi8vIGBzZXRpbW1lZGlhdGVgIGxpYnJhcnkuXG5leHBvcnRzLnNldEltbWVkaWF0ZSA9ICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBzZWxmLnNldEltbWVkaWF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2xvYmFsLnNldEltbWVkaWF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMgJiYgdGhpcy5zZXRJbW1lZGlhdGUpO1xuZXhwb3J0cy5jbGVhckltbWVkaWF0ZSA9ICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBzZWxmLmNsZWFySW1tZWRpYXRlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiICYmIGdsb2JhbC5jbGVhckltbWVkaWF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAodGhpcyAmJiB0aGlzLmNsZWFySW1tZWRpYXRlKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3RpbWVycy1icm93c2VyaWZ5L21haW4uanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3RpbWVycy1icm93c2VyaWZ5L21haW4uanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKiFcbiAqIFZ1ZS5qcyB2Mi41LjE2XG4gKiAoYykgMjAxNC0yMDE4IEV2YW4gWW91XG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuLyogICovXG5cbnZhciBlbXB0eU9iamVjdCA9IE9iamVjdC5mcmVlemUoe30pO1xuXG4vLyB0aGVzZSBoZWxwZXJzIHByb2R1Y2VzIGJldHRlciB2bSBjb2RlIGluIEpTIGVuZ2luZXMgZHVlIHRvIHRoZWlyXG4vLyBleHBsaWNpdG5lc3MgYW5kIGZ1bmN0aW9uIGlubGluaW5nXG5mdW5jdGlvbiBpc1VuZGVmICh2KSB7XG4gIHJldHVybiB2ID09PSB1bmRlZmluZWQgfHwgdiA9PT0gbnVsbFxufVxuXG5mdW5jdGlvbiBpc0RlZiAodikge1xuICByZXR1cm4gdiAhPT0gdW5kZWZpbmVkICYmIHYgIT09IG51bGxcbn1cblxuZnVuY3Rpb24gaXNUcnVlICh2KSB7XG4gIHJldHVybiB2ID09PSB0cnVlXG59XG5cbmZ1bmN0aW9uIGlzRmFsc2UgKHYpIHtcbiAgcmV0dXJuIHYgPT09IGZhbHNlXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdmFsdWUgaXMgcHJpbWl0aXZlXG4gKi9cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlICh2YWx1ZSkge1xuICByZXR1cm4gKFxuICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHxcbiAgICB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInIHx8XG4gICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgdHlwZW9mIHZhbHVlID09PSAnc3ltYm9sJyB8fFxuICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nXG4gIClcbn1cblxuLyoqXG4gKiBRdWljayBvYmplY3QgY2hlY2sgLSB0aGlzIGlzIHByaW1hcmlseSB1c2VkIHRvIHRlbGxcbiAqIE9iamVjdHMgZnJvbSBwcmltaXRpdmUgdmFsdWVzIHdoZW4gd2Uga25vdyB0aGUgdmFsdWVcbiAqIGlzIGEgSlNPTi1jb21wbGlhbnQgdHlwZS5cbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QgKG9iaikge1xuICByZXR1cm4gb2JqICE9PSBudWxsICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnXG59XG5cbi8qKlxuICogR2V0IHRoZSByYXcgdHlwZSBzdHJpbmcgb2YgYSB2YWx1ZSBlLmcuIFtvYmplY3QgT2JqZWN0XVxuICovXG52YXIgX3RvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuZnVuY3Rpb24gdG9SYXdUeXBlICh2YWx1ZSkge1xuICByZXR1cm4gX3RvU3RyaW5nLmNhbGwodmFsdWUpLnNsaWNlKDgsIC0xKVxufVxuXG4vKipcbiAqIFN0cmljdCBvYmplY3QgdHlwZSBjaGVjay4gT25seSByZXR1cm5zIHRydWVcbiAqIGZvciBwbGFpbiBKYXZhU2NyaXB0IG9iamVjdHMuXG4gKi9cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QgKG9iaikge1xuICByZXR1cm4gX3RvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgT2JqZWN0XSdcbn1cblxuZnVuY3Rpb24gaXNSZWdFeHAgKHYpIHtcbiAgcmV0dXJuIF90b1N0cmluZy5jYWxsKHYpID09PSAnW29iamVjdCBSZWdFeHBdJ1xufVxuXG4vKipcbiAqIENoZWNrIGlmIHZhbCBpcyBhIHZhbGlkIGFycmF5IGluZGV4LlxuICovXG5mdW5jdGlvbiBpc1ZhbGlkQXJyYXlJbmRleCAodmFsKSB7XG4gIHZhciBuID0gcGFyc2VGbG9hdChTdHJpbmcodmFsKSk7XG4gIHJldHVybiBuID49IDAgJiYgTWF0aC5mbG9vcihuKSA9PT0gbiAmJiBpc0Zpbml0ZSh2YWwpXG59XG5cbi8qKlxuICogQ29udmVydCBhIHZhbHVlIHRvIGEgc3RyaW5nIHRoYXQgaXMgYWN0dWFsbHkgcmVuZGVyZWQuXG4gKi9cbmZ1bmN0aW9uIHRvU3RyaW5nICh2YWwpIHtcbiAgcmV0dXJuIHZhbCA9PSBudWxsXG4gICAgPyAnJ1xuICAgIDogdHlwZW9mIHZhbCA9PT0gJ29iamVjdCdcbiAgICAgID8gSlNPTi5zdHJpbmdpZnkodmFsLCBudWxsLCAyKVxuICAgICAgOiBTdHJpbmcodmFsKVxufVxuXG4vKipcbiAqIENvbnZlcnQgYSBpbnB1dCB2YWx1ZSB0byBhIG51bWJlciBmb3IgcGVyc2lzdGVuY2UuXG4gKiBJZiB0aGUgY29udmVyc2lvbiBmYWlscywgcmV0dXJuIG9yaWdpbmFsIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gdG9OdW1iZXIgKHZhbCkge1xuICB2YXIgbiA9IHBhcnNlRmxvYXQodmFsKTtcbiAgcmV0dXJuIGlzTmFOKG4pID8gdmFsIDogblxufVxuXG4vKipcbiAqIE1ha2UgYSBtYXAgYW5kIHJldHVybiBhIGZ1bmN0aW9uIGZvciBjaGVja2luZyBpZiBhIGtleVxuICogaXMgaW4gdGhhdCBtYXAuXG4gKi9cbmZ1bmN0aW9uIG1ha2VNYXAgKFxuICBzdHIsXG4gIGV4cGVjdHNMb3dlckNhc2Vcbikge1xuICB2YXIgbWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdmFyIGxpc3QgPSBzdHIuc3BsaXQoJywnKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgbWFwW2xpc3RbaV1dID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZXhwZWN0c0xvd2VyQ2FzZVxuICAgID8gZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gbWFwW3ZhbC50b0xvd2VyQ2FzZSgpXTsgfVxuICAgIDogZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gbWFwW3ZhbF07IH1cbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhIHRhZyBpcyBhIGJ1aWx0LWluIHRhZy5cbiAqL1xudmFyIGlzQnVpbHRJblRhZyA9IG1ha2VNYXAoJ3Nsb3QsY29tcG9uZW50JywgdHJ1ZSk7XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBhdHRyaWJ1dGUgaXMgYSByZXNlcnZlZCBhdHRyaWJ1dGUuXG4gKi9cbnZhciBpc1Jlc2VydmVkQXR0cmlidXRlID0gbWFrZU1hcCgna2V5LHJlZixzbG90LHNsb3Qtc2NvcGUsaXMnKTtcblxuLyoqXG4gKiBSZW1vdmUgYW4gaXRlbSBmcm9tIGFuIGFycmF5XG4gKi9cbmZ1bmN0aW9uIHJlbW92ZSAoYXJyLCBpdGVtKSB7XG4gIGlmIChhcnIubGVuZ3RoKSB7XG4gICAgdmFyIGluZGV4ID0gYXJyLmluZGV4T2YoaXRlbSk7XG4gICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgIHJldHVybiBhcnIuc3BsaWNlKGluZGV4LCAxKVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhlIG9iamVjdCBoYXMgdGhlIHByb3BlcnR5LlxuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuZnVuY3Rpb24gaGFzT3duIChvYmosIGtleSkge1xuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSlcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBjYWNoZWQgdmVyc2lvbiBvZiBhIHB1cmUgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNhY2hlZCAoZm4pIHtcbiAgdmFyIGNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgcmV0dXJuIChmdW5jdGlvbiBjYWNoZWRGbiAoc3RyKSB7XG4gICAgdmFyIGhpdCA9IGNhY2hlW3N0cl07XG4gICAgcmV0dXJuIGhpdCB8fCAoY2FjaGVbc3RyXSA9IGZuKHN0cikpXG4gIH0pXG59XG5cbi8qKlxuICogQ2FtZWxpemUgYSBoeXBoZW4tZGVsaW1pdGVkIHN0cmluZy5cbiAqL1xudmFyIGNhbWVsaXplUkUgPSAvLShcXHcpL2c7XG52YXIgY2FtZWxpemUgPSBjYWNoZWQoZnVuY3Rpb24gKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoY2FtZWxpemVSRSwgZnVuY3Rpb24gKF8sIGMpIHsgcmV0dXJuIGMgPyBjLnRvVXBwZXJDYXNlKCkgOiAnJzsgfSlcbn0pO1xuXG4vKipcbiAqIENhcGl0YWxpemUgYSBzdHJpbmcuXG4gKi9cbnZhciBjYXBpdGFsaXplID0gY2FjaGVkKGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKVxufSk7XG5cbi8qKlxuICogSHlwaGVuYXRlIGEgY2FtZWxDYXNlIHN0cmluZy5cbiAqL1xudmFyIGh5cGhlbmF0ZVJFID0gL1xcQihbQS1aXSkvZztcbnZhciBoeXBoZW5hdGUgPSBjYWNoZWQoZnVuY3Rpb24gKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoaHlwaGVuYXRlUkUsICctJDEnKS50b0xvd2VyQ2FzZSgpXG59KTtcblxuLyoqXG4gKiBTaW1wbGUgYmluZCBwb2x5ZmlsbCBmb3IgZW52aXJvbm1lbnRzIHRoYXQgZG8gbm90IHN1cHBvcnQgaXQuLi4gZS5nLlxuICogUGhhbnRvbUpTIDEueC4gVGVjaG5pY2FsbHkgd2UgZG9uJ3QgbmVlZCB0aGlzIGFueW1vcmUgc2luY2UgbmF0aXZlIGJpbmQgaXNcbiAqIG5vdyBtb3JlIHBlcmZvcm1hbnQgaW4gbW9zdCBicm93c2VycywgYnV0IHJlbW92aW5nIGl0IHdvdWxkIGJlIGJyZWFraW5nIGZvclxuICogY29kZSB0aGF0IHdhcyBhYmxlIHRvIHJ1biBpbiBQaGFudG9tSlMgMS54LCBzbyB0aGlzIG11c3QgYmUga2VwdCBmb3JcbiAqIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuICovXG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5mdW5jdGlvbiBwb2x5ZmlsbEJpbmQgKGZuLCBjdHgpIHtcbiAgZnVuY3Rpb24gYm91bmRGbiAoYSkge1xuICAgIHZhciBsID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICByZXR1cm4gbFxuICAgICAgPyBsID4gMVxuICAgICAgICA/IGZuLmFwcGx5KGN0eCwgYXJndW1lbnRzKVxuICAgICAgICA6IGZuLmNhbGwoY3R4LCBhKVxuICAgICAgOiBmbi5jYWxsKGN0eClcbiAgfVxuXG4gIGJvdW5kRm4uX2xlbmd0aCA9IGZuLmxlbmd0aDtcbiAgcmV0dXJuIGJvdW5kRm5cbn1cblxuZnVuY3Rpb24gbmF0aXZlQmluZCAoZm4sIGN0eCkge1xuICByZXR1cm4gZm4uYmluZChjdHgpXG59XG5cbnZhciBiaW5kID0gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmRcbiAgPyBuYXRpdmVCaW5kXG4gIDogcG9seWZpbGxCaW5kO1xuXG4vKipcbiAqIENvbnZlcnQgYW4gQXJyYXktbGlrZSBvYmplY3QgdG8gYSByZWFsIEFycmF5LlxuICovXG5mdW5jdGlvbiB0b0FycmF5IChsaXN0LCBzdGFydCkge1xuICBzdGFydCA9IHN0YXJ0IHx8IDA7XG4gIHZhciBpID0gbGlzdC5sZW5ndGggLSBzdGFydDtcbiAgdmFyIHJldCA9IG5ldyBBcnJheShpKTtcbiAgd2hpbGUgKGktLSkge1xuICAgIHJldFtpXSA9IGxpc3RbaSArIHN0YXJ0XTtcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbi8qKlxuICogTWl4IHByb3BlcnRpZXMgaW50byB0YXJnZXQgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBleHRlbmQgKHRvLCBfZnJvbSkge1xuICBmb3IgKHZhciBrZXkgaW4gX2Zyb20pIHtcbiAgICB0b1trZXldID0gX2Zyb21ba2V5XTtcbiAgfVxuICByZXR1cm4gdG9cbn1cblxuLyoqXG4gKiBNZXJnZSBhbiBBcnJheSBvZiBPYmplY3RzIGludG8gYSBzaW5nbGUgT2JqZWN0LlxuICovXG5mdW5jdGlvbiB0b09iamVjdCAoYXJyKSB7XG4gIHZhciByZXMgPSB7fTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoYXJyW2ldKSB7XG4gICAgICBleHRlbmQocmVzLCBhcnJbaV0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qKlxuICogUGVyZm9ybSBubyBvcGVyYXRpb24uXG4gKiBTdHViYmluZyBhcmdzIHRvIG1ha2UgRmxvdyBoYXBweSB3aXRob3V0IGxlYXZpbmcgdXNlbGVzcyB0cmFuc3BpbGVkIGNvZGVcbiAqIHdpdGggLi4ucmVzdCAoaHR0cHM6Ly9mbG93Lm9yZy9ibG9nLzIwMTcvMDUvMDcvU3RyaWN0LUZ1bmN0aW9uLUNhbGwtQXJpdHkvKVxuICovXG5mdW5jdGlvbiBub29wIChhLCBiLCBjKSB7fVxuXG4vKipcbiAqIEFsd2F5cyByZXR1cm4gZmFsc2UuXG4gKi9cbnZhciBubyA9IGZ1bmN0aW9uIChhLCBiLCBjKSB7IHJldHVybiBmYWxzZTsgfTtcblxuLyoqXG4gKiBSZXR1cm4gc2FtZSB2YWx1ZVxuICovXG52YXIgaWRlbnRpdHkgPSBmdW5jdGlvbiAoXykgeyByZXR1cm4gXzsgfTtcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIHN0YXRpYyBrZXlzIHN0cmluZyBmcm9tIGNvbXBpbGVyIG1vZHVsZXMuXG4gKi9cbmZ1bmN0aW9uIGdlblN0YXRpY0tleXMgKG1vZHVsZXMpIHtcbiAgcmV0dXJuIG1vZHVsZXMucmVkdWNlKGZ1bmN0aW9uIChrZXlzLCBtKSB7XG4gICAgcmV0dXJuIGtleXMuY29uY2F0KG0uc3RhdGljS2V5cyB8fCBbXSlcbiAgfSwgW10pLmpvaW4oJywnKVxufVxuXG4vKipcbiAqIENoZWNrIGlmIHR3byB2YWx1ZXMgYXJlIGxvb3NlbHkgZXF1YWwgLSB0aGF0IGlzLFxuICogaWYgdGhleSBhcmUgcGxhaW4gb2JqZWN0cywgZG8gdGhleSBoYXZlIHRoZSBzYW1lIHNoYXBlP1xuICovXG5mdW5jdGlvbiBsb29zZUVxdWFsIChhLCBiKSB7XG4gIGlmIChhID09PSBiKSB7IHJldHVybiB0cnVlIH1cbiAgdmFyIGlzT2JqZWN0QSA9IGlzT2JqZWN0KGEpO1xuICB2YXIgaXNPYmplY3RCID0gaXNPYmplY3QoYik7XG4gIGlmIChpc09iamVjdEEgJiYgaXNPYmplY3RCKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBpc0FycmF5QSA9IEFycmF5LmlzQXJyYXkoYSk7XG4gICAgICB2YXIgaXNBcnJheUIgPSBBcnJheS5pc0FycmF5KGIpO1xuICAgICAgaWYgKGlzQXJyYXlBICYmIGlzQXJyYXlCKSB7XG4gICAgICAgIHJldHVybiBhLmxlbmd0aCA9PT0gYi5sZW5ndGggJiYgYS5ldmVyeShmdW5jdGlvbiAoZSwgaSkge1xuICAgICAgICAgIHJldHVybiBsb29zZUVxdWFsKGUsIGJbaV0pXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2UgaWYgKCFpc0FycmF5QSAmJiAhaXNBcnJheUIpIHtcbiAgICAgICAgdmFyIGtleXNBID0gT2JqZWN0LmtleXMoYSk7XG4gICAgICAgIHZhciBrZXlzQiA9IE9iamVjdC5rZXlzKGIpO1xuICAgICAgICByZXR1cm4ga2V5c0EubGVuZ3RoID09PSBrZXlzQi5sZW5ndGggJiYga2V5c0EuZXZlcnkoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgIHJldHVybiBsb29zZUVxdWFsKGFba2V5XSwgYltrZXldKVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfSBlbHNlIGlmICghaXNPYmplY3RBICYmICFpc09iamVjdEIpIHtcbiAgICByZXR1cm4gU3RyaW5nKGEpID09PSBTdHJpbmcoYilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5mdW5jdGlvbiBsb29zZUluZGV4T2YgKGFyciwgdmFsKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGxvb3NlRXF1YWwoYXJyW2ldLCB2YWwpKSB7IHJldHVybiBpIH1cbiAgfVxuICByZXR1cm4gLTFcbn1cblxuLyoqXG4gKiBFbnN1cmUgYSBmdW5jdGlvbiBpcyBjYWxsZWQgb25seSBvbmNlLlxuICovXG5mdW5jdGlvbiBvbmNlIChmbikge1xuICB2YXIgY2FsbGVkID0gZmFsc2U7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFjYWxsZWQpIHtcbiAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgU1NSX0FUVFIgPSAnZGF0YS1zZXJ2ZXItcmVuZGVyZWQnO1xuXG52YXIgQVNTRVRfVFlQRVMgPSBbXG4gICdjb21wb25lbnQnLFxuICAnZGlyZWN0aXZlJyxcbiAgJ2ZpbHRlcidcbl07XG5cbnZhciBMSUZFQ1lDTEVfSE9PS1MgPSBbXG4gICdiZWZvcmVDcmVhdGUnLFxuICAnY3JlYXRlZCcsXG4gICdiZWZvcmVNb3VudCcsXG4gICdtb3VudGVkJyxcbiAgJ2JlZm9yZVVwZGF0ZScsXG4gICd1cGRhdGVkJyxcbiAgJ2JlZm9yZURlc3Ryb3knLFxuICAnZGVzdHJveWVkJyxcbiAgJ2FjdGl2YXRlZCcsXG4gICdkZWFjdGl2YXRlZCcsXG4gICdlcnJvckNhcHR1cmVkJ1xuXTtcblxuLyogICovXG5cbnZhciBjb25maWcgPSAoe1xuICAvKipcbiAgICogT3B0aW9uIG1lcmdlIHN0cmF0ZWdpZXMgKHVzZWQgaW4gY29yZS91dGlsL29wdGlvbnMpXG4gICAqL1xuICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgb3B0aW9uTWVyZ2VTdHJhdGVnaWVzOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIHN1cHByZXNzIHdhcm5pbmdzLlxuICAgKi9cbiAgc2lsZW50OiBmYWxzZSxcblxuICAvKipcbiAgICogU2hvdyBwcm9kdWN0aW9uIG1vZGUgdGlwIG1lc3NhZ2Ugb24gYm9vdD9cbiAgICovXG4gIHByb2R1Y3Rpb25UaXA6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicsXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gZW5hYmxlIGRldnRvb2xzXG4gICAqL1xuICBkZXZ0b29sczogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyxcblxuICAvKipcbiAgICogV2hldGhlciB0byByZWNvcmQgcGVyZlxuICAgKi9cbiAgcGVyZm9ybWFuY2U6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBFcnJvciBoYW5kbGVyIGZvciB3YXRjaGVyIGVycm9yc1xuICAgKi9cbiAgZXJyb3JIYW5kbGVyOiBudWxsLFxuXG4gIC8qKlxuICAgKiBXYXJuIGhhbmRsZXIgZm9yIHdhdGNoZXIgd2FybnNcbiAgICovXG4gIHdhcm5IYW5kbGVyOiBudWxsLFxuXG4gIC8qKlxuICAgKiBJZ25vcmUgY2VydGFpbiBjdXN0b20gZWxlbWVudHNcbiAgICovXG4gIGlnbm9yZWRFbGVtZW50czogW10sXG5cbiAgLyoqXG4gICAqIEN1c3RvbSB1c2VyIGtleSBhbGlhc2VzIGZvciB2LW9uXG4gICAqL1xuICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAga2V5Q29kZXM6IE9iamVjdC5jcmVhdGUobnVsbCksXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEgdGFnIGlzIHJlc2VydmVkIHNvIHRoYXQgaXQgY2Fubm90IGJlIHJlZ2lzdGVyZWQgYXMgYVxuICAgKiBjb21wb25lbnQuIFRoaXMgaXMgcGxhdGZvcm0tZGVwZW5kZW50IGFuZCBtYXkgYmUgb3ZlcndyaXR0ZW4uXG4gICAqL1xuICBpc1Jlc2VydmVkVGFnOiBubyxcblxuICAvKipcbiAgICogQ2hlY2sgaWYgYW4gYXR0cmlidXRlIGlzIHJlc2VydmVkIHNvIHRoYXQgaXQgY2Fubm90IGJlIHVzZWQgYXMgYSBjb21wb25lbnRcbiAgICogcHJvcC4gVGhpcyBpcyBwbGF0Zm9ybS1kZXBlbmRlbnQgYW5kIG1heSBiZSBvdmVyd3JpdHRlbi5cbiAgICovXG4gIGlzUmVzZXJ2ZWRBdHRyOiBubyxcblxuICAvKipcbiAgICogQ2hlY2sgaWYgYSB0YWcgaXMgYW4gdW5rbm93biBlbGVtZW50LlxuICAgKiBQbGF0Zm9ybS1kZXBlbmRlbnQuXG4gICAqL1xuICBpc1Vua25vd25FbGVtZW50OiBubyxcblxuICAvKipcbiAgICogR2V0IHRoZSBuYW1lc3BhY2Ugb2YgYW4gZWxlbWVudFxuICAgKi9cbiAgZ2V0VGFnTmFtZXNwYWNlOiBub29wLFxuXG4gIC8qKlxuICAgKiBQYXJzZSB0aGUgcmVhbCB0YWcgbmFtZSBmb3IgdGhlIHNwZWNpZmljIHBsYXRmb3JtLlxuICAgKi9cbiAgcGFyc2VQbGF0Zm9ybVRhZ05hbWU6IGlkZW50aXR5LFxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhbiBhdHRyaWJ1dGUgbXVzdCBiZSBib3VuZCB1c2luZyBwcm9wZXJ0eSwgZS5nLiB2YWx1ZVxuICAgKiBQbGF0Zm9ybS1kZXBlbmRlbnQuXG4gICAqL1xuICBtdXN0VXNlUHJvcDogbm8sXG5cbiAgLyoqXG4gICAqIEV4cG9zZWQgZm9yIGxlZ2FjeSByZWFzb25zXG4gICAqL1xuICBfbGlmZWN5Y2xlSG9va3M6IExJRkVDWUNMRV9IT09LU1xufSlcblxuLyogICovXG5cbi8qKlxuICogQ2hlY2sgaWYgYSBzdHJpbmcgc3RhcnRzIHdpdGggJCBvciBfXG4gKi9cbmZ1bmN0aW9uIGlzUmVzZXJ2ZWQgKHN0cikge1xuICB2YXIgYyA9IChzdHIgKyAnJykuY2hhckNvZGVBdCgwKTtcbiAgcmV0dXJuIGMgPT09IDB4MjQgfHwgYyA9PT0gMHg1RlxufVxuXG4vKipcbiAqIERlZmluZSBhIHByb3BlcnR5LlxuICovXG5mdW5jdGlvbiBkZWYgKG9iaiwga2V5LCB2YWwsIGVudW1lcmFibGUpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgdmFsdWU6IHZhbCxcbiAgICBlbnVtZXJhYmxlOiAhIWVudW1lcmFibGUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuXG4vKipcbiAqIFBhcnNlIHNpbXBsZSBwYXRoLlxuICovXG52YXIgYmFpbFJFID0gL1teXFx3LiRdLztcbmZ1bmN0aW9uIHBhcnNlUGF0aCAocGF0aCkge1xuICBpZiAoYmFpbFJFLnRlc3QocGF0aCkpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgc2VnbWVudHMgPSBwYXRoLnNwbGl0KCcuJyk7XG4gIHJldHVybiBmdW5jdGlvbiAob2JqKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCFvYmopIHsgcmV0dXJuIH1cbiAgICAgIG9iaiA9IG9ialtzZWdtZW50c1tpXV07XG4gICAgfVxuICAgIHJldHVybiBvYmpcbiAgfVxufVxuXG4vKiAgKi9cblxuLy8gY2FuIHdlIHVzZSBfX3Byb3RvX18/XG52YXIgaGFzUHJvdG8gPSAnX19wcm90b19fJyBpbiB7fTtcblxuLy8gQnJvd3NlciBlbnZpcm9ubWVudCBzbmlmZmluZ1xudmFyIGluQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnO1xudmFyIGluV2VleCA9IHR5cGVvZiBXWEVudmlyb25tZW50ICE9PSAndW5kZWZpbmVkJyAmJiAhIVdYRW52aXJvbm1lbnQucGxhdGZvcm07XG52YXIgd2VleFBsYXRmb3JtID0gaW5XZWV4ICYmIFdYRW52aXJvbm1lbnQucGxhdGZvcm0udG9Mb3dlckNhc2UoKTtcbnZhciBVQSA9IGluQnJvd3NlciAmJiB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpO1xudmFyIGlzSUUgPSBVQSAmJiAvbXNpZXx0cmlkZW50Ly50ZXN0KFVBKTtcbnZhciBpc0lFOSA9IFVBICYmIFVBLmluZGV4T2YoJ21zaWUgOS4wJykgPiAwO1xudmFyIGlzRWRnZSA9IFVBICYmIFVBLmluZGV4T2YoJ2VkZ2UvJykgPiAwO1xudmFyIGlzQW5kcm9pZCA9IChVQSAmJiBVQS5pbmRleE9mKCdhbmRyb2lkJykgPiAwKSB8fCAod2VleFBsYXRmb3JtID09PSAnYW5kcm9pZCcpO1xudmFyIGlzSU9TID0gKFVBICYmIC9pcGhvbmV8aXBhZHxpcG9kfGlvcy8udGVzdChVQSkpIHx8ICh3ZWV4UGxhdGZvcm0gPT09ICdpb3MnKTtcbnZhciBpc0Nocm9tZSA9IFVBICYmIC9jaHJvbWVcXC9cXGQrLy50ZXN0KFVBKSAmJiAhaXNFZGdlO1xuXG4vLyBGaXJlZm94IGhhcyBhIFwid2F0Y2hcIiBmdW5jdGlvbiBvbiBPYmplY3QucHJvdG90eXBlLi4uXG52YXIgbmF0aXZlV2F0Y2ggPSAoe30pLndhdGNoO1xuXG52YXIgc3VwcG9ydHNQYXNzaXZlID0gZmFsc2U7XG5pZiAoaW5Ccm93c2VyKSB7XG4gIHRyeSB7XG4gICAgdmFyIG9wdHMgPSB7fTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob3B0cywgJ3Bhc3NpdmUnLCAoe1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQgKCkge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICBzdXBwb3J0c1Bhc3NpdmUgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pKTsgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2Zsb3cvaXNzdWVzLzI4NVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0ZXN0LXBhc3NpdmUnLCBudWxsLCBvcHRzKTtcbiAgfSBjYXRjaCAoZSkge31cbn1cblxuLy8gdGhpcyBuZWVkcyB0byBiZSBsYXp5LWV2YWxlZCBiZWNhdXNlIHZ1ZSBtYXkgYmUgcmVxdWlyZWQgYmVmb3JlXG4vLyB2dWUtc2VydmVyLXJlbmRlcmVyIGNhbiBzZXQgVlVFX0VOVlxudmFyIF9pc1NlcnZlcjtcbnZhciBpc1NlcnZlclJlbmRlcmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKF9pc1NlcnZlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFpbkJyb3dzZXIgJiYgIWluV2VleCAmJiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgLy8gZGV0ZWN0IHByZXNlbmNlIG9mIHZ1ZS1zZXJ2ZXItcmVuZGVyZXIgYW5kIGF2b2lkXG4gICAgICAvLyBXZWJwYWNrIHNoaW1taW5nIHRoZSBwcm9jZXNzXG4gICAgICBfaXNTZXJ2ZXIgPSBnbG9iYWxbJ3Byb2Nlc3MnXS5lbnYuVlVFX0VOViA9PT0gJ3NlcnZlcic7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9pc1NlcnZlciA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gX2lzU2VydmVyXG59O1xuXG4vLyBkZXRlY3QgZGV2dG9vbHNcbnZhciBkZXZ0b29scyA9IGluQnJvd3NlciAmJiB3aW5kb3cuX19WVUVfREVWVE9PTFNfR0xPQkFMX0hPT0tfXztcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIGlzTmF0aXZlIChDdG9yKSB7XG4gIHJldHVybiB0eXBlb2YgQ3RvciA9PT0gJ2Z1bmN0aW9uJyAmJiAvbmF0aXZlIGNvZGUvLnRlc3QoQ3Rvci50b1N0cmluZygpKVxufVxuXG52YXIgaGFzU3ltYm9sID1cbiAgdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoU3ltYm9sKSAmJlxuICB0eXBlb2YgUmVmbGVjdCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoUmVmbGVjdC5vd25LZXlzKTtcblxudmFyIF9TZXQ7XG4vKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi8gLy8gJGZsb3ctZGlzYWJsZS1saW5lXG5pZiAodHlwZW9mIFNldCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoU2V0KSkge1xuICAvLyB1c2UgbmF0aXZlIFNldCB3aGVuIGF2YWlsYWJsZS5cbiAgX1NldCA9IFNldDtcbn0gZWxzZSB7XG4gIC8vIGEgbm9uLXN0YW5kYXJkIFNldCBwb2x5ZmlsbCB0aGF0IG9ubHkgd29ya3Mgd2l0aCBwcmltaXRpdmUga2V5cy5cbiAgX1NldCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2V0ICgpIHtcbiAgICAgIHRoaXMuc2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB9XG4gICAgU2V0LnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiBoYXMgKGtleSkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0W2tleV0gPT09IHRydWVcbiAgICB9O1xuICAgIFNldC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkIChrZXkpIHtcbiAgICAgIHRoaXMuc2V0W2tleV0gPSB0cnVlO1xuICAgIH07XG4gICAgU2V0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyICgpIHtcbiAgICAgIHRoaXMuc2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFNldDtcbiAgfSgpKTtcbn1cblxuLyogICovXG5cbnZhciB3YXJuID0gbm9vcDtcbnZhciB0aXAgPSBub29wO1xudmFyIGdlbmVyYXRlQ29tcG9uZW50VHJhY2UgPSAobm9vcCk7IC8vIHdvcmsgYXJvdW5kIGZsb3cgY2hlY2tcbnZhciBmb3JtYXRDb21wb25lbnROYW1lID0gKG5vb3ApO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgaGFzQ29uc29sZSA9IHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJztcbiAgdmFyIGNsYXNzaWZ5UkUgPSAvKD86XnxbLV9dKShcXHcpL2c7XG4gIHZhciBjbGFzc2lmeSA9IGZ1bmN0aW9uIChzdHIpIHsgcmV0dXJuIHN0clxuICAgIC5yZXBsYWNlKGNsYXNzaWZ5UkUsIGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLnRvVXBwZXJDYXNlKCk7IH0pXG4gICAgLnJlcGxhY2UoL1stX10vZywgJycpOyB9O1xuXG4gIHdhcm4gPSBmdW5jdGlvbiAobXNnLCB2bSkge1xuICAgIHZhciB0cmFjZSA9IHZtID8gZ2VuZXJhdGVDb21wb25lbnRUcmFjZSh2bSkgOiAnJztcblxuICAgIGlmIChjb25maWcud2FybkhhbmRsZXIpIHtcbiAgICAgIGNvbmZpZy53YXJuSGFuZGxlci5jYWxsKG51bGwsIG1zZywgdm0sIHRyYWNlKTtcbiAgICB9IGVsc2UgaWYgKGhhc0NvbnNvbGUgJiYgKCFjb25maWcuc2lsZW50KSkge1xuICAgICAgY29uc29sZS5lcnJvcigoXCJbVnVlIHdhcm5dOiBcIiArIG1zZyArIHRyYWNlKSk7XG4gICAgfVxuICB9O1xuXG4gIHRpcCA9IGZ1bmN0aW9uIChtc2csIHZtKSB7XG4gICAgaWYgKGhhc0NvbnNvbGUgJiYgKCFjb25maWcuc2lsZW50KSkge1xuICAgICAgY29uc29sZS53YXJuKFwiW1Z1ZSB0aXBdOiBcIiArIG1zZyArIChcbiAgICAgICAgdm0gPyBnZW5lcmF0ZUNvbXBvbmVudFRyYWNlKHZtKSA6ICcnXG4gICAgICApKTtcbiAgICB9XG4gIH07XG5cbiAgZm9ybWF0Q29tcG9uZW50TmFtZSA9IGZ1bmN0aW9uICh2bSwgaW5jbHVkZUZpbGUpIHtcbiAgICBpZiAodm0uJHJvb3QgPT09IHZtKSB7XG4gICAgICByZXR1cm4gJzxSb290PidcbiAgICB9XG4gICAgdmFyIG9wdGlvbnMgPSB0eXBlb2Ygdm0gPT09ICdmdW5jdGlvbicgJiYgdm0uY2lkICE9IG51bGxcbiAgICAgID8gdm0ub3B0aW9uc1xuICAgICAgOiB2bS5faXNWdWVcbiAgICAgICAgPyB2bS4kb3B0aW9ucyB8fCB2bS5jb25zdHJ1Y3Rvci5vcHRpb25zXG4gICAgICAgIDogdm0gfHwge307XG4gICAgdmFyIG5hbWUgPSBvcHRpb25zLm5hbWUgfHwgb3B0aW9ucy5fY29tcG9uZW50VGFnO1xuICAgIHZhciBmaWxlID0gb3B0aW9ucy5fX2ZpbGU7XG4gICAgaWYgKCFuYW1lICYmIGZpbGUpIHtcbiAgICAgIHZhciBtYXRjaCA9IGZpbGUubWF0Y2goLyhbXi9cXFxcXSspXFwudnVlJC8pO1xuICAgICAgbmFtZSA9IG1hdGNoICYmIG1hdGNoWzFdO1xuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICAobmFtZSA/IChcIjxcIiArIChjbGFzc2lmeShuYW1lKSkgKyBcIj5cIikgOiBcIjxBbm9ueW1vdXM+XCIpICtcbiAgICAgIChmaWxlICYmIGluY2x1ZGVGaWxlICE9PSBmYWxzZSA/IChcIiBhdCBcIiArIGZpbGUpIDogJycpXG4gICAgKVxuICB9O1xuXG4gIHZhciByZXBlYXQgPSBmdW5jdGlvbiAoc3RyLCBuKSB7XG4gICAgdmFyIHJlcyA9ICcnO1xuICAgIHdoaWxlIChuKSB7XG4gICAgICBpZiAobiAlIDIgPT09IDEpIHsgcmVzICs9IHN0cjsgfVxuICAgICAgaWYgKG4gPiAxKSB7IHN0ciArPSBzdHI7IH1cbiAgICAgIG4gPj49IDE7XG4gICAgfVxuICAgIHJldHVybiByZXNcbiAgfTtcblxuICBnZW5lcmF0ZUNvbXBvbmVudFRyYWNlID0gZnVuY3Rpb24gKHZtKSB7XG4gICAgaWYgKHZtLl9pc1Z1ZSAmJiB2bS4kcGFyZW50KSB7XG4gICAgICB2YXIgdHJlZSA9IFtdO1xuICAgICAgdmFyIGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZSA9IDA7XG4gICAgICB3aGlsZSAodm0pIHtcbiAgICAgICAgaWYgKHRyZWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHZhciBsYXN0ID0gdHJlZVt0cmVlLmxlbmd0aCAtIDFdO1xuICAgICAgICAgIGlmIChsYXN0LmNvbnN0cnVjdG9yID09PSB2bS5jb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlKys7XG4gICAgICAgICAgICB2bSA9IHZtLiRwYXJlbnQ7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH0gZWxzZSBpZiAoY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlID4gMCkge1xuICAgICAgICAgICAgdHJlZVt0cmVlLmxlbmd0aCAtIDFdID0gW2xhc3QsIGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZV07XG4gICAgICAgICAgICBjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0cmVlLnB1c2godm0pO1xuICAgICAgICB2bSA9IHZtLiRwYXJlbnQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gJ1xcblxcbmZvdW5kIGluXFxuXFxuJyArIHRyZWVcbiAgICAgICAgLm1hcChmdW5jdGlvbiAodm0sIGkpIHsgcmV0dXJuIChcIlwiICsgKGkgPT09IDAgPyAnLS0tPiAnIDogcmVwZWF0KCcgJywgNSArIGkgKiAyKSkgKyAoQXJyYXkuaXNBcnJheSh2bSlcbiAgICAgICAgICAgID8gKChmb3JtYXRDb21wb25lbnROYW1lKHZtWzBdKSkgKyBcIi4uLiAoXCIgKyAodm1bMV0pICsgXCIgcmVjdXJzaXZlIGNhbGxzKVwiKVxuICAgICAgICAgICAgOiBmb3JtYXRDb21wb25lbnROYW1lKHZtKSkpOyB9KVxuICAgICAgICAuam9pbignXFxuJylcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIChcIlxcblxcbihmb3VuZCBpbiBcIiArIChmb3JtYXRDb21wb25lbnROYW1lKHZtKSkgKyBcIilcIilcbiAgICB9XG4gIH07XG59XG5cbi8qICAqL1xuXG5cbnZhciB1aWQgPSAwO1xuXG4vKipcbiAqIEEgZGVwIGlzIGFuIG9ic2VydmFibGUgdGhhdCBjYW4gaGF2ZSBtdWx0aXBsZVxuICogZGlyZWN0aXZlcyBzdWJzY3JpYmluZyB0byBpdC5cbiAqL1xudmFyIERlcCA9IGZ1bmN0aW9uIERlcCAoKSB7XG4gIHRoaXMuaWQgPSB1aWQrKztcbiAgdGhpcy5zdWJzID0gW107XG59O1xuXG5EZXAucHJvdG90eXBlLmFkZFN1YiA9IGZ1bmN0aW9uIGFkZFN1YiAoc3ViKSB7XG4gIHRoaXMuc3Vicy5wdXNoKHN1Yik7XG59O1xuXG5EZXAucHJvdG90eXBlLnJlbW92ZVN1YiA9IGZ1bmN0aW9uIHJlbW92ZVN1YiAoc3ViKSB7XG4gIHJlbW92ZSh0aGlzLnN1YnMsIHN1Yik7XG59O1xuXG5EZXAucHJvdG90eXBlLmRlcGVuZCA9IGZ1bmN0aW9uIGRlcGVuZCAoKSB7XG4gIGlmIChEZXAudGFyZ2V0KSB7XG4gICAgRGVwLnRhcmdldC5hZGREZXAodGhpcyk7XG4gIH1cbn07XG5cbkRlcC5wcm90b3R5cGUubm90aWZ5ID0gZnVuY3Rpb24gbm90aWZ5ICgpIHtcbiAgLy8gc3RhYmlsaXplIHRoZSBzdWJzY3JpYmVyIGxpc3QgZmlyc3RcbiAgdmFyIHN1YnMgPSB0aGlzLnN1YnMuc2xpY2UoKTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBzdWJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHN1YnNbaV0udXBkYXRlKCk7XG4gIH1cbn07XG5cbi8vIHRoZSBjdXJyZW50IHRhcmdldCB3YXRjaGVyIGJlaW5nIGV2YWx1YXRlZC5cbi8vIHRoaXMgaXMgZ2xvYmFsbHkgdW5pcXVlIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgb25seSBvbmVcbi8vIHdhdGNoZXIgYmVpbmcgZXZhbHVhdGVkIGF0IGFueSB0aW1lLlxuRGVwLnRhcmdldCA9IG51bGw7XG52YXIgdGFyZ2V0U3RhY2sgPSBbXTtcblxuZnVuY3Rpb24gcHVzaFRhcmdldCAoX3RhcmdldCkge1xuICBpZiAoRGVwLnRhcmdldCkgeyB0YXJnZXRTdGFjay5wdXNoKERlcC50YXJnZXQpOyB9XG4gIERlcC50YXJnZXQgPSBfdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBwb3BUYXJnZXQgKCkge1xuICBEZXAudGFyZ2V0ID0gdGFyZ2V0U3RhY2sucG9wKCk7XG59XG5cbi8qICAqL1xuXG52YXIgVk5vZGUgPSBmdW5jdGlvbiBWTm9kZSAoXG4gIHRhZyxcbiAgZGF0YSxcbiAgY2hpbGRyZW4sXG4gIHRleHQsXG4gIGVsbSxcbiAgY29udGV4dCxcbiAgY29tcG9uZW50T3B0aW9ucyxcbiAgYXN5bmNGYWN0b3J5XG4pIHtcbiAgdGhpcy50YWcgPSB0YWc7XG4gIHRoaXMuZGF0YSA9IGRhdGE7XG4gIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgdGhpcy5lbG0gPSBlbG07XG4gIHRoaXMubnMgPSB1bmRlZmluZWQ7XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMuZm5Db250ZXh0ID0gdW5kZWZpbmVkO1xuICB0aGlzLmZuT3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgdGhpcy5mblNjb3BlSWQgPSB1bmRlZmluZWQ7XG4gIHRoaXMua2V5ID0gZGF0YSAmJiBkYXRhLmtleTtcbiAgdGhpcy5jb21wb25lbnRPcHRpb25zID0gY29tcG9uZW50T3B0aW9ucztcbiAgdGhpcy5jb21wb25lbnRJbnN0YW5jZSA9IHVuZGVmaW5lZDtcbiAgdGhpcy5wYXJlbnQgPSB1bmRlZmluZWQ7XG4gIHRoaXMucmF3ID0gZmFsc2U7XG4gIHRoaXMuaXNTdGF0aWMgPSBmYWxzZTtcbiAgdGhpcy5pc1Jvb3RJbnNlcnQgPSB0cnVlO1xuICB0aGlzLmlzQ29tbWVudCA9IGZhbHNlO1xuICB0aGlzLmlzQ2xvbmVkID0gZmFsc2U7XG4gIHRoaXMuaXNPbmNlID0gZmFsc2U7XG4gIHRoaXMuYXN5bmNGYWN0b3J5ID0gYXN5bmNGYWN0b3J5O1xuICB0aGlzLmFzeW5jTWV0YSA9IHVuZGVmaW5lZDtcbiAgdGhpcy5pc0FzeW5jUGxhY2Vob2xkZXIgPSBmYWxzZTtcbn07XG5cbnZhciBwcm90b3R5cGVBY2Nlc3NvcnMgPSB7IGNoaWxkOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5cbi8vIERFUFJFQ0FURUQ6IGFsaWFzIGZvciBjb21wb25lbnRJbnN0YW5jZSBmb3IgYmFja3dhcmRzIGNvbXBhdC5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5wcm90b3R5cGVBY2Nlc3NvcnMuY2hpbGQuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5jb21wb25lbnRJbnN0YW5jZVxufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIFZOb2RlLnByb3RvdHlwZSwgcHJvdG90eXBlQWNjZXNzb3JzICk7XG5cbnZhciBjcmVhdGVFbXB0eVZOb2RlID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgaWYgKCB0ZXh0ID09PSB2b2lkIDAgKSB0ZXh0ID0gJyc7XG5cbiAgdmFyIG5vZGUgPSBuZXcgVk5vZGUoKTtcbiAgbm9kZS50ZXh0ID0gdGV4dDtcbiAgbm9kZS5pc0NvbW1lbnQgPSB0cnVlO1xuICByZXR1cm4gbm9kZVxufTtcblxuZnVuY3Rpb24gY3JlYXRlVGV4dFZOb2RlICh2YWwpIHtcbiAgcmV0dXJuIG5ldyBWTm9kZSh1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBTdHJpbmcodmFsKSlcbn1cblxuLy8gb3B0aW1pemVkIHNoYWxsb3cgY2xvbmVcbi8vIHVzZWQgZm9yIHN0YXRpYyBub2RlcyBhbmQgc2xvdCBub2RlcyBiZWNhdXNlIHRoZXkgbWF5IGJlIHJldXNlZCBhY3Jvc3Ncbi8vIG11bHRpcGxlIHJlbmRlcnMsIGNsb25pbmcgdGhlbSBhdm9pZHMgZXJyb3JzIHdoZW4gRE9NIG1hbmlwdWxhdGlvbnMgcmVseVxuLy8gb24gdGhlaXIgZWxtIHJlZmVyZW5jZS5cbmZ1bmN0aW9uIGNsb25lVk5vZGUgKHZub2RlKSB7XG4gIHZhciBjbG9uZWQgPSBuZXcgVk5vZGUoXG4gICAgdm5vZGUudGFnLFxuICAgIHZub2RlLmRhdGEsXG4gICAgdm5vZGUuY2hpbGRyZW4sXG4gICAgdm5vZGUudGV4dCxcbiAgICB2bm9kZS5lbG0sXG4gICAgdm5vZGUuY29udGV4dCxcbiAgICB2bm9kZS5jb21wb25lbnRPcHRpb25zLFxuICAgIHZub2RlLmFzeW5jRmFjdG9yeVxuICApO1xuICBjbG9uZWQubnMgPSB2bm9kZS5ucztcbiAgY2xvbmVkLmlzU3RhdGljID0gdm5vZGUuaXNTdGF0aWM7XG4gIGNsb25lZC5rZXkgPSB2bm9kZS5rZXk7XG4gIGNsb25lZC5pc0NvbW1lbnQgPSB2bm9kZS5pc0NvbW1lbnQ7XG4gIGNsb25lZC5mbkNvbnRleHQgPSB2bm9kZS5mbkNvbnRleHQ7XG4gIGNsb25lZC5mbk9wdGlvbnMgPSB2bm9kZS5mbk9wdGlvbnM7XG4gIGNsb25lZC5mblNjb3BlSWQgPSB2bm9kZS5mblNjb3BlSWQ7XG4gIGNsb25lZC5pc0Nsb25lZCA9IHRydWU7XG4gIHJldHVybiBjbG9uZWRcbn1cblxuLypcbiAqIG5vdCB0eXBlIGNoZWNraW5nIHRoaXMgZmlsZSBiZWNhdXNlIGZsb3cgZG9lc24ndCBwbGF5IHdlbGwgd2l0aFxuICogZHluYW1pY2FsbHkgYWNjZXNzaW5nIG1ldGhvZHMgb24gQXJyYXkgcHJvdG90eXBlXG4gKi9cblxudmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG52YXIgYXJyYXlNZXRob2RzID0gT2JqZWN0LmNyZWF0ZShhcnJheVByb3RvKTtcblxudmFyIG1ldGhvZHNUb1BhdGNoID0gW1xuICAncHVzaCcsXG4gICdwb3AnLFxuICAnc2hpZnQnLFxuICAndW5zaGlmdCcsXG4gICdzcGxpY2UnLFxuICAnc29ydCcsXG4gICdyZXZlcnNlJ1xuXTtcblxuLyoqXG4gKiBJbnRlcmNlcHQgbXV0YXRpbmcgbWV0aG9kcyBhbmQgZW1pdCBldmVudHNcbiAqL1xubWV0aG9kc1RvUGF0Y2guZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG4gIC8vIGNhY2hlIG9yaWdpbmFsIG1ldGhvZFxuICB2YXIgb3JpZ2luYWwgPSBhcnJheVByb3RvW21ldGhvZF07XG4gIGRlZihhcnJheU1ldGhvZHMsIG1ldGhvZCwgZnVuY3Rpb24gbXV0YXRvciAoKSB7XG4gICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgdmFyIHJlc3VsdCA9IG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIHZhciBvYiA9IHRoaXMuX19vYl9fO1xuICAgIHZhciBpbnNlcnRlZDtcbiAgICBzd2l0Y2ggKG1ldGhvZCkge1xuICAgICAgY2FzZSAncHVzaCc6XG4gICAgICBjYXNlICd1bnNoaWZ0JzpcbiAgICAgICAgaW5zZXJ0ZWQgPSBhcmdzO1xuICAgICAgICBicmVha1xuICAgICAgY2FzZSAnc3BsaWNlJzpcbiAgICAgICAgaW5zZXJ0ZWQgPSBhcmdzLnNsaWNlKDIpO1xuICAgICAgICBicmVha1xuICAgIH1cbiAgICBpZiAoaW5zZXJ0ZWQpIHsgb2Iub2JzZXJ2ZUFycmF5KGluc2VydGVkKTsgfVxuICAgIC8vIG5vdGlmeSBjaGFuZ2VcbiAgICBvYi5kZXAubm90aWZ5KCk7XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9KTtcbn0pO1xuXG4vKiAgKi9cblxudmFyIGFycmF5S2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGFycmF5TWV0aG9kcyk7XG5cbi8qKlxuICogSW4gc29tZSBjYXNlcyB3ZSBtYXkgd2FudCB0byBkaXNhYmxlIG9ic2VydmF0aW9uIGluc2lkZSBhIGNvbXBvbmVudCdzXG4gKiB1cGRhdGUgY29tcHV0YXRpb24uXG4gKi9cbnZhciBzaG91bGRPYnNlcnZlID0gdHJ1ZTtcblxuZnVuY3Rpb24gdG9nZ2xlT2JzZXJ2aW5nICh2YWx1ZSkge1xuICBzaG91bGRPYnNlcnZlID0gdmFsdWU7XG59XG5cbi8qKlxuICogT2JzZXJ2ZXIgY2xhc3MgdGhhdCBpcyBhdHRhY2hlZCB0byBlYWNoIG9ic2VydmVkXG4gKiBvYmplY3QuIE9uY2UgYXR0YWNoZWQsIHRoZSBvYnNlcnZlciBjb252ZXJ0cyB0aGUgdGFyZ2V0XG4gKiBvYmplY3QncyBwcm9wZXJ0eSBrZXlzIGludG8gZ2V0dGVyL3NldHRlcnMgdGhhdFxuICogY29sbGVjdCBkZXBlbmRlbmNpZXMgYW5kIGRpc3BhdGNoIHVwZGF0ZXMuXG4gKi9cbnZhciBPYnNlcnZlciA9IGZ1bmN0aW9uIE9ic2VydmVyICh2YWx1ZSkge1xuICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gIHRoaXMuZGVwID0gbmV3IERlcCgpO1xuICB0aGlzLnZtQ291bnQgPSAwO1xuICBkZWYodmFsdWUsICdfX29iX18nLCB0aGlzKTtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgdmFyIGF1Z21lbnQgPSBoYXNQcm90b1xuICAgICAgPyBwcm90b0F1Z21lbnRcbiAgICAgIDogY29weUF1Z21lbnQ7XG4gICAgYXVnbWVudCh2YWx1ZSwgYXJyYXlNZXRob2RzLCBhcnJheUtleXMpO1xuICAgIHRoaXMub2JzZXJ2ZUFycmF5KHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLndhbGsodmFsdWUpO1xuICB9XG59O1xuXG4vKipcbiAqIFdhbGsgdGhyb3VnaCBlYWNoIHByb3BlcnR5IGFuZCBjb252ZXJ0IHRoZW0gaW50b1xuICogZ2V0dGVyL3NldHRlcnMuIFRoaXMgbWV0aG9kIHNob3VsZCBvbmx5IGJlIGNhbGxlZCB3aGVuXG4gKiB2YWx1ZSB0eXBlIGlzIE9iamVjdC5cbiAqL1xuT2JzZXJ2ZXIucHJvdG90eXBlLndhbGsgPSBmdW5jdGlvbiB3YWxrIChvYmopIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBkZWZpbmVSZWFjdGl2ZShvYmosIGtleXNbaV0pO1xuICB9XG59O1xuXG4vKipcbiAqIE9ic2VydmUgYSBsaXN0IG9mIEFycmF5IGl0ZW1zLlxuICovXG5PYnNlcnZlci5wcm90b3R5cGUub2JzZXJ2ZUFycmF5ID0gZnVuY3Rpb24gb2JzZXJ2ZUFycmF5IChpdGVtcykge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGl0ZW1zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIG9ic2VydmUoaXRlbXNbaV0pO1xuICB9XG59O1xuXG4vLyBoZWxwZXJzXG5cbi8qKlxuICogQXVnbWVudCBhbiB0YXJnZXQgT2JqZWN0IG9yIEFycmF5IGJ5IGludGVyY2VwdGluZ1xuICogdGhlIHByb3RvdHlwZSBjaGFpbiB1c2luZyBfX3Byb3RvX19cbiAqL1xuZnVuY3Rpb24gcHJvdG9BdWdtZW50ICh0YXJnZXQsIHNyYywga2V5cykge1xuICAvKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuICB0YXJnZXQuX19wcm90b19fID0gc3JjO1xuICAvKiBlc2xpbnQtZW5hYmxlIG5vLXByb3RvICovXG59XG5cbi8qKlxuICogQXVnbWVudCBhbiB0YXJnZXQgT2JqZWN0IG9yIEFycmF5IGJ5IGRlZmluaW5nXG4gKiBoaWRkZW4gcHJvcGVydGllcy5cbiAqL1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIGNvcHlBdWdtZW50ICh0YXJnZXQsIHNyYywga2V5cykge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgZGVmKHRhcmdldCwga2V5LCBzcmNba2V5XSk7XG4gIH1cbn1cblxuLyoqXG4gKiBBdHRlbXB0IHRvIGNyZWF0ZSBhbiBvYnNlcnZlciBpbnN0YW5jZSBmb3IgYSB2YWx1ZSxcbiAqIHJldHVybnMgdGhlIG5ldyBvYnNlcnZlciBpZiBzdWNjZXNzZnVsbHkgb2JzZXJ2ZWQsXG4gKiBvciB0aGUgZXhpc3Rpbmcgb2JzZXJ2ZXIgaWYgdGhlIHZhbHVlIGFscmVhZHkgaGFzIG9uZS5cbiAqL1xuZnVuY3Rpb24gb2JzZXJ2ZSAodmFsdWUsIGFzUm9vdERhdGEpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkgfHwgdmFsdWUgaW5zdGFuY2VvZiBWTm9kZSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBvYjtcbiAgaWYgKGhhc093bih2YWx1ZSwgJ19fb2JfXycpICYmIHZhbHVlLl9fb2JfXyBpbnN0YW5jZW9mIE9ic2VydmVyKSB7XG4gICAgb2IgPSB2YWx1ZS5fX29iX187XG4gIH0gZWxzZSBpZiAoXG4gICAgc2hvdWxkT2JzZXJ2ZSAmJlxuICAgICFpc1NlcnZlclJlbmRlcmluZygpICYmXG4gICAgKEFycmF5LmlzQXJyYXkodmFsdWUpIHx8IGlzUGxhaW5PYmplY3QodmFsdWUpKSAmJlxuICAgIE9iamVjdC5pc0V4dGVuc2libGUodmFsdWUpICYmXG4gICAgIXZhbHVlLl9pc1Z1ZVxuICApIHtcbiAgICBvYiA9IG5ldyBPYnNlcnZlcih2YWx1ZSk7XG4gIH1cbiAgaWYgKGFzUm9vdERhdGEgJiYgb2IpIHtcbiAgICBvYi52bUNvdW50Kys7XG4gIH1cbiAgcmV0dXJuIG9iXG59XG5cbi8qKlxuICogRGVmaW5lIGEgcmVhY3RpdmUgcHJvcGVydHkgb24gYW4gT2JqZWN0LlxuICovXG5mdW5jdGlvbiBkZWZpbmVSZWFjdGl2ZSAoXG4gIG9iaixcbiAga2V5LFxuICB2YWwsXG4gIGN1c3RvbVNldHRlcixcbiAgc2hhbGxvd1xuKSB7XG4gIHZhciBkZXAgPSBuZXcgRGVwKCk7XG5cbiAgdmFyIHByb3BlcnR5ID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSk7XG4gIGlmIChwcm9wZXJ0eSAmJiBwcm9wZXJ0eS5jb25maWd1cmFibGUgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyBjYXRlciBmb3IgcHJlLWRlZmluZWQgZ2V0dGVyL3NldHRlcnNcbiAgdmFyIGdldHRlciA9IHByb3BlcnR5ICYmIHByb3BlcnR5LmdldDtcbiAgaWYgKCFnZXR0ZXIgJiYgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHZhbCA9IG9ialtrZXldO1xuICB9XG4gIHZhciBzZXR0ZXIgPSBwcm9wZXJ0eSAmJiBwcm9wZXJ0eS5zZXQ7XG5cbiAgdmFyIGNoaWxkT2IgPSAhc2hhbGxvdyAmJiBvYnNlcnZlKHZhbCk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gcmVhY3RpdmVHZXR0ZXIgKCkge1xuICAgICAgdmFyIHZhbHVlID0gZ2V0dGVyID8gZ2V0dGVyLmNhbGwob2JqKSA6IHZhbDtcbiAgICAgIGlmIChEZXAudGFyZ2V0KSB7XG4gICAgICAgIGRlcC5kZXBlbmQoKTtcbiAgICAgICAgaWYgKGNoaWxkT2IpIHtcbiAgICAgICAgICBjaGlsZE9iLmRlcC5kZXBlbmQoKTtcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGRlcGVuZEFycmF5KHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZVxuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiByZWFjdGl2ZVNldHRlciAobmV3VmFsKSB7XG4gICAgICB2YXIgdmFsdWUgPSBnZXR0ZXIgPyBnZXR0ZXIuY2FsbChvYmopIDogdmFsO1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tc2VsZi1jb21wYXJlICovXG4gICAgICBpZiAobmV3VmFsID09PSB2YWx1ZSB8fCAobmV3VmFsICE9PSBuZXdWYWwgJiYgdmFsdWUgIT09IHZhbHVlKSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tc2VsZi1jb21wYXJlICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjdXN0b21TZXR0ZXIpIHtcbiAgICAgICAgY3VzdG9tU2V0dGVyKCk7XG4gICAgICB9XG4gICAgICBpZiAoc2V0dGVyKSB7XG4gICAgICAgIHNldHRlci5jYWxsKG9iaiwgbmV3VmFsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbCA9IG5ld1ZhbDtcbiAgICAgIH1cbiAgICAgIGNoaWxkT2IgPSAhc2hhbGxvdyAmJiBvYnNlcnZlKG5ld1ZhbCk7XG4gICAgICBkZXAubm90aWZ5KCk7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBTZXQgYSBwcm9wZXJ0eSBvbiBhbiBvYmplY3QuIEFkZHMgdGhlIG5ldyBwcm9wZXJ0eSBhbmRcbiAqIHRyaWdnZXJzIGNoYW5nZSBub3RpZmljYXRpb24gaWYgdGhlIHByb3BlcnR5IGRvZXNuJ3RcbiAqIGFscmVhZHkgZXhpc3QuXG4gKi9cbmZ1bmN0aW9uIHNldCAodGFyZ2V0LCBrZXksIHZhbCkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgIChpc1VuZGVmKHRhcmdldCkgfHwgaXNQcmltaXRpdmUodGFyZ2V0KSlcbiAgKSB7XG4gICAgd2FybigoXCJDYW5ub3Qgc2V0IHJlYWN0aXZlIHByb3BlcnR5IG9uIHVuZGVmaW5lZCwgbnVsbCwgb3IgcHJpbWl0aXZlIHZhbHVlOiBcIiArICgodGFyZ2V0KSkpKTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXQpICYmIGlzVmFsaWRBcnJheUluZGV4KGtleSkpIHtcbiAgICB0YXJnZXQubGVuZ3RoID0gTWF0aC5tYXgodGFyZ2V0Lmxlbmd0aCwga2V5KTtcbiAgICB0YXJnZXQuc3BsaWNlKGtleSwgMSwgdmFsKTtcbiAgICByZXR1cm4gdmFsXG4gIH1cbiAgaWYgKGtleSBpbiB0YXJnZXQgJiYgIShrZXkgaW4gT2JqZWN0LnByb3RvdHlwZSkpIHtcbiAgICB0YXJnZXRba2V5XSA9IHZhbDtcbiAgICByZXR1cm4gdmFsXG4gIH1cbiAgdmFyIG9iID0gKHRhcmdldCkuX19vYl9fO1xuICBpZiAodGFyZ2V0Ll9pc1Z1ZSB8fCAob2IgJiYgb2Iudm1Db3VudCkpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAnQXZvaWQgYWRkaW5nIHJlYWN0aXZlIHByb3BlcnRpZXMgdG8gYSBWdWUgaW5zdGFuY2Ugb3IgaXRzIHJvb3QgJGRhdGEgJyArXG4gICAgICAnYXQgcnVudGltZSAtIGRlY2xhcmUgaXQgdXBmcm9udCBpbiB0aGUgZGF0YSBvcHRpb24uJ1xuICAgICk7XG4gICAgcmV0dXJuIHZhbFxuICB9XG4gIGlmICghb2IpIHtcbiAgICB0YXJnZXRba2V5XSA9IHZhbDtcbiAgICByZXR1cm4gdmFsXG4gIH1cbiAgZGVmaW5lUmVhY3RpdmUob2IudmFsdWUsIGtleSwgdmFsKTtcbiAgb2IuZGVwLm5vdGlmeSgpO1xuICByZXR1cm4gdmFsXG59XG5cbi8qKlxuICogRGVsZXRlIGEgcHJvcGVydHkgYW5kIHRyaWdnZXIgY2hhbmdlIGlmIG5lY2Vzc2FyeS5cbiAqL1xuZnVuY3Rpb24gZGVsICh0YXJnZXQsIGtleSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgIChpc1VuZGVmKHRhcmdldCkgfHwgaXNQcmltaXRpdmUodGFyZ2V0KSlcbiAgKSB7XG4gICAgd2FybigoXCJDYW5ub3QgZGVsZXRlIHJlYWN0aXZlIHByb3BlcnR5IG9uIHVuZGVmaW5lZCwgbnVsbCwgb3IgcHJpbWl0aXZlIHZhbHVlOiBcIiArICgodGFyZ2V0KSkpKTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXQpICYmIGlzVmFsaWRBcnJheUluZGV4KGtleSkpIHtcbiAgICB0YXJnZXQuc3BsaWNlKGtleSwgMSk7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIG9iID0gKHRhcmdldCkuX19vYl9fO1xuICBpZiAodGFyZ2V0Ll9pc1Z1ZSB8fCAob2IgJiYgb2Iudm1Db3VudCkpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAnQXZvaWQgZGVsZXRpbmcgcHJvcGVydGllcyBvbiBhIFZ1ZSBpbnN0YW5jZSBvciBpdHMgcm9vdCAkZGF0YSAnICtcbiAgICAgICctIGp1c3Qgc2V0IGl0IHRvIG51bGwuJ1xuICAgICk7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKCFoYXNPd24odGFyZ2V0LCBrZXkpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgZGVsZXRlIHRhcmdldFtrZXldO1xuICBpZiAoIW9iKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgb2IuZGVwLm5vdGlmeSgpO1xufVxuXG4vKipcbiAqIENvbGxlY3QgZGVwZW5kZW5jaWVzIG9uIGFycmF5IGVsZW1lbnRzIHdoZW4gdGhlIGFycmF5IGlzIHRvdWNoZWQsIHNpbmNlXG4gKiB3ZSBjYW5ub3QgaW50ZXJjZXB0IGFycmF5IGVsZW1lbnQgYWNjZXNzIGxpa2UgcHJvcGVydHkgZ2V0dGVycy5cbiAqL1xuZnVuY3Rpb24gZGVwZW5kQXJyYXkgKHZhbHVlKSB7XG4gIGZvciAodmFyIGUgPSAodm9pZCAwKSwgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBlID0gdmFsdWVbaV07XG4gICAgZSAmJiBlLl9fb2JfXyAmJiBlLl9fb2JfXy5kZXAuZGVwZW5kKCk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZSkpIHtcbiAgICAgIGRlcGVuZEFycmF5KGUpO1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBPcHRpb24gb3ZlcndyaXRpbmcgc3RyYXRlZ2llcyBhcmUgZnVuY3Rpb25zIHRoYXQgaGFuZGxlXG4gKiBob3cgdG8gbWVyZ2UgYSBwYXJlbnQgb3B0aW9uIHZhbHVlIGFuZCBhIGNoaWxkIG9wdGlvblxuICogdmFsdWUgaW50byB0aGUgZmluYWwgdmFsdWUuXG4gKi9cbnZhciBzdHJhdHMgPSBjb25maWcub3B0aW9uTWVyZ2VTdHJhdGVnaWVzO1xuXG4vKipcbiAqIE9wdGlvbnMgd2l0aCByZXN0cmljdGlvbnNcbiAqL1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgc3RyYXRzLmVsID0gc3RyYXRzLnByb3BzRGF0YSA9IGZ1bmN0aW9uIChwYXJlbnQsIGNoaWxkLCB2bSwga2V5KSB7XG4gICAgaWYgKCF2bSkge1xuICAgICAgd2FybihcbiAgICAgICAgXCJvcHRpb24gXFxcIlwiICsga2V5ICsgXCJcXFwiIGNhbiBvbmx5IGJlIHVzZWQgZHVyaW5nIGluc3RhbmNlIFwiICtcbiAgICAgICAgJ2NyZWF0aW9uIHdpdGggdGhlIGBuZXdgIGtleXdvcmQuJ1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlZmF1bHRTdHJhdChwYXJlbnQsIGNoaWxkKVxuICB9O1xufVxuXG4vKipcbiAqIEhlbHBlciB0aGF0IHJlY3Vyc2l2ZWx5IG1lcmdlcyB0d28gZGF0YSBvYmplY3RzIHRvZ2V0aGVyLlxuICovXG5mdW5jdGlvbiBtZXJnZURhdGEgKHRvLCBmcm9tKSB7XG4gIGlmICghZnJvbSkgeyByZXR1cm4gdG8gfVxuICB2YXIga2V5LCB0b1ZhbCwgZnJvbVZhbDtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhmcm9tKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAga2V5ID0ga2V5c1tpXTtcbiAgICB0b1ZhbCA9IHRvW2tleV07XG4gICAgZnJvbVZhbCA9IGZyb21ba2V5XTtcbiAgICBpZiAoIWhhc093bih0bywga2V5KSkge1xuICAgICAgc2V0KHRvLCBrZXksIGZyb21WYWwpO1xuICAgIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdCh0b1ZhbCkgJiYgaXNQbGFpbk9iamVjdChmcm9tVmFsKSkge1xuICAgICAgbWVyZ2VEYXRhKHRvVmFsLCBmcm9tVmFsKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRvXG59XG5cbi8qKlxuICogRGF0YVxuICovXG5mdW5jdGlvbiBtZXJnZURhdGFPckZuIChcbiAgcGFyZW50VmFsLFxuICBjaGlsZFZhbCxcbiAgdm1cbikge1xuICBpZiAoIXZtKSB7XG4gICAgLy8gaW4gYSBWdWUuZXh0ZW5kIG1lcmdlLCBib3RoIHNob3VsZCBiZSBmdW5jdGlvbnNcbiAgICBpZiAoIWNoaWxkVmFsKSB7XG4gICAgICByZXR1cm4gcGFyZW50VmFsXG4gICAgfVxuICAgIGlmICghcGFyZW50VmFsKSB7XG4gICAgICByZXR1cm4gY2hpbGRWYWxcbiAgICB9XG4gICAgLy8gd2hlbiBwYXJlbnRWYWwgJiBjaGlsZFZhbCBhcmUgYm90aCBwcmVzZW50LFxuICAgIC8vIHdlIG5lZWQgdG8gcmV0dXJuIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZVxuICAgIC8vIG1lcmdlZCByZXN1bHQgb2YgYm90aCBmdW5jdGlvbnMuLi4gbm8gbmVlZCB0b1xuICAgIC8vIGNoZWNrIGlmIHBhcmVudFZhbCBpcyBhIGZ1bmN0aW9uIGhlcmUgYmVjYXVzZVxuICAgIC8vIGl0IGhhcyB0byBiZSBhIGZ1bmN0aW9uIHRvIHBhc3MgcHJldmlvdXMgbWVyZ2VzLlxuICAgIHJldHVybiBmdW5jdGlvbiBtZXJnZWREYXRhRm4gKCkge1xuICAgICAgcmV0dXJuIG1lcmdlRGF0YShcbiAgICAgICAgdHlwZW9mIGNoaWxkVmFsID09PSAnZnVuY3Rpb24nID8gY2hpbGRWYWwuY2FsbCh0aGlzLCB0aGlzKSA6IGNoaWxkVmFsLFxuICAgICAgICB0eXBlb2YgcGFyZW50VmFsID09PSAnZnVuY3Rpb24nID8gcGFyZW50VmFsLmNhbGwodGhpcywgdGhpcykgOiBwYXJlbnRWYWxcbiAgICAgIClcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1lcmdlZEluc3RhbmNlRGF0YUZuICgpIHtcbiAgICAgIC8vIGluc3RhbmNlIG1lcmdlXG4gICAgICB2YXIgaW5zdGFuY2VEYXRhID0gdHlwZW9mIGNoaWxkVmFsID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gY2hpbGRWYWwuY2FsbCh2bSwgdm0pXG4gICAgICAgIDogY2hpbGRWYWw7XG4gICAgICB2YXIgZGVmYXVsdERhdGEgPSB0eXBlb2YgcGFyZW50VmFsID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gcGFyZW50VmFsLmNhbGwodm0sIHZtKVxuICAgICAgICA6IHBhcmVudFZhbDtcbiAgICAgIGlmIChpbnN0YW5jZURhdGEpIHtcbiAgICAgICAgcmV0dXJuIG1lcmdlRGF0YShpbnN0YW5jZURhdGEsIGRlZmF1bHREYXRhKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHREYXRhXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnN0cmF0cy5kYXRhID0gZnVuY3Rpb24gKFxuICBwYXJlbnRWYWwsXG4gIGNoaWxkVmFsLFxuICB2bVxuKSB7XG4gIGlmICghdm0pIHtcbiAgICBpZiAoY2hpbGRWYWwgJiYgdHlwZW9mIGNoaWxkVmFsICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgICdUaGUgXCJkYXRhXCIgb3B0aW9uIHNob3VsZCBiZSBhIGZ1bmN0aW9uICcgK1xuICAgICAgICAndGhhdCByZXR1cm5zIGEgcGVyLWluc3RhbmNlIHZhbHVlIGluIGNvbXBvbmVudCAnICtcbiAgICAgICAgJ2RlZmluaXRpb25zLicsXG4gICAgICAgIHZtXG4gICAgICApO1xuXG4gICAgICByZXR1cm4gcGFyZW50VmFsXG4gICAgfVxuICAgIHJldHVybiBtZXJnZURhdGFPckZuKHBhcmVudFZhbCwgY2hpbGRWYWwpXG4gIH1cblxuICByZXR1cm4gbWVyZ2VEYXRhT3JGbihwYXJlbnRWYWwsIGNoaWxkVmFsLCB2bSlcbn07XG5cbi8qKlxuICogSG9va3MgYW5kIHByb3BzIGFyZSBtZXJnZWQgYXMgYXJyYXlzLlxuICovXG5mdW5jdGlvbiBtZXJnZUhvb2sgKFxuICBwYXJlbnRWYWwsXG4gIGNoaWxkVmFsXG4pIHtcbiAgcmV0dXJuIGNoaWxkVmFsXG4gICAgPyBwYXJlbnRWYWxcbiAgICAgID8gcGFyZW50VmFsLmNvbmNhdChjaGlsZFZhbClcbiAgICAgIDogQXJyYXkuaXNBcnJheShjaGlsZFZhbClcbiAgICAgICAgPyBjaGlsZFZhbFxuICAgICAgICA6IFtjaGlsZFZhbF1cbiAgICA6IHBhcmVudFZhbFxufVxuXG5MSUZFQ1lDTEVfSE9PS1MuZm9yRWFjaChmdW5jdGlvbiAoaG9vaykge1xuICBzdHJhdHNbaG9va10gPSBtZXJnZUhvb2s7XG59KTtcblxuLyoqXG4gKiBBc3NldHNcbiAqXG4gKiBXaGVuIGEgdm0gaXMgcHJlc2VudCAoaW5zdGFuY2UgY3JlYXRpb24pLCB3ZSBuZWVkIHRvIGRvXG4gKiBhIHRocmVlLXdheSBtZXJnZSBiZXR3ZWVuIGNvbnN0cnVjdG9yIG9wdGlvbnMsIGluc3RhbmNlXG4gKiBvcHRpb25zIGFuZCBwYXJlbnQgb3B0aW9ucy5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VBc3NldHMgKFxuICBwYXJlbnRWYWwsXG4gIGNoaWxkVmFsLFxuICB2bSxcbiAga2V5XG4pIHtcbiAgdmFyIHJlcyA9IE9iamVjdC5jcmVhdGUocGFyZW50VmFsIHx8IG51bGwpO1xuICBpZiAoY2hpbGRWYWwpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGFzc2VydE9iamVjdFR5cGUoa2V5LCBjaGlsZFZhbCwgdm0pO1xuICAgIHJldHVybiBleHRlbmQocmVzLCBjaGlsZFZhbClcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcmVzXG4gIH1cbn1cblxuQVNTRVRfVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICBzdHJhdHNbdHlwZSArICdzJ10gPSBtZXJnZUFzc2V0cztcbn0pO1xuXG4vKipcbiAqIFdhdGNoZXJzLlxuICpcbiAqIFdhdGNoZXJzIGhhc2hlcyBzaG91bGQgbm90IG92ZXJ3cml0ZSBvbmVcbiAqIGFub3RoZXIsIHNvIHdlIG1lcmdlIHRoZW0gYXMgYXJyYXlzLlxuICovXG5zdHJhdHMud2F0Y2ggPSBmdW5jdGlvbiAoXG4gIHBhcmVudFZhbCxcbiAgY2hpbGRWYWwsXG4gIHZtLFxuICBrZXlcbikge1xuICAvLyB3b3JrIGFyb3VuZCBGaXJlZm94J3MgT2JqZWN0LnByb3RvdHlwZS53YXRjaC4uLlxuICBpZiAocGFyZW50VmFsID09PSBuYXRpdmVXYXRjaCkgeyBwYXJlbnRWYWwgPSB1bmRlZmluZWQ7IH1cbiAgaWYgKGNoaWxkVmFsID09PSBuYXRpdmVXYXRjaCkgeyBjaGlsZFZhbCA9IHVuZGVmaW5lZDsgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFjaGlsZFZhbCkgeyByZXR1cm4gT2JqZWN0LmNyZWF0ZShwYXJlbnRWYWwgfHwgbnVsbCkgfVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGFzc2VydE9iamVjdFR5cGUoa2V5LCBjaGlsZFZhbCwgdm0pO1xuICB9XG4gIGlmICghcGFyZW50VmFsKSB7IHJldHVybiBjaGlsZFZhbCB9XG4gIHZhciByZXQgPSB7fTtcbiAgZXh0ZW5kKHJldCwgcGFyZW50VmFsKTtcbiAgZm9yICh2YXIga2V5JDEgaW4gY2hpbGRWYWwpIHtcbiAgICB2YXIgcGFyZW50ID0gcmV0W2tleSQxXTtcbiAgICB2YXIgY2hpbGQgPSBjaGlsZFZhbFtrZXkkMV07XG4gICAgaWYgKHBhcmVudCAmJiAhQXJyYXkuaXNBcnJheShwYXJlbnQpKSB7XG4gICAgICBwYXJlbnQgPSBbcGFyZW50XTtcbiAgICB9XG4gICAgcmV0W2tleSQxXSA9IHBhcmVudFxuICAgICAgPyBwYXJlbnQuY29uY2F0KGNoaWxkKVxuICAgICAgOiBBcnJheS5pc0FycmF5KGNoaWxkKSA/IGNoaWxkIDogW2NoaWxkXTtcbiAgfVxuICByZXR1cm4gcmV0XG59O1xuXG4vKipcbiAqIE90aGVyIG9iamVjdCBoYXNoZXMuXG4gKi9cbnN0cmF0cy5wcm9wcyA9XG5zdHJhdHMubWV0aG9kcyA9XG5zdHJhdHMuaW5qZWN0ID1cbnN0cmF0cy5jb21wdXRlZCA9IGZ1bmN0aW9uIChcbiAgcGFyZW50VmFsLFxuICBjaGlsZFZhbCxcbiAgdm0sXG4gIGtleVxuKSB7XG4gIGlmIChjaGlsZFZhbCAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgYXNzZXJ0T2JqZWN0VHlwZShrZXksIGNoaWxkVmFsLCB2bSk7XG4gIH1cbiAgaWYgKCFwYXJlbnRWYWwpIHsgcmV0dXJuIGNoaWxkVmFsIH1cbiAgdmFyIHJldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGV4dGVuZChyZXQsIHBhcmVudFZhbCk7XG4gIGlmIChjaGlsZFZhbCkgeyBleHRlbmQocmV0LCBjaGlsZFZhbCk7IH1cbiAgcmV0dXJuIHJldFxufTtcbnN0cmF0cy5wcm92aWRlID0gbWVyZ2VEYXRhT3JGbjtcblxuLyoqXG4gKiBEZWZhdWx0IHN0cmF0ZWd5LlxuICovXG52YXIgZGVmYXVsdFN0cmF0ID0gZnVuY3Rpb24gKHBhcmVudFZhbCwgY2hpbGRWYWwpIHtcbiAgcmV0dXJuIGNoaWxkVmFsID09PSB1bmRlZmluZWRcbiAgICA/IHBhcmVudFZhbFxuICAgIDogY2hpbGRWYWxcbn07XG5cbi8qKlxuICogVmFsaWRhdGUgY29tcG9uZW50IG5hbWVzXG4gKi9cbmZ1bmN0aW9uIGNoZWNrQ29tcG9uZW50cyAob3B0aW9ucykge1xuICBmb3IgKHZhciBrZXkgaW4gb3B0aW9ucy5jb21wb25lbnRzKSB7XG4gICAgdmFsaWRhdGVDb21wb25lbnROYW1lKGtleSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVDb21wb25lbnROYW1lIChuYW1lKSB7XG4gIGlmICghL15bYS16QS1aXVtcXHctXSokLy50ZXN0KG5hbWUpKSB7XG4gICAgd2FybihcbiAgICAgICdJbnZhbGlkIGNvbXBvbmVudCBuYW1lOiBcIicgKyBuYW1lICsgJ1wiLiBDb21wb25lbnQgbmFtZXMgJyArXG4gICAgICAnY2FuIG9ubHkgY29udGFpbiBhbHBoYW51bWVyaWMgY2hhcmFjdGVycyBhbmQgdGhlIGh5cGhlbiwgJyArXG4gICAgICAnYW5kIG11c3Qgc3RhcnQgd2l0aCBhIGxldHRlci4nXG4gICAgKTtcbiAgfVxuICBpZiAoaXNCdWlsdEluVGFnKG5hbWUpIHx8IGNvbmZpZy5pc1Jlc2VydmVkVGFnKG5hbWUpKSB7XG4gICAgd2FybihcbiAgICAgICdEbyBub3QgdXNlIGJ1aWx0LWluIG9yIHJlc2VydmVkIEhUTUwgZWxlbWVudHMgYXMgY29tcG9uZW50ICcgK1xuICAgICAgJ2lkOiAnICsgbmFtZVxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBFbnN1cmUgYWxsIHByb3BzIG9wdGlvbiBzeW50YXggYXJlIG5vcm1hbGl6ZWQgaW50byB0aGVcbiAqIE9iamVjdC1iYXNlZCBmb3JtYXQuXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZVByb3BzIChvcHRpb25zLCB2bSkge1xuICB2YXIgcHJvcHMgPSBvcHRpb25zLnByb3BzO1xuICBpZiAoIXByb3BzKSB7IHJldHVybiB9XG4gIHZhciByZXMgPSB7fTtcbiAgdmFyIGksIHZhbCwgbmFtZTtcbiAgaWYgKEFycmF5LmlzQXJyYXkocHJvcHMpKSB7XG4gICAgaSA9IHByb3BzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB2YWwgPSBwcm9wc1tpXTtcbiAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgICAgICBuYW1lID0gY2FtZWxpemUodmFsKTtcbiAgICAgICAgcmVzW25hbWVdID0geyB0eXBlOiBudWxsIH07XG4gICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgd2FybigncHJvcHMgbXVzdCBiZSBzdHJpbmdzIHdoZW4gdXNpbmcgYXJyYXkgc3ludGF4LicpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHByb3BzKSkge1xuICAgIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgICAgdmFsID0gcHJvcHNba2V5XTtcbiAgICAgIG5hbWUgPSBjYW1lbGl6ZShrZXkpO1xuICAgICAgcmVzW25hbWVdID0gaXNQbGFpbk9iamVjdCh2YWwpXG4gICAgICAgID8gdmFsXG4gICAgICAgIDogeyB0eXBlOiB2YWwgfTtcbiAgICB9XG4gIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHdhcm4oXG4gICAgICBcIkludmFsaWQgdmFsdWUgZm9yIG9wdGlvbiBcXFwicHJvcHNcXFwiOiBleHBlY3RlZCBhbiBBcnJheSBvciBhbiBPYmplY3QsIFwiICtcbiAgICAgIFwiYnV0IGdvdCBcIiArICh0b1Jhd1R5cGUocHJvcHMpKSArIFwiLlwiLFxuICAgICAgdm1cbiAgICApO1xuICB9XG4gIG9wdGlvbnMucHJvcHMgPSByZXM7XG59XG5cbi8qKlxuICogTm9ybWFsaXplIGFsbCBpbmplY3Rpb25zIGludG8gT2JqZWN0LWJhc2VkIGZvcm1hdFxuICovXG5mdW5jdGlvbiBub3JtYWxpemVJbmplY3QgKG9wdGlvbnMsIHZtKSB7XG4gIHZhciBpbmplY3QgPSBvcHRpb25zLmluamVjdDtcbiAgaWYgKCFpbmplY3QpIHsgcmV0dXJuIH1cbiAgdmFyIG5vcm1hbGl6ZWQgPSBvcHRpb25zLmluamVjdCA9IHt9O1xuICBpZiAoQXJyYXkuaXNBcnJheShpbmplY3QpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmplY3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIG5vcm1hbGl6ZWRbaW5qZWN0W2ldXSA9IHsgZnJvbTogaW5qZWN0W2ldIH07XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QoaW5qZWN0KSkge1xuICAgIGZvciAodmFyIGtleSBpbiBpbmplY3QpIHtcbiAgICAgIHZhciB2YWwgPSBpbmplY3Rba2V5XTtcbiAgICAgIG5vcm1hbGl6ZWRba2V5XSA9IGlzUGxhaW5PYmplY3QodmFsKVxuICAgICAgICA/IGV4dGVuZCh7IGZyb206IGtleSB9LCB2YWwpXG4gICAgICAgIDogeyBmcm9tOiB2YWwgfTtcbiAgICB9XG4gIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHdhcm4oXG4gICAgICBcIkludmFsaWQgdmFsdWUgZm9yIG9wdGlvbiBcXFwiaW5qZWN0XFxcIjogZXhwZWN0ZWQgYW4gQXJyYXkgb3IgYW4gT2JqZWN0LCBcIiArXG4gICAgICBcImJ1dCBnb3QgXCIgKyAodG9SYXdUeXBlKGluamVjdCkpICsgXCIuXCIsXG4gICAgICB2bVxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgcmF3IGZ1bmN0aW9uIGRpcmVjdGl2ZXMgaW50byBvYmplY3QgZm9ybWF0LlxuICovXG5mdW5jdGlvbiBub3JtYWxpemVEaXJlY3RpdmVzIChvcHRpb25zKSB7XG4gIHZhciBkaXJzID0gb3B0aW9ucy5kaXJlY3RpdmVzO1xuICBpZiAoZGlycykge1xuICAgIGZvciAodmFyIGtleSBpbiBkaXJzKSB7XG4gICAgICB2YXIgZGVmID0gZGlyc1trZXldO1xuICAgICAgaWYgKHR5cGVvZiBkZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZGlyc1trZXldID0geyBiaW5kOiBkZWYsIHVwZGF0ZTogZGVmIH07XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2VydE9iamVjdFR5cGUgKG5hbWUsIHZhbHVlLCB2bSkge1xuICBpZiAoIWlzUGxhaW5PYmplY3QodmFsdWUpKSB7XG4gICAgd2FybihcbiAgICAgIFwiSW52YWxpZCB2YWx1ZSBmb3Igb3B0aW9uIFxcXCJcIiArIG5hbWUgKyBcIlxcXCI6IGV4cGVjdGVkIGFuIE9iamVjdCwgXCIgK1xuICAgICAgXCJidXQgZ290IFwiICsgKHRvUmF3VHlwZSh2YWx1ZSkpICsgXCIuXCIsXG4gICAgICB2bVxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBNZXJnZSB0d28gb3B0aW9uIG9iamVjdHMgaW50byBhIG5ldyBvbmUuXG4gKiBDb3JlIHV0aWxpdHkgdXNlZCBpbiBib3RoIGluc3RhbnRpYXRpb24gYW5kIGluaGVyaXRhbmNlLlxuICovXG5mdW5jdGlvbiBtZXJnZU9wdGlvbnMgKFxuICBwYXJlbnQsXG4gIGNoaWxkLFxuICB2bVxuKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgY2hlY2tDb21wb25lbnRzKGNoaWxkKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgY2hpbGQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjaGlsZCA9IGNoaWxkLm9wdGlvbnM7XG4gIH1cblxuICBub3JtYWxpemVQcm9wcyhjaGlsZCwgdm0pO1xuICBub3JtYWxpemVJbmplY3QoY2hpbGQsIHZtKTtcbiAgbm9ybWFsaXplRGlyZWN0aXZlcyhjaGlsZCk7XG4gIHZhciBleHRlbmRzRnJvbSA9IGNoaWxkLmV4dGVuZHM7XG4gIGlmIChleHRlbmRzRnJvbSkge1xuICAgIHBhcmVudCA9IG1lcmdlT3B0aW9ucyhwYXJlbnQsIGV4dGVuZHNGcm9tLCB2bSk7XG4gIH1cbiAgaWYgKGNoaWxkLm1peGlucykge1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGQubWl4aW5zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgcGFyZW50ID0gbWVyZ2VPcHRpb25zKHBhcmVudCwgY2hpbGQubWl4aW5zW2ldLCB2bSk7XG4gICAgfVxuICB9XG4gIHZhciBvcHRpb25zID0ge307XG4gIHZhciBrZXk7XG4gIGZvciAoa2V5IGluIHBhcmVudCkge1xuICAgIG1lcmdlRmllbGQoa2V5KTtcbiAgfVxuICBmb3IgKGtleSBpbiBjaGlsZCkge1xuICAgIGlmICghaGFzT3duKHBhcmVudCwga2V5KSkge1xuICAgICAgbWVyZ2VGaWVsZChrZXkpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBtZXJnZUZpZWxkIChrZXkpIHtcbiAgICB2YXIgc3RyYXQgPSBzdHJhdHNba2V5XSB8fCBkZWZhdWx0U3RyYXQ7XG4gICAgb3B0aW9uc1trZXldID0gc3RyYXQocGFyZW50W2tleV0sIGNoaWxkW2tleV0sIHZtLCBrZXkpO1xuICB9XG4gIHJldHVybiBvcHRpb25zXG59XG5cbi8qKlxuICogUmVzb2x2ZSBhbiBhc3NldC5cbiAqIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCBiZWNhdXNlIGNoaWxkIGluc3RhbmNlcyBuZWVkIGFjY2Vzc1xuICogdG8gYXNzZXRzIGRlZmluZWQgaW4gaXRzIGFuY2VzdG9yIGNoYWluLlxuICovXG5mdW5jdGlvbiByZXNvbHZlQXNzZXQgKFxuICBvcHRpb25zLFxuICB0eXBlLFxuICBpZCxcbiAgd2Fybk1pc3Npbmdcbikge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHR5cGVvZiBpZCAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgYXNzZXRzID0gb3B0aW9uc1t0eXBlXTtcbiAgLy8gY2hlY2sgbG9jYWwgcmVnaXN0cmF0aW9uIHZhcmlhdGlvbnMgZmlyc3RcbiAgaWYgKGhhc093bihhc3NldHMsIGlkKSkgeyByZXR1cm4gYXNzZXRzW2lkXSB9XG4gIHZhciBjYW1lbGl6ZWRJZCA9IGNhbWVsaXplKGlkKTtcbiAgaWYgKGhhc093bihhc3NldHMsIGNhbWVsaXplZElkKSkgeyByZXR1cm4gYXNzZXRzW2NhbWVsaXplZElkXSB9XG4gIHZhciBQYXNjYWxDYXNlSWQgPSBjYXBpdGFsaXplKGNhbWVsaXplZElkKTtcbiAgaWYgKGhhc093bihhc3NldHMsIFBhc2NhbENhc2VJZCkpIHsgcmV0dXJuIGFzc2V0c1tQYXNjYWxDYXNlSWRdIH1cbiAgLy8gZmFsbGJhY2sgdG8gcHJvdG90eXBlIGNoYWluXG4gIHZhciByZXMgPSBhc3NldHNbaWRdIHx8IGFzc2V0c1tjYW1lbGl6ZWRJZF0gfHwgYXNzZXRzW1Bhc2NhbENhc2VJZF07XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm5NaXNzaW5nICYmICFyZXMpIHtcbiAgICB3YXJuKFxuICAgICAgJ0ZhaWxlZCB0byByZXNvbHZlICcgKyB0eXBlLnNsaWNlKDAsIC0xKSArICc6ICcgKyBpZCxcbiAgICAgIG9wdGlvbnNcbiAgICApO1xuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcCAoXG4gIGtleSxcbiAgcHJvcE9wdGlvbnMsXG4gIHByb3BzRGF0YSxcbiAgdm1cbikge1xuICB2YXIgcHJvcCA9IHByb3BPcHRpb25zW2tleV07XG4gIHZhciBhYnNlbnQgPSAhaGFzT3duKHByb3BzRGF0YSwga2V5KTtcbiAgdmFyIHZhbHVlID0gcHJvcHNEYXRhW2tleV07XG4gIC8vIGJvb2xlYW4gY2FzdGluZ1xuICB2YXIgYm9vbGVhbkluZGV4ID0gZ2V0VHlwZUluZGV4KEJvb2xlYW4sIHByb3AudHlwZSk7XG4gIGlmIChib29sZWFuSW5kZXggPiAtMSkge1xuICAgIGlmIChhYnNlbnQgJiYgIWhhc093bihwcm9wLCAnZGVmYXVsdCcpKSB7XG4gICAgICB2YWx1ZSA9IGZhbHNlO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgPT09ICcnIHx8IHZhbHVlID09PSBoeXBoZW5hdGUoa2V5KSkge1xuICAgICAgLy8gb25seSBjYXN0IGVtcHR5IHN0cmluZyAvIHNhbWUgbmFtZSB0byBib29sZWFuIGlmXG4gICAgICAvLyBib29sZWFuIGhhcyBoaWdoZXIgcHJpb3JpdHlcbiAgICAgIHZhciBzdHJpbmdJbmRleCA9IGdldFR5cGVJbmRleChTdHJpbmcsIHByb3AudHlwZSk7XG4gICAgICBpZiAoc3RyaW5nSW5kZXggPCAwIHx8IGJvb2xlYW5JbmRleCA8IHN0cmluZ0luZGV4KSB7XG4gICAgICAgIHZhbHVlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy8gY2hlY2sgZGVmYXVsdCB2YWx1ZVxuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHZhbHVlID0gZ2V0UHJvcERlZmF1bHRWYWx1ZSh2bSwgcHJvcCwga2V5KTtcbiAgICAvLyBzaW5jZSB0aGUgZGVmYXVsdCB2YWx1ZSBpcyBhIGZyZXNoIGNvcHksXG4gICAgLy8gbWFrZSBzdXJlIHRvIG9ic2VydmUgaXQuXG4gICAgdmFyIHByZXZTaG91bGRPYnNlcnZlID0gc2hvdWxkT2JzZXJ2ZTtcbiAgICB0b2dnbGVPYnNlcnZpbmcodHJ1ZSk7XG4gICAgb2JzZXJ2ZSh2YWx1ZSk7XG4gICAgdG9nZ2xlT2JzZXJ2aW5nKHByZXZTaG91bGRPYnNlcnZlKTtcbiAgfVxuICBpZiAoXG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgIC8vIHNraXAgdmFsaWRhdGlvbiBmb3Igd2VleCByZWN5Y2xlLWxpc3QgY2hpbGQgY29tcG9uZW50IHByb3BzXG4gICAgIShmYWxzZSAmJiBpc09iamVjdCh2YWx1ZSkgJiYgKCdAYmluZGluZycgaW4gdmFsdWUpKVxuICApIHtcbiAgICBhc3NlcnRQcm9wKHByb3AsIGtleSwgdmFsdWUsIHZtLCBhYnNlbnQpO1xuICB9XG4gIHJldHVybiB2YWx1ZVxufVxuXG4vKipcbiAqIEdldCB0aGUgZGVmYXVsdCB2YWx1ZSBvZiBhIHByb3AuXG4gKi9cbmZ1bmN0aW9uIGdldFByb3BEZWZhdWx0VmFsdWUgKHZtLCBwcm9wLCBrZXkpIHtcbiAgLy8gbm8gZGVmYXVsdCwgcmV0dXJuIHVuZGVmaW5lZFxuICBpZiAoIWhhc093bihwcm9wLCAnZGVmYXVsdCcpKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZFxuICB9XG4gIHZhciBkZWYgPSBwcm9wLmRlZmF1bHQ7XG4gIC8vIHdhcm4gYWdhaW5zdCBub24tZmFjdG9yeSBkZWZhdWx0cyBmb3IgT2JqZWN0ICYgQXJyYXlcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgaXNPYmplY3QoZGVmKSkge1xuICAgIHdhcm4oXG4gICAgICAnSW52YWxpZCBkZWZhdWx0IHZhbHVlIGZvciBwcm9wIFwiJyArIGtleSArICdcIjogJyArXG4gICAgICAnUHJvcHMgd2l0aCB0eXBlIE9iamVjdC9BcnJheSBtdXN0IHVzZSBhIGZhY3RvcnkgZnVuY3Rpb24gJyArXG4gICAgICAndG8gcmV0dXJuIHRoZSBkZWZhdWx0IHZhbHVlLicsXG4gICAgICB2bVxuICAgICk7XG4gIH1cbiAgLy8gdGhlIHJhdyBwcm9wIHZhbHVlIHdhcyBhbHNvIHVuZGVmaW5lZCBmcm9tIHByZXZpb3VzIHJlbmRlcixcbiAgLy8gcmV0dXJuIHByZXZpb3VzIGRlZmF1bHQgdmFsdWUgdG8gYXZvaWQgdW5uZWNlc3Nhcnkgd2F0Y2hlciB0cmlnZ2VyXG4gIGlmICh2bSAmJiB2bS4kb3B0aW9ucy5wcm9wc0RhdGEgJiZcbiAgICB2bS4kb3B0aW9ucy5wcm9wc0RhdGFba2V5XSA9PT0gdW5kZWZpbmVkICYmXG4gICAgdm0uX3Byb3BzW2tleV0gIT09IHVuZGVmaW5lZFxuICApIHtcbiAgICByZXR1cm4gdm0uX3Byb3BzW2tleV1cbiAgfVxuICAvLyBjYWxsIGZhY3RvcnkgZnVuY3Rpb24gZm9yIG5vbi1GdW5jdGlvbiB0eXBlc1xuICAvLyBhIHZhbHVlIGlzIEZ1bmN0aW9uIGlmIGl0cyBwcm90b3R5cGUgaXMgZnVuY3Rpb24gZXZlbiBhY3Jvc3MgZGlmZmVyZW50IGV4ZWN1dGlvbiBjb250ZXh0XG4gIHJldHVybiB0eXBlb2YgZGVmID09PSAnZnVuY3Rpb24nICYmIGdldFR5cGUocHJvcC50eXBlKSAhPT0gJ0Z1bmN0aW9uJ1xuICAgID8gZGVmLmNhbGwodm0pXG4gICAgOiBkZWZcbn1cblxuLyoqXG4gKiBBc3NlcnQgd2hldGhlciBhIHByb3AgaXMgdmFsaWQuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydFByb3AgKFxuICBwcm9wLFxuICBuYW1lLFxuICB2YWx1ZSxcbiAgdm0sXG4gIGFic2VudFxuKSB7XG4gIGlmIChwcm9wLnJlcXVpcmVkICYmIGFic2VudCkge1xuICAgIHdhcm4oXG4gICAgICAnTWlzc2luZyByZXF1aXJlZCBwcm9wOiBcIicgKyBuYW1lICsgJ1wiJyxcbiAgICAgIHZtXG4gICAgKTtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAodmFsdWUgPT0gbnVsbCAmJiAhcHJvcC5yZXF1aXJlZCkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciB0eXBlID0gcHJvcC50eXBlO1xuICB2YXIgdmFsaWQgPSAhdHlwZSB8fCB0eXBlID09PSB0cnVlO1xuICB2YXIgZXhwZWN0ZWRUeXBlcyA9IFtdO1xuICBpZiAodHlwZSkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh0eXBlKSkge1xuICAgICAgdHlwZSA9IFt0eXBlXTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlLmxlbmd0aCAmJiAhdmFsaWQ7IGkrKykge1xuICAgICAgdmFyIGFzc2VydGVkVHlwZSA9IGFzc2VydFR5cGUodmFsdWUsIHR5cGVbaV0pO1xuICAgICAgZXhwZWN0ZWRUeXBlcy5wdXNoKGFzc2VydGVkVHlwZS5leHBlY3RlZFR5cGUgfHwgJycpO1xuICAgICAgdmFsaWQgPSBhc3NlcnRlZFR5cGUudmFsaWQ7XG4gICAgfVxuICB9XG4gIGlmICghdmFsaWQpIHtcbiAgICB3YXJuKFxuICAgICAgXCJJbnZhbGlkIHByb3A6IHR5cGUgY2hlY2sgZmFpbGVkIGZvciBwcm9wIFxcXCJcIiArIG5hbWUgKyBcIlxcXCIuXCIgK1xuICAgICAgXCIgRXhwZWN0ZWQgXCIgKyAoZXhwZWN0ZWRUeXBlcy5tYXAoY2FwaXRhbGl6ZSkuam9pbignLCAnKSkgK1xuICAgICAgXCIsIGdvdCBcIiArICh0b1Jhd1R5cGUodmFsdWUpKSArIFwiLlwiLFxuICAgICAgdm1cbiAgICApO1xuICAgIHJldHVyblxuICB9XG4gIHZhciB2YWxpZGF0b3IgPSBwcm9wLnZhbGlkYXRvcjtcbiAgaWYgKHZhbGlkYXRvcikge1xuICAgIGlmICghdmFsaWRhdG9yKHZhbHVlKSkge1xuICAgICAgd2FybihcbiAgICAgICAgJ0ludmFsaWQgcHJvcDogY3VzdG9tIHZhbGlkYXRvciBjaGVjayBmYWlsZWQgZm9yIHByb3AgXCInICsgbmFtZSArICdcIi4nLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIHNpbXBsZUNoZWNrUkUgPSAvXihTdHJpbmd8TnVtYmVyfEJvb2xlYW58RnVuY3Rpb258U3ltYm9sKSQvO1xuXG5mdW5jdGlvbiBhc3NlcnRUeXBlICh2YWx1ZSwgdHlwZSkge1xuICB2YXIgdmFsaWQ7XG4gIHZhciBleHBlY3RlZFR5cGUgPSBnZXRUeXBlKHR5cGUpO1xuICBpZiAoc2ltcGxlQ2hlY2tSRS50ZXN0KGV4cGVjdGVkVHlwZSkpIHtcbiAgICB2YXIgdCA9IHR5cGVvZiB2YWx1ZTtcbiAgICB2YWxpZCA9IHQgPT09IGV4cGVjdGVkVHlwZS50b0xvd2VyQ2FzZSgpO1xuICAgIC8vIGZvciBwcmltaXRpdmUgd3JhcHBlciBvYmplY3RzXG4gICAgaWYgKCF2YWxpZCAmJiB0ID09PSAnb2JqZWN0Jykge1xuICAgICAgdmFsaWQgPSB2YWx1ZSBpbnN0YW5jZW9mIHR5cGU7XG4gICAgfVxuICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gJ09iamVjdCcpIHtcbiAgICB2YWxpZCA9IGlzUGxhaW5PYmplY3QodmFsdWUpO1xuICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gJ0FycmF5Jykge1xuICAgIHZhbGlkID0gQXJyYXkuaXNBcnJheSh2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFsaWQgPSB2YWx1ZSBpbnN0YW5jZW9mIHR5cGU7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB2YWxpZDogdmFsaWQsXG4gICAgZXhwZWN0ZWRUeXBlOiBleHBlY3RlZFR5cGVcbiAgfVxufVxuXG4vKipcbiAqIFVzZSBmdW5jdGlvbiBzdHJpbmcgbmFtZSB0byBjaGVjayBidWlsdC1pbiB0eXBlcyxcbiAqIGJlY2F1c2UgYSBzaW1wbGUgZXF1YWxpdHkgY2hlY2sgd2lsbCBmYWlsIHdoZW4gcnVubmluZ1xuICogYWNyb3NzIGRpZmZlcmVudCB2bXMgLyBpZnJhbWVzLlxuICovXG5mdW5jdGlvbiBnZXRUeXBlIChmbikge1xuICB2YXIgbWF0Y2ggPSBmbiAmJiBmbi50b1N0cmluZygpLm1hdGNoKC9eXFxzKmZ1bmN0aW9uIChcXHcrKS8pO1xuICByZXR1cm4gbWF0Y2ggPyBtYXRjaFsxXSA6ICcnXG59XG5cbmZ1bmN0aW9uIGlzU2FtZVR5cGUgKGEsIGIpIHtcbiAgcmV0dXJuIGdldFR5cGUoYSkgPT09IGdldFR5cGUoYilcbn1cblxuZnVuY3Rpb24gZ2V0VHlwZUluZGV4ICh0eXBlLCBleHBlY3RlZFR5cGVzKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShleHBlY3RlZFR5cGVzKSkge1xuICAgIHJldHVybiBpc1NhbWVUeXBlKGV4cGVjdGVkVHlwZXMsIHR5cGUpID8gMCA6IC0xXG4gIH1cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGV4cGVjdGVkVHlwZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoaXNTYW1lVHlwZShleHBlY3RlZFR5cGVzW2ldLCB0eXBlKSkge1xuICAgICAgcmV0dXJuIGlcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBoYW5kbGVFcnJvciAoZXJyLCB2bSwgaW5mbykge1xuICBpZiAodm0pIHtcbiAgICB2YXIgY3VyID0gdm07XG4gICAgd2hpbGUgKChjdXIgPSBjdXIuJHBhcmVudCkpIHtcbiAgICAgIHZhciBob29rcyA9IGN1ci4kb3B0aW9ucy5lcnJvckNhcHR1cmVkO1xuICAgICAgaWYgKGhvb2tzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaG9va3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIGNhcHR1cmUgPSBob29rc1tpXS5jYWxsKGN1ciwgZXJyLCB2bSwgaW5mbykgPT09IGZhbHNlO1xuICAgICAgICAgICAgaWYgKGNhcHR1cmUpIHsgcmV0dXJuIH1cbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBnbG9iYWxIYW5kbGVFcnJvcihlLCBjdXIsICdlcnJvckNhcHR1cmVkIGhvb2snKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZ2xvYmFsSGFuZGxlRXJyb3IoZXJyLCB2bSwgaW5mbyk7XG59XG5cbmZ1bmN0aW9uIGdsb2JhbEhhbmRsZUVycm9yIChlcnIsIHZtLCBpbmZvKSB7XG4gIGlmIChjb25maWcuZXJyb3JIYW5kbGVyKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBjb25maWcuZXJyb3JIYW5kbGVyLmNhbGwobnVsbCwgZXJyLCB2bSwgaW5mbylcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBsb2dFcnJvcihlLCBudWxsLCAnY29uZmlnLmVycm9ySGFuZGxlcicpO1xuICAgIH1cbiAgfVxuICBsb2dFcnJvcihlcnIsIHZtLCBpbmZvKTtcbn1cblxuZnVuY3Rpb24gbG9nRXJyb3IgKGVyciwgdm0sIGluZm8pIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB3YXJuKChcIkVycm9yIGluIFwiICsgaW5mbyArIFwiOiBcXFwiXCIgKyAoZXJyLnRvU3RyaW5nKCkpICsgXCJcXFwiXCIpLCB2bSk7XG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKChpbkJyb3dzZXIgfHwgaW5XZWV4KSAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBjb25zb2xlLmVycm9yKGVycik7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgZXJyXG4gIH1cbn1cblxuLyogICovXG4vKiBnbG9iYWxzIE1lc3NhZ2VDaGFubmVsICovXG5cbnZhciBjYWxsYmFja3MgPSBbXTtcbnZhciBwZW5kaW5nID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGZsdXNoQ2FsbGJhY2tzICgpIHtcbiAgcGVuZGluZyA9IGZhbHNlO1xuICB2YXIgY29waWVzID0gY2FsbGJhY2tzLnNsaWNlKDApO1xuICBjYWxsYmFja3MubGVuZ3RoID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3BpZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb3BpZXNbaV0oKTtcbiAgfVxufVxuXG4vLyBIZXJlIHdlIGhhdmUgYXN5bmMgZGVmZXJyaW5nIHdyYXBwZXJzIHVzaW5nIGJvdGggbWljcm90YXNrcyBhbmQgKG1hY3JvKSB0YXNrcy5cbi8vIEluIDwgMi40IHdlIHVzZWQgbWljcm90YXNrcyBldmVyeXdoZXJlLCBidXQgdGhlcmUgYXJlIHNvbWUgc2NlbmFyaW9zIHdoZXJlXG4vLyBtaWNyb3Rhc2tzIGhhdmUgdG9vIGhpZ2ggYSBwcmlvcml0eSBhbmQgZmlyZSBpbiBiZXR3ZWVuIHN1cHBvc2VkbHlcbi8vIHNlcXVlbnRpYWwgZXZlbnRzIChlLmcuICM0NTIxLCAjNjY5MCkgb3IgZXZlbiBiZXR3ZWVuIGJ1YmJsaW5nIG9mIHRoZSBzYW1lXG4vLyBldmVudCAoIzY1NjYpLiBIb3dldmVyLCB1c2luZyAobWFjcm8pIHRhc2tzIGV2ZXJ5d2hlcmUgYWxzbyBoYXMgc3VidGxlIHByb2JsZW1zXG4vLyB3aGVuIHN0YXRlIGlzIGNoYW5nZWQgcmlnaHQgYmVmb3JlIHJlcGFpbnQgKGUuZy4gIzY4MTMsIG91dC1pbiB0cmFuc2l0aW9ucykuXG4vLyBIZXJlIHdlIHVzZSBtaWNyb3Rhc2sgYnkgZGVmYXVsdCwgYnV0IGV4cG9zZSBhIHdheSB0byBmb3JjZSAobWFjcm8pIHRhc2sgd2hlblxuLy8gbmVlZGVkIChlLmcuIGluIGV2ZW50IGhhbmRsZXJzIGF0dGFjaGVkIGJ5IHYtb24pLlxudmFyIG1pY3JvVGltZXJGdW5jO1xudmFyIG1hY3JvVGltZXJGdW5jO1xudmFyIHVzZU1hY3JvVGFzayA9IGZhbHNlO1xuXG4vLyBEZXRlcm1pbmUgKG1hY3JvKSB0YXNrIGRlZmVyIGltcGxlbWVudGF0aW9uLlxuLy8gVGVjaG5pY2FsbHkgc2V0SW1tZWRpYXRlIHNob3VsZCBiZSB0aGUgaWRlYWwgY2hvaWNlLCBidXQgaXQncyBvbmx5IGF2YWlsYWJsZVxuLy8gaW4gSUUuIFRoZSBvbmx5IHBvbHlmaWxsIHRoYXQgY29uc2lzdGVudGx5IHF1ZXVlcyB0aGUgY2FsbGJhY2sgYWZ0ZXIgYWxsIERPTVxuLy8gZXZlbnRzIHRyaWdnZXJlZCBpbiB0aGUgc2FtZSBsb29wIGlzIGJ5IHVzaW5nIE1lc3NhZ2VDaGFubmVsLlxuLyogaXN0YW5idWwgaWdub3JlIGlmICovXG5pZiAodHlwZW9mIHNldEltbWVkaWF0ZSAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoc2V0SW1tZWRpYXRlKSkge1xuICBtYWNyb1RpbWVyRnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICBzZXRJbW1lZGlhdGUoZmx1c2hDYWxsYmFja3MpO1xuICB9O1xufSBlbHNlIGlmICh0eXBlb2YgTWVzc2FnZUNoYW5uZWwgIT09ICd1bmRlZmluZWQnICYmIChcbiAgaXNOYXRpdmUoTWVzc2FnZUNoYW5uZWwpIHx8XG4gIC8vIFBoYW50b21KU1xuICBNZXNzYWdlQ2hhbm5lbC50b1N0cmluZygpID09PSAnW29iamVjdCBNZXNzYWdlQ2hhbm5lbENvbnN0cnVjdG9yXSdcbikpIHtcbiAgdmFyIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgdmFyIHBvcnQgPSBjaGFubmVsLnBvcnQyO1xuICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGZsdXNoQ2FsbGJhY2tzO1xuICBtYWNyb1RpbWVyRnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICBwb3J0LnBvc3RNZXNzYWdlKDEpO1xuICB9O1xufSBlbHNlIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgbWFjcm9UaW1lckZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgc2V0VGltZW91dChmbHVzaENhbGxiYWNrcywgMCk7XG4gIH07XG59XG5cbi8vIERldGVybWluZSBtaWNyb3Rhc2sgZGVmZXIgaW1wbGVtZW50YXRpb24uXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCwgJGZsb3ctZGlzYWJsZS1saW5lICovXG5pZiAodHlwZW9mIFByb21pc2UgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFByb21pc2UpKSB7XG4gIHZhciBwID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIG1pY3JvVGltZXJGdW5jID0gZnVuY3Rpb24gKCkge1xuICAgIHAudGhlbihmbHVzaENhbGxiYWNrcyk7XG4gICAgLy8gaW4gcHJvYmxlbWF0aWMgVUlXZWJWaWV3cywgUHJvbWlzZS50aGVuIGRvZXNuJ3QgY29tcGxldGVseSBicmVhaywgYnV0XG4gICAgLy8gaXQgY2FuIGdldCBzdHVjayBpbiBhIHdlaXJkIHN0YXRlIHdoZXJlIGNhbGxiYWNrcyBhcmUgcHVzaGVkIGludG8gdGhlXG4gICAgLy8gbWljcm90YXNrIHF1ZXVlIGJ1dCB0aGUgcXVldWUgaXNuJ3QgYmVpbmcgZmx1c2hlZCwgdW50aWwgdGhlIGJyb3dzZXJcbiAgICAvLyBuZWVkcyB0byBkbyBzb21lIG90aGVyIHdvcmssIGUuZy4gaGFuZGxlIGEgdGltZXIuIFRoZXJlZm9yZSB3ZSBjYW5cbiAgICAvLyBcImZvcmNlXCIgdGhlIG1pY3JvdGFzayBxdWV1ZSB0byBiZSBmbHVzaGVkIGJ5IGFkZGluZyBhbiBlbXB0eSB0aW1lci5cbiAgICBpZiAoaXNJT1MpIHsgc2V0VGltZW91dChub29wKTsgfVxuICB9O1xufSBlbHNlIHtcbiAgLy8gZmFsbGJhY2sgdG8gbWFjcm9cbiAgbWljcm9UaW1lckZ1bmMgPSBtYWNyb1RpbWVyRnVuYztcbn1cblxuLyoqXG4gKiBXcmFwIGEgZnVuY3Rpb24gc28gdGhhdCBpZiBhbnkgY29kZSBpbnNpZGUgdHJpZ2dlcnMgc3RhdGUgY2hhbmdlLFxuICogdGhlIGNoYW5nZXMgYXJlIHF1ZXVlZCB1c2luZyBhIChtYWNybykgdGFzayBpbnN0ZWFkIG9mIGEgbWljcm90YXNrLlxuICovXG5mdW5jdGlvbiB3aXRoTWFjcm9UYXNrIChmbikge1xuICByZXR1cm4gZm4uX3dpdGhUYXNrIHx8IChmbi5fd2l0aFRhc2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgdXNlTWFjcm9UYXNrID0gdHJ1ZTtcbiAgICB2YXIgcmVzID0gZm4uYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB1c2VNYWNyb1Rhc2sgPSBmYWxzZTtcbiAgICByZXR1cm4gcmVzXG4gIH0pXG59XG5cbmZ1bmN0aW9uIG5leHRUaWNrIChjYiwgY3R4KSB7XG4gIHZhciBfcmVzb2x2ZTtcbiAgY2FsbGJhY2tzLnB1c2goZnVuY3Rpb24gKCkge1xuICAgIGlmIChjYikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY2IuY2FsbChjdHgpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBoYW5kbGVFcnJvcihlLCBjdHgsICduZXh0VGljaycpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoX3Jlc29sdmUpIHtcbiAgICAgIF9yZXNvbHZlKGN0eCk7XG4gICAgfVxuICB9KTtcbiAgaWYgKCFwZW5kaW5nKSB7XG4gICAgcGVuZGluZyA9IHRydWU7XG4gICAgaWYgKHVzZU1hY3JvVGFzaykge1xuICAgICAgbWFjcm9UaW1lckZ1bmMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWljcm9UaW1lckZ1bmMoKTtcbiAgICB9XG4gIH1cbiAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gIGlmICghY2IgJiYgdHlwZW9mIFByb21pc2UgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICBfcmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgfSlcbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIG1hcms7XG52YXIgbWVhc3VyZTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIHBlcmYgPSBpbkJyb3dzZXIgJiYgd2luZG93LnBlcmZvcm1hbmNlO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKFxuICAgIHBlcmYgJiZcbiAgICBwZXJmLm1hcmsgJiZcbiAgICBwZXJmLm1lYXN1cmUgJiZcbiAgICBwZXJmLmNsZWFyTWFya3MgJiZcbiAgICBwZXJmLmNsZWFyTWVhc3VyZXNcbiAgKSB7XG4gICAgbWFyayA9IGZ1bmN0aW9uICh0YWcpIHsgcmV0dXJuIHBlcmYubWFyayh0YWcpOyB9O1xuICAgIG1lYXN1cmUgPSBmdW5jdGlvbiAobmFtZSwgc3RhcnRUYWcsIGVuZFRhZykge1xuICAgICAgcGVyZi5tZWFzdXJlKG5hbWUsIHN0YXJ0VGFnLCBlbmRUYWcpO1xuICAgICAgcGVyZi5jbGVhck1hcmtzKHN0YXJ0VGFnKTtcbiAgICAgIHBlcmYuY2xlYXJNYXJrcyhlbmRUYWcpO1xuICAgICAgcGVyZi5jbGVhck1lYXN1cmVzKG5hbWUpO1xuICAgIH07XG4gIH1cbn1cblxuLyogbm90IHR5cGUgY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgZmxvdyBkb2Vzbid0IHBsYXkgd2VsbCB3aXRoIFByb3h5ICovXG5cbnZhciBpbml0UHJveHk7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBhbGxvd2VkR2xvYmFscyA9IG1ha2VNYXAoXG4gICAgJ0luZmluaXR5LHVuZGVmaW5lZCxOYU4saXNGaW5pdGUsaXNOYU4sJyArXG4gICAgJ3BhcnNlRmxvYXQscGFyc2VJbnQsZGVjb2RlVVJJLGRlY29kZVVSSUNvbXBvbmVudCxlbmNvZGVVUkksZW5jb2RlVVJJQ29tcG9uZW50LCcgK1xuICAgICdNYXRoLE51bWJlcixEYXRlLEFycmF5LE9iamVjdCxCb29sZWFuLFN0cmluZyxSZWdFeHAsTWFwLFNldCxKU09OLEludGwsJyArXG4gICAgJ3JlcXVpcmUnIC8vIGZvciBXZWJwYWNrL0Jyb3dzZXJpZnlcbiAgKTtcblxuICB2YXIgd2Fybk5vblByZXNlbnQgPSBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHtcbiAgICB3YXJuKFxuICAgICAgXCJQcm9wZXJ0eSBvciBtZXRob2QgXFxcIlwiICsga2V5ICsgXCJcXFwiIGlzIG5vdCBkZWZpbmVkIG9uIHRoZSBpbnN0YW5jZSBidXQgXCIgK1xuICAgICAgJ3JlZmVyZW5jZWQgZHVyaW5nIHJlbmRlci4gTWFrZSBzdXJlIHRoYXQgdGhpcyBwcm9wZXJ0eSBpcyByZWFjdGl2ZSwgJyArXG4gICAgICAnZWl0aGVyIGluIHRoZSBkYXRhIG9wdGlvbiwgb3IgZm9yIGNsYXNzLWJhc2VkIGNvbXBvbmVudHMsIGJ5ICcgK1xuICAgICAgJ2luaXRpYWxpemluZyB0aGUgcHJvcGVydHkuICcgK1xuICAgICAgJ1NlZTogaHR0cHM6Ly92dWVqcy5vcmcvdjIvZ3VpZGUvcmVhY3Rpdml0eS5odG1sI0RlY2xhcmluZy1SZWFjdGl2ZS1Qcm9wZXJ0aWVzLicsXG4gICAgICB0YXJnZXRcbiAgICApO1xuICB9O1xuXG4gIHZhciBoYXNQcm94eSA9XG4gICAgdHlwZW9mIFByb3h5ICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShQcm94eSk7XG5cbiAgaWYgKGhhc1Byb3h5KSB7XG4gICAgdmFyIGlzQnVpbHRJbk1vZGlmaWVyID0gbWFrZU1hcCgnc3RvcCxwcmV2ZW50LHNlbGYsY3RybCxzaGlmdCxhbHQsbWV0YSxleGFjdCcpO1xuICAgIGNvbmZpZy5rZXlDb2RlcyA9IG5ldyBQcm94eShjb25maWcua2V5Q29kZXMsIHtcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0ICh0YXJnZXQsIGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKGlzQnVpbHRJbk1vZGlmaWVyKGtleSkpIHtcbiAgICAgICAgICB3YXJuKChcIkF2b2lkIG92ZXJ3cml0aW5nIGJ1aWx0LWluIG1vZGlmaWVyIGluIGNvbmZpZy5rZXlDb2RlczogLlwiICsga2V5KSk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICB2YXIgaGFzSGFuZGxlciA9IHtcbiAgICBoYXM6IGZ1bmN0aW9uIGhhcyAodGFyZ2V0LCBrZXkpIHtcbiAgICAgIHZhciBoYXMgPSBrZXkgaW4gdGFyZ2V0O1xuICAgICAgdmFyIGlzQWxsb3dlZCA9IGFsbG93ZWRHbG9iYWxzKGtleSkgfHwga2V5LmNoYXJBdCgwKSA9PT0gJ18nO1xuICAgICAgaWYgKCFoYXMgJiYgIWlzQWxsb3dlZCkge1xuICAgICAgICB3YXJuTm9uUHJlc2VudCh0YXJnZXQsIGtleSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaGFzIHx8ICFpc0FsbG93ZWRcbiAgICB9XG4gIH07XG5cbiAgdmFyIGdldEhhbmRsZXIgPSB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQgKHRhcmdldCwga2V5KSB7XG4gICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycgJiYgIShrZXkgaW4gdGFyZ2V0KSkge1xuICAgICAgICB3YXJuTm9uUHJlc2VudCh0YXJnZXQsIGtleSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFyZ2V0W2tleV1cbiAgICB9XG4gIH07XG5cbiAgaW5pdFByb3h5ID0gZnVuY3Rpb24gaW5pdFByb3h5ICh2bSkge1xuICAgIGlmIChoYXNQcm94eSkge1xuICAgICAgLy8gZGV0ZXJtaW5lIHdoaWNoIHByb3h5IGhhbmRsZXIgdG8gdXNlXG4gICAgICB2YXIgb3B0aW9ucyA9IHZtLiRvcHRpb25zO1xuICAgICAgdmFyIGhhbmRsZXJzID0gb3B0aW9ucy5yZW5kZXIgJiYgb3B0aW9ucy5yZW5kZXIuX3dpdGhTdHJpcHBlZFxuICAgICAgICA/IGdldEhhbmRsZXJcbiAgICAgICAgOiBoYXNIYW5kbGVyO1xuICAgICAgdm0uX3JlbmRlclByb3h5ID0gbmV3IFByb3h5KHZtLCBoYW5kbGVycyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZtLl9yZW5kZXJQcm94eSA9IHZtO1xuICAgIH1cbiAgfTtcbn1cblxuLyogICovXG5cbnZhciBzZWVuT2JqZWN0cyA9IG5ldyBfU2V0KCk7XG5cbi8qKlxuICogUmVjdXJzaXZlbHkgdHJhdmVyc2UgYW4gb2JqZWN0IHRvIGV2b2tlIGFsbCBjb252ZXJ0ZWRcbiAqIGdldHRlcnMsIHNvIHRoYXQgZXZlcnkgbmVzdGVkIHByb3BlcnR5IGluc2lkZSB0aGUgb2JqZWN0XG4gKiBpcyBjb2xsZWN0ZWQgYXMgYSBcImRlZXBcIiBkZXBlbmRlbmN5LlxuICovXG5mdW5jdGlvbiB0cmF2ZXJzZSAodmFsKSB7XG4gIF90cmF2ZXJzZSh2YWwsIHNlZW5PYmplY3RzKTtcbiAgc2Vlbk9iamVjdHMuY2xlYXIoKTtcbn1cblxuZnVuY3Rpb24gX3RyYXZlcnNlICh2YWwsIHNlZW4pIHtcbiAgdmFyIGksIGtleXM7XG4gIHZhciBpc0EgPSBBcnJheS5pc0FycmF5KHZhbCk7XG4gIGlmICgoIWlzQSAmJiAhaXNPYmplY3QodmFsKSkgfHwgT2JqZWN0LmlzRnJvemVuKHZhbCkgfHwgdmFsIGluc3RhbmNlb2YgVk5vZGUpIHtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAodmFsLl9fb2JfXykge1xuICAgIHZhciBkZXBJZCA9IHZhbC5fX29iX18uZGVwLmlkO1xuICAgIGlmIChzZWVuLmhhcyhkZXBJZCkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBzZWVuLmFkZChkZXBJZCk7XG4gIH1cbiAgaWYgKGlzQSkge1xuICAgIGkgPSB2YWwubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHsgX3RyYXZlcnNlKHZhbFtpXSwgc2Vlbik7IH1cbiAgfSBlbHNlIHtcbiAgICBrZXlzID0gT2JqZWN0LmtleXModmFsKTtcbiAgICBpID0ga2V5cy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkgeyBfdHJhdmVyc2UodmFsW2tleXNbaV1dLCBzZWVuKTsgfVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgbm9ybWFsaXplRXZlbnQgPSBjYWNoZWQoZnVuY3Rpb24gKG5hbWUpIHtcbiAgdmFyIHBhc3NpdmUgPSBuYW1lLmNoYXJBdCgwKSA9PT0gJyYnO1xuICBuYW1lID0gcGFzc2l2ZSA/IG5hbWUuc2xpY2UoMSkgOiBuYW1lO1xuICB2YXIgb25jZSQkMSA9IG5hbWUuY2hhckF0KDApID09PSAnfic7IC8vIFByZWZpeGVkIGxhc3QsIGNoZWNrZWQgZmlyc3RcbiAgbmFtZSA9IG9uY2UkJDEgPyBuYW1lLnNsaWNlKDEpIDogbmFtZTtcbiAgdmFyIGNhcHR1cmUgPSBuYW1lLmNoYXJBdCgwKSA9PT0gJyEnO1xuICBuYW1lID0gY2FwdHVyZSA/IG5hbWUuc2xpY2UoMSkgOiBuYW1lO1xuICByZXR1cm4ge1xuICAgIG5hbWU6IG5hbWUsXG4gICAgb25jZTogb25jZSQkMSxcbiAgICBjYXB0dXJlOiBjYXB0dXJlLFxuICAgIHBhc3NpdmU6IHBhc3NpdmVcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIGNyZWF0ZUZuSW52b2tlciAoZm5zKSB7XG4gIGZ1bmN0aW9uIGludm9rZXIgKCkge1xuICAgIHZhciBhcmd1bWVudHMkMSA9IGFyZ3VtZW50cztcblxuICAgIHZhciBmbnMgPSBpbnZva2VyLmZucztcbiAgICBpZiAoQXJyYXkuaXNBcnJheShmbnMpKSB7XG4gICAgICB2YXIgY2xvbmVkID0gZm5zLnNsaWNlKCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsb25lZC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjbG9uZWRbaV0uYXBwbHkobnVsbCwgYXJndW1lbnRzJDEpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyByZXR1cm4gaGFuZGxlciByZXR1cm4gdmFsdWUgZm9yIHNpbmdsZSBoYW5kbGVyc1xuICAgICAgcmV0dXJuIGZucy5hcHBseShudWxsLCBhcmd1bWVudHMpXG4gICAgfVxuICB9XG4gIGludm9rZXIuZm5zID0gZm5zO1xuICByZXR1cm4gaW52b2tlclxufVxuXG5mdW5jdGlvbiB1cGRhdGVMaXN0ZW5lcnMgKFxuICBvbixcbiAgb2xkT24sXG4gIGFkZCxcbiAgcmVtb3ZlJCQxLFxuICB2bVxuKSB7XG4gIHZhciBuYW1lLCBkZWYsIGN1ciwgb2xkLCBldmVudDtcbiAgZm9yIChuYW1lIGluIG9uKSB7XG4gICAgZGVmID0gY3VyID0gb25bbmFtZV07XG4gICAgb2xkID0gb2xkT25bbmFtZV07XG4gICAgZXZlbnQgPSBub3JtYWxpemVFdmVudChuYW1lKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoaXNVbmRlZihjdXIpKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgIFwiSW52YWxpZCBoYW5kbGVyIGZvciBldmVudCBcXFwiXCIgKyAoZXZlbnQubmFtZSkgKyBcIlxcXCI6IGdvdCBcIiArIFN0cmluZyhjdXIpLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKGlzVW5kZWYob2xkKSkge1xuICAgICAgaWYgKGlzVW5kZWYoY3VyLmZucykpIHtcbiAgICAgICAgY3VyID0gb25bbmFtZV0gPSBjcmVhdGVGbkludm9rZXIoY3VyKTtcbiAgICAgIH1cbiAgICAgIGFkZChldmVudC5uYW1lLCBjdXIsIGV2ZW50Lm9uY2UsIGV2ZW50LmNhcHR1cmUsIGV2ZW50LnBhc3NpdmUsIGV2ZW50LnBhcmFtcyk7XG4gICAgfSBlbHNlIGlmIChjdXIgIT09IG9sZCkge1xuICAgICAgb2xkLmZucyA9IGN1cjtcbiAgICAgIG9uW25hbWVdID0gb2xkO1xuICAgIH1cbiAgfVxuICBmb3IgKG5hbWUgaW4gb2xkT24pIHtcbiAgICBpZiAoaXNVbmRlZihvbltuYW1lXSkpIHtcbiAgICAgIGV2ZW50ID0gbm9ybWFsaXplRXZlbnQobmFtZSk7XG4gICAgICByZW1vdmUkJDEoZXZlbnQubmFtZSwgb2xkT25bbmFtZV0sIGV2ZW50LmNhcHR1cmUpO1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gbWVyZ2VWTm9kZUhvb2sgKGRlZiwgaG9va0tleSwgaG9vaykge1xuICBpZiAoZGVmIGluc3RhbmNlb2YgVk5vZGUpIHtcbiAgICBkZWYgPSBkZWYuZGF0YS5ob29rIHx8IChkZWYuZGF0YS5ob29rID0ge30pO1xuICB9XG4gIHZhciBpbnZva2VyO1xuICB2YXIgb2xkSG9vayA9IGRlZltob29rS2V5XTtcblxuICBmdW5jdGlvbiB3cmFwcGVkSG9vayAoKSB7XG4gICAgaG9vay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIC8vIGltcG9ydGFudDogcmVtb3ZlIG1lcmdlZCBob29rIHRvIGVuc3VyZSBpdCdzIGNhbGxlZCBvbmx5IG9uY2VcbiAgICAvLyBhbmQgcHJldmVudCBtZW1vcnkgbGVha1xuICAgIHJlbW92ZShpbnZva2VyLmZucywgd3JhcHBlZEhvb2spO1xuICB9XG5cbiAgaWYgKGlzVW5kZWYob2xkSG9vaykpIHtcbiAgICAvLyBubyBleGlzdGluZyBob29rXG4gICAgaW52b2tlciA9IGNyZWF0ZUZuSW52b2tlcihbd3JhcHBlZEhvb2tdKTtcbiAgfSBlbHNlIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoaXNEZWYob2xkSG9vay5mbnMpICYmIGlzVHJ1ZShvbGRIb29rLm1lcmdlZCkpIHtcbiAgICAgIC8vIGFscmVhZHkgYSBtZXJnZWQgaW52b2tlclxuICAgICAgaW52b2tlciA9IG9sZEhvb2s7XG4gICAgICBpbnZva2VyLmZucy5wdXNoKHdyYXBwZWRIb29rKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZXhpc3RpbmcgcGxhaW4gaG9va1xuICAgICAgaW52b2tlciA9IGNyZWF0ZUZuSW52b2tlcihbb2xkSG9vaywgd3JhcHBlZEhvb2tdKTtcbiAgICB9XG4gIH1cblxuICBpbnZva2VyLm1lcmdlZCA9IHRydWU7XG4gIGRlZltob29rS2V5XSA9IGludm9rZXI7XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBleHRyYWN0UHJvcHNGcm9tVk5vZGVEYXRhIChcbiAgZGF0YSxcbiAgQ3RvcixcbiAgdGFnXG4pIHtcbiAgLy8gd2UgYXJlIG9ubHkgZXh0cmFjdGluZyByYXcgdmFsdWVzIGhlcmUuXG4gIC8vIHZhbGlkYXRpb24gYW5kIGRlZmF1bHQgdmFsdWVzIGFyZSBoYW5kbGVkIGluIHRoZSBjaGlsZFxuICAvLyBjb21wb25lbnQgaXRzZWxmLlxuICB2YXIgcHJvcE9wdGlvbnMgPSBDdG9yLm9wdGlvbnMucHJvcHM7XG4gIGlmIChpc1VuZGVmKHByb3BPcHRpb25zKSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciByZXMgPSB7fTtcbiAgdmFyIGF0dHJzID0gZGF0YS5hdHRycztcbiAgdmFyIHByb3BzID0gZGF0YS5wcm9wcztcbiAgaWYgKGlzRGVmKGF0dHJzKSB8fCBpc0RlZihwcm9wcykpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcE9wdGlvbnMpIHtcbiAgICAgIHZhciBhbHRLZXkgPSBoeXBoZW5hdGUoa2V5KTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHZhciBrZXlJbkxvd2VyQ2FzZSA9IGtleS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoXG4gICAgICAgICAga2V5ICE9PSBrZXlJbkxvd2VyQ2FzZSAmJlxuICAgICAgICAgIGF0dHJzICYmIGhhc093bihhdHRycywga2V5SW5Mb3dlckNhc2UpXG4gICAgICAgICkge1xuICAgICAgICAgIHRpcChcbiAgICAgICAgICAgIFwiUHJvcCBcXFwiXCIgKyBrZXlJbkxvd2VyQ2FzZSArIFwiXFxcIiBpcyBwYXNzZWQgdG8gY29tcG9uZW50IFwiICtcbiAgICAgICAgICAgIChmb3JtYXRDb21wb25lbnROYW1lKHRhZyB8fCBDdG9yKSkgKyBcIiwgYnV0IHRoZSBkZWNsYXJlZCBwcm9wIG5hbWUgaXNcIiArXG4gICAgICAgICAgICBcIiBcXFwiXCIgKyBrZXkgKyBcIlxcXCIuIFwiICtcbiAgICAgICAgICAgIFwiTm90ZSB0aGF0IEhUTUwgYXR0cmlidXRlcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZSBhbmQgY2FtZWxDYXNlZCBcIiArXG4gICAgICAgICAgICBcInByb3BzIG5lZWQgdG8gdXNlIHRoZWlyIGtlYmFiLWNhc2UgZXF1aXZhbGVudHMgd2hlbiB1c2luZyBpbi1ET00gXCIgK1xuICAgICAgICAgICAgXCJ0ZW1wbGF0ZXMuIFlvdSBzaG91bGQgcHJvYmFibHkgdXNlIFxcXCJcIiArIGFsdEtleSArIFwiXFxcIiBpbnN0ZWFkIG9mIFxcXCJcIiArIGtleSArIFwiXFxcIi5cIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNoZWNrUHJvcChyZXMsIHByb3BzLCBrZXksIGFsdEtleSwgdHJ1ZSkgfHxcbiAgICAgIGNoZWNrUHJvcChyZXMsIGF0dHJzLCBrZXksIGFsdEtleSwgZmFsc2UpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGNoZWNrUHJvcCAoXG4gIHJlcyxcbiAgaGFzaCxcbiAga2V5LFxuICBhbHRLZXksXG4gIHByZXNlcnZlXG4pIHtcbiAgaWYgKGlzRGVmKGhhc2gpKSB7XG4gICAgaWYgKGhhc093bihoYXNoLCBrZXkpKSB7XG4gICAgICByZXNba2V5XSA9IGhhc2hba2V5XTtcbiAgICAgIGlmICghcHJlc2VydmUpIHtcbiAgICAgICAgZGVsZXRlIGhhc2hba2V5XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfSBlbHNlIGlmIChoYXNPd24oaGFzaCwgYWx0S2V5KSkge1xuICAgICAgcmVzW2tleV0gPSBoYXNoW2FsdEtleV07XG4gICAgICBpZiAoIXByZXNlcnZlKSB7XG4gICAgICAgIGRlbGV0ZSBoYXNoW2FsdEtleV07XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuLyogICovXG5cbi8vIFRoZSB0ZW1wbGF0ZSBjb21waWxlciBhdHRlbXB0cyB0byBtaW5pbWl6ZSB0aGUgbmVlZCBmb3Igbm9ybWFsaXphdGlvbiBieVxuLy8gc3RhdGljYWxseSBhbmFseXppbmcgdGhlIHRlbXBsYXRlIGF0IGNvbXBpbGUgdGltZS5cbi8vXG4vLyBGb3IgcGxhaW4gSFRNTCBtYXJrdXAsIG5vcm1hbGl6YXRpb24gY2FuIGJlIGNvbXBsZXRlbHkgc2tpcHBlZCBiZWNhdXNlIHRoZVxuLy8gZ2VuZXJhdGVkIHJlbmRlciBmdW5jdGlvbiBpcyBndWFyYW50ZWVkIHRvIHJldHVybiBBcnJheTxWTm9kZT4uIFRoZXJlIGFyZVxuLy8gdHdvIGNhc2VzIHdoZXJlIGV4dHJhIG5vcm1hbGl6YXRpb24gaXMgbmVlZGVkOlxuXG4vLyAxLiBXaGVuIHRoZSBjaGlsZHJlbiBjb250YWlucyBjb21wb25lbnRzIC0gYmVjYXVzZSBhIGZ1bmN0aW9uYWwgY29tcG9uZW50XG4vLyBtYXkgcmV0dXJuIGFuIEFycmF5IGluc3RlYWQgb2YgYSBzaW5nbGUgcm9vdC4gSW4gdGhpcyBjYXNlLCBqdXN0IGEgc2ltcGxlXG4vLyBub3JtYWxpemF0aW9uIGlzIG5lZWRlZCAtIGlmIGFueSBjaGlsZCBpcyBhbiBBcnJheSwgd2UgZmxhdHRlbiB0aGUgd2hvbGVcbi8vIHRoaW5nIHdpdGggQXJyYXkucHJvdG90eXBlLmNvbmNhdC4gSXQgaXMgZ3VhcmFudGVlZCB0byBiZSBvbmx5IDEtbGV2ZWwgZGVlcFxuLy8gYmVjYXVzZSBmdW5jdGlvbmFsIGNvbXBvbmVudHMgYWxyZWFkeSBub3JtYWxpemUgdGhlaXIgb3duIGNoaWxkcmVuLlxuZnVuY3Rpb24gc2ltcGxlTm9ybWFsaXplQ2hpbGRyZW4gKGNoaWxkcmVuKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbltpXSkpIHtcbiAgICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuY29uY2F0LmFwcGx5KFtdLCBjaGlsZHJlbilcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNoaWxkcmVuXG59XG5cbi8vIDIuIFdoZW4gdGhlIGNoaWxkcmVuIGNvbnRhaW5zIGNvbnN0cnVjdHMgdGhhdCBhbHdheXMgZ2VuZXJhdGVkIG5lc3RlZCBBcnJheXMsXG4vLyBlLmcuIDx0ZW1wbGF0ZT4sIDxzbG90Piwgdi1mb3IsIG9yIHdoZW4gdGhlIGNoaWxkcmVuIGlzIHByb3ZpZGVkIGJ5IHVzZXJcbi8vIHdpdGggaGFuZC13cml0dGVuIHJlbmRlciBmdW5jdGlvbnMgLyBKU1guIEluIHN1Y2ggY2FzZXMgYSBmdWxsIG5vcm1hbGl6YXRpb25cbi8vIGlzIG5lZWRlZCB0byBjYXRlciB0byBhbGwgcG9zc2libGUgdHlwZXMgb2YgY2hpbGRyZW4gdmFsdWVzLlxuZnVuY3Rpb24gbm9ybWFsaXplQ2hpbGRyZW4gKGNoaWxkcmVuKSB7XG4gIHJldHVybiBpc1ByaW1pdGl2ZShjaGlsZHJlbilcbiAgICA/IFtjcmVhdGVUZXh0Vk5vZGUoY2hpbGRyZW4pXVxuICAgIDogQXJyYXkuaXNBcnJheShjaGlsZHJlbilcbiAgICAgID8gbm9ybWFsaXplQXJyYXlDaGlsZHJlbihjaGlsZHJlbilcbiAgICAgIDogdW5kZWZpbmVkXG59XG5cbmZ1bmN0aW9uIGlzVGV4dE5vZGUgKG5vZGUpIHtcbiAgcmV0dXJuIGlzRGVmKG5vZGUpICYmIGlzRGVmKG5vZGUudGV4dCkgJiYgaXNGYWxzZShub2RlLmlzQ29tbWVudClcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplQXJyYXlDaGlsZHJlbiAoY2hpbGRyZW4sIG5lc3RlZEluZGV4KSB7XG4gIHZhciByZXMgPSBbXTtcbiAgdmFyIGksIGMsIGxhc3RJbmRleCwgbGFzdDtcbiAgZm9yIChpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgYyA9IGNoaWxkcmVuW2ldO1xuICAgIGlmIChpc1VuZGVmKGMpIHx8IHR5cGVvZiBjID09PSAnYm9vbGVhbicpIHsgY29udGludWUgfVxuICAgIGxhc3RJbmRleCA9IHJlcy5sZW5ndGggLSAxO1xuICAgIGxhc3QgPSByZXNbbGFzdEluZGV4XTtcbiAgICAvLyAgbmVzdGVkXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYykpIHtcbiAgICAgIGlmIChjLmxlbmd0aCA+IDApIHtcbiAgICAgICAgYyA9IG5vcm1hbGl6ZUFycmF5Q2hpbGRyZW4oYywgKChuZXN0ZWRJbmRleCB8fCAnJykgKyBcIl9cIiArIGkpKTtcbiAgICAgICAgLy8gbWVyZ2UgYWRqYWNlbnQgdGV4dCBub2Rlc1xuICAgICAgICBpZiAoaXNUZXh0Tm9kZShjWzBdKSAmJiBpc1RleHROb2RlKGxhc3QpKSB7XG4gICAgICAgICAgcmVzW2xhc3RJbmRleF0gPSBjcmVhdGVUZXh0Vk5vZGUobGFzdC50ZXh0ICsgKGNbMF0pLnRleHQpO1xuICAgICAgICAgIGMuc2hpZnQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXMucHVzaC5hcHBseShyZXMsIGMpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNQcmltaXRpdmUoYykpIHtcbiAgICAgIGlmIChpc1RleHROb2RlKGxhc3QpKSB7XG4gICAgICAgIC8vIG1lcmdlIGFkamFjZW50IHRleHQgbm9kZXNcbiAgICAgICAgLy8gdGhpcyBpcyBuZWNlc3NhcnkgZm9yIFNTUiBoeWRyYXRpb24gYmVjYXVzZSB0ZXh0IG5vZGVzIGFyZVxuICAgICAgICAvLyBlc3NlbnRpYWxseSBtZXJnZWQgd2hlbiByZW5kZXJlZCB0byBIVE1MIHN0cmluZ3NcbiAgICAgICAgcmVzW2xhc3RJbmRleF0gPSBjcmVhdGVUZXh0Vk5vZGUobGFzdC50ZXh0ICsgYyk7XG4gICAgICB9IGVsc2UgaWYgKGMgIT09ICcnKSB7XG4gICAgICAgIC8vIGNvbnZlcnQgcHJpbWl0aXZlIHRvIHZub2RlXG4gICAgICAgIHJlcy5wdXNoKGNyZWF0ZVRleHRWTm9kZShjKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpc1RleHROb2RlKGMpICYmIGlzVGV4dE5vZGUobGFzdCkpIHtcbiAgICAgICAgLy8gbWVyZ2UgYWRqYWNlbnQgdGV4dCBub2Rlc1xuICAgICAgICByZXNbbGFzdEluZGV4XSA9IGNyZWF0ZVRleHRWTm9kZShsYXN0LnRleHQgKyBjLnRleHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZGVmYXVsdCBrZXkgZm9yIG5lc3RlZCBhcnJheSBjaGlsZHJlbiAobGlrZWx5IGdlbmVyYXRlZCBieSB2LWZvcilcbiAgICAgICAgaWYgKGlzVHJ1ZShjaGlsZHJlbi5faXNWTGlzdCkgJiZcbiAgICAgICAgICBpc0RlZihjLnRhZykgJiZcbiAgICAgICAgICBpc1VuZGVmKGMua2V5KSAmJlxuICAgICAgICAgIGlzRGVmKG5lc3RlZEluZGV4KSkge1xuICAgICAgICAgIGMua2V5ID0gXCJfX3ZsaXN0XCIgKyBuZXN0ZWRJbmRleCArIFwiX1wiICsgaSArIFwiX19cIjtcbiAgICAgICAgfVxuICAgICAgICByZXMucHVzaChjKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gZW5zdXJlQ3RvciAoY29tcCwgYmFzZSkge1xuICBpZiAoXG4gICAgY29tcC5fX2VzTW9kdWxlIHx8XG4gICAgKGhhc1N5bWJvbCAmJiBjb21wW1N5bWJvbC50b1N0cmluZ1RhZ10gPT09ICdNb2R1bGUnKVxuICApIHtcbiAgICBjb21wID0gY29tcC5kZWZhdWx0O1xuICB9XG4gIHJldHVybiBpc09iamVjdChjb21wKVxuICAgID8gYmFzZS5leHRlbmQoY29tcClcbiAgICA6IGNvbXBcbn1cblxuZnVuY3Rpb24gY3JlYXRlQXN5bmNQbGFjZWhvbGRlciAoXG4gIGZhY3RvcnksXG4gIGRhdGEsXG4gIGNvbnRleHQsXG4gIGNoaWxkcmVuLFxuICB0YWdcbikge1xuICB2YXIgbm9kZSA9IGNyZWF0ZUVtcHR5Vk5vZGUoKTtcbiAgbm9kZS5hc3luY0ZhY3RvcnkgPSBmYWN0b3J5O1xuICBub2RlLmFzeW5jTWV0YSA9IHsgZGF0YTogZGF0YSwgY29udGV4dDogY29udGV4dCwgY2hpbGRyZW46IGNoaWxkcmVuLCB0YWc6IHRhZyB9O1xuICByZXR1cm4gbm9kZVxufVxuXG5mdW5jdGlvbiByZXNvbHZlQXN5bmNDb21wb25lbnQgKFxuICBmYWN0b3J5LFxuICBiYXNlQ3RvcixcbiAgY29udGV4dFxuKSB7XG4gIGlmIChpc1RydWUoZmFjdG9yeS5lcnJvcikgJiYgaXNEZWYoZmFjdG9yeS5lcnJvckNvbXApKSB7XG4gICAgcmV0dXJuIGZhY3RvcnkuZXJyb3JDb21wXG4gIH1cblxuICBpZiAoaXNEZWYoZmFjdG9yeS5yZXNvbHZlZCkpIHtcbiAgICByZXR1cm4gZmFjdG9yeS5yZXNvbHZlZFxuICB9XG5cbiAgaWYgKGlzVHJ1ZShmYWN0b3J5LmxvYWRpbmcpICYmIGlzRGVmKGZhY3RvcnkubG9hZGluZ0NvbXApKSB7XG4gICAgcmV0dXJuIGZhY3RvcnkubG9hZGluZ0NvbXBcbiAgfVxuXG4gIGlmIChpc0RlZihmYWN0b3J5LmNvbnRleHRzKSkge1xuICAgIC8vIGFscmVhZHkgcGVuZGluZ1xuICAgIGZhY3RvcnkuY29udGV4dHMucHVzaChjb250ZXh0KTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgY29udGV4dHMgPSBmYWN0b3J5LmNvbnRleHRzID0gW2NvbnRleHRdO1xuICAgIHZhciBzeW5jID0gdHJ1ZTtcblxuICAgIHZhciBmb3JjZVJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY29udGV4dHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGNvbnRleHRzW2ldLiRmb3JjZVVwZGF0ZSgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgcmVzb2x2ZSA9IG9uY2UoZnVuY3Rpb24gKHJlcykge1xuICAgICAgLy8gY2FjaGUgcmVzb2x2ZWRcbiAgICAgIGZhY3RvcnkucmVzb2x2ZWQgPSBlbnN1cmVDdG9yKHJlcywgYmFzZUN0b3IpO1xuICAgICAgLy8gaW52b2tlIGNhbGxiYWNrcyBvbmx5IGlmIHRoaXMgaXMgbm90IGEgc3luY2hyb25vdXMgcmVzb2x2ZVxuICAgICAgLy8gKGFzeW5jIHJlc29sdmVzIGFyZSBzaGltbWVkIGFzIHN5bmNocm9ub3VzIGR1cmluZyBTU1IpXG4gICAgICBpZiAoIXN5bmMpIHtcbiAgICAgICAgZm9yY2VSZW5kZXIoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciByZWplY3QgPSBvbmNlKGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgXCJGYWlsZWQgdG8gcmVzb2x2ZSBhc3luYyBjb21wb25lbnQ6IFwiICsgKFN0cmluZyhmYWN0b3J5KSkgK1xuICAgICAgICAocmVhc29uID8gKFwiXFxuUmVhc29uOiBcIiArIHJlYXNvbikgOiAnJylcbiAgICAgICk7XG4gICAgICBpZiAoaXNEZWYoZmFjdG9yeS5lcnJvckNvbXApKSB7XG4gICAgICAgIGZhY3RvcnkuZXJyb3IgPSB0cnVlO1xuICAgICAgICBmb3JjZVJlbmRlcigpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIHJlcyA9IGZhY3RvcnkocmVzb2x2ZSwgcmVqZWN0KTtcblxuICAgIGlmIChpc09iamVjdChyZXMpKSB7XG4gICAgICBpZiAodHlwZW9mIHJlcy50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vICgpID0+IFByb21pc2VcbiAgICAgICAgaWYgKGlzVW5kZWYoZmFjdG9yeS5yZXNvbHZlZCkpIHtcbiAgICAgICAgICByZXMudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlzRGVmKHJlcy5jb21wb25lbnQpICYmIHR5cGVvZiByZXMuY29tcG9uZW50LnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmVzLmNvbXBvbmVudC50aGVuKHJlc29sdmUsIHJlamVjdCk7XG5cbiAgICAgICAgaWYgKGlzRGVmKHJlcy5lcnJvcikpIHtcbiAgICAgICAgICBmYWN0b3J5LmVycm9yQ29tcCA9IGVuc3VyZUN0b3IocmVzLmVycm9yLCBiYXNlQ3Rvcik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNEZWYocmVzLmxvYWRpbmcpKSB7XG4gICAgICAgICAgZmFjdG9yeS5sb2FkaW5nQ29tcCA9IGVuc3VyZUN0b3IocmVzLmxvYWRpbmcsIGJhc2VDdG9yKTtcbiAgICAgICAgICBpZiAocmVzLmRlbGF5ID09PSAwKSB7XG4gICAgICAgICAgICBmYWN0b3J5LmxvYWRpbmcgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgaWYgKGlzVW5kZWYoZmFjdG9yeS5yZXNvbHZlZCkgJiYgaXNVbmRlZihmYWN0b3J5LmVycm9yKSkge1xuICAgICAgICAgICAgICAgIGZhY3RvcnkubG9hZGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgZm9yY2VSZW5kZXIoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgcmVzLmRlbGF5IHx8IDIwMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzRGVmKHJlcy50aW1lb3V0KSkge1xuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGlzVW5kZWYoZmFjdG9yeS5yZXNvbHZlZCkpIHtcbiAgICAgICAgICAgICAgcmVqZWN0KFxuICAgICAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbidcbiAgICAgICAgICAgICAgICAgID8gKFwidGltZW91dCAoXCIgKyAocmVzLnRpbWVvdXQpICsgXCJtcylcIilcbiAgICAgICAgICAgICAgICAgIDogbnVsbFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIHJlcy50aW1lb3V0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHN5bmMgPSBmYWxzZTtcbiAgICAvLyByZXR1cm4gaW4gY2FzZSByZXNvbHZlZCBzeW5jaHJvbm91c2x5XG4gICAgcmV0dXJuIGZhY3RvcnkubG9hZGluZ1xuICAgICAgPyBmYWN0b3J5LmxvYWRpbmdDb21wXG4gICAgICA6IGZhY3RvcnkucmVzb2x2ZWRcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaXNBc3luY1BsYWNlaG9sZGVyIChub2RlKSB7XG4gIHJldHVybiBub2RlLmlzQ29tbWVudCAmJiBub2RlLmFzeW5jRmFjdG9yeVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gZ2V0Rmlyc3RDb21wb25lbnRDaGlsZCAoY2hpbGRyZW4pIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGMgPSBjaGlsZHJlbltpXTtcbiAgICAgIGlmIChpc0RlZihjKSAmJiAoaXNEZWYoYy5jb21wb25lbnRPcHRpb25zKSB8fCBpc0FzeW5jUGxhY2Vob2xkZXIoYykpKSB7XG4gICAgICAgIHJldHVybiBjXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdEV2ZW50cyAodm0pIHtcbiAgdm0uX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHZtLl9oYXNIb29rRXZlbnQgPSBmYWxzZTtcbiAgLy8gaW5pdCBwYXJlbnQgYXR0YWNoZWQgZXZlbnRzXG4gIHZhciBsaXN0ZW5lcnMgPSB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xuICBpZiAobGlzdGVuZXJzKSB7XG4gICAgdXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzKHZtLCBsaXN0ZW5lcnMpO1xuICB9XG59XG5cbnZhciB0YXJnZXQ7XG5cbmZ1bmN0aW9uIGFkZCAoZXZlbnQsIGZuLCBvbmNlKSB7XG4gIGlmIChvbmNlKSB7XG4gICAgdGFyZ2V0LiRvbmNlKGV2ZW50LCBmbik7XG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0LiRvbihldmVudCwgZm4pO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZSQxIChldmVudCwgZm4pIHtcbiAgdGFyZ2V0LiRvZmYoZXZlbnQsIGZuKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzIChcbiAgdm0sXG4gIGxpc3RlbmVycyxcbiAgb2xkTGlzdGVuZXJzXG4pIHtcbiAgdGFyZ2V0ID0gdm07XG4gIHVwZGF0ZUxpc3RlbmVycyhsaXN0ZW5lcnMsIG9sZExpc3RlbmVycyB8fCB7fSwgYWRkLCByZW1vdmUkMSwgdm0pO1xuICB0YXJnZXQgPSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGV2ZW50c01peGluIChWdWUpIHtcbiAgdmFyIGhvb2tSRSA9IC9eaG9vazovO1xuICBWdWUucHJvdG90eXBlLiRvbiA9IGZ1bmN0aW9uIChldmVudCwgZm4pIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZXZlbnQpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGV2ZW50Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB0aGlzJDEuJG9uKGV2ZW50W2ldLCBmbik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICh2bS5fZXZlbnRzW2V2ZW50XSB8fCAodm0uX2V2ZW50c1tldmVudF0gPSBbXSkpLnB1c2goZm4pO1xuICAgICAgLy8gb3B0aW1pemUgaG9vazpldmVudCBjb3N0IGJ5IHVzaW5nIGEgYm9vbGVhbiBmbGFnIG1hcmtlZCBhdCByZWdpc3RyYXRpb25cbiAgICAgIC8vIGluc3RlYWQgb2YgYSBoYXNoIGxvb2t1cFxuICAgICAgaWYgKGhvb2tSRS50ZXN0KGV2ZW50KSkge1xuICAgICAgICB2bS5faGFzSG9va0V2ZW50ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZtXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kb25jZSA9IGZ1bmN0aW9uIChldmVudCwgZm4pIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGZ1bmN0aW9uIG9uICgpIHtcbiAgICAgIHZtLiRvZmYoZXZlbnQsIG9uKTtcbiAgICAgIGZuLmFwcGx5KHZtLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBvbi5mbiA9IGZuO1xuICAgIHZtLiRvbihldmVudCwgb24pO1xuICAgIHJldHVybiB2bVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJG9mZiA9IGZ1bmN0aW9uIChldmVudCwgZm4pIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgLy8gYWxsXG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICB2bS5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIHJldHVybiB2bVxuICAgIH1cbiAgICAvLyBhcnJheSBvZiBldmVudHNcbiAgICBpZiAoQXJyYXkuaXNBcnJheShldmVudCkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gZXZlbnQubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHRoaXMkMS4kb2ZmKGV2ZW50W2ldLCBmbik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdm1cbiAgICB9XG4gICAgLy8gc3BlY2lmaWMgZXZlbnRcbiAgICB2YXIgY2JzID0gdm0uX2V2ZW50c1tldmVudF07XG4gICAgaWYgKCFjYnMpIHtcbiAgICAgIHJldHVybiB2bVxuICAgIH1cbiAgICBpZiAoIWZuKSB7XG4gICAgICB2bS5fZXZlbnRzW2V2ZW50XSA9IG51bGw7XG4gICAgICByZXR1cm4gdm1cbiAgICB9XG4gICAgaWYgKGZuKSB7XG4gICAgICAvLyBzcGVjaWZpYyBoYW5kbGVyXG4gICAgICB2YXIgY2I7XG4gICAgICB2YXIgaSQxID0gY2JzLmxlbmd0aDtcbiAgICAgIHdoaWxlIChpJDEtLSkge1xuICAgICAgICBjYiA9IGNic1tpJDFdO1xuICAgICAgICBpZiAoY2IgPT09IGZuIHx8IGNiLmZuID09PSBmbikge1xuICAgICAgICAgIGNicy5zcGxpY2UoaSQxLCAxKTtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2bVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJGVtaXQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgbG93ZXJDYXNlRXZlbnQgPSBldmVudC50b0xvd2VyQ2FzZSgpO1xuICAgICAgaWYgKGxvd2VyQ2FzZUV2ZW50ICE9PSBldmVudCAmJiB2bS5fZXZlbnRzW2xvd2VyQ2FzZUV2ZW50XSkge1xuICAgICAgICB0aXAoXG4gICAgICAgICAgXCJFdmVudCBcXFwiXCIgKyBsb3dlckNhc2VFdmVudCArIFwiXFxcIiBpcyBlbWl0dGVkIGluIGNvbXBvbmVudCBcIiArXG4gICAgICAgICAgKGZvcm1hdENvbXBvbmVudE5hbWUodm0pKSArIFwiIGJ1dCB0aGUgaGFuZGxlciBpcyByZWdpc3RlcmVkIGZvciBcXFwiXCIgKyBldmVudCArIFwiXFxcIi4gXCIgK1xuICAgICAgICAgIFwiTm90ZSB0aGF0IEhUTUwgYXR0cmlidXRlcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZSBhbmQgeW91IGNhbm5vdCB1c2UgXCIgK1xuICAgICAgICAgIFwidi1vbiB0byBsaXN0ZW4gdG8gY2FtZWxDYXNlIGV2ZW50cyB3aGVuIHVzaW5nIGluLURPTSB0ZW1wbGF0ZXMuIFwiICtcbiAgICAgICAgICBcIllvdSBzaG91bGQgcHJvYmFibHkgdXNlIFxcXCJcIiArIChoeXBoZW5hdGUoZXZlbnQpKSArIFwiXFxcIiBpbnN0ZWFkIG9mIFxcXCJcIiArIGV2ZW50ICsgXCJcXFwiLlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBjYnMgPSB2bS5fZXZlbnRzW2V2ZW50XTtcbiAgICBpZiAoY2JzKSB7XG4gICAgICBjYnMgPSBjYnMubGVuZ3RoID4gMSA/IHRvQXJyYXkoY2JzKSA6IGNicztcbiAgICAgIHZhciBhcmdzID0gdG9BcnJheShhcmd1bWVudHMsIDEpO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjYnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY2JzW2ldLmFwcGx5KHZtLCBhcmdzKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGhhbmRsZUVycm9yKGUsIHZtLCAoXCJldmVudCBoYW5kbGVyIGZvciBcXFwiXCIgKyBldmVudCArIFwiXFxcIlwiKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZtXG4gIH07XG59XG5cbi8qICAqL1xuXG5cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVzb2x2aW5nIHJhdyBjaGlsZHJlbiBWTm9kZXMgaW50byBhIHNsb3Qgb2JqZWN0LlxuICovXG5mdW5jdGlvbiByZXNvbHZlU2xvdHMgKFxuICBjaGlsZHJlbixcbiAgY29udGV4dFxuKSB7XG4gIHZhciBzbG90cyA9IHt9O1xuICBpZiAoIWNoaWxkcmVuKSB7XG4gICAgcmV0dXJuIHNsb3RzXG4gIH1cbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICB2YXIgZGF0YSA9IGNoaWxkLmRhdGE7XG4gICAgLy8gcmVtb3ZlIHNsb3QgYXR0cmlidXRlIGlmIHRoZSBub2RlIGlzIHJlc29sdmVkIGFzIGEgVnVlIHNsb3Qgbm9kZVxuICAgIGlmIChkYXRhICYmIGRhdGEuYXR0cnMgJiYgZGF0YS5hdHRycy5zbG90KSB7XG4gICAgICBkZWxldGUgZGF0YS5hdHRycy5zbG90O1xuICAgIH1cbiAgICAvLyBuYW1lZCBzbG90cyBzaG91bGQgb25seSBiZSByZXNwZWN0ZWQgaWYgdGhlIHZub2RlIHdhcyByZW5kZXJlZCBpbiB0aGVcbiAgICAvLyBzYW1lIGNvbnRleHQuXG4gICAgaWYgKChjaGlsZC5jb250ZXh0ID09PSBjb250ZXh0IHx8IGNoaWxkLmZuQ29udGV4dCA9PT0gY29udGV4dCkgJiZcbiAgICAgIGRhdGEgJiYgZGF0YS5zbG90ICE9IG51bGxcbiAgICApIHtcbiAgICAgIHZhciBuYW1lID0gZGF0YS5zbG90O1xuICAgICAgdmFyIHNsb3QgPSAoc2xvdHNbbmFtZV0gfHwgKHNsb3RzW25hbWVdID0gW10pKTtcbiAgICAgIGlmIChjaGlsZC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgICAgc2xvdC5wdXNoLmFwcGx5KHNsb3QsIGNoaWxkLmNoaWxkcmVuIHx8IFtdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNsb3QucHVzaChjaGlsZCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIChzbG90cy5kZWZhdWx0IHx8IChzbG90cy5kZWZhdWx0ID0gW10pKS5wdXNoKGNoaWxkKTtcbiAgICB9XG4gIH1cbiAgLy8gaWdub3JlIHNsb3RzIHRoYXQgY29udGFpbnMgb25seSB3aGl0ZXNwYWNlXG4gIGZvciAodmFyIG5hbWUkMSBpbiBzbG90cykge1xuICAgIGlmIChzbG90c1tuYW1lJDFdLmV2ZXJ5KGlzV2hpdGVzcGFjZSkpIHtcbiAgICAgIGRlbGV0ZSBzbG90c1tuYW1lJDFdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc2xvdHNcbn1cblxuZnVuY3Rpb24gaXNXaGl0ZXNwYWNlIChub2RlKSB7XG4gIHJldHVybiAobm9kZS5pc0NvbW1lbnQgJiYgIW5vZGUuYXN5bmNGYWN0b3J5KSB8fCBub2RlLnRleHQgPT09ICcgJ1xufVxuXG5mdW5jdGlvbiByZXNvbHZlU2NvcGVkU2xvdHMgKFxuICBmbnMsIC8vIHNlZSBmbG93L3Zub2RlXG4gIHJlc1xuKSB7XG4gIHJlcyA9IHJlcyB8fCB7fTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBmbnMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShmbnNbaV0pKSB7XG4gICAgICByZXNvbHZlU2NvcGVkU2xvdHMoZm5zW2ldLCByZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXNbZm5zW2ldLmtleV0gPSBmbnNbaV0uZm47XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbnZhciBhY3RpdmVJbnN0YW5jZSA9IG51bGw7XG52YXIgaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50ID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGluaXRMaWZlY3ljbGUgKHZtKSB7XG4gIHZhciBvcHRpb25zID0gdm0uJG9wdGlvbnM7XG5cbiAgLy8gbG9jYXRlIGZpcnN0IG5vbi1hYnN0cmFjdCBwYXJlbnRcbiAgdmFyIHBhcmVudCA9IG9wdGlvbnMucGFyZW50O1xuICBpZiAocGFyZW50ICYmICFvcHRpb25zLmFic3RyYWN0KSB7XG4gICAgd2hpbGUgKHBhcmVudC4kb3B0aW9ucy5hYnN0cmFjdCAmJiBwYXJlbnQuJHBhcmVudCkge1xuICAgICAgcGFyZW50ID0gcGFyZW50LiRwYXJlbnQ7XG4gICAgfVxuICAgIHBhcmVudC4kY2hpbGRyZW4ucHVzaCh2bSk7XG4gIH1cblxuICB2bS4kcGFyZW50ID0gcGFyZW50O1xuICB2bS4kcm9vdCA9IHBhcmVudCA/IHBhcmVudC4kcm9vdCA6IHZtO1xuXG4gIHZtLiRjaGlsZHJlbiA9IFtdO1xuICB2bS4kcmVmcyA9IHt9O1xuXG4gIHZtLl93YXRjaGVyID0gbnVsbDtcbiAgdm0uX2luYWN0aXZlID0gbnVsbDtcbiAgdm0uX2RpcmVjdEluYWN0aXZlID0gZmFsc2U7XG4gIHZtLl9pc01vdW50ZWQgPSBmYWxzZTtcbiAgdm0uX2lzRGVzdHJveWVkID0gZmFsc2U7XG4gIHZtLl9pc0JlaW5nRGVzdHJveWVkID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGxpZmVjeWNsZU1peGluIChWdWUpIHtcbiAgVnVlLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKHZub2RlLCBoeWRyYXRpbmcpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmICh2bS5faXNNb3VudGVkKSB7XG4gICAgICBjYWxsSG9vayh2bSwgJ2JlZm9yZVVwZGF0ZScpO1xuICAgIH1cbiAgICB2YXIgcHJldkVsID0gdm0uJGVsO1xuICAgIHZhciBwcmV2Vm5vZGUgPSB2bS5fdm5vZGU7XG4gICAgdmFyIHByZXZBY3RpdmVJbnN0YW5jZSA9IGFjdGl2ZUluc3RhbmNlO1xuICAgIGFjdGl2ZUluc3RhbmNlID0gdm07XG4gICAgdm0uX3Zub2RlID0gdm5vZGU7XG4gICAgLy8gVnVlLnByb3RvdHlwZS5fX3BhdGNoX18gaXMgaW5qZWN0ZWQgaW4gZW50cnkgcG9pbnRzXG4gICAgLy8gYmFzZWQgb24gdGhlIHJlbmRlcmluZyBiYWNrZW5kIHVzZWQuXG4gICAgaWYgKCFwcmV2Vm5vZGUpIHtcbiAgICAgIC8vIGluaXRpYWwgcmVuZGVyXG4gICAgICB2bS4kZWwgPSB2bS5fX3BhdGNoX18oXG4gICAgICAgIHZtLiRlbCwgdm5vZGUsIGh5ZHJhdGluZywgZmFsc2UgLyogcmVtb3ZlT25seSAqLyxcbiAgICAgICAgdm0uJG9wdGlvbnMuX3BhcmVudEVsbSxcbiAgICAgICAgdm0uJG9wdGlvbnMuX3JlZkVsbVxuICAgICAgKTtcbiAgICAgIC8vIG5vIG5lZWQgZm9yIHRoZSByZWYgbm9kZXMgYWZ0ZXIgaW5pdGlhbCBwYXRjaFxuICAgICAgLy8gdGhpcyBwcmV2ZW50cyBrZWVwaW5nIGEgZGV0YWNoZWQgRE9NIHRyZWUgaW4gbWVtb3J5ICgjNTg1MSlcbiAgICAgIHZtLiRvcHRpb25zLl9wYXJlbnRFbG0gPSB2bS4kb3B0aW9ucy5fcmVmRWxtID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdXBkYXRlc1xuICAgICAgdm0uJGVsID0gdm0uX19wYXRjaF9fKHByZXZWbm9kZSwgdm5vZGUpO1xuICAgIH1cbiAgICBhY3RpdmVJbnN0YW5jZSA9IHByZXZBY3RpdmVJbnN0YW5jZTtcbiAgICAvLyB1cGRhdGUgX192dWVfXyByZWZlcmVuY2VcbiAgICBpZiAocHJldkVsKSB7XG4gICAgICBwcmV2RWwuX192dWVfXyA9IG51bGw7XG4gICAgfVxuICAgIGlmICh2bS4kZWwpIHtcbiAgICAgIHZtLiRlbC5fX3Z1ZV9fID0gdm07XG4gICAgfVxuICAgIC8vIGlmIHBhcmVudCBpcyBhbiBIT0MsIHVwZGF0ZSBpdHMgJGVsIGFzIHdlbGxcbiAgICBpZiAodm0uJHZub2RlICYmIHZtLiRwYXJlbnQgJiYgdm0uJHZub2RlID09PSB2bS4kcGFyZW50Ll92bm9kZSkge1xuICAgICAgdm0uJHBhcmVudC4kZWwgPSB2bS4kZWw7XG4gICAgfVxuICAgIC8vIHVwZGF0ZWQgaG9vayBpcyBjYWxsZWQgYnkgdGhlIHNjaGVkdWxlciB0byBlbnN1cmUgdGhhdCBjaGlsZHJlbiBhcmVcbiAgICAvLyB1cGRhdGVkIGluIGEgcGFyZW50J3MgdXBkYXRlZCBob29rLlxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJGZvcmNlVXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgaWYgKHZtLl93YXRjaGVyKSB7XG4gICAgICB2bS5fd2F0Y2hlci51cGRhdGUoKTtcbiAgICB9XG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmICh2bS5faXNCZWluZ0Rlc3Ryb3llZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGNhbGxIb29rKHZtLCAnYmVmb3JlRGVzdHJveScpO1xuICAgIHZtLl9pc0JlaW5nRGVzdHJveWVkID0gdHJ1ZTtcbiAgICAvLyByZW1vdmUgc2VsZiBmcm9tIHBhcmVudFxuICAgIHZhciBwYXJlbnQgPSB2bS4kcGFyZW50O1xuICAgIGlmIChwYXJlbnQgJiYgIXBhcmVudC5faXNCZWluZ0Rlc3Ryb3llZCAmJiAhdm0uJG9wdGlvbnMuYWJzdHJhY3QpIHtcbiAgICAgIHJlbW92ZShwYXJlbnQuJGNoaWxkcmVuLCB2bSk7XG4gICAgfVxuICAgIC8vIHRlYXJkb3duIHdhdGNoZXJzXG4gICAgaWYgKHZtLl93YXRjaGVyKSB7XG4gICAgICB2bS5fd2F0Y2hlci50ZWFyZG93bigpO1xuICAgIH1cbiAgICB2YXIgaSA9IHZtLl93YXRjaGVycy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdm0uX3dhdGNoZXJzW2ldLnRlYXJkb3duKCk7XG4gICAgfVxuICAgIC8vIHJlbW92ZSByZWZlcmVuY2UgZnJvbSBkYXRhIG9iXG4gICAgLy8gZnJvemVuIG9iamVjdCBtYXkgbm90IGhhdmUgb2JzZXJ2ZXIuXG4gICAgaWYgKHZtLl9kYXRhLl9fb2JfXykge1xuICAgICAgdm0uX2RhdGEuX19vYl9fLnZtQ291bnQtLTtcbiAgICB9XG4gICAgLy8gY2FsbCB0aGUgbGFzdCBob29rLi4uXG4gICAgdm0uX2lzRGVzdHJveWVkID0gdHJ1ZTtcbiAgICAvLyBpbnZva2UgZGVzdHJveSBob29rcyBvbiBjdXJyZW50IHJlbmRlcmVkIHRyZWVcbiAgICB2bS5fX3BhdGNoX18odm0uX3Zub2RlLCBudWxsKTtcbiAgICAvLyBmaXJlIGRlc3Ryb3llZCBob29rXG4gICAgY2FsbEhvb2sodm0sICdkZXN0cm95ZWQnKTtcbiAgICAvLyB0dXJuIG9mZiBhbGwgaW5zdGFuY2UgbGlzdGVuZXJzLlxuICAgIHZtLiRvZmYoKTtcbiAgICAvLyByZW1vdmUgX192dWVfXyByZWZlcmVuY2VcbiAgICBpZiAodm0uJGVsKSB7XG4gICAgICB2bS4kZWwuX192dWVfXyA9IG51bGw7XG4gICAgfVxuICAgIC8vIHJlbGVhc2UgY2lyY3VsYXIgcmVmZXJlbmNlICgjNjc1OSlcbiAgICBpZiAodm0uJHZub2RlKSB7XG4gICAgICB2bS4kdm5vZGUucGFyZW50ID0gbnVsbDtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIG1vdW50Q29tcG9uZW50IChcbiAgdm0sXG4gIGVsLFxuICBoeWRyYXRpbmdcbikge1xuICB2bS4kZWwgPSBlbDtcbiAgaWYgKCF2bS4kb3B0aW9ucy5yZW5kZXIpIHtcbiAgICB2bS4kb3B0aW9ucy5yZW5kZXIgPSBjcmVhdGVFbXB0eVZOb2RlO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmICgodm0uJG9wdGlvbnMudGVtcGxhdGUgJiYgdm0uJG9wdGlvbnMudGVtcGxhdGUuY2hhckF0KDApICE9PSAnIycpIHx8XG4gICAgICAgIHZtLiRvcHRpb25zLmVsIHx8IGVsKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ1lvdSBhcmUgdXNpbmcgdGhlIHJ1bnRpbWUtb25seSBidWlsZCBvZiBWdWUgd2hlcmUgdGhlIHRlbXBsYXRlICcgK1xuICAgICAgICAgICdjb21waWxlciBpcyBub3QgYXZhaWxhYmxlLiBFaXRoZXIgcHJlLWNvbXBpbGUgdGhlIHRlbXBsYXRlcyBpbnRvICcgK1xuICAgICAgICAgICdyZW5kZXIgZnVuY3Rpb25zLCBvciB1c2UgdGhlIGNvbXBpbGVyLWluY2x1ZGVkIGJ1aWxkLicsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ0ZhaWxlZCB0byBtb3VudCBjb21wb25lbnQ6IHRlbXBsYXRlIG9yIHJlbmRlciBmdW5jdGlvbiBub3QgZGVmaW5lZC4nLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNhbGxIb29rKHZtLCAnYmVmb3JlTW91bnQnKTtcblxuICB2YXIgdXBkYXRlQ29tcG9uZW50O1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICB1cGRhdGVDb21wb25lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgbmFtZSA9IHZtLl9uYW1lO1xuICAgICAgdmFyIGlkID0gdm0uX3VpZDtcbiAgICAgIHZhciBzdGFydFRhZyA9IFwidnVlLXBlcmYtc3RhcnQ6XCIgKyBpZDtcbiAgICAgIHZhciBlbmRUYWcgPSBcInZ1ZS1wZXJmLWVuZDpcIiArIGlkO1xuXG4gICAgICBtYXJrKHN0YXJ0VGFnKTtcbiAgICAgIHZhciB2bm9kZSA9IHZtLl9yZW5kZXIoKTtcbiAgICAgIG1hcmsoZW5kVGFnKTtcbiAgICAgIG1lYXN1cmUoKFwidnVlIFwiICsgbmFtZSArIFwiIHJlbmRlclwiKSwgc3RhcnRUYWcsIGVuZFRhZyk7XG5cbiAgICAgIG1hcmsoc3RhcnRUYWcpO1xuICAgICAgdm0uX3VwZGF0ZSh2bm9kZSwgaHlkcmF0aW5nKTtcbiAgICAgIG1hcmsoZW5kVGFnKTtcbiAgICAgIG1lYXN1cmUoKFwidnVlIFwiICsgbmFtZSArIFwiIHBhdGNoXCIpLCBzdGFydFRhZywgZW5kVGFnKTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHVwZGF0ZUNvbXBvbmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZtLl91cGRhdGUodm0uX3JlbmRlcigpLCBoeWRyYXRpbmcpO1xuICAgIH07XG4gIH1cblxuICAvLyB3ZSBzZXQgdGhpcyB0byB2bS5fd2F0Y2hlciBpbnNpZGUgdGhlIHdhdGNoZXIncyBjb25zdHJ1Y3RvclxuICAvLyBzaW5jZSB0aGUgd2F0Y2hlcidzIGluaXRpYWwgcGF0Y2ggbWF5IGNhbGwgJGZvcmNlVXBkYXRlIChlLmcuIGluc2lkZSBjaGlsZFxuICAvLyBjb21wb25lbnQncyBtb3VudGVkIGhvb2spLCB3aGljaCByZWxpZXMgb24gdm0uX3dhdGNoZXIgYmVpbmcgYWxyZWFkeSBkZWZpbmVkXG4gIG5ldyBXYXRjaGVyKHZtLCB1cGRhdGVDb21wb25lbnQsIG5vb3AsIG51bGwsIHRydWUgLyogaXNSZW5kZXJXYXRjaGVyICovKTtcbiAgaHlkcmF0aW5nID0gZmFsc2U7XG5cbiAgLy8gbWFudWFsbHkgbW91bnRlZCBpbnN0YW5jZSwgY2FsbCBtb3VudGVkIG9uIHNlbGZcbiAgLy8gbW91bnRlZCBpcyBjYWxsZWQgZm9yIHJlbmRlci1jcmVhdGVkIGNoaWxkIGNvbXBvbmVudHMgaW4gaXRzIGluc2VydGVkIGhvb2tcbiAgaWYgKHZtLiR2bm9kZSA9PSBudWxsKSB7XG4gICAgdm0uX2lzTW91bnRlZCA9IHRydWU7XG4gICAgY2FsbEhvb2sodm0sICdtb3VudGVkJyk7XG4gIH1cbiAgcmV0dXJuIHZtXG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUNoaWxkQ29tcG9uZW50IChcbiAgdm0sXG4gIHByb3BzRGF0YSxcbiAgbGlzdGVuZXJzLFxuICBwYXJlbnRWbm9kZSxcbiAgcmVuZGVyQ2hpbGRyZW5cbikge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCA9IHRydWU7XG4gIH1cblxuICAvLyBkZXRlcm1pbmUgd2hldGhlciBjb21wb25lbnQgaGFzIHNsb3QgY2hpbGRyZW5cbiAgLy8gd2UgbmVlZCB0byBkbyB0aGlzIGJlZm9yZSBvdmVyd3JpdGluZyAkb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW5cbiAgdmFyIGhhc0NoaWxkcmVuID0gISEoXG4gICAgcmVuZGVyQ2hpbGRyZW4gfHwgICAgICAgICAgICAgICAvLyBoYXMgbmV3IHN0YXRpYyBzbG90c1xuICAgIHZtLiRvcHRpb25zLl9yZW5kZXJDaGlsZHJlbiB8fCAgLy8gaGFzIG9sZCBzdGF0aWMgc2xvdHNcbiAgICBwYXJlbnRWbm9kZS5kYXRhLnNjb3BlZFNsb3RzIHx8IC8vIGhhcyBuZXcgc2NvcGVkIHNsb3RzXG4gICAgdm0uJHNjb3BlZFNsb3RzICE9PSBlbXB0eU9iamVjdCAvLyBoYXMgb2xkIHNjb3BlZCBzbG90c1xuICApO1xuXG4gIHZtLiRvcHRpb25zLl9wYXJlbnRWbm9kZSA9IHBhcmVudFZub2RlO1xuICB2bS4kdm5vZGUgPSBwYXJlbnRWbm9kZTsgLy8gdXBkYXRlIHZtJ3MgcGxhY2Vob2xkZXIgbm9kZSB3aXRob3V0IHJlLXJlbmRlclxuXG4gIGlmICh2bS5fdm5vZGUpIHsgLy8gdXBkYXRlIGNoaWxkIHRyZWUncyBwYXJlbnRcbiAgICB2bS5fdm5vZGUucGFyZW50ID0gcGFyZW50Vm5vZGU7XG4gIH1cbiAgdm0uJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuID0gcmVuZGVyQ2hpbGRyZW47XG5cbiAgLy8gdXBkYXRlICRhdHRycyBhbmQgJGxpc3RlbmVycyBoYXNoXG4gIC8vIHRoZXNlIGFyZSBhbHNvIHJlYWN0aXZlIHNvIHRoZXkgbWF5IHRyaWdnZXIgY2hpbGQgdXBkYXRlIGlmIHRoZSBjaGlsZFxuICAvLyB1c2VkIHRoZW0gZHVyaW5nIHJlbmRlclxuICB2bS4kYXR0cnMgPSBwYXJlbnRWbm9kZS5kYXRhLmF0dHJzIHx8IGVtcHR5T2JqZWN0O1xuICB2bS4kbGlzdGVuZXJzID0gbGlzdGVuZXJzIHx8IGVtcHR5T2JqZWN0O1xuXG4gIC8vIHVwZGF0ZSBwcm9wc1xuICBpZiAocHJvcHNEYXRhICYmIHZtLiRvcHRpb25zLnByb3BzKSB7XG4gICAgdG9nZ2xlT2JzZXJ2aW5nKGZhbHNlKTtcbiAgICB2YXIgcHJvcHMgPSB2bS5fcHJvcHM7XG4gICAgdmFyIHByb3BLZXlzID0gdm0uJG9wdGlvbnMuX3Byb3BLZXlzIHx8IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBwcm9wS2V5c1tpXTtcbiAgICAgIHZhciBwcm9wT3B0aW9ucyA9IHZtLiRvcHRpb25zLnByb3BzOyAvLyB3dGYgZmxvdz9cbiAgICAgIHByb3BzW2tleV0gPSB2YWxpZGF0ZVByb3Aoa2V5LCBwcm9wT3B0aW9ucywgcHJvcHNEYXRhLCB2bSk7XG4gICAgfVxuICAgIHRvZ2dsZU9ic2VydmluZyh0cnVlKTtcbiAgICAvLyBrZWVwIGEgY29weSBvZiByYXcgcHJvcHNEYXRhXG4gICAgdm0uJG9wdGlvbnMucHJvcHNEYXRhID0gcHJvcHNEYXRhO1xuICB9XG5cbiAgLy8gdXBkYXRlIGxpc3RlbmVyc1xuICBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMgfHwgZW1wdHlPYmplY3Q7XG4gIHZhciBvbGRMaXN0ZW5lcnMgPSB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xuICB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzID0gbGlzdGVuZXJzO1xuICB1cGRhdGVDb21wb25lbnRMaXN0ZW5lcnModm0sIGxpc3RlbmVycywgb2xkTGlzdGVuZXJzKTtcblxuICAvLyByZXNvbHZlIHNsb3RzICsgZm9yY2UgdXBkYXRlIGlmIGhhcyBjaGlsZHJlblxuICBpZiAoaGFzQ2hpbGRyZW4pIHtcbiAgICB2bS4kc2xvdHMgPSByZXNvbHZlU2xvdHMocmVuZGVyQ2hpbGRyZW4sIHBhcmVudFZub2RlLmNvbnRleHQpO1xuICAgIHZtLiRmb3JjZVVwZGF0ZSgpO1xuICB9XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgPSBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc0luSW5hY3RpdmVUcmVlICh2bSkge1xuICB3aGlsZSAodm0gJiYgKHZtID0gdm0uJHBhcmVudCkpIHtcbiAgICBpZiAodm0uX2luYWN0aXZlKSB7IHJldHVybiB0cnVlIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gYWN0aXZhdGVDaGlsZENvbXBvbmVudCAodm0sIGRpcmVjdCkge1xuICBpZiAoZGlyZWN0KSB7XG4gICAgdm0uX2RpcmVjdEluYWN0aXZlID0gZmFsc2U7XG4gICAgaWYgKGlzSW5JbmFjdGl2ZVRyZWUodm0pKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gIH0gZWxzZSBpZiAodm0uX2RpcmVjdEluYWN0aXZlKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKHZtLl9pbmFjdGl2ZSB8fCB2bS5faW5hY3RpdmUgPT09IG51bGwpIHtcbiAgICB2bS5faW5hY3RpdmUgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZtLiRjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgYWN0aXZhdGVDaGlsZENvbXBvbmVudCh2bS4kY2hpbGRyZW5baV0pO1xuICAgIH1cbiAgICBjYWxsSG9vayh2bSwgJ2FjdGl2YXRlZCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlYWN0aXZhdGVDaGlsZENvbXBvbmVudCAodm0sIGRpcmVjdCkge1xuICBpZiAoZGlyZWN0KSB7XG4gICAgdm0uX2RpcmVjdEluYWN0aXZlID0gdHJ1ZTtcbiAgICBpZiAoaXNJbkluYWN0aXZlVHJlZSh2bSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgfVxuICBpZiAoIXZtLl9pbmFjdGl2ZSkge1xuICAgIHZtLl9pbmFjdGl2ZSA9IHRydWU7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2bS4kY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRlYWN0aXZhdGVDaGlsZENvbXBvbmVudCh2bS4kY2hpbGRyZW5baV0pO1xuICAgIH1cbiAgICBjYWxsSG9vayh2bSwgJ2RlYWN0aXZhdGVkJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FsbEhvb2sgKHZtLCBob29rKSB7XG4gIC8vICM3NTczIGRpc2FibGUgZGVwIGNvbGxlY3Rpb24gd2hlbiBpbnZva2luZyBsaWZlY3ljbGUgaG9va3NcbiAgcHVzaFRhcmdldCgpO1xuICB2YXIgaGFuZGxlcnMgPSB2bS4kb3B0aW9uc1tob29rXTtcbiAgaWYgKGhhbmRsZXJzKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGogPSBoYW5kbGVycy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGhhbmRsZXJzW2ldLmNhbGwodm0pO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBoYW5kbGVFcnJvcihlLCB2bSwgKGhvb2sgKyBcIiBob29rXCIpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHZtLl9oYXNIb29rRXZlbnQpIHtcbiAgICB2bS4kZW1pdCgnaG9vazonICsgaG9vayk7XG4gIH1cbiAgcG9wVGFyZ2V0KCk7XG59XG5cbi8qICAqL1xuXG5cbnZhciBNQVhfVVBEQVRFX0NPVU5UID0gMTAwO1xuXG52YXIgcXVldWUgPSBbXTtcbnZhciBhY3RpdmF0ZWRDaGlsZHJlbiA9IFtdO1xudmFyIGhhcyA9IHt9O1xudmFyIGNpcmN1bGFyID0ge307XG52YXIgd2FpdGluZyA9IGZhbHNlO1xudmFyIGZsdXNoaW5nID0gZmFsc2U7XG52YXIgaW5kZXggPSAwO1xuXG4vKipcbiAqIFJlc2V0IHRoZSBzY2hlZHVsZXIncyBzdGF0ZS5cbiAqL1xuZnVuY3Rpb24gcmVzZXRTY2hlZHVsZXJTdGF0ZSAoKSB7XG4gIGluZGV4ID0gcXVldWUubGVuZ3RoID0gYWN0aXZhdGVkQ2hpbGRyZW4ubGVuZ3RoID0gMDtcbiAgaGFzID0ge307XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgY2lyY3VsYXIgPSB7fTtcbiAgfVxuICB3YWl0aW5nID0gZmx1c2hpbmcgPSBmYWxzZTtcbn1cblxuLyoqXG4gKiBGbHVzaCBib3RoIHF1ZXVlcyBhbmQgcnVuIHRoZSB3YXRjaGVycy5cbiAqL1xuZnVuY3Rpb24gZmx1c2hTY2hlZHVsZXJRdWV1ZSAoKSB7XG4gIGZsdXNoaW5nID0gdHJ1ZTtcbiAgdmFyIHdhdGNoZXIsIGlkO1xuXG4gIC8vIFNvcnQgcXVldWUgYmVmb3JlIGZsdXNoLlxuICAvLyBUaGlzIGVuc3VyZXMgdGhhdDpcbiAgLy8gMS4gQ29tcG9uZW50cyBhcmUgdXBkYXRlZCBmcm9tIHBhcmVudCB0byBjaGlsZC4gKGJlY2F1c2UgcGFyZW50IGlzIGFsd2F5c1xuICAvLyAgICBjcmVhdGVkIGJlZm9yZSB0aGUgY2hpbGQpXG4gIC8vIDIuIEEgY29tcG9uZW50J3MgdXNlciB3YXRjaGVycyBhcmUgcnVuIGJlZm9yZSBpdHMgcmVuZGVyIHdhdGNoZXIgKGJlY2F1c2VcbiAgLy8gICAgdXNlciB3YXRjaGVycyBhcmUgY3JlYXRlZCBiZWZvcmUgdGhlIHJlbmRlciB3YXRjaGVyKVxuICAvLyAzLiBJZiBhIGNvbXBvbmVudCBpcyBkZXN0cm95ZWQgZHVyaW5nIGEgcGFyZW50IGNvbXBvbmVudCdzIHdhdGNoZXIgcnVuLFxuICAvLyAgICBpdHMgd2F0Y2hlcnMgY2FuIGJlIHNraXBwZWQuXG4gIHF1ZXVlLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEuaWQgLSBiLmlkOyB9KTtcblxuICAvLyBkbyBub3QgY2FjaGUgbGVuZ3RoIGJlY2F1c2UgbW9yZSB3YXRjaGVycyBtaWdodCBiZSBwdXNoZWRcbiAgLy8gYXMgd2UgcnVuIGV4aXN0aW5nIHdhdGNoZXJzXG4gIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IHF1ZXVlLmxlbmd0aDsgaW5kZXgrKykge1xuICAgIHdhdGNoZXIgPSBxdWV1ZVtpbmRleF07XG4gICAgaWQgPSB3YXRjaGVyLmlkO1xuICAgIGhhc1tpZF0gPSBudWxsO1xuICAgIHdhdGNoZXIucnVuKCk7XG4gICAgLy8gaW4gZGV2IGJ1aWxkLCBjaGVjayBhbmQgc3RvcCBjaXJjdWxhciB1cGRhdGVzLlxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGhhc1tpZF0gIT0gbnVsbCkge1xuICAgICAgY2lyY3VsYXJbaWRdID0gKGNpcmN1bGFyW2lkXSB8fCAwKSArIDE7XG4gICAgICBpZiAoY2lyY3VsYXJbaWRdID4gTUFYX1VQREFURV9DT1VOVCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdZb3UgbWF5IGhhdmUgYW4gaW5maW5pdGUgdXBkYXRlIGxvb3AgJyArIChcbiAgICAgICAgICAgIHdhdGNoZXIudXNlclxuICAgICAgICAgICAgICA/IChcImluIHdhdGNoZXIgd2l0aCBleHByZXNzaW9uIFxcXCJcIiArICh3YXRjaGVyLmV4cHJlc3Npb24pICsgXCJcXFwiXCIpXG4gICAgICAgICAgICAgIDogXCJpbiBhIGNvbXBvbmVudCByZW5kZXIgZnVuY3Rpb24uXCJcbiAgICAgICAgICApLFxuICAgICAgICAgIHdhdGNoZXIudm1cbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBrZWVwIGNvcGllcyBvZiBwb3N0IHF1ZXVlcyBiZWZvcmUgcmVzZXR0aW5nIHN0YXRlXG4gIHZhciBhY3RpdmF0ZWRRdWV1ZSA9IGFjdGl2YXRlZENoaWxkcmVuLnNsaWNlKCk7XG4gIHZhciB1cGRhdGVkUXVldWUgPSBxdWV1ZS5zbGljZSgpO1xuXG4gIHJlc2V0U2NoZWR1bGVyU3RhdGUoKTtcblxuICAvLyBjYWxsIGNvbXBvbmVudCB1cGRhdGVkIGFuZCBhY3RpdmF0ZWQgaG9va3NcbiAgY2FsbEFjdGl2YXRlZEhvb2tzKGFjdGl2YXRlZFF1ZXVlKTtcbiAgY2FsbFVwZGF0ZWRIb29rcyh1cGRhdGVkUXVldWUpO1xuXG4gIC8vIGRldnRvb2wgaG9va1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGRldnRvb2xzICYmIGNvbmZpZy5kZXZ0b29scykge1xuICAgIGRldnRvb2xzLmVtaXQoJ2ZsdXNoJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FsbFVwZGF0ZWRIb29rcyAocXVldWUpIHtcbiAgdmFyIGkgPSBxdWV1ZS5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICB2YXIgd2F0Y2hlciA9IHF1ZXVlW2ldO1xuICAgIHZhciB2bSA9IHdhdGNoZXIudm07XG4gICAgaWYgKHZtLl93YXRjaGVyID09PSB3YXRjaGVyICYmIHZtLl9pc01vdW50ZWQpIHtcbiAgICAgIGNhbGxIb29rKHZtLCAndXBkYXRlZCcpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFF1ZXVlIGEga2VwdC1hbGl2ZSBjb21wb25lbnQgdGhhdCB3YXMgYWN0aXZhdGVkIGR1cmluZyBwYXRjaC5cbiAqIFRoZSBxdWV1ZSB3aWxsIGJlIHByb2Nlc3NlZCBhZnRlciB0aGUgZW50aXJlIHRyZWUgaGFzIGJlZW4gcGF0Y2hlZC5cbiAqL1xuZnVuY3Rpb24gcXVldWVBY3RpdmF0ZWRDb21wb25lbnQgKHZtKSB7XG4gIC8vIHNldHRpbmcgX2luYWN0aXZlIHRvIGZhbHNlIGhlcmUgc28gdGhhdCBhIHJlbmRlciBmdW5jdGlvbiBjYW5cbiAgLy8gcmVseSBvbiBjaGVja2luZyB3aGV0aGVyIGl0J3MgaW4gYW4gaW5hY3RpdmUgdHJlZSAoZS5nLiByb3V0ZXItdmlldylcbiAgdm0uX2luYWN0aXZlID0gZmFsc2U7XG4gIGFjdGl2YXRlZENoaWxkcmVuLnB1c2godm0pO1xufVxuXG5mdW5jdGlvbiBjYWxsQWN0aXZhdGVkSG9va3MgKHF1ZXVlKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICBxdWV1ZVtpXS5faW5hY3RpdmUgPSB0cnVlO1xuICAgIGFjdGl2YXRlQ2hpbGRDb21wb25lbnQocXVldWVbaV0sIHRydWUgLyogdHJ1ZSAqLyk7XG4gIH1cbn1cblxuLyoqXG4gKiBQdXNoIGEgd2F0Y2hlciBpbnRvIHRoZSB3YXRjaGVyIHF1ZXVlLlxuICogSm9icyB3aXRoIGR1cGxpY2F0ZSBJRHMgd2lsbCBiZSBza2lwcGVkIHVubGVzcyBpdCdzXG4gKiBwdXNoZWQgd2hlbiB0aGUgcXVldWUgaXMgYmVpbmcgZmx1c2hlZC5cbiAqL1xuZnVuY3Rpb24gcXVldWVXYXRjaGVyICh3YXRjaGVyKSB7XG4gIHZhciBpZCA9IHdhdGNoZXIuaWQ7XG4gIGlmIChoYXNbaWRdID09IG51bGwpIHtcbiAgICBoYXNbaWRdID0gdHJ1ZTtcbiAgICBpZiAoIWZsdXNoaW5nKSB7XG4gICAgICBxdWV1ZS5wdXNoKHdhdGNoZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpZiBhbHJlYWR5IGZsdXNoaW5nLCBzcGxpY2UgdGhlIHdhdGNoZXIgYmFzZWQgb24gaXRzIGlkXG4gICAgICAvLyBpZiBhbHJlYWR5IHBhc3QgaXRzIGlkLCBpdCB3aWxsIGJlIHJ1biBuZXh0IGltbWVkaWF0ZWx5LlxuICAgICAgdmFyIGkgPSBxdWV1ZS5sZW5ndGggLSAxO1xuICAgICAgd2hpbGUgKGkgPiBpbmRleCAmJiBxdWV1ZVtpXS5pZCA+IHdhdGNoZXIuaWQpIHtcbiAgICAgICAgaS0tO1xuICAgICAgfVxuICAgICAgcXVldWUuc3BsaWNlKGkgKyAxLCAwLCB3YXRjaGVyKTtcbiAgICB9XG4gICAgLy8gcXVldWUgdGhlIGZsdXNoXG4gICAgaWYgKCF3YWl0aW5nKSB7XG4gICAgICB3YWl0aW5nID0gdHJ1ZTtcbiAgICAgIG5leHRUaWNrKGZsdXNoU2NoZWR1bGVyUXVldWUpO1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIHVpZCQxID0gMDtcblxuLyoqXG4gKiBBIHdhdGNoZXIgcGFyc2VzIGFuIGV4cHJlc3Npb24sIGNvbGxlY3RzIGRlcGVuZGVuY2llcyxcbiAqIGFuZCBmaXJlcyBjYWxsYmFjayB3aGVuIHRoZSBleHByZXNzaW9uIHZhbHVlIGNoYW5nZXMuXG4gKiBUaGlzIGlzIHVzZWQgZm9yIGJvdGggdGhlICR3YXRjaCgpIGFwaSBhbmQgZGlyZWN0aXZlcy5cbiAqL1xudmFyIFdhdGNoZXIgPSBmdW5jdGlvbiBXYXRjaGVyIChcbiAgdm0sXG4gIGV4cE9yRm4sXG4gIGNiLFxuICBvcHRpb25zLFxuICBpc1JlbmRlcldhdGNoZXJcbikge1xuICB0aGlzLnZtID0gdm07XG4gIGlmIChpc1JlbmRlcldhdGNoZXIpIHtcbiAgICB2bS5fd2F0Y2hlciA9IHRoaXM7XG4gIH1cbiAgdm0uX3dhdGNoZXJzLnB1c2godGhpcyk7XG4gIC8vIG9wdGlvbnNcbiAgaWYgKG9wdGlvbnMpIHtcbiAgICB0aGlzLmRlZXAgPSAhIW9wdGlvbnMuZGVlcDtcbiAgICB0aGlzLnVzZXIgPSAhIW9wdGlvbnMudXNlcjtcbiAgICB0aGlzLmxhenkgPSAhIW9wdGlvbnMubGF6eTtcbiAgICB0aGlzLnN5bmMgPSAhIW9wdGlvbnMuc3luYztcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmRlZXAgPSB0aGlzLnVzZXIgPSB0aGlzLmxhenkgPSB0aGlzLnN5bmMgPSBmYWxzZTtcbiAgfVxuICB0aGlzLmNiID0gY2I7XG4gIHRoaXMuaWQgPSArK3VpZCQxOyAvLyB1aWQgZm9yIGJhdGNoaW5nXG4gIHRoaXMuYWN0aXZlID0gdHJ1ZTtcbiAgdGhpcy5kaXJ0eSA9IHRoaXMubGF6eTsgLy8gZm9yIGxhenkgd2F0Y2hlcnNcbiAgdGhpcy5kZXBzID0gW107XG4gIHRoaXMubmV3RGVwcyA9IFtdO1xuICB0aGlzLmRlcElkcyA9IG5ldyBfU2V0KCk7XG4gIHRoaXMubmV3RGVwSWRzID0gbmV3IF9TZXQoKTtcbiAgdGhpcy5leHByZXNzaW9uID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJ1xuICAgID8gZXhwT3JGbi50b1N0cmluZygpXG4gICAgOiAnJztcbiAgLy8gcGFyc2UgZXhwcmVzc2lvbiBmb3IgZ2V0dGVyXG4gIGlmICh0eXBlb2YgZXhwT3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRoaXMuZ2V0dGVyID0gZXhwT3JGbjtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmdldHRlciA9IHBhcnNlUGF0aChleHBPckZuKTtcbiAgICBpZiAoIXRoaXMuZ2V0dGVyKSB7XG4gICAgICB0aGlzLmdldHRlciA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICBcIkZhaWxlZCB3YXRjaGluZyBwYXRoOiBcXFwiXCIgKyBleHBPckZuICsgXCJcXFwiIFwiICtcbiAgICAgICAgJ1dhdGNoZXIgb25seSBhY2NlcHRzIHNpbXBsZSBkb3QtZGVsaW1pdGVkIHBhdGhzLiAnICtcbiAgICAgICAgJ0ZvciBmdWxsIGNvbnRyb2wsIHVzZSBhIGZ1bmN0aW9uIGluc3RlYWQuJyxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfVxuICB9XG4gIHRoaXMudmFsdWUgPSB0aGlzLmxhenlcbiAgICA/IHVuZGVmaW5lZFxuICAgIDogdGhpcy5nZXQoKTtcbn07XG5cbi8qKlxuICogRXZhbHVhdGUgdGhlIGdldHRlciwgYW5kIHJlLWNvbGxlY3QgZGVwZW5kZW5jaWVzLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQgKCkge1xuICBwdXNoVGFyZ2V0KHRoaXMpO1xuICB2YXIgdmFsdWU7XG4gIHZhciB2bSA9IHRoaXMudm07XG4gIHRyeSB7XG4gICAgdmFsdWUgPSB0aGlzLmdldHRlci5jYWxsKHZtLCB2bSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAodGhpcy51c2VyKSB7XG4gICAgICBoYW5kbGVFcnJvcihlLCB2bSwgKFwiZ2V0dGVyIGZvciB3YXRjaGVyIFxcXCJcIiArICh0aGlzLmV4cHJlc3Npb24pICsgXCJcXFwiXCIpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgZVxuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICAvLyBcInRvdWNoXCIgZXZlcnkgcHJvcGVydHkgc28gdGhleSBhcmUgYWxsIHRyYWNrZWQgYXNcbiAgICAvLyBkZXBlbmRlbmNpZXMgZm9yIGRlZXAgd2F0Y2hpbmdcbiAgICBpZiAodGhpcy5kZWVwKSB7XG4gICAgICB0cmF2ZXJzZSh2YWx1ZSk7XG4gICAgfVxuICAgIHBvcFRhcmdldCgpO1xuICAgIHRoaXMuY2xlYW51cERlcHMoKTtcbiAgfVxuICByZXR1cm4gdmFsdWVcbn07XG5cbi8qKlxuICogQWRkIGEgZGVwZW5kZW5jeSB0byB0aGlzIGRpcmVjdGl2ZS5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUuYWRkRGVwID0gZnVuY3Rpb24gYWRkRGVwIChkZXApIHtcbiAgdmFyIGlkID0gZGVwLmlkO1xuICBpZiAoIXRoaXMubmV3RGVwSWRzLmhhcyhpZCkpIHtcbiAgICB0aGlzLm5ld0RlcElkcy5hZGQoaWQpO1xuICAgIHRoaXMubmV3RGVwcy5wdXNoKGRlcCk7XG4gICAgaWYgKCF0aGlzLmRlcElkcy5oYXMoaWQpKSB7XG4gICAgICBkZXAuYWRkU3ViKHRoaXMpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBDbGVhbiB1cCBmb3IgZGVwZW5kZW5jeSBjb2xsZWN0aW9uLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5jbGVhbnVwRGVwcyA9IGZ1bmN0aW9uIGNsZWFudXBEZXBzICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICB2YXIgZGVwID0gdGhpcyQxLmRlcHNbaV07XG4gICAgaWYgKCF0aGlzJDEubmV3RGVwSWRzLmhhcyhkZXAuaWQpKSB7XG4gICAgICBkZXAucmVtb3ZlU3ViKHRoaXMkMSk7XG4gICAgfVxuICB9XG4gIHZhciB0bXAgPSB0aGlzLmRlcElkcztcbiAgdGhpcy5kZXBJZHMgPSB0aGlzLm5ld0RlcElkcztcbiAgdGhpcy5uZXdEZXBJZHMgPSB0bXA7XG4gIHRoaXMubmV3RGVwSWRzLmNsZWFyKCk7XG4gIHRtcCA9IHRoaXMuZGVwcztcbiAgdGhpcy5kZXBzID0gdGhpcy5uZXdEZXBzO1xuICB0aGlzLm5ld0RlcHMgPSB0bXA7XG4gIHRoaXMubmV3RGVwcy5sZW5ndGggPSAwO1xufTtcblxuLyoqXG4gKiBTdWJzY3JpYmVyIGludGVyZmFjZS5cbiAqIFdpbGwgYmUgY2FsbGVkIHdoZW4gYSBkZXBlbmRlbmN5IGNoYW5nZXMuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSAoKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmICh0aGlzLmxhenkpIHtcbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgfSBlbHNlIGlmICh0aGlzLnN5bmMpIHtcbiAgICB0aGlzLnJ1bigpO1xuICB9IGVsc2Uge1xuICAgIHF1ZXVlV2F0Y2hlcih0aGlzKTtcbiAgfVxufTtcblxuLyoqXG4gKiBTY2hlZHVsZXIgam9iIGludGVyZmFjZS5cbiAqIFdpbGwgYmUgY2FsbGVkIGJ5IHRoZSBzY2hlZHVsZXIuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uIHJ1biAoKSB7XG4gIGlmICh0aGlzLmFjdGl2ZSkge1xuICAgIHZhciB2YWx1ZSA9IHRoaXMuZ2V0KCk7XG4gICAgaWYgKFxuICAgICAgdmFsdWUgIT09IHRoaXMudmFsdWUgfHxcbiAgICAgIC8vIERlZXAgd2F0Y2hlcnMgYW5kIHdhdGNoZXJzIG9uIE9iamVjdC9BcnJheXMgc2hvdWxkIGZpcmUgZXZlblxuICAgICAgLy8gd2hlbiB0aGUgdmFsdWUgaXMgdGhlIHNhbWUsIGJlY2F1c2UgdGhlIHZhbHVlIG1heVxuICAgICAgLy8gaGF2ZSBtdXRhdGVkLlxuICAgICAgaXNPYmplY3QodmFsdWUpIHx8XG4gICAgICB0aGlzLmRlZXBcbiAgICApIHtcbiAgICAgIC8vIHNldCBuZXcgdmFsdWVcbiAgICAgIHZhciBvbGRWYWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICBpZiAodGhpcy51c2VyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhpcy5jYi5jYWxsKHRoaXMudm0sIHZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBoYW5kbGVFcnJvcihlLCB0aGlzLnZtLCAoXCJjYWxsYmFjayBmb3Igd2F0Y2hlciBcXFwiXCIgKyAodGhpcy5leHByZXNzaW9uKSArIFwiXFxcIlwiKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY2IuY2FsbCh0aGlzLnZtLCB2YWx1ZSwgb2xkVmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBFdmFsdWF0ZSB0aGUgdmFsdWUgb2YgdGhlIHdhdGNoZXIuXG4gKiBUaGlzIG9ubHkgZ2V0cyBjYWxsZWQgZm9yIGxhenkgd2F0Y2hlcnMuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24gZXZhbHVhdGUgKCkge1xuICB0aGlzLnZhbHVlID0gdGhpcy5nZXQoKTtcbiAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xufTtcblxuLyoqXG4gKiBEZXBlbmQgb24gYWxsIGRlcHMgY29sbGVjdGVkIGJ5IHRoaXMgd2F0Y2hlci5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUuZGVwZW5kID0gZnVuY3Rpb24gZGVwZW5kICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICB0aGlzJDEuZGVwc1tpXS5kZXBlbmQoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZW1vdmUgc2VsZiBmcm9tIGFsbCBkZXBlbmRlbmNpZXMnIHN1YnNjcmliZXIgbGlzdC5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUudGVhcmRvd24gPSBmdW5jdGlvbiB0ZWFyZG93biAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgaWYgKHRoaXMuYWN0aXZlKSB7XG4gICAgLy8gcmVtb3ZlIHNlbGYgZnJvbSB2bSdzIHdhdGNoZXIgbGlzdFxuICAgIC8vIHRoaXMgaXMgYSBzb21ld2hhdCBleHBlbnNpdmUgb3BlcmF0aW9uIHNvIHdlIHNraXAgaXRcbiAgICAvLyBpZiB0aGUgdm0gaXMgYmVpbmcgZGVzdHJveWVkLlxuICAgIGlmICghdGhpcy52bS5faXNCZWluZ0Rlc3Ryb3llZCkge1xuICAgICAgcmVtb3ZlKHRoaXMudm0uX3dhdGNoZXJzLCB0aGlzKTtcbiAgICB9XG4gICAgdmFyIGkgPSB0aGlzLmRlcHMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHRoaXMkMS5kZXBzW2ldLnJlbW92ZVN1Yih0aGlzJDEpO1xuICAgIH1cbiAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICB9XG59O1xuXG4vKiAgKi9cblxudmFyIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbiA9IHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBnZXQ6IG5vb3AsXG4gIHNldDogbm9vcFxufTtcblxuZnVuY3Rpb24gcHJveHkgKHRhcmdldCwgc291cmNlS2V5LCBrZXkpIHtcbiAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLmdldCA9IGZ1bmN0aW9uIHByb3h5R2V0dGVyICgpIHtcbiAgICByZXR1cm4gdGhpc1tzb3VyY2VLZXldW2tleV1cbiAgfTtcbiAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IGZ1bmN0aW9uIHByb3h5U2V0dGVyICh2YWwpIHtcbiAgICB0aGlzW3NvdXJjZUtleV1ba2V5XSA9IHZhbDtcbiAgfTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24pO1xufVxuXG5mdW5jdGlvbiBpbml0U3RhdGUgKHZtKSB7XG4gIHZtLl93YXRjaGVycyA9IFtdO1xuICB2YXIgb3B0cyA9IHZtLiRvcHRpb25zO1xuICBpZiAob3B0cy5wcm9wcykgeyBpbml0UHJvcHModm0sIG9wdHMucHJvcHMpOyB9XG4gIGlmIChvcHRzLm1ldGhvZHMpIHsgaW5pdE1ldGhvZHModm0sIG9wdHMubWV0aG9kcyk7IH1cbiAgaWYgKG9wdHMuZGF0YSkge1xuICAgIGluaXREYXRhKHZtKTtcbiAgfSBlbHNlIHtcbiAgICBvYnNlcnZlKHZtLl9kYXRhID0ge30sIHRydWUgLyogYXNSb290RGF0YSAqLyk7XG4gIH1cbiAgaWYgKG9wdHMuY29tcHV0ZWQpIHsgaW5pdENvbXB1dGVkKHZtLCBvcHRzLmNvbXB1dGVkKTsgfVxuICBpZiAob3B0cy53YXRjaCAmJiBvcHRzLndhdGNoICE9PSBuYXRpdmVXYXRjaCkge1xuICAgIGluaXRXYXRjaCh2bSwgb3B0cy53YXRjaCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdFByb3BzICh2bSwgcHJvcHNPcHRpb25zKSB7XG4gIHZhciBwcm9wc0RhdGEgPSB2bS4kb3B0aW9ucy5wcm9wc0RhdGEgfHwge307XG4gIHZhciBwcm9wcyA9IHZtLl9wcm9wcyA9IHt9O1xuICAvLyBjYWNoZSBwcm9wIGtleXMgc28gdGhhdCBmdXR1cmUgcHJvcHMgdXBkYXRlcyBjYW4gaXRlcmF0ZSB1c2luZyBBcnJheVxuICAvLyBpbnN0ZWFkIG9mIGR5bmFtaWMgb2JqZWN0IGtleSBlbnVtZXJhdGlvbi5cbiAgdmFyIGtleXMgPSB2bS4kb3B0aW9ucy5fcHJvcEtleXMgPSBbXTtcbiAgdmFyIGlzUm9vdCA9ICF2bS4kcGFyZW50O1xuICAvLyByb290IGluc3RhbmNlIHByb3BzIHNob3VsZCBiZSBjb252ZXJ0ZWRcbiAgaWYgKCFpc1Jvb3QpIHtcbiAgICB0b2dnbGVPYnNlcnZpbmcoZmFsc2UpO1xuICB9XG4gIHZhciBsb29wID0gZnVuY3Rpb24gKCBrZXkgKSB7XG4gICAga2V5cy5wdXNoKGtleSk7XG4gICAgdmFyIHZhbHVlID0gdmFsaWRhdGVQcm9wKGtleSwgcHJvcHNPcHRpb25zLCBwcm9wc0RhdGEsIHZtKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgaHlwaGVuYXRlZEtleSA9IGh5cGhlbmF0ZShrZXkpO1xuICAgICAgaWYgKGlzUmVzZXJ2ZWRBdHRyaWJ1dGUoaHlwaGVuYXRlZEtleSkgfHxcbiAgICAgICAgICBjb25maWcuaXNSZXNlcnZlZEF0dHIoaHlwaGVuYXRlZEtleSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAoXCJcXFwiXCIgKyBoeXBoZW5hdGVkS2V5ICsgXCJcXFwiIGlzIGEgcmVzZXJ2ZWQgYXR0cmlidXRlIGFuZCBjYW5ub3QgYmUgdXNlZCBhcyBjb21wb25lbnQgcHJvcC5cIiksXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGRlZmluZVJlYWN0aXZlKHByb3BzLCBrZXksIHZhbHVlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh2bS4kcGFyZW50ICYmICFpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgXCJBdm9pZCBtdXRhdGluZyBhIHByb3AgZGlyZWN0bHkgc2luY2UgdGhlIHZhbHVlIHdpbGwgYmUgXCIgK1xuICAgICAgICAgICAgXCJvdmVyd3JpdHRlbiB3aGVuZXZlciB0aGUgcGFyZW50IGNvbXBvbmVudCByZS1yZW5kZXJzLiBcIiArXG4gICAgICAgICAgICBcIkluc3RlYWQsIHVzZSBhIGRhdGEgb3IgY29tcHV0ZWQgcHJvcGVydHkgYmFzZWQgb24gdGhlIHByb3AncyBcIiArXG4gICAgICAgICAgICBcInZhbHVlLiBQcm9wIGJlaW5nIG11dGF0ZWQ6IFxcXCJcIiArIGtleSArIFwiXFxcIlwiLFxuICAgICAgICAgICAgdm1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVmaW5lUmVhY3RpdmUocHJvcHMsIGtleSwgdmFsdWUpO1xuICAgIH1cbiAgICAvLyBzdGF0aWMgcHJvcHMgYXJlIGFscmVhZHkgcHJveGllZCBvbiB0aGUgY29tcG9uZW50J3MgcHJvdG90eXBlXG4gICAgLy8gZHVyaW5nIFZ1ZS5leHRlbmQoKS4gV2Ugb25seSBuZWVkIHRvIHByb3h5IHByb3BzIGRlZmluZWQgYXRcbiAgICAvLyBpbnN0YW50aWF0aW9uIGhlcmUuXG4gICAgaWYgKCEoa2V5IGluIHZtKSkge1xuICAgICAgcHJveHkodm0sIFwiX3Byb3BzXCIsIGtleSk7XG4gICAgfVxuICB9O1xuXG4gIGZvciAodmFyIGtleSBpbiBwcm9wc09wdGlvbnMpIGxvb3AoIGtleSApO1xuICB0b2dnbGVPYnNlcnZpbmcodHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIGluaXREYXRhICh2bSkge1xuICB2YXIgZGF0YSA9IHZtLiRvcHRpb25zLmRhdGE7XG4gIGRhdGEgPSB2bS5fZGF0YSA9IHR5cGVvZiBkYXRhID09PSAnZnVuY3Rpb24nXG4gICAgPyBnZXREYXRhKGRhdGEsIHZtKVxuICAgIDogZGF0YSB8fCB7fTtcbiAgaWYgKCFpc1BsYWluT2JqZWN0KGRhdGEpKSB7XG4gICAgZGF0YSA9IHt9O1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICdkYXRhIGZ1bmN0aW9ucyBzaG91bGQgcmV0dXJuIGFuIG9iamVjdDpcXG4nICtcbiAgICAgICdodHRwczovL3Z1ZWpzLm9yZy92Mi9ndWlkZS9jb21wb25lbnRzLmh0bWwjZGF0YS1NdXN0LUJlLWEtRnVuY3Rpb24nLFxuICAgICAgdm1cbiAgICApO1xuICB9XG4gIC8vIHByb3h5IGRhdGEgb24gaW5zdGFuY2VcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhkYXRhKTtcbiAgdmFyIHByb3BzID0gdm0uJG9wdGlvbnMucHJvcHM7XG4gIHZhciBtZXRob2RzID0gdm0uJG9wdGlvbnMubWV0aG9kcztcbiAgdmFyIGkgPSBrZXlzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAobWV0aG9kcyAmJiBoYXNPd24obWV0aG9kcywga2V5KSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIChcIk1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaGFzIGFscmVhZHkgYmVlbiBkZWZpbmVkIGFzIGEgZGF0YSBwcm9wZXJ0eS5cIiksXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHByb3BzICYmIGhhc093bihwcm9wcywga2V5KSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICBcIlRoZSBkYXRhIHByb3BlcnR5IFxcXCJcIiArIGtleSArIFwiXFxcIiBpcyBhbHJlYWR5IGRlY2xhcmVkIGFzIGEgcHJvcC4gXCIgK1xuICAgICAgICBcIlVzZSBwcm9wIGRlZmF1bHQgdmFsdWUgaW5zdGVhZC5cIixcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfSBlbHNlIGlmICghaXNSZXNlcnZlZChrZXkpKSB7XG4gICAgICBwcm94eSh2bSwgXCJfZGF0YVwiLCBrZXkpO1xuICAgIH1cbiAgfVxuICAvLyBvYnNlcnZlIGRhdGFcbiAgb2JzZXJ2ZShkYXRhLCB0cnVlIC8qIGFzUm9vdERhdGEgKi8pO1xufVxuXG5mdW5jdGlvbiBnZXREYXRhIChkYXRhLCB2bSkge1xuICAvLyAjNzU3MyBkaXNhYmxlIGRlcCBjb2xsZWN0aW9uIHdoZW4gaW52b2tpbmcgZGF0YSBnZXR0ZXJzXG4gIHB1c2hUYXJnZXQoKTtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZGF0YS5jYWxsKHZtLCB2bSlcbiAgfSBjYXRjaCAoZSkge1xuICAgIGhhbmRsZUVycm9yKGUsIHZtLCBcImRhdGEoKVwiKTtcbiAgICByZXR1cm4ge31cbiAgfSBmaW5hbGx5IHtcbiAgICBwb3BUYXJnZXQoKTtcbiAgfVxufVxuXG52YXIgY29tcHV0ZWRXYXRjaGVyT3B0aW9ucyA9IHsgbGF6eTogdHJ1ZSB9O1xuXG5mdW5jdGlvbiBpbml0Q29tcHV0ZWQgKHZtLCBjb21wdXRlZCkge1xuICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgdmFyIHdhdGNoZXJzID0gdm0uX2NvbXB1dGVkV2F0Y2hlcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAvLyBjb21wdXRlZCBwcm9wZXJ0aWVzIGFyZSBqdXN0IGdldHRlcnMgZHVyaW5nIFNTUlxuICB2YXIgaXNTU1IgPSBpc1NlcnZlclJlbmRlcmluZygpO1xuXG4gIGZvciAodmFyIGtleSBpbiBjb21wdXRlZCkge1xuICAgIHZhciB1c2VyRGVmID0gY29tcHV0ZWRba2V5XTtcbiAgICB2YXIgZ2V0dGVyID0gdHlwZW9mIHVzZXJEZWYgPT09ICdmdW5jdGlvbicgPyB1c2VyRGVmIDogdXNlckRlZi5nZXQ7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgZ2V0dGVyID09IG51bGwpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIChcIkdldHRlciBpcyBtaXNzaW5nIGZvciBjb21wdXRlZCBwcm9wZXJ0eSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIuXCIpLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoIWlzU1NSKSB7XG4gICAgICAvLyBjcmVhdGUgaW50ZXJuYWwgd2F0Y2hlciBmb3IgdGhlIGNvbXB1dGVkIHByb3BlcnR5LlxuICAgICAgd2F0Y2hlcnNba2V5XSA9IG5ldyBXYXRjaGVyKFxuICAgICAgICB2bSxcbiAgICAgICAgZ2V0dGVyIHx8IG5vb3AsXG4gICAgICAgIG5vb3AsXG4gICAgICAgIGNvbXB1dGVkV2F0Y2hlck9wdGlvbnNcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gY29tcG9uZW50LWRlZmluZWQgY29tcHV0ZWQgcHJvcGVydGllcyBhcmUgYWxyZWFkeSBkZWZpbmVkIG9uIHRoZVxuICAgIC8vIGNvbXBvbmVudCBwcm90b3R5cGUuIFdlIG9ubHkgbmVlZCB0byBkZWZpbmUgY29tcHV0ZWQgcHJvcGVydGllcyBkZWZpbmVkXG4gICAgLy8gYXQgaW5zdGFudGlhdGlvbiBoZXJlLlxuICAgIGlmICghKGtleSBpbiB2bSkpIHtcbiAgICAgIGRlZmluZUNvbXB1dGVkKHZtLCBrZXksIHVzZXJEZWYpO1xuICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGtleSBpbiB2bS4kZGF0YSkge1xuICAgICAgICB3YXJuKChcIlRoZSBjb21wdXRlZCBwcm9wZXJ0eSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaXMgYWxyZWFkeSBkZWZpbmVkIGluIGRhdGEuXCIpLCB2bSk7XG4gICAgICB9IGVsc2UgaWYgKHZtLiRvcHRpb25zLnByb3BzICYmIGtleSBpbiB2bS4kb3B0aW9ucy5wcm9wcykge1xuICAgICAgICB3YXJuKChcIlRoZSBjb21wdXRlZCBwcm9wZXJ0eSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaXMgYWxyZWFkeSBkZWZpbmVkIGFzIGEgcHJvcC5cIiksIHZtKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lQ29tcHV0ZWQgKFxuICB0YXJnZXQsXG4gIGtleSxcbiAgdXNlckRlZlxuKSB7XG4gIHZhciBzaG91bGRDYWNoZSA9ICFpc1NlcnZlclJlbmRlcmluZygpO1xuICBpZiAodHlwZW9mIHVzZXJEZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uZ2V0ID0gc2hvdWxkQ2FjaGVcbiAgICAgID8gY3JlYXRlQ29tcHV0ZWRHZXR0ZXIoa2V5KVxuICAgICAgOiB1c2VyRGVmO1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPSBub29wO1xuICB9IGVsc2Uge1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5nZXQgPSB1c2VyRGVmLmdldFxuICAgICAgPyBzaG91bGRDYWNoZSAmJiB1c2VyRGVmLmNhY2hlICE9PSBmYWxzZVxuICAgICAgICA/IGNyZWF0ZUNvbXB1dGVkR2V0dGVyKGtleSlcbiAgICAgICAgOiB1c2VyRGVmLmdldFxuICAgICAgOiBub29wO1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPSB1c2VyRGVmLnNldFxuICAgICAgPyB1c2VyRGVmLnNldFxuICAgICAgOiBub29wO1xuICB9XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID09PSBub29wKSB7XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIChcIkNvbXB1dGVkIHByb3BlcnR5IFxcXCJcIiArIGtleSArIFwiXFxcIiB3YXMgYXNzaWduZWQgdG8gYnV0IGl0IGhhcyBubyBzZXR0ZXIuXCIpLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgIH07XG4gIH1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDb21wdXRlZEdldHRlciAoa2V5KSB7XG4gIHJldHVybiBmdW5jdGlvbiBjb21wdXRlZEdldHRlciAoKSB7XG4gICAgdmFyIHdhdGNoZXIgPSB0aGlzLl9jb21wdXRlZFdhdGNoZXJzICYmIHRoaXMuX2NvbXB1dGVkV2F0Y2hlcnNba2V5XTtcbiAgICBpZiAod2F0Y2hlcikge1xuICAgICAgaWYgKHdhdGNoZXIuZGlydHkpIHtcbiAgICAgICAgd2F0Y2hlci5ldmFsdWF0ZSgpO1xuICAgICAgfVxuICAgICAgaWYgKERlcC50YXJnZXQpIHtcbiAgICAgICAgd2F0Y2hlci5kZXBlbmQoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3YXRjaGVyLnZhbHVlXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRNZXRob2RzICh2bSwgbWV0aG9kcykge1xuICB2YXIgcHJvcHMgPSB2bS4kb3B0aW9ucy5wcm9wcztcbiAgZm9yICh2YXIga2V5IGluIG1ldGhvZHMpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKG1ldGhvZHNba2V5XSA9PSBudWxsKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgXCJNZXRob2QgXFxcIlwiICsga2V5ICsgXCJcXFwiIGhhcyBhbiB1bmRlZmluZWQgdmFsdWUgaW4gdGhlIGNvbXBvbmVudCBkZWZpbml0aW9uLiBcIiArXG4gICAgICAgICAgXCJEaWQgeW91IHJlZmVyZW5jZSB0aGUgZnVuY3Rpb24gY29ycmVjdGx5P1wiLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAocHJvcHMgJiYgaGFzT3duKHByb3BzLCBrZXkpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgKFwiTWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBoYXMgYWxyZWFkeSBiZWVuIGRlZmluZWQgYXMgYSBwcm9wLlwiKSxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKChrZXkgaW4gdm0pICYmIGlzUmVzZXJ2ZWQoa2V5KSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIFwiTWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBjb25mbGljdHMgd2l0aCBhbiBleGlzdGluZyBWdWUgaW5zdGFuY2UgbWV0aG9kLiBcIiArXG4gICAgICAgICAgXCJBdm9pZCBkZWZpbmluZyBjb21wb25lbnQgbWV0aG9kcyB0aGF0IHN0YXJ0IHdpdGggXyBvciAkLlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHZtW2tleV0gPSBtZXRob2RzW2tleV0gPT0gbnVsbCA/IG5vb3AgOiBiaW5kKG1ldGhvZHNba2V5XSwgdm0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRXYXRjaCAodm0sIHdhdGNoKSB7XG4gIGZvciAodmFyIGtleSBpbiB3YXRjaCkge1xuICAgIHZhciBoYW5kbGVyID0gd2F0Y2hba2V5XTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShoYW5kbGVyKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoYW5kbGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNyZWF0ZVdhdGNoZXIodm0sIGtleSwgaGFuZGxlcltpXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNyZWF0ZVdhdGNoZXIodm0sIGtleSwgaGFuZGxlcik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVdhdGNoZXIgKFxuICB2bSxcbiAgZXhwT3JGbixcbiAgaGFuZGxlcixcbiAgb3B0aW9uc1xuKSB7XG4gIGlmIChpc1BsYWluT2JqZWN0KGhhbmRsZXIpKSB7XG4gICAgb3B0aW9ucyA9IGhhbmRsZXI7XG4gICAgaGFuZGxlciA9IGhhbmRsZXIuaGFuZGxlcjtcbiAgfVxuICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgaGFuZGxlciA9IHZtW2hhbmRsZXJdO1xuICB9XG4gIHJldHVybiB2bS4kd2F0Y2goZXhwT3JGbiwgaGFuZGxlciwgb3B0aW9ucylcbn1cblxuZnVuY3Rpb24gc3RhdGVNaXhpbiAoVnVlKSB7XG4gIC8vIGZsb3cgc29tZWhvdyBoYXMgcHJvYmxlbXMgd2l0aCBkaXJlY3RseSBkZWNsYXJlZCBkZWZpbml0aW9uIG9iamVjdFxuICAvLyB3aGVuIHVzaW5nIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSwgc28gd2UgaGF2ZSB0byBwcm9jZWR1cmFsbHkgYnVpbGQgdXBcbiAgLy8gdGhlIG9iamVjdCBoZXJlLlxuICB2YXIgZGF0YURlZiA9IHt9O1xuICBkYXRhRGVmLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2RhdGEgfTtcbiAgdmFyIHByb3BzRGVmID0ge307XG4gIHByb3BzRGVmLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3Byb3BzIH07XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgZGF0YURlZi5zZXQgPSBmdW5jdGlvbiAobmV3RGF0YSkge1xuICAgICAgd2FybihcbiAgICAgICAgJ0F2b2lkIHJlcGxhY2luZyBpbnN0YW5jZSByb290ICRkYXRhLiAnICtcbiAgICAgICAgJ1VzZSBuZXN0ZWQgZGF0YSBwcm9wZXJ0aWVzIGluc3RlYWQuJyxcbiAgICAgICAgdGhpc1xuICAgICAgKTtcbiAgICB9O1xuICAgIHByb3BzRGVmLnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHdhcm4oXCIkcHJvcHMgaXMgcmVhZG9ubHkuXCIsIHRoaXMpO1xuICAgIH07XG4gIH1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZS5wcm90b3R5cGUsICckZGF0YScsIGRhdGFEZWYpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRwcm9wcycsIHByb3BzRGVmKTtcblxuICBWdWUucHJvdG90eXBlLiRzZXQgPSBzZXQ7XG4gIFZ1ZS5wcm90b3R5cGUuJGRlbGV0ZSA9IGRlbDtcblxuICBWdWUucHJvdG90eXBlLiR3YXRjaCA9IGZ1bmN0aW9uIChcbiAgICBleHBPckZuLFxuICAgIGNiLFxuICAgIG9wdGlvbnNcbiAgKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAoaXNQbGFpbk9iamVjdChjYikpIHtcbiAgICAgIHJldHVybiBjcmVhdGVXYXRjaGVyKHZtLCBleHBPckZuLCBjYiwgb3B0aW9ucylcbiAgICB9XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgb3B0aW9ucy51c2VyID0gdHJ1ZTtcbiAgICB2YXIgd2F0Y2hlciA9IG5ldyBXYXRjaGVyKHZtLCBleHBPckZuLCBjYiwgb3B0aW9ucyk7XG4gICAgaWYgKG9wdGlvbnMuaW1tZWRpYXRlKSB7XG4gICAgICBjYi5jYWxsKHZtLCB3YXRjaGVyLnZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVud2F0Y2hGbiAoKSB7XG4gICAgICB3YXRjaGVyLnRlYXJkb3duKCk7XG4gICAgfVxuICB9O1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdFByb3ZpZGUgKHZtKSB7XG4gIHZhciBwcm92aWRlID0gdm0uJG9wdGlvbnMucHJvdmlkZTtcbiAgaWYgKHByb3ZpZGUpIHtcbiAgICB2bS5fcHJvdmlkZWQgPSB0eXBlb2YgcHJvdmlkZSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgPyBwcm92aWRlLmNhbGwodm0pXG4gICAgICA6IHByb3ZpZGU7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdEluamVjdGlvbnMgKHZtKSB7XG4gIHZhciByZXN1bHQgPSByZXNvbHZlSW5qZWN0KHZtLiRvcHRpb25zLmluamVjdCwgdm0pO1xuICBpZiAocmVzdWx0KSB7XG4gICAgdG9nZ2xlT2JzZXJ2aW5nKGZhbHNlKTtcbiAgICBPYmplY3Qua2V5cyhyZXN1bHQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGRlZmluZVJlYWN0aXZlKHZtLCBrZXksIHJlc3VsdFtrZXldLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgIFwiQXZvaWQgbXV0YXRpbmcgYW4gaW5qZWN0ZWQgdmFsdWUgZGlyZWN0bHkgc2luY2UgdGhlIGNoYW5nZXMgd2lsbCBiZSBcIiArXG4gICAgICAgICAgICBcIm92ZXJ3cml0dGVuIHdoZW5ldmVyIHRoZSBwcm92aWRlZCBjb21wb25lbnQgcmUtcmVuZGVycy4gXCIgK1xuICAgICAgICAgICAgXCJpbmplY3Rpb24gYmVpbmcgbXV0YXRlZDogXFxcIlwiICsga2V5ICsgXCJcXFwiXCIsXG4gICAgICAgICAgICB2bVxuICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVmaW5lUmVhY3RpdmUodm0sIGtleSwgcmVzdWx0W2tleV0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRvZ2dsZU9ic2VydmluZyh0cnVlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXNvbHZlSW5qZWN0IChpbmplY3QsIHZtKSB7XG4gIGlmIChpbmplY3QpIHtcbiAgICAvLyBpbmplY3QgaXMgOmFueSBiZWNhdXNlIGZsb3cgaXMgbm90IHNtYXJ0IGVub3VnaCB0byBmaWd1cmUgb3V0IGNhY2hlZFxuICAgIHZhciByZXN1bHQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHZhciBrZXlzID0gaGFzU3ltYm9sXG4gICAgICA/IFJlZmxlY3Qub3duS2V5cyhpbmplY3QpLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGluamVjdCwga2V5KS5lbnVtZXJhYmxlXG4gICAgICB9KVxuICAgICAgOiBPYmplY3Qua2V5cyhpbmplY3QpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgIHZhciBwcm92aWRlS2V5ID0gaW5qZWN0W2tleV0uZnJvbTtcbiAgICAgIHZhciBzb3VyY2UgPSB2bTtcbiAgICAgIHdoaWxlIChzb3VyY2UpIHtcbiAgICAgICAgaWYgKHNvdXJjZS5fcHJvdmlkZWQgJiYgaGFzT3duKHNvdXJjZS5fcHJvdmlkZWQsIHByb3ZpZGVLZXkpKSB7XG4gICAgICAgICAgcmVzdWx0W2tleV0gPSBzb3VyY2UuX3Byb3ZpZGVkW3Byb3ZpZGVLZXldO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgc291cmNlID0gc291cmNlLiRwYXJlbnQ7XG4gICAgICB9XG4gICAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgICBpZiAoJ2RlZmF1bHQnIGluIGluamVjdFtrZXldKSB7XG4gICAgICAgICAgdmFyIHByb3ZpZGVEZWZhdWx0ID0gaW5qZWN0W2tleV0uZGVmYXVsdDtcbiAgICAgICAgICByZXN1bHRba2V5XSA9IHR5cGVvZiBwcm92aWRlRGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgPyBwcm92aWRlRGVmYXVsdC5jYWxsKHZtKVxuICAgICAgICAgICAgOiBwcm92aWRlRGVmYXVsdDtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgd2FybigoXCJJbmplY3Rpb24gXFxcIlwiICsga2V5ICsgXCJcXFwiIG5vdCBmb3VuZFwiKSwgdm0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRcbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVuZGVyaW5nIHYtZm9yIGxpc3RzLlxuICovXG5mdW5jdGlvbiByZW5kZXJMaXN0IChcbiAgdmFsLFxuICByZW5kZXJcbikge1xuICB2YXIgcmV0LCBpLCBsLCBrZXlzLCBrZXk7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbCkgfHwgdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICByZXQgPSBuZXcgQXJyYXkodmFsLmxlbmd0aCk7XG4gICAgZm9yIChpID0gMCwgbCA9IHZhbC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHJldFtpXSA9IHJlbmRlcih2YWxbaV0sIGkpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHJldCA9IG5ldyBBcnJheSh2YWwpO1xuICAgIGZvciAoaSA9IDA7IGkgPCB2YWw7IGkrKykge1xuICAgICAgcmV0W2ldID0gcmVuZGVyKGkgKyAxLCBpKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QodmFsKSkge1xuICAgIGtleXMgPSBPYmplY3Qua2V5cyh2YWwpO1xuICAgIHJldCA9IG5ldyBBcnJheShrZXlzLmxlbmd0aCk7XG4gICAgZm9yIChpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgcmV0W2ldID0gcmVuZGVyKHZhbFtrZXldLCBrZXksIGkpO1xuICAgIH1cbiAgfVxuICBpZiAoaXNEZWYocmV0KSkge1xuICAgIChyZXQpLl9pc1ZMaXN0ID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZW5kZXJpbmcgPHNsb3Q+XG4gKi9cbmZ1bmN0aW9uIHJlbmRlclNsb3QgKFxuICBuYW1lLFxuICBmYWxsYmFjayxcbiAgcHJvcHMsXG4gIGJpbmRPYmplY3Rcbikge1xuICB2YXIgc2NvcGVkU2xvdEZuID0gdGhpcy4kc2NvcGVkU2xvdHNbbmFtZV07XG4gIHZhciBub2RlcztcbiAgaWYgKHNjb3BlZFNsb3RGbikgeyAvLyBzY29wZWQgc2xvdFxuICAgIHByb3BzID0gcHJvcHMgfHwge307XG4gICAgaWYgKGJpbmRPYmplY3QpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICFpc09iamVjdChiaW5kT2JqZWN0KSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdzbG90IHYtYmluZCB3aXRob3V0IGFyZ3VtZW50IGV4cGVjdHMgYW4gT2JqZWN0JyxcbiAgICAgICAgICB0aGlzXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBwcm9wcyA9IGV4dGVuZChleHRlbmQoe30sIGJpbmRPYmplY3QpLCBwcm9wcyk7XG4gICAgfVxuICAgIG5vZGVzID0gc2NvcGVkU2xvdEZuKHByb3BzKSB8fCBmYWxsYmFjaztcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2xvdE5vZGVzID0gdGhpcy4kc2xvdHNbbmFtZV07XG4gICAgLy8gd2FybiBkdXBsaWNhdGUgc2xvdCB1c2FnZVxuICAgIGlmIChzbG90Tm9kZXMpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHNsb3ROb2Rlcy5fcmVuZGVyZWQpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBcIkR1cGxpY2F0ZSBwcmVzZW5jZSBvZiBzbG90IFxcXCJcIiArIG5hbWUgKyBcIlxcXCIgZm91bmQgaW4gdGhlIHNhbWUgcmVuZGVyIHRyZWUgXCIgK1xuICAgICAgICAgIFwiLSB0aGlzIHdpbGwgbGlrZWx5IGNhdXNlIHJlbmRlciBlcnJvcnMuXCIsXG4gICAgICAgICAgdGhpc1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgc2xvdE5vZGVzLl9yZW5kZXJlZCA9IHRydWU7XG4gICAgfVxuICAgIG5vZGVzID0gc2xvdE5vZGVzIHx8IGZhbGxiYWNrO1xuICB9XG5cbiAgdmFyIHRhcmdldCA9IHByb3BzICYmIHByb3BzLnNsb3Q7XG4gIGlmICh0YXJnZXQpIHtcbiAgICByZXR1cm4gdGhpcy4kY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnLCB7IHNsb3Q6IHRhcmdldCB9LCBub2RlcylcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbm9kZXNcbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVzb2x2aW5nIGZpbHRlcnNcbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZUZpbHRlciAoaWQpIHtcbiAgcmV0dXJuIHJlc29sdmVBc3NldCh0aGlzLiRvcHRpb25zLCAnZmlsdGVycycsIGlkLCB0cnVlKSB8fCBpZGVudGl0eVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaXNLZXlOb3RNYXRjaCAoZXhwZWN0LCBhY3R1YWwpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoZXhwZWN0KSkge1xuICAgIHJldHVybiBleHBlY3QuaW5kZXhPZihhY3R1YWwpID09PSAtMVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBleHBlY3QgIT09IGFjdHVhbFxuICB9XG59XG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIGNoZWNraW5nIGtleUNvZGVzIGZyb20gY29uZmlnLlxuICogZXhwb3NlZCBhcyBWdWUucHJvdG90eXBlLl9rXG4gKiBwYXNzaW5nIGluIGV2ZW50S2V5TmFtZSBhcyBsYXN0IGFyZ3VtZW50IHNlcGFyYXRlbHkgZm9yIGJhY2t3YXJkcyBjb21wYXRcbiAqL1xuZnVuY3Rpb24gY2hlY2tLZXlDb2RlcyAoXG4gIGV2ZW50S2V5Q29kZSxcbiAga2V5LFxuICBidWlsdEluS2V5Q29kZSxcbiAgZXZlbnRLZXlOYW1lLFxuICBidWlsdEluS2V5TmFtZVxuKSB7XG4gIHZhciBtYXBwZWRLZXlDb2RlID0gY29uZmlnLmtleUNvZGVzW2tleV0gfHwgYnVpbHRJbktleUNvZGU7XG4gIGlmIChidWlsdEluS2V5TmFtZSAmJiBldmVudEtleU5hbWUgJiYgIWNvbmZpZy5rZXlDb2Rlc1trZXldKSB7XG4gICAgcmV0dXJuIGlzS2V5Tm90TWF0Y2goYnVpbHRJbktleU5hbWUsIGV2ZW50S2V5TmFtZSlcbiAgfSBlbHNlIGlmIChtYXBwZWRLZXlDb2RlKSB7XG4gICAgcmV0dXJuIGlzS2V5Tm90TWF0Y2gobWFwcGVkS2V5Q29kZSwgZXZlbnRLZXlDb2RlKVxuICB9IGVsc2UgaWYgKGV2ZW50S2V5TmFtZSkge1xuICAgIHJldHVybiBoeXBoZW5hdGUoZXZlbnRLZXlOYW1lKSAhPT0ga2V5XG4gIH1cbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIG1lcmdpbmcgdi1iaW5kPVwib2JqZWN0XCIgaW50byBhIFZOb2RlJ3MgZGF0YS5cbiAqL1xuZnVuY3Rpb24gYmluZE9iamVjdFByb3BzIChcbiAgZGF0YSxcbiAgdGFnLFxuICB2YWx1ZSxcbiAgYXNQcm9wLFxuICBpc1N5bmNcbikge1xuICBpZiAodmFsdWUpIHtcbiAgICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICAndi1iaW5kIHdpdGhvdXQgYXJndW1lbnQgZXhwZWN0cyBhbiBPYmplY3Qgb3IgQXJyYXkgdmFsdWUnLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUgPSB0b09iamVjdCh2YWx1ZSk7XG4gICAgICB9XG4gICAgICB2YXIgaGFzaDtcbiAgICAgIHZhciBsb29wID0gZnVuY3Rpb24gKCBrZXkgKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBrZXkgPT09ICdjbGFzcycgfHxcbiAgICAgICAgICBrZXkgPT09ICdzdHlsZScgfHxcbiAgICAgICAgICBpc1Jlc2VydmVkQXR0cmlidXRlKGtleSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgaGFzaCA9IGRhdGE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHR5cGUgPSBkYXRhLmF0dHJzICYmIGRhdGEuYXR0cnMudHlwZTtcbiAgICAgICAgICBoYXNoID0gYXNQcm9wIHx8IGNvbmZpZy5tdXN0VXNlUHJvcCh0YWcsIHR5cGUsIGtleSlcbiAgICAgICAgICAgID8gZGF0YS5kb21Qcm9wcyB8fCAoZGF0YS5kb21Qcm9wcyA9IHt9KVxuICAgICAgICAgICAgOiBkYXRhLmF0dHJzIHx8IChkYXRhLmF0dHJzID0ge30pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKGtleSBpbiBoYXNoKSkge1xuICAgICAgICAgIGhhc2hba2V5XSA9IHZhbHVlW2tleV07XG5cbiAgICAgICAgICBpZiAoaXNTeW5jKSB7XG4gICAgICAgICAgICB2YXIgb24gPSBkYXRhLm9uIHx8IChkYXRhLm9uID0ge30pO1xuICAgICAgICAgICAgb25bKFwidXBkYXRlOlwiICsga2V5KV0gPSBmdW5jdGlvbiAoJGV2ZW50KSB7XG4gICAgICAgICAgICAgIHZhbHVlW2tleV0gPSAkZXZlbnQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgZm9yICh2YXIga2V5IGluIHZhbHVlKSBsb29wKCBrZXkgKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlbmRlcmluZyBzdGF0aWMgdHJlZXMuXG4gKi9cbmZ1bmN0aW9uIHJlbmRlclN0YXRpYyAoXG4gIGluZGV4LFxuICBpc0luRm9yXG4pIHtcbiAgdmFyIGNhY2hlZCA9IHRoaXMuX3N0YXRpY1RyZWVzIHx8ICh0aGlzLl9zdGF0aWNUcmVlcyA9IFtdKTtcbiAgdmFyIHRyZWUgPSBjYWNoZWRbaW5kZXhdO1xuICAvLyBpZiBoYXMgYWxyZWFkeS1yZW5kZXJlZCBzdGF0aWMgdHJlZSBhbmQgbm90IGluc2lkZSB2LWZvcixcbiAgLy8gd2UgY2FuIHJldXNlIHRoZSBzYW1lIHRyZWUuXG4gIGlmICh0cmVlICYmICFpc0luRm9yKSB7XG4gICAgcmV0dXJuIHRyZWVcbiAgfVxuICAvLyBvdGhlcndpc2UsIHJlbmRlciBhIGZyZXNoIHRyZWUuXG4gIHRyZWUgPSBjYWNoZWRbaW5kZXhdID0gdGhpcy4kb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnNbaW5kZXhdLmNhbGwoXG4gICAgdGhpcy5fcmVuZGVyUHJveHksXG4gICAgbnVsbCxcbiAgICB0aGlzIC8vIGZvciByZW5kZXIgZm5zIGdlbmVyYXRlZCBmb3IgZnVuY3Rpb25hbCBjb21wb25lbnQgdGVtcGxhdGVzXG4gICk7XG4gIG1hcmtTdGF0aWModHJlZSwgKFwiX19zdGF0aWNfX1wiICsgaW5kZXgpLCBmYWxzZSk7XG4gIHJldHVybiB0cmVlXG59XG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHYtb25jZS5cbiAqIEVmZmVjdGl2ZWx5IGl0IG1lYW5zIG1hcmtpbmcgdGhlIG5vZGUgYXMgc3RhdGljIHdpdGggYSB1bmlxdWUga2V5LlxuICovXG5mdW5jdGlvbiBtYXJrT25jZSAoXG4gIHRyZWUsXG4gIGluZGV4LFxuICBrZXlcbikge1xuICBtYXJrU3RhdGljKHRyZWUsIChcIl9fb25jZV9fXCIgKyBpbmRleCArIChrZXkgPyAoXCJfXCIgKyBrZXkpIDogXCJcIikpLCB0cnVlKTtcbiAgcmV0dXJuIHRyZWVcbn1cblxuZnVuY3Rpb24gbWFya1N0YXRpYyAoXG4gIHRyZWUsXG4gIGtleSxcbiAgaXNPbmNlXG4pIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodHJlZSkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyZWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0cmVlW2ldICYmIHR5cGVvZiB0cmVlW2ldICE9PSAnc3RyaW5nJykge1xuICAgICAgICBtYXJrU3RhdGljTm9kZSh0cmVlW2ldLCAoa2V5ICsgXCJfXCIgKyBpKSwgaXNPbmNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbWFya1N0YXRpY05vZGUodHJlZSwga2V5LCBpc09uY2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1hcmtTdGF0aWNOb2RlIChub2RlLCBrZXksIGlzT25jZSkge1xuICBub2RlLmlzU3RhdGljID0gdHJ1ZTtcbiAgbm9kZS5rZXkgPSBrZXk7XG4gIG5vZGUuaXNPbmNlID0gaXNPbmNlO1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gYmluZE9iamVjdExpc3RlbmVycyAoZGF0YSwgdmFsdWUpIHtcbiAgaWYgKHZhbHVlKSB7XG4gICAgaWYgKCFpc1BsYWluT2JqZWN0KHZhbHVlKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICAndi1vbiB3aXRob3V0IGFyZ3VtZW50IGV4cGVjdHMgYW4gT2JqZWN0IHZhbHVlJyxcbiAgICAgICAgdGhpc1xuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG9uID0gZGF0YS5vbiA9IGRhdGEub24gPyBleHRlbmQoe30sIGRhdGEub24pIDoge307XG4gICAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICAgICAgdmFyIGV4aXN0aW5nID0gb25ba2V5XTtcbiAgICAgICAgdmFyIG91cnMgPSB2YWx1ZVtrZXldO1xuICAgICAgICBvbltrZXldID0gZXhpc3RpbmcgPyBbXS5jb25jYXQoZXhpc3RpbmcsIG91cnMpIDogb3VycztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluc3RhbGxSZW5kZXJIZWxwZXJzICh0YXJnZXQpIHtcbiAgdGFyZ2V0Ll9vID0gbWFya09uY2U7XG4gIHRhcmdldC5fbiA9IHRvTnVtYmVyO1xuICB0YXJnZXQuX3MgPSB0b1N0cmluZztcbiAgdGFyZ2V0Ll9sID0gcmVuZGVyTGlzdDtcbiAgdGFyZ2V0Ll90ID0gcmVuZGVyU2xvdDtcbiAgdGFyZ2V0Ll9xID0gbG9vc2VFcXVhbDtcbiAgdGFyZ2V0Ll9pID0gbG9vc2VJbmRleE9mO1xuICB0YXJnZXQuX20gPSByZW5kZXJTdGF0aWM7XG4gIHRhcmdldC5fZiA9IHJlc29sdmVGaWx0ZXI7XG4gIHRhcmdldC5fayA9IGNoZWNrS2V5Q29kZXM7XG4gIHRhcmdldC5fYiA9IGJpbmRPYmplY3RQcm9wcztcbiAgdGFyZ2V0Ll92ID0gY3JlYXRlVGV4dFZOb2RlO1xuICB0YXJnZXQuX2UgPSBjcmVhdGVFbXB0eVZOb2RlO1xuICB0YXJnZXQuX3UgPSByZXNvbHZlU2NvcGVkU2xvdHM7XG4gIHRhcmdldC5fZyA9IGJpbmRPYmplY3RMaXN0ZW5lcnM7XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBGdW5jdGlvbmFsUmVuZGVyQ29udGV4dCAoXG4gIGRhdGEsXG4gIHByb3BzLFxuICBjaGlsZHJlbixcbiAgcGFyZW50LFxuICBDdG9yXG4pIHtcbiAgdmFyIG9wdGlvbnMgPSBDdG9yLm9wdGlvbnM7XG4gIC8vIGVuc3VyZSB0aGUgY3JlYXRlRWxlbWVudCBmdW5jdGlvbiBpbiBmdW5jdGlvbmFsIGNvbXBvbmVudHNcbiAgLy8gZ2V0cyBhIHVuaXF1ZSBjb250ZXh0IC0gdGhpcyBpcyBuZWNlc3NhcnkgZm9yIGNvcnJlY3QgbmFtZWQgc2xvdCBjaGVja1xuICB2YXIgY29udGV4dFZtO1xuICBpZiAoaGFzT3duKHBhcmVudCwgJ191aWQnKSkge1xuICAgIGNvbnRleHRWbSA9IE9iamVjdC5jcmVhdGUocGFyZW50KTtcbiAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICBjb250ZXh0Vm0uX29yaWdpbmFsID0gcGFyZW50O1xuICB9IGVsc2Uge1xuICAgIC8vIHRoZSBjb250ZXh0IHZtIHBhc3NlZCBpbiBpcyBhIGZ1bmN0aW9uYWwgY29udGV4dCBhcyB3ZWxsLlxuICAgIC8vIGluIHRoaXMgY2FzZSB3ZSB3YW50IHRvIG1ha2Ugc3VyZSB3ZSBhcmUgYWJsZSB0byBnZXQgYSBob2xkIHRvIHRoZVxuICAgIC8vIHJlYWwgY29udGV4dCBpbnN0YW5jZS5cbiAgICBjb250ZXh0Vm0gPSBwYXJlbnQ7XG4gICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgcGFyZW50ID0gcGFyZW50Ll9vcmlnaW5hbDtcbiAgfVxuICB2YXIgaXNDb21waWxlZCA9IGlzVHJ1ZShvcHRpb25zLl9jb21waWxlZCk7XG4gIHZhciBuZWVkTm9ybWFsaXphdGlvbiA9ICFpc0NvbXBpbGVkO1xuXG4gIHRoaXMuZGF0YSA9IGRhdGE7XG4gIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgdGhpcy5saXN0ZW5lcnMgPSBkYXRhLm9uIHx8IGVtcHR5T2JqZWN0O1xuICB0aGlzLmluamVjdGlvbnMgPSByZXNvbHZlSW5qZWN0KG9wdGlvbnMuaW5qZWN0LCBwYXJlbnQpO1xuICB0aGlzLnNsb3RzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVzb2x2ZVNsb3RzKGNoaWxkcmVuLCBwYXJlbnQpOyB9O1xuXG4gIC8vIHN1cHBvcnQgZm9yIGNvbXBpbGVkIGZ1bmN0aW9uYWwgdGVtcGxhdGVcbiAgaWYgKGlzQ29tcGlsZWQpIHtcbiAgICAvLyBleHBvc2luZyAkb3B0aW9ucyBmb3IgcmVuZGVyU3RhdGljKClcbiAgICB0aGlzLiRvcHRpb25zID0gb3B0aW9ucztcbiAgICAvLyBwcmUtcmVzb2x2ZSBzbG90cyBmb3IgcmVuZGVyU2xvdCgpXG4gICAgdGhpcy4kc2xvdHMgPSB0aGlzLnNsb3RzKCk7XG4gICAgdGhpcy4kc2NvcGVkU2xvdHMgPSBkYXRhLnNjb3BlZFNsb3RzIHx8IGVtcHR5T2JqZWN0O1xuICB9XG5cbiAgaWYgKG9wdGlvbnMuX3Njb3BlSWQpIHtcbiAgICB0aGlzLl9jID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHtcbiAgICAgIHZhciB2bm9kZSA9IGNyZWF0ZUVsZW1lbnQoY29udGV4dFZtLCBhLCBiLCBjLCBkLCBuZWVkTm9ybWFsaXphdGlvbik7XG4gICAgICBpZiAodm5vZGUgJiYgIUFycmF5LmlzQXJyYXkodm5vZGUpKSB7XG4gICAgICAgIHZub2RlLmZuU2NvcGVJZCA9IG9wdGlvbnMuX3Njb3BlSWQ7XG4gICAgICAgIHZub2RlLmZuQ29udGV4dCA9IHBhcmVudDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2bm9kZVxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fYyA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7IHJldHVybiBjcmVhdGVFbGVtZW50KGNvbnRleHRWbSwgYSwgYiwgYywgZCwgbmVlZE5vcm1hbGl6YXRpb24pOyB9O1xuICB9XG59XG5cbmluc3RhbGxSZW5kZXJIZWxwZXJzKEZ1bmN0aW9uYWxSZW5kZXJDb250ZXh0LnByb3RvdHlwZSk7XG5cbmZ1bmN0aW9uIGNyZWF0ZUZ1bmN0aW9uYWxDb21wb25lbnQgKFxuICBDdG9yLFxuICBwcm9wc0RhdGEsXG4gIGRhdGEsXG4gIGNvbnRleHRWbSxcbiAgY2hpbGRyZW5cbikge1xuICB2YXIgb3B0aW9ucyA9IEN0b3Iub3B0aW9ucztcbiAgdmFyIHByb3BzID0ge307XG4gIHZhciBwcm9wT3B0aW9ucyA9IG9wdGlvbnMucHJvcHM7XG4gIGlmIChpc0RlZihwcm9wT3B0aW9ucykpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcE9wdGlvbnMpIHtcbiAgICAgIHByb3BzW2tleV0gPSB2YWxpZGF0ZVByb3Aoa2V5LCBwcm9wT3B0aW9ucywgcHJvcHNEYXRhIHx8IGVtcHR5T2JqZWN0KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGlzRGVmKGRhdGEuYXR0cnMpKSB7IG1lcmdlUHJvcHMocHJvcHMsIGRhdGEuYXR0cnMpOyB9XG4gICAgaWYgKGlzRGVmKGRhdGEucHJvcHMpKSB7IG1lcmdlUHJvcHMocHJvcHMsIGRhdGEucHJvcHMpOyB9XG4gIH1cblxuICB2YXIgcmVuZGVyQ29udGV4dCA9IG5ldyBGdW5jdGlvbmFsUmVuZGVyQ29udGV4dChcbiAgICBkYXRhLFxuICAgIHByb3BzLFxuICAgIGNoaWxkcmVuLFxuICAgIGNvbnRleHRWbSxcbiAgICBDdG9yXG4gICk7XG5cbiAgdmFyIHZub2RlID0gb3B0aW9ucy5yZW5kZXIuY2FsbChudWxsLCByZW5kZXJDb250ZXh0Ll9jLCByZW5kZXJDb250ZXh0KTtcblxuICBpZiAodm5vZGUgaW5zdGFuY2VvZiBWTm9kZSkge1xuICAgIHJldHVybiBjbG9uZUFuZE1hcmtGdW5jdGlvbmFsUmVzdWx0KHZub2RlLCBkYXRhLCByZW5kZXJDb250ZXh0LnBhcmVudCwgb3B0aW9ucylcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZub2RlKSkge1xuICAgIHZhciB2bm9kZXMgPSBub3JtYWxpemVDaGlsZHJlbih2bm9kZSkgfHwgW107XG4gICAgdmFyIHJlcyA9IG5ldyBBcnJheSh2bm9kZXMubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgcmVzW2ldID0gY2xvbmVBbmRNYXJrRnVuY3Rpb25hbFJlc3VsdCh2bm9kZXNbaV0sIGRhdGEsIHJlbmRlckNvbnRleHQucGFyZW50LCBvcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc1xuICB9XG59XG5cbmZ1bmN0aW9uIGNsb25lQW5kTWFya0Z1bmN0aW9uYWxSZXN1bHQgKHZub2RlLCBkYXRhLCBjb250ZXh0Vm0sIG9wdGlvbnMpIHtcbiAgLy8gIzc4MTcgY2xvbmUgbm9kZSBiZWZvcmUgc2V0dGluZyBmbkNvbnRleHQsIG90aGVyd2lzZSBpZiB0aGUgbm9kZSBpcyByZXVzZWRcbiAgLy8gKGUuZy4gaXQgd2FzIGZyb20gYSBjYWNoZWQgbm9ybWFsIHNsb3QpIHRoZSBmbkNvbnRleHQgY2F1c2VzIG5hbWVkIHNsb3RzXG4gIC8vIHRoYXQgc2hvdWxkIG5vdCBiZSBtYXRjaGVkIHRvIG1hdGNoLlxuICB2YXIgY2xvbmUgPSBjbG9uZVZOb2RlKHZub2RlKTtcbiAgY2xvbmUuZm5Db250ZXh0ID0gY29udGV4dFZtO1xuICBjbG9uZS5mbk9wdGlvbnMgPSBvcHRpb25zO1xuICBpZiAoZGF0YS5zbG90KSB7XG4gICAgKGNsb25lLmRhdGEgfHwgKGNsb25lLmRhdGEgPSB7fSkpLnNsb3QgPSBkYXRhLnNsb3Q7XG4gIH1cbiAgcmV0dXJuIGNsb25lXG59XG5cbmZ1bmN0aW9uIG1lcmdlUHJvcHMgKHRvLCBmcm9tKSB7XG4gIGZvciAodmFyIGtleSBpbiBmcm9tKSB7XG4gICAgdG9bY2FtZWxpemUoa2V5KV0gPSBmcm9tW2tleV07XG4gIH1cbn1cblxuLyogICovXG5cblxuXG5cbi8vIFJlZ2lzdGVyIHRoZSBjb21wb25lbnQgaG9vayB0byB3ZWV4IG5hdGl2ZSByZW5kZXIgZW5naW5lLlxuLy8gVGhlIGhvb2sgd2lsbCBiZSB0cmlnZ2VyZWQgYnkgbmF0aXZlLCBub3QgamF2YXNjcmlwdC5cblxuXG4vLyBVcGRhdGVzIHRoZSBzdGF0ZSBvZiB0aGUgY29tcG9uZW50IHRvIHdlZXggbmF0aXZlIHJlbmRlciBlbmdpbmUuXG5cbi8qICAqL1xuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vSGFua3MxMDEwMC93ZWV4LW5hdGl2ZS1kaXJlY3RpdmUvdHJlZS9tYXN0ZXIvY29tcG9uZW50XG5cbi8vIGxpc3RlbmluZyBvbiBuYXRpdmUgY2FsbGJhY2tcblxuLyogICovXG5cbi8qICAqL1xuXG4vLyBpbmxpbmUgaG9va3MgdG8gYmUgaW52b2tlZCBvbiBjb21wb25lbnQgVk5vZGVzIGR1cmluZyBwYXRjaFxudmFyIGNvbXBvbmVudFZOb2RlSG9va3MgPSB7XG4gIGluaXQ6IGZ1bmN0aW9uIGluaXQgKFxuICAgIHZub2RlLFxuICAgIGh5ZHJhdGluZyxcbiAgICBwYXJlbnRFbG0sXG4gICAgcmVmRWxtXG4gICkge1xuICAgIGlmIChcbiAgICAgIHZub2RlLmNvbXBvbmVudEluc3RhbmNlICYmXG4gICAgICAhdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX2lzRGVzdHJveWVkICYmXG4gICAgICB2bm9kZS5kYXRhLmtlZXBBbGl2ZVxuICAgICkge1xuICAgICAgLy8ga2VwdC1hbGl2ZSBjb21wb25lbnRzLCB0cmVhdCBhcyBhIHBhdGNoXG4gICAgICB2YXIgbW91bnRlZE5vZGUgPSB2bm9kZTsgLy8gd29yayBhcm91bmQgZmxvd1xuICAgICAgY29tcG9uZW50Vk5vZGVIb29rcy5wcmVwYXRjaChtb3VudGVkTm9kZSwgbW91bnRlZE5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgY2hpbGQgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IGNyZWF0ZUNvbXBvbmVudEluc3RhbmNlRm9yVm5vZGUoXG4gICAgICAgIHZub2RlLFxuICAgICAgICBhY3RpdmVJbnN0YW5jZSxcbiAgICAgICAgcGFyZW50RWxtLFxuICAgICAgICByZWZFbG1cbiAgICAgICk7XG4gICAgICBjaGlsZC4kbW91bnQoaHlkcmF0aW5nID8gdm5vZGUuZWxtIDogdW5kZWZpbmVkLCBoeWRyYXRpbmcpO1xuICAgIH1cbiAgfSxcblxuICBwcmVwYXRjaDogZnVuY3Rpb24gcHJlcGF0Y2ggKG9sZFZub2RlLCB2bm9kZSkge1xuICAgIHZhciBvcHRpb25zID0gdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgICB2YXIgY2hpbGQgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IG9sZFZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xuICAgIHVwZGF0ZUNoaWxkQ29tcG9uZW50KFxuICAgICAgY2hpbGQsXG4gICAgICBvcHRpb25zLnByb3BzRGF0YSwgLy8gdXBkYXRlZCBwcm9wc1xuICAgICAgb3B0aW9ucy5saXN0ZW5lcnMsIC8vIHVwZGF0ZWQgbGlzdGVuZXJzXG4gICAgICB2bm9kZSwgLy8gbmV3IHBhcmVudCB2bm9kZVxuICAgICAgb3B0aW9ucy5jaGlsZHJlbiAvLyBuZXcgY2hpbGRyZW5cbiAgICApO1xuICB9LFxuXG4gIGluc2VydDogZnVuY3Rpb24gaW5zZXJ0ICh2bm9kZSkge1xuICAgIHZhciBjb250ZXh0ID0gdm5vZGUuY29udGV4dDtcbiAgICB2YXIgY29tcG9uZW50SW5zdGFuY2UgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICBpZiAoIWNvbXBvbmVudEluc3RhbmNlLl9pc01vdW50ZWQpIHtcbiAgICAgIGNvbXBvbmVudEluc3RhbmNlLl9pc01vdW50ZWQgPSB0cnVlO1xuICAgICAgY2FsbEhvb2soY29tcG9uZW50SW5zdGFuY2UsICdtb3VudGVkJyk7XG4gICAgfVxuICAgIGlmICh2bm9kZS5kYXRhLmtlZXBBbGl2ZSkge1xuICAgICAgaWYgKGNvbnRleHQuX2lzTW91bnRlZCkge1xuICAgICAgICAvLyB2dWUtcm91dGVyIzEyMTJcbiAgICAgICAgLy8gRHVyaW5nIHVwZGF0ZXMsIGEga2VwdC1hbGl2ZSBjb21wb25lbnQncyBjaGlsZCBjb21wb25lbnRzIG1heVxuICAgICAgICAvLyBjaGFuZ2UsIHNvIGRpcmVjdGx5IHdhbGtpbmcgdGhlIHRyZWUgaGVyZSBtYXkgY2FsbCBhY3RpdmF0ZWQgaG9va3NcbiAgICAgICAgLy8gb24gaW5jb3JyZWN0IGNoaWxkcmVuLiBJbnN0ZWFkIHdlIHB1c2ggdGhlbSBpbnRvIGEgcXVldWUgd2hpY2ggd2lsbFxuICAgICAgICAvLyBiZSBwcm9jZXNzZWQgYWZ0ZXIgdGhlIHdob2xlIHBhdGNoIHByb2Nlc3MgZW5kZWQuXG4gICAgICAgIHF1ZXVlQWN0aXZhdGVkQ29tcG9uZW50KGNvbXBvbmVudEluc3RhbmNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFjdGl2YXRlQ2hpbGRDb21wb25lbnQoY29tcG9uZW50SW5zdGFuY2UsIHRydWUgLyogZGlyZWN0ICovKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSAodm5vZGUpIHtcbiAgICB2YXIgY29tcG9uZW50SW5zdGFuY2UgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICBpZiAoIWNvbXBvbmVudEluc3RhbmNlLl9pc0Rlc3Ryb3llZCkge1xuICAgICAgaWYgKCF2bm9kZS5kYXRhLmtlZXBBbGl2ZSkge1xuICAgICAgICBjb21wb25lbnRJbnN0YW5jZS4kZGVzdHJveSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KGNvbXBvbmVudEluc3RhbmNlLCB0cnVlIC8qIGRpcmVjdCAqLyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG52YXIgaG9va3NUb01lcmdlID0gT2JqZWN0LmtleXMoY29tcG9uZW50Vk5vZGVIb29rcyk7XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudCAoXG4gIEN0b3IsXG4gIGRhdGEsXG4gIGNvbnRleHQsXG4gIGNoaWxkcmVuLFxuICB0YWdcbikge1xuICBpZiAoaXNVbmRlZihDdG9yKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGJhc2VDdG9yID0gY29udGV4dC4kb3B0aW9ucy5fYmFzZTtcblxuICAvLyBwbGFpbiBvcHRpb25zIG9iamVjdDogdHVybiBpdCBpbnRvIGEgY29uc3RydWN0b3JcbiAgaWYgKGlzT2JqZWN0KEN0b3IpKSB7XG4gICAgQ3RvciA9IGJhc2VDdG9yLmV4dGVuZChDdG9yKTtcbiAgfVxuXG4gIC8vIGlmIGF0IHRoaXMgc3RhZ2UgaXQncyBub3QgYSBjb25zdHJ1Y3RvciBvciBhbiBhc3luYyBjb21wb25lbnQgZmFjdG9yeSxcbiAgLy8gcmVqZWN0LlxuICBpZiAodHlwZW9mIEN0b3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgd2FybigoXCJJbnZhbGlkIENvbXBvbmVudCBkZWZpbml0aW9uOiBcIiArIChTdHJpbmcoQ3RvcikpKSwgY29udGV4dCk7XG4gICAgfVxuICAgIHJldHVyblxuICB9XG5cbiAgLy8gYXN5bmMgY29tcG9uZW50XG4gIHZhciBhc3luY0ZhY3Rvcnk7XG4gIGlmIChpc1VuZGVmKEN0b3IuY2lkKSkge1xuICAgIGFzeW5jRmFjdG9yeSA9IEN0b3I7XG4gICAgQ3RvciA9IHJlc29sdmVBc3luY0NvbXBvbmVudChhc3luY0ZhY3RvcnksIGJhc2VDdG9yLCBjb250ZXh0KTtcbiAgICBpZiAoQ3RvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyByZXR1cm4gYSBwbGFjZWhvbGRlciBub2RlIGZvciBhc3luYyBjb21wb25lbnQsIHdoaWNoIGlzIHJlbmRlcmVkXG4gICAgICAvLyBhcyBhIGNvbW1lbnQgbm9kZSBidXQgcHJlc2VydmVzIGFsbCB0aGUgcmF3IGluZm9ybWF0aW9uIGZvciB0aGUgbm9kZS5cbiAgICAgIC8vIHRoZSBpbmZvcm1hdGlvbiB3aWxsIGJlIHVzZWQgZm9yIGFzeW5jIHNlcnZlci1yZW5kZXJpbmcgYW5kIGh5ZHJhdGlvbi5cbiAgICAgIHJldHVybiBjcmVhdGVBc3luY1BsYWNlaG9sZGVyKFxuICAgICAgICBhc3luY0ZhY3RvcnksXG4gICAgICAgIGRhdGEsXG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGNoaWxkcmVuLFxuICAgICAgICB0YWdcbiAgICAgIClcbiAgICB9XG4gIH1cblxuICBkYXRhID0gZGF0YSB8fCB7fTtcblxuICAvLyByZXNvbHZlIGNvbnN0cnVjdG9yIG9wdGlvbnMgaW4gY2FzZSBnbG9iYWwgbWl4aW5zIGFyZSBhcHBsaWVkIGFmdGVyXG4gIC8vIGNvbXBvbmVudCBjb25zdHJ1Y3RvciBjcmVhdGlvblxuICByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zKEN0b3IpO1xuXG4gIC8vIHRyYW5zZm9ybSBjb21wb25lbnQgdi1tb2RlbCBkYXRhIGludG8gcHJvcHMgJiBldmVudHNcbiAgaWYgKGlzRGVmKGRhdGEubW9kZWwpKSB7XG4gICAgdHJhbnNmb3JtTW9kZWwoQ3Rvci5vcHRpb25zLCBkYXRhKTtcbiAgfVxuXG4gIC8vIGV4dHJhY3QgcHJvcHNcbiAgdmFyIHByb3BzRGF0YSA9IGV4dHJhY3RQcm9wc0Zyb21WTm9kZURhdGEoZGF0YSwgQ3RvciwgdGFnKTtcblxuICAvLyBmdW5jdGlvbmFsIGNvbXBvbmVudFxuICBpZiAoaXNUcnVlKEN0b3Iub3B0aW9ucy5mdW5jdGlvbmFsKSkge1xuICAgIHJldHVybiBjcmVhdGVGdW5jdGlvbmFsQ29tcG9uZW50KEN0b3IsIHByb3BzRGF0YSwgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4pXG4gIH1cblxuICAvLyBleHRyYWN0IGxpc3RlbmVycywgc2luY2UgdGhlc2UgbmVlZHMgdG8gYmUgdHJlYXRlZCBhc1xuICAvLyBjaGlsZCBjb21wb25lbnQgbGlzdGVuZXJzIGluc3RlYWQgb2YgRE9NIGxpc3RlbmVyc1xuICB2YXIgbGlzdGVuZXJzID0gZGF0YS5vbjtcbiAgLy8gcmVwbGFjZSB3aXRoIGxpc3RlbmVycyB3aXRoIC5uYXRpdmUgbW9kaWZpZXJcbiAgLy8gc28gaXQgZ2V0cyBwcm9jZXNzZWQgZHVyaW5nIHBhcmVudCBjb21wb25lbnQgcGF0Y2guXG4gIGRhdGEub24gPSBkYXRhLm5hdGl2ZU9uO1xuXG4gIGlmIChpc1RydWUoQ3Rvci5vcHRpb25zLmFic3RyYWN0KSkge1xuICAgIC8vIGFic3RyYWN0IGNvbXBvbmVudHMgZG8gbm90IGtlZXAgYW55dGhpbmdcbiAgICAvLyBvdGhlciB0aGFuIHByb3BzICYgbGlzdGVuZXJzICYgc2xvdFxuXG4gICAgLy8gd29yayBhcm91bmQgZmxvd1xuICAgIHZhciBzbG90ID0gZGF0YS5zbG90O1xuICAgIGRhdGEgPSB7fTtcbiAgICBpZiAoc2xvdCkge1xuICAgICAgZGF0YS5zbG90ID0gc2xvdDtcbiAgICB9XG4gIH1cblxuICAvLyBpbnN0YWxsIGNvbXBvbmVudCBtYW5hZ2VtZW50IGhvb2tzIG9udG8gdGhlIHBsYWNlaG9sZGVyIG5vZGVcbiAgaW5zdGFsbENvbXBvbmVudEhvb2tzKGRhdGEpO1xuXG4gIC8vIHJldHVybiBhIHBsYWNlaG9sZGVyIHZub2RlXG4gIHZhciBuYW1lID0gQ3Rvci5vcHRpb25zLm5hbWUgfHwgdGFnO1xuICB2YXIgdm5vZGUgPSBuZXcgVk5vZGUoXG4gICAgKFwidnVlLWNvbXBvbmVudC1cIiArIChDdG9yLmNpZCkgKyAobmFtZSA/IChcIi1cIiArIG5hbWUpIDogJycpKSxcbiAgICBkYXRhLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0LFxuICAgIHsgQ3RvcjogQ3RvciwgcHJvcHNEYXRhOiBwcm9wc0RhdGEsIGxpc3RlbmVyczogbGlzdGVuZXJzLCB0YWc6IHRhZywgY2hpbGRyZW46IGNoaWxkcmVuIH0sXG4gICAgYXN5bmNGYWN0b3J5XG4gICk7XG5cbiAgLy8gV2VleCBzcGVjaWZpYzogaW52b2tlIHJlY3ljbGUtbGlzdCBvcHRpbWl6ZWQgQHJlbmRlciBmdW5jdGlvbiBmb3JcbiAgLy8gZXh0cmFjdGluZyBjZWxsLXNsb3QgdGVtcGxhdGUuXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9IYW5rczEwMTAwL3dlZXgtbmF0aXZlLWRpcmVjdGl2ZS90cmVlL21hc3Rlci9jb21wb25lbnRcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIHJldHVybiB2bm9kZVxufVxuXG5mdW5jdGlvbiBjcmVhdGVDb21wb25lbnRJbnN0YW5jZUZvclZub2RlIChcbiAgdm5vZGUsIC8vIHdlIGtub3cgaXQncyBNb3VudGVkQ29tcG9uZW50Vk5vZGUgYnV0IGZsb3cgZG9lc24ndFxuICBwYXJlbnQsIC8vIGFjdGl2ZUluc3RhbmNlIGluIGxpZmVjeWNsZSBzdGF0ZVxuICBwYXJlbnRFbG0sXG4gIHJlZkVsbVxuKSB7XG4gIHZhciBvcHRpb25zID0ge1xuICAgIF9pc0NvbXBvbmVudDogdHJ1ZSxcbiAgICBwYXJlbnQ6IHBhcmVudCxcbiAgICBfcGFyZW50Vm5vZGU6IHZub2RlLFxuICAgIF9wYXJlbnRFbG06IHBhcmVudEVsbSB8fCBudWxsLFxuICAgIF9yZWZFbG06IHJlZkVsbSB8fCBudWxsXG4gIH07XG4gIC8vIGNoZWNrIGlubGluZS10ZW1wbGF0ZSByZW5kZXIgZnVuY3Rpb25zXG4gIHZhciBpbmxpbmVUZW1wbGF0ZSA9IHZub2RlLmRhdGEuaW5saW5lVGVtcGxhdGU7XG4gIGlmIChpc0RlZihpbmxpbmVUZW1wbGF0ZSkpIHtcbiAgICBvcHRpb25zLnJlbmRlciA9IGlubGluZVRlbXBsYXRlLnJlbmRlcjtcbiAgICBvcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IGlubGluZVRlbXBsYXRlLnN0YXRpY1JlbmRlckZucztcbiAgfVxuICByZXR1cm4gbmV3IHZub2RlLmNvbXBvbmVudE9wdGlvbnMuQ3RvcihvcHRpb25zKVxufVxuXG5mdW5jdGlvbiBpbnN0YWxsQ29tcG9uZW50SG9va3MgKGRhdGEpIHtcbiAgdmFyIGhvb2tzID0gZGF0YS5ob29rIHx8IChkYXRhLmhvb2sgPSB7fSk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaG9va3NUb01lcmdlLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGhvb2tzVG9NZXJnZVtpXTtcbiAgICBob29rc1trZXldID0gY29tcG9uZW50Vk5vZGVIb29rc1trZXldO1xuICB9XG59XG5cbi8vIHRyYW5zZm9ybSBjb21wb25lbnQgdi1tb2RlbCBpbmZvICh2YWx1ZSBhbmQgY2FsbGJhY2spIGludG9cbi8vIHByb3AgYW5kIGV2ZW50IGhhbmRsZXIgcmVzcGVjdGl2ZWx5LlxuZnVuY3Rpb24gdHJhbnNmb3JtTW9kZWwgKG9wdGlvbnMsIGRhdGEpIHtcbiAgdmFyIHByb3AgPSAob3B0aW9ucy5tb2RlbCAmJiBvcHRpb25zLm1vZGVsLnByb3ApIHx8ICd2YWx1ZSc7XG4gIHZhciBldmVudCA9IChvcHRpb25zLm1vZGVsICYmIG9wdGlvbnMubW9kZWwuZXZlbnQpIHx8ICdpbnB1dCc7KGRhdGEucHJvcHMgfHwgKGRhdGEucHJvcHMgPSB7fSkpW3Byb3BdID0gZGF0YS5tb2RlbC52YWx1ZTtcbiAgdmFyIG9uID0gZGF0YS5vbiB8fCAoZGF0YS5vbiA9IHt9KTtcbiAgaWYgKGlzRGVmKG9uW2V2ZW50XSkpIHtcbiAgICBvbltldmVudF0gPSBbZGF0YS5tb2RlbC5jYWxsYmFja10uY29uY2F0KG9uW2V2ZW50XSk7XG4gIH0gZWxzZSB7XG4gICAgb25bZXZlbnRdID0gZGF0YS5tb2RlbC5jYWxsYmFjaztcbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIFNJTVBMRV9OT1JNQUxJWkUgPSAxO1xudmFyIEFMV0FZU19OT1JNQUxJWkUgPSAyO1xuXG4vLyB3cmFwcGVyIGZ1bmN0aW9uIGZvciBwcm92aWRpbmcgYSBtb3JlIGZsZXhpYmxlIGludGVyZmFjZVxuLy8gd2l0aG91dCBnZXR0aW5nIHllbGxlZCBhdCBieSBmbG93XG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50IChcbiAgY29udGV4dCxcbiAgdGFnLFxuICBkYXRhLFxuICBjaGlsZHJlbixcbiAgbm9ybWFsaXphdGlvblR5cGUsXG4gIGFsd2F5c05vcm1hbGl6ZVxuKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGRhdGEpIHx8IGlzUHJpbWl0aXZlKGRhdGEpKSB7XG4gICAgbm9ybWFsaXphdGlvblR5cGUgPSBjaGlsZHJlbjtcbiAgICBjaGlsZHJlbiA9IGRhdGE7XG4gICAgZGF0YSA9IHVuZGVmaW5lZDtcbiAgfVxuICBpZiAoaXNUcnVlKGFsd2F5c05vcm1hbGl6ZSkpIHtcbiAgICBub3JtYWxpemF0aW9uVHlwZSA9IEFMV0FZU19OT1JNQUxJWkU7XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVFbGVtZW50KGNvbnRleHQsIHRhZywgZGF0YSwgY2hpbGRyZW4sIG5vcm1hbGl6YXRpb25UeXBlKVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlRWxlbWVudCAoXG4gIGNvbnRleHQsXG4gIHRhZyxcbiAgZGF0YSxcbiAgY2hpbGRyZW4sXG4gIG5vcm1hbGl6YXRpb25UeXBlXG4pIHtcbiAgaWYgKGlzRGVmKGRhdGEpICYmIGlzRGVmKChkYXRhKS5fX29iX18pKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgXCJBdm9pZCB1c2luZyBvYnNlcnZlZCBkYXRhIG9iamVjdCBhcyB2bm9kZSBkYXRhOiBcIiArIChKU09OLnN0cmluZ2lmeShkYXRhKSkgKyBcIlxcblwiICtcbiAgICAgICdBbHdheXMgY3JlYXRlIGZyZXNoIHZub2RlIGRhdGEgb2JqZWN0cyBpbiBlYWNoIHJlbmRlciEnLFxuICAgICAgY29udGV4dFxuICAgICk7XG4gICAgcmV0dXJuIGNyZWF0ZUVtcHR5Vk5vZGUoKVxuICB9XG4gIC8vIG9iamVjdCBzeW50YXggaW4gdi1iaW5kXG4gIGlmIChpc0RlZihkYXRhKSAmJiBpc0RlZihkYXRhLmlzKSkge1xuICAgIHRhZyA9IGRhdGEuaXM7XG4gIH1cbiAgaWYgKCF0YWcpIHtcbiAgICAvLyBpbiBjYXNlIG9mIGNvbXBvbmVudCA6aXMgc2V0IHRvIGZhbHN5IHZhbHVlXG4gICAgcmV0dXJuIGNyZWF0ZUVtcHR5Vk5vZGUoKVxuICB9XG4gIC8vIHdhcm4gYWdhaW5zdCBub24tcHJpbWl0aXZlIGtleVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgIGlzRGVmKGRhdGEpICYmIGlzRGVmKGRhdGEua2V5KSAmJiAhaXNQcmltaXRpdmUoZGF0YS5rZXkpXG4gICkge1xuICAgIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdBdm9pZCB1c2luZyBub24tcHJpbWl0aXZlIHZhbHVlIGFzIGtleSwgJyArXG4gICAgICAgICd1c2Ugc3RyaW5nL251bWJlciB2YWx1ZSBpbnN0ZWFkLicsXG4gICAgICAgIGNvbnRleHRcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIC8vIHN1cHBvcnQgc2luZ2xlIGZ1bmN0aW9uIGNoaWxkcmVuIGFzIGRlZmF1bHQgc2NvcGVkIHNsb3RcbiAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pICYmXG4gICAgdHlwZW9mIGNoaWxkcmVuWzBdID09PSAnZnVuY3Rpb24nXG4gICkge1xuICAgIGRhdGEgPSBkYXRhIHx8IHt9O1xuICAgIGRhdGEuc2NvcGVkU2xvdHMgPSB7IGRlZmF1bHQ6IGNoaWxkcmVuWzBdIH07XG4gICAgY2hpbGRyZW4ubGVuZ3RoID0gMDtcbiAgfVxuICBpZiAobm9ybWFsaXphdGlvblR5cGUgPT09IEFMV0FZU19OT1JNQUxJWkUpIHtcbiAgICBjaGlsZHJlbiA9IG5vcm1hbGl6ZUNoaWxkcmVuKGNoaWxkcmVuKTtcbiAgfSBlbHNlIGlmIChub3JtYWxpemF0aW9uVHlwZSA9PT0gU0lNUExFX05PUk1BTElaRSkge1xuICAgIGNoaWxkcmVuID0gc2ltcGxlTm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4pO1xuICB9XG4gIHZhciB2bm9kZSwgbnM7XG4gIGlmICh0eXBlb2YgdGFnID09PSAnc3RyaW5nJykge1xuICAgIHZhciBDdG9yO1xuICAgIG5zID0gKGNvbnRleHQuJHZub2RlICYmIGNvbnRleHQuJHZub2RlLm5zKSB8fCBjb25maWcuZ2V0VGFnTmFtZXNwYWNlKHRhZyk7XG4gICAgaWYgKGNvbmZpZy5pc1Jlc2VydmVkVGFnKHRhZykpIHtcbiAgICAgIC8vIHBsYXRmb3JtIGJ1aWx0LWluIGVsZW1lbnRzXG4gICAgICB2bm9kZSA9IG5ldyBWTm9kZShcbiAgICAgICAgY29uZmlnLnBhcnNlUGxhdGZvcm1UYWdOYW1lKHRhZyksIGRhdGEsIGNoaWxkcmVuLFxuICAgICAgICB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY29udGV4dFxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKGlzRGVmKEN0b3IgPSByZXNvbHZlQXNzZXQoY29udGV4dC4kb3B0aW9ucywgJ2NvbXBvbmVudHMnLCB0YWcpKSkge1xuICAgICAgLy8gY29tcG9uZW50XG4gICAgICB2bm9kZSA9IGNyZWF0ZUNvbXBvbmVudChDdG9yLCBkYXRhLCBjb250ZXh0LCBjaGlsZHJlbiwgdGFnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdW5rbm93biBvciB1bmxpc3RlZCBuYW1lc3BhY2VkIGVsZW1lbnRzXG4gICAgICAvLyBjaGVjayBhdCBydW50aW1lIGJlY2F1c2UgaXQgbWF5IGdldCBhc3NpZ25lZCBhIG5hbWVzcGFjZSB3aGVuIGl0c1xuICAgICAgLy8gcGFyZW50IG5vcm1hbGl6ZXMgY2hpbGRyZW5cbiAgICAgIHZub2RlID0gbmV3IFZOb2RlKFxuICAgICAgICB0YWcsIGRhdGEsIGNoaWxkcmVuLFxuICAgICAgICB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY29udGV4dFxuICAgICAgKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gZGlyZWN0IGNvbXBvbmVudCBvcHRpb25zIC8gY29uc3RydWN0b3JcbiAgICB2bm9kZSA9IGNyZWF0ZUNvbXBvbmVudCh0YWcsIGRhdGEsIGNvbnRleHQsIGNoaWxkcmVuKTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheSh2bm9kZSkpIHtcbiAgICByZXR1cm4gdm5vZGVcbiAgfSBlbHNlIGlmIChpc0RlZih2bm9kZSkpIHtcbiAgICBpZiAoaXNEZWYobnMpKSB7IGFwcGx5TlModm5vZGUsIG5zKTsgfVxuICAgIGlmIChpc0RlZihkYXRhKSkgeyByZWdpc3RlckRlZXBCaW5kaW5ncyhkYXRhKTsgfVxuICAgIHJldHVybiB2bm9kZVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBjcmVhdGVFbXB0eVZOb2RlKClcbiAgfVxufVxuXG5mdW5jdGlvbiBhcHBseU5TICh2bm9kZSwgbnMsIGZvcmNlKSB7XG4gIHZub2RlLm5zID0gbnM7XG4gIGlmICh2bm9kZS50YWcgPT09ICdmb3JlaWduT2JqZWN0Jykge1xuICAgIC8vIHVzZSBkZWZhdWx0IG5hbWVzcGFjZSBpbnNpZGUgZm9yZWlnbk9iamVjdFxuICAgIG5zID0gdW5kZWZpbmVkO1xuICAgIGZvcmNlID0gdHJ1ZTtcbiAgfVxuICBpZiAoaXNEZWYodm5vZGUuY2hpbGRyZW4pKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSB2bm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBjaGlsZCA9IHZub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgaWYgKGlzRGVmKGNoaWxkLnRhZykgJiYgKFxuICAgICAgICBpc1VuZGVmKGNoaWxkLm5zKSB8fCAoaXNUcnVlKGZvcmNlKSAmJiBjaGlsZC50YWcgIT09ICdzdmcnKSkpIHtcbiAgICAgICAgYXBwbHlOUyhjaGlsZCwgbnMsIGZvcmNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLy8gcmVmICM1MzE4XG4vLyBuZWNlc3NhcnkgdG8gZW5zdXJlIHBhcmVudCByZS1yZW5kZXIgd2hlbiBkZWVwIGJpbmRpbmdzIGxpa2UgOnN0eWxlIGFuZFxuLy8gOmNsYXNzIGFyZSB1c2VkIG9uIHNsb3Qgbm9kZXNcbmZ1bmN0aW9uIHJlZ2lzdGVyRGVlcEJpbmRpbmdzIChkYXRhKSB7XG4gIGlmIChpc09iamVjdChkYXRhLnN0eWxlKSkge1xuICAgIHRyYXZlcnNlKGRhdGEuc3R5bGUpO1xuICB9XG4gIGlmIChpc09iamVjdChkYXRhLmNsYXNzKSkge1xuICAgIHRyYXZlcnNlKGRhdGEuY2xhc3MpO1xuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0UmVuZGVyICh2bSkge1xuICB2bS5fdm5vZGUgPSBudWxsOyAvLyB0aGUgcm9vdCBvZiB0aGUgY2hpbGQgdHJlZVxuICB2bS5fc3RhdGljVHJlZXMgPSBudWxsOyAvLyB2LW9uY2UgY2FjaGVkIHRyZWVzXG4gIHZhciBvcHRpb25zID0gdm0uJG9wdGlvbnM7XG4gIHZhciBwYXJlbnRWbm9kZSA9IHZtLiR2bm9kZSA9IG9wdGlvbnMuX3BhcmVudFZub2RlOyAvLyB0aGUgcGxhY2Vob2xkZXIgbm9kZSBpbiBwYXJlbnQgdHJlZVxuICB2YXIgcmVuZGVyQ29udGV4dCA9IHBhcmVudFZub2RlICYmIHBhcmVudFZub2RlLmNvbnRleHQ7XG4gIHZtLiRzbG90cyA9IHJlc29sdmVTbG90cyhvcHRpb25zLl9yZW5kZXJDaGlsZHJlbiwgcmVuZGVyQ29udGV4dCk7XG4gIHZtLiRzY29wZWRTbG90cyA9IGVtcHR5T2JqZWN0O1xuICAvLyBiaW5kIHRoZSBjcmVhdGVFbGVtZW50IGZuIHRvIHRoaXMgaW5zdGFuY2VcbiAgLy8gc28gdGhhdCB3ZSBnZXQgcHJvcGVyIHJlbmRlciBjb250ZXh0IGluc2lkZSBpdC5cbiAgLy8gYXJncyBvcmRlcjogdGFnLCBkYXRhLCBjaGlsZHJlbiwgbm9ybWFsaXphdGlvblR5cGUsIGFsd2F5c05vcm1hbGl6ZVxuICAvLyBpbnRlcm5hbCB2ZXJzaW9uIGlzIHVzZWQgYnkgcmVuZGVyIGZ1bmN0aW9ucyBjb21waWxlZCBmcm9tIHRlbXBsYXRlc1xuICB2bS5fYyA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7IHJldHVybiBjcmVhdGVFbGVtZW50KHZtLCBhLCBiLCBjLCBkLCBmYWxzZSk7IH07XG4gIC8vIG5vcm1hbGl6YXRpb24gaXMgYWx3YXlzIGFwcGxpZWQgZm9yIHRoZSBwdWJsaWMgdmVyc2lvbiwgdXNlZCBpblxuICAvLyB1c2VyLXdyaXR0ZW4gcmVuZGVyIGZ1bmN0aW9ucy5cbiAgdm0uJGNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkgeyByZXR1cm4gY3JlYXRlRWxlbWVudCh2bSwgYSwgYiwgYywgZCwgdHJ1ZSk7IH07XG5cbiAgLy8gJGF0dHJzICYgJGxpc3RlbmVycyBhcmUgZXhwb3NlZCBmb3IgZWFzaWVyIEhPQyBjcmVhdGlvbi5cbiAgLy8gdGhleSBuZWVkIHRvIGJlIHJlYWN0aXZlIHNvIHRoYXQgSE9DcyB1c2luZyB0aGVtIGFyZSBhbHdheXMgdXBkYXRlZFxuICB2YXIgcGFyZW50RGF0YSA9IHBhcmVudFZub2RlICYmIHBhcmVudFZub2RlLmRhdGE7XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBkZWZpbmVSZWFjdGl2ZSh2bSwgJyRhdHRycycsIHBhcmVudERhdGEgJiYgcGFyZW50RGF0YS5hdHRycyB8fCBlbXB0eU9iamVjdCwgZnVuY3Rpb24gKCkge1xuICAgICAgIWlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCAmJiB3YXJuKFwiJGF0dHJzIGlzIHJlYWRvbmx5LlwiLCB2bSk7XG4gICAgfSwgdHJ1ZSk7XG4gICAgZGVmaW5lUmVhY3RpdmUodm0sICckbGlzdGVuZXJzJywgb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzIHx8IGVtcHR5T2JqZWN0LCBmdW5jdGlvbiAoKSB7XG4gICAgICAhaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50ICYmIHdhcm4oXCIkbGlzdGVuZXJzIGlzIHJlYWRvbmx5LlwiLCB2bSk7XG4gICAgfSwgdHJ1ZSk7XG4gIH0gZWxzZSB7XG4gICAgZGVmaW5lUmVhY3RpdmUodm0sICckYXR0cnMnLCBwYXJlbnREYXRhICYmIHBhcmVudERhdGEuYXR0cnMgfHwgZW1wdHlPYmplY3QsIG51bGwsIHRydWUpO1xuICAgIGRlZmluZVJlYWN0aXZlKHZtLCAnJGxpc3RlbmVycycsIG9wdGlvbnMuX3BhcmVudExpc3RlbmVycyB8fCBlbXB0eU9iamVjdCwgbnVsbCwgdHJ1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVuZGVyTWl4aW4gKFZ1ZSkge1xuICAvLyBpbnN0YWxsIHJ1bnRpbWUgY29udmVuaWVuY2UgaGVscGVyc1xuICBpbnN0YWxsUmVuZGVySGVscGVycyhWdWUucHJvdG90eXBlKTtcblxuICBWdWUucHJvdG90eXBlLiRuZXh0VGljayA9IGZ1bmN0aW9uIChmbikge1xuICAgIHJldHVybiBuZXh0VGljayhmbiwgdGhpcylcbiAgfTtcblxuICBWdWUucHJvdG90eXBlLl9yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICB2YXIgcmVmID0gdm0uJG9wdGlvbnM7XG4gICAgdmFyIHJlbmRlciA9IHJlZi5yZW5kZXI7XG4gICAgdmFyIF9wYXJlbnRWbm9kZSA9IHJlZi5fcGFyZW50Vm5vZGU7XG5cbiAgICAvLyByZXNldCBfcmVuZGVyZWQgZmxhZyBvbiBzbG90cyBmb3IgZHVwbGljYXRlIHNsb3QgY2hlY2tcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgZm9yICh2YXIga2V5IGluIHZtLiRzbG90cykge1xuICAgICAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICAgICAgdm0uJHNsb3RzW2tleV0uX3JlbmRlcmVkID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKF9wYXJlbnRWbm9kZSkge1xuICAgICAgdm0uJHNjb3BlZFNsb3RzID0gX3BhcmVudFZub2RlLmRhdGEuc2NvcGVkU2xvdHMgfHwgZW1wdHlPYmplY3Q7XG4gICAgfVxuXG4gICAgLy8gc2V0IHBhcmVudCB2bm9kZS4gdGhpcyBhbGxvd3MgcmVuZGVyIGZ1bmN0aW9ucyB0byBoYXZlIGFjY2Vzc1xuICAgIC8vIHRvIHRoZSBkYXRhIG9uIHRoZSBwbGFjZWhvbGRlciBub2RlLlxuICAgIHZtLiR2bm9kZSA9IF9wYXJlbnRWbm9kZTtcbiAgICAvLyByZW5kZXIgc2VsZlxuICAgIHZhciB2bm9kZTtcbiAgICB0cnkge1xuICAgICAgdm5vZGUgPSByZW5kZXIuY2FsbCh2bS5fcmVuZGVyUHJveHksIHZtLiRjcmVhdGVFbGVtZW50KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBoYW5kbGVFcnJvcihlLCB2bSwgXCJyZW5kZXJcIik7XG4gICAgICAvLyByZXR1cm4gZXJyb3IgcmVuZGVyIHJlc3VsdCxcbiAgICAgIC8vIG9yIHByZXZpb3VzIHZub2RlIHRvIHByZXZlbnQgcmVuZGVyIGVycm9yIGNhdXNpbmcgYmxhbmsgY29tcG9uZW50XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKHZtLiRvcHRpb25zLnJlbmRlckVycm9yKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZub2RlID0gdm0uJG9wdGlvbnMucmVuZGVyRXJyb3IuY2FsbCh2bS5fcmVuZGVyUHJveHksIHZtLiRjcmVhdGVFbGVtZW50LCBlKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBoYW5kbGVFcnJvcihlLCB2bSwgXCJyZW5kZXJFcnJvclwiKTtcbiAgICAgICAgICAgIHZub2RlID0gdm0uX3Zub2RlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2bm9kZSA9IHZtLl92bm9kZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdm5vZGUgPSB2bS5fdm5vZGU7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIHJldHVybiBlbXB0eSB2bm9kZSBpbiBjYXNlIHRoZSByZW5kZXIgZnVuY3Rpb24gZXJyb3JlZCBvdXRcbiAgICBpZiAoISh2bm9kZSBpbnN0YW5jZW9mIFZOb2RlKSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgQXJyYXkuaXNBcnJheSh2bm9kZSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAnTXVsdGlwbGUgcm9vdCBub2RlcyByZXR1cm5lZCBmcm9tIHJlbmRlciBmdW5jdGlvbi4gUmVuZGVyIGZ1bmN0aW9uICcgK1xuICAgICAgICAgICdzaG91bGQgcmV0dXJuIGEgc2luZ2xlIHJvb3Qgbm9kZS4nLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICB2bm9kZSA9IGNyZWF0ZUVtcHR5Vk5vZGUoKTtcbiAgICB9XG4gICAgLy8gc2V0IHBhcmVudFxuICAgIHZub2RlLnBhcmVudCA9IF9wYXJlbnRWbm9kZTtcbiAgICByZXR1cm4gdm5vZGVcbiAgfTtcbn1cblxuLyogICovXG5cbnZhciB1aWQkMyA9IDA7XG5cbmZ1bmN0aW9uIGluaXRNaXhpbiAoVnVlKSB7XG4gIFZ1ZS5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgLy8gYSB1aWRcbiAgICB2bS5fdWlkID0gdWlkJDMrKztcblxuICAgIHZhciBzdGFydFRhZywgZW5kVGFnO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XG4gICAgICBzdGFydFRhZyA9IFwidnVlLXBlcmYtc3RhcnQ6XCIgKyAodm0uX3VpZCk7XG4gICAgICBlbmRUYWcgPSBcInZ1ZS1wZXJmLWVuZDpcIiArICh2bS5fdWlkKTtcbiAgICAgIG1hcmsoc3RhcnRUYWcpO1xuICAgIH1cblxuICAgIC8vIGEgZmxhZyB0byBhdm9pZCB0aGlzIGJlaW5nIG9ic2VydmVkXG4gICAgdm0uX2lzVnVlID0gdHJ1ZTtcbiAgICAvLyBtZXJnZSBvcHRpb25zXG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5faXNDb21wb25lbnQpIHtcbiAgICAgIC8vIG9wdGltaXplIGludGVybmFsIGNvbXBvbmVudCBpbnN0YW50aWF0aW9uXG4gICAgICAvLyBzaW5jZSBkeW5hbWljIG9wdGlvbnMgbWVyZ2luZyBpcyBwcmV0dHkgc2xvdywgYW5kIG5vbmUgb2YgdGhlXG4gICAgICAvLyBpbnRlcm5hbCBjb21wb25lbnQgb3B0aW9ucyBuZWVkcyBzcGVjaWFsIHRyZWF0bWVudC5cbiAgICAgIGluaXRJbnRlcm5hbENvbXBvbmVudCh2bSwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZtLiRvcHRpb25zID0gbWVyZ2VPcHRpb25zKFxuICAgICAgICByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zKHZtLmNvbnN0cnVjdG9yKSxcbiAgICAgICAgb3B0aW9ucyB8fCB7fSxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGluaXRQcm94eSh2bSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZtLl9yZW5kZXJQcm94eSA9IHZtO1xuICAgIH1cbiAgICAvLyBleHBvc2UgcmVhbCBzZWxmXG4gICAgdm0uX3NlbGYgPSB2bTtcbiAgICBpbml0TGlmZWN5Y2xlKHZtKTtcbiAgICBpbml0RXZlbnRzKHZtKTtcbiAgICBpbml0UmVuZGVyKHZtKTtcbiAgICBjYWxsSG9vayh2bSwgJ2JlZm9yZUNyZWF0ZScpO1xuICAgIGluaXRJbmplY3Rpb25zKHZtKTsgLy8gcmVzb2x2ZSBpbmplY3Rpb25zIGJlZm9yZSBkYXRhL3Byb3BzXG4gICAgaW5pdFN0YXRlKHZtKTtcbiAgICBpbml0UHJvdmlkZSh2bSk7IC8vIHJlc29sdmUgcHJvdmlkZSBhZnRlciBkYXRhL3Byb3BzXG4gICAgY2FsbEhvb2sodm0sICdjcmVhdGVkJyk7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgICAgdm0uX25hbWUgPSBmb3JtYXRDb21wb25lbnROYW1lKHZtLCBmYWxzZSk7XG4gICAgICBtYXJrKGVuZFRhZyk7XG4gICAgICBtZWFzdXJlKChcInZ1ZSBcIiArICh2bS5fbmFtZSkgKyBcIiBpbml0XCIpLCBzdGFydFRhZywgZW5kVGFnKTtcbiAgICB9XG5cbiAgICBpZiAodm0uJG9wdGlvbnMuZWwpIHtcbiAgICAgIHZtLiRtb3VudCh2bS4kb3B0aW9ucy5lbCk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBpbml0SW50ZXJuYWxDb21wb25lbnQgKHZtLCBvcHRpb25zKSB7XG4gIHZhciBvcHRzID0gdm0uJG9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKHZtLmNvbnN0cnVjdG9yLm9wdGlvbnMpO1xuICAvLyBkb2luZyB0aGlzIGJlY2F1c2UgaXQncyBmYXN0ZXIgdGhhbiBkeW5hbWljIGVudW1lcmF0aW9uLlxuICB2YXIgcGFyZW50Vm5vZGUgPSBvcHRpb25zLl9wYXJlbnRWbm9kZTtcbiAgb3B0cy5wYXJlbnQgPSBvcHRpb25zLnBhcmVudDtcbiAgb3B0cy5fcGFyZW50Vm5vZGUgPSBwYXJlbnRWbm9kZTtcbiAgb3B0cy5fcGFyZW50RWxtID0gb3B0aW9ucy5fcGFyZW50RWxtO1xuICBvcHRzLl9yZWZFbG0gPSBvcHRpb25zLl9yZWZFbG07XG5cbiAgdmFyIHZub2RlQ29tcG9uZW50T3B0aW9ucyA9IHBhcmVudFZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gIG9wdHMucHJvcHNEYXRhID0gdm5vZGVDb21wb25lbnRPcHRpb25zLnByb3BzRGF0YTtcbiAgb3B0cy5fcGFyZW50TGlzdGVuZXJzID0gdm5vZGVDb21wb25lbnRPcHRpb25zLmxpc3RlbmVycztcbiAgb3B0cy5fcmVuZGVyQ2hpbGRyZW4gPSB2bm9kZUNvbXBvbmVudE9wdGlvbnMuY2hpbGRyZW47XG4gIG9wdHMuX2NvbXBvbmVudFRhZyA9IHZub2RlQ29tcG9uZW50T3B0aW9ucy50YWc7XG5cbiAgaWYgKG9wdGlvbnMucmVuZGVyKSB7XG4gICAgb3B0cy5yZW5kZXIgPSBvcHRpb25zLnJlbmRlcjtcbiAgICBvcHRzLnN0YXRpY1JlbmRlckZucyA9IG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnMgKEN0b3IpIHtcbiAgdmFyIG9wdGlvbnMgPSBDdG9yLm9wdGlvbnM7XG4gIGlmIChDdG9yLnN1cGVyKSB7XG4gICAgdmFyIHN1cGVyT3B0aW9ucyA9IHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnMoQ3Rvci5zdXBlcik7XG4gICAgdmFyIGNhY2hlZFN1cGVyT3B0aW9ucyA9IEN0b3Iuc3VwZXJPcHRpb25zO1xuICAgIGlmIChzdXBlck9wdGlvbnMgIT09IGNhY2hlZFN1cGVyT3B0aW9ucykge1xuICAgICAgLy8gc3VwZXIgb3B0aW9uIGNoYW5nZWQsXG4gICAgICAvLyBuZWVkIHRvIHJlc29sdmUgbmV3IG9wdGlvbnMuXG4gICAgICBDdG9yLnN1cGVyT3B0aW9ucyA9IHN1cGVyT3B0aW9ucztcbiAgICAgIC8vIGNoZWNrIGlmIHRoZXJlIGFyZSBhbnkgbGF0ZS1tb2RpZmllZC9hdHRhY2hlZCBvcHRpb25zICgjNDk3NilcbiAgICAgIHZhciBtb2RpZmllZE9wdGlvbnMgPSByZXNvbHZlTW9kaWZpZWRPcHRpb25zKEN0b3IpO1xuICAgICAgLy8gdXBkYXRlIGJhc2UgZXh0ZW5kIG9wdGlvbnNcbiAgICAgIGlmIChtb2RpZmllZE9wdGlvbnMpIHtcbiAgICAgICAgZXh0ZW5kKEN0b3IuZXh0ZW5kT3B0aW9ucywgbW9kaWZpZWRPcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIG9wdGlvbnMgPSBDdG9yLm9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoc3VwZXJPcHRpb25zLCBDdG9yLmV4dGVuZE9wdGlvbnMpO1xuICAgICAgaWYgKG9wdGlvbnMubmFtZSkge1xuICAgICAgICBvcHRpb25zLmNvbXBvbmVudHNbb3B0aW9ucy5uYW1lXSA9IEN0b3I7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBvcHRpb25zXG59XG5cbmZ1bmN0aW9uIHJlc29sdmVNb2RpZmllZE9wdGlvbnMgKEN0b3IpIHtcbiAgdmFyIG1vZGlmaWVkO1xuICB2YXIgbGF0ZXN0ID0gQ3Rvci5vcHRpb25zO1xuICB2YXIgZXh0ZW5kZWQgPSBDdG9yLmV4dGVuZE9wdGlvbnM7XG4gIHZhciBzZWFsZWQgPSBDdG9yLnNlYWxlZE9wdGlvbnM7XG4gIGZvciAodmFyIGtleSBpbiBsYXRlc3QpIHtcbiAgICBpZiAobGF0ZXN0W2tleV0gIT09IHNlYWxlZFtrZXldKSB7XG4gICAgICBpZiAoIW1vZGlmaWVkKSB7IG1vZGlmaWVkID0ge307IH1cbiAgICAgIG1vZGlmaWVkW2tleV0gPSBkZWR1cGUobGF0ZXN0W2tleV0sIGV4dGVuZGVkW2tleV0sIHNlYWxlZFtrZXldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1vZGlmaWVkXG59XG5cbmZ1bmN0aW9uIGRlZHVwZSAobGF0ZXN0LCBleHRlbmRlZCwgc2VhbGVkKSB7XG4gIC8vIGNvbXBhcmUgbGF0ZXN0IGFuZCBzZWFsZWQgdG8gZW5zdXJlIGxpZmVjeWNsZSBob29rcyB3b24ndCBiZSBkdXBsaWNhdGVkXG4gIC8vIGJldHdlZW4gbWVyZ2VzXG4gIGlmIChBcnJheS5pc0FycmF5KGxhdGVzdCkpIHtcbiAgICB2YXIgcmVzID0gW107XG4gICAgc2VhbGVkID0gQXJyYXkuaXNBcnJheShzZWFsZWQpID8gc2VhbGVkIDogW3NlYWxlZF07XG4gICAgZXh0ZW5kZWQgPSBBcnJheS5pc0FycmF5KGV4dGVuZGVkKSA/IGV4dGVuZGVkIDogW2V4dGVuZGVkXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhdGVzdC5sZW5ndGg7IGkrKykge1xuICAgICAgLy8gcHVzaCBvcmlnaW5hbCBvcHRpb25zIGFuZCBub3Qgc2VhbGVkIG9wdGlvbnMgdG8gZXhjbHVkZSBkdXBsaWNhdGVkIG9wdGlvbnNcbiAgICAgIGlmIChleHRlbmRlZC5pbmRleE9mKGxhdGVzdFtpXSkgPj0gMCB8fCBzZWFsZWQuaW5kZXhPZihsYXRlc3RbaV0pIDwgMCkge1xuICAgICAgICByZXMucHVzaChsYXRlc3RbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGxhdGVzdFxuICB9XG59XG5cbmZ1bmN0aW9uIFZ1ZSAob3B0aW9ucykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICEodGhpcyBpbnN0YW5jZW9mIFZ1ZSlcbiAgKSB7XG4gICAgd2FybignVnVlIGlzIGEgY29uc3RydWN0b3IgYW5kIHNob3VsZCBiZSBjYWxsZWQgd2l0aCB0aGUgYG5ld2Aga2V5d29yZCcpO1xuICB9XG4gIHRoaXMuX2luaXQob3B0aW9ucyk7XG59XG5cbmluaXRNaXhpbihWdWUpO1xuc3RhdGVNaXhpbihWdWUpO1xuZXZlbnRzTWl4aW4oVnVlKTtcbmxpZmVjeWNsZU1peGluKFZ1ZSk7XG5yZW5kZXJNaXhpbihWdWUpO1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdFVzZSAoVnVlKSB7XG4gIFZ1ZS51c2UgPSBmdW5jdGlvbiAocGx1Z2luKSB7XG4gICAgdmFyIGluc3RhbGxlZFBsdWdpbnMgPSAodGhpcy5faW5zdGFsbGVkUGx1Z2lucyB8fCAodGhpcy5faW5zdGFsbGVkUGx1Z2lucyA9IFtdKSk7XG4gICAgaWYgKGluc3RhbGxlZFBsdWdpbnMuaW5kZXhPZihwbHVnaW4pID4gLTEpIHtcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgLy8gYWRkaXRpb25hbCBwYXJhbWV0ZXJzXG4gICAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cywgMSk7XG4gICAgYXJncy51bnNoaWZ0KHRoaXMpO1xuICAgIGlmICh0eXBlb2YgcGx1Z2luLmluc3RhbGwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHBsdWdpbi5pbnN0YWxsLmFwcGx5KHBsdWdpbiwgYXJncyk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcGx1Z2luID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwbHVnaW4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgfVxuICAgIGluc3RhbGxlZFBsdWdpbnMucHVzaChwbHVnaW4pO1xuICAgIHJldHVybiB0aGlzXG4gIH07XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0TWl4aW4kMSAoVnVlKSB7XG4gIFZ1ZS5taXhpbiA9IGZ1bmN0aW9uIChtaXhpbikge1xuICAgIHRoaXMub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyh0aGlzLm9wdGlvbnMsIG1peGluKTtcbiAgICByZXR1cm4gdGhpc1xuICB9O1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdEV4dGVuZCAoVnVlKSB7XG4gIC8qKlxuICAgKiBFYWNoIGluc3RhbmNlIGNvbnN0cnVjdG9yLCBpbmNsdWRpbmcgVnVlLCBoYXMgYSB1bmlxdWVcbiAgICogY2lkLiBUaGlzIGVuYWJsZXMgdXMgdG8gY3JlYXRlIHdyYXBwZWQgXCJjaGlsZFxuICAgKiBjb25zdHJ1Y3RvcnNcIiBmb3IgcHJvdG90eXBhbCBpbmhlcml0YW5jZSBhbmQgY2FjaGUgdGhlbS5cbiAgICovXG4gIFZ1ZS5jaWQgPSAwO1xuICB2YXIgY2lkID0gMTtcblxuICAvKipcbiAgICogQ2xhc3MgaW5oZXJpdGFuY2VcbiAgICovXG4gIFZ1ZS5leHRlbmQgPSBmdW5jdGlvbiAoZXh0ZW5kT3B0aW9ucykge1xuICAgIGV4dGVuZE9wdGlvbnMgPSBleHRlbmRPcHRpb25zIHx8IHt9O1xuICAgIHZhciBTdXBlciA9IHRoaXM7XG4gICAgdmFyIFN1cGVySWQgPSBTdXBlci5jaWQ7XG4gICAgdmFyIGNhY2hlZEN0b3JzID0gZXh0ZW5kT3B0aW9ucy5fQ3RvciB8fCAoZXh0ZW5kT3B0aW9ucy5fQ3RvciA9IHt9KTtcbiAgICBpZiAoY2FjaGVkQ3RvcnNbU3VwZXJJZF0pIHtcbiAgICAgIHJldHVybiBjYWNoZWRDdG9yc1tTdXBlcklkXVxuICAgIH1cblxuICAgIHZhciBuYW1lID0gZXh0ZW5kT3B0aW9ucy5uYW1lIHx8IFN1cGVyLm9wdGlvbnMubmFtZTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBuYW1lKSB7XG4gICAgICB2YWxpZGF0ZUNvbXBvbmVudE5hbWUobmFtZSk7XG4gICAgfVxuXG4gICAgdmFyIFN1YiA9IGZ1bmN0aW9uIFZ1ZUNvbXBvbmVudCAob3B0aW9ucykge1xuICAgICAgdGhpcy5faW5pdChvcHRpb25zKTtcbiAgICB9O1xuICAgIFN1Yi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFN1cGVyLnByb3RvdHlwZSk7XG4gICAgU3ViLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFN1YjtcbiAgICBTdWIuY2lkID0gY2lkKys7XG4gICAgU3ViLm9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoXG4gICAgICBTdXBlci5vcHRpb25zLFxuICAgICAgZXh0ZW5kT3B0aW9uc1xuICAgICk7XG4gICAgU3ViWydzdXBlciddID0gU3VwZXI7XG5cbiAgICAvLyBGb3IgcHJvcHMgYW5kIGNvbXB1dGVkIHByb3BlcnRpZXMsIHdlIGRlZmluZSB0aGUgcHJveHkgZ2V0dGVycyBvblxuICAgIC8vIHRoZSBWdWUgaW5zdGFuY2VzIGF0IGV4dGVuc2lvbiB0aW1lLCBvbiB0aGUgZXh0ZW5kZWQgcHJvdG90eXBlLiBUaGlzXG4gICAgLy8gYXZvaWRzIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSBjYWxscyBmb3IgZWFjaCBpbnN0YW5jZSBjcmVhdGVkLlxuICAgIGlmIChTdWIub3B0aW9ucy5wcm9wcykge1xuICAgICAgaW5pdFByb3BzJDEoU3ViKTtcbiAgICB9XG4gICAgaWYgKFN1Yi5vcHRpb25zLmNvbXB1dGVkKSB7XG4gICAgICBpbml0Q29tcHV0ZWQkMShTdWIpO1xuICAgIH1cblxuICAgIC8vIGFsbG93IGZ1cnRoZXIgZXh0ZW5zaW9uL21peGluL3BsdWdpbiB1c2FnZVxuICAgIFN1Yi5leHRlbmQgPSBTdXBlci5leHRlbmQ7XG4gICAgU3ViLm1peGluID0gU3VwZXIubWl4aW47XG4gICAgU3ViLnVzZSA9IFN1cGVyLnVzZTtcblxuICAgIC8vIGNyZWF0ZSBhc3NldCByZWdpc3RlcnMsIHNvIGV4dGVuZGVkIGNsYXNzZXNcbiAgICAvLyBjYW4gaGF2ZSB0aGVpciBwcml2YXRlIGFzc2V0cyB0b28uXG4gICAgQVNTRVRfVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgU3ViW3R5cGVdID0gU3VwZXJbdHlwZV07XG4gICAgfSk7XG4gICAgLy8gZW5hYmxlIHJlY3Vyc2l2ZSBzZWxmLWxvb2t1cFxuICAgIGlmIChuYW1lKSB7XG4gICAgICBTdWIub3B0aW9ucy5jb21wb25lbnRzW25hbWVdID0gU3ViO1xuICAgIH1cblxuICAgIC8vIGtlZXAgYSByZWZlcmVuY2UgdG8gdGhlIHN1cGVyIG9wdGlvbnMgYXQgZXh0ZW5zaW9uIHRpbWUuXG4gICAgLy8gbGF0ZXIgYXQgaW5zdGFudGlhdGlvbiB3ZSBjYW4gY2hlY2sgaWYgU3VwZXIncyBvcHRpb25zIGhhdmVcbiAgICAvLyBiZWVuIHVwZGF0ZWQuXG4gICAgU3ViLnN1cGVyT3B0aW9ucyA9IFN1cGVyLm9wdGlvbnM7XG4gICAgU3ViLmV4dGVuZE9wdGlvbnMgPSBleHRlbmRPcHRpb25zO1xuICAgIFN1Yi5zZWFsZWRPcHRpb25zID0gZXh0ZW5kKHt9LCBTdWIub3B0aW9ucyk7XG5cbiAgICAvLyBjYWNoZSBjb25zdHJ1Y3RvclxuICAgIGNhY2hlZEN0b3JzW1N1cGVySWRdID0gU3ViO1xuICAgIHJldHVybiBTdWJcbiAgfTtcbn1cblxuZnVuY3Rpb24gaW5pdFByb3BzJDEgKENvbXApIHtcbiAgdmFyIHByb3BzID0gQ29tcC5vcHRpb25zLnByb3BzO1xuICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICBwcm94eShDb21wLnByb3RvdHlwZSwgXCJfcHJvcHNcIiwga2V5KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0Q29tcHV0ZWQkMSAoQ29tcCkge1xuICB2YXIgY29tcHV0ZWQgPSBDb21wLm9wdGlvbnMuY29tcHV0ZWQ7XG4gIGZvciAodmFyIGtleSBpbiBjb21wdXRlZCkge1xuICAgIGRlZmluZUNvbXB1dGVkKENvbXAucHJvdG90eXBlLCBrZXksIGNvbXB1dGVkW2tleV0pO1xuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0QXNzZXRSZWdpc3RlcnMgKFZ1ZSkge1xuICAvKipcbiAgICogQ3JlYXRlIGFzc2V0IHJlZ2lzdHJhdGlvbiBtZXRob2RzLlxuICAgKi9cbiAgQVNTRVRfVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgIFZ1ZVt0eXBlXSA9IGZ1bmN0aW9uIChcbiAgICAgIGlkLFxuICAgICAgZGVmaW5pdGlvblxuICAgICkge1xuICAgICAgaWYgKCFkZWZpbml0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnNbdHlwZSArICdzJ11baWRdXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgdHlwZSA9PT0gJ2NvbXBvbmVudCcpIHtcbiAgICAgICAgICB2YWxpZGF0ZUNvbXBvbmVudE5hbWUoaWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSAnY29tcG9uZW50JyAmJiBpc1BsYWluT2JqZWN0KGRlZmluaXRpb24pKSB7XG4gICAgICAgICAgZGVmaW5pdGlvbi5uYW1lID0gZGVmaW5pdGlvbi5uYW1lIHx8IGlkO1xuICAgICAgICAgIGRlZmluaXRpb24gPSB0aGlzLm9wdGlvbnMuX2Jhc2UuZXh0ZW5kKGRlZmluaXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSAnZGlyZWN0aXZlJyAmJiB0eXBlb2YgZGVmaW5pdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGRlZmluaXRpb24gPSB7IGJpbmQ6IGRlZmluaXRpb24sIHVwZGF0ZTogZGVmaW5pdGlvbiB9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3B0aW9uc1t0eXBlICsgJ3MnXVtpZF0gPSBkZWZpbml0aW9uO1xuICAgICAgICByZXR1cm4gZGVmaW5pdGlvblxuICAgICAgfVxuICAgIH07XG4gIH0pO1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZSAob3B0cykge1xuICByZXR1cm4gb3B0cyAmJiAob3B0cy5DdG9yLm9wdGlvbnMubmFtZSB8fCBvcHRzLnRhZylcbn1cblxuZnVuY3Rpb24gbWF0Y2hlcyAocGF0dGVybiwgbmFtZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShwYXR0ZXJuKSkge1xuICAgIHJldHVybiBwYXR0ZXJuLmluZGV4T2YobmFtZSkgPiAtMVxuICB9IGVsc2UgaWYgKHR5cGVvZiBwYXR0ZXJuID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBwYXR0ZXJuLnNwbGl0KCcsJykuaW5kZXhPZihuYW1lKSA+IC0xXG4gIH0gZWxzZSBpZiAoaXNSZWdFeHAocGF0dGVybikpIHtcbiAgICByZXR1cm4gcGF0dGVybi50ZXN0KG5hbWUpXG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIHBydW5lQ2FjaGUgKGtlZXBBbGl2ZUluc3RhbmNlLCBmaWx0ZXIpIHtcbiAgdmFyIGNhY2hlID0ga2VlcEFsaXZlSW5zdGFuY2UuY2FjaGU7XG4gIHZhciBrZXlzID0ga2VlcEFsaXZlSW5zdGFuY2Uua2V5cztcbiAgdmFyIF92bm9kZSA9IGtlZXBBbGl2ZUluc3RhbmNlLl92bm9kZTtcbiAgZm9yICh2YXIga2V5IGluIGNhY2hlKSB7XG4gICAgdmFyIGNhY2hlZE5vZGUgPSBjYWNoZVtrZXldO1xuICAgIGlmIChjYWNoZWROb2RlKSB7XG4gICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoY2FjaGVkTm9kZS5jb21wb25lbnRPcHRpb25zKTtcbiAgICAgIGlmIChuYW1lICYmICFmaWx0ZXIobmFtZSkpIHtcbiAgICAgICAgcHJ1bmVDYWNoZUVudHJ5KGNhY2hlLCBrZXksIGtleXMsIF92bm9kZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHBydW5lQ2FjaGVFbnRyeSAoXG4gIGNhY2hlLFxuICBrZXksXG4gIGtleXMsXG4gIGN1cnJlbnRcbikge1xuICB2YXIgY2FjaGVkJCQxID0gY2FjaGVba2V5XTtcbiAgaWYgKGNhY2hlZCQkMSAmJiAoIWN1cnJlbnQgfHwgY2FjaGVkJCQxLnRhZyAhPT0gY3VycmVudC50YWcpKSB7XG4gICAgY2FjaGVkJCQxLmNvbXBvbmVudEluc3RhbmNlLiRkZXN0cm95KCk7XG4gIH1cbiAgY2FjaGVba2V5XSA9IG51bGw7XG4gIHJlbW92ZShrZXlzLCBrZXkpO1xufVxuXG52YXIgcGF0dGVyblR5cGVzID0gW1N0cmluZywgUmVnRXhwLCBBcnJheV07XG5cbnZhciBLZWVwQWxpdmUgPSB7XG4gIG5hbWU6ICdrZWVwLWFsaXZlJyxcbiAgYWJzdHJhY3Q6IHRydWUsXG5cbiAgcHJvcHM6IHtcbiAgICBpbmNsdWRlOiBwYXR0ZXJuVHlwZXMsXG4gICAgZXhjbHVkZTogcGF0dGVyblR5cGVzLFxuICAgIG1heDogW1N0cmluZywgTnVtYmVyXVxuICB9LFxuXG4gIGNyZWF0ZWQ6IGZ1bmN0aW9uIGNyZWF0ZWQgKCkge1xuICAgIHRoaXMuY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMua2V5cyA9IFtdO1xuICB9LFxuXG4gIGRlc3Ryb3llZDogZnVuY3Rpb24gZGVzdHJveWVkICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIGZvciAodmFyIGtleSBpbiB0aGlzJDEuY2FjaGUpIHtcbiAgICAgIHBydW5lQ2FjaGVFbnRyeSh0aGlzJDEuY2FjaGUsIGtleSwgdGhpcyQxLmtleXMpO1xuICAgIH1cbiAgfSxcblxuICBtb3VudGVkOiBmdW5jdGlvbiBtb3VudGVkICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHRoaXMuJHdhdGNoKCdpbmNsdWRlJywgZnVuY3Rpb24gKHZhbCkge1xuICAgICAgcHJ1bmVDYWNoZSh0aGlzJDEsIGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBtYXRjaGVzKHZhbCwgbmFtZSk7IH0pO1xuICAgIH0pO1xuICAgIHRoaXMuJHdhdGNoKCdleGNsdWRlJywgZnVuY3Rpb24gKHZhbCkge1xuICAgICAgcHJ1bmVDYWNoZSh0aGlzJDEsIGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiAhbWF0Y2hlcyh2YWwsIG5hbWUpOyB9KTtcbiAgICB9KTtcbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoKSB7XG4gICAgdmFyIHNsb3QgPSB0aGlzLiRzbG90cy5kZWZhdWx0O1xuICAgIHZhciB2bm9kZSA9IGdldEZpcnN0Q29tcG9uZW50Q2hpbGQoc2xvdCk7XG4gICAgdmFyIGNvbXBvbmVudE9wdGlvbnMgPSB2bm9kZSAmJiB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xuICAgIGlmIChjb21wb25lbnRPcHRpb25zKSB7XG4gICAgICAvLyBjaGVjayBwYXR0ZXJuXG4gICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoY29tcG9uZW50T3B0aW9ucyk7XG4gICAgICB2YXIgcmVmID0gdGhpcztcbiAgICAgIHZhciBpbmNsdWRlID0gcmVmLmluY2x1ZGU7XG4gICAgICB2YXIgZXhjbHVkZSA9IHJlZi5leGNsdWRlO1xuICAgICAgaWYgKFxuICAgICAgICAvLyBub3QgaW5jbHVkZWRcbiAgICAgICAgKGluY2x1ZGUgJiYgKCFuYW1lIHx8ICFtYXRjaGVzKGluY2x1ZGUsIG5hbWUpKSkgfHxcbiAgICAgICAgLy8gZXhjbHVkZWRcbiAgICAgICAgKGV4Y2x1ZGUgJiYgbmFtZSAmJiBtYXRjaGVzKGV4Y2x1ZGUsIG5hbWUpKVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiB2bm9kZVxuICAgICAgfVxuXG4gICAgICB2YXIgcmVmJDEgPSB0aGlzO1xuICAgICAgdmFyIGNhY2hlID0gcmVmJDEuY2FjaGU7XG4gICAgICB2YXIga2V5cyA9IHJlZiQxLmtleXM7XG4gICAgICB2YXIga2V5ID0gdm5vZGUua2V5ID09IG51bGxcbiAgICAgICAgLy8gc2FtZSBjb25zdHJ1Y3RvciBtYXkgZ2V0IHJlZ2lzdGVyZWQgYXMgZGlmZmVyZW50IGxvY2FsIGNvbXBvbmVudHNcbiAgICAgICAgLy8gc28gY2lkIGFsb25lIGlzIG5vdCBlbm91Z2ggKCMzMjY5KVxuICAgICAgICA/IGNvbXBvbmVudE9wdGlvbnMuQ3Rvci5jaWQgKyAoY29tcG9uZW50T3B0aW9ucy50YWcgPyAoXCI6OlwiICsgKGNvbXBvbmVudE9wdGlvbnMudGFnKSkgOiAnJylcbiAgICAgICAgOiB2bm9kZS5rZXk7XG4gICAgICBpZiAoY2FjaGVba2V5XSkge1xuICAgICAgICB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IGNhY2hlW2tleV0uY29tcG9uZW50SW5zdGFuY2U7XG4gICAgICAgIC8vIG1ha2UgY3VycmVudCBrZXkgZnJlc2hlc3RcbiAgICAgICAgcmVtb3ZlKGtleXMsIGtleSk7XG4gICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FjaGVba2V5XSA9IHZub2RlO1xuICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgLy8gcHJ1bmUgb2xkZXN0IGVudHJ5XG4gICAgICAgIGlmICh0aGlzLm1heCAmJiBrZXlzLmxlbmd0aCA+IHBhcnNlSW50KHRoaXMubWF4KSkge1xuICAgICAgICAgIHBydW5lQ2FjaGVFbnRyeShjYWNoZSwga2V5c1swXSwga2V5cywgdGhpcy5fdm5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZub2RlLmRhdGEua2VlcEFsaXZlID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHZub2RlIHx8IChzbG90ICYmIHNsb3RbMF0pXG4gIH1cbn1cblxudmFyIGJ1aWx0SW5Db21wb25lbnRzID0ge1xuICBLZWVwQWxpdmU6IEtlZXBBbGl2ZVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdEdsb2JhbEFQSSAoVnVlKSB7XG4gIC8vIGNvbmZpZ1xuICB2YXIgY29uZmlnRGVmID0ge307XG4gIGNvbmZpZ0RlZi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25maWc7IH07XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgY29uZmlnRGVmLnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdEbyBub3QgcmVwbGFjZSB0aGUgVnVlLmNvbmZpZyBvYmplY3QsIHNldCBpbmRpdmlkdWFsIGZpZWxkcyBpbnN0ZWFkLidcbiAgICAgICk7XG4gICAgfTtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLCAnY29uZmlnJywgY29uZmlnRGVmKTtcblxuICAvLyBleHBvc2VkIHV0aWwgbWV0aG9kcy5cbiAgLy8gTk9URTogdGhlc2UgYXJlIG5vdCBjb25zaWRlcmVkIHBhcnQgb2YgdGhlIHB1YmxpYyBBUEkgLSBhdm9pZCByZWx5aW5nIG9uXG4gIC8vIHRoZW0gdW5sZXNzIHlvdSBhcmUgYXdhcmUgb2YgdGhlIHJpc2suXG4gIFZ1ZS51dGlsID0ge1xuICAgIHdhcm46IHdhcm4sXG4gICAgZXh0ZW5kOiBleHRlbmQsXG4gICAgbWVyZ2VPcHRpb25zOiBtZXJnZU9wdGlvbnMsXG4gICAgZGVmaW5lUmVhY3RpdmU6IGRlZmluZVJlYWN0aXZlXG4gIH07XG5cbiAgVnVlLnNldCA9IHNldDtcbiAgVnVlLmRlbGV0ZSA9IGRlbDtcbiAgVnVlLm5leHRUaWNrID0gbmV4dFRpY2s7XG5cbiAgVnVlLm9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBBU1NFVF9UWVBFUy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgVnVlLm9wdGlvbnNbdHlwZSArICdzJ10gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB9KTtcblxuICAvLyB0aGlzIGlzIHVzZWQgdG8gaWRlbnRpZnkgdGhlIFwiYmFzZVwiIGNvbnN0cnVjdG9yIHRvIGV4dGVuZCBhbGwgcGxhaW4tb2JqZWN0XG4gIC8vIGNvbXBvbmVudHMgd2l0aCBpbiBXZWV4J3MgbXVsdGktaW5zdGFuY2Ugc2NlbmFyaW9zLlxuICBWdWUub3B0aW9ucy5fYmFzZSA9IFZ1ZTtcblxuICBleHRlbmQoVnVlLm9wdGlvbnMuY29tcG9uZW50cywgYnVpbHRJbkNvbXBvbmVudHMpO1xuXG4gIGluaXRVc2UoVnVlKTtcbiAgaW5pdE1peGluJDEoVnVlKTtcbiAgaW5pdEV4dGVuZChWdWUpO1xuICBpbml0QXNzZXRSZWdpc3RlcnMoVnVlKTtcbn1cblxuaW5pdEdsb2JhbEFQSShWdWUpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRpc1NlcnZlcicsIHtcbiAgZ2V0OiBpc1NlcnZlclJlbmRlcmluZ1xufSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJHNzckNvbnRleHQnLCB7XG4gIGdldDogZnVuY3Rpb24gZ2V0ICgpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHJldHVybiB0aGlzLiR2bm9kZSAmJiB0aGlzLiR2bm9kZS5zc3JDb250ZXh0XG4gIH1cbn0pO1xuXG4vLyBleHBvc2UgRnVuY3Rpb25hbFJlbmRlckNvbnRleHQgZm9yIHNzciBydW50aW1lIGhlbHBlciBpbnN0YWxsYXRpb25cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUsICdGdW5jdGlvbmFsUmVuZGVyQ29udGV4dCcsIHtcbiAgdmFsdWU6IEZ1bmN0aW9uYWxSZW5kZXJDb250ZXh0XG59KTtcblxuVnVlLnZlcnNpb24gPSAnMi41LjE2JztcblxuLyogICovXG5cbi8vIHRoZXNlIGFyZSByZXNlcnZlZCBmb3Igd2ViIGJlY2F1c2UgdGhleSBhcmUgZGlyZWN0bHkgY29tcGlsZWQgYXdheVxuLy8gZHVyaW5nIHRlbXBsYXRlIGNvbXBpbGF0aW9uXG52YXIgaXNSZXNlcnZlZEF0dHIgPSBtYWtlTWFwKCdzdHlsZSxjbGFzcycpO1xuXG4vLyBhdHRyaWJ1dGVzIHRoYXQgc2hvdWxkIGJlIHVzaW5nIHByb3BzIGZvciBiaW5kaW5nXG52YXIgYWNjZXB0VmFsdWUgPSBtYWtlTWFwKCdpbnB1dCx0ZXh0YXJlYSxvcHRpb24sc2VsZWN0LHByb2dyZXNzJyk7XG52YXIgbXVzdFVzZVByb3AgPSBmdW5jdGlvbiAodGFnLCB0eXBlLCBhdHRyKSB7XG4gIHJldHVybiAoXG4gICAgKGF0dHIgPT09ICd2YWx1ZScgJiYgYWNjZXB0VmFsdWUodGFnKSkgJiYgdHlwZSAhPT0gJ2J1dHRvbicgfHxcbiAgICAoYXR0ciA9PT0gJ3NlbGVjdGVkJyAmJiB0YWcgPT09ICdvcHRpb24nKSB8fFxuICAgIChhdHRyID09PSAnY2hlY2tlZCcgJiYgdGFnID09PSAnaW5wdXQnKSB8fFxuICAgIChhdHRyID09PSAnbXV0ZWQnICYmIHRhZyA9PT0gJ3ZpZGVvJylcbiAgKVxufTtcblxudmFyIGlzRW51bWVyYXRlZEF0dHIgPSBtYWtlTWFwKCdjb250ZW50ZWRpdGFibGUsZHJhZ2dhYmxlLHNwZWxsY2hlY2snKTtcblxudmFyIGlzQm9vbGVhbkF0dHIgPSBtYWtlTWFwKFxuICAnYWxsb3dmdWxsc2NyZWVuLGFzeW5jLGF1dG9mb2N1cyxhdXRvcGxheSxjaGVja2VkLGNvbXBhY3QsY29udHJvbHMsZGVjbGFyZSwnICtcbiAgJ2RlZmF1bHQsZGVmYXVsdGNoZWNrZWQsZGVmYXVsdG11dGVkLGRlZmF1bHRzZWxlY3RlZCxkZWZlcixkaXNhYmxlZCwnICtcbiAgJ2VuYWJsZWQsZm9ybW5vdmFsaWRhdGUsaGlkZGVuLGluZGV0ZXJtaW5hdGUsaW5lcnQsaXNtYXAsaXRlbXNjb3BlLGxvb3AsbXVsdGlwbGUsJyArXG4gICdtdXRlZCxub2hyZWYsbm9yZXNpemUsbm9zaGFkZSxub3ZhbGlkYXRlLG5vd3JhcCxvcGVuLHBhdXNlb25leGl0LHJlYWRvbmx5LCcgK1xuICAncmVxdWlyZWQscmV2ZXJzZWQsc2NvcGVkLHNlYW1sZXNzLHNlbGVjdGVkLHNvcnRhYmxlLHRyYW5zbGF0ZSwnICtcbiAgJ3RydWVzcGVlZCx0eXBlbXVzdG1hdGNoLHZpc2libGUnXG4pO1xuXG52YXIgeGxpbmtOUyA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJztcblxudmFyIGlzWGxpbmsgPSBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gbmFtZS5jaGFyQXQoNSkgPT09ICc6JyAmJiBuYW1lLnNsaWNlKDAsIDUpID09PSAneGxpbmsnXG59O1xuXG52YXIgZ2V0WGxpbmtQcm9wID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIGlzWGxpbmsobmFtZSkgPyBuYW1lLnNsaWNlKDYsIG5hbWUubGVuZ3RoKSA6ICcnXG59O1xuXG52YXIgaXNGYWxzeUF0dHJWYWx1ZSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgcmV0dXJuIHZhbCA9PSBudWxsIHx8IHZhbCA9PT0gZmFsc2Vcbn07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBnZW5DbGFzc0ZvclZub2RlICh2bm9kZSkge1xuICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gIHZhciBwYXJlbnROb2RlID0gdm5vZGU7XG4gIHZhciBjaGlsZE5vZGUgPSB2bm9kZTtcbiAgd2hpbGUgKGlzRGVmKGNoaWxkTm9kZS5jb21wb25lbnRJbnN0YW5jZSkpIHtcbiAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgIGlmIChjaGlsZE5vZGUgJiYgY2hpbGROb2RlLmRhdGEpIHtcbiAgICAgIGRhdGEgPSBtZXJnZUNsYXNzRGF0YShjaGlsZE5vZGUuZGF0YSwgZGF0YSk7XG4gICAgfVxuICB9XG4gIHdoaWxlIChpc0RlZihwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5wYXJlbnQpKSB7XG4gICAgaWYgKHBhcmVudE5vZGUgJiYgcGFyZW50Tm9kZS5kYXRhKSB7XG4gICAgICBkYXRhID0gbWVyZ2VDbGFzc0RhdGEoZGF0YSwgcGFyZW50Tm9kZS5kYXRhKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlbmRlckNsYXNzKGRhdGEuc3RhdGljQ2xhc3MsIGRhdGEuY2xhc3MpXG59XG5cbmZ1bmN0aW9uIG1lcmdlQ2xhc3NEYXRhIChjaGlsZCwgcGFyZW50KSB7XG4gIHJldHVybiB7XG4gICAgc3RhdGljQ2xhc3M6IGNvbmNhdChjaGlsZC5zdGF0aWNDbGFzcywgcGFyZW50LnN0YXRpY0NsYXNzKSxcbiAgICBjbGFzczogaXNEZWYoY2hpbGQuY2xhc3MpXG4gICAgICA/IFtjaGlsZC5jbGFzcywgcGFyZW50LmNsYXNzXVxuICAgICAgOiBwYXJlbnQuY2xhc3NcbiAgfVxufVxuXG5mdW5jdGlvbiByZW5kZXJDbGFzcyAoXG4gIHN0YXRpY0NsYXNzLFxuICBkeW5hbWljQ2xhc3Ncbikge1xuICBpZiAoaXNEZWYoc3RhdGljQ2xhc3MpIHx8IGlzRGVmKGR5bmFtaWNDbGFzcykpIHtcbiAgICByZXR1cm4gY29uY2F0KHN0YXRpY0NsYXNzLCBzdHJpbmdpZnlDbGFzcyhkeW5hbWljQ2xhc3MpKVxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHJldHVybiAnJ1xufVxuXG5mdW5jdGlvbiBjb25jYXQgKGEsIGIpIHtcbiAgcmV0dXJuIGEgPyBiID8gKGEgKyAnICcgKyBiKSA6IGEgOiAoYiB8fCAnJylcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5Q2xhc3MgKHZhbHVlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiBzdHJpbmdpZnlBcnJheSh2YWx1ZSlcbiAgfVxuICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIHN0cmluZ2lmeU9iamVjdCh2YWx1ZSlcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZVxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHJldHVybiAnJ1xufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnlBcnJheSAodmFsdWUpIHtcbiAgdmFyIHJlcyA9ICcnO1xuICB2YXIgc3RyaW5naWZpZWQ7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKGlzRGVmKHN0cmluZ2lmaWVkID0gc3RyaW5naWZ5Q2xhc3ModmFsdWVbaV0pKSAmJiBzdHJpbmdpZmllZCAhPT0gJycpIHtcbiAgICAgIGlmIChyZXMpIHsgcmVzICs9ICcgJzsgfVxuICAgICAgcmVzICs9IHN0cmluZ2lmaWVkO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeU9iamVjdCAodmFsdWUpIHtcbiAgdmFyIHJlcyA9ICcnO1xuICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICBpZiAodmFsdWVba2V5XSkge1xuICAgICAgaWYgKHJlcykgeyByZXMgKz0gJyAnOyB9XG4gICAgICByZXMgKz0ga2V5O1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG52YXIgbmFtZXNwYWNlTWFwID0ge1xuICBzdmc6ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsXG4gIG1hdGg6ICdodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MJ1xufTtcblxudmFyIGlzSFRNTFRhZyA9IG1ha2VNYXAoXG4gICdodG1sLGJvZHksYmFzZSxoZWFkLGxpbmssbWV0YSxzdHlsZSx0aXRsZSwnICtcbiAgJ2FkZHJlc3MsYXJ0aWNsZSxhc2lkZSxmb290ZXIsaGVhZGVyLGgxLGgyLGgzLGg0LGg1LGg2LGhncm91cCxuYXYsc2VjdGlvbiwnICtcbiAgJ2RpdixkZCxkbCxkdCxmaWdjYXB0aW9uLGZpZ3VyZSxwaWN0dXJlLGhyLGltZyxsaSxtYWluLG9sLHAscHJlLHVsLCcgK1xuICAnYSxiLGFiYnIsYmRpLGJkbyxicixjaXRlLGNvZGUsZGF0YSxkZm4sZW0saSxrYmQsbWFyayxxLHJwLHJ0LHJ0YyxydWJ5LCcgK1xuICAncyxzYW1wLHNtYWxsLHNwYW4sc3Ryb25nLHN1YixzdXAsdGltZSx1LHZhcix3YnIsYXJlYSxhdWRpbyxtYXAsdHJhY2ssdmlkZW8sJyArXG4gICdlbWJlZCxvYmplY3QscGFyYW0sc291cmNlLGNhbnZhcyxzY3JpcHQsbm9zY3JpcHQsZGVsLGlucywnICtcbiAgJ2NhcHRpb24sY29sLGNvbGdyb3VwLHRhYmxlLHRoZWFkLHRib2R5LHRkLHRoLHRyLCcgK1xuICAnYnV0dG9uLGRhdGFsaXN0LGZpZWxkc2V0LGZvcm0saW5wdXQsbGFiZWwsbGVnZW5kLG1ldGVyLG9wdGdyb3VwLG9wdGlvbiwnICtcbiAgJ291dHB1dCxwcm9ncmVzcyxzZWxlY3QsdGV4dGFyZWEsJyArXG4gICdkZXRhaWxzLGRpYWxvZyxtZW51LG1lbnVpdGVtLHN1bW1hcnksJyArXG4gICdjb250ZW50LGVsZW1lbnQsc2hhZG93LHRlbXBsYXRlLGJsb2NrcXVvdGUsaWZyYW1lLHRmb290J1xuKTtcblxuLy8gdGhpcyBtYXAgaXMgaW50ZW50aW9uYWxseSBzZWxlY3RpdmUsIG9ubHkgY292ZXJpbmcgU1ZHIGVsZW1lbnRzIHRoYXQgbWF5XG4vLyBjb250YWluIGNoaWxkIGVsZW1lbnRzLlxudmFyIGlzU1ZHID0gbWFrZU1hcChcbiAgJ3N2ZyxhbmltYXRlLGNpcmNsZSxjbGlwcGF0aCxjdXJzb3IsZGVmcyxkZXNjLGVsbGlwc2UsZmlsdGVyLGZvbnQtZmFjZSwnICtcbiAgJ2ZvcmVpZ25PYmplY3QsZyxnbHlwaCxpbWFnZSxsaW5lLG1hcmtlcixtYXNrLG1pc3NpbmctZ2x5cGgscGF0aCxwYXR0ZXJuLCcgK1xuICAncG9seWdvbixwb2x5bGluZSxyZWN0LHN3aXRjaCxzeW1ib2wsdGV4dCx0ZXh0cGF0aCx0c3Bhbix1c2UsdmlldycsXG4gIHRydWVcbik7XG5cbnZhciBpc1ByZVRhZyA9IGZ1bmN0aW9uICh0YWcpIHsgcmV0dXJuIHRhZyA9PT0gJ3ByZSc7IH07XG5cbnZhciBpc1Jlc2VydmVkVGFnID0gZnVuY3Rpb24gKHRhZykge1xuICByZXR1cm4gaXNIVE1MVGFnKHRhZykgfHwgaXNTVkcodGFnKVxufTtcblxuZnVuY3Rpb24gZ2V0VGFnTmFtZXNwYWNlICh0YWcpIHtcbiAgaWYgKGlzU1ZHKHRhZykpIHtcbiAgICByZXR1cm4gJ3N2ZydcbiAgfVxuICAvLyBiYXNpYyBzdXBwb3J0IGZvciBNYXRoTUxcbiAgLy8gbm90ZSBpdCBkb2Vzbid0IHN1cHBvcnQgb3RoZXIgTWF0aE1MIGVsZW1lbnRzIGJlaW5nIGNvbXBvbmVudCByb290c1xuICBpZiAodGFnID09PSAnbWF0aCcpIHtcbiAgICByZXR1cm4gJ21hdGgnXG4gIH1cbn1cblxudmFyIHVua25vd25FbGVtZW50Q2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuZnVuY3Rpb24gaXNVbmtub3duRWxlbWVudCAodGFnKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIWluQnJvd3Nlcikge1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgaWYgKGlzUmVzZXJ2ZWRUYWcodGFnKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIHRhZyA9IHRhZy50b0xvd2VyQ2FzZSgpO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHVua25vd25FbGVtZW50Q2FjaGVbdGFnXSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHVua25vd25FbGVtZW50Q2FjaGVbdGFnXVxuICB9XG4gIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgaWYgKHRhZy5pbmRleE9mKCctJykgPiAtMSkge1xuICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI4MjEwMzY0LzEwNzAyNDRcbiAgICByZXR1cm4gKHVua25vd25FbGVtZW50Q2FjaGVbdGFnXSA9IChcbiAgICAgIGVsLmNvbnN0cnVjdG9yID09PSB3aW5kb3cuSFRNTFVua25vd25FbGVtZW50IHx8XG4gICAgICBlbC5jb25zdHJ1Y3RvciA9PT0gd2luZG93LkhUTUxFbGVtZW50XG4gICAgKSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKHVua25vd25FbGVtZW50Q2FjaGVbdGFnXSA9IC9IVE1MVW5rbm93bkVsZW1lbnQvLnRlc3QoZWwudG9TdHJpbmcoKSkpXG4gIH1cbn1cblxudmFyIGlzVGV4dElucHV0VHlwZSA9IG1ha2VNYXAoJ3RleHQsbnVtYmVyLHBhc3N3b3JkLHNlYXJjaCxlbWFpbCx0ZWwsdXJsJyk7XG5cbi8qICAqL1xuXG4vKipcbiAqIFF1ZXJ5IGFuIGVsZW1lbnQgc2VsZWN0b3IgaWYgaXQncyBub3QgYW4gZWxlbWVudCBhbHJlYWR5LlxuICovXG5mdW5jdGlvbiBxdWVyeSAoZWwpIHtcbiAgaWYgKHR5cGVvZiBlbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgc2VsZWN0ZWQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGVsKTtcbiAgICBpZiAoIXNlbGVjdGVkKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgICdDYW5ub3QgZmluZCBlbGVtZW50OiAnICsgZWxcbiAgICAgICk7XG4gICAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICB9XG4gICAgcmV0dXJuIHNlbGVjdGVkXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGVsXG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQkMSAodGFnTmFtZSwgdm5vZGUpIHtcbiAgdmFyIGVsbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnTmFtZSk7XG4gIGlmICh0YWdOYW1lICE9PSAnc2VsZWN0Jykge1xuICAgIHJldHVybiBlbG1cbiAgfVxuICAvLyBmYWxzZSBvciBudWxsIHdpbGwgcmVtb3ZlIHRoZSBhdHRyaWJ1dGUgYnV0IHVuZGVmaW5lZCB3aWxsIG5vdFxuICBpZiAodm5vZGUuZGF0YSAmJiB2bm9kZS5kYXRhLmF0dHJzICYmIHZub2RlLmRhdGEuYXR0cnMubXVsdGlwbGUgIT09IHVuZGVmaW5lZCkge1xuICAgIGVsbS5zZXRBdHRyaWJ1dGUoJ211bHRpcGxlJywgJ211bHRpcGxlJyk7XG4gIH1cbiAgcmV0dXJuIGVsbVxufVxuXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50TlMgKG5hbWVzcGFjZSwgdGFnTmFtZSkge1xuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5hbWVzcGFjZU1hcFtuYW1lc3BhY2VdLCB0YWdOYW1lKVxufVxuXG5mdW5jdGlvbiBjcmVhdGVUZXh0Tm9kZSAodGV4dCkge1xuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGV4dClcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29tbWVudCAodGV4dCkge1xuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlQ29tbWVudCh0ZXh0KVxufVxuXG5mdW5jdGlvbiBpbnNlcnRCZWZvcmUgKHBhcmVudE5vZGUsIG5ld05vZGUsIHJlZmVyZW5jZU5vZGUpIHtcbiAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobmV3Tm9kZSwgcmVmZXJlbmNlTm9kZSk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUNoaWxkIChub2RlLCBjaGlsZCkge1xuICBub2RlLnJlbW92ZUNoaWxkKGNoaWxkKTtcbn1cblxuZnVuY3Rpb24gYXBwZW5kQ2hpbGQgKG5vZGUsIGNoaWxkKSB7XG4gIG5vZGUuYXBwZW5kQ2hpbGQoY2hpbGQpO1xufVxuXG5mdW5jdGlvbiBwYXJlbnROb2RlIChub2RlKSB7XG4gIHJldHVybiBub2RlLnBhcmVudE5vZGVcbn1cblxuZnVuY3Rpb24gbmV4dFNpYmxpbmcgKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUubmV4dFNpYmxpbmdcbn1cblxuZnVuY3Rpb24gdGFnTmFtZSAobm9kZSkge1xuICByZXR1cm4gbm9kZS50YWdOYW1lXG59XG5cbmZ1bmN0aW9uIHNldFRleHRDb250ZW50IChub2RlLCB0ZXh0KSB7XG4gIG5vZGUudGV4dENvbnRlbnQgPSB0ZXh0O1xufVxuXG5mdW5jdGlvbiBzZXRTdHlsZVNjb3BlIChub2RlLCBzY29wZUlkKSB7XG4gIG5vZGUuc2V0QXR0cmlidXRlKHNjb3BlSWQsICcnKTtcbn1cblxuXG52YXIgbm9kZU9wcyA9IE9iamVjdC5mcmVlemUoe1xuXHRjcmVhdGVFbGVtZW50OiBjcmVhdGVFbGVtZW50JDEsXG5cdGNyZWF0ZUVsZW1lbnROUzogY3JlYXRlRWxlbWVudE5TLFxuXHRjcmVhdGVUZXh0Tm9kZTogY3JlYXRlVGV4dE5vZGUsXG5cdGNyZWF0ZUNvbW1lbnQ6IGNyZWF0ZUNvbW1lbnQsXG5cdGluc2VydEJlZm9yZTogaW5zZXJ0QmVmb3JlLFxuXHRyZW1vdmVDaGlsZDogcmVtb3ZlQ2hpbGQsXG5cdGFwcGVuZENoaWxkOiBhcHBlbmRDaGlsZCxcblx0cGFyZW50Tm9kZTogcGFyZW50Tm9kZSxcblx0bmV4dFNpYmxpbmc6IG5leHRTaWJsaW5nLFxuXHR0YWdOYW1lOiB0YWdOYW1lLFxuXHRzZXRUZXh0Q29udGVudDogc2V0VGV4dENvbnRlbnQsXG5cdHNldFN0eWxlU2NvcGU6IHNldFN0eWxlU2NvcGVcbn0pO1xuXG4vKiAgKi9cblxudmFyIHJlZiA9IHtcbiAgY3JlYXRlOiBmdW5jdGlvbiBjcmVhdGUgKF8sIHZub2RlKSB7XG4gICAgcmVnaXN0ZXJSZWYodm5vZGUpO1xuICB9LFxuICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSAob2xkVm5vZGUsIHZub2RlKSB7XG4gICAgaWYgKG9sZFZub2RlLmRhdGEucmVmICE9PSB2bm9kZS5kYXRhLnJlZikge1xuICAgICAgcmVnaXN0ZXJSZWYob2xkVm5vZGUsIHRydWUpO1xuICAgICAgcmVnaXN0ZXJSZWYodm5vZGUpO1xuICAgIH1cbiAgfSxcbiAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSAodm5vZGUpIHtcbiAgICByZWdpc3RlclJlZih2bm9kZSwgdHJ1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVnaXN0ZXJSZWYgKHZub2RlLCBpc1JlbW92YWwpIHtcbiAgdmFyIGtleSA9IHZub2RlLmRhdGEucmVmO1xuICBpZiAoIWlzRGVmKGtleSkpIHsgcmV0dXJuIH1cblxuICB2YXIgdm0gPSB2bm9kZS5jb250ZXh0O1xuICB2YXIgcmVmID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgfHwgdm5vZGUuZWxtO1xuICB2YXIgcmVmcyA9IHZtLiRyZWZzO1xuICBpZiAoaXNSZW1vdmFsKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocmVmc1trZXldKSkge1xuICAgICAgcmVtb3ZlKHJlZnNba2V5XSwgcmVmKTtcbiAgICB9IGVsc2UgaWYgKHJlZnNba2V5XSA9PT0gcmVmKSB7XG4gICAgICByZWZzW2tleV0gPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICh2bm9kZS5kYXRhLnJlZkluRm9yKSB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkocmVmc1trZXldKSkge1xuICAgICAgICByZWZzW2tleV0gPSBbcmVmXTtcbiAgICAgIH0gZWxzZSBpZiAocmVmc1trZXldLmluZGV4T2YocmVmKSA8IDApIHtcbiAgICAgICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgICAgIHJlZnNba2V5XS5wdXNoKHJlZik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlZnNba2V5XSA9IHJlZjtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBWaXJ0dWFsIERPTSBwYXRjaGluZyBhbGdvcml0aG0gYmFzZWQgb24gU25hYmJkb20gYnlcbiAqIFNpbW9uIEZyaWlzIFZpbmR1bSAoQHBhbGRlcGluZClcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICogaHR0cHM6Ly9naXRodWIuY29tL3BhbGRlcGluZC9zbmFiYmRvbS9ibG9iL21hc3Rlci9MSUNFTlNFXG4gKlxuICogbW9kaWZpZWQgYnkgRXZhbiBZb3UgKEB5eXg5OTA4MDMpXG4gKlxuICogTm90IHR5cGUtY2hlY2tpbmcgdGhpcyBiZWNhdXNlIHRoaXMgZmlsZSBpcyBwZXJmLWNyaXRpY2FsIGFuZCB0aGUgY29zdFxuICogb2YgbWFraW5nIGZsb3cgdW5kZXJzdGFuZCBpdCBpcyBub3Qgd29ydGggaXQuXG4gKi9cblxudmFyIGVtcHR5Tm9kZSA9IG5ldyBWTm9kZSgnJywge30sIFtdKTtcblxudmFyIGhvb2tzID0gWydjcmVhdGUnLCAnYWN0aXZhdGUnLCAndXBkYXRlJywgJ3JlbW92ZScsICdkZXN0cm95J107XG5cbmZ1bmN0aW9uIHNhbWVWbm9kZSAoYSwgYikge1xuICByZXR1cm4gKFxuICAgIGEua2V5ID09PSBiLmtleSAmJiAoXG4gICAgICAoXG4gICAgICAgIGEudGFnID09PSBiLnRhZyAmJlxuICAgICAgICBhLmlzQ29tbWVudCA9PT0gYi5pc0NvbW1lbnQgJiZcbiAgICAgICAgaXNEZWYoYS5kYXRhKSA9PT0gaXNEZWYoYi5kYXRhKSAmJlxuICAgICAgICBzYW1lSW5wdXRUeXBlKGEsIGIpXG4gICAgICApIHx8IChcbiAgICAgICAgaXNUcnVlKGEuaXNBc3luY1BsYWNlaG9sZGVyKSAmJlxuICAgICAgICBhLmFzeW5jRmFjdG9yeSA9PT0gYi5hc3luY0ZhY3RvcnkgJiZcbiAgICAgICAgaXNVbmRlZihiLmFzeW5jRmFjdG9yeS5lcnJvcilcbiAgICAgIClcbiAgICApXG4gIClcbn1cblxuZnVuY3Rpb24gc2FtZUlucHV0VHlwZSAoYSwgYikge1xuICBpZiAoYS50YWcgIT09ICdpbnB1dCcpIHsgcmV0dXJuIHRydWUgfVxuICB2YXIgaTtcbiAgdmFyIHR5cGVBID0gaXNEZWYoaSA9IGEuZGF0YSkgJiYgaXNEZWYoaSA9IGkuYXR0cnMpICYmIGkudHlwZTtcbiAgdmFyIHR5cGVCID0gaXNEZWYoaSA9IGIuZGF0YSkgJiYgaXNEZWYoaSA9IGkuYXR0cnMpICYmIGkudHlwZTtcbiAgcmV0dXJuIHR5cGVBID09PSB0eXBlQiB8fCBpc1RleHRJbnB1dFR5cGUodHlwZUEpICYmIGlzVGV4dElucHV0VHlwZSh0eXBlQilcbn1cblxuZnVuY3Rpb24gY3JlYXRlS2V5VG9PbGRJZHggKGNoaWxkcmVuLCBiZWdpbklkeCwgZW5kSWR4KSB7XG4gIHZhciBpLCBrZXk7XG4gIHZhciBtYXAgPSB7fTtcbiAgZm9yIChpID0gYmVnaW5JZHg7IGkgPD0gZW5kSWR4OyArK2kpIHtcbiAgICBrZXkgPSBjaGlsZHJlbltpXS5rZXk7XG4gICAgaWYgKGlzRGVmKGtleSkpIHsgbWFwW2tleV0gPSBpOyB9XG4gIH1cbiAgcmV0dXJuIG1hcFxufVxuXG5mdW5jdGlvbiBjcmVhdGVQYXRjaEZ1bmN0aW9uIChiYWNrZW5kKSB7XG4gIHZhciBpLCBqO1xuICB2YXIgY2JzID0ge307XG5cbiAgdmFyIG1vZHVsZXMgPSBiYWNrZW5kLm1vZHVsZXM7XG4gIHZhciBub2RlT3BzID0gYmFja2VuZC5ub2RlT3BzO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBob29rcy5sZW5ndGg7ICsraSkge1xuICAgIGNic1tob29rc1tpXV0gPSBbXTtcbiAgICBmb3IgKGogPSAwOyBqIDwgbW9kdWxlcy5sZW5ndGg7ICsraikge1xuICAgICAgaWYgKGlzRGVmKG1vZHVsZXNbal1baG9va3NbaV1dKSkge1xuICAgICAgICBjYnNbaG9va3NbaV1dLnB1c2gobW9kdWxlc1tqXVtob29rc1tpXV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGVtcHR5Tm9kZUF0IChlbG0pIHtcbiAgICByZXR1cm4gbmV3IFZOb2RlKG5vZGVPcHMudGFnTmFtZShlbG0pLnRvTG93ZXJDYXNlKCksIHt9LCBbXSwgdW5kZWZpbmVkLCBlbG0pXG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVSbUNiIChjaGlsZEVsbSwgbGlzdGVuZXJzKSB7XG4gICAgZnVuY3Rpb24gcmVtb3ZlICgpIHtcbiAgICAgIGlmICgtLXJlbW92ZS5saXN0ZW5lcnMgPT09IDApIHtcbiAgICAgICAgcmVtb3ZlTm9kZShjaGlsZEVsbSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlbW92ZS5saXN0ZW5lcnMgPSBsaXN0ZW5lcnM7XG4gICAgcmV0dXJuIHJlbW92ZVxuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlTm9kZSAoZWwpIHtcbiAgICB2YXIgcGFyZW50ID0gbm9kZU9wcy5wYXJlbnROb2RlKGVsKTtcbiAgICAvLyBlbGVtZW50IG1heSBoYXZlIGFscmVhZHkgYmVlbiByZW1vdmVkIGR1ZSB0byB2LWh0bWwgLyB2LXRleHRcbiAgICBpZiAoaXNEZWYocGFyZW50KSkge1xuICAgICAgbm9kZU9wcy5yZW1vdmVDaGlsZChwYXJlbnQsIGVsKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc1Vua25vd25FbGVtZW50JCQxICh2bm9kZSwgaW5WUHJlKSB7XG4gICAgcmV0dXJuIChcbiAgICAgICFpblZQcmUgJiZcbiAgICAgICF2bm9kZS5ucyAmJlxuICAgICAgIShcbiAgICAgICAgY29uZmlnLmlnbm9yZWRFbGVtZW50cy5sZW5ndGggJiZcbiAgICAgICAgY29uZmlnLmlnbm9yZWRFbGVtZW50cy5zb21lKGZ1bmN0aW9uIChpZ25vcmUpIHtcbiAgICAgICAgICByZXR1cm4gaXNSZWdFeHAoaWdub3JlKVxuICAgICAgICAgICAgPyBpZ25vcmUudGVzdCh2bm9kZS50YWcpXG4gICAgICAgICAgICA6IGlnbm9yZSA9PT0gdm5vZGUudGFnXG4gICAgICAgIH0pXG4gICAgICApICYmXG4gICAgICBjb25maWcuaXNVbmtub3duRWxlbWVudCh2bm9kZS50YWcpXG4gICAgKVxuICB9XG5cbiAgdmFyIGNyZWF0aW5nRWxtSW5WUHJlID0gMDtcblxuICBmdW5jdGlvbiBjcmVhdGVFbG0gKFxuICAgIHZub2RlLFxuICAgIGluc2VydGVkVm5vZGVRdWV1ZSxcbiAgICBwYXJlbnRFbG0sXG4gICAgcmVmRWxtLFxuICAgIG5lc3RlZCxcbiAgICBvd25lckFycmF5LFxuICAgIGluZGV4XG4gICkge1xuICAgIGlmIChpc0RlZih2bm9kZS5lbG0pICYmIGlzRGVmKG93bmVyQXJyYXkpKSB7XG4gICAgICAvLyBUaGlzIHZub2RlIHdhcyB1c2VkIGluIGEgcHJldmlvdXMgcmVuZGVyIVxuICAgICAgLy8gbm93IGl0J3MgdXNlZCBhcyBhIG5ldyBub2RlLCBvdmVyd3JpdGluZyBpdHMgZWxtIHdvdWxkIGNhdXNlXG4gICAgICAvLyBwb3RlbnRpYWwgcGF0Y2ggZXJyb3JzIGRvd24gdGhlIHJvYWQgd2hlbiBpdCdzIHVzZWQgYXMgYW4gaW5zZXJ0aW9uXG4gICAgICAvLyByZWZlcmVuY2Ugbm9kZS4gSW5zdGVhZCwgd2UgY2xvbmUgdGhlIG5vZGUgb24tZGVtYW5kIGJlZm9yZSBjcmVhdGluZ1xuICAgICAgLy8gYXNzb2NpYXRlZCBET00gZWxlbWVudCBmb3IgaXQuXG4gICAgICB2bm9kZSA9IG93bmVyQXJyYXlbaW5kZXhdID0gY2xvbmVWTm9kZSh2bm9kZSk7XG4gICAgfVxuXG4gICAgdm5vZGUuaXNSb290SW5zZXJ0ID0gIW5lc3RlZDsgLy8gZm9yIHRyYW5zaXRpb24gZW50ZXIgY2hlY2tcbiAgICBpZiAoY3JlYXRlQ29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgIHZhciBjaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuO1xuICAgIHZhciB0YWcgPSB2bm9kZS50YWc7XG4gICAgaWYgKGlzRGVmKHRhZykpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmIChkYXRhICYmIGRhdGEucHJlKSB7XG4gICAgICAgICAgY3JlYXRpbmdFbG1JblZQcmUrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNVbmtub3duRWxlbWVudCQkMSh2bm9kZSwgY3JlYXRpbmdFbG1JblZQcmUpKSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgICdVbmtub3duIGN1c3RvbSBlbGVtZW50OiA8JyArIHRhZyArICc+IC0gZGlkIHlvdSAnICtcbiAgICAgICAgICAgICdyZWdpc3RlciB0aGUgY29tcG9uZW50IGNvcnJlY3RseT8gRm9yIHJlY3Vyc2l2ZSBjb21wb25lbnRzLCAnICtcbiAgICAgICAgICAgICdtYWtlIHN1cmUgdG8gcHJvdmlkZSB0aGUgXCJuYW1lXCIgb3B0aW9uLicsXG4gICAgICAgICAgICB2bm9kZS5jb250ZXh0XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2bm9kZS5lbG0gPSB2bm9kZS5uc1xuICAgICAgICA/IG5vZGVPcHMuY3JlYXRlRWxlbWVudE5TKHZub2RlLm5zLCB0YWcpXG4gICAgICAgIDogbm9kZU9wcy5jcmVhdGVFbGVtZW50KHRhZywgdm5vZGUpO1xuICAgICAgc2V0U2NvcGUodm5vZGUpO1xuXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIHtcbiAgICAgICAgY3JlYXRlQ2hpbGRyZW4odm5vZGUsIGNoaWxkcmVuLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgICAgICBpbnZva2VDcmVhdGVIb29rcyh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgfVxuICAgICAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGRhdGEgJiYgZGF0YS5wcmUpIHtcbiAgICAgICAgY3JlYXRpbmdFbG1JblZQcmUtLTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzVHJ1ZSh2bm9kZS5pc0NvbW1lbnQpKSB7XG4gICAgICB2bm9kZS5lbG0gPSBub2RlT3BzLmNyZWF0ZUNvbW1lbnQodm5vZGUudGV4dCk7XG4gICAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZub2RlLmVsbSA9IG5vZGVPcHMuY3JlYXRlVGV4dE5vZGUodm5vZGUudGV4dCk7XG4gICAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50ICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSkge1xuICAgIHZhciBpID0gdm5vZGUuZGF0YTtcbiAgICBpZiAoaXNEZWYoaSkpIHtcbiAgICAgIHZhciBpc1JlYWN0aXZhdGVkID0gaXNEZWYodm5vZGUuY29tcG9uZW50SW5zdGFuY2UpICYmIGkua2VlcEFsaXZlO1xuICAgICAgaWYgKGlzRGVmKGkgPSBpLmhvb2spICYmIGlzRGVmKGkgPSBpLmluaXQpKSB7XG4gICAgICAgIGkodm5vZGUsIGZhbHNlIC8qIGh5ZHJhdGluZyAqLywgcGFyZW50RWxtLCByZWZFbG0pO1xuICAgICAgfVxuICAgICAgLy8gYWZ0ZXIgY2FsbGluZyB0aGUgaW5pdCBob29rLCBpZiB0aGUgdm5vZGUgaXMgYSBjaGlsZCBjb21wb25lbnRcbiAgICAgIC8vIGl0IHNob3VsZCd2ZSBjcmVhdGVkIGEgY2hpbGQgaW5zdGFuY2UgYW5kIG1vdW50ZWQgaXQuIHRoZSBjaGlsZFxuICAgICAgLy8gY29tcG9uZW50IGFsc28gaGFzIHNldCB0aGUgcGxhY2Vob2xkZXIgdm5vZGUncyBlbG0uXG4gICAgICAvLyBpbiB0aGF0IGNhc2Ugd2UgY2FuIGp1c3QgcmV0dXJuIHRoZSBlbGVtZW50IGFuZCBiZSBkb25lLlxuICAgICAgaWYgKGlzRGVmKHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSkge1xuICAgICAgICBpbml0Q29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICBpZiAoaXNUcnVlKGlzUmVhY3RpdmF0ZWQpKSB7XG4gICAgICAgICAgcmVhY3RpdmF0ZUNvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbml0Q29tcG9uZW50ICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgaWYgKGlzRGVmKHZub2RlLmRhdGEucGVuZGluZ0luc2VydCkpIHtcbiAgICAgIGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoLmFwcGx5KGluc2VydGVkVm5vZGVRdWV1ZSwgdm5vZGUuZGF0YS5wZW5kaW5nSW5zZXJ0KTtcbiAgICAgIHZub2RlLmRhdGEucGVuZGluZ0luc2VydCA9IG51bGw7XG4gICAgfVxuICAgIHZub2RlLmVsbSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlLiRlbDtcbiAgICBpZiAoaXNQYXRjaGFibGUodm5vZGUpKSB7XG4gICAgICBpbnZva2VDcmVhdGVIb29rcyh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgIHNldFNjb3BlKHZub2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZW1wdHkgY29tcG9uZW50IHJvb3QuXG4gICAgICAvLyBza2lwIGFsbCBlbGVtZW50LXJlbGF0ZWQgbW9kdWxlcyBleGNlcHQgZm9yIHJlZiAoIzM0NTUpXG4gICAgICByZWdpc3RlclJlZih2bm9kZSk7XG4gICAgICAvLyBtYWtlIHN1cmUgdG8gaW52b2tlIHRoZSBpbnNlcnQgaG9va1xuICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2godm5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWN0aXZhdGVDb21wb25lbnQgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKSB7XG4gICAgdmFyIGk7XG4gICAgLy8gaGFjayBmb3IgIzQzMzk6IGEgcmVhY3RpdmF0ZWQgY29tcG9uZW50IHdpdGggaW5uZXIgdHJhbnNpdGlvblxuICAgIC8vIGRvZXMgbm90IHRyaWdnZXIgYmVjYXVzZSB0aGUgaW5uZXIgbm9kZSdzIGNyZWF0ZWQgaG9va3MgYXJlIG5vdCBjYWxsZWRcbiAgICAvLyBhZ2Fpbi4gSXQncyBub3QgaWRlYWwgdG8gaW52b2x2ZSBtb2R1bGUtc3BlY2lmaWMgbG9naWMgaW4gaGVyZSBidXRcbiAgICAvLyB0aGVyZSBkb2Vzbid0IHNlZW0gdG8gYmUgYSBiZXR0ZXIgd2F5IHRvIGRvIGl0LlxuICAgIHZhciBpbm5lck5vZGUgPSB2bm9kZTtcbiAgICB3aGlsZSAoaW5uZXJOb2RlLmNvbXBvbmVudEluc3RhbmNlKSB7XG4gICAgICBpbm5lck5vZGUgPSBpbm5lck5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgICAgaWYgKGlzRGVmKGkgPSBpbm5lck5vZGUuZGF0YSkgJiYgaXNEZWYoaSA9IGkudHJhbnNpdGlvbikpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNicy5hY3RpdmF0ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGNicy5hY3RpdmF0ZVtpXShlbXB0eU5vZGUsIGlubmVyTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2goaW5uZXJOb2RlKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gdW5saWtlIGEgbmV3bHkgY3JlYXRlZCBjb21wb25lbnQsXG4gICAgLy8gYSByZWFjdGl2YXRlZCBrZWVwLWFsaXZlIGNvbXBvbmVudCBkb2Vzbid0IGluc2VydCBpdHNlbGZcbiAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gIH1cblxuICBmdW5jdGlvbiBpbnNlcnQgKHBhcmVudCwgZWxtLCByZWYkJDEpIHtcbiAgICBpZiAoaXNEZWYocGFyZW50KSkge1xuICAgICAgaWYgKGlzRGVmKHJlZiQkMSkpIHtcbiAgICAgICAgaWYgKHJlZiQkMS5wYXJlbnROb2RlID09PSBwYXJlbnQpIHtcbiAgICAgICAgICBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnQsIGVsbSwgcmVmJCQxKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZU9wcy5hcHBlbmRDaGlsZChwYXJlbnQsIGVsbSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQ2hpbGRyZW4gKHZub2RlLCBjaGlsZHJlbiwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBjaGVja0R1cGxpY2F0ZUtleXMoY2hpbGRyZW4pO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7ICsraSkge1xuICAgICAgICBjcmVhdGVFbG0oY2hpbGRyZW5baV0sIGluc2VydGVkVm5vZGVRdWV1ZSwgdm5vZGUuZWxtLCBudWxsLCB0cnVlLCBjaGlsZHJlbiwgaSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1ByaW1pdGl2ZSh2bm9kZS50ZXh0KSkge1xuICAgICAgbm9kZU9wcy5hcHBlbmRDaGlsZCh2bm9kZS5lbG0sIG5vZGVPcHMuY3JlYXRlVGV4dE5vZGUoU3RyaW5nKHZub2RlLnRleHQpKSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNQYXRjaGFibGUgKHZub2RlKSB7XG4gICAgd2hpbGUgKHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSB7XG4gICAgICB2bm9kZSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIGlzRGVmKHZub2RlLnRhZylcbiAgfVxuXG4gIGZ1bmN0aW9uIGludm9rZUNyZWF0ZUhvb2tzICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgY2JzLmNyZWF0ZS5sZW5ndGg7ICsraSQxKSB7XG4gICAgICBjYnMuY3JlYXRlW2kkMV0oZW1wdHlOb2RlLCB2bm9kZSk7XG4gICAgfVxuICAgIGkgPSB2bm9kZS5kYXRhLmhvb2s7IC8vIFJldXNlIHZhcmlhYmxlXG4gICAgaWYgKGlzRGVmKGkpKSB7XG4gICAgICBpZiAoaXNEZWYoaS5jcmVhdGUpKSB7IGkuY3JlYXRlKGVtcHR5Tm9kZSwgdm5vZGUpOyB9XG4gICAgICBpZiAoaXNEZWYoaS5pbnNlcnQpKSB7IGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoKHZub2RlKTsgfVxuICAgIH1cbiAgfVxuXG4gIC8vIHNldCBzY29wZSBpZCBhdHRyaWJ1dGUgZm9yIHNjb3BlZCBDU1MuXG4gIC8vIHRoaXMgaXMgaW1wbGVtZW50ZWQgYXMgYSBzcGVjaWFsIGNhc2UgdG8gYXZvaWQgdGhlIG92ZXJoZWFkXG4gIC8vIG9mIGdvaW5nIHRocm91Z2ggdGhlIG5vcm1hbCBhdHRyaWJ1dGUgcGF0Y2hpbmcgcHJvY2Vzcy5cbiAgZnVuY3Rpb24gc2V0U2NvcGUgKHZub2RlKSB7XG4gICAgdmFyIGk7XG4gICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5mblNjb3BlSWQpKSB7XG4gICAgICBub2RlT3BzLnNldFN0eWxlU2NvcGUodm5vZGUuZWxtLCBpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGFuY2VzdG9yID0gdm5vZGU7XG4gICAgICB3aGlsZSAoYW5jZXN0b3IpIHtcbiAgICAgICAgaWYgKGlzRGVmKGkgPSBhbmNlc3Rvci5jb250ZXh0KSAmJiBpc0RlZihpID0gaS4kb3B0aW9ucy5fc2NvcGVJZCkpIHtcbiAgICAgICAgICBub2RlT3BzLnNldFN0eWxlU2NvcGUodm5vZGUuZWxtLCBpKTtcbiAgICAgICAgfVxuICAgICAgICBhbmNlc3RvciA9IGFuY2VzdG9yLnBhcmVudDtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gZm9yIHNsb3QgY29udGVudCB0aGV5IHNob3VsZCBhbHNvIGdldCB0aGUgc2NvcGVJZCBmcm9tIHRoZSBob3N0IGluc3RhbmNlLlxuICAgIGlmIChpc0RlZihpID0gYWN0aXZlSW5zdGFuY2UpICYmXG4gICAgICBpICE9PSB2bm9kZS5jb250ZXh0ICYmXG4gICAgICBpICE9PSB2bm9kZS5mbkNvbnRleHQgJiZcbiAgICAgIGlzRGVmKGkgPSBpLiRvcHRpb25zLl9zY29wZUlkKVxuICAgICkge1xuICAgICAgbm9kZU9wcy5zZXRTdHlsZVNjb3BlKHZub2RlLmVsbSwgaSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYWRkVm5vZGVzIChwYXJlbnRFbG0sIHJlZkVsbSwgdm5vZGVzLCBzdGFydElkeCwgZW5kSWR4LCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICBmb3IgKDsgc3RhcnRJZHggPD0gZW5kSWR4OyArK3N0YXJ0SWR4KSB7XG4gICAgICBjcmVhdGVFbG0odm5vZGVzW3N0YXJ0SWR4XSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSwgZmFsc2UsIHZub2Rlcywgc3RhcnRJZHgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGludm9rZURlc3Ryb3lIb29rICh2bm9kZSkge1xuICAgIHZhciBpLCBqO1xuICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgIGlmIChpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5kZXN0cm95KSkgeyBpKHZub2RlKTsgfVxuICAgICAgZm9yIChpID0gMDsgaSA8IGNicy5kZXN0cm95Lmxlbmd0aDsgKytpKSB7IGNicy5kZXN0cm95W2ldKHZub2RlKTsgfVxuICAgIH1cbiAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmNoaWxkcmVuKSkge1xuICAgICAgZm9yIChqID0gMDsgaiA8IHZub2RlLmNoaWxkcmVuLmxlbmd0aDsgKytqKSB7XG4gICAgICAgIGludm9rZURlc3Ryb3lIb29rKHZub2RlLmNoaWxkcmVuW2pdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVWbm9kZXMgKHBhcmVudEVsbSwgdm5vZGVzLCBzdGFydElkeCwgZW5kSWR4KSB7XG4gICAgZm9yICg7IHN0YXJ0SWR4IDw9IGVuZElkeDsgKytzdGFydElkeCkge1xuICAgICAgdmFyIGNoID0gdm5vZGVzW3N0YXJ0SWR4XTtcbiAgICAgIGlmIChpc0RlZihjaCkpIHtcbiAgICAgICAgaWYgKGlzRGVmKGNoLnRhZykpIHtcbiAgICAgICAgICByZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rKGNoKTtcbiAgICAgICAgICBpbnZva2VEZXN0cm95SG9vayhjaCk7XG4gICAgICAgIH0gZWxzZSB7IC8vIFRleHQgbm9kZVxuICAgICAgICAgIHJlbW92ZU5vZGUoY2guZWxtKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZUFuZEludm9rZVJlbW92ZUhvb2sgKHZub2RlLCBybSkge1xuICAgIGlmIChpc0RlZihybSkgfHwgaXNEZWYodm5vZGUuZGF0YSkpIHtcbiAgICAgIHZhciBpO1xuICAgICAgdmFyIGxpc3RlbmVycyA9IGNicy5yZW1vdmUubGVuZ3RoICsgMTtcbiAgICAgIGlmIChpc0RlZihybSkpIHtcbiAgICAgICAgLy8gd2UgaGF2ZSBhIHJlY3Vyc2l2ZWx5IHBhc3NlZCBkb3duIHJtIGNhbGxiYWNrXG4gICAgICAgIC8vIGluY3JlYXNlIHRoZSBsaXN0ZW5lcnMgY291bnRcbiAgICAgICAgcm0ubGlzdGVuZXJzICs9IGxpc3RlbmVycztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGRpcmVjdGx5IHJlbW92aW5nXG4gICAgICAgIHJtID0gY3JlYXRlUm1DYih2bm9kZS5lbG0sIGxpc3RlbmVycyk7XG4gICAgICB9XG4gICAgICAvLyByZWN1cnNpdmVseSBpbnZva2UgaG9va3Mgb24gY2hpbGQgY29tcG9uZW50IHJvb3Qgbm9kZVxuICAgICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkgJiYgaXNEZWYoaSA9IGkuX3Zub2RlKSAmJiBpc0RlZihpLmRhdGEpKSB7XG4gICAgICAgIHJlbW92ZUFuZEludm9rZVJlbW92ZUhvb2soaSwgcm0pO1xuICAgICAgfVxuICAgICAgZm9yIChpID0gMDsgaSA8IGNicy5yZW1vdmUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY2JzLnJlbW92ZVtpXSh2bm9kZSwgcm0pO1xuICAgICAgfVxuICAgICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5kYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnJlbW92ZSkpIHtcbiAgICAgICAgaSh2bm9kZSwgcm0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcm0oKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVtb3ZlTm9kZSh2bm9kZS5lbG0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUNoaWxkcmVuIChwYXJlbnRFbG0sIG9sZENoLCBuZXdDaCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCByZW1vdmVPbmx5KSB7XG4gICAgdmFyIG9sZFN0YXJ0SWR4ID0gMDtcbiAgICB2YXIgbmV3U3RhcnRJZHggPSAwO1xuICAgIHZhciBvbGRFbmRJZHggPSBvbGRDaC5sZW5ndGggLSAxO1xuICAgIHZhciBvbGRTdGFydFZub2RlID0gb2xkQ2hbMF07XG4gICAgdmFyIG9sZEVuZFZub2RlID0gb2xkQ2hbb2xkRW5kSWR4XTtcbiAgICB2YXIgbmV3RW5kSWR4ID0gbmV3Q2gubGVuZ3RoIC0gMTtcbiAgICB2YXIgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWzBdO1xuICAgIHZhciBuZXdFbmRWbm9kZSA9IG5ld0NoW25ld0VuZElkeF07XG4gICAgdmFyIG9sZEtleVRvSWR4LCBpZHhJbk9sZCwgdm5vZGVUb01vdmUsIHJlZkVsbTtcblxuICAgIC8vIHJlbW92ZU9ubHkgaXMgYSBzcGVjaWFsIGZsYWcgdXNlZCBvbmx5IGJ5IDx0cmFuc2l0aW9uLWdyb3VwPlxuICAgIC8vIHRvIGVuc3VyZSByZW1vdmVkIGVsZW1lbnRzIHN0YXkgaW4gY29ycmVjdCByZWxhdGl2ZSBwb3NpdGlvbnNcbiAgICAvLyBkdXJpbmcgbGVhdmluZyB0cmFuc2l0aW9uc1xuICAgIHZhciBjYW5Nb3ZlID0gIXJlbW92ZU9ubHk7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgY2hlY2tEdXBsaWNhdGVLZXlzKG5ld0NoKTtcbiAgICB9XG5cbiAgICB3aGlsZSAob2xkU3RhcnRJZHggPD0gb2xkRW5kSWR4ICYmIG5ld1N0YXJ0SWR4IDw9IG5ld0VuZElkeCkge1xuICAgICAgaWYgKGlzVW5kZWYob2xkU3RhcnRWbm9kZSkpIHtcbiAgICAgICAgb2xkU3RhcnRWbm9kZSA9IG9sZENoWysrb2xkU3RhcnRJZHhdOyAvLyBWbm9kZSBoYXMgYmVlbiBtb3ZlZCBsZWZ0XG4gICAgICB9IGVsc2UgaWYgKGlzVW5kZWYob2xkRW5kVm5vZGUpKSB7XG4gICAgICAgIG9sZEVuZFZub2RlID0gb2xkQ2hbLS1vbGRFbmRJZHhdO1xuICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3U3RhcnRWbm9kZSkpIHtcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRTdGFydFZub2RlLCBuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07XG4gICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZEVuZFZub2RlLCBuZXdFbmRWbm9kZSkpIHtcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRFbmRWbm9kZSwgbmV3RW5kVm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIG9sZEVuZFZub2RlID0gb2xkQ2hbLS1vbGRFbmRJZHhdO1xuICAgICAgICBuZXdFbmRWbm9kZSA9IG5ld0NoWy0tbmV3RW5kSWR4XTtcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld0VuZFZub2RlKSkgeyAvLyBWbm9kZSBtb3ZlZCByaWdodFxuICAgICAgICBwYXRjaFZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld0VuZFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICBjYW5Nb3ZlICYmIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudEVsbSwgb2xkU3RhcnRWbm9kZS5lbG0sIG5vZGVPcHMubmV4dFNpYmxpbmcob2xkRW5kVm5vZGUuZWxtKSk7XG4gICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTtcbiAgICAgICAgbmV3RW5kVm5vZGUgPSBuZXdDaFstLW5ld0VuZElkeF07XG4gICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRFbmRWbm9kZSwgbmV3U3RhcnRWbm9kZSkpIHsgLy8gVm5vZGUgbW92ZWQgbGVmdFxuICAgICAgICBwYXRjaFZub2RlKG9sZEVuZFZub2RlLCBuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICBjYW5Nb3ZlICYmIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudEVsbSwgb2xkRW5kVm5vZGUuZWxtLCBvbGRTdGFydFZub2RlLmVsbSk7XG4gICAgICAgIG9sZEVuZFZub2RlID0gb2xkQ2hbLS1vbGRFbmRJZHhdO1xuICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXNVbmRlZihvbGRLZXlUb0lkeCkpIHsgb2xkS2V5VG9JZHggPSBjcmVhdGVLZXlUb09sZElkeChvbGRDaCwgb2xkU3RhcnRJZHgsIG9sZEVuZElkeCk7IH1cbiAgICAgICAgaWR4SW5PbGQgPSBpc0RlZihuZXdTdGFydFZub2RlLmtleSlcbiAgICAgICAgICA/IG9sZEtleVRvSWR4W25ld1N0YXJ0Vm5vZGUua2V5XVxuICAgICAgICAgIDogZmluZElkeEluT2xkKG5ld1N0YXJ0Vm5vZGUsIG9sZENoLCBvbGRTdGFydElkeCwgb2xkRW5kSWR4KTtcbiAgICAgICAgaWYgKGlzVW5kZWYoaWR4SW5PbGQpKSB7IC8vIE5ldyBlbGVtZW50XG4gICAgICAgICAgY3JlYXRlRWxtKG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCBvbGRTdGFydFZub2RlLmVsbSwgZmFsc2UsIG5ld0NoLCBuZXdTdGFydElkeCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdm5vZGVUb01vdmUgPSBvbGRDaFtpZHhJbk9sZF07XG4gICAgICAgICAgaWYgKHNhbWVWbm9kZSh2bm9kZVRvTW92ZSwgbmV3U3RhcnRWbm9kZSkpIHtcbiAgICAgICAgICAgIHBhdGNoVm5vZGUodm5vZGVUb01vdmUsIG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgICAgICBvbGRDaFtpZHhJbk9sZF0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjYW5Nb3ZlICYmIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudEVsbSwgdm5vZGVUb01vdmUuZWxtLCBvbGRTdGFydFZub2RlLmVsbSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHNhbWUga2V5IGJ1dCBkaWZmZXJlbnQgZWxlbWVudC4gdHJlYXQgYXMgbmV3IGVsZW1lbnRcbiAgICAgICAgICAgIGNyZWF0ZUVsbShuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgb2xkU3RhcnRWbm9kZS5lbG0sIGZhbHNlLCBuZXdDaCwgbmV3U3RhcnRJZHgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvbGRTdGFydElkeCA+IG9sZEVuZElkeCkge1xuICAgICAgcmVmRWxtID0gaXNVbmRlZihuZXdDaFtuZXdFbmRJZHggKyAxXSkgPyBudWxsIDogbmV3Q2hbbmV3RW5kSWR4ICsgMV0uZWxtO1xuICAgICAgYWRkVm5vZGVzKHBhcmVudEVsbSwgcmVmRWxtLCBuZXdDaCwgbmV3U3RhcnRJZHgsIG5ld0VuZElkeCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICB9IGVsc2UgaWYgKG5ld1N0YXJ0SWR4ID4gbmV3RW5kSWR4KSB7XG4gICAgICByZW1vdmVWbm9kZXMocGFyZW50RWxtLCBvbGRDaCwgb2xkU3RhcnRJZHgsIG9sZEVuZElkeCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2hlY2tEdXBsaWNhdGVLZXlzIChjaGlsZHJlbikge1xuICAgIHZhciBzZWVuS2V5cyA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB2bm9kZSA9IGNoaWxkcmVuW2ldO1xuICAgICAgdmFyIGtleSA9IHZub2RlLmtleTtcbiAgICAgIGlmIChpc0RlZihrZXkpKSB7XG4gICAgICAgIGlmIChzZWVuS2V5c1trZXldKSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgIChcIkR1cGxpY2F0ZSBrZXlzIGRldGVjdGVkOiAnXCIgKyBrZXkgKyBcIicuIFRoaXMgbWF5IGNhdXNlIGFuIHVwZGF0ZSBlcnJvci5cIiksXG4gICAgICAgICAgICB2bm9kZS5jb250ZXh0XG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZWVuS2V5c1trZXldID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmRJZHhJbk9sZCAobm9kZSwgb2xkQ2gsIHN0YXJ0LCBlbmQpIHtcbiAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgdmFyIGMgPSBvbGRDaFtpXTtcbiAgICAgIGlmIChpc0RlZihjKSAmJiBzYW1lVm5vZGUobm9kZSwgYykpIHsgcmV0dXJuIGkgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBhdGNoVm5vZGUgKG9sZFZub2RlLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCByZW1vdmVPbmx5KSB7XG4gICAgaWYgKG9sZFZub2RlID09PSB2bm9kZSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdmFyIGVsbSA9IHZub2RlLmVsbSA9IG9sZFZub2RlLmVsbTtcblxuICAgIGlmIChpc1RydWUob2xkVm5vZGUuaXNBc3luY1BsYWNlaG9sZGVyKSkge1xuICAgICAgaWYgKGlzRGVmKHZub2RlLmFzeW5jRmFjdG9yeS5yZXNvbHZlZCkpIHtcbiAgICAgICAgaHlkcmF0ZShvbGRWbm9kZS5lbG0sIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdm5vZGUuaXNBc3luY1BsYWNlaG9sZGVyID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIHJldXNlIGVsZW1lbnQgZm9yIHN0YXRpYyB0cmVlcy5cbiAgICAvLyBub3RlIHdlIG9ubHkgZG8gdGhpcyBpZiB0aGUgdm5vZGUgaXMgY2xvbmVkIC1cbiAgICAvLyBpZiB0aGUgbmV3IG5vZGUgaXMgbm90IGNsb25lZCBpdCBtZWFucyB0aGUgcmVuZGVyIGZ1bmN0aW9ucyBoYXZlIGJlZW5cbiAgICAvLyByZXNldCBieSB0aGUgaG90LXJlbG9hZC1hcGkgYW5kIHdlIG5lZWQgdG8gZG8gYSBwcm9wZXIgcmUtcmVuZGVyLlxuICAgIGlmIChpc1RydWUodm5vZGUuaXNTdGF0aWMpICYmXG4gICAgICBpc1RydWUob2xkVm5vZGUuaXNTdGF0aWMpICYmXG4gICAgICB2bm9kZS5rZXkgPT09IG9sZFZub2RlLmtleSAmJlxuICAgICAgKGlzVHJ1ZSh2bm9kZS5pc0Nsb25lZCkgfHwgaXNUcnVlKHZub2RlLmlzT25jZSkpXG4gICAgKSB7XG4gICAgICB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IG9sZFZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdmFyIGk7XG4gICAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgIGlmIChpc0RlZihkYXRhKSAmJiBpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5wcmVwYXRjaCkpIHtcbiAgICAgIGkob2xkVm5vZGUsIHZub2RlKTtcbiAgICB9XG5cbiAgICB2YXIgb2xkQ2ggPSBvbGRWbm9kZS5jaGlsZHJlbjtcbiAgICB2YXIgY2ggPSB2bm9kZS5jaGlsZHJlbjtcbiAgICBpZiAoaXNEZWYoZGF0YSkgJiYgaXNQYXRjaGFibGUodm5vZGUpKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLnVwZGF0ZS5sZW5ndGg7ICsraSkgeyBjYnMudXBkYXRlW2ldKG9sZFZub2RlLCB2bm9kZSk7IH1cbiAgICAgIGlmIChpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS51cGRhdGUpKSB7IGkob2xkVm5vZGUsIHZub2RlKTsgfVxuICAgIH1cbiAgICBpZiAoaXNVbmRlZih2bm9kZS50ZXh0KSkge1xuICAgICAgaWYgKGlzRGVmKG9sZENoKSAmJiBpc0RlZihjaCkpIHtcbiAgICAgICAgaWYgKG9sZENoICE9PSBjaCkgeyB1cGRhdGVDaGlsZHJlbihlbG0sIG9sZENoLCBjaCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCByZW1vdmVPbmx5KTsgfVxuICAgICAgfSBlbHNlIGlmIChpc0RlZihjaCkpIHtcbiAgICAgICAgaWYgKGlzRGVmKG9sZFZub2RlLnRleHQpKSB7IG5vZGVPcHMuc2V0VGV4dENvbnRlbnQoZWxtLCAnJyk7IH1cbiAgICAgICAgYWRkVm5vZGVzKGVsbSwgbnVsbCwgY2gsIDAsIGNoLmxlbmd0aCAtIDEsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICB9IGVsc2UgaWYgKGlzRGVmKG9sZENoKSkge1xuICAgICAgICByZW1vdmVWbm9kZXMoZWxtLCBvbGRDaCwgMCwgb2xkQ2gubGVuZ3RoIC0gMSk7XG4gICAgICB9IGVsc2UgaWYgKGlzRGVmKG9sZFZub2RlLnRleHQpKSB7XG4gICAgICAgIG5vZGVPcHMuc2V0VGV4dENvbnRlbnQoZWxtLCAnJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChvbGRWbm9kZS50ZXh0ICE9PSB2bm9kZS50ZXh0KSB7XG4gICAgICBub2RlT3BzLnNldFRleHRDb250ZW50KGVsbSwgdm5vZGUudGV4dCk7XG4gICAgfVxuICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnBvc3RwYXRjaCkpIHsgaShvbGRWbm9kZSwgdm5vZGUpOyB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW52b2tlSW5zZXJ0SG9vayAodm5vZGUsIHF1ZXVlLCBpbml0aWFsKSB7XG4gICAgLy8gZGVsYXkgaW5zZXJ0IGhvb2tzIGZvciBjb21wb25lbnQgcm9vdCBub2RlcywgaW52b2tlIHRoZW0gYWZ0ZXIgdGhlXG4gICAgLy8gZWxlbWVudCBpcyByZWFsbHkgaW5zZXJ0ZWRcbiAgICBpZiAoaXNUcnVlKGluaXRpYWwpICYmIGlzRGVmKHZub2RlLnBhcmVudCkpIHtcbiAgICAgIHZub2RlLnBhcmVudC5kYXRhLnBlbmRpbmdJbnNlcnQgPSBxdWV1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICBxdWV1ZVtpXS5kYXRhLmhvb2suaW5zZXJ0KHF1ZXVlW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgaHlkcmF0aW9uQmFpbGVkID0gZmFsc2U7XG4gIC8vIGxpc3Qgb2YgbW9kdWxlcyB0aGF0IGNhbiBza2lwIGNyZWF0ZSBob29rIGR1cmluZyBoeWRyYXRpb24gYmVjYXVzZSB0aGV5XG4gIC8vIGFyZSBhbHJlYWR5IHJlbmRlcmVkIG9uIHRoZSBjbGllbnQgb3IgaGFzIG5vIG5lZWQgZm9yIGluaXRpYWxpemF0aW9uXG4gIC8vIE5vdGU6IHN0eWxlIGlzIGV4Y2x1ZGVkIGJlY2F1c2UgaXQgcmVsaWVzIG9uIGluaXRpYWwgY2xvbmUgZm9yIGZ1dHVyZVxuICAvLyBkZWVwIHVwZGF0ZXMgKCM3MDYzKS5cbiAgdmFyIGlzUmVuZGVyZWRNb2R1bGUgPSBtYWtlTWFwKCdhdHRycyxjbGFzcyxzdGF0aWNDbGFzcyxzdGF0aWNTdHlsZSxrZXknKTtcblxuICAvLyBOb3RlOiB0aGlzIGlzIGEgYnJvd3Nlci1vbmx5IGZ1bmN0aW9uIHNvIHdlIGNhbiBhc3N1bWUgZWxtcyBhcmUgRE9NIG5vZGVzLlxuICBmdW5jdGlvbiBoeWRyYXRlIChlbG0sIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIGluVlByZSkge1xuICAgIHZhciBpO1xuICAgIHZhciB0YWcgPSB2bm9kZS50YWc7XG4gICAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgIHZhciBjaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuO1xuICAgIGluVlByZSA9IGluVlByZSB8fCAoZGF0YSAmJiBkYXRhLnByZSk7XG4gICAgdm5vZGUuZWxtID0gZWxtO1xuXG4gICAgaWYgKGlzVHJ1ZSh2bm9kZS5pc0NvbW1lbnQpICYmIGlzRGVmKHZub2RlLmFzeW5jRmFjdG9yeSkpIHtcbiAgICAgIHZub2RlLmlzQXN5bmNQbGFjZWhvbGRlciA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICAvLyBhc3NlcnQgbm9kZSBtYXRjaFxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoIWFzc2VydE5vZGVNYXRjaChlbG0sIHZub2RlLCBpblZQcmUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgIGlmIChpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5pbml0KSkgeyBpKHZub2RlLCB0cnVlIC8qIGh5ZHJhdGluZyAqLyk7IH1cbiAgICAgIGlmIChpc0RlZihpID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UpKSB7XG4gICAgICAgIC8vIGNoaWxkIGNvbXBvbmVudC4gaXQgc2hvdWxkIGhhdmUgaHlkcmF0ZWQgaXRzIG93biB0cmVlLlxuICAgICAgICBpbml0Q29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNEZWYodGFnKSkge1xuICAgICAgaWYgKGlzRGVmKGNoaWxkcmVuKSkge1xuICAgICAgICAvLyBlbXB0eSBlbGVtZW50LCBhbGxvdyBjbGllbnQgdG8gcGljayB1cCBhbmQgcG9wdWxhdGUgY2hpbGRyZW5cbiAgICAgICAgaWYgKCFlbG0uaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgICAgICAgY3JlYXRlQ2hpbGRyZW4odm5vZGUsIGNoaWxkcmVuLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHYtaHRtbCBhbmQgZG9tUHJvcHM6IGlubmVySFRNTFxuICAgICAgICAgIGlmIChpc0RlZihpID0gZGF0YSkgJiYgaXNEZWYoaSA9IGkuZG9tUHJvcHMpICYmIGlzRGVmKGkgPSBpLmlubmVySFRNTCkpIHtcbiAgICAgICAgICAgIGlmIChpICE9PSBlbG0uaW5uZXJIVE1MKSB7XG4gICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgICAgICFoeWRyYXRpb25CYWlsZWRcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgaHlkcmF0aW9uQmFpbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1BhcmVudDogJywgZWxtKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ3NlcnZlciBpbm5lckhUTUw6ICcsIGkpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignY2xpZW50IGlubmVySFRNTDogJywgZWxtLmlubmVySFRNTCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGl0ZXJhdGUgYW5kIGNvbXBhcmUgY2hpbGRyZW4gbGlzdHNcbiAgICAgICAgICAgIHZhciBjaGlsZHJlbk1hdGNoID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBjaGlsZE5vZGUgPSBlbG0uZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGNoaWxkcmVuLmxlbmd0aDsgaSQxKyspIHtcbiAgICAgICAgICAgICAgaWYgKCFjaGlsZE5vZGUgfHwgIWh5ZHJhdGUoY2hpbGROb2RlLCBjaGlsZHJlbltpJDFdLCBpbnNlcnRlZFZub2RlUXVldWUsIGluVlByZSkpIHtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbk1hdGNoID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpZiBjaGlsZE5vZGUgaXMgbm90IG51bGwsIGl0IG1lYW5zIHRoZSBhY3R1YWwgY2hpbGROb2RlcyBsaXN0IGlzXG4gICAgICAgICAgICAvLyBsb25nZXIgdGhhbiB0aGUgdmlydHVhbCBjaGlsZHJlbiBsaXN0LlxuICAgICAgICAgICAgaWYgKCFjaGlsZHJlbk1hdGNoIHx8IGNoaWxkTm9kZSkge1xuICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgICAgICAhaHlkcmF0aW9uQmFpbGVkXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGh5ZHJhdGlvbkJhaWxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdQYXJlbnQ6ICcsIGVsbSk7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdNaXNtYXRjaGluZyBjaGlsZE5vZGVzIHZzLiBWTm9kZXM6ICcsIGVsbS5jaGlsZE5vZGVzLCBjaGlsZHJlbik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgICAgdmFyIGZ1bGxJbnZva2UgPSBmYWxzZTtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGRhdGEpIHtcbiAgICAgICAgICBpZiAoIWlzUmVuZGVyZWRNb2R1bGUoa2V5KSkge1xuICAgICAgICAgICAgZnVsbEludm9rZSA9IHRydWU7XG4gICAgICAgICAgICBpbnZva2VDcmVhdGVIb29rcyh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghZnVsbEludm9rZSAmJiBkYXRhWydjbGFzcyddKSB7XG4gICAgICAgICAgLy8gZW5zdXJlIGNvbGxlY3RpbmcgZGVwcyBmb3IgZGVlcCBjbGFzcyBiaW5kaW5ncyBmb3IgZnV0dXJlIHVwZGF0ZXNcbiAgICAgICAgICB0cmF2ZXJzZShkYXRhWydjbGFzcyddKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZWxtLmRhdGEgIT09IHZub2RlLnRleHQpIHtcbiAgICAgIGVsbS5kYXRhID0gdm5vZGUudGV4dDtcbiAgICB9XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGZ1bmN0aW9uIGFzc2VydE5vZGVNYXRjaCAobm9kZSwgdm5vZGUsIGluVlByZSkge1xuICAgIGlmIChpc0RlZih2bm9kZS50YWcpKSB7XG4gICAgICByZXR1cm4gdm5vZGUudGFnLmluZGV4T2YoJ3Z1ZS1jb21wb25lbnQnKSA9PT0gMCB8fCAoXG4gICAgICAgICFpc1Vua25vd25FbGVtZW50JCQxKHZub2RlLCBpblZQcmUpICYmXG4gICAgICAgIHZub2RlLnRhZy50b0xvd2VyQ2FzZSgpID09PSAobm9kZS50YWdOYW1lICYmIG5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpKVxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbm9kZS5ub2RlVHlwZSA9PT0gKHZub2RlLmlzQ29tbWVudCA/IDggOiAzKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiBwYXRjaCAob2xkVm5vZGUsIHZub2RlLCBoeWRyYXRpbmcsIHJlbW92ZU9ubHksIHBhcmVudEVsbSwgcmVmRWxtKSB7XG4gICAgaWYgKGlzVW5kZWYodm5vZGUpKSB7XG4gICAgICBpZiAoaXNEZWYob2xkVm5vZGUpKSB7IGludm9rZURlc3Ryb3lIb29rKG9sZFZub2RlKTsgfVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdmFyIGlzSW5pdGlhbFBhdGNoID0gZmFsc2U7XG4gICAgdmFyIGluc2VydGVkVm5vZGVRdWV1ZSA9IFtdO1xuXG4gICAgaWYgKGlzVW5kZWYob2xkVm5vZGUpKSB7XG4gICAgICAvLyBlbXB0eSBtb3VudCAobGlrZWx5IGFzIGNvbXBvbmVudCksIGNyZWF0ZSBuZXcgcm9vdCBlbGVtZW50XG4gICAgICBpc0luaXRpYWxQYXRjaCA9IHRydWU7XG4gICAgICBjcmVhdGVFbG0odm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaXNSZWFsRWxlbWVudCA9IGlzRGVmKG9sZFZub2RlLm5vZGVUeXBlKTtcbiAgICAgIGlmICghaXNSZWFsRWxlbWVudCAmJiBzYW1lVm5vZGUob2xkVm5vZGUsIHZub2RlKSkge1xuICAgICAgICAvLyBwYXRjaCBleGlzdGluZyByb290IG5vZGVcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRWbm9kZSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXNSZWFsRWxlbWVudCkge1xuICAgICAgICAgIC8vIG1vdW50aW5nIHRvIGEgcmVhbCBlbGVtZW50XG4gICAgICAgICAgLy8gY2hlY2sgaWYgdGhpcyBpcyBzZXJ2ZXItcmVuZGVyZWQgY29udGVudCBhbmQgaWYgd2UgY2FuIHBlcmZvcm1cbiAgICAgICAgICAvLyBhIHN1Y2Nlc3NmdWwgaHlkcmF0aW9uLlxuICAgICAgICAgIGlmIChvbGRWbm9kZS5ub2RlVHlwZSA9PT0gMSAmJiBvbGRWbm9kZS5oYXNBdHRyaWJ1dGUoU1NSX0FUVFIpKSB7XG4gICAgICAgICAgICBvbGRWbm9kZS5yZW1vdmVBdHRyaWJ1dGUoU1NSX0FUVFIpO1xuICAgICAgICAgICAgaHlkcmF0aW5nID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzVHJ1ZShoeWRyYXRpbmcpKSB7XG4gICAgICAgICAgICBpZiAoaHlkcmF0ZShvbGRWbm9kZSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSkpIHtcbiAgICAgICAgICAgICAgaW52b2tlSW5zZXJ0SG9vayh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCB0cnVlKTtcbiAgICAgICAgICAgICAgcmV0dXJuIG9sZFZub2RlXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgICAnVGhlIGNsaWVudC1zaWRlIHJlbmRlcmVkIHZpcnR1YWwgRE9NIHRyZWUgaXMgbm90IG1hdGNoaW5nICcgK1xuICAgICAgICAgICAgICAgICdzZXJ2ZXItcmVuZGVyZWQgY29udGVudC4gVGhpcyBpcyBsaWtlbHkgY2F1c2VkIGJ5IGluY29ycmVjdCAnICtcbiAgICAgICAgICAgICAgICAnSFRNTCBtYXJrdXAsIGZvciBleGFtcGxlIG5lc3RpbmcgYmxvY2stbGV2ZWwgZWxlbWVudHMgaW5zaWRlICcgK1xuICAgICAgICAgICAgICAgICc8cD4sIG9yIG1pc3NpbmcgPHRib2R5Pi4gQmFpbGluZyBoeWRyYXRpb24gYW5kIHBlcmZvcm1pbmcgJyArXG4gICAgICAgICAgICAgICAgJ2Z1bGwgY2xpZW50LXNpZGUgcmVuZGVyLidcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gZWl0aGVyIG5vdCBzZXJ2ZXItcmVuZGVyZWQsIG9yIGh5ZHJhdGlvbiBmYWlsZWQuXG4gICAgICAgICAgLy8gY3JlYXRlIGFuIGVtcHR5IG5vZGUgYW5kIHJlcGxhY2UgaXRcbiAgICAgICAgICBvbGRWbm9kZSA9IGVtcHR5Tm9kZUF0KG9sZFZub2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlcGxhY2luZyBleGlzdGluZyBlbGVtZW50XG4gICAgICAgIHZhciBvbGRFbG0gPSBvbGRWbm9kZS5lbG07XG4gICAgICAgIHZhciBwYXJlbnRFbG0kMSA9IG5vZGVPcHMucGFyZW50Tm9kZShvbGRFbG0pO1xuXG4gICAgICAgIC8vIGNyZWF0ZSBuZXcgbm9kZVxuICAgICAgICBjcmVhdGVFbG0oXG4gICAgICAgICAgdm5vZGUsXG4gICAgICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLFxuICAgICAgICAgIC8vIGV4dHJlbWVseSByYXJlIGVkZ2UgY2FzZTogZG8gbm90IGluc2VydCBpZiBvbGQgZWxlbWVudCBpcyBpbiBhXG4gICAgICAgICAgLy8gbGVhdmluZyB0cmFuc2l0aW9uLiBPbmx5IGhhcHBlbnMgd2hlbiBjb21iaW5pbmcgdHJhbnNpdGlvbiArXG4gICAgICAgICAgLy8ga2VlcC1hbGl2ZSArIEhPQ3MuICgjNDU5MClcbiAgICAgICAgICBvbGRFbG0uX2xlYXZlQ2IgPyBudWxsIDogcGFyZW50RWxtJDEsXG4gICAgICAgICAgbm9kZU9wcy5uZXh0U2libGluZyhvbGRFbG0pXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gdXBkYXRlIHBhcmVudCBwbGFjZWhvbGRlciBub2RlIGVsZW1lbnQsIHJlY3Vyc2l2ZWx5XG4gICAgICAgIGlmIChpc0RlZih2bm9kZS5wYXJlbnQpKSB7XG4gICAgICAgICAgdmFyIGFuY2VzdG9yID0gdm5vZGUucGFyZW50O1xuICAgICAgICAgIHZhciBwYXRjaGFibGUgPSBpc1BhdGNoYWJsZSh2bm9kZSk7XG4gICAgICAgICAgd2hpbGUgKGFuY2VzdG9yKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNicy5kZXN0cm95Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgIGNicy5kZXN0cm95W2ldKGFuY2VzdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFuY2VzdG9yLmVsbSA9IHZub2RlLmVsbTtcbiAgICAgICAgICAgIGlmIChwYXRjaGFibGUpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgY2JzLmNyZWF0ZS5sZW5ndGg7ICsraSQxKSB7XG4gICAgICAgICAgICAgICAgY2JzLmNyZWF0ZVtpJDFdKGVtcHR5Tm9kZSwgYW5jZXN0b3IpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vICM2NTEzXG4gICAgICAgICAgICAgIC8vIGludm9rZSBpbnNlcnQgaG9va3MgdGhhdCBtYXkgaGF2ZSBiZWVuIG1lcmdlZCBieSBjcmVhdGUgaG9va3MuXG4gICAgICAgICAgICAgIC8vIGUuZy4gZm9yIGRpcmVjdGl2ZXMgdGhhdCB1c2VzIHRoZSBcImluc2VydGVkXCIgaG9vay5cbiAgICAgICAgICAgICAgdmFyIGluc2VydCA9IGFuY2VzdG9yLmRhdGEuaG9vay5pbnNlcnQ7XG4gICAgICAgICAgICAgIGlmIChpbnNlcnQubWVyZ2VkKSB7XG4gICAgICAgICAgICAgICAgLy8gc3RhcnQgYXQgaW5kZXggMSB0byBhdm9pZCByZS1pbnZva2luZyBjb21wb25lbnQgbW91bnRlZCBob29rXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSQyID0gMTsgaSQyIDwgaW5zZXJ0LmZucy5sZW5ndGg7IGkkMisrKSB7XG4gICAgICAgICAgICAgICAgICBpbnNlcnQuZm5zW2kkMl0oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlZ2lzdGVyUmVmKGFuY2VzdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFuY2VzdG9yID0gYW5jZXN0b3IucGFyZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGRlc3Ryb3kgb2xkIG5vZGVcbiAgICAgICAgaWYgKGlzRGVmKHBhcmVudEVsbSQxKSkge1xuICAgICAgICAgIHJlbW92ZVZub2RlcyhwYXJlbnRFbG0kMSwgW29sZFZub2RlXSwgMCwgMCk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNEZWYob2xkVm5vZGUudGFnKSkge1xuICAgICAgICAgIGludm9rZURlc3Ryb3lIb29rKG9sZFZub2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGludm9rZUluc2VydEhvb2sodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgaXNJbml0aWFsUGF0Y2gpO1xuICAgIHJldHVybiB2bm9kZS5lbG1cbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIGRpcmVjdGl2ZXMgPSB7XG4gIGNyZWF0ZTogdXBkYXRlRGlyZWN0aXZlcyxcbiAgdXBkYXRlOiB1cGRhdGVEaXJlY3RpdmVzLFxuICBkZXN0cm95OiBmdW5jdGlvbiB1bmJpbmREaXJlY3RpdmVzICh2bm9kZSkge1xuICAgIHVwZGF0ZURpcmVjdGl2ZXModm5vZGUsIGVtcHR5Tm9kZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlRGlyZWN0aXZlcyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIGlmIChvbGRWbm9kZS5kYXRhLmRpcmVjdGl2ZXMgfHwgdm5vZGUuZGF0YS5kaXJlY3RpdmVzKSB7XG4gICAgX3VwZGF0ZShvbGRWbm9kZSwgdm5vZGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF91cGRhdGUgKG9sZFZub2RlLCB2bm9kZSkge1xuICB2YXIgaXNDcmVhdGUgPSBvbGRWbm9kZSA9PT0gZW1wdHlOb2RlO1xuICB2YXIgaXNEZXN0cm95ID0gdm5vZGUgPT09IGVtcHR5Tm9kZTtcbiAgdmFyIG9sZERpcnMgPSBub3JtYWxpemVEaXJlY3RpdmVzJDEob2xkVm5vZGUuZGF0YS5kaXJlY3RpdmVzLCBvbGRWbm9kZS5jb250ZXh0KTtcbiAgdmFyIG5ld0RpcnMgPSBub3JtYWxpemVEaXJlY3RpdmVzJDEodm5vZGUuZGF0YS5kaXJlY3RpdmVzLCB2bm9kZS5jb250ZXh0KTtcblxuICB2YXIgZGlyc1dpdGhJbnNlcnQgPSBbXTtcbiAgdmFyIGRpcnNXaXRoUG9zdHBhdGNoID0gW107XG5cbiAgdmFyIGtleSwgb2xkRGlyLCBkaXI7XG4gIGZvciAoa2V5IGluIG5ld0RpcnMpIHtcbiAgICBvbGREaXIgPSBvbGREaXJzW2tleV07XG4gICAgZGlyID0gbmV3RGlyc1trZXldO1xuICAgIGlmICghb2xkRGlyKSB7XG4gICAgICAvLyBuZXcgZGlyZWN0aXZlLCBiaW5kXG4gICAgICBjYWxsSG9vayQxKGRpciwgJ2JpbmQnLCB2bm9kZSwgb2xkVm5vZGUpO1xuICAgICAgaWYgKGRpci5kZWYgJiYgZGlyLmRlZi5pbnNlcnRlZCkge1xuICAgICAgICBkaXJzV2l0aEluc2VydC5wdXNoKGRpcik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGV4aXN0aW5nIGRpcmVjdGl2ZSwgdXBkYXRlXG4gICAgICBkaXIub2xkVmFsdWUgPSBvbGREaXIudmFsdWU7XG4gICAgICBjYWxsSG9vayQxKGRpciwgJ3VwZGF0ZScsIHZub2RlLCBvbGRWbm9kZSk7XG4gICAgICBpZiAoZGlyLmRlZiAmJiBkaXIuZGVmLmNvbXBvbmVudFVwZGF0ZWQpIHtcbiAgICAgICAgZGlyc1dpdGhQb3N0cGF0Y2gucHVzaChkaXIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChkaXJzV2l0aEluc2VydC5sZW5ndGgpIHtcbiAgICB2YXIgY2FsbEluc2VydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlyc1dpdGhJbnNlcnQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2FsbEhvb2skMShkaXJzV2l0aEluc2VydFtpXSwgJ2luc2VydGVkJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGlmIChpc0NyZWF0ZSkge1xuICAgICAgbWVyZ2VWTm9kZUhvb2sodm5vZGUsICdpbnNlcnQnLCBjYWxsSW5zZXJ0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FsbEluc2VydCgpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChkaXJzV2l0aFBvc3RwYXRjaC5sZW5ndGgpIHtcbiAgICBtZXJnZVZOb2RlSG9vayh2bm9kZSwgJ3Bvc3RwYXRjaCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlyc1dpdGhQb3N0cGF0Y2gubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2FsbEhvb2skMShkaXJzV2l0aFBvc3RwYXRjaFtpXSwgJ2NvbXBvbmVudFVwZGF0ZWQnLCB2bm9kZSwgb2xkVm5vZGUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgaWYgKCFpc0NyZWF0ZSkge1xuICAgIGZvciAoa2V5IGluIG9sZERpcnMpIHtcbiAgICAgIGlmICghbmV3RGlyc1trZXldKSB7XG4gICAgICAgIC8vIG5vIGxvbmdlciBwcmVzZW50LCB1bmJpbmRcbiAgICAgICAgY2FsbEhvb2skMShvbGREaXJzW2tleV0sICd1bmJpbmQnLCBvbGRWbm9kZSwgb2xkVm5vZGUsIGlzRGVzdHJveSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciBlbXB0eU1vZGlmaWVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZURpcmVjdGl2ZXMkMSAoXG4gIGRpcnMsXG4gIHZtXG4pIHtcbiAgdmFyIHJlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGlmICghZGlycykge1xuICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgIHJldHVybiByZXNcbiAgfVxuICB2YXIgaSwgZGlyO1xuICBmb3IgKGkgPSAwOyBpIDwgZGlycy5sZW5ndGg7IGkrKykge1xuICAgIGRpciA9IGRpcnNbaV07XG4gICAgaWYgKCFkaXIubW9kaWZpZXJzKSB7XG4gICAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICAgIGRpci5tb2RpZmllcnMgPSBlbXB0eU1vZGlmaWVycztcbiAgICB9XG4gICAgcmVzW2dldFJhd0Rpck5hbWUoZGlyKV0gPSBkaXI7XG4gICAgZGlyLmRlZiA9IHJlc29sdmVBc3NldCh2bS4kb3B0aW9ucywgJ2RpcmVjdGl2ZXMnLCBkaXIubmFtZSwgdHJ1ZSk7XG4gIH1cbiAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gZ2V0UmF3RGlyTmFtZSAoZGlyKSB7XG4gIHJldHVybiBkaXIucmF3TmFtZSB8fCAoKGRpci5uYW1lKSArIFwiLlwiICsgKE9iamVjdC5rZXlzKGRpci5tb2RpZmllcnMgfHwge30pLmpvaW4oJy4nKSkpXG59XG5cbmZ1bmN0aW9uIGNhbGxIb29rJDEgKGRpciwgaG9vaywgdm5vZGUsIG9sZFZub2RlLCBpc0Rlc3Ryb3kpIHtcbiAgdmFyIGZuID0gZGlyLmRlZiAmJiBkaXIuZGVmW2hvb2tdO1xuICBpZiAoZm4pIHtcbiAgICB0cnkge1xuICAgICAgZm4odm5vZGUuZWxtLCBkaXIsIHZub2RlLCBvbGRWbm9kZSwgaXNEZXN0cm95KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBoYW5kbGVFcnJvcihlLCB2bm9kZS5jb250ZXh0LCAoXCJkaXJlY3RpdmUgXCIgKyAoZGlyLm5hbWUpICsgXCIgXCIgKyBob29rICsgXCIgaG9va1wiKSk7XG4gICAgfVxuICB9XG59XG5cbnZhciBiYXNlTW9kdWxlcyA9IFtcbiAgcmVmLFxuICBkaXJlY3RpdmVzXG5dXG5cbi8qICAqL1xuXG5mdW5jdGlvbiB1cGRhdGVBdHRycyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIHZhciBvcHRzID0gdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgaWYgKGlzRGVmKG9wdHMpICYmIG9wdHMuQ3Rvci5vcHRpb25zLmluaGVyaXRBdHRycyA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAoaXNVbmRlZihvbGRWbm9kZS5kYXRhLmF0dHJzKSAmJiBpc1VuZGVmKHZub2RlLmRhdGEuYXR0cnMpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIGtleSwgY3VyLCBvbGQ7XG4gIHZhciBlbG0gPSB2bm9kZS5lbG07XG4gIHZhciBvbGRBdHRycyA9IG9sZFZub2RlLmRhdGEuYXR0cnMgfHwge307XG4gIHZhciBhdHRycyA9IHZub2RlLmRhdGEuYXR0cnMgfHwge307XG4gIC8vIGNsb25lIG9ic2VydmVkIG9iamVjdHMsIGFzIHRoZSB1c2VyIHByb2JhYmx5IHdhbnRzIHRvIG11dGF0ZSBpdFxuICBpZiAoaXNEZWYoYXR0cnMuX19vYl9fKSkge1xuICAgIGF0dHJzID0gdm5vZGUuZGF0YS5hdHRycyA9IGV4dGVuZCh7fSwgYXR0cnMpO1xuICB9XG5cbiAgZm9yIChrZXkgaW4gYXR0cnMpIHtcbiAgICBjdXIgPSBhdHRyc1trZXldO1xuICAgIG9sZCA9IG9sZEF0dHJzW2tleV07XG4gICAgaWYgKG9sZCAhPT0gY3VyKSB7XG4gICAgICBzZXRBdHRyKGVsbSwga2V5LCBjdXIpO1xuICAgIH1cbiAgfVxuICAvLyAjNDM5MTogaW4gSUU5LCBzZXR0aW5nIHR5cGUgY2FuIHJlc2V0IHZhbHVlIGZvciBpbnB1dFt0eXBlPXJhZGlvXVxuICAvLyAjNjY2NjogSUUvRWRnZSBmb3JjZXMgcHJvZ3Jlc3MgdmFsdWUgZG93biB0byAxIGJlZm9yZSBzZXR0aW5nIGEgbWF4XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoKGlzSUUgfHwgaXNFZGdlKSAmJiBhdHRycy52YWx1ZSAhPT0gb2xkQXR0cnMudmFsdWUpIHtcbiAgICBzZXRBdHRyKGVsbSwgJ3ZhbHVlJywgYXR0cnMudmFsdWUpO1xuICB9XG4gIGZvciAoa2V5IGluIG9sZEF0dHJzKSB7XG4gICAgaWYgKGlzVW5kZWYoYXR0cnNba2V5XSkpIHtcbiAgICAgIGlmIChpc1hsaW5rKGtleSkpIHtcbiAgICAgICAgZWxtLnJlbW92ZUF0dHJpYnV0ZU5TKHhsaW5rTlMsIGdldFhsaW5rUHJvcChrZXkpKTtcbiAgICAgIH0gZWxzZSBpZiAoIWlzRW51bWVyYXRlZEF0dHIoa2V5KSkge1xuICAgICAgICBlbG0ucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHNldEF0dHIgKGVsLCBrZXksIHZhbHVlKSB7XG4gIGlmIChlbC50YWdOYW1lLmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgYmFzZVNldEF0dHIoZWwsIGtleSwgdmFsdWUpO1xuICB9IGVsc2UgaWYgKGlzQm9vbGVhbkF0dHIoa2V5KSkge1xuICAgIC8vIHNldCBhdHRyaWJ1dGUgZm9yIGJsYW5rIHZhbHVlXG4gICAgLy8gZS5nLiA8b3B0aW9uIGRpc2FibGVkPlNlbGVjdCBvbmU8L29wdGlvbj5cbiAgICBpZiAoaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB0ZWNobmljYWxseSBhbGxvd2Z1bGxzY3JlZW4gaXMgYSBib29sZWFuIGF0dHJpYnV0ZSBmb3IgPGlmcmFtZT4sXG4gICAgICAvLyBidXQgRmxhc2ggZXhwZWN0cyBhIHZhbHVlIG9mIFwidHJ1ZVwiIHdoZW4gdXNlZCBvbiA8ZW1iZWQ+IHRhZ1xuICAgICAgdmFsdWUgPSBrZXkgPT09ICdhbGxvd2Z1bGxzY3JlZW4nICYmIGVsLnRhZ05hbWUgPT09ICdFTUJFRCdcbiAgICAgICAgPyAndHJ1ZSdcbiAgICAgICAgOiBrZXk7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzRW51bWVyYXRlZEF0dHIoa2V5KSkge1xuICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpIHx8IHZhbHVlID09PSAnZmFsc2UnID8gJ2ZhbHNlJyA6ICd0cnVlJyk7XG4gIH0gZWxzZSBpZiAoaXNYbGluayhrZXkpKSB7XG4gICAgaWYgKGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGVOUyh4bGlua05TLCBnZXRYbGlua1Byb3Aoa2V5KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZU5TKHhsaW5rTlMsIGtleSwgdmFsdWUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBiYXNlU2V0QXR0cihlbCwga2V5LCB2YWx1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYmFzZVNldEF0dHIgKGVsLCBrZXksIHZhbHVlKSB7XG4gIGlmIChpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSkge1xuICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICB9IGVsc2Uge1xuICAgIC8vICM3MTM4OiBJRTEwICYgMTEgZmlyZXMgaW5wdXQgZXZlbnQgd2hlbiBzZXR0aW5nIHBsYWNlaG9sZGVyIG9uXG4gICAgLy8gPHRleHRhcmVhPi4uLiBibG9jayB0aGUgZmlyc3QgaW5wdXQgZXZlbnQgYW5kIHJlbW92ZSB0aGUgYmxvY2tlclxuICAgIC8vIGltbWVkaWF0ZWx5LlxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChcbiAgICAgIGlzSUUgJiYgIWlzSUU5ICYmXG4gICAgICBlbC50YWdOYW1lID09PSAnVEVYVEFSRUEnICYmXG4gICAgICBrZXkgPT09ICdwbGFjZWhvbGRlcicgJiYgIWVsLl9faWVwaFxuICAgICkge1xuICAgICAgdmFyIGJsb2NrZXIgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKCdpbnB1dCcsIGJsb2NrZXIpO1xuICAgICAgfTtcbiAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgYmxvY2tlcik7XG4gICAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICAgIGVsLl9faWVwaCA9IHRydWU7IC8qIElFIHBsYWNlaG9sZGVyIHBhdGNoZWQgKi9cbiAgICB9XG4gICAgZWwuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICB9XG59XG5cbnZhciBhdHRycyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVBdHRycyxcbiAgdXBkYXRlOiB1cGRhdGVBdHRyc1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gdXBkYXRlQ2xhc3MgKG9sZFZub2RlLCB2bm9kZSkge1xuICB2YXIgZWwgPSB2bm9kZS5lbG07XG4gIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgdmFyIG9sZERhdGEgPSBvbGRWbm9kZS5kYXRhO1xuICBpZiAoXG4gICAgaXNVbmRlZihkYXRhLnN0YXRpY0NsYXNzKSAmJlxuICAgIGlzVW5kZWYoZGF0YS5jbGFzcykgJiYgKFxuICAgICAgaXNVbmRlZihvbGREYXRhKSB8fCAoXG4gICAgICAgIGlzVW5kZWYob2xkRGF0YS5zdGF0aWNDbGFzcykgJiZcbiAgICAgICAgaXNVbmRlZihvbGREYXRhLmNsYXNzKVxuICAgICAgKVxuICAgIClcbiAgKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgY2xzID0gZ2VuQ2xhc3NGb3JWbm9kZSh2bm9kZSk7XG5cbiAgLy8gaGFuZGxlIHRyYW5zaXRpb24gY2xhc3Nlc1xuICB2YXIgdHJhbnNpdGlvbkNsYXNzID0gZWwuX3RyYW5zaXRpb25DbGFzc2VzO1xuICBpZiAoaXNEZWYodHJhbnNpdGlvbkNsYXNzKSkge1xuICAgIGNscyA9IGNvbmNhdChjbHMsIHN0cmluZ2lmeUNsYXNzKHRyYW5zaXRpb25DbGFzcykpO1xuICB9XG5cbiAgLy8gc2V0IHRoZSBjbGFzc1xuICBpZiAoY2xzICE9PSBlbC5fcHJldkNsYXNzKSB7XG4gICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIGNscyk7XG4gICAgZWwuX3ByZXZDbGFzcyA9IGNscztcbiAgfVxufVxuXG52YXIga2xhc3MgPSB7XG4gIGNyZWF0ZTogdXBkYXRlQ2xhc3MsXG4gIHVwZGF0ZTogdXBkYXRlQ2xhc3Ncbn1cblxuLyogICovXG5cbnZhciB2YWxpZERpdmlzaW9uQ2hhclJFID0gL1tcXHcpLitcXC1fJFxcXV0vO1xuXG5mdW5jdGlvbiBwYXJzZUZpbHRlcnMgKGV4cCkge1xuICB2YXIgaW5TaW5nbGUgPSBmYWxzZTtcbiAgdmFyIGluRG91YmxlID0gZmFsc2U7XG4gIHZhciBpblRlbXBsYXRlU3RyaW5nID0gZmFsc2U7XG4gIHZhciBpblJlZ2V4ID0gZmFsc2U7XG4gIHZhciBjdXJseSA9IDA7XG4gIHZhciBzcXVhcmUgPSAwO1xuICB2YXIgcGFyZW4gPSAwO1xuICB2YXIgbGFzdEZpbHRlckluZGV4ID0gMDtcbiAgdmFyIGMsIHByZXYsIGksIGV4cHJlc3Npb24sIGZpbHRlcnM7XG5cbiAgZm9yIChpID0gMDsgaSA8IGV4cC5sZW5ndGg7IGkrKykge1xuICAgIHByZXYgPSBjO1xuICAgIGMgPSBleHAuY2hhckNvZGVBdChpKTtcbiAgICBpZiAoaW5TaW5nbGUpIHtcbiAgICAgIGlmIChjID09PSAweDI3ICYmIHByZXYgIT09IDB4NUMpIHsgaW5TaW5nbGUgPSBmYWxzZTsgfVxuICAgIH0gZWxzZSBpZiAoaW5Eb3VibGUpIHtcbiAgICAgIGlmIChjID09PSAweDIyICYmIHByZXYgIT09IDB4NUMpIHsgaW5Eb3VibGUgPSBmYWxzZTsgfVxuICAgIH0gZWxzZSBpZiAoaW5UZW1wbGF0ZVN0cmluZykge1xuICAgICAgaWYgKGMgPT09IDB4NjAgJiYgcHJldiAhPT0gMHg1QykgeyBpblRlbXBsYXRlU3RyaW5nID0gZmFsc2U7IH1cbiAgICB9IGVsc2UgaWYgKGluUmVnZXgpIHtcbiAgICAgIGlmIChjID09PSAweDJmICYmIHByZXYgIT09IDB4NUMpIHsgaW5SZWdleCA9IGZhbHNlOyB9XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIGMgPT09IDB4N0MgJiYgLy8gcGlwZVxuICAgICAgZXhwLmNoYXJDb2RlQXQoaSArIDEpICE9PSAweDdDICYmXG4gICAgICBleHAuY2hhckNvZGVBdChpIC0gMSkgIT09IDB4N0MgJiZcbiAgICAgICFjdXJseSAmJiAhc3F1YXJlICYmICFwYXJlblxuICAgICkge1xuICAgICAgaWYgKGV4cHJlc3Npb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBmaXJzdCBmaWx0ZXIsIGVuZCBvZiBleHByZXNzaW9uXG4gICAgICAgIGxhc3RGaWx0ZXJJbmRleCA9IGkgKyAxO1xuICAgICAgICBleHByZXNzaW9uID0gZXhwLnNsaWNlKDAsIGkpLnRyaW0oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHB1c2hGaWx0ZXIoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3dpdGNoIChjKSB7XG4gICAgICAgIGNhc2UgMHgyMjogaW5Eb3VibGUgPSB0cnVlOyBicmVhayAgICAgICAgIC8vIFwiXG4gICAgICAgIGNhc2UgMHgyNzogaW5TaW5nbGUgPSB0cnVlOyBicmVhayAgICAgICAgIC8vICdcbiAgICAgICAgY2FzZSAweDYwOiBpblRlbXBsYXRlU3RyaW5nID0gdHJ1ZTsgYnJlYWsgLy8gYFxuICAgICAgICBjYXNlIDB4Mjg6IHBhcmVuKys7IGJyZWFrICAgICAgICAgICAgICAgICAvLyAoXG4gICAgICAgIGNhc2UgMHgyOTogcGFyZW4tLTsgYnJlYWsgICAgICAgICAgICAgICAgIC8vIClcbiAgICAgICAgY2FzZSAweDVCOiBzcXVhcmUrKzsgYnJlYWsgICAgICAgICAgICAgICAgLy8gW1xuICAgICAgICBjYXNlIDB4NUQ6IHNxdWFyZS0tOyBicmVhayAgICAgICAgICAgICAgICAvLyBdXG4gICAgICAgIGNhc2UgMHg3QjogY3VybHkrKzsgYnJlYWsgICAgICAgICAgICAgICAgIC8vIHtcbiAgICAgICAgY2FzZSAweDdEOiBjdXJseS0tOyBicmVhayAgICAgICAgICAgICAgICAgLy8gfVxuICAgICAgfVxuICAgICAgaWYgKGMgPT09IDB4MmYpIHsgLy8gL1xuICAgICAgICB2YXIgaiA9IGkgLSAxO1xuICAgICAgICB2YXIgcCA9ICh2b2lkIDApO1xuICAgICAgICAvLyBmaW5kIGZpcnN0IG5vbi13aGl0ZXNwYWNlIHByZXYgY2hhclxuICAgICAgICBmb3IgKDsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgICBwID0gZXhwLmNoYXJBdChqKTtcbiAgICAgICAgICBpZiAocCAhPT0gJyAnKSB7IGJyZWFrIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXAgfHwgIXZhbGlkRGl2aXNpb25DaGFyUkUudGVzdChwKSkge1xuICAgICAgICAgIGluUmVnZXggPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGV4cHJlc3Npb24gPT09IHVuZGVmaW5lZCkge1xuICAgIGV4cHJlc3Npb24gPSBleHAuc2xpY2UoMCwgaSkudHJpbSgpO1xuICB9IGVsc2UgaWYgKGxhc3RGaWx0ZXJJbmRleCAhPT0gMCkge1xuICAgIHB1c2hGaWx0ZXIoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHB1c2hGaWx0ZXIgKCkge1xuICAgIChmaWx0ZXJzIHx8IChmaWx0ZXJzID0gW10pKS5wdXNoKGV4cC5zbGljZShsYXN0RmlsdGVySW5kZXgsIGkpLnRyaW0oKSk7XG4gICAgbGFzdEZpbHRlckluZGV4ID0gaSArIDE7XG4gIH1cblxuICBpZiAoZmlsdGVycykge1xuICAgIGZvciAoaSA9IDA7IGkgPCBmaWx0ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBleHByZXNzaW9uID0gd3JhcEZpbHRlcihleHByZXNzaW9uLCBmaWx0ZXJzW2ldKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZXhwcmVzc2lvblxufVxuXG5mdW5jdGlvbiB3cmFwRmlsdGVyIChleHAsIGZpbHRlcikge1xuICB2YXIgaSA9IGZpbHRlci5pbmRleE9mKCcoJyk7XG4gIGlmIChpIDwgMCkge1xuICAgIC8vIF9mOiByZXNvbHZlRmlsdGVyXG4gICAgcmV0dXJuIChcIl9mKFxcXCJcIiArIGZpbHRlciArIFwiXFxcIikoXCIgKyBleHAgKyBcIilcIilcbiAgfSBlbHNlIHtcbiAgICB2YXIgbmFtZSA9IGZpbHRlci5zbGljZSgwLCBpKTtcbiAgICB2YXIgYXJncyA9IGZpbHRlci5zbGljZShpICsgMSk7XG4gICAgcmV0dXJuIChcIl9mKFxcXCJcIiArIG5hbWUgKyBcIlxcXCIpKFwiICsgZXhwICsgKGFyZ3MgIT09ICcpJyA/ICcsJyArIGFyZ3MgOiBhcmdzKSlcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gYmFzZVdhcm4gKG1zZykge1xuICBjb25zb2xlLmVycm9yKChcIltWdWUgY29tcGlsZXJdOiBcIiArIG1zZykpO1xufVxuXG5mdW5jdGlvbiBwbHVja01vZHVsZUZ1bmN0aW9uIChcbiAgbW9kdWxlcyxcbiAga2V5XG4pIHtcbiAgcmV0dXJuIG1vZHVsZXNcbiAgICA/IG1vZHVsZXMubWFwKGZ1bmN0aW9uIChtKSB7IHJldHVybiBtW2tleV07IH0pLmZpbHRlcihmdW5jdGlvbiAoXykgeyByZXR1cm4gXzsgfSlcbiAgICA6IFtdXG59XG5cbmZ1bmN0aW9uIGFkZFByb3AgKGVsLCBuYW1lLCB2YWx1ZSkge1xuICAoZWwucHJvcHMgfHwgKGVsLnByb3BzID0gW10pKS5wdXNoKHsgbmFtZTogbmFtZSwgdmFsdWU6IHZhbHVlIH0pO1xuICBlbC5wbGFpbiA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBhZGRBdHRyIChlbCwgbmFtZSwgdmFsdWUpIHtcbiAgKGVsLmF0dHJzIHx8IChlbC5hdHRycyA9IFtdKSkucHVzaCh7IG5hbWU6IG5hbWUsIHZhbHVlOiB2YWx1ZSB9KTtcbiAgZWwucGxhaW4gPSBmYWxzZTtcbn1cblxuLy8gYWRkIGEgcmF3IGF0dHIgKHVzZSB0aGlzIGluIHByZVRyYW5zZm9ybXMpXG5mdW5jdGlvbiBhZGRSYXdBdHRyIChlbCwgbmFtZSwgdmFsdWUpIHtcbiAgZWwuYXR0cnNNYXBbbmFtZV0gPSB2YWx1ZTtcbiAgZWwuYXR0cnNMaXN0LnB1c2goeyBuYW1lOiBuYW1lLCB2YWx1ZTogdmFsdWUgfSk7XG59XG5cbmZ1bmN0aW9uIGFkZERpcmVjdGl2ZSAoXG4gIGVsLFxuICBuYW1lLFxuICByYXdOYW1lLFxuICB2YWx1ZSxcbiAgYXJnLFxuICBtb2RpZmllcnNcbikge1xuICAoZWwuZGlyZWN0aXZlcyB8fCAoZWwuZGlyZWN0aXZlcyA9IFtdKSkucHVzaCh7IG5hbWU6IG5hbWUsIHJhd05hbWU6IHJhd05hbWUsIHZhbHVlOiB2YWx1ZSwgYXJnOiBhcmcsIG1vZGlmaWVyczogbW9kaWZpZXJzIH0pO1xuICBlbC5wbGFpbiA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBhZGRIYW5kbGVyIChcbiAgZWwsXG4gIG5hbWUsXG4gIHZhbHVlLFxuICBtb2RpZmllcnMsXG4gIGltcG9ydGFudCxcbiAgd2FyblxuKSB7XG4gIG1vZGlmaWVycyA9IG1vZGlmaWVycyB8fCBlbXB0eU9iamVjdDtcbiAgLy8gd2FybiBwcmV2ZW50IGFuZCBwYXNzaXZlIG1vZGlmaWVyXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoXG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuICYmXG4gICAgbW9kaWZpZXJzLnByZXZlbnQgJiYgbW9kaWZpZXJzLnBhc3NpdmVcbiAgKSB7XG4gICAgd2FybihcbiAgICAgICdwYXNzaXZlIGFuZCBwcmV2ZW50IGNhblxcJ3QgYmUgdXNlZCB0b2dldGhlci4gJyArXG4gICAgICAnUGFzc2l2ZSBoYW5kbGVyIGNhblxcJ3QgcHJldmVudCBkZWZhdWx0IGV2ZW50LidcbiAgICApO1xuICB9XG5cbiAgLy8gY2hlY2sgY2FwdHVyZSBtb2RpZmllclxuICBpZiAobW9kaWZpZXJzLmNhcHR1cmUpIHtcbiAgICBkZWxldGUgbW9kaWZpZXJzLmNhcHR1cmU7XG4gICAgbmFtZSA9ICchJyArIG5hbWU7IC8vIG1hcmsgdGhlIGV2ZW50IGFzIGNhcHR1cmVkXG4gIH1cbiAgaWYgKG1vZGlmaWVycy5vbmNlKSB7XG4gICAgZGVsZXRlIG1vZGlmaWVycy5vbmNlO1xuICAgIG5hbWUgPSAnficgKyBuYW1lOyAvLyBtYXJrIHRoZSBldmVudCBhcyBvbmNlXG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChtb2RpZmllcnMucGFzc2l2ZSkge1xuICAgIGRlbGV0ZSBtb2RpZmllcnMucGFzc2l2ZTtcbiAgICBuYW1lID0gJyYnICsgbmFtZTsgLy8gbWFyayB0aGUgZXZlbnQgYXMgcGFzc2l2ZVxuICB9XG5cbiAgLy8gbm9ybWFsaXplIGNsaWNrLnJpZ2h0IGFuZCBjbGljay5taWRkbGUgc2luY2UgdGhleSBkb24ndCBhY3R1YWxseSBmaXJlXG4gIC8vIHRoaXMgaXMgdGVjaG5pY2FsbHkgYnJvd3Nlci1zcGVjaWZpYywgYnV0IGF0IGxlYXN0IGZvciBub3cgYnJvd3NlcnMgYXJlXG4gIC8vIHRoZSBvbmx5IHRhcmdldCBlbnZzIHRoYXQgaGF2ZSByaWdodC9taWRkbGUgY2xpY2tzLlxuICBpZiAobmFtZSA9PT0gJ2NsaWNrJykge1xuICAgIGlmIChtb2RpZmllcnMucmlnaHQpIHtcbiAgICAgIG5hbWUgPSAnY29udGV4dG1lbnUnO1xuICAgICAgZGVsZXRlIG1vZGlmaWVycy5yaWdodDtcbiAgICB9IGVsc2UgaWYgKG1vZGlmaWVycy5taWRkbGUpIHtcbiAgICAgIG5hbWUgPSAnbW91c2V1cCc7XG4gICAgfVxuICB9XG5cbiAgdmFyIGV2ZW50cztcbiAgaWYgKG1vZGlmaWVycy5uYXRpdmUpIHtcbiAgICBkZWxldGUgbW9kaWZpZXJzLm5hdGl2ZTtcbiAgICBldmVudHMgPSBlbC5uYXRpdmVFdmVudHMgfHwgKGVsLm5hdGl2ZUV2ZW50cyA9IHt9KTtcbiAgfSBlbHNlIHtcbiAgICBldmVudHMgPSBlbC5ldmVudHMgfHwgKGVsLmV2ZW50cyA9IHt9KTtcbiAgfVxuXG4gIHZhciBuZXdIYW5kbGVyID0ge1xuICAgIHZhbHVlOiB2YWx1ZS50cmltKClcbiAgfTtcbiAgaWYgKG1vZGlmaWVycyAhPT0gZW1wdHlPYmplY3QpIHtcbiAgICBuZXdIYW5kbGVyLm1vZGlmaWVycyA9IG1vZGlmaWVycztcbiAgfVxuXG4gIHZhciBoYW5kbGVycyA9IGV2ZW50c1tuYW1lXTtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChBcnJheS5pc0FycmF5KGhhbmRsZXJzKSkge1xuICAgIGltcG9ydGFudCA/IGhhbmRsZXJzLnVuc2hpZnQobmV3SGFuZGxlcikgOiBoYW5kbGVycy5wdXNoKG5ld0hhbmRsZXIpO1xuICB9IGVsc2UgaWYgKGhhbmRsZXJzKSB7XG4gICAgZXZlbnRzW25hbWVdID0gaW1wb3J0YW50ID8gW25ld0hhbmRsZXIsIGhhbmRsZXJzXSA6IFtoYW5kbGVycywgbmV3SGFuZGxlcl07XG4gIH0gZWxzZSB7XG4gICAgZXZlbnRzW25hbWVdID0gbmV3SGFuZGxlcjtcbiAgfVxuXG4gIGVsLnBsYWluID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldEJpbmRpbmdBdHRyIChcbiAgZWwsXG4gIG5hbWUsXG4gIGdldFN0YXRpY1xuKSB7XG4gIHZhciBkeW5hbWljVmFsdWUgPVxuICAgIGdldEFuZFJlbW92ZUF0dHIoZWwsICc6JyArIG5hbWUpIHx8XG4gICAgZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtYmluZDonICsgbmFtZSk7XG4gIGlmIChkeW5hbWljVmFsdWUgIT0gbnVsbCkge1xuICAgIHJldHVybiBwYXJzZUZpbHRlcnMoZHluYW1pY1ZhbHVlKVxuICB9IGVsc2UgaWYgKGdldFN0YXRpYyAhPT0gZmFsc2UpIHtcbiAgICB2YXIgc3RhdGljVmFsdWUgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCBuYW1lKTtcbiAgICBpZiAoc3RhdGljVmFsdWUgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHN0YXRpY1ZhbHVlKVxuICAgIH1cbiAgfVxufVxuXG4vLyBub3RlOiB0aGlzIG9ubHkgcmVtb3ZlcyB0aGUgYXR0ciBmcm9tIHRoZSBBcnJheSAoYXR0cnNMaXN0KSBzbyB0aGF0IGl0XG4vLyBkb2Vzbid0IGdldCBwcm9jZXNzZWQgYnkgcHJvY2Vzc0F0dHJzLlxuLy8gQnkgZGVmYXVsdCBpdCBkb2VzIE5PVCByZW1vdmUgaXQgZnJvbSB0aGUgbWFwIChhdHRyc01hcCkgYmVjYXVzZSB0aGUgbWFwIGlzXG4vLyBuZWVkZWQgZHVyaW5nIGNvZGVnZW4uXG5mdW5jdGlvbiBnZXRBbmRSZW1vdmVBdHRyIChcbiAgZWwsXG4gIG5hbWUsXG4gIHJlbW92ZUZyb21NYXBcbikge1xuICB2YXIgdmFsO1xuICBpZiAoKHZhbCA9IGVsLmF0dHJzTWFwW25hbWVdKSAhPSBudWxsKSB7XG4gICAgdmFyIGxpc3QgPSBlbC5hdHRyc0xpc3Q7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKGxpc3RbaV0ubmFtZSA9PT0gbmFtZSkge1xuICAgICAgICBsaXN0LnNwbGljZShpLCAxKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHJlbW92ZUZyb21NYXApIHtcbiAgICBkZWxldGUgZWwuYXR0cnNNYXBbbmFtZV07XG4gIH1cbiAgcmV0dXJuIHZhbFxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBDcm9zcy1wbGF0Zm9ybSBjb2RlIGdlbmVyYXRpb24gZm9yIGNvbXBvbmVudCB2LW1vZGVsXG4gKi9cbmZ1bmN0aW9uIGdlbkNvbXBvbmVudE1vZGVsIChcbiAgZWwsXG4gIHZhbHVlLFxuICBtb2RpZmllcnNcbikge1xuICB2YXIgcmVmID0gbW9kaWZpZXJzIHx8IHt9O1xuICB2YXIgbnVtYmVyID0gcmVmLm51bWJlcjtcbiAgdmFyIHRyaW0gPSByZWYudHJpbTtcblxuICB2YXIgYmFzZVZhbHVlRXhwcmVzc2lvbiA9ICckJHYnO1xuICB2YXIgdmFsdWVFeHByZXNzaW9uID0gYmFzZVZhbHVlRXhwcmVzc2lvbjtcbiAgaWYgKHRyaW0pIHtcbiAgICB2YWx1ZUV4cHJlc3Npb24gPVxuICAgICAgXCIodHlwZW9mIFwiICsgYmFzZVZhbHVlRXhwcmVzc2lvbiArIFwiID09PSAnc3RyaW5nJ1wiICtcbiAgICAgIFwiPyBcIiArIGJhc2VWYWx1ZUV4cHJlc3Npb24gKyBcIi50cmltKClcIiArXG4gICAgICBcIjogXCIgKyBiYXNlVmFsdWVFeHByZXNzaW9uICsgXCIpXCI7XG4gIH1cbiAgaWYgKG51bWJlcikge1xuICAgIHZhbHVlRXhwcmVzc2lvbiA9IFwiX24oXCIgKyB2YWx1ZUV4cHJlc3Npb24gKyBcIilcIjtcbiAgfVxuICB2YXIgYXNzaWdubWVudCA9IGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCB2YWx1ZUV4cHJlc3Npb24pO1xuXG4gIGVsLm1vZGVsID0ge1xuICAgIHZhbHVlOiAoXCIoXCIgKyB2YWx1ZSArIFwiKVwiKSxcbiAgICBleHByZXNzaW9uOiAoXCJcXFwiXCIgKyB2YWx1ZSArIFwiXFxcIlwiKSxcbiAgICBjYWxsYmFjazogKFwiZnVuY3Rpb24gKFwiICsgYmFzZVZhbHVlRXhwcmVzc2lvbiArIFwiKSB7XCIgKyBhc3NpZ25tZW50ICsgXCJ9XCIpXG4gIH07XG59XG5cbi8qKlxuICogQ3Jvc3MtcGxhdGZvcm0gY29kZWdlbiBoZWxwZXIgZm9yIGdlbmVyYXRpbmcgdi1tb2RlbCB2YWx1ZSBhc3NpZ25tZW50IGNvZGUuXG4gKi9cbmZ1bmN0aW9uIGdlbkFzc2lnbm1lbnRDb2RlIChcbiAgdmFsdWUsXG4gIGFzc2lnbm1lbnRcbikge1xuICB2YXIgcmVzID0gcGFyc2VNb2RlbCh2YWx1ZSk7XG4gIGlmIChyZXMua2V5ID09PSBudWxsKSB7XG4gICAgcmV0dXJuICh2YWx1ZSArIFwiPVwiICsgYXNzaWdubWVudClcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKFwiJHNldChcIiArIChyZXMuZXhwKSArIFwiLCBcIiArIChyZXMua2V5KSArIFwiLCBcIiArIGFzc2lnbm1lbnQgKyBcIilcIilcbiAgfVxufVxuXG4vKipcbiAqIFBhcnNlIGEgdi1tb2RlbCBleHByZXNzaW9uIGludG8gYSBiYXNlIHBhdGggYW5kIGEgZmluYWwga2V5IHNlZ21lbnQuXG4gKiBIYW5kbGVzIGJvdGggZG90LXBhdGggYW5kIHBvc3NpYmxlIHNxdWFyZSBicmFja2V0cy5cbiAqXG4gKiBQb3NzaWJsZSBjYXNlczpcbiAqXG4gKiAtIHRlc3RcbiAqIC0gdGVzdFtrZXldXG4gKiAtIHRlc3RbdGVzdDFba2V5XV1cbiAqIC0gdGVzdFtcImFcIl1ba2V5XVxuICogLSB4eHgudGVzdFthW2FdLnRlc3QxW2tleV1dXG4gKiAtIHRlc3QueHh4LmFbXCJhc2FcIl1bdGVzdDFba2V5XV1cbiAqXG4gKi9cblxudmFyIGxlbjtcbnZhciBzdHI7XG52YXIgY2hyO1xudmFyIGluZGV4JDE7XG52YXIgZXhwcmVzc2lvblBvcztcbnZhciBleHByZXNzaW9uRW5kUG9zO1xuXG5cblxuZnVuY3Rpb24gcGFyc2VNb2RlbCAodmFsKSB7XG4gIC8vIEZpeCBodHRwczovL2dpdGh1Yi5jb20vdnVlanMvdnVlL3B1bGwvNzczMFxuICAvLyBhbGxvdyB2LW1vZGVsPVwib2JqLnZhbCBcIiAodHJhaWxpbmcgd2hpdGVzcGFjZSlcbiAgdmFsID0gdmFsLnRyaW0oKTtcbiAgbGVuID0gdmFsLmxlbmd0aDtcblxuICBpZiAodmFsLmluZGV4T2YoJ1snKSA8IDAgfHwgdmFsLmxhc3RJbmRleE9mKCddJykgPCBsZW4gLSAxKSB7XG4gICAgaW5kZXgkMSA9IHZhbC5sYXN0SW5kZXhPZignLicpO1xuICAgIGlmIChpbmRleCQxID4gLTEpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGV4cDogdmFsLnNsaWNlKDAsIGluZGV4JDEpLFxuICAgICAgICBrZXk6ICdcIicgKyB2YWwuc2xpY2UoaW5kZXgkMSArIDEpICsgJ1wiJ1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBleHA6IHZhbCxcbiAgICAgICAga2V5OiBudWxsXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgc3RyID0gdmFsO1xuICBpbmRleCQxID0gZXhwcmVzc2lvblBvcyA9IGV4cHJlc3Npb25FbmRQb3MgPSAwO1xuXG4gIHdoaWxlICghZW9mKCkpIHtcbiAgICBjaHIgPSBuZXh0KCk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGlzU3RyaW5nU3RhcnQoY2hyKSkge1xuICAgICAgcGFyc2VTdHJpbmcoY2hyKTtcbiAgICB9IGVsc2UgaWYgKGNociA9PT0gMHg1Qikge1xuICAgICAgcGFyc2VCcmFja2V0KGNocik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBleHA6IHZhbC5zbGljZSgwLCBleHByZXNzaW9uUG9zKSxcbiAgICBrZXk6IHZhbC5zbGljZShleHByZXNzaW9uUG9zICsgMSwgZXhwcmVzc2lvbkVuZFBvcylcbiAgfVxufVxuXG5mdW5jdGlvbiBuZXh0ICgpIHtcbiAgcmV0dXJuIHN0ci5jaGFyQ29kZUF0KCsraW5kZXgkMSlcbn1cblxuZnVuY3Rpb24gZW9mICgpIHtcbiAgcmV0dXJuIGluZGV4JDEgPj0gbGVuXG59XG5cbmZ1bmN0aW9uIGlzU3RyaW5nU3RhcnQgKGNocikge1xuICByZXR1cm4gY2hyID09PSAweDIyIHx8IGNociA9PT0gMHgyN1xufVxuXG5mdW5jdGlvbiBwYXJzZUJyYWNrZXQgKGNocikge1xuICB2YXIgaW5CcmFja2V0ID0gMTtcbiAgZXhwcmVzc2lvblBvcyA9IGluZGV4JDE7XG4gIHdoaWxlICghZW9mKCkpIHtcbiAgICBjaHIgPSBuZXh0KCk7XG4gICAgaWYgKGlzU3RyaW5nU3RhcnQoY2hyKSkge1xuICAgICAgcGFyc2VTdHJpbmcoY2hyKTtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIGlmIChjaHIgPT09IDB4NUIpIHsgaW5CcmFja2V0Kys7IH1cbiAgICBpZiAoY2hyID09PSAweDVEKSB7IGluQnJhY2tldC0tOyB9XG4gICAgaWYgKGluQnJhY2tldCA9PT0gMCkge1xuICAgICAgZXhwcmVzc2lvbkVuZFBvcyA9IGluZGV4JDE7XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwYXJzZVN0cmluZyAoY2hyKSB7XG4gIHZhciBzdHJpbmdRdW90ZSA9IGNocjtcbiAgd2hpbGUgKCFlb2YoKSkge1xuICAgIGNociA9IG5leHQoKTtcbiAgICBpZiAoY2hyID09PSBzdHJpbmdRdW90ZSkge1xuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbnZhciB3YXJuJDE7XG5cbi8vIGluIHNvbWUgY2FzZXMsIHRoZSBldmVudCB1c2VkIGhhcyB0byBiZSBkZXRlcm1pbmVkIGF0IHJ1bnRpbWVcbi8vIHNvIHdlIHVzZWQgc29tZSByZXNlcnZlZCB0b2tlbnMgZHVyaW5nIGNvbXBpbGUuXG52YXIgUkFOR0VfVE9LRU4gPSAnX19yJztcbnZhciBDSEVDS0JPWF9SQURJT19UT0tFTiA9ICdfX2MnO1xuXG5mdW5jdGlvbiBtb2RlbCAoXG4gIGVsLFxuICBkaXIsXG4gIF93YXJuXG4pIHtcbiAgd2FybiQxID0gX3dhcm47XG4gIHZhciB2YWx1ZSA9IGRpci52YWx1ZTtcbiAgdmFyIG1vZGlmaWVycyA9IGRpci5tb2RpZmllcnM7XG4gIHZhciB0YWcgPSBlbC50YWc7XG4gIHZhciB0eXBlID0gZWwuYXR0cnNNYXAudHlwZTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIC8vIGlucHV0cyB3aXRoIHR5cGU9XCJmaWxlXCIgYXJlIHJlYWQgb25seSBhbmQgc2V0dGluZyB0aGUgaW5wdXQnc1xuICAgIC8vIHZhbHVlIHdpbGwgdGhyb3cgYW4gZXJyb3IuXG4gICAgaWYgKHRhZyA9PT0gJ2lucHV0JyAmJiB0eXBlID09PSAnZmlsZScpIHtcbiAgICAgIHdhcm4kMShcbiAgICAgICAgXCI8XCIgKyAoZWwudGFnKSArIFwiIHYtbW9kZWw9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCIgdHlwZT1cXFwiZmlsZVxcXCI+OlxcblwiICtcbiAgICAgICAgXCJGaWxlIGlucHV0cyBhcmUgcmVhZCBvbmx5LiBVc2UgYSB2LW9uOmNoYW5nZSBsaXN0ZW5lciBpbnN0ZWFkLlwiXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIGlmIChlbC5jb21wb25lbnQpIHtcbiAgICBnZW5Db21wb25lbnRNb2RlbChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XG4gICAgLy8gY29tcG9uZW50IHYtbW9kZWwgZG9lc24ndCBuZWVkIGV4dHJhIHJ1bnRpbWVcbiAgICByZXR1cm4gZmFsc2VcbiAgfSBlbHNlIGlmICh0YWcgPT09ICdzZWxlY3QnKSB7XG4gICAgZ2VuU2VsZWN0KGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgfSBlbHNlIGlmICh0YWcgPT09ICdpbnB1dCcgJiYgdHlwZSA9PT0gJ2NoZWNrYm94Jykge1xuICAgIGdlbkNoZWNrYm94TW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ2lucHV0JyAmJiB0eXBlID09PSAncmFkaW8nKSB7XG4gICAgZ2VuUmFkaW9Nb2RlbChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XG4gIH0gZWxzZSBpZiAodGFnID09PSAnaW5wdXQnIHx8IHRhZyA9PT0gJ3RleHRhcmVhJykge1xuICAgIGdlbkRlZmF1bHRNb2RlbChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XG4gIH0gZWxzZSBpZiAoIWNvbmZpZy5pc1Jlc2VydmVkVGFnKHRhZykpIHtcbiAgICBnZW5Db21wb25lbnRNb2RlbChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XG4gICAgLy8gY29tcG9uZW50IHYtbW9kZWwgZG9lc24ndCBuZWVkIGV4dHJhIHJ1bnRpbWVcbiAgICByZXR1cm4gZmFsc2VcbiAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgd2FybiQxKFxuICAgICAgXCI8XCIgKyAoZWwudGFnKSArIFwiIHYtbW9kZWw9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCI+OiBcIiArXG4gICAgICBcInYtbW9kZWwgaXMgbm90IHN1cHBvcnRlZCBvbiB0aGlzIGVsZW1lbnQgdHlwZS4gXCIgK1xuICAgICAgJ0lmIHlvdSBhcmUgd29ya2luZyB3aXRoIGNvbnRlbnRlZGl0YWJsZSwgaXRcXCdzIHJlY29tbWVuZGVkIHRvICcgK1xuICAgICAgJ3dyYXAgYSBsaWJyYXJ5IGRlZGljYXRlZCBmb3IgdGhhdCBwdXJwb3NlIGluc2lkZSBhIGN1c3RvbSBjb21wb25lbnQuJ1xuICAgICk7XG4gIH1cblxuICAvLyBlbnN1cmUgcnVudGltZSBkaXJlY3RpdmUgbWV0YWRhdGFcbiAgcmV0dXJuIHRydWVcbn1cblxuZnVuY3Rpb24gZ2VuQ2hlY2tib3hNb2RlbCAoXG4gIGVsLFxuICB2YWx1ZSxcbiAgbW9kaWZpZXJzXG4pIHtcbiAgdmFyIG51bWJlciA9IG1vZGlmaWVycyAmJiBtb2RpZmllcnMubnVtYmVyO1xuICB2YXIgdmFsdWVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICd2YWx1ZScpIHx8ICdudWxsJztcbiAgdmFyIHRydWVWYWx1ZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3RydWUtdmFsdWUnKSB8fCAndHJ1ZSc7XG4gIHZhciBmYWxzZVZhbHVlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAnZmFsc2UtdmFsdWUnKSB8fCAnZmFsc2UnO1xuICBhZGRQcm9wKGVsLCAnY2hlY2tlZCcsXG4gICAgXCJBcnJheS5pc0FycmF5KFwiICsgdmFsdWUgKyBcIilcIiArXG4gICAgXCI/X2koXCIgKyB2YWx1ZSArIFwiLFwiICsgdmFsdWVCaW5kaW5nICsgXCIpPi0xXCIgKyAoXG4gICAgICB0cnVlVmFsdWVCaW5kaW5nID09PSAndHJ1ZSdcbiAgICAgICAgPyAoXCI6KFwiICsgdmFsdWUgKyBcIilcIilcbiAgICAgICAgOiAoXCI6X3EoXCIgKyB2YWx1ZSArIFwiLFwiICsgdHJ1ZVZhbHVlQmluZGluZyArIFwiKVwiKVxuICAgIClcbiAgKTtcbiAgYWRkSGFuZGxlcihlbCwgJ2NoYW5nZScsXG4gICAgXCJ2YXIgJCRhPVwiICsgdmFsdWUgKyBcIixcIiArXG4gICAgICAgICckJGVsPSRldmVudC50YXJnZXQsJyArXG4gICAgICAgIFwiJCRjPSQkZWwuY2hlY2tlZD8oXCIgKyB0cnVlVmFsdWVCaW5kaW5nICsgXCIpOihcIiArIGZhbHNlVmFsdWVCaW5kaW5nICsgXCIpO1wiICtcbiAgICAnaWYoQXJyYXkuaXNBcnJheSgkJGEpKXsnICtcbiAgICAgIFwidmFyICQkdj1cIiArIChudW1iZXIgPyAnX24oJyArIHZhbHVlQmluZGluZyArICcpJyA6IHZhbHVlQmluZGluZykgKyBcIixcIiArXG4gICAgICAgICAgJyQkaT1faSgkJGEsJCR2KTsnICtcbiAgICAgIFwiaWYoJCRlbC5jaGVja2VkKXskJGk8MCYmKFwiICsgKGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCAnJCRhLmNvbmNhdChbJCR2XSknKSkgKyBcIil9XCIgK1xuICAgICAgXCJlbHNleyQkaT4tMSYmKFwiICsgKGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCAnJCRhLnNsaWNlKDAsJCRpKS5jb25jYXQoJCRhLnNsaWNlKCQkaSsxKSknKSkgKyBcIil9XCIgK1xuICAgIFwifWVsc2V7XCIgKyAoZ2VuQXNzaWdubWVudENvZGUodmFsdWUsICckJGMnKSkgKyBcIn1cIixcbiAgICBudWxsLCB0cnVlXG4gICk7XG59XG5cbmZ1bmN0aW9uIGdlblJhZGlvTW9kZWwgKFxuICBlbCxcbiAgdmFsdWUsXG4gIG1vZGlmaWVyc1xuKSB7XG4gIHZhciBudW1iZXIgPSBtb2RpZmllcnMgJiYgbW9kaWZpZXJzLm51bWJlcjtcbiAgdmFyIHZhbHVlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAndmFsdWUnKSB8fCAnbnVsbCc7XG4gIHZhbHVlQmluZGluZyA9IG51bWJlciA/IChcIl9uKFwiICsgdmFsdWVCaW5kaW5nICsgXCIpXCIpIDogdmFsdWVCaW5kaW5nO1xuICBhZGRQcm9wKGVsLCAnY2hlY2tlZCcsIChcIl9xKFwiICsgdmFsdWUgKyBcIixcIiArIHZhbHVlQmluZGluZyArIFwiKVwiKSk7XG4gIGFkZEhhbmRsZXIoZWwsICdjaGFuZ2UnLCBnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgdmFsdWVCaW5kaW5nKSwgbnVsbCwgdHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIGdlblNlbGVjdCAoXG4gIGVsLFxuICB2YWx1ZSxcbiAgbW9kaWZpZXJzXG4pIHtcbiAgdmFyIG51bWJlciA9IG1vZGlmaWVycyAmJiBtb2RpZmllcnMubnVtYmVyO1xuICB2YXIgc2VsZWN0ZWRWYWwgPSBcIkFycmF5LnByb3RvdHlwZS5maWx0ZXJcIiArXG4gICAgXCIuY2FsbCgkZXZlbnQudGFyZ2V0Lm9wdGlvbnMsZnVuY3Rpb24obyl7cmV0dXJuIG8uc2VsZWN0ZWR9KVwiICtcbiAgICBcIi5tYXAoZnVuY3Rpb24obyl7dmFyIHZhbCA9IFxcXCJfdmFsdWVcXFwiIGluIG8gPyBvLl92YWx1ZSA6IG8udmFsdWU7XCIgK1xuICAgIFwicmV0dXJuIFwiICsgKG51bWJlciA/ICdfbih2YWwpJyA6ICd2YWwnKSArIFwifSlcIjtcblxuICB2YXIgYXNzaWdubWVudCA9ICckZXZlbnQudGFyZ2V0Lm11bHRpcGxlID8gJCRzZWxlY3RlZFZhbCA6ICQkc2VsZWN0ZWRWYWxbMF0nO1xuICB2YXIgY29kZSA9IFwidmFyICQkc2VsZWN0ZWRWYWwgPSBcIiArIHNlbGVjdGVkVmFsICsgXCI7XCI7XG4gIGNvZGUgPSBjb2RlICsgXCIgXCIgKyAoZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIGFzc2lnbm1lbnQpKTtcbiAgYWRkSGFuZGxlcihlbCwgJ2NoYW5nZScsIGNvZGUsIG51bGwsIHRydWUpO1xufVxuXG5mdW5jdGlvbiBnZW5EZWZhdWx0TW9kZWwgKFxuICBlbCxcbiAgdmFsdWUsXG4gIG1vZGlmaWVyc1xuKSB7XG4gIHZhciB0eXBlID0gZWwuYXR0cnNNYXAudHlwZTtcblxuICAvLyB3YXJuIGlmIHYtYmluZDp2YWx1ZSBjb25mbGljdHMgd2l0aCB2LW1vZGVsXG4gIC8vIGV4Y2VwdCBmb3IgaW5wdXRzIHdpdGggdi1iaW5kOnR5cGVcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB2YXIgdmFsdWUkMSA9IGVsLmF0dHJzTWFwWyd2LWJpbmQ6dmFsdWUnXSB8fCBlbC5hdHRyc01hcFsnOnZhbHVlJ107XG4gICAgdmFyIHR5cGVCaW5kaW5nID0gZWwuYXR0cnNNYXBbJ3YtYmluZDp0eXBlJ10gfHwgZWwuYXR0cnNNYXBbJzp0eXBlJ107XG4gICAgaWYgKHZhbHVlJDEgJiYgIXR5cGVCaW5kaW5nKSB7XG4gICAgICB2YXIgYmluZGluZyA9IGVsLmF0dHJzTWFwWyd2LWJpbmQ6dmFsdWUnXSA/ICd2LWJpbmQ6dmFsdWUnIDogJzp2YWx1ZSc7XG4gICAgICB3YXJuJDEoXG4gICAgICAgIGJpbmRpbmcgKyBcIj1cXFwiXCIgKyB2YWx1ZSQxICsgXCJcXFwiIGNvbmZsaWN0cyB3aXRoIHYtbW9kZWwgb24gdGhlIHNhbWUgZWxlbWVudCBcIiArXG4gICAgICAgICdiZWNhdXNlIHRoZSBsYXR0ZXIgYWxyZWFkeSBleHBhbmRzIHRvIGEgdmFsdWUgYmluZGluZyBpbnRlcm5hbGx5J1xuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICB2YXIgcmVmID0gbW9kaWZpZXJzIHx8IHt9O1xuICB2YXIgbGF6eSA9IHJlZi5sYXp5O1xuICB2YXIgbnVtYmVyID0gcmVmLm51bWJlcjtcbiAgdmFyIHRyaW0gPSByZWYudHJpbTtcbiAgdmFyIG5lZWRDb21wb3NpdGlvbkd1YXJkID0gIWxhenkgJiYgdHlwZSAhPT0gJ3JhbmdlJztcbiAgdmFyIGV2ZW50ID0gbGF6eVxuICAgID8gJ2NoYW5nZSdcbiAgICA6IHR5cGUgPT09ICdyYW5nZSdcbiAgICAgID8gUkFOR0VfVE9LRU5cbiAgICAgIDogJ2lucHV0JztcblxuICB2YXIgdmFsdWVFeHByZXNzaW9uID0gJyRldmVudC50YXJnZXQudmFsdWUnO1xuICBpZiAodHJpbSkge1xuICAgIHZhbHVlRXhwcmVzc2lvbiA9IFwiJGV2ZW50LnRhcmdldC52YWx1ZS50cmltKClcIjtcbiAgfVxuICBpZiAobnVtYmVyKSB7XG4gICAgdmFsdWVFeHByZXNzaW9uID0gXCJfbihcIiArIHZhbHVlRXhwcmVzc2lvbiArIFwiKVwiO1xuICB9XG5cbiAgdmFyIGNvZGUgPSBnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgdmFsdWVFeHByZXNzaW9uKTtcbiAgaWYgKG5lZWRDb21wb3NpdGlvbkd1YXJkKSB7XG4gICAgY29kZSA9IFwiaWYoJGV2ZW50LnRhcmdldC5jb21wb3NpbmcpcmV0dXJuO1wiICsgY29kZTtcbiAgfVxuXG4gIGFkZFByb3AoZWwsICd2YWx1ZScsIChcIihcIiArIHZhbHVlICsgXCIpXCIpKTtcbiAgYWRkSGFuZGxlcihlbCwgZXZlbnQsIGNvZGUsIG51bGwsIHRydWUpO1xuICBpZiAodHJpbSB8fCBudW1iZXIpIHtcbiAgICBhZGRIYW5kbGVyKGVsLCAnYmx1cicsICckZm9yY2VVcGRhdGUoKScpO1xuICB9XG59XG5cbi8qICAqL1xuXG4vLyBub3JtYWxpemUgdi1tb2RlbCBldmVudCB0b2tlbnMgdGhhdCBjYW4gb25seSBiZSBkZXRlcm1pbmVkIGF0IHJ1bnRpbWUuXG4vLyBpdCdzIGltcG9ydGFudCB0byBwbGFjZSB0aGUgZXZlbnQgYXMgdGhlIGZpcnN0IGluIHRoZSBhcnJheSBiZWNhdXNlXG4vLyB0aGUgd2hvbGUgcG9pbnQgaXMgZW5zdXJpbmcgdGhlIHYtbW9kZWwgY2FsbGJhY2sgZ2V0cyBjYWxsZWQgYmVmb3JlXG4vLyB1c2VyLWF0dGFjaGVkIGhhbmRsZXJzLlxuZnVuY3Rpb24gbm9ybWFsaXplRXZlbnRzIChvbikge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGlzRGVmKG9uW1JBTkdFX1RPS0VOXSkpIHtcbiAgICAvLyBJRSBpbnB1dFt0eXBlPXJhbmdlXSBvbmx5IHN1cHBvcnRzIGBjaGFuZ2VgIGV2ZW50XG4gICAgdmFyIGV2ZW50ID0gaXNJRSA/ICdjaGFuZ2UnIDogJ2lucHV0JztcbiAgICBvbltldmVudF0gPSBbXS5jb25jYXQob25bUkFOR0VfVE9LRU5dLCBvbltldmVudF0gfHwgW10pO1xuICAgIGRlbGV0ZSBvbltSQU5HRV9UT0tFTl07XG4gIH1cbiAgLy8gVGhpcyB3YXMgb3JpZ2luYWxseSBpbnRlbmRlZCB0byBmaXggIzQ1MjEgYnV0IG5vIGxvbmdlciBuZWNlc3NhcnlcbiAgLy8gYWZ0ZXIgMi41LiBLZWVwaW5nIGl0IGZvciBiYWNrd2FyZHMgY29tcGF0IHdpdGggZ2VuZXJhdGVkIGNvZGUgZnJvbSA8IDIuNFxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGlzRGVmKG9uW0NIRUNLQk9YX1JBRElPX1RPS0VOXSkpIHtcbiAgICBvbi5jaGFuZ2UgPSBbXS5jb25jYXQob25bQ0hFQ0tCT1hfUkFESU9fVE9LRU5dLCBvbi5jaGFuZ2UgfHwgW10pO1xuICAgIGRlbGV0ZSBvbltDSEVDS0JPWF9SQURJT19UT0tFTl07XG4gIH1cbn1cblxudmFyIHRhcmdldCQxO1xuXG5mdW5jdGlvbiBjcmVhdGVPbmNlSGFuZGxlciAoaGFuZGxlciwgZXZlbnQsIGNhcHR1cmUpIHtcbiAgdmFyIF90YXJnZXQgPSB0YXJnZXQkMTsgLy8gc2F2ZSBjdXJyZW50IHRhcmdldCBlbGVtZW50IGluIGNsb3N1cmVcbiAgcmV0dXJuIGZ1bmN0aW9uIG9uY2VIYW5kbGVyICgpIHtcbiAgICB2YXIgcmVzID0gaGFuZGxlci5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIGlmIChyZXMgIT09IG51bGwpIHtcbiAgICAgIHJlbW92ZSQyKGV2ZW50LCBvbmNlSGFuZGxlciwgY2FwdHVyZSwgX3RhcmdldCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFkZCQxIChcbiAgZXZlbnQsXG4gIGhhbmRsZXIsXG4gIG9uY2UkJDEsXG4gIGNhcHR1cmUsXG4gIHBhc3NpdmVcbikge1xuICBoYW5kbGVyID0gd2l0aE1hY3JvVGFzayhoYW5kbGVyKTtcbiAgaWYgKG9uY2UkJDEpIHsgaGFuZGxlciA9IGNyZWF0ZU9uY2VIYW5kbGVyKGhhbmRsZXIsIGV2ZW50LCBjYXB0dXJlKTsgfVxuICB0YXJnZXQkMS5hZGRFdmVudExpc3RlbmVyKFxuICAgIGV2ZW50LFxuICAgIGhhbmRsZXIsXG4gICAgc3VwcG9ydHNQYXNzaXZlXG4gICAgICA/IHsgY2FwdHVyZTogY2FwdHVyZSwgcGFzc2l2ZTogcGFzc2l2ZSB9XG4gICAgICA6IGNhcHR1cmVcbiAgKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlJDIgKFxuICBldmVudCxcbiAgaGFuZGxlcixcbiAgY2FwdHVyZSxcbiAgX3RhcmdldFxuKSB7XG4gIChfdGFyZ2V0IHx8IHRhcmdldCQxKS5yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgIGV2ZW50LFxuICAgIGhhbmRsZXIuX3dpdGhUYXNrIHx8IGhhbmRsZXIsXG4gICAgY2FwdHVyZVxuICApO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVET01MaXN0ZW5lcnMgKG9sZFZub2RlLCB2bm9kZSkge1xuICBpZiAoaXNVbmRlZihvbGRWbm9kZS5kYXRhLm9uKSAmJiBpc1VuZGVmKHZub2RlLmRhdGEub24pKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIG9uID0gdm5vZGUuZGF0YS5vbiB8fCB7fTtcbiAgdmFyIG9sZE9uID0gb2xkVm5vZGUuZGF0YS5vbiB8fCB7fTtcbiAgdGFyZ2V0JDEgPSB2bm9kZS5lbG07XG4gIG5vcm1hbGl6ZUV2ZW50cyhvbik7XG4gIHVwZGF0ZUxpc3RlbmVycyhvbiwgb2xkT24sIGFkZCQxLCByZW1vdmUkMiwgdm5vZGUuY29udGV4dCk7XG4gIHRhcmdldCQxID0gdW5kZWZpbmVkO1xufVxuXG52YXIgZXZlbnRzID0ge1xuICBjcmVhdGU6IHVwZGF0ZURPTUxpc3RlbmVycyxcbiAgdXBkYXRlOiB1cGRhdGVET01MaXN0ZW5lcnNcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIHVwZGF0ZURPTVByb3BzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgaWYgKGlzVW5kZWYob2xkVm5vZGUuZGF0YS5kb21Qcm9wcykgJiYgaXNVbmRlZih2bm9kZS5kYXRhLmRvbVByb3BzKSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBrZXksIGN1cjtcbiAgdmFyIGVsbSA9IHZub2RlLmVsbTtcbiAgdmFyIG9sZFByb3BzID0gb2xkVm5vZGUuZGF0YS5kb21Qcm9wcyB8fCB7fTtcbiAgdmFyIHByb3BzID0gdm5vZGUuZGF0YS5kb21Qcm9wcyB8fCB7fTtcbiAgLy8gY2xvbmUgb2JzZXJ2ZWQgb2JqZWN0cywgYXMgdGhlIHVzZXIgcHJvYmFibHkgd2FudHMgdG8gbXV0YXRlIGl0XG4gIGlmIChpc0RlZihwcm9wcy5fX29iX18pKSB7XG4gICAgcHJvcHMgPSB2bm9kZS5kYXRhLmRvbVByb3BzID0gZXh0ZW5kKHt9LCBwcm9wcyk7XG4gIH1cblxuICBmb3IgKGtleSBpbiBvbGRQcm9wcykge1xuICAgIGlmIChpc1VuZGVmKHByb3BzW2tleV0pKSB7XG4gICAgICBlbG1ba2V5XSA9ICcnO1xuICAgIH1cbiAgfVxuICBmb3IgKGtleSBpbiBwcm9wcykge1xuICAgIGN1ciA9IHByb3BzW2tleV07XG4gICAgLy8gaWdub3JlIGNoaWxkcmVuIGlmIHRoZSBub2RlIGhhcyB0ZXh0Q29udGVudCBvciBpbm5lckhUTUwsXG4gICAgLy8gYXMgdGhlc2Ugd2lsbCB0aHJvdyBhd2F5IGV4aXN0aW5nIERPTSBub2RlcyBhbmQgY2F1c2UgcmVtb3ZhbCBlcnJvcnNcbiAgICAvLyBvbiBzdWJzZXF1ZW50IHBhdGNoZXMgKCMzMzYwKVxuICAgIGlmIChrZXkgPT09ICd0ZXh0Q29udGVudCcgfHwga2V5ID09PSAnaW5uZXJIVE1MJykge1xuICAgICAgaWYgKHZub2RlLmNoaWxkcmVuKSB7IHZub2RlLmNoaWxkcmVuLmxlbmd0aCA9IDA7IH1cbiAgICAgIGlmIChjdXIgPT09IG9sZFByb3BzW2tleV0pIHsgY29udGludWUgfVxuICAgICAgLy8gIzY2MDEgd29yayBhcm91bmQgQ2hyb21lIHZlcnNpb24gPD0gNTUgYnVnIHdoZXJlIHNpbmdsZSB0ZXh0Tm9kZVxuICAgICAgLy8gcmVwbGFjZWQgYnkgaW5uZXJIVE1ML3RleHRDb250ZW50IHJldGFpbnMgaXRzIHBhcmVudE5vZGUgcHJvcGVydHlcbiAgICAgIGlmIChlbG0uY2hpbGROb2Rlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgZWxtLnJlbW92ZUNoaWxkKGVsbS5jaGlsZE5vZGVzWzBdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoa2V5ID09PSAndmFsdWUnKSB7XG4gICAgICAvLyBzdG9yZSB2YWx1ZSBhcyBfdmFsdWUgYXMgd2VsbCBzaW5jZVxuICAgICAgLy8gbm9uLXN0cmluZyB2YWx1ZXMgd2lsbCBiZSBzdHJpbmdpZmllZFxuICAgICAgZWxtLl92YWx1ZSA9IGN1cjtcbiAgICAgIC8vIGF2b2lkIHJlc2V0dGluZyBjdXJzb3IgcG9zaXRpb24gd2hlbiB2YWx1ZSBpcyB0aGUgc2FtZVxuICAgICAgdmFyIHN0ckN1ciA9IGlzVW5kZWYoY3VyKSA/ICcnIDogU3RyaW5nKGN1cik7XG4gICAgICBpZiAoc2hvdWxkVXBkYXRlVmFsdWUoZWxtLCBzdHJDdXIpKSB7XG4gICAgICAgIGVsbS52YWx1ZSA9IHN0ckN1cjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZWxtW2tleV0gPSBjdXI7XG4gICAgfVxuICB9XG59XG5cbi8vIGNoZWNrIHBsYXRmb3Jtcy93ZWIvdXRpbC9hdHRycy5qcyBhY2NlcHRWYWx1ZVxuXG5cbmZ1bmN0aW9uIHNob3VsZFVwZGF0ZVZhbHVlIChlbG0sIGNoZWNrVmFsKSB7XG4gIHJldHVybiAoIWVsbS5jb21wb3NpbmcgJiYgKFxuICAgIGVsbS50YWdOYW1lID09PSAnT1BUSU9OJyB8fFxuICAgIGlzTm90SW5Gb2N1c0FuZERpcnR5KGVsbSwgY2hlY2tWYWwpIHx8XG4gICAgaXNEaXJ0eVdpdGhNb2RpZmllcnMoZWxtLCBjaGVja1ZhbClcbiAgKSlcbn1cblxuZnVuY3Rpb24gaXNOb3RJbkZvY3VzQW5kRGlydHkgKGVsbSwgY2hlY2tWYWwpIHtcbiAgLy8gcmV0dXJuIHRydWUgd2hlbiB0ZXh0Ym94ICgubnVtYmVyIGFuZCAudHJpbSkgbG9zZXMgZm9jdXMgYW5kIGl0cyB2YWx1ZSBpc1xuICAvLyBub3QgZXF1YWwgdG8gdGhlIHVwZGF0ZWQgdmFsdWVcbiAgdmFyIG5vdEluRm9jdXMgPSB0cnVlO1xuICAvLyAjNjE1N1xuICAvLyB3b3JrIGFyb3VuZCBJRSBidWcgd2hlbiBhY2Nlc3NpbmcgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCBpbiBhbiBpZnJhbWVcbiAgdHJ5IHsgbm90SW5Gb2N1cyA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgIT09IGVsbTsgfSBjYXRjaCAoZSkge31cbiAgcmV0dXJuIG5vdEluRm9jdXMgJiYgZWxtLnZhbHVlICE9PSBjaGVja1ZhbFxufVxuXG5mdW5jdGlvbiBpc0RpcnR5V2l0aE1vZGlmaWVycyAoZWxtLCBuZXdWYWwpIHtcbiAgdmFyIHZhbHVlID0gZWxtLnZhbHVlO1xuICB2YXIgbW9kaWZpZXJzID0gZWxtLl92TW9kaWZpZXJzOyAvLyBpbmplY3RlZCBieSB2LW1vZGVsIHJ1bnRpbWVcbiAgaWYgKGlzRGVmKG1vZGlmaWVycykpIHtcbiAgICBpZiAobW9kaWZpZXJzLmxhenkpIHtcbiAgICAgIC8vIGlucHV0cyB3aXRoIGxhenkgc2hvdWxkIG9ubHkgYmUgdXBkYXRlZCB3aGVuIG5vdCBpbiBmb2N1c1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIGlmIChtb2RpZmllcnMubnVtYmVyKSB7XG4gICAgICByZXR1cm4gdG9OdW1iZXIodmFsdWUpICE9PSB0b051bWJlcihuZXdWYWwpXG4gICAgfVxuICAgIGlmIChtb2RpZmllcnMudHJpbSkge1xuICAgICAgcmV0dXJuIHZhbHVlLnRyaW0oKSAhPT0gbmV3VmFsLnRyaW0oKVxuICAgIH1cbiAgfVxuICByZXR1cm4gdmFsdWUgIT09IG5ld1ZhbFxufVxuXG52YXIgZG9tUHJvcHMgPSB7XG4gIGNyZWF0ZTogdXBkYXRlRE9NUHJvcHMsXG4gIHVwZGF0ZTogdXBkYXRlRE9NUHJvcHNcbn1cblxuLyogICovXG5cbnZhciBwYXJzZVN0eWxlVGV4dCA9IGNhY2hlZChmdW5jdGlvbiAoY3NzVGV4dCkge1xuICB2YXIgcmVzID0ge307XG4gIHZhciBsaXN0RGVsaW1pdGVyID0gLzsoPyFbXihdKlxcKSkvZztcbiAgdmFyIHByb3BlcnR5RGVsaW1pdGVyID0gLzooLispLztcbiAgY3NzVGV4dC5zcGxpdChsaXN0RGVsaW1pdGVyKS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgaWYgKGl0ZW0pIHtcbiAgICAgIHZhciB0bXAgPSBpdGVtLnNwbGl0KHByb3BlcnR5RGVsaW1pdGVyKTtcbiAgICAgIHRtcC5sZW5ndGggPiAxICYmIChyZXNbdG1wWzBdLnRyaW0oKV0gPSB0bXBbMV0udHJpbSgpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzXG59KTtcblxuLy8gbWVyZ2Ugc3RhdGljIGFuZCBkeW5hbWljIHN0eWxlIGRhdGEgb24gdGhlIHNhbWUgdm5vZGVcbmZ1bmN0aW9uIG5vcm1hbGl6ZVN0eWxlRGF0YSAoZGF0YSkge1xuICB2YXIgc3R5bGUgPSBub3JtYWxpemVTdHlsZUJpbmRpbmcoZGF0YS5zdHlsZSk7XG4gIC8vIHN0YXRpYyBzdHlsZSBpcyBwcmUtcHJvY2Vzc2VkIGludG8gYW4gb2JqZWN0IGR1cmluZyBjb21waWxhdGlvblxuICAvLyBhbmQgaXMgYWx3YXlzIGEgZnJlc2ggb2JqZWN0LCBzbyBpdCdzIHNhZmUgdG8gbWVyZ2UgaW50byBpdFxuICByZXR1cm4gZGF0YS5zdGF0aWNTdHlsZVxuICAgID8gZXh0ZW5kKGRhdGEuc3RhdGljU3R5bGUsIHN0eWxlKVxuICAgIDogc3R5bGVcbn1cblxuLy8gbm9ybWFsaXplIHBvc3NpYmxlIGFycmF5IC8gc3RyaW5nIHZhbHVlcyBpbnRvIE9iamVjdFxuZnVuY3Rpb24gbm9ybWFsaXplU3R5bGVCaW5kaW5nIChiaW5kaW5nU3R5bGUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYmluZGluZ1N0eWxlKSkge1xuICAgIHJldHVybiB0b09iamVjdChiaW5kaW5nU3R5bGUpXG4gIH1cbiAgaWYgKHR5cGVvZiBiaW5kaW5nU3R5bGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHBhcnNlU3R5bGVUZXh0KGJpbmRpbmdTdHlsZSlcbiAgfVxuICByZXR1cm4gYmluZGluZ1N0eWxlXG59XG5cbi8qKlxuICogcGFyZW50IGNvbXBvbmVudCBzdHlsZSBzaG91bGQgYmUgYWZ0ZXIgY2hpbGQnc1xuICogc28gdGhhdCBwYXJlbnQgY29tcG9uZW50J3Mgc3R5bGUgY291bGQgb3ZlcnJpZGUgaXRcbiAqL1xuZnVuY3Rpb24gZ2V0U3R5bGUgKHZub2RlLCBjaGVja0NoaWxkKSB7XG4gIHZhciByZXMgPSB7fTtcbiAgdmFyIHN0eWxlRGF0YTtcblxuICBpZiAoY2hlY2tDaGlsZCkge1xuICAgIHZhciBjaGlsZE5vZGUgPSB2bm9kZTtcbiAgICB3aGlsZSAoY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlKSB7XG4gICAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgICAgaWYgKFxuICAgICAgICBjaGlsZE5vZGUgJiYgY2hpbGROb2RlLmRhdGEgJiZcbiAgICAgICAgKHN0eWxlRGF0YSA9IG5vcm1hbGl6ZVN0eWxlRGF0YShjaGlsZE5vZGUuZGF0YSkpXG4gICAgICApIHtcbiAgICAgICAgZXh0ZW5kKHJlcywgc3R5bGVEYXRhKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoKHN0eWxlRGF0YSA9IG5vcm1hbGl6ZVN0eWxlRGF0YSh2bm9kZS5kYXRhKSkpIHtcbiAgICBleHRlbmQocmVzLCBzdHlsZURhdGEpO1xuICB9XG5cbiAgdmFyIHBhcmVudE5vZGUgPSB2bm9kZTtcbiAgd2hpbGUgKChwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5wYXJlbnQpKSB7XG4gICAgaWYgKHBhcmVudE5vZGUuZGF0YSAmJiAoc3R5bGVEYXRhID0gbm9ybWFsaXplU3R5bGVEYXRhKHBhcmVudE5vZGUuZGF0YSkpKSB7XG4gICAgICBleHRlbmQocmVzLCBzdHlsZURhdGEpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG52YXIgY3NzVmFyUkUgPSAvXi0tLztcbnZhciBpbXBvcnRhbnRSRSA9IC9cXHMqIWltcG9ydGFudCQvO1xudmFyIHNldFByb3AgPSBmdW5jdGlvbiAoZWwsIG5hbWUsIHZhbCkge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGNzc1ZhclJFLnRlc3QobmFtZSkpIHtcbiAgICBlbC5zdHlsZS5zZXRQcm9wZXJ0eShuYW1lLCB2YWwpO1xuICB9IGVsc2UgaWYgKGltcG9ydGFudFJFLnRlc3QodmFsKSkge1xuICAgIGVsLnN0eWxlLnNldFByb3BlcnR5KG5hbWUsIHZhbC5yZXBsYWNlKGltcG9ydGFudFJFLCAnJyksICdpbXBvcnRhbnQnKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbm9ybWFsaXplZE5hbWUgPSBub3JtYWxpemUobmFtZSk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgLy8gU3VwcG9ydCB2YWx1ZXMgYXJyYXkgY3JlYXRlZCBieSBhdXRvcHJlZml4ZXIsIGUuZy5cbiAgICAgIC8vIHtkaXNwbGF5OiBbXCItd2Via2l0LWJveFwiLCBcIi1tcy1mbGV4Ym94XCIsIFwiZmxleFwiXX1cbiAgICAgIC8vIFNldCB0aGVtIG9uZSBieSBvbmUsIGFuZCB0aGUgYnJvd3NlciB3aWxsIG9ubHkgc2V0IHRob3NlIGl0IGNhbiByZWNvZ25pemVcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB2YWwubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgZWwuc3R5bGVbbm9ybWFsaXplZE5hbWVdID0gdmFsW2ldO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zdHlsZVtub3JtYWxpemVkTmFtZV0gPSB2YWw7XG4gICAgfVxuICB9XG59O1xuXG52YXIgdmVuZG9yTmFtZXMgPSBbJ1dlYmtpdCcsICdNb3onLCAnbXMnXTtcblxudmFyIGVtcHR5U3R5bGU7XG52YXIgbm9ybWFsaXplID0gY2FjaGVkKGZ1bmN0aW9uIChwcm9wKSB7XG4gIGVtcHR5U3R5bGUgPSBlbXB0eVN0eWxlIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLnN0eWxlO1xuICBwcm9wID0gY2FtZWxpemUocHJvcCk7XG4gIGlmIChwcm9wICE9PSAnZmlsdGVyJyAmJiAocHJvcCBpbiBlbXB0eVN0eWxlKSkge1xuICAgIHJldHVybiBwcm9wXG4gIH1cbiAgdmFyIGNhcE5hbWUgPSBwcm9wLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcHJvcC5zbGljZSgxKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB2ZW5kb3JOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBuYW1lID0gdmVuZG9yTmFtZXNbaV0gKyBjYXBOYW1lO1xuICAgIGlmIChuYW1lIGluIGVtcHR5U3R5bGUpIHtcbiAgICAgIHJldHVybiBuYW1lXG4gICAgfVxuICB9XG59KTtcblxuZnVuY3Rpb24gdXBkYXRlU3R5bGUgKG9sZFZub2RlLCB2bm9kZSkge1xuICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gIHZhciBvbGREYXRhID0gb2xkVm5vZGUuZGF0YTtcblxuICBpZiAoaXNVbmRlZihkYXRhLnN0YXRpY1N0eWxlKSAmJiBpc1VuZGVmKGRhdGEuc3R5bGUpICYmXG4gICAgaXNVbmRlZihvbGREYXRhLnN0YXRpY1N0eWxlKSAmJiBpc1VuZGVmKG9sZERhdGEuc3R5bGUpXG4gICkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGN1ciwgbmFtZTtcbiAgdmFyIGVsID0gdm5vZGUuZWxtO1xuICB2YXIgb2xkU3RhdGljU3R5bGUgPSBvbGREYXRhLnN0YXRpY1N0eWxlO1xuICB2YXIgb2xkU3R5bGVCaW5kaW5nID0gb2xkRGF0YS5ub3JtYWxpemVkU3R5bGUgfHwgb2xkRGF0YS5zdHlsZSB8fCB7fTtcblxuICAvLyBpZiBzdGF0aWMgc3R5bGUgZXhpc3RzLCBzdHlsZWJpbmRpbmcgYWxyZWFkeSBtZXJnZWQgaW50byBpdCB3aGVuIGRvaW5nIG5vcm1hbGl6ZVN0eWxlRGF0YVxuICB2YXIgb2xkU3R5bGUgPSBvbGRTdGF0aWNTdHlsZSB8fCBvbGRTdHlsZUJpbmRpbmc7XG5cbiAgdmFyIHN0eWxlID0gbm9ybWFsaXplU3R5bGVCaW5kaW5nKHZub2RlLmRhdGEuc3R5bGUpIHx8IHt9O1xuXG4gIC8vIHN0b3JlIG5vcm1hbGl6ZWQgc3R5bGUgdW5kZXIgYSBkaWZmZXJlbnQga2V5IGZvciBuZXh0IGRpZmZcbiAgLy8gbWFrZSBzdXJlIHRvIGNsb25lIGl0IGlmIGl0J3MgcmVhY3RpdmUsIHNpbmNlIHRoZSB1c2VyIGxpa2VseSB3YW50c1xuICAvLyB0byBtdXRhdGUgaXQuXG4gIHZub2RlLmRhdGEubm9ybWFsaXplZFN0eWxlID0gaXNEZWYoc3R5bGUuX19vYl9fKVxuICAgID8gZXh0ZW5kKHt9LCBzdHlsZSlcbiAgICA6IHN0eWxlO1xuXG4gIHZhciBuZXdTdHlsZSA9IGdldFN0eWxlKHZub2RlLCB0cnVlKTtcblxuICBmb3IgKG5hbWUgaW4gb2xkU3R5bGUpIHtcbiAgICBpZiAoaXNVbmRlZihuZXdTdHlsZVtuYW1lXSkpIHtcbiAgICAgIHNldFByb3AoZWwsIG5hbWUsICcnKTtcbiAgICB9XG4gIH1cbiAgZm9yIChuYW1lIGluIG5ld1N0eWxlKSB7XG4gICAgY3VyID0gbmV3U3R5bGVbbmFtZV07XG4gICAgaWYgKGN1ciAhPT0gb2xkU3R5bGVbbmFtZV0pIHtcbiAgICAgIC8vIGllOSBzZXR0aW5nIHRvIG51bGwgaGFzIG5vIGVmZmVjdCwgbXVzdCB1c2UgZW1wdHkgc3RyaW5nXG4gICAgICBzZXRQcm9wKGVsLCBuYW1lLCBjdXIgPT0gbnVsbCA/ICcnIDogY3VyKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIHN0eWxlID0ge1xuICBjcmVhdGU6IHVwZGF0ZVN0eWxlLFxuICB1cGRhdGU6IHVwZGF0ZVN0eWxlXG59XG5cbi8qICAqL1xuXG4vKipcbiAqIEFkZCBjbGFzcyB3aXRoIGNvbXBhdGliaWxpdHkgZm9yIFNWRyBzaW5jZSBjbGFzc0xpc3QgaXMgbm90IHN1cHBvcnRlZCBvblxuICogU1ZHIGVsZW1lbnRzIGluIElFXG4gKi9cbmZ1bmN0aW9uIGFkZENsYXNzIChlbCwgY2xzKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIWNscyB8fCAhKGNscyA9IGNscy50cmltKCkpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoZWwuY2xhc3NMaXN0KSB7XG4gICAgaWYgKGNscy5pbmRleE9mKCcgJykgPiAtMSkge1xuICAgICAgY2xzLnNwbGl0KC9cXHMrLykuZm9yRWFjaChmdW5jdGlvbiAoYykgeyByZXR1cm4gZWwuY2xhc3NMaXN0LmFkZChjKTsgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLmNsYXNzTGlzdC5hZGQoY2xzKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGN1ciA9IFwiIFwiICsgKGVsLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSB8fCAnJykgKyBcIiBcIjtcbiAgICBpZiAoY3VyLmluZGV4T2YoJyAnICsgY2xzICsgJyAnKSA8IDApIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAoY3VyICsgY2xzKS50cmltKCkpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZSBjbGFzcyB3aXRoIGNvbXBhdGliaWxpdHkgZm9yIFNWRyBzaW5jZSBjbGFzc0xpc3QgaXMgbm90IHN1cHBvcnRlZCBvblxuICogU1ZHIGVsZW1lbnRzIGluIElFXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUNsYXNzIChlbCwgY2xzKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIWNscyB8fCAhKGNscyA9IGNscy50cmltKCkpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoZWwuY2xhc3NMaXN0KSB7XG4gICAgaWYgKGNscy5pbmRleE9mKCcgJykgPiAtMSkge1xuICAgICAgY2xzLnNwbGl0KC9cXHMrLykuZm9yRWFjaChmdW5jdGlvbiAoYykgeyByZXR1cm4gZWwuY2xhc3NMaXN0LnJlbW92ZShjKTsgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoY2xzKTtcbiAgICB9XG4gICAgaWYgKCFlbC5jbGFzc0xpc3QubGVuZ3RoKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ2NsYXNzJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBjdXIgPSBcIiBcIiArIChlbC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgfHwgJycpICsgXCIgXCI7XG4gICAgdmFyIHRhciA9ICcgJyArIGNscyArICcgJztcbiAgICB3aGlsZSAoY3VyLmluZGV4T2YodGFyKSA+PSAwKSB7XG4gICAgICBjdXIgPSBjdXIucmVwbGFjZSh0YXIsICcgJyk7XG4gICAgfVxuICAgIGN1ciA9IGN1ci50cmltKCk7XG4gICAgaWYgKGN1cikge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIGN1cik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSgnY2xhc3MnKTtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIHJlc29sdmVUcmFuc2l0aW9uIChkZWYpIHtcbiAgaWYgKCFkZWYpIHtcbiAgICByZXR1cm5cbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAodHlwZW9mIGRlZiA9PT0gJ29iamVjdCcpIHtcbiAgICB2YXIgcmVzID0ge307XG4gICAgaWYgKGRlZi5jc3MgIT09IGZhbHNlKSB7XG4gICAgICBleHRlbmQocmVzLCBhdXRvQ3NzVHJhbnNpdGlvbihkZWYubmFtZSB8fCAndicpKTtcbiAgICB9XG4gICAgZXh0ZW5kKHJlcywgZGVmKTtcbiAgICByZXR1cm4gcmVzXG4gIH0gZWxzZSBpZiAodHlwZW9mIGRlZiA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gYXV0b0Nzc1RyYW5zaXRpb24oZGVmKVxuICB9XG59XG5cbnZhciBhdXRvQ3NzVHJhbnNpdGlvbiA9IGNhY2hlZChmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4ge1xuICAgIGVudGVyQ2xhc3M6IChuYW1lICsgXCItZW50ZXJcIiksXG4gICAgZW50ZXJUb0NsYXNzOiAobmFtZSArIFwiLWVudGVyLXRvXCIpLFxuICAgIGVudGVyQWN0aXZlQ2xhc3M6IChuYW1lICsgXCItZW50ZXItYWN0aXZlXCIpLFxuICAgIGxlYXZlQ2xhc3M6IChuYW1lICsgXCItbGVhdmVcIiksXG4gICAgbGVhdmVUb0NsYXNzOiAobmFtZSArIFwiLWxlYXZlLXRvXCIpLFxuICAgIGxlYXZlQWN0aXZlQ2xhc3M6IChuYW1lICsgXCItbGVhdmUtYWN0aXZlXCIpXG4gIH1cbn0pO1xuXG52YXIgaGFzVHJhbnNpdGlvbiA9IGluQnJvd3NlciAmJiAhaXNJRTk7XG52YXIgVFJBTlNJVElPTiA9ICd0cmFuc2l0aW9uJztcbnZhciBBTklNQVRJT04gPSAnYW5pbWF0aW9uJztcblxuLy8gVHJhbnNpdGlvbiBwcm9wZXJ0eS9ldmVudCBzbmlmZmluZ1xudmFyIHRyYW5zaXRpb25Qcm9wID0gJ3RyYW5zaXRpb24nO1xudmFyIHRyYW5zaXRpb25FbmRFdmVudCA9ICd0cmFuc2l0aW9uZW5kJztcbnZhciBhbmltYXRpb25Qcm9wID0gJ2FuaW1hdGlvbic7XG52YXIgYW5pbWF0aW9uRW5kRXZlbnQgPSAnYW5pbWF0aW9uZW5kJztcbmlmIChoYXNUcmFuc2l0aW9uKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAod2luZG93Lm9udHJhbnNpdGlvbmVuZCA9PT0gdW5kZWZpbmVkICYmXG4gICAgd2luZG93Lm9ud2Via2l0dHJhbnNpdGlvbmVuZCAhPT0gdW5kZWZpbmVkXG4gICkge1xuICAgIHRyYW5zaXRpb25Qcm9wID0gJ1dlYmtpdFRyYW5zaXRpb24nO1xuICAgIHRyYW5zaXRpb25FbmRFdmVudCA9ICd3ZWJraXRUcmFuc2l0aW9uRW5kJztcbiAgfVxuICBpZiAod2luZG93Lm9uYW5pbWF0aW9uZW5kID09PSB1bmRlZmluZWQgJiZcbiAgICB3aW5kb3cub253ZWJraXRhbmltYXRpb25lbmQgIT09IHVuZGVmaW5lZFxuICApIHtcbiAgICBhbmltYXRpb25Qcm9wID0gJ1dlYmtpdEFuaW1hdGlvbic7XG4gICAgYW5pbWF0aW9uRW5kRXZlbnQgPSAnd2Via2l0QW5pbWF0aW9uRW5kJztcbiAgfVxufVxuXG4vLyBiaW5kaW5nIHRvIHdpbmRvdyBpcyBuZWNlc3NhcnkgdG8gbWFrZSBob3QgcmVsb2FkIHdvcmsgaW4gSUUgaW4gc3RyaWN0IG1vZGVcbnZhciByYWYgPSBpbkJyb3dzZXJcbiAgPyB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gICAgPyB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lLmJpbmQod2luZG93KVxuICAgIDogc2V0VGltZW91dFxuICA6IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIGZ1bmN0aW9uIChmbikgeyByZXR1cm4gZm4oKTsgfTtcblxuZnVuY3Rpb24gbmV4dEZyYW1lIChmbikge1xuICByYWYoZnVuY3Rpb24gKCkge1xuICAgIHJhZihmbik7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBhZGRUcmFuc2l0aW9uQ2xhc3MgKGVsLCBjbHMpIHtcbiAgdmFyIHRyYW5zaXRpb25DbGFzc2VzID0gZWwuX3RyYW5zaXRpb25DbGFzc2VzIHx8IChlbC5fdHJhbnNpdGlvbkNsYXNzZXMgPSBbXSk7XG4gIGlmICh0cmFuc2l0aW9uQ2xhc3Nlcy5pbmRleE9mKGNscykgPCAwKSB7XG4gICAgdHJhbnNpdGlvbkNsYXNzZXMucHVzaChjbHMpO1xuICAgIGFkZENsYXNzKGVsLCBjbHMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVRyYW5zaXRpb25DbGFzcyAoZWwsIGNscykge1xuICBpZiAoZWwuX3RyYW5zaXRpb25DbGFzc2VzKSB7XG4gICAgcmVtb3ZlKGVsLl90cmFuc2l0aW9uQ2xhc3NlcywgY2xzKTtcbiAgfVxuICByZW1vdmVDbGFzcyhlbCwgY2xzKTtcbn1cblxuZnVuY3Rpb24gd2hlblRyYW5zaXRpb25FbmRzIChcbiAgZWwsXG4gIGV4cGVjdGVkVHlwZSxcbiAgY2Jcbikge1xuICB2YXIgcmVmID0gZ2V0VHJhbnNpdGlvbkluZm8oZWwsIGV4cGVjdGVkVHlwZSk7XG4gIHZhciB0eXBlID0gcmVmLnR5cGU7XG4gIHZhciB0aW1lb3V0ID0gcmVmLnRpbWVvdXQ7XG4gIHZhciBwcm9wQ291bnQgPSByZWYucHJvcENvdW50O1xuICBpZiAoIXR5cGUpIHsgcmV0dXJuIGNiKCkgfVxuICB2YXIgZXZlbnQgPSB0eXBlID09PSBUUkFOU0lUSU9OID8gdHJhbnNpdGlvbkVuZEV2ZW50IDogYW5pbWF0aW9uRW5kRXZlbnQ7XG4gIHZhciBlbmRlZCA9IDA7XG4gIHZhciBlbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgb25FbmQpO1xuICAgIGNiKCk7XG4gIH07XG4gIHZhciBvbkVuZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGUudGFyZ2V0ID09PSBlbCkge1xuICAgICAgaWYgKCsrZW5kZWQgPj0gcHJvcENvdW50KSB7XG4gICAgICAgIGVuZCgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGVuZGVkIDwgcHJvcENvdW50KSB7XG4gICAgICBlbmQoKTtcbiAgICB9XG4gIH0sIHRpbWVvdXQgKyAxKTtcbiAgZWwuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgb25FbmQpO1xufVxuXG52YXIgdHJhbnNmb3JtUkUgPSAvXFxiKHRyYW5zZm9ybXxhbGwpKCx8JCkvO1xuXG5mdW5jdGlvbiBnZXRUcmFuc2l0aW9uSW5mbyAoZWwsIGV4cGVjdGVkVHlwZSkge1xuICB2YXIgc3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpO1xuICB2YXIgdHJhbnNpdGlvbkRlbGF5cyA9IHN0eWxlc1t0cmFuc2l0aW9uUHJvcCArICdEZWxheSddLnNwbGl0KCcsICcpO1xuICB2YXIgdHJhbnNpdGlvbkR1cmF0aW9ucyA9IHN0eWxlc1t0cmFuc2l0aW9uUHJvcCArICdEdXJhdGlvbiddLnNwbGl0KCcsICcpO1xuICB2YXIgdHJhbnNpdGlvblRpbWVvdXQgPSBnZXRUaW1lb3V0KHRyYW5zaXRpb25EZWxheXMsIHRyYW5zaXRpb25EdXJhdGlvbnMpO1xuICB2YXIgYW5pbWF0aW9uRGVsYXlzID0gc3R5bGVzW2FuaW1hdGlvblByb3AgKyAnRGVsYXknXS5zcGxpdCgnLCAnKTtcbiAgdmFyIGFuaW1hdGlvbkR1cmF0aW9ucyA9IHN0eWxlc1thbmltYXRpb25Qcm9wICsgJ0R1cmF0aW9uJ10uc3BsaXQoJywgJyk7XG4gIHZhciBhbmltYXRpb25UaW1lb3V0ID0gZ2V0VGltZW91dChhbmltYXRpb25EZWxheXMsIGFuaW1hdGlvbkR1cmF0aW9ucyk7XG5cbiAgdmFyIHR5cGU7XG4gIHZhciB0aW1lb3V0ID0gMDtcbiAgdmFyIHByb3BDb3VudCA9IDA7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoZXhwZWN0ZWRUeXBlID09PSBUUkFOU0lUSU9OKSB7XG4gICAgaWYgKHRyYW5zaXRpb25UaW1lb3V0ID4gMCkge1xuICAgICAgdHlwZSA9IFRSQU5TSVRJT047XG4gICAgICB0aW1lb3V0ID0gdHJhbnNpdGlvblRpbWVvdXQ7XG4gICAgICBwcm9wQ291bnQgPSB0cmFuc2l0aW9uRHVyYXRpb25zLmxlbmd0aDtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSBBTklNQVRJT04pIHtcbiAgICBpZiAoYW5pbWF0aW9uVGltZW91dCA+IDApIHtcbiAgICAgIHR5cGUgPSBBTklNQVRJT047XG4gICAgICB0aW1lb3V0ID0gYW5pbWF0aW9uVGltZW91dDtcbiAgICAgIHByb3BDb3VudCA9IGFuaW1hdGlvbkR1cmF0aW9ucy5sZW5ndGg7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRpbWVvdXQgPSBNYXRoLm1heCh0cmFuc2l0aW9uVGltZW91dCwgYW5pbWF0aW9uVGltZW91dCk7XG4gICAgdHlwZSA9IHRpbWVvdXQgPiAwXG4gICAgICA/IHRyYW5zaXRpb25UaW1lb3V0ID4gYW5pbWF0aW9uVGltZW91dFxuICAgICAgICA/IFRSQU5TSVRJT05cbiAgICAgICAgOiBBTklNQVRJT05cbiAgICAgIDogbnVsbDtcbiAgICBwcm9wQ291bnQgPSB0eXBlXG4gICAgICA/IHR5cGUgPT09IFRSQU5TSVRJT05cbiAgICAgICAgPyB0cmFuc2l0aW9uRHVyYXRpb25zLmxlbmd0aFxuICAgICAgICA6IGFuaW1hdGlvbkR1cmF0aW9ucy5sZW5ndGhcbiAgICAgIDogMDtcbiAgfVxuICB2YXIgaGFzVHJhbnNmb3JtID1cbiAgICB0eXBlID09PSBUUkFOU0lUSU9OICYmXG4gICAgdHJhbnNmb3JtUkUudGVzdChzdHlsZXNbdHJhbnNpdGlvblByb3AgKyAnUHJvcGVydHknXSk7XG4gIHJldHVybiB7XG4gICAgdHlwZTogdHlwZSxcbiAgICB0aW1lb3V0OiB0aW1lb3V0LFxuICAgIHByb3BDb3VudDogcHJvcENvdW50LFxuICAgIGhhc1RyYW5zZm9ybTogaGFzVHJhbnNmb3JtXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0VGltZW91dCAoZGVsYXlzLCBkdXJhdGlvbnMpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgd2hpbGUgKGRlbGF5cy5sZW5ndGggPCBkdXJhdGlvbnMubGVuZ3RoKSB7XG4gICAgZGVsYXlzID0gZGVsYXlzLmNvbmNhdChkZWxheXMpO1xuICB9XG5cbiAgcmV0dXJuIE1hdGgubWF4LmFwcGx5KG51bGwsIGR1cmF0aW9ucy5tYXAoZnVuY3Rpb24gKGQsIGkpIHtcbiAgICByZXR1cm4gdG9NcyhkKSArIHRvTXMoZGVsYXlzW2ldKVxuICB9KSlcbn1cblxuZnVuY3Rpb24gdG9NcyAocykge1xuICByZXR1cm4gTnVtYmVyKHMuc2xpY2UoMCwgLTEpKSAqIDEwMDBcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGVudGVyICh2bm9kZSwgdG9nZ2xlRGlzcGxheSkge1xuICB2YXIgZWwgPSB2bm9kZS5lbG07XG5cbiAgLy8gY2FsbCBsZWF2ZSBjYWxsYmFjayBub3dcbiAgaWYgKGlzRGVmKGVsLl9sZWF2ZUNiKSkge1xuICAgIGVsLl9sZWF2ZUNiLmNhbmNlbGxlZCA9IHRydWU7XG4gICAgZWwuX2xlYXZlQ2IoKTtcbiAgfVxuXG4gIHZhciBkYXRhID0gcmVzb2x2ZVRyYW5zaXRpb24odm5vZGUuZGF0YS50cmFuc2l0aW9uKTtcbiAgaWYgKGlzVW5kZWYoZGF0YSkpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNEZWYoZWwuX2VudGVyQ2IpIHx8IGVsLm5vZGVUeXBlICE9PSAxKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgY3NzID0gZGF0YS5jc3M7XG4gIHZhciB0eXBlID0gZGF0YS50eXBlO1xuICB2YXIgZW50ZXJDbGFzcyA9IGRhdGEuZW50ZXJDbGFzcztcbiAgdmFyIGVudGVyVG9DbGFzcyA9IGRhdGEuZW50ZXJUb0NsYXNzO1xuICB2YXIgZW50ZXJBY3RpdmVDbGFzcyA9IGRhdGEuZW50ZXJBY3RpdmVDbGFzcztcbiAgdmFyIGFwcGVhckNsYXNzID0gZGF0YS5hcHBlYXJDbGFzcztcbiAgdmFyIGFwcGVhclRvQ2xhc3MgPSBkYXRhLmFwcGVhclRvQ2xhc3M7XG4gIHZhciBhcHBlYXJBY3RpdmVDbGFzcyA9IGRhdGEuYXBwZWFyQWN0aXZlQ2xhc3M7XG4gIHZhciBiZWZvcmVFbnRlciA9IGRhdGEuYmVmb3JlRW50ZXI7XG4gIHZhciBlbnRlciA9IGRhdGEuZW50ZXI7XG4gIHZhciBhZnRlckVudGVyID0gZGF0YS5hZnRlckVudGVyO1xuICB2YXIgZW50ZXJDYW5jZWxsZWQgPSBkYXRhLmVudGVyQ2FuY2VsbGVkO1xuICB2YXIgYmVmb3JlQXBwZWFyID0gZGF0YS5iZWZvcmVBcHBlYXI7XG4gIHZhciBhcHBlYXIgPSBkYXRhLmFwcGVhcjtcbiAgdmFyIGFmdGVyQXBwZWFyID0gZGF0YS5hZnRlckFwcGVhcjtcbiAgdmFyIGFwcGVhckNhbmNlbGxlZCA9IGRhdGEuYXBwZWFyQ2FuY2VsbGVkO1xuICB2YXIgZHVyYXRpb24gPSBkYXRhLmR1cmF0aW9uO1xuXG4gIC8vIGFjdGl2ZUluc3RhbmNlIHdpbGwgYWx3YXlzIGJlIHRoZSA8dHJhbnNpdGlvbj4gY29tcG9uZW50IG1hbmFnaW5nIHRoaXNcbiAgLy8gdHJhbnNpdGlvbi4gT25lIGVkZ2UgY2FzZSB0byBjaGVjayBpcyB3aGVuIHRoZSA8dHJhbnNpdGlvbj4gaXMgcGxhY2VkXG4gIC8vIGFzIHRoZSByb290IG5vZGUgb2YgYSBjaGlsZCBjb21wb25lbnQuIEluIHRoYXQgY2FzZSB3ZSBuZWVkIHRvIGNoZWNrXG4gIC8vIDx0cmFuc2l0aW9uPidzIHBhcmVudCBmb3IgYXBwZWFyIGNoZWNrLlxuICB2YXIgY29udGV4dCA9IGFjdGl2ZUluc3RhbmNlO1xuICB2YXIgdHJhbnNpdGlvbk5vZGUgPSBhY3RpdmVJbnN0YW5jZS4kdm5vZGU7XG4gIHdoaWxlICh0cmFuc2l0aW9uTm9kZSAmJiB0cmFuc2l0aW9uTm9kZS5wYXJlbnQpIHtcbiAgICB0cmFuc2l0aW9uTm9kZSA9IHRyYW5zaXRpb25Ob2RlLnBhcmVudDtcbiAgICBjb250ZXh0ID0gdHJhbnNpdGlvbk5vZGUuY29udGV4dDtcbiAgfVxuXG4gIHZhciBpc0FwcGVhciA9ICFjb250ZXh0Ll9pc01vdW50ZWQgfHwgIXZub2RlLmlzUm9vdEluc2VydDtcblxuICBpZiAoaXNBcHBlYXIgJiYgIWFwcGVhciAmJiBhcHBlYXIgIT09ICcnKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgc3RhcnRDbGFzcyA9IGlzQXBwZWFyICYmIGFwcGVhckNsYXNzXG4gICAgPyBhcHBlYXJDbGFzc1xuICAgIDogZW50ZXJDbGFzcztcbiAgdmFyIGFjdGl2ZUNsYXNzID0gaXNBcHBlYXIgJiYgYXBwZWFyQWN0aXZlQ2xhc3NcbiAgICA/IGFwcGVhckFjdGl2ZUNsYXNzXG4gICAgOiBlbnRlckFjdGl2ZUNsYXNzO1xuICB2YXIgdG9DbGFzcyA9IGlzQXBwZWFyICYmIGFwcGVhclRvQ2xhc3NcbiAgICA/IGFwcGVhclRvQ2xhc3NcbiAgICA6IGVudGVyVG9DbGFzcztcblxuICB2YXIgYmVmb3JlRW50ZXJIb29rID0gaXNBcHBlYXJcbiAgICA/IChiZWZvcmVBcHBlYXIgfHwgYmVmb3JlRW50ZXIpXG4gICAgOiBiZWZvcmVFbnRlcjtcbiAgdmFyIGVudGVySG9vayA9IGlzQXBwZWFyXG4gICAgPyAodHlwZW9mIGFwcGVhciA9PT0gJ2Z1bmN0aW9uJyA/IGFwcGVhciA6IGVudGVyKVxuICAgIDogZW50ZXI7XG4gIHZhciBhZnRlckVudGVySG9vayA9IGlzQXBwZWFyXG4gICAgPyAoYWZ0ZXJBcHBlYXIgfHwgYWZ0ZXJFbnRlcilcbiAgICA6IGFmdGVyRW50ZXI7XG4gIHZhciBlbnRlckNhbmNlbGxlZEhvb2sgPSBpc0FwcGVhclxuICAgID8gKGFwcGVhckNhbmNlbGxlZCB8fCBlbnRlckNhbmNlbGxlZClcbiAgICA6IGVudGVyQ2FuY2VsbGVkO1xuXG4gIHZhciBleHBsaWNpdEVudGVyRHVyYXRpb24gPSB0b051bWJlcihcbiAgICBpc09iamVjdChkdXJhdGlvbilcbiAgICAgID8gZHVyYXRpb24uZW50ZXJcbiAgICAgIDogZHVyYXRpb25cbiAgKTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBleHBsaWNpdEVudGVyRHVyYXRpb24gIT0gbnVsbCkge1xuICAgIGNoZWNrRHVyYXRpb24oZXhwbGljaXRFbnRlckR1cmF0aW9uLCAnZW50ZXInLCB2bm9kZSk7XG4gIH1cblxuICB2YXIgZXhwZWN0c0NTUyA9IGNzcyAhPT0gZmFsc2UgJiYgIWlzSUU5O1xuICB2YXIgdXNlcldhbnRzQ29udHJvbCA9IGdldEhvb2tBcmd1bWVudHNMZW5ndGgoZW50ZXJIb29rKTtcblxuICB2YXIgY2IgPSBlbC5fZW50ZXJDYiA9IG9uY2UoZnVuY3Rpb24gKCkge1xuICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIHRvQ2xhc3MpO1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBhY3RpdmVDbGFzcyk7XG4gICAgfVxuICAgIGlmIChjYi5jYW5jZWxsZWQpIHtcbiAgICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgc3RhcnRDbGFzcyk7XG4gICAgICB9XG4gICAgICBlbnRlckNhbmNlbGxlZEhvb2sgJiYgZW50ZXJDYW5jZWxsZWRIb29rKGVsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWZ0ZXJFbnRlckhvb2sgJiYgYWZ0ZXJFbnRlckhvb2soZWwpO1xuICAgIH1cbiAgICBlbC5fZW50ZXJDYiA9IG51bGw7XG4gIH0pO1xuXG4gIGlmICghdm5vZGUuZGF0YS5zaG93KSB7XG4gICAgLy8gcmVtb3ZlIHBlbmRpbmcgbGVhdmUgZWxlbWVudCBvbiBlbnRlciBieSBpbmplY3RpbmcgYW4gaW5zZXJ0IGhvb2tcbiAgICBtZXJnZVZOb2RlSG9vayh2bm9kZSwgJ2luc2VydCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBwYXJlbnQgPSBlbC5wYXJlbnROb2RlO1xuICAgICAgdmFyIHBlbmRpbmdOb2RlID0gcGFyZW50ICYmIHBhcmVudC5fcGVuZGluZyAmJiBwYXJlbnQuX3BlbmRpbmdbdm5vZGUua2V5XTtcbiAgICAgIGlmIChwZW5kaW5nTm9kZSAmJlxuICAgICAgICBwZW5kaW5nTm9kZS50YWcgPT09IHZub2RlLnRhZyAmJlxuICAgICAgICBwZW5kaW5nTm9kZS5lbG0uX2xlYXZlQ2JcbiAgICAgICkge1xuICAgICAgICBwZW5kaW5nTm9kZS5lbG0uX2xlYXZlQ2IoKTtcbiAgICAgIH1cbiAgICAgIGVudGVySG9vayAmJiBlbnRlckhvb2soZWwsIGNiKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIHN0YXJ0IGVudGVyIHRyYW5zaXRpb25cbiAgYmVmb3JlRW50ZXJIb29rICYmIGJlZm9yZUVudGVySG9vayhlbCk7XG4gIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBzdGFydENsYXNzKTtcbiAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGFjdGl2ZUNsYXNzKTtcbiAgICBuZXh0RnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBzdGFydENsYXNzKTtcbiAgICAgIGlmICghY2IuY2FuY2VsbGVkKSB7XG4gICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgdG9DbGFzcyk7XG4gICAgICAgIGlmICghdXNlcldhbnRzQ29udHJvbCkge1xuICAgICAgICAgIGlmIChpc1ZhbGlkRHVyYXRpb24oZXhwbGljaXRFbnRlckR1cmF0aW9uKSkge1xuICAgICAgICAgICAgc2V0VGltZW91dChjYiwgZXhwbGljaXRFbnRlckR1cmF0aW9uKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2hlblRyYW5zaXRpb25FbmRzKGVsLCB0eXBlLCBjYik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBpZiAodm5vZGUuZGF0YS5zaG93KSB7XG4gICAgdG9nZ2xlRGlzcGxheSAmJiB0b2dnbGVEaXNwbGF5KCk7XG4gICAgZW50ZXJIb29rICYmIGVudGVySG9vayhlbCwgY2IpO1xuICB9XG5cbiAgaWYgKCFleHBlY3RzQ1NTICYmICF1c2VyV2FudHNDb250cm9sKSB7XG4gICAgY2IoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBsZWF2ZSAodm5vZGUsIHJtKSB7XG4gIHZhciBlbCA9IHZub2RlLmVsbTtcblxuICAvLyBjYWxsIGVudGVyIGNhbGxiYWNrIG5vd1xuICBpZiAoaXNEZWYoZWwuX2VudGVyQ2IpKSB7XG4gICAgZWwuX2VudGVyQ2IuY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICBlbC5fZW50ZXJDYigpO1xuICB9XG5cbiAgdmFyIGRhdGEgPSByZXNvbHZlVHJhbnNpdGlvbih2bm9kZS5kYXRhLnRyYW5zaXRpb24pO1xuICBpZiAoaXNVbmRlZihkYXRhKSB8fCBlbC5ub2RlVHlwZSAhPT0gMSkge1xuICAgIHJldHVybiBybSgpXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGlzRGVmKGVsLl9sZWF2ZUNiKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGNzcyA9IGRhdGEuY3NzO1xuICB2YXIgdHlwZSA9IGRhdGEudHlwZTtcbiAgdmFyIGxlYXZlQ2xhc3MgPSBkYXRhLmxlYXZlQ2xhc3M7XG4gIHZhciBsZWF2ZVRvQ2xhc3MgPSBkYXRhLmxlYXZlVG9DbGFzcztcbiAgdmFyIGxlYXZlQWN0aXZlQ2xhc3MgPSBkYXRhLmxlYXZlQWN0aXZlQ2xhc3M7XG4gIHZhciBiZWZvcmVMZWF2ZSA9IGRhdGEuYmVmb3JlTGVhdmU7XG4gIHZhciBsZWF2ZSA9IGRhdGEubGVhdmU7XG4gIHZhciBhZnRlckxlYXZlID0gZGF0YS5hZnRlckxlYXZlO1xuICB2YXIgbGVhdmVDYW5jZWxsZWQgPSBkYXRhLmxlYXZlQ2FuY2VsbGVkO1xuICB2YXIgZGVsYXlMZWF2ZSA9IGRhdGEuZGVsYXlMZWF2ZTtcbiAgdmFyIGR1cmF0aW9uID0gZGF0YS5kdXJhdGlvbjtcblxuICB2YXIgZXhwZWN0c0NTUyA9IGNzcyAhPT0gZmFsc2UgJiYgIWlzSUU5O1xuICB2YXIgdXNlcldhbnRzQ29udHJvbCA9IGdldEhvb2tBcmd1bWVudHNMZW5ndGgobGVhdmUpO1xuXG4gIHZhciBleHBsaWNpdExlYXZlRHVyYXRpb24gPSB0b051bWJlcihcbiAgICBpc09iamVjdChkdXJhdGlvbilcbiAgICAgID8gZHVyYXRpb24ubGVhdmVcbiAgICAgIDogZHVyYXRpb25cbiAgKTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBpc0RlZihleHBsaWNpdExlYXZlRHVyYXRpb24pKSB7XG4gICAgY2hlY2tEdXJhdGlvbihleHBsaWNpdExlYXZlRHVyYXRpb24sICdsZWF2ZScsIHZub2RlKTtcbiAgfVxuXG4gIHZhciBjYiA9IGVsLl9sZWF2ZUNiID0gb25jZShmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGVsLnBhcmVudE5vZGUgJiYgZWwucGFyZW50Tm9kZS5fcGVuZGluZykge1xuICAgICAgZWwucGFyZW50Tm9kZS5fcGVuZGluZ1t2bm9kZS5rZXldID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVUb0NsYXNzKTtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVBY3RpdmVDbGFzcyk7XG4gICAgfVxuICAgIGlmIChjYi5jYW5jZWxsZWQpIHtcbiAgICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVDbGFzcyk7XG4gICAgICB9XG4gICAgICBsZWF2ZUNhbmNlbGxlZCAmJiBsZWF2ZUNhbmNlbGxlZChlbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJtKCk7XG4gICAgICBhZnRlckxlYXZlICYmIGFmdGVyTGVhdmUoZWwpO1xuICAgIH1cbiAgICBlbC5fbGVhdmVDYiA9IG51bGw7XG4gIH0pO1xuXG4gIGlmIChkZWxheUxlYXZlKSB7XG4gICAgZGVsYXlMZWF2ZShwZXJmb3JtTGVhdmUpO1xuICB9IGVsc2Uge1xuICAgIHBlcmZvcm1MZWF2ZSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVyZm9ybUxlYXZlICgpIHtcbiAgICAvLyB0aGUgZGVsYXllZCBsZWF2ZSBtYXkgaGF2ZSBhbHJlYWR5IGJlZW4gY2FuY2VsbGVkXG4gICAgaWYgKGNiLmNhbmNlbGxlZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIC8vIHJlY29yZCBsZWF2aW5nIGVsZW1lbnRcbiAgICBpZiAoIXZub2RlLmRhdGEuc2hvdykge1xuICAgICAgKGVsLnBhcmVudE5vZGUuX3BlbmRpbmcgfHwgKGVsLnBhcmVudE5vZGUuX3BlbmRpbmcgPSB7fSkpWyh2bm9kZS5rZXkpXSA9IHZub2RlO1xuICAgIH1cbiAgICBiZWZvcmVMZWF2ZSAmJiBiZWZvcmVMZWF2ZShlbCk7XG4gICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVDbGFzcyk7XG4gICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQWN0aXZlQ2xhc3MpO1xuICAgICAgbmV4dEZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUNsYXNzKTtcbiAgICAgICAgaWYgKCFjYi5jYW5jZWxsZWQpIHtcbiAgICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlVG9DbGFzcyk7XG4gICAgICAgICAgaWYgKCF1c2VyV2FudHNDb250cm9sKSB7XG4gICAgICAgICAgICBpZiAoaXNWYWxpZER1cmF0aW9uKGV4cGxpY2l0TGVhdmVEdXJhdGlvbikpIHtcbiAgICAgICAgICAgICAgc2V0VGltZW91dChjYiwgZXhwbGljaXRMZWF2ZUR1cmF0aW9uKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHdoZW5UcmFuc2l0aW9uRW5kcyhlbCwgdHlwZSwgY2IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGxlYXZlICYmIGxlYXZlKGVsLCBjYik7XG4gICAgaWYgKCFleHBlY3RzQ1NTICYmICF1c2VyV2FudHNDb250cm9sKSB7XG4gICAgICBjYigpO1xuICAgIH1cbiAgfVxufVxuXG4vLyBvbmx5IHVzZWQgaW4gZGV2IG1vZGVcbmZ1bmN0aW9uIGNoZWNrRHVyYXRpb24gKHZhbCwgbmFtZSwgdm5vZGUpIHtcbiAgaWYgKHR5cGVvZiB2YWwgIT09ICdudW1iZXInKSB7XG4gICAgd2FybihcbiAgICAgIFwiPHRyYW5zaXRpb24+IGV4cGxpY2l0IFwiICsgbmFtZSArIFwiIGR1cmF0aW9uIGlzIG5vdCBhIHZhbGlkIG51bWJlciAtIFwiICtcbiAgICAgIFwiZ290IFwiICsgKEpTT04uc3RyaW5naWZ5KHZhbCkpICsgXCIuXCIsXG4gICAgICB2bm9kZS5jb250ZXh0XG4gICAgKTtcbiAgfSBlbHNlIGlmIChpc05hTih2YWwpKSB7XG4gICAgd2FybihcbiAgICAgIFwiPHRyYW5zaXRpb24+IGV4cGxpY2l0IFwiICsgbmFtZSArIFwiIGR1cmF0aW9uIGlzIE5hTiAtIFwiICtcbiAgICAgICd0aGUgZHVyYXRpb24gZXhwcmVzc2lvbiBtaWdodCBiZSBpbmNvcnJlY3QuJyxcbiAgICAgIHZub2RlLmNvbnRleHRcbiAgICApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzVmFsaWREdXJhdGlvbiAodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAnbnVtYmVyJyAmJiAhaXNOYU4odmFsKVxufVxuXG4vKipcbiAqIE5vcm1hbGl6ZSBhIHRyYW5zaXRpb24gaG9vaydzIGFyZ3VtZW50IGxlbmd0aC4gVGhlIGhvb2sgbWF5IGJlOlxuICogLSBhIG1lcmdlZCBob29rIChpbnZva2VyKSB3aXRoIHRoZSBvcmlnaW5hbCBpbiAuZm5zXG4gKiAtIGEgd3JhcHBlZCBjb21wb25lbnQgbWV0aG9kIChjaGVjayAuX2xlbmd0aClcbiAqIC0gYSBwbGFpbiBmdW5jdGlvbiAoLmxlbmd0aClcbiAqL1xuZnVuY3Rpb24gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aCAoZm4pIHtcbiAgaWYgKGlzVW5kZWYoZm4pKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgdmFyIGludm9rZXJGbnMgPSBmbi5mbnM7XG4gIGlmIChpc0RlZihpbnZva2VyRm5zKSkge1xuICAgIC8vIGludm9rZXJcbiAgICByZXR1cm4gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aChcbiAgICAgIEFycmF5LmlzQXJyYXkoaW52b2tlckZucylcbiAgICAgICAgPyBpbnZva2VyRm5zWzBdXG4gICAgICAgIDogaW52b2tlckZuc1xuICAgIClcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKGZuLl9sZW5ndGggfHwgZm4ubGVuZ3RoKSA+IDFcbiAgfVxufVxuXG5mdW5jdGlvbiBfZW50ZXIgKF8sIHZub2RlKSB7XG4gIGlmICh2bm9kZS5kYXRhLnNob3cgIT09IHRydWUpIHtcbiAgICBlbnRlcih2bm9kZSk7XG4gIH1cbn1cblxudmFyIHRyYW5zaXRpb24gPSBpbkJyb3dzZXIgPyB7XG4gIGNyZWF0ZTogX2VudGVyLFxuICBhY3RpdmF0ZTogX2VudGVyLFxuICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSQkMSAodm5vZGUsIHJtKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAodm5vZGUuZGF0YS5zaG93ICE9PSB0cnVlKSB7XG4gICAgICBsZWF2ZSh2bm9kZSwgcm0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBybSgpO1xuICAgIH1cbiAgfVxufSA6IHt9XG5cbnZhciBwbGF0Zm9ybU1vZHVsZXMgPSBbXG4gIGF0dHJzLFxuICBrbGFzcyxcbiAgZXZlbnRzLFxuICBkb21Qcm9wcyxcbiAgc3R5bGUsXG4gIHRyYW5zaXRpb25cbl1cblxuLyogICovXG5cbi8vIHRoZSBkaXJlY3RpdmUgbW9kdWxlIHNob3VsZCBiZSBhcHBsaWVkIGxhc3QsIGFmdGVyIGFsbFxuLy8gYnVpbHQtaW4gbW9kdWxlcyBoYXZlIGJlZW4gYXBwbGllZC5cbnZhciBtb2R1bGVzID0gcGxhdGZvcm1Nb2R1bGVzLmNvbmNhdChiYXNlTW9kdWxlcyk7XG5cbnZhciBwYXRjaCA9IGNyZWF0ZVBhdGNoRnVuY3Rpb24oeyBub2RlT3BzOiBub2RlT3BzLCBtb2R1bGVzOiBtb2R1bGVzIH0pO1xuXG4vKipcbiAqIE5vdCB0eXBlIGNoZWNraW5nIHRoaXMgZmlsZSBiZWNhdXNlIGZsb3cgZG9lc24ndCBsaWtlIGF0dGFjaGluZ1xuICogcHJvcGVydGllcyB0byBFbGVtZW50cy5cbiAqL1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbmlmIChpc0lFOSkge1xuICAvLyBodHRwOi8vd3d3Lm1hdHRzNDExLmNvbS9wb3N0L2ludGVybmV0LWV4cGxvcmVyLTktb25pbnB1dC9cbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignc2VsZWN0aW9uY2hhbmdlJywgZnVuY3Rpb24gKCkge1xuICAgIHZhciBlbCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgaWYgKGVsICYmIGVsLnZtb2RlbCkge1xuICAgICAgdHJpZ2dlcihlbCwgJ2lucHV0Jyk7XG4gICAgfVxuICB9KTtcbn1cblxudmFyIGRpcmVjdGl2ZSA9IHtcbiAgaW5zZXJ0ZWQ6IGZ1bmN0aW9uIGluc2VydGVkIChlbCwgYmluZGluZywgdm5vZGUsIG9sZFZub2RlKSB7XG4gICAgaWYgKHZub2RlLnRhZyA9PT0gJ3NlbGVjdCcpIHtcbiAgICAgIC8vICM2OTAzXG4gICAgICBpZiAob2xkVm5vZGUuZWxtICYmICFvbGRWbm9kZS5lbG0uX3ZPcHRpb25zKSB7XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLCAncG9zdHBhdGNoJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGRpcmVjdGl2ZS5jb21wb25lbnRVcGRhdGVkKGVsLCBiaW5kaW5nLCB2bm9kZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0U2VsZWN0ZWQoZWwsIGJpbmRpbmcsIHZub2RlLmNvbnRleHQpO1xuICAgICAgfVxuICAgICAgZWwuX3ZPcHRpb25zID0gW10ubWFwLmNhbGwoZWwub3B0aW9ucywgZ2V0VmFsdWUpO1xuICAgIH0gZWxzZSBpZiAodm5vZGUudGFnID09PSAndGV4dGFyZWEnIHx8IGlzVGV4dElucHV0VHlwZShlbC50eXBlKSkge1xuICAgICAgZWwuX3ZNb2RpZmllcnMgPSBiaW5kaW5nLm1vZGlmaWVycztcbiAgICAgIGlmICghYmluZGluZy5tb2RpZmllcnMubGF6eSkge1xuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjb21wb3NpdGlvbnN0YXJ0Jywgb25Db21wb3NpdGlvblN0YXJ0KTtcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY29tcG9zaXRpb25lbmQnLCBvbkNvbXBvc2l0aW9uRW5kKTtcbiAgICAgICAgLy8gU2FmYXJpIDwgMTAuMiAmIFVJV2ViVmlldyBkb2Vzbid0IGZpcmUgY29tcG9zaXRpb25lbmQgd2hlblxuICAgICAgICAvLyBzd2l0Y2hpbmcgZm9jdXMgYmVmb3JlIGNvbmZpcm1pbmcgY29tcG9zaXRpb24gY2hvaWNlXG4gICAgICAgIC8vIHRoaXMgYWxzbyBmaXhlcyB0aGUgaXNzdWUgd2hlcmUgc29tZSBicm93c2VycyBlLmcuIGlPUyBDaHJvbWVcbiAgICAgICAgLy8gZmlyZXMgXCJjaGFuZ2VcIiBpbnN0ZWFkIG9mIFwiaW5wdXRcIiBvbiBhdXRvY29tcGxldGUuXG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIG9uQ29tcG9zaXRpb25FbmQpO1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKGlzSUU5KSB7XG4gICAgICAgICAgZWwudm1vZGVsID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBjb21wb25lbnRVcGRhdGVkOiBmdW5jdGlvbiBjb21wb25lbnRVcGRhdGVkIChlbCwgYmluZGluZywgdm5vZGUpIHtcbiAgICBpZiAodm5vZGUudGFnID09PSAnc2VsZWN0Jykge1xuICAgICAgc2V0U2VsZWN0ZWQoZWwsIGJpbmRpbmcsIHZub2RlLmNvbnRleHQpO1xuICAgICAgLy8gaW4gY2FzZSB0aGUgb3B0aW9ucyByZW5kZXJlZCBieSB2LWZvciBoYXZlIGNoYW5nZWQsXG4gICAgICAvLyBpdCdzIHBvc3NpYmxlIHRoYXQgdGhlIHZhbHVlIGlzIG91dC1vZi1zeW5jIHdpdGggdGhlIHJlbmRlcmVkIG9wdGlvbnMuXG4gICAgICAvLyBkZXRlY3Qgc3VjaCBjYXNlcyBhbmQgZmlsdGVyIG91dCB2YWx1ZXMgdGhhdCBubyBsb25nZXIgaGFzIGEgbWF0Y2hpbmdcbiAgICAgIC8vIG9wdGlvbiBpbiB0aGUgRE9NLlxuICAgICAgdmFyIHByZXZPcHRpb25zID0gZWwuX3ZPcHRpb25zO1xuICAgICAgdmFyIGN1ck9wdGlvbnMgPSBlbC5fdk9wdGlvbnMgPSBbXS5tYXAuY2FsbChlbC5vcHRpb25zLCBnZXRWYWx1ZSk7XG4gICAgICBpZiAoY3VyT3B0aW9ucy5zb21lKGZ1bmN0aW9uIChvLCBpKSB7IHJldHVybiAhbG9vc2VFcXVhbChvLCBwcmV2T3B0aW9uc1tpXSk7IH0pKSB7XG4gICAgICAgIC8vIHRyaWdnZXIgY2hhbmdlIGV2ZW50IGlmXG4gICAgICAgIC8vIG5vIG1hdGNoaW5nIG9wdGlvbiBmb3VuZCBmb3IgYXQgbGVhc3Qgb25lIHZhbHVlXG4gICAgICAgIHZhciBuZWVkUmVzZXQgPSBlbC5tdWx0aXBsZVxuICAgICAgICAgID8gYmluZGluZy52YWx1ZS5zb21lKGZ1bmN0aW9uICh2KSB7IHJldHVybiBoYXNOb01hdGNoaW5nT3B0aW9uKHYsIGN1ck9wdGlvbnMpOyB9KVxuICAgICAgICAgIDogYmluZGluZy52YWx1ZSAhPT0gYmluZGluZy5vbGRWYWx1ZSAmJiBoYXNOb01hdGNoaW5nT3B0aW9uKGJpbmRpbmcudmFsdWUsIGN1ck9wdGlvbnMpO1xuICAgICAgICBpZiAobmVlZFJlc2V0KSB7XG4gICAgICAgICAgdHJpZ2dlcihlbCwgJ2NoYW5nZScpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBzZXRTZWxlY3RlZCAoZWwsIGJpbmRpbmcsIHZtKSB7XG4gIGFjdHVhbGx5U2V0U2VsZWN0ZWQoZWwsIGJpbmRpbmcsIHZtKTtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc0lFIHx8IGlzRWRnZSkge1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgYWN0dWFsbHlTZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm0pO1xuICAgIH0sIDApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFjdHVhbGx5U2V0U2VsZWN0ZWQgKGVsLCBiaW5kaW5nLCB2bSkge1xuICB2YXIgdmFsdWUgPSBiaW5kaW5nLnZhbHVlO1xuICB2YXIgaXNNdWx0aXBsZSA9IGVsLm11bHRpcGxlO1xuICBpZiAoaXNNdWx0aXBsZSAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICBcIjxzZWxlY3QgbXVsdGlwbGUgdi1tb2RlbD1cXFwiXCIgKyAoYmluZGluZy5leHByZXNzaW9uKSArIFwiXFxcIj4gXCIgK1xuICAgICAgXCJleHBlY3RzIGFuIEFycmF5IHZhbHVlIGZvciBpdHMgYmluZGluZywgYnV0IGdvdCBcIiArIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLnNsaWNlKDgsIC0xKSksXG4gICAgICB2bVxuICAgICk7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHNlbGVjdGVkLCBvcHRpb247XG4gIGZvciAodmFyIGkgPSAwLCBsID0gZWwub3B0aW9ucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBvcHRpb24gPSBlbC5vcHRpb25zW2ldO1xuICAgIGlmIChpc011bHRpcGxlKSB7XG4gICAgICBzZWxlY3RlZCA9IGxvb3NlSW5kZXhPZih2YWx1ZSwgZ2V0VmFsdWUob3B0aW9uKSkgPiAtMTtcbiAgICAgIGlmIChvcHRpb24uc2VsZWN0ZWQgIT09IHNlbGVjdGVkKSB7XG4gICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IHNlbGVjdGVkO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobG9vc2VFcXVhbChnZXRWYWx1ZShvcHRpb24pLCB2YWx1ZSkpIHtcbiAgICAgICAgaWYgKGVsLnNlbGVjdGVkSW5kZXggIT09IGkpIHtcbiAgICAgICAgICBlbC5zZWxlY3RlZEluZGV4ID0gaTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKCFpc011bHRpcGxlKSB7XG4gICAgZWwuc2VsZWN0ZWRJbmRleCA9IC0xO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhc05vTWF0Y2hpbmdPcHRpb24gKHZhbHVlLCBvcHRpb25zKSB7XG4gIHJldHVybiBvcHRpb25zLmV2ZXJ5KGZ1bmN0aW9uIChvKSB7IHJldHVybiAhbG9vc2VFcXVhbChvLCB2YWx1ZSk7IH0pXG59XG5cbmZ1bmN0aW9uIGdldFZhbHVlIChvcHRpb24pIHtcbiAgcmV0dXJuICdfdmFsdWUnIGluIG9wdGlvblxuICAgID8gb3B0aW9uLl92YWx1ZVxuICAgIDogb3B0aW9uLnZhbHVlXG59XG5cbmZ1bmN0aW9uIG9uQ29tcG9zaXRpb25TdGFydCAoZSkge1xuICBlLnRhcmdldC5jb21wb3NpbmcgPSB0cnVlO1xufVxuXG5mdW5jdGlvbiBvbkNvbXBvc2l0aW9uRW5kIChlKSB7XG4gIC8vIHByZXZlbnQgdHJpZ2dlcmluZyBhbiBpbnB1dCBldmVudCBmb3Igbm8gcmVhc29uXG4gIGlmICghZS50YXJnZXQuY29tcG9zaW5nKSB7IHJldHVybiB9XG4gIGUudGFyZ2V0LmNvbXBvc2luZyA9IGZhbHNlO1xuICB0cmlnZ2VyKGUudGFyZ2V0LCAnaW5wdXQnKTtcbn1cblxuZnVuY3Rpb24gdHJpZ2dlciAoZWwsIHR5cGUpIHtcbiAgdmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnSFRNTEV2ZW50cycpO1xuICBlLmluaXRFdmVudCh0eXBlLCB0cnVlLCB0cnVlKTtcbiAgZWwuZGlzcGF0Y2hFdmVudChlKTtcbn1cblxuLyogICovXG5cbi8vIHJlY3Vyc2l2ZWx5IHNlYXJjaCBmb3IgcG9zc2libGUgdHJhbnNpdGlvbiBkZWZpbmVkIGluc2lkZSB0aGUgY29tcG9uZW50IHJvb3RcbmZ1bmN0aW9uIGxvY2F0ZU5vZGUgKHZub2RlKSB7XG4gIHJldHVybiB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSAmJiAoIXZub2RlLmRhdGEgfHwgIXZub2RlLmRhdGEudHJhbnNpdGlvbilcbiAgICA/IGxvY2F0ZU5vZGUodm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlKVxuICAgIDogdm5vZGVcbn1cblxudmFyIHNob3cgPSB7XG4gIGJpbmQ6IGZ1bmN0aW9uIGJpbmQgKGVsLCByZWYsIHZub2RlKSB7XG4gICAgdmFyIHZhbHVlID0gcmVmLnZhbHVlO1xuXG4gICAgdm5vZGUgPSBsb2NhdGVOb2RlKHZub2RlKTtcbiAgICB2YXIgdHJhbnNpdGlvbiQkMSA9IHZub2RlLmRhdGEgJiYgdm5vZGUuZGF0YS50cmFuc2l0aW9uO1xuICAgIHZhciBvcmlnaW5hbERpc3BsYXkgPSBlbC5fX3ZPcmlnaW5hbERpc3BsYXkgPVxuICAgICAgZWwuc3R5bGUuZGlzcGxheSA9PT0gJ25vbmUnID8gJycgOiBlbC5zdHlsZS5kaXNwbGF5O1xuICAgIGlmICh2YWx1ZSAmJiB0cmFuc2l0aW9uJCQxKSB7XG4gICAgICB2bm9kZS5kYXRhLnNob3cgPSB0cnVlO1xuICAgICAgZW50ZXIodm5vZGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IG9yaWdpbmFsRGlzcGxheTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gdmFsdWUgPyBvcmlnaW5hbERpc3BsYXkgOiAnbm9uZSc7XG4gICAgfVxuICB9LFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlIChlbCwgcmVmLCB2bm9kZSkge1xuICAgIHZhciB2YWx1ZSA9IHJlZi52YWx1ZTtcbiAgICB2YXIgb2xkVmFsdWUgPSByZWYub2xkVmFsdWU7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIXZhbHVlID09PSAhb2xkVmFsdWUpIHsgcmV0dXJuIH1cbiAgICB2bm9kZSA9IGxvY2F0ZU5vZGUodm5vZGUpO1xuICAgIHZhciB0cmFuc2l0aW9uJCQxID0gdm5vZGUuZGF0YSAmJiB2bm9kZS5kYXRhLnRyYW5zaXRpb247XG4gICAgaWYgKHRyYW5zaXRpb24kJDEpIHtcbiAgICAgIHZub2RlLmRhdGEuc2hvdyA9IHRydWU7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgZW50ZXIodm5vZGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gZWwuX192T3JpZ2luYWxEaXNwbGF5O1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxlYXZlKHZub2RlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZSA/IGVsLl9fdk9yaWdpbmFsRGlzcGxheSA6ICdub25lJztcbiAgICB9XG4gIH0sXG5cbiAgdW5iaW5kOiBmdW5jdGlvbiB1bmJpbmQgKFxuICAgIGVsLFxuICAgIGJpbmRpbmcsXG4gICAgdm5vZGUsXG4gICAgb2xkVm5vZGUsXG4gICAgaXNEZXN0cm95XG4gICkge1xuICAgIGlmICghaXNEZXN0cm95KSB7XG4gICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gZWwuX192T3JpZ2luYWxEaXNwbGF5O1xuICAgIH1cbiAgfVxufVxuXG52YXIgcGxhdGZvcm1EaXJlY3RpdmVzID0ge1xuICBtb2RlbDogZGlyZWN0aXZlLFxuICBzaG93OiBzaG93XG59XG5cbi8qICAqL1xuXG4vLyBQcm92aWRlcyB0cmFuc2l0aW9uIHN1cHBvcnQgZm9yIGEgc2luZ2xlIGVsZW1lbnQvY29tcG9uZW50LlxuLy8gc3VwcG9ydHMgdHJhbnNpdGlvbiBtb2RlIChvdXQtaW4gLyBpbi1vdXQpXG5cbnZhciB0cmFuc2l0aW9uUHJvcHMgPSB7XG4gIG5hbWU6IFN0cmluZyxcbiAgYXBwZWFyOiBCb29sZWFuLFxuICBjc3M6IEJvb2xlYW4sXG4gIG1vZGU6IFN0cmluZyxcbiAgdHlwZTogU3RyaW5nLFxuICBlbnRlckNsYXNzOiBTdHJpbmcsXG4gIGxlYXZlQ2xhc3M6IFN0cmluZyxcbiAgZW50ZXJUb0NsYXNzOiBTdHJpbmcsXG4gIGxlYXZlVG9DbGFzczogU3RyaW5nLFxuICBlbnRlckFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gIGxlYXZlQWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgYXBwZWFyQ2xhc3M6IFN0cmluZyxcbiAgYXBwZWFyQWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgYXBwZWFyVG9DbGFzczogU3RyaW5nLFxuICBkdXJhdGlvbjogW051bWJlciwgU3RyaW5nLCBPYmplY3RdXG59O1xuXG4vLyBpbiBjYXNlIHRoZSBjaGlsZCBpcyBhbHNvIGFuIGFic3RyYWN0IGNvbXBvbmVudCwgZS5nLiA8a2VlcC1hbGl2ZT5cbi8vIHdlIHdhbnQgdG8gcmVjdXJzaXZlbHkgcmV0cmlldmUgdGhlIHJlYWwgY29tcG9uZW50IHRvIGJlIHJlbmRlcmVkXG5mdW5jdGlvbiBnZXRSZWFsQ2hpbGQgKHZub2RlKSB7XG4gIHZhciBjb21wT3B0aW9ucyA9IHZub2RlICYmIHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gIGlmIChjb21wT3B0aW9ucyAmJiBjb21wT3B0aW9ucy5DdG9yLm9wdGlvbnMuYWJzdHJhY3QpIHtcbiAgICByZXR1cm4gZ2V0UmVhbENoaWxkKGdldEZpcnN0Q29tcG9uZW50Q2hpbGQoY29tcE9wdGlvbnMuY2hpbGRyZW4pKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiB2bm9kZVxuICB9XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RUcmFuc2l0aW9uRGF0YSAoY29tcCkge1xuICB2YXIgZGF0YSA9IHt9O1xuICB2YXIgb3B0aW9ucyA9IGNvbXAuJG9wdGlvbnM7XG4gIC8vIHByb3BzXG4gIGZvciAodmFyIGtleSBpbiBvcHRpb25zLnByb3BzRGF0YSkge1xuICAgIGRhdGFba2V5XSA9IGNvbXBba2V5XTtcbiAgfVxuICAvLyBldmVudHMuXG4gIC8vIGV4dHJhY3QgbGlzdGVuZXJzIGFuZCBwYXNzIHRoZW0gZGlyZWN0bHkgdG8gdGhlIHRyYW5zaXRpb24gbWV0aG9kc1xuICB2YXIgbGlzdGVuZXJzID0gb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xuICBmb3IgKHZhciBrZXkkMSBpbiBsaXN0ZW5lcnMpIHtcbiAgICBkYXRhW2NhbWVsaXplKGtleSQxKV0gPSBsaXN0ZW5lcnNba2V5JDFdO1xuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbmZ1bmN0aW9uIHBsYWNlaG9sZGVyIChoLCByYXdDaGlsZCkge1xuICBpZiAoL1xcZC1rZWVwLWFsaXZlJC8udGVzdChyYXdDaGlsZC50YWcpKSB7XG4gICAgcmV0dXJuIGgoJ2tlZXAtYWxpdmUnLCB7XG4gICAgICBwcm9wczogcmF3Q2hpbGQuY29tcG9uZW50T3B0aW9ucy5wcm9wc0RhdGFcbiAgICB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIGhhc1BhcmVudFRyYW5zaXRpb24gKHZub2RlKSB7XG4gIHdoaWxlICgodm5vZGUgPSB2bm9kZS5wYXJlbnQpKSB7XG4gICAgaWYgKHZub2RlLmRhdGEudHJhbnNpdGlvbikge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNTYW1lQ2hpbGQgKGNoaWxkLCBvbGRDaGlsZCkge1xuICByZXR1cm4gb2xkQ2hpbGQua2V5ID09PSBjaGlsZC5rZXkgJiYgb2xkQ2hpbGQudGFnID09PSBjaGlsZC50YWdcbn1cblxudmFyIFRyYW5zaXRpb24gPSB7XG4gIG5hbWU6ICd0cmFuc2l0aW9uJyxcbiAgcHJvcHM6IHRyYW5zaXRpb25Qcm9wcyxcbiAgYWJzdHJhY3Q6IHRydWUsXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKGgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuJHNsb3RzLmRlZmF1bHQ7XG4gICAgaWYgKCFjaGlsZHJlbikge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gZmlsdGVyIG91dCB0ZXh0IG5vZGVzIChwb3NzaWJsZSB3aGl0ZXNwYWNlcylcbiAgICBjaGlsZHJlbiA9IGNoaWxkcmVuLmZpbHRlcihmdW5jdGlvbiAoYykgeyByZXR1cm4gYy50YWcgfHwgaXNBc3luY1BsYWNlaG9sZGVyKGMpOyB9KTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gd2FybiBtdWx0aXBsZSBlbGVtZW50c1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICc8dHJhbnNpdGlvbj4gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIHNpbmdsZSBlbGVtZW50LiBVc2UgJyArXG4gICAgICAgICc8dHJhbnNpdGlvbi1ncm91cD4gZm9yIGxpc3RzLicsXG4gICAgICAgIHRoaXMuJHBhcmVudFxuICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgbW9kZSA9IHRoaXMubW9kZTtcblxuICAgIC8vIHdhcm4gaW52YWxpZCBtb2RlXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgIG1vZGUgJiYgbW9kZSAhPT0gJ2luLW91dCcgJiYgbW9kZSAhPT0gJ291dC1pbidcbiAgICApIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdpbnZhbGlkIDx0cmFuc2l0aW9uPiBtb2RlOiAnICsgbW9kZSxcbiAgICAgICAgdGhpcy4kcGFyZW50XG4gICAgICApO1xuICAgIH1cblxuICAgIHZhciByYXdDaGlsZCA9IGNoaWxkcmVuWzBdO1xuXG4gICAgLy8gaWYgdGhpcyBpcyBhIGNvbXBvbmVudCByb290IG5vZGUgYW5kIHRoZSBjb21wb25lbnQnc1xuICAgIC8vIHBhcmVudCBjb250YWluZXIgbm9kZSBhbHNvIGhhcyB0cmFuc2l0aW9uLCBza2lwLlxuICAgIGlmIChoYXNQYXJlbnRUcmFuc2l0aW9uKHRoaXMuJHZub2RlKSkge1xuICAgICAgcmV0dXJuIHJhd0NoaWxkXG4gICAgfVxuXG4gICAgLy8gYXBwbHkgdHJhbnNpdGlvbiBkYXRhIHRvIGNoaWxkXG4gICAgLy8gdXNlIGdldFJlYWxDaGlsZCgpIHRvIGlnbm9yZSBhYnN0cmFjdCBjb21wb25lbnRzIGUuZy4ga2VlcC1hbGl2ZVxuICAgIHZhciBjaGlsZCA9IGdldFJlYWxDaGlsZChyYXdDaGlsZCk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFjaGlsZCkge1xuICAgICAgcmV0dXJuIHJhd0NoaWxkXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2xlYXZpbmcpIHtcbiAgICAgIHJldHVybiBwbGFjZWhvbGRlcihoLCByYXdDaGlsZClcbiAgICB9XG5cbiAgICAvLyBlbnN1cmUgYSBrZXkgdGhhdCBpcyB1bmlxdWUgdG8gdGhlIHZub2RlIHR5cGUgYW5kIHRvIHRoaXMgdHJhbnNpdGlvblxuICAgIC8vIGNvbXBvbmVudCBpbnN0YW5jZS4gVGhpcyBrZXkgd2lsbCBiZSB1c2VkIHRvIHJlbW92ZSBwZW5kaW5nIGxlYXZpbmcgbm9kZXNcbiAgICAvLyBkdXJpbmcgZW50ZXJpbmcuXG4gICAgdmFyIGlkID0gXCJfX3RyYW5zaXRpb24tXCIgKyAodGhpcy5fdWlkKSArIFwiLVwiO1xuICAgIGNoaWxkLmtleSA9IGNoaWxkLmtleSA9PSBudWxsXG4gICAgICA/IGNoaWxkLmlzQ29tbWVudFxuICAgICAgICA/IGlkICsgJ2NvbW1lbnQnXG4gICAgICAgIDogaWQgKyBjaGlsZC50YWdcbiAgICAgIDogaXNQcmltaXRpdmUoY2hpbGQua2V5KVxuICAgICAgICA/IChTdHJpbmcoY2hpbGQua2V5KS5pbmRleE9mKGlkKSA9PT0gMCA/IGNoaWxkLmtleSA6IGlkICsgY2hpbGQua2V5KVxuICAgICAgICA6IGNoaWxkLmtleTtcblxuICAgIHZhciBkYXRhID0gKGNoaWxkLmRhdGEgfHwgKGNoaWxkLmRhdGEgPSB7fSkpLnRyYW5zaXRpb24gPSBleHRyYWN0VHJhbnNpdGlvbkRhdGEodGhpcyk7XG4gICAgdmFyIG9sZFJhd0NoaWxkID0gdGhpcy5fdm5vZGU7XG4gICAgdmFyIG9sZENoaWxkID0gZ2V0UmVhbENoaWxkKG9sZFJhd0NoaWxkKTtcblxuICAgIC8vIG1hcmsgdi1zaG93XG4gICAgLy8gc28gdGhhdCB0aGUgdHJhbnNpdGlvbiBtb2R1bGUgY2FuIGhhbmQgb3ZlciB0aGUgY29udHJvbCB0byB0aGUgZGlyZWN0aXZlXG4gICAgaWYgKGNoaWxkLmRhdGEuZGlyZWN0aXZlcyAmJiBjaGlsZC5kYXRhLmRpcmVjdGl2ZXMuc29tZShmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC5uYW1lID09PSAnc2hvdyc7IH0pKSB7XG4gICAgICBjaGlsZC5kYXRhLnNob3cgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChcbiAgICAgIG9sZENoaWxkICYmXG4gICAgICBvbGRDaGlsZC5kYXRhICYmXG4gICAgICAhaXNTYW1lQ2hpbGQoY2hpbGQsIG9sZENoaWxkKSAmJlxuICAgICAgIWlzQXN5bmNQbGFjZWhvbGRlcihvbGRDaGlsZCkgJiZcbiAgICAgIC8vICM2Njg3IGNvbXBvbmVudCByb290IGlzIGEgY29tbWVudCBub2RlXG4gICAgICAhKG9sZENoaWxkLmNvbXBvbmVudEluc3RhbmNlICYmIG9sZENoaWxkLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZS5pc0NvbW1lbnQpXG4gICAgKSB7XG4gICAgICAvLyByZXBsYWNlIG9sZCBjaGlsZCB0cmFuc2l0aW9uIGRhdGEgd2l0aCBmcmVzaCBvbmVcbiAgICAgIC8vIGltcG9ydGFudCBmb3IgZHluYW1pYyB0cmFuc2l0aW9ucyFcbiAgICAgIHZhciBvbGREYXRhID0gb2xkQ2hpbGQuZGF0YS50cmFuc2l0aW9uID0gZXh0ZW5kKHt9LCBkYXRhKTtcbiAgICAgIC8vIGhhbmRsZSB0cmFuc2l0aW9uIG1vZGVcbiAgICAgIGlmIChtb2RlID09PSAnb3V0LWluJykge1xuICAgICAgICAvLyByZXR1cm4gcGxhY2Vob2xkZXIgbm9kZSBhbmQgcXVldWUgdXBkYXRlIHdoZW4gbGVhdmUgZmluaXNoZXNcbiAgICAgICAgdGhpcy5fbGVhdmluZyA9IHRydWU7XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKG9sZERhdGEsICdhZnRlckxlYXZlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoaXMkMS5fbGVhdmluZyA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMkMS4kZm9yY2VVcGRhdGUoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwbGFjZWhvbGRlcihoLCByYXdDaGlsZClcbiAgICAgIH0gZWxzZSBpZiAobW9kZSA9PT0gJ2luLW91dCcpIHtcbiAgICAgICAgaWYgKGlzQXN5bmNQbGFjZWhvbGRlcihjaGlsZCkpIHtcbiAgICAgICAgICByZXR1cm4gb2xkUmF3Q2hpbGRcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGVsYXllZExlYXZlO1xuICAgICAgICB2YXIgcGVyZm9ybUxlYXZlID0gZnVuY3Rpb24gKCkgeyBkZWxheWVkTGVhdmUoKTsgfTtcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2soZGF0YSwgJ2FmdGVyRW50ZXInLCBwZXJmb3JtTGVhdmUpO1xuICAgICAgICBtZXJnZVZOb2RlSG9vayhkYXRhLCAnZW50ZXJDYW5jZWxsZWQnLCBwZXJmb3JtTGVhdmUpO1xuICAgICAgICBtZXJnZVZOb2RlSG9vayhvbGREYXRhLCAnZGVsYXlMZWF2ZScsIGZ1bmN0aW9uIChsZWF2ZSkgeyBkZWxheWVkTGVhdmUgPSBsZWF2ZTsgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJhd0NoaWxkXG4gIH1cbn1cblxuLyogICovXG5cbi8vIFByb3ZpZGVzIHRyYW5zaXRpb24gc3VwcG9ydCBmb3IgbGlzdCBpdGVtcy5cbi8vIHN1cHBvcnRzIG1vdmUgdHJhbnNpdGlvbnMgdXNpbmcgdGhlIEZMSVAgdGVjaG5pcXVlLlxuXG4vLyBCZWNhdXNlIHRoZSB2ZG9tJ3MgY2hpbGRyZW4gdXBkYXRlIGFsZ29yaXRobSBpcyBcInVuc3RhYmxlXCIgLSBpLmUuXG4vLyBpdCBkb2Vzbid0IGd1YXJhbnRlZSB0aGUgcmVsYXRpdmUgcG9zaXRpb25pbmcgb2YgcmVtb3ZlZCBlbGVtZW50cyxcbi8vIHdlIGZvcmNlIHRyYW5zaXRpb24tZ3JvdXAgdG8gdXBkYXRlIGl0cyBjaGlsZHJlbiBpbnRvIHR3byBwYXNzZXM6XG4vLyBpbiB0aGUgZmlyc3QgcGFzcywgd2UgcmVtb3ZlIGFsbCBub2RlcyB0aGF0IG5lZWQgdG8gYmUgcmVtb3ZlZCxcbi8vIHRyaWdnZXJpbmcgdGhlaXIgbGVhdmluZyB0cmFuc2l0aW9uOyBpbiB0aGUgc2Vjb25kIHBhc3MsIHdlIGluc2VydC9tb3ZlXG4vLyBpbnRvIHRoZSBmaW5hbCBkZXNpcmVkIHN0YXRlLiBUaGlzIHdheSBpbiB0aGUgc2Vjb25kIHBhc3MgcmVtb3ZlZFxuLy8gbm9kZXMgd2lsbCByZW1haW4gd2hlcmUgdGhleSBzaG91bGQgYmUuXG5cbnZhciBwcm9wcyA9IGV4dGVuZCh7XG4gIHRhZzogU3RyaW5nLFxuICBtb3ZlQ2xhc3M6IFN0cmluZ1xufSwgdHJhbnNpdGlvblByb3BzKTtcblxuZGVsZXRlIHByb3BzLm1vZGU7XG5cbnZhciBUcmFuc2l0aW9uR3JvdXAgPSB7XG4gIHByb3BzOiBwcm9wcyxcblxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoaCkge1xuICAgIHZhciB0YWcgPSB0aGlzLnRhZyB8fCB0aGlzLiR2bm9kZS5kYXRhLnRhZyB8fCAnc3Bhbic7XG4gICAgdmFyIG1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdmFyIHByZXZDaGlsZHJlbiA9IHRoaXMucHJldkNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcbiAgICB2YXIgcmF3Q2hpbGRyZW4gPSB0aGlzLiRzbG90cy5kZWZhdWx0IHx8IFtdO1xuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgICB2YXIgdHJhbnNpdGlvbkRhdGEgPSBleHRyYWN0VHJhbnNpdGlvbkRhdGEodGhpcyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhd0NoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYyA9IHJhd0NoaWxkcmVuW2ldO1xuICAgICAgaWYgKGMudGFnKSB7XG4gICAgICAgIGlmIChjLmtleSAhPSBudWxsICYmIFN0cmluZyhjLmtleSkuaW5kZXhPZignX192bGlzdCcpICE9PSAwKSB7XG4gICAgICAgICAgY2hpbGRyZW4ucHVzaChjKTtcbiAgICAgICAgICBtYXBbYy5rZXldID0gY1xuICAgICAgICAgIDsoYy5kYXRhIHx8IChjLmRhdGEgPSB7fSkpLnRyYW5zaXRpb24gPSB0cmFuc2l0aW9uRGF0YTtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgdmFyIG9wdHMgPSBjLmNvbXBvbmVudE9wdGlvbnM7XG4gICAgICAgICAgdmFyIG5hbWUgPSBvcHRzID8gKG9wdHMuQ3Rvci5vcHRpb25zLm5hbWUgfHwgb3B0cy50YWcgfHwgJycpIDogYy50YWc7XG4gICAgICAgICAgd2FybigoXCI8dHJhbnNpdGlvbi1ncm91cD4gY2hpbGRyZW4gbXVzdCBiZSBrZXllZDogPFwiICsgbmFtZSArIFwiPlwiKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocHJldkNoaWxkcmVuKSB7XG4gICAgICB2YXIga2VwdCA9IFtdO1xuICAgICAgdmFyIHJlbW92ZWQgPSBbXTtcbiAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IHByZXZDaGlsZHJlbi5sZW5ndGg7IGkkMSsrKSB7XG4gICAgICAgIHZhciBjJDEgPSBwcmV2Q2hpbGRyZW5baSQxXTtcbiAgICAgICAgYyQxLmRhdGEudHJhbnNpdGlvbiA9IHRyYW5zaXRpb25EYXRhO1xuICAgICAgICBjJDEuZGF0YS5wb3MgPSBjJDEuZWxtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBpZiAobWFwW2MkMS5rZXldKSB7XG4gICAgICAgICAga2VwdC5wdXNoKGMkMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVtb3ZlZC5wdXNoKGMkMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMua2VwdCA9IGgodGFnLCBudWxsLCBrZXB0KTtcbiAgICAgIHRoaXMucmVtb3ZlZCA9IHJlbW92ZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGgodGFnLCBudWxsLCBjaGlsZHJlbilcbiAgfSxcblxuICBiZWZvcmVVcGRhdGU6IGZ1bmN0aW9uIGJlZm9yZVVwZGF0ZSAoKSB7XG4gICAgLy8gZm9yY2UgcmVtb3ZpbmcgcGFzc1xuICAgIHRoaXMuX19wYXRjaF9fKFxuICAgICAgdGhpcy5fdm5vZGUsXG4gICAgICB0aGlzLmtlcHQsXG4gICAgICBmYWxzZSwgLy8gaHlkcmF0aW5nXG4gICAgICB0cnVlIC8vIHJlbW92ZU9ubHkgKCFpbXBvcnRhbnQsIGF2b2lkcyB1bm5lY2Vzc2FyeSBtb3ZlcylcbiAgICApO1xuICAgIHRoaXMuX3Zub2RlID0gdGhpcy5rZXB0O1xuICB9LFxuXG4gIHVwZGF0ZWQ6IGZ1bmN0aW9uIHVwZGF0ZWQgKCkge1xuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMucHJldkNoaWxkcmVuO1xuICAgIHZhciBtb3ZlQ2xhc3MgPSB0aGlzLm1vdmVDbGFzcyB8fCAoKHRoaXMubmFtZSB8fCAndicpICsgJy1tb3ZlJyk7XG4gICAgaWYgKCFjaGlsZHJlbi5sZW5ndGggfHwgIXRoaXMuaGFzTW92ZShjaGlsZHJlblswXS5lbG0sIG1vdmVDbGFzcykpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIHdlIGRpdmlkZSB0aGUgd29yayBpbnRvIHRocmVlIGxvb3BzIHRvIGF2b2lkIG1peGluZyBET00gcmVhZHMgYW5kIHdyaXRlc1xuICAgIC8vIGluIGVhY2ggaXRlcmF0aW9uIC0gd2hpY2ggaGVscHMgcHJldmVudCBsYXlvdXQgdGhyYXNoaW5nLlxuICAgIGNoaWxkcmVuLmZvckVhY2goY2FsbFBlbmRpbmdDYnMpO1xuICAgIGNoaWxkcmVuLmZvckVhY2gocmVjb3JkUG9zaXRpb24pO1xuICAgIGNoaWxkcmVuLmZvckVhY2goYXBwbHlUcmFuc2xhdGlvbik7XG5cbiAgICAvLyBmb3JjZSByZWZsb3cgdG8gcHV0IGV2ZXJ5dGhpbmcgaW4gcG9zaXRpb25cbiAgICAvLyBhc3NpZ24gdG8gdGhpcyB0byBhdm9pZCBiZWluZyByZW1vdmVkIGluIHRyZWUtc2hha2luZ1xuICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgIHRoaXMuX3JlZmxvdyA9IGRvY3VtZW50LmJvZHkub2Zmc2V0SGVpZ2h0O1xuXG4gICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgaWYgKGMuZGF0YS5tb3ZlZCkge1xuICAgICAgICB2YXIgZWwgPSBjLmVsbTtcbiAgICAgICAgdmFyIHMgPSBlbC5zdHlsZTtcbiAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBtb3ZlQ2xhc3MpO1xuICAgICAgICBzLnRyYW5zZm9ybSA9IHMuV2Via2l0VHJhbnNmb3JtID0gcy50cmFuc2l0aW9uRHVyYXRpb24gPSAnJztcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcih0cmFuc2l0aW9uRW5kRXZlbnQsIGVsLl9tb3ZlQ2IgPSBmdW5jdGlvbiBjYiAoZSkge1xuICAgICAgICAgIGlmICghZSB8fCAvdHJhbnNmb3JtJC8udGVzdChlLnByb3BlcnR5TmFtZSkpIHtcbiAgICAgICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIodHJhbnNpdGlvbkVuZEV2ZW50LCBjYik7XG4gICAgICAgICAgICBlbC5fbW92ZUNiID0gbnVsbDtcbiAgICAgICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbW92ZUNsYXNzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIG1ldGhvZHM6IHtcbiAgICBoYXNNb3ZlOiBmdW5jdGlvbiBoYXNNb3ZlIChlbCwgbW92ZUNsYXNzKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmICghaGFzVHJhbnNpdGlvbikge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKHRoaXMuX2hhc01vdmUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hhc01vdmVcbiAgICAgIH1cbiAgICAgIC8vIERldGVjdCB3aGV0aGVyIGFuIGVsZW1lbnQgd2l0aCB0aGUgbW92ZSBjbGFzcyBhcHBsaWVkIGhhc1xuICAgICAgLy8gQ1NTIHRyYW5zaXRpb25zLiBTaW5jZSB0aGUgZWxlbWVudCBtYXkgYmUgaW5zaWRlIGFuIGVudGVyaW5nXG4gICAgICAvLyB0cmFuc2l0aW9uIGF0IHRoaXMgdmVyeSBtb21lbnQsIHdlIG1ha2UgYSBjbG9uZSBvZiBpdCBhbmQgcmVtb3ZlXG4gICAgICAvLyBhbGwgb3RoZXIgdHJhbnNpdGlvbiBjbGFzc2VzIGFwcGxpZWQgdG8gZW5zdXJlIG9ubHkgdGhlIG1vdmUgY2xhc3NcbiAgICAgIC8vIGlzIGFwcGxpZWQuXG4gICAgICB2YXIgY2xvbmUgPSBlbC5jbG9uZU5vZGUoKTtcbiAgICAgIGlmIChlbC5fdHJhbnNpdGlvbkNsYXNzZXMpIHtcbiAgICAgICAgZWwuX3RyYW5zaXRpb25DbGFzc2VzLmZvckVhY2goZnVuY3Rpb24gKGNscykgeyByZW1vdmVDbGFzcyhjbG9uZSwgY2xzKTsgfSk7XG4gICAgICB9XG4gICAgICBhZGRDbGFzcyhjbG9uZSwgbW92ZUNsYXNzKTtcbiAgICAgIGNsb25lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICB0aGlzLiRlbC5hcHBlbmRDaGlsZChjbG9uZSk7XG4gICAgICB2YXIgaW5mbyA9IGdldFRyYW5zaXRpb25JbmZvKGNsb25lKTtcbiAgICAgIHRoaXMuJGVsLnJlbW92ZUNoaWxkKGNsb25lKTtcbiAgICAgIHJldHVybiAodGhpcy5faGFzTW92ZSA9IGluZm8uaGFzVHJhbnNmb3JtKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjYWxsUGVuZGluZ0NicyAoYykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGMuZWxtLl9tb3ZlQ2IpIHtcbiAgICBjLmVsbS5fbW92ZUNiKCk7XG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChjLmVsbS5fZW50ZXJDYikge1xuICAgIGMuZWxtLl9lbnRlckNiKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVjb3JkUG9zaXRpb24gKGMpIHtcbiAgYy5kYXRhLm5ld1BvcyA9IGMuZWxtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xufVxuXG5mdW5jdGlvbiBhcHBseVRyYW5zbGF0aW9uIChjKSB7XG4gIHZhciBvbGRQb3MgPSBjLmRhdGEucG9zO1xuICB2YXIgbmV3UG9zID0gYy5kYXRhLm5ld1BvcztcbiAgdmFyIGR4ID0gb2xkUG9zLmxlZnQgLSBuZXdQb3MubGVmdDtcbiAgdmFyIGR5ID0gb2xkUG9zLnRvcCAtIG5ld1Bvcy50b3A7XG4gIGlmIChkeCB8fCBkeSkge1xuICAgIGMuZGF0YS5tb3ZlZCA9IHRydWU7XG4gICAgdmFyIHMgPSBjLmVsbS5zdHlsZTtcbiAgICBzLnRyYW5zZm9ybSA9IHMuV2Via2l0VHJhbnNmb3JtID0gXCJ0cmFuc2xhdGUoXCIgKyBkeCArIFwicHgsXCIgKyBkeSArIFwicHgpXCI7XG4gICAgcy50cmFuc2l0aW9uRHVyYXRpb24gPSAnMHMnO1xuICB9XG59XG5cbnZhciBwbGF0Zm9ybUNvbXBvbmVudHMgPSB7XG4gIFRyYW5zaXRpb246IFRyYW5zaXRpb24sXG4gIFRyYW5zaXRpb25Hcm91cDogVHJhbnNpdGlvbkdyb3VwXG59XG5cbi8qICAqL1xuXG4vLyBpbnN0YWxsIHBsYXRmb3JtIHNwZWNpZmljIHV0aWxzXG5WdWUuY29uZmlnLm11c3RVc2VQcm9wID0gbXVzdFVzZVByb3A7XG5WdWUuY29uZmlnLmlzUmVzZXJ2ZWRUYWcgPSBpc1Jlc2VydmVkVGFnO1xuVnVlLmNvbmZpZy5pc1Jlc2VydmVkQXR0ciA9IGlzUmVzZXJ2ZWRBdHRyO1xuVnVlLmNvbmZpZy5nZXRUYWdOYW1lc3BhY2UgPSBnZXRUYWdOYW1lc3BhY2U7XG5WdWUuY29uZmlnLmlzVW5rbm93bkVsZW1lbnQgPSBpc1Vua25vd25FbGVtZW50O1xuXG4vLyBpbnN0YWxsIHBsYXRmb3JtIHJ1bnRpbWUgZGlyZWN0aXZlcyAmIGNvbXBvbmVudHNcbmV4dGVuZChWdWUub3B0aW9ucy5kaXJlY3RpdmVzLCBwbGF0Zm9ybURpcmVjdGl2ZXMpO1xuZXh0ZW5kKFZ1ZS5vcHRpb25zLmNvbXBvbmVudHMsIHBsYXRmb3JtQ29tcG9uZW50cyk7XG5cbi8vIGluc3RhbGwgcGxhdGZvcm0gcGF0Y2ggZnVuY3Rpb25cblZ1ZS5wcm90b3R5cGUuX19wYXRjaF9fID0gaW5Ccm93c2VyID8gcGF0Y2ggOiBub29wO1xuXG4vLyBwdWJsaWMgbW91bnQgbWV0aG9kXG5WdWUucHJvdG90eXBlLiRtb3VudCA9IGZ1bmN0aW9uIChcbiAgZWwsXG4gIGh5ZHJhdGluZ1xuKSB7XG4gIGVsID0gZWwgJiYgaW5Ccm93c2VyID8gcXVlcnkoZWwpIDogdW5kZWZpbmVkO1xuICByZXR1cm4gbW91bnRDb21wb25lbnQodGhpcywgZWwsIGh5ZHJhdGluZylcbn07XG5cbi8vIGRldnRvb2xzIGdsb2JhbCBob29rXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuaWYgKGluQnJvd3Nlcikge1xuICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoY29uZmlnLmRldnRvb2xzKSB7XG4gICAgICBpZiAoZGV2dG9vbHMpIHtcbiAgICAgICAgZGV2dG9vbHMuZW1pdCgnaW5pdCcsIFZ1ZSk7XG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAndGVzdCcgJiZcbiAgICAgICAgaXNDaHJvbWVcbiAgICAgICkge1xuICAgICAgICBjb25zb2xlW2NvbnNvbGUuaW5mbyA/ICdpbmZvJyA6ICdsb2cnXShcbiAgICAgICAgICAnRG93bmxvYWQgdGhlIFZ1ZSBEZXZ0b29scyBleHRlbnNpb24gZm9yIGEgYmV0dGVyIGRldmVsb3BtZW50IGV4cGVyaWVuY2U6XFxuJyArXG4gICAgICAgICAgJ2h0dHBzOi8vZ2l0aHViLmNvbS92dWVqcy92dWUtZGV2dG9vbHMnXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Rlc3QnICYmXG4gICAgICBjb25maWcucHJvZHVjdGlvblRpcCAhPT0gZmFsc2UgJiZcbiAgICAgIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJ1xuICAgICkge1xuICAgICAgY29uc29sZVtjb25zb2xlLmluZm8gPyAnaW5mbycgOiAnbG9nJ10oXG4gICAgICAgIFwiWW91IGFyZSBydW5uaW5nIFZ1ZSBpbiBkZXZlbG9wbWVudCBtb2RlLlxcblwiICtcbiAgICAgICAgXCJNYWtlIHN1cmUgdG8gdHVybiBvbiBwcm9kdWN0aW9uIG1vZGUgd2hlbiBkZXBsb3lpbmcgZm9yIHByb2R1Y3Rpb24uXFxuXCIgK1xuICAgICAgICBcIlNlZSBtb3JlIHRpcHMgYXQgaHR0cHM6Ly92dWVqcy5vcmcvZ3VpZGUvZGVwbG95bWVudC5odG1sXCJcbiAgICAgICk7XG4gICAgfVxuICB9LCAwKTtcbn1cblxuLyogICovXG5cbnZhciBkZWZhdWx0VGFnUkUgPSAvXFx7XFx7KCg/Oi58XFxuKSs/KVxcfVxcfS9nO1xudmFyIHJlZ2V4RXNjYXBlUkUgPSAvWy0uKis/XiR7fSgpfFtcXF1cXC9cXFxcXS9nO1xuXG52YXIgYnVpbGRSZWdleCA9IGNhY2hlZChmdW5jdGlvbiAoZGVsaW1pdGVycykge1xuICB2YXIgb3BlbiA9IGRlbGltaXRlcnNbMF0ucmVwbGFjZShyZWdleEVzY2FwZVJFLCAnXFxcXCQmJyk7XG4gIHZhciBjbG9zZSA9IGRlbGltaXRlcnNbMV0ucmVwbGFjZShyZWdleEVzY2FwZVJFLCAnXFxcXCQmJyk7XG4gIHJldHVybiBuZXcgUmVnRXhwKG9wZW4gKyAnKCg/Oi58XFxcXG4pKz8pJyArIGNsb3NlLCAnZycpXG59KTtcblxuXG5cbmZ1bmN0aW9uIHBhcnNlVGV4dCAoXG4gIHRleHQsXG4gIGRlbGltaXRlcnNcbikge1xuICB2YXIgdGFnUkUgPSBkZWxpbWl0ZXJzID8gYnVpbGRSZWdleChkZWxpbWl0ZXJzKSA6IGRlZmF1bHRUYWdSRTtcbiAgaWYgKCF0YWdSRS50ZXN0KHRleHQpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHRva2VucyA9IFtdO1xuICB2YXIgcmF3VG9rZW5zID0gW107XG4gIHZhciBsYXN0SW5kZXggPSB0YWdSRS5sYXN0SW5kZXggPSAwO1xuICB2YXIgbWF0Y2gsIGluZGV4LCB0b2tlblZhbHVlO1xuICB3aGlsZSAoKG1hdGNoID0gdGFnUkUuZXhlYyh0ZXh0KSkpIHtcbiAgICBpbmRleCA9IG1hdGNoLmluZGV4O1xuICAgIC8vIHB1c2ggdGV4dCB0b2tlblxuICAgIGlmIChpbmRleCA+IGxhc3RJbmRleCkge1xuICAgICAgcmF3VG9rZW5zLnB1c2godG9rZW5WYWx1ZSA9IHRleHQuc2xpY2UobGFzdEluZGV4LCBpbmRleCkpO1xuICAgICAgdG9rZW5zLnB1c2goSlNPTi5zdHJpbmdpZnkodG9rZW5WYWx1ZSkpO1xuICAgIH1cbiAgICAvLyB0YWcgdG9rZW5cbiAgICB2YXIgZXhwID0gcGFyc2VGaWx0ZXJzKG1hdGNoWzFdLnRyaW0oKSk7XG4gICAgdG9rZW5zLnB1c2goKFwiX3MoXCIgKyBleHAgKyBcIilcIikpO1xuICAgIHJhd1Rva2Vucy5wdXNoKHsgJ0BiaW5kaW5nJzogZXhwIH0pO1xuICAgIGxhc3RJbmRleCA9IGluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoO1xuICB9XG4gIGlmIChsYXN0SW5kZXggPCB0ZXh0Lmxlbmd0aCkge1xuICAgIHJhd1Rva2Vucy5wdXNoKHRva2VuVmFsdWUgPSB0ZXh0LnNsaWNlKGxhc3RJbmRleCkpO1xuICAgIHRva2Vucy5wdXNoKEpTT04uc3RyaW5naWZ5KHRva2VuVmFsdWUpKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGV4cHJlc3Npb246IHRva2Vucy5qb2luKCcrJyksXG4gICAgdG9rZW5zOiByYXdUb2tlbnNcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gdHJhbnNmb3JtTm9kZSAoZWwsIG9wdGlvbnMpIHtcbiAgdmFyIHdhcm4gPSBvcHRpb25zLndhcm4gfHwgYmFzZVdhcm47XG4gIHZhciBzdGF0aWNDbGFzcyA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICdjbGFzcycpO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBzdGF0aWNDbGFzcykge1xuICAgIHZhciByZXMgPSBwYXJzZVRleHQoc3RhdGljQ2xhc3MsIG9wdGlvbnMuZGVsaW1pdGVycyk7XG4gICAgaWYgKHJlcykge1xuICAgICAgd2FybihcbiAgICAgICAgXCJjbGFzcz1cXFwiXCIgKyBzdGF0aWNDbGFzcyArIFwiXFxcIjogXCIgK1xuICAgICAgICAnSW50ZXJwb2xhdGlvbiBpbnNpZGUgYXR0cmlidXRlcyBoYXMgYmVlbiByZW1vdmVkLiAnICtcbiAgICAgICAgJ1VzZSB2LWJpbmQgb3IgdGhlIGNvbG9uIHNob3J0aGFuZCBpbnN0ZWFkLiBGb3IgZXhhbXBsZSwgJyArXG4gICAgICAgICdpbnN0ZWFkIG9mIDxkaXYgY2xhc3M9XCJ7eyB2YWwgfX1cIj4sIHVzZSA8ZGl2IDpjbGFzcz1cInZhbFwiPi4nXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBpZiAoc3RhdGljQ2xhc3MpIHtcbiAgICBlbC5zdGF0aWNDbGFzcyA9IEpTT04uc3RyaW5naWZ5KHN0YXRpY0NsYXNzKTtcbiAgfVxuICB2YXIgY2xhc3NCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICdjbGFzcycsIGZhbHNlIC8qIGdldFN0YXRpYyAqLyk7XG4gIGlmIChjbGFzc0JpbmRpbmcpIHtcbiAgICBlbC5jbGFzc0JpbmRpbmcgPSBjbGFzc0JpbmRpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuRGF0YSAoZWwpIHtcbiAgdmFyIGRhdGEgPSAnJztcbiAgaWYgKGVsLnN0YXRpY0NsYXNzKSB7XG4gICAgZGF0YSArPSBcInN0YXRpY0NsYXNzOlwiICsgKGVsLnN0YXRpY0NsYXNzKSArIFwiLFwiO1xuICB9XG4gIGlmIChlbC5jbGFzc0JpbmRpbmcpIHtcbiAgICBkYXRhICs9IFwiY2xhc3M6XCIgKyAoZWwuY2xhc3NCaW5kaW5nKSArIFwiLFwiO1xuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbnZhciBrbGFzcyQxID0ge1xuICBzdGF0aWNLZXlzOiBbJ3N0YXRpY0NsYXNzJ10sXG4gIHRyYW5zZm9ybU5vZGU6IHRyYW5zZm9ybU5vZGUsXG4gIGdlbkRhdGE6IGdlbkRhdGFcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIHRyYW5zZm9ybU5vZGUkMSAoZWwsIG9wdGlvbnMpIHtcbiAgdmFyIHdhcm4gPSBvcHRpb25zLndhcm4gfHwgYmFzZVdhcm47XG4gIHZhciBzdGF0aWNTdHlsZSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICdzdHlsZScpO1xuICBpZiAoc3RhdGljU3R5bGUpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIHJlcyA9IHBhcnNlVGV4dChzdGF0aWNTdHlsZSwgb3B0aW9ucy5kZWxpbWl0ZXJzKTtcbiAgICAgIGlmIChyZXMpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBcInN0eWxlPVxcXCJcIiArIHN0YXRpY1N0eWxlICsgXCJcXFwiOiBcIiArXG4gICAgICAgICAgJ0ludGVycG9sYXRpb24gaW5zaWRlIGF0dHJpYnV0ZXMgaGFzIGJlZW4gcmVtb3ZlZC4gJyArXG4gICAgICAgICAgJ1VzZSB2LWJpbmQgb3IgdGhlIGNvbG9uIHNob3J0aGFuZCBpbnN0ZWFkLiBGb3IgZXhhbXBsZSwgJyArXG4gICAgICAgICAgJ2luc3RlYWQgb2YgPGRpdiBzdHlsZT1cInt7IHZhbCB9fVwiPiwgdXNlIDxkaXYgOnN0eWxlPVwidmFsXCI+LidcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWwuc3RhdGljU3R5bGUgPSBKU09OLnN0cmluZ2lmeShwYXJzZVN0eWxlVGV4dChzdGF0aWNTdHlsZSkpO1xuICB9XG5cbiAgdmFyIHN0eWxlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAnc3R5bGUnLCBmYWxzZSAvKiBnZXRTdGF0aWMgKi8pO1xuICBpZiAoc3R5bGVCaW5kaW5nKSB7XG4gICAgZWwuc3R5bGVCaW5kaW5nID0gc3R5bGVCaW5kaW5nO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdlbkRhdGEkMSAoZWwpIHtcbiAgdmFyIGRhdGEgPSAnJztcbiAgaWYgKGVsLnN0YXRpY1N0eWxlKSB7XG4gICAgZGF0YSArPSBcInN0YXRpY1N0eWxlOlwiICsgKGVsLnN0YXRpY1N0eWxlKSArIFwiLFwiO1xuICB9XG4gIGlmIChlbC5zdHlsZUJpbmRpbmcpIHtcbiAgICBkYXRhICs9IFwic3R5bGU6KFwiICsgKGVsLnN0eWxlQmluZGluZykgKyBcIiksXCI7XG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cblxudmFyIHN0eWxlJDEgPSB7XG4gIHN0YXRpY0tleXM6IFsnc3RhdGljU3R5bGUnXSxcbiAgdHJhbnNmb3JtTm9kZTogdHJhbnNmb3JtTm9kZSQxLFxuICBnZW5EYXRhOiBnZW5EYXRhJDFcbn1cblxuLyogICovXG5cbnZhciBkZWNvZGVyO1xuXG52YXIgaGUgPSB7XG4gIGRlY29kZTogZnVuY3Rpb24gZGVjb2RlIChodG1sKSB7XG4gICAgZGVjb2RlciA9IGRlY29kZXIgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZGVjb2Rlci5pbm5lckhUTUwgPSBodG1sO1xuICAgIHJldHVybiBkZWNvZGVyLnRleHRDb250ZW50XG4gIH1cbn1cblxuLyogICovXG5cbnZhciBpc1VuYXJ5VGFnID0gbWFrZU1hcChcbiAgJ2FyZWEsYmFzZSxicixjb2wsZW1iZWQsZnJhbWUsaHIsaW1nLGlucHV0LGlzaW5kZXgsa2V5Z2VuLCcgK1xuICAnbGluayxtZXRhLHBhcmFtLHNvdXJjZSx0cmFjayx3YnInXG4pO1xuXG4vLyBFbGVtZW50cyB0aGF0IHlvdSBjYW4sIGludGVudGlvbmFsbHksIGxlYXZlIG9wZW5cbi8vIChhbmQgd2hpY2ggY2xvc2UgdGhlbXNlbHZlcylcbnZhciBjYW5CZUxlZnRPcGVuVGFnID0gbWFrZU1hcChcbiAgJ2NvbGdyb3VwLGRkLGR0LGxpLG9wdGlvbnMscCx0ZCx0Zm9vdCx0aCx0aGVhZCx0cixzb3VyY2UnXG4pO1xuXG4vLyBIVE1MNSB0YWdzIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2luZGljZXMuaHRtbCNlbGVtZW50cy0zXG4vLyBQaHJhc2luZyBDb250ZW50IGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2RvbS5odG1sI3BocmFzaW5nLWNvbnRlbnRcbnZhciBpc05vblBocmFzaW5nVGFnID0gbWFrZU1hcChcbiAgJ2FkZHJlc3MsYXJ0aWNsZSxhc2lkZSxiYXNlLGJsb2NrcXVvdGUsYm9keSxjYXB0aW9uLGNvbCxjb2xncm91cCxkZCwnICtcbiAgJ2RldGFpbHMsZGlhbG9nLGRpdixkbCxkdCxmaWVsZHNldCxmaWdjYXB0aW9uLGZpZ3VyZSxmb290ZXIsZm9ybSwnICtcbiAgJ2gxLGgyLGgzLGg0LGg1LGg2LGhlYWQsaGVhZGVyLGhncm91cCxocixodG1sLGxlZ2VuZCxsaSxtZW51aXRlbSxtZXRhLCcgK1xuICAnb3B0Z3JvdXAsb3B0aW9uLHBhcmFtLHJwLHJ0LHNvdXJjZSxzdHlsZSxzdW1tYXJ5LHRib2R5LHRkLHRmb290LHRoLHRoZWFkLCcgK1xuICAndGl0bGUsdHIsdHJhY2snXG4pO1xuXG4vKipcbiAqIE5vdCB0eXBlLWNoZWNraW5nIHRoaXMgZmlsZSBiZWNhdXNlIGl0J3MgbW9zdGx5IHZlbmRvciBjb2RlLlxuICovXG5cbi8qIVxuICogSFRNTCBQYXJzZXIgQnkgSm9obiBSZXNpZyAoZWpvaG4ub3JnKVxuICogTW9kaWZpZWQgYnkgSnVyaXkgXCJrYW5nYXhcIiBaYXl0c2V2XG4gKiBPcmlnaW5hbCBjb2RlIGJ5IEVyaWsgQXJ2aWRzc29uLCBNb3ppbGxhIFB1YmxpYyBMaWNlbnNlXG4gKiBodHRwOi8vZXJpay5lYWUubmV0L3NpbXBsZWh0bWxwYXJzZXIvc2ltcGxlaHRtbHBhcnNlci5qc1xuICovXG5cbi8vIFJlZ3VsYXIgRXhwcmVzc2lvbnMgZm9yIHBhcnNpbmcgdGFncyBhbmQgYXR0cmlidXRlc1xudmFyIGF0dHJpYnV0ZSA9IC9eXFxzKihbXlxcc1wiJzw+XFwvPV0rKSg/OlxccyooPSlcXHMqKD86XCIoW15cIl0qKVwiK3wnKFteJ10qKScrfChbXlxcc1wiJz08PmBdKykpKT8vO1xuLy8gY291bGQgdXNlIGh0dHBzOi8vd3d3LnczLm9yZy9UUi8xOTk5L1JFQy14bWwtbmFtZXMtMTk5OTAxMTQvI05ULVFOYW1lXG4vLyBidXQgZm9yIFZ1ZSB0ZW1wbGF0ZXMgd2UgY2FuIGVuZm9yY2UgYSBzaW1wbGUgY2hhcnNldFxudmFyIG5jbmFtZSA9ICdbYS16QS1aX11bXFxcXHdcXFxcLVxcXFwuXSonO1xudmFyIHFuYW1lQ2FwdHVyZSA9IFwiKCg/OlwiICsgbmNuYW1lICsgXCJcXFxcOik/XCIgKyBuY25hbWUgKyBcIilcIjtcbnZhciBzdGFydFRhZ09wZW4gPSBuZXcgUmVnRXhwKChcIl48XCIgKyBxbmFtZUNhcHR1cmUpKTtcbnZhciBzdGFydFRhZ0Nsb3NlID0gL15cXHMqKFxcLz8pPi87XG52YXIgZW5kVGFnID0gbmV3IFJlZ0V4cCgoXCJePFxcXFwvXCIgKyBxbmFtZUNhcHR1cmUgKyBcIltePl0qPlwiKSk7XG52YXIgZG9jdHlwZSA9IC9ePCFET0NUWVBFIFtePl0rPi9pO1xuLy8gIzcyOTg6IGVzY2FwZSAtIHRvIGF2b2lkIGJlaW5nIHBhc2VkIGFzIEhUTUwgY29tbWVudCB3aGVuIGlubGluZWQgaW4gcGFnZVxudmFyIGNvbW1lbnQgPSAvXjwhXFwtLS87XG52YXIgY29uZGl0aW9uYWxDb21tZW50ID0gL148IVxcWy87XG5cbnZhciBJU19SRUdFWF9DQVBUVVJJTkdfQlJPS0VOID0gZmFsc2U7XG4neCcucmVwbGFjZSgveCguKT8vZywgZnVuY3Rpb24gKG0sIGcpIHtcbiAgSVNfUkVHRVhfQ0FQVFVSSU5HX0JST0tFTiA9IGcgPT09ICcnO1xufSk7XG5cbi8vIFNwZWNpYWwgRWxlbWVudHMgKGNhbiBjb250YWluIGFueXRoaW5nKVxudmFyIGlzUGxhaW5UZXh0RWxlbWVudCA9IG1ha2VNYXAoJ3NjcmlwdCxzdHlsZSx0ZXh0YXJlYScsIHRydWUpO1xudmFyIHJlQ2FjaGUgPSB7fTtcblxudmFyIGRlY29kaW5nTWFwID0ge1xuICAnJmx0Oyc6ICc8JyxcbiAgJyZndDsnOiAnPicsXG4gICcmcXVvdDsnOiAnXCInLFxuICAnJmFtcDsnOiAnJicsXG4gICcmIzEwOyc6ICdcXG4nLFxuICAnJiM5Oyc6ICdcXHQnXG59O1xudmFyIGVuY29kZWRBdHRyID0gLyYoPzpsdHxndHxxdW90fGFtcCk7L2c7XG52YXIgZW5jb2RlZEF0dHJXaXRoTmV3TGluZXMgPSAvJig/Omx0fGd0fHF1b3R8YW1wfCMxMHwjOSk7L2c7XG5cbi8vICM1OTkyXG52YXIgaXNJZ25vcmVOZXdsaW5lVGFnID0gbWFrZU1hcCgncHJlLHRleHRhcmVhJywgdHJ1ZSk7XG52YXIgc2hvdWxkSWdub3JlRmlyc3ROZXdsaW5lID0gZnVuY3Rpb24gKHRhZywgaHRtbCkgeyByZXR1cm4gdGFnICYmIGlzSWdub3JlTmV3bGluZVRhZyh0YWcpICYmIGh0bWxbMF0gPT09ICdcXG4nOyB9O1xuXG5mdW5jdGlvbiBkZWNvZGVBdHRyICh2YWx1ZSwgc2hvdWxkRGVjb2RlTmV3bGluZXMpIHtcbiAgdmFyIHJlID0gc2hvdWxkRGVjb2RlTmV3bGluZXMgPyBlbmNvZGVkQXR0cldpdGhOZXdMaW5lcyA6IGVuY29kZWRBdHRyO1xuICByZXR1cm4gdmFsdWUucmVwbGFjZShyZSwgZnVuY3Rpb24gKG1hdGNoKSB7IHJldHVybiBkZWNvZGluZ01hcFttYXRjaF07IH0pXG59XG5cbmZ1bmN0aW9uIHBhcnNlSFRNTCAoaHRtbCwgb3B0aW9ucykge1xuICB2YXIgc3RhY2sgPSBbXTtcbiAgdmFyIGV4cGVjdEhUTUwgPSBvcHRpb25zLmV4cGVjdEhUTUw7XG4gIHZhciBpc1VuYXJ5VGFnJCQxID0gb3B0aW9ucy5pc1VuYXJ5VGFnIHx8IG5vO1xuICB2YXIgY2FuQmVMZWZ0T3BlblRhZyQkMSA9IG9wdGlvbnMuY2FuQmVMZWZ0T3BlblRhZyB8fCBubztcbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGxhc3QsIGxhc3RUYWc7XG4gIHdoaWxlIChodG1sKSB7XG4gICAgbGFzdCA9IGh0bWw7XG4gICAgLy8gTWFrZSBzdXJlIHdlJ3JlIG5vdCBpbiBhIHBsYWludGV4dCBjb250ZW50IGVsZW1lbnQgbGlrZSBzY3JpcHQvc3R5bGVcbiAgICBpZiAoIWxhc3RUYWcgfHwgIWlzUGxhaW5UZXh0RWxlbWVudChsYXN0VGFnKSkge1xuICAgICAgdmFyIHRleHRFbmQgPSBodG1sLmluZGV4T2YoJzwnKTtcbiAgICAgIGlmICh0ZXh0RW5kID09PSAwKSB7XG4gICAgICAgIC8vIENvbW1lbnQ6XG4gICAgICAgIGlmIChjb21tZW50LnRlc3QoaHRtbCkpIHtcbiAgICAgICAgICB2YXIgY29tbWVudEVuZCA9IGh0bWwuaW5kZXhPZignLS0+Jyk7XG5cbiAgICAgICAgICBpZiAoY29tbWVudEVuZCA+PSAwKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5zaG91bGRLZWVwQ29tbWVudCkge1xuICAgICAgICAgICAgICBvcHRpb25zLmNvbW1lbnQoaHRtbC5zdWJzdHJpbmcoNCwgY29tbWVudEVuZCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWR2YW5jZShjb21tZW50RW5kICsgMyk7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29uZGl0aW9uYWxfY29tbWVudCNEb3dubGV2ZWwtcmV2ZWFsZWRfY29uZGl0aW9uYWxfY29tbWVudFxuICAgICAgICBpZiAoY29uZGl0aW9uYWxDb21tZW50LnRlc3QoaHRtbCkpIHtcbiAgICAgICAgICB2YXIgY29uZGl0aW9uYWxFbmQgPSBodG1sLmluZGV4T2YoJ10+Jyk7XG5cbiAgICAgICAgICBpZiAoY29uZGl0aW9uYWxFbmQgPj0gMCkge1xuICAgICAgICAgICAgYWR2YW5jZShjb25kaXRpb25hbEVuZCArIDIpO1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEb2N0eXBlOlxuICAgICAgICB2YXIgZG9jdHlwZU1hdGNoID0gaHRtbC5tYXRjaChkb2N0eXBlKTtcbiAgICAgICAgaWYgKGRvY3R5cGVNYXRjaCkge1xuICAgICAgICAgIGFkdmFuY2UoZG9jdHlwZU1hdGNoWzBdLmxlbmd0aCk7XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEVuZCB0YWc6XG4gICAgICAgIHZhciBlbmRUYWdNYXRjaCA9IGh0bWwubWF0Y2goZW5kVGFnKTtcbiAgICAgICAgaWYgKGVuZFRhZ01hdGNoKSB7XG4gICAgICAgICAgdmFyIGN1ckluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgYWR2YW5jZShlbmRUYWdNYXRjaFswXS5sZW5ndGgpO1xuICAgICAgICAgIHBhcnNlRW5kVGFnKGVuZFRhZ01hdGNoWzFdLCBjdXJJbmRleCwgaW5kZXgpO1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyBTdGFydCB0YWc6XG4gICAgICAgIHZhciBzdGFydFRhZ01hdGNoID0gcGFyc2VTdGFydFRhZygpO1xuICAgICAgICBpZiAoc3RhcnRUYWdNYXRjaCkge1xuICAgICAgICAgIGhhbmRsZVN0YXJ0VGFnKHN0YXJ0VGFnTWF0Y2gpO1xuICAgICAgICAgIGlmIChzaG91bGRJZ25vcmVGaXJzdE5ld2xpbmUobGFzdFRhZywgaHRtbCkpIHtcbiAgICAgICAgICAgIGFkdmFuY2UoMSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHRleHQgPSAodm9pZCAwKSwgcmVzdCA9ICh2b2lkIDApLCBuZXh0ID0gKHZvaWQgMCk7XG4gICAgICBpZiAodGV4dEVuZCA+PSAwKSB7XG4gICAgICAgIHJlc3QgPSBodG1sLnNsaWNlKHRleHRFbmQpO1xuICAgICAgICB3aGlsZSAoXG4gICAgICAgICAgIWVuZFRhZy50ZXN0KHJlc3QpICYmXG4gICAgICAgICAgIXN0YXJ0VGFnT3Blbi50ZXN0KHJlc3QpICYmXG4gICAgICAgICAgIWNvbW1lbnQudGVzdChyZXN0KSAmJlxuICAgICAgICAgICFjb25kaXRpb25hbENvbW1lbnQudGVzdChyZXN0KVxuICAgICAgICApIHtcbiAgICAgICAgICAvLyA8IGluIHBsYWluIHRleHQsIGJlIGZvcmdpdmluZyBhbmQgdHJlYXQgaXQgYXMgdGV4dFxuICAgICAgICAgIG5leHQgPSByZXN0LmluZGV4T2YoJzwnLCAxKTtcbiAgICAgICAgICBpZiAobmV4dCA8IDApIHsgYnJlYWsgfVxuICAgICAgICAgIHRleHRFbmQgKz0gbmV4dDtcbiAgICAgICAgICByZXN0ID0gaHRtbC5zbGljZSh0ZXh0RW5kKTtcbiAgICAgICAgfVxuICAgICAgICB0ZXh0ID0gaHRtbC5zdWJzdHJpbmcoMCwgdGV4dEVuZCk7XG4gICAgICAgIGFkdmFuY2UodGV4dEVuZCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0ZXh0RW5kIDwgMCkge1xuICAgICAgICB0ZXh0ID0gaHRtbDtcbiAgICAgICAgaHRtbCA9ICcnO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5jaGFycyAmJiB0ZXh0KSB7XG4gICAgICAgIG9wdGlvbnMuY2hhcnModGV4dCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBlbmRUYWdMZW5ndGggPSAwO1xuICAgICAgdmFyIHN0YWNrZWRUYWcgPSBsYXN0VGFnLnRvTG93ZXJDYXNlKCk7XG4gICAgICB2YXIgcmVTdGFja2VkVGFnID0gcmVDYWNoZVtzdGFja2VkVGFnXSB8fCAocmVDYWNoZVtzdGFja2VkVGFnXSA9IG5ldyBSZWdFeHAoJyhbXFxcXHNcXFxcU10qPykoPC8nICsgc3RhY2tlZFRhZyArICdbXj5dKj4pJywgJ2knKSk7XG4gICAgICB2YXIgcmVzdCQxID0gaHRtbC5yZXBsYWNlKHJlU3RhY2tlZFRhZywgZnVuY3Rpb24gKGFsbCwgdGV4dCwgZW5kVGFnKSB7XG4gICAgICAgIGVuZFRhZ0xlbmd0aCA9IGVuZFRhZy5sZW5ndGg7XG4gICAgICAgIGlmICghaXNQbGFpblRleHRFbGVtZW50KHN0YWNrZWRUYWcpICYmIHN0YWNrZWRUYWcgIT09ICdub3NjcmlwdCcpIHtcbiAgICAgICAgICB0ZXh0ID0gdGV4dFxuICAgICAgICAgICAgLnJlcGxhY2UoLzwhXFwtLShbXFxzXFxTXSo/KS0tPi9nLCAnJDEnKSAvLyAjNzI5OFxuICAgICAgICAgICAgLnJlcGxhY2UoLzwhXFxbQ0RBVEFcXFsoW1xcc1xcU10qPyldXT4vZywgJyQxJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNob3VsZElnbm9yZUZpcnN0TmV3bGluZShzdGFja2VkVGFnLCB0ZXh0KSkge1xuICAgICAgICAgIHRleHQgPSB0ZXh0LnNsaWNlKDEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmNoYXJzKSB7XG4gICAgICAgICAgb3B0aW9ucy5jaGFycyh0ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJydcbiAgICAgIH0pO1xuICAgICAgaW5kZXggKz0gaHRtbC5sZW5ndGggLSByZXN0JDEubGVuZ3RoO1xuICAgICAgaHRtbCA9IHJlc3QkMTtcbiAgICAgIHBhcnNlRW5kVGFnKHN0YWNrZWRUYWcsIGluZGV4IC0gZW5kVGFnTGVuZ3RoLCBpbmRleCk7XG4gICAgfVxuXG4gICAgaWYgKGh0bWwgPT09IGxhc3QpIHtcbiAgICAgIG9wdGlvbnMuY2hhcnMgJiYgb3B0aW9ucy5jaGFycyhodG1sKTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICFzdGFjay5sZW5ndGggJiYgb3B0aW9ucy53YXJuKSB7XG4gICAgICAgIG9wdGlvbnMud2FybigoXCJNYWwtZm9ybWF0dGVkIHRhZyBhdCBlbmQgb2YgdGVtcGxhdGU6IFxcXCJcIiArIGh0bWwgKyBcIlxcXCJcIikpO1xuICAgICAgfVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICAvLyBDbGVhbiB1cCBhbnkgcmVtYWluaW5nIHRhZ3NcbiAgcGFyc2VFbmRUYWcoKTtcblxuICBmdW5jdGlvbiBhZHZhbmNlIChuKSB7XG4gICAgaW5kZXggKz0gbjtcbiAgICBodG1sID0gaHRtbC5zdWJzdHJpbmcobik7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVN0YXJ0VGFnICgpIHtcbiAgICB2YXIgc3RhcnQgPSBodG1sLm1hdGNoKHN0YXJ0VGFnT3Blbik7XG4gICAgaWYgKHN0YXJ0KSB7XG4gICAgICB2YXIgbWF0Y2ggPSB7XG4gICAgICAgIHRhZ05hbWU6IHN0YXJ0WzFdLFxuICAgICAgICBhdHRyczogW10sXG4gICAgICAgIHN0YXJ0OiBpbmRleFxuICAgICAgfTtcbiAgICAgIGFkdmFuY2Uoc3RhcnRbMF0ubGVuZ3RoKTtcbiAgICAgIHZhciBlbmQsIGF0dHI7XG4gICAgICB3aGlsZSAoIShlbmQgPSBodG1sLm1hdGNoKHN0YXJ0VGFnQ2xvc2UpKSAmJiAoYXR0ciA9IGh0bWwubWF0Y2goYXR0cmlidXRlKSkpIHtcbiAgICAgICAgYWR2YW5jZShhdHRyWzBdLmxlbmd0aCk7XG4gICAgICAgIG1hdGNoLmF0dHJzLnB1c2goYXR0cik7XG4gICAgICB9XG4gICAgICBpZiAoZW5kKSB7XG4gICAgICAgIG1hdGNoLnVuYXJ5U2xhc2ggPSBlbmRbMV07XG4gICAgICAgIGFkdmFuY2UoZW5kWzBdLmxlbmd0aCk7XG4gICAgICAgIG1hdGNoLmVuZCA9IGluZGV4O1xuICAgICAgICByZXR1cm4gbWF0Y2hcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVTdGFydFRhZyAobWF0Y2gpIHtcbiAgICB2YXIgdGFnTmFtZSA9IG1hdGNoLnRhZ05hbWU7XG4gICAgdmFyIHVuYXJ5U2xhc2ggPSBtYXRjaC51bmFyeVNsYXNoO1xuXG4gICAgaWYgKGV4cGVjdEhUTUwpIHtcbiAgICAgIGlmIChsYXN0VGFnID09PSAncCcgJiYgaXNOb25QaHJhc2luZ1RhZyh0YWdOYW1lKSkge1xuICAgICAgICBwYXJzZUVuZFRhZyhsYXN0VGFnKTtcbiAgICAgIH1cbiAgICAgIGlmIChjYW5CZUxlZnRPcGVuVGFnJCQxKHRhZ05hbWUpICYmIGxhc3RUYWcgPT09IHRhZ05hbWUpIHtcbiAgICAgICAgcGFyc2VFbmRUYWcodGFnTmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHVuYXJ5ID0gaXNVbmFyeVRhZyQkMSh0YWdOYW1lKSB8fCAhIXVuYXJ5U2xhc2g7XG5cbiAgICB2YXIgbCA9IG1hdGNoLmF0dHJzLmxlbmd0aDtcbiAgICB2YXIgYXR0cnMgPSBuZXcgQXJyYXkobCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBhcmdzID0gbWF0Y2guYXR0cnNbaV07XG4gICAgICAvLyBoYWNraXNoIHdvcmsgYXJvdW5kIEZGIGJ1ZyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0zNjk3NzhcbiAgICAgIGlmIChJU19SRUdFWF9DQVBUVVJJTkdfQlJPS0VOICYmIGFyZ3NbMF0uaW5kZXhPZignXCJcIicpID09PSAtMSkge1xuICAgICAgICBpZiAoYXJnc1szXSA9PT0gJycpIHsgZGVsZXRlIGFyZ3NbM107IH1cbiAgICAgICAgaWYgKGFyZ3NbNF0gPT09ICcnKSB7IGRlbGV0ZSBhcmdzWzRdOyB9XG4gICAgICAgIGlmIChhcmdzWzVdID09PSAnJykgeyBkZWxldGUgYXJnc1s1XTsgfVxuICAgICAgfVxuICAgICAgdmFyIHZhbHVlID0gYXJnc1szXSB8fCBhcmdzWzRdIHx8IGFyZ3NbNV0gfHwgJyc7XG4gICAgICB2YXIgc2hvdWxkRGVjb2RlTmV3bGluZXMgPSB0YWdOYW1lID09PSAnYScgJiYgYXJnc1sxXSA9PT0gJ2hyZWYnXG4gICAgICAgID8gb3B0aW9ucy5zaG91bGREZWNvZGVOZXdsaW5lc0ZvckhyZWZcbiAgICAgICAgOiBvcHRpb25zLnNob3VsZERlY29kZU5ld2xpbmVzO1xuICAgICAgYXR0cnNbaV0gPSB7XG4gICAgICAgIG5hbWU6IGFyZ3NbMV0sXG4gICAgICAgIHZhbHVlOiBkZWNvZGVBdHRyKHZhbHVlLCBzaG91bGREZWNvZGVOZXdsaW5lcylcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKCF1bmFyeSkge1xuICAgICAgc3RhY2sucHVzaCh7IHRhZzogdGFnTmFtZSwgbG93ZXJDYXNlZFRhZzogdGFnTmFtZS50b0xvd2VyQ2FzZSgpLCBhdHRyczogYXR0cnMgfSk7XG4gICAgICBsYXN0VGFnID0gdGFnTmFtZTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5zdGFydCkge1xuICAgICAgb3B0aW9ucy5zdGFydCh0YWdOYW1lLCBhdHRycywgdW5hcnksIG1hdGNoLnN0YXJ0LCBtYXRjaC5lbmQpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlRW5kVGFnICh0YWdOYW1lLCBzdGFydCwgZW5kKSB7XG4gICAgdmFyIHBvcywgbG93ZXJDYXNlZFRhZ05hbWU7XG4gICAgaWYgKHN0YXJ0ID09IG51bGwpIHsgc3RhcnQgPSBpbmRleDsgfVxuICAgIGlmIChlbmQgPT0gbnVsbCkgeyBlbmQgPSBpbmRleDsgfVxuXG4gICAgaWYgKHRhZ05hbWUpIHtcbiAgICAgIGxvd2VyQ2FzZWRUYWdOYW1lID0gdGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cblxuICAgIC8vIEZpbmQgdGhlIGNsb3Nlc3Qgb3BlbmVkIHRhZyBvZiB0aGUgc2FtZSB0eXBlXG4gICAgaWYgKHRhZ05hbWUpIHtcbiAgICAgIGZvciAocG9zID0gc3RhY2subGVuZ3RoIC0gMTsgcG9zID49IDA7IHBvcy0tKSB7XG4gICAgICAgIGlmIChzdGFja1twb3NdLmxvd2VyQ2FzZWRUYWcgPT09IGxvd2VyQ2FzZWRUYWdOYW1lKSB7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiBubyB0YWcgbmFtZSBpcyBwcm92aWRlZCwgY2xlYW4gc2hvcFxuICAgICAgcG9zID0gMDtcbiAgICB9XG5cbiAgICBpZiAocG9zID49IDApIHtcbiAgICAgIC8vIENsb3NlIGFsbCB0aGUgb3BlbiBlbGVtZW50cywgdXAgdGhlIHN0YWNrXG4gICAgICBmb3IgKHZhciBpID0gc3RhY2subGVuZ3RoIC0gMTsgaSA+PSBwb3M7IGktLSkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgICAgIChpID4gcG9zIHx8ICF0YWdOYW1lKSAmJlxuICAgICAgICAgIG9wdGlvbnMud2FyblxuICAgICAgICApIHtcbiAgICAgICAgICBvcHRpb25zLndhcm4oXG4gICAgICAgICAgICAoXCJ0YWcgPFwiICsgKHN0YWNrW2ldLnRhZykgKyBcIj4gaGFzIG5vIG1hdGNoaW5nIGVuZCB0YWcuXCIpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5lbmQpIHtcbiAgICAgICAgICBvcHRpb25zLmVuZChzdGFja1tpXS50YWcsIHN0YXJ0LCBlbmQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFJlbW92ZSB0aGUgb3BlbiBlbGVtZW50cyBmcm9tIHRoZSBzdGFja1xuICAgICAgc3RhY2subGVuZ3RoID0gcG9zO1xuICAgICAgbGFzdFRhZyA9IHBvcyAmJiBzdGFja1twb3MgLSAxXS50YWc7XG4gICAgfSBlbHNlIGlmIChsb3dlckNhc2VkVGFnTmFtZSA9PT0gJ2JyJykge1xuICAgICAgaWYgKG9wdGlvbnMuc3RhcnQpIHtcbiAgICAgICAgb3B0aW9ucy5zdGFydCh0YWdOYW1lLCBbXSwgdHJ1ZSwgc3RhcnQsIGVuZCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChsb3dlckNhc2VkVGFnTmFtZSA9PT0gJ3AnKSB7XG4gICAgICBpZiAob3B0aW9ucy5zdGFydCkge1xuICAgICAgICBvcHRpb25zLnN0YXJ0KHRhZ05hbWUsIFtdLCBmYWxzZSwgc3RhcnQsIGVuZCk7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5lbmQpIHtcbiAgICAgICAgb3B0aW9ucy5lbmQodGFnTmFtZSwgc3RhcnQsIGVuZCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgb25SRSA9IC9eQHxedi1vbjovO1xudmFyIGRpclJFID0gL152LXxeQHxeOi87XG52YXIgZm9yQWxpYXNSRSA9IC8oW15dKj8pXFxzKyg/OmlufG9mKVxccysoW15dKikvO1xudmFyIGZvckl0ZXJhdG9yUkUgPSAvLChbXixcXH1cXF1dKikoPzosKFteLFxcfVxcXV0qKSk/JC87XG52YXIgc3RyaXBQYXJlbnNSRSA9IC9eXFwofFxcKSQvZztcblxudmFyIGFyZ1JFID0gLzooLiopJC87XG52YXIgYmluZFJFID0gL146fF52LWJpbmQ6LztcbnZhciBtb2RpZmllclJFID0gL1xcLlteLl0rL2c7XG5cbnZhciBkZWNvZGVIVE1MQ2FjaGVkID0gY2FjaGVkKGhlLmRlY29kZSk7XG5cbi8vIGNvbmZpZ3VyYWJsZSBzdGF0ZVxudmFyIHdhcm4kMjtcbnZhciBkZWxpbWl0ZXJzO1xudmFyIHRyYW5zZm9ybXM7XG52YXIgcHJlVHJhbnNmb3JtcztcbnZhciBwb3N0VHJhbnNmb3JtcztcbnZhciBwbGF0Zm9ybUlzUHJlVGFnO1xudmFyIHBsYXRmb3JtTXVzdFVzZVByb3A7XG52YXIgcGxhdGZvcm1HZXRUYWdOYW1lc3BhY2U7XG5cblxuXG5mdW5jdGlvbiBjcmVhdGVBU1RFbGVtZW50IChcbiAgdGFnLFxuICBhdHRycyxcbiAgcGFyZW50XG4pIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAxLFxuICAgIHRhZzogdGFnLFxuICAgIGF0dHJzTGlzdDogYXR0cnMsXG4gICAgYXR0cnNNYXA6IG1ha2VBdHRyc01hcChhdHRycyksXG4gICAgcGFyZW50OiBwYXJlbnQsXG4gICAgY2hpbGRyZW46IFtdXG4gIH1cbn1cblxuLyoqXG4gKiBDb252ZXJ0IEhUTUwgc3RyaW5nIHRvIEFTVC5cbiAqL1xuZnVuY3Rpb24gcGFyc2UgKFxuICB0ZW1wbGF0ZSxcbiAgb3B0aW9uc1xuKSB7XG4gIHdhcm4kMiA9IG9wdGlvbnMud2FybiB8fCBiYXNlV2FybjtcblxuICBwbGF0Zm9ybUlzUHJlVGFnID0gb3B0aW9ucy5pc1ByZVRhZyB8fCBubztcbiAgcGxhdGZvcm1NdXN0VXNlUHJvcCA9IG9wdGlvbnMubXVzdFVzZVByb3AgfHwgbm87XG4gIHBsYXRmb3JtR2V0VGFnTmFtZXNwYWNlID0gb3B0aW9ucy5nZXRUYWdOYW1lc3BhY2UgfHwgbm87XG5cbiAgdHJhbnNmb3JtcyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAndHJhbnNmb3JtTm9kZScpO1xuICBwcmVUcmFuc2Zvcm1zID0gcGx1Y2tNb2R1bGVGdW5jdGlvbihvcHRpb25zLm1vZHVsZXMsICdwcmVUcmFuc2Zvcm1Ob2RlJyk7XG4gIHBvc3RUcmFuc2Zvcm1zID0gcGx1Y2tNb2R1bGVGdW5jdGlvbihvcHRpb25zLm1vZHVsZXMsICdwb3N0VHJhbnNmb3JtTm9kZScpO1xuXG4gIGRlbGltaXRlcnMgPSBvcHRpb25zLmRlbGltaXRlcnM7XG5cbiAgdmFyIHN0YWNrID0gW107XG4gIHZhciBwcmVzZXJ2ZVdoaXRlc3BhY2UgPSBvcHRpb25zLnByZXNlcnZlV2hpdGVzcGFjZSAhPT0gZmFsc2U7XG4gIHZhciByb290O1xuICB2YXIgY3VycmVudFBhcmVudDtcbiAgdmFyIGluVlByZSA9IGZhbHNlO1xuICB2YXIgaW5QcmUgPSBmYWxzZTtcbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIHdhcm5PbmNlIChtc2cpIHtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICAgIHdhcm4kMihtc2cpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNsb3NlRWxlbWVudCAoZWxlbWVudCkge1xuICAgIC8vIGNoZWNrIHByZSBzdGF0ZVxuICAgIGlmIChlbGVtZW50LnByZSkge1xuICAgICAgaW5WUHJlID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChwbGF0Zm9ybUlzUHJlVGFnKGVsZW1lbnQudGFnKSkge1xuICAgICAgaW5QcmUgPSBmYWxzZTtcbiAgICB9XG4gICAgLy8gYXBwbHkgcG9zdC10cmFuc2Zvcm1zXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb3N0VHJhbnNmb3Jtcy5sZW5ndGg7IGkrKykge1xuICAgICAgcG9zdFRyYW5zZm9ybXNbaV0oZWxlbWVudCwgb3B0aW9ucyk7XG4gICAgfVxuICB9XG5cbiAgcGFyc2VIVE1MKHRlbXBsYXRlLCB7XG4gICAgd2Fybjogd2FybiQyLFxuICAgIGV4cGVjdEhUTUw6IG9wdGlvbnMuZXhwZWN0SFRNTCxcbiAgICBpc1VuYXJ5VGFnOiBvcHRpb25zLmlzVW5hcnlUYWcsXG4gICAgY2FuQmVMZWZ0T3BlblRhZzogb3B0aW9ucy5jYW5CZUxlZnRPcGVuVGFnLFxuICAgIHNob3VsZERlY29kZU5ld2xpbmVzOiBvcHRpb25zLnNob3VsZERlY29kZU5ld2xpbmVzLFxuICAgIHNob3VsZERlY29kZU5ld2xpbmVzRm9ySHJlZjogb3B0aW9ucy5zaG91bGREZWNvZGVOZXdsaW5lc0ZvckhyZWYsXG4gICAgc2hvdWxkS2VlcENvbW1lbnQ6IG9wdGlvbnMuY29tbWVudHMsXG4gICAgc3RhcnQ6IGZ1bmN0aW9uIHN0YXJ0ICh0YWcsIGF0dHJzLCB1bmFyeSkge1xuICAgICAgLy8gY2hlY2sgbmFtZXNwYWNlLlxuICAgICAgLy8gaW5oZXJpdCBwYXJlbnQgbnMgaWYgdGhlcmUgaXMgb25lXG4gICAgICB2YXIgbnMgPSAoY3VycmVudFBhcmVudCAmJiBjdXJyZW50UGFyZW50Lm5zKSB8fCBwbGF0Zm9ybUdldFRhZ05hbWVzcGFjZSh0YWcpO1xuXG4gICAgICAvLyBoYW5kbGUgSUUgc3ZnIGJ1Z1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoaXNJRSAmJiBucyA9PT0gJ3N2ZycpIHtcbiAgICAgICAgYXR0cnMgPSBndWFyZElFU1ZHQnVnKGF0dHJzKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGVsZW1lbnQgPSBjcmVhdGVBU1RFbGVtZW50KHRhZywgYXR0cnMsIGN1cnJlbnRQYXJlbnQpO1xuICAgICAgaWYgKG5zKSB7XG4gICAgICAgIGVsZW1lbnQubnMgPSBucztcbiAgICAgIH1cblxuICAgICAgaWYgKGlzRm9yYmlkZGVuVGFnKGVsZW1lbnQpICYmICFpc1NlcnZlclJlbmRlcmluZygpKSB7XG4gICAgICAgIGVsZW1lbnQuZm9yYmlkZGVuID0gdHJ1ZTtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuJDIoXG4gICAgICAgICAgJ1RlbXBsYXRlcyBzaG91bGQgb25seSBiZSByZXNwb25zaWJsZSBmb3IgbWFwcGluZyB0aGUgc3RhdGUgdG8gdGhlICcgK1xuICAgICAgICAgICdVSS4gQXZvaWQgcGxhY2luZyB0YWdzIHdpdGggc2lkZS1lZmZlY3RzIGluIHlvdXIgdGVtcGxhdGVzLCBzdWNoIGFzICcgK1xuICAgICAgICAgIFwiPFwiICsgdGFnICsgXCI+XCIgKyAnLCBhcyB0aGV5IHdpbGwgbm90IGJlIHBhcnNlZC4nXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIC8vIGFwcGx5IHByZS10cmFuc2Zvcm1zXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByZVRyYW5zZm9ybXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZWxlbWVudCA9IHByZVRyYW5zZm9ybXNbaV0oZWxlbWVudCwgb3B0aW9ucykgfHwgZWxlbWVudDtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpblZQcmUpIHtcbiAgICAgICAgcHJvY2Vzc1ByZShlbGVtZW50KTtcbiAgICAgICAgaWYgKGVsZW1lbnQucHJlKSB7XG4gICAgICAgICAgaW5WUHJlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHBsYXRmb3JtSXNQcmVUYWcoZWxlbWVudC50YWcpKSB7XG4gICAgICAgIGluUHJlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpblZQcmUpIHtcbiAgICAgICAgcHJvY2Vzc1Jhd0F0dHJzKGVsZW1lbnQpO1xuICAgICAgfSBlbHNlIGlmICghZWxlbWVudC5wcm9jZXNzZWQpIHtcbiAgICAgICAgLy8gc3RydWN0dXJhbCBkaXJlY3RpdmVzXG4gICAgICAgIHByb2Nlc3NGb3IoZWxlbWVudCk7XG4gICAgICAgIHByb2Nlc3NJZihlbGVtZW50KTtcbiAgICAgICAgcHJvY2Vzc09uY2UoZWxlbWVudCk7XG4gICAgICAgIC8vIGVsZW1lbnQtc2NvcGUgc3R1ZmZcbiAgICAgICAgcHJvY2Vzc0VsZW1lbnQoZWxlbWVudCwgb3B0aW9ucyk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGNoZWNrUm9vdENvbnN0cmFpbnRzIChlbCkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGlmIChlbC50YWcgPT09ICdzbG90JyB8fCBlbC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgICAgICAgIHdhcm5PbmNlKFxuICAgICAgICAgICAgICBcIkNhbm5vdCB1c2UgPFwiICsgKGVsLnRhZykgKyBcIj4gYXMgY29tcG9uZW50IHJvb3QgZWxlbWVudCBiZWNhdXNlIGl0IG1heSBcIiArXG4gICAgICAgICAgICAgICdjb250YWluIG11bHRpcGxlIG5vZGVzLidcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChlbC5hdHRyc01hcC5oYXNPd25Qcm9wZXJ0eSgndi1mb3InKSkge1xuICAgICAgICAgICAgd2Fybk9uY2UoXG4gICAgICAgICAgICAgICdDYW5ub3QgdXNlIHYtZm9yIG9uIHN0YXRlZnVsIGNvbXBvbmVudCByb290IGVsZW1lbnQgYmVjYXVzZSAnICtcbiAgICAgICAgICAgICAgJ2l0IHJlbmRlcnMgbXVsdGlwbGUgZWxlbWVudHMuJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gdHJlZSBtYW5hZ2VtZW50XG4gICAgICBpZiAoIXJvb3QpIHtcbiAgICAgICAgcm9vdCA9IGVsZW1lbnQ7XG4gICAgICAgIGNoZWNrUm9vdENvbnN0cmFpbnRzKHJvb3QpO1xuICAgICAgfSBlbHNlIGlmICghc3RhY2subGVuZ3RoKSB7XG4gICAgICAgIC8vIGFsbG93IHJvb3QgZWxlbWVudHMgd2l0aCB2LWlmLCB2LWVsc2UtaWYgYW5kIHYtZWxzZVxuICAgICAgICBpZiAocm9vdC5pZiAmJiAoZWxlbWVudC5lbHNlaWYgfHwgZWxlbWVudC5lbHNlKSkge1xuICAgICAgICAgIGNoZWNrUm9vdENvbnN0cmFpbnRzKGVsZW1lbnQpO1xuICAgICAgICAgIGFkZElmQ29uZGl0aW9uKHJvb3QsIHtcbiAgICAgICAgICAgIGV4cDogZWxlbWVudC5lbHNlaWYsXG4gICAgICAgICAgICBibG9jazogZWxlbWVudFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICB3YXJuT25jZShcbiAgICAgICAgICAgIFwiQ29tcG9uZW50IHRlbXBsYXRlIHNob3VsZCBjb250YWluIGV4YWN0bHkgb25lIHJvb3QgZWxlbWVudC4gXCIgK1xuICAgICAgICAgICAgXCJJZiB5b3UgYXJlIHVzaW5nIHYtaWYgb24gbXVsdGlwbGUgZWxlbWVudHMsIFwiICtcbiAgICAgICAgICAgIFwidXNlIHYtZWxzZS1pZiB0byBjaGFpbiB0aGVtIGluc3RlYWQuXCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY3VycmVudFBhcmVudCAmJiAhZWxlbWVudC5mb3JiaWRkZW4pIHtcbiAgICAgICAgaWYgKGVsZW1lbnQuZWxzZWlmIHx8IGVsZW1lbnQuZWxzZSkge1xuICAgICAgICAgIHByb2Nlc3NJZkNvbmRpdGlvbnMoZWxlbWVudCwgY3VycmVudFBhcmVudCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZWxlbWVudC5zbG90U2NvcGUpIHsgLy8gc2NvcGVkIHNsb3RcbiAgICAgICAgICBjdXJyZW50UGFyZW50LnBsYWluID0gZmFsc2U7XG4gICAgICAgICAgdmFyIG5hbWUgPSBlbGVtZW50LnNsb3RUYXJnZXQgfHwgJ1wiZGVmYXVsdFwiJzsoY3VycmVudFBhcmVudC5zY29wZWRTbG90cyB8fCAoY3VycmVudFBhcmVudC5zY29wZWRTbG90cyA9IHt9KSlbbmFtZV0gPSBlbGVtZW50O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN1cnJlbnRQYXJlbnQuY2hpbGRyZW4ucHVzaChlbGVtZW50KTtcbiAgICAgICAgICBlbGVtZW50LnBhcmVudCA9IGN1cnJlbnRQYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghdW5hcnkpIHtcbiAgICAgICAgY3VycmVudFBhcmVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHN0YWNrLnB1c2goZWxlbWVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjbG9zZUVsZW1lbnQoZWxlbWVudCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGVuZDogZnVuY3Rpb24gZW5kICgpIHtcbiAgICAgIC8vIHJlbW92ZSB0cmFpbGluZyB3aGl0ZXNwYWNlXG4gICAgICB2YXIgZWxlbWVudCA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgdmFyIGxhc3ROb2RlID0gZWxlbWVudC5jaGlsZHJlbltlbGVtZW50LmNoaWxkcmVuLmxlbmd0aCAtIDFdO1xuICAgICAgaWYgKGxhc3ROb2RlICYmIGxhc3ROb2RlLnR5cGUgPT09IDMgJiYgbGFzdE5vZGUudGV4dCA9PT0gJyAnICYmICFpblByZSkge1xuICAgICAgICBlbGVtZW50LmNoaWxkcmVuLnBvcCgpO1xuICAgICAgfVxuICAgICAgLy8gcG9wIHN0YWNrXG4gICAgICBzdGFjay5sZW5ndGggLT0gMTtcbiAgICAgIGN1cnJlbnRQYXJlbnQgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcbiAgICAgIGNsb3NlRWxlbWVudChlbGVtZW50KTtcbiAgICB9LFxuXG4gICAgY2hhcnM6IGZ1bmN0aW9uIGNoYXJzICh0ZXh0KSB7XG4gICAgICBpZiAoIWN1cnJlbnRQYXJlbnQpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBpZiAodGV4dCA9PT0gdGVtcGxhdGUpIHtcbiAgICAgICAgICAgIHdhcm5PbmNlKFxuICAgICAgICAgICAgICAnQ29tcG9uZW50IHRlbXBsYXRlIHJlcXVpcmVzIGEgcm9vdCBlbGVtZW50LCByYXRoZXIgdGhhbiBqdXN0IHRleHQuJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCh0ZXh0ID0gdGV4dC50cmltKCkpKSB7XG4gICAgICAgICAgICB3YXJuT25jZShcbiAgICAgICAgICAgICAgKFwidGV4dCBcXFwiXCIgKyB0ZXh0ICsgXCJcXFwiIG91dHNpZGUgcm9vdCBlbGVtZW50IHdpbGwgYmUgaWdub3JlZC5cIilcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgLy8gSUUgdGV4dGFyZWEgcGxhY2Vob2xkZXIgYnVnXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChpc0lFICYmXG4gICAgICAgIGN1cnJlbnRQYXJlbnQudGFnID09PSAndGV4dGFyZWEnICYmXG4gICAgICAgIGN1cnJlbnRQYXJlbnQuYXR0cnNNYXAucGxhY2Vob2xkZXIgPT09IHRleHRcbiAgICAgICkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIHZhciBjaGlsZHJlbiA9IGN1cnJlbnRQYXJlbnQuY2hpbGRyZW47XG4gICAgICB0ZXh0ID0gaW5QcmUgfHwgdGV4dC50cmltKClcbiAgICAgICAgPyBpc1RleHRUYWcoY3VycmVudFBhcmVudCkgPyB0ZXh0IDogZGVjb2RlSFRNTENhY2hlZCh0ZXh0KVxuICAgICAgICAvLyBvbmx5IHByZXNlcnZlIHdoaXRlc3BhY2UgaWYgaXRzIG5vdCByaWdodCBhZnRlciBhIHN0YXJ0aW5nIHRhZ1xuICAgICAgICA6IHByZXNlcnZlV2hpdGVzcGFjZSAmJiBjaGlsZHJlbi5sZW5ndGggPyAnICcgOiAnJztcbiAgICAgIGlmICh0ZXh0KSB7XG4gICAgICAgIHZhciByZXM7XG4gICAgICAgIGlmICghaW5WUHJlICYmIHRleHQgIT09ICcgJyAmJiAocmVzID0gcGFyc2VUZXh0KHRleHQsIGRlbGltaXRlcnMpKSkge1xuICAgICAgICAgIGNoaWxkcmVuLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogMixcbiAgICAgICAgICAgIGV4cHJlc3Npb246IHJlcy5leHByZXNzaW9uLFxuICAgICAgICAgICAgdG9rZW5zOiByZXMudG9rZW5zLFxuICAgICAgICAgICAgdGV4dDogdGV4dFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKHRleHQgIT09ICcgJyB8fCAhY2hpbGRyZW4ubGVuZ3RoIHx8IGNoaWxkcmVuW2NoaWxkcmVuLmxlbmd0aCAtIDFdLnRleHQgIT09ICcgJykge1xuICAgICAgICAgIGNoaWxkcmVuLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogMyxcbiAgICAgICAgICAgIHRleHQ6IHRleHRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgY29tbWVudDogZnVuY3Rpb24gY29tbWVudCAodGV4dCkge1xuICAgICAgY3VycmVudFBhcmVudC5jaGlsZHJlbi5wdXNoKHtcbiAgICAgICAgdHlwZTogMyxcbiAgICAgICAgdGV4dDogdGV4dCxcbiAgICAgICAgaXNDb21tZW50OiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcm9vdFxufVxuXG5mdW5jdGlvbiBwcm9jZXNzUHJlIChlbCkge1xuICBpZiAoZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtcHJlJykgIT0gbnVsbCkge1xuICAgIGVsLnByZSA9IHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc1Jhd0F0dHJzIChlbCkge1xuICB2YXIgbCA9IGVsLmF0dHJzTGlzdC5sZW5ndGg7XG4gIGlmIChsKSB7XG4gICAgdmFyIGF0dHJzID0gZWwuYXR0cnMgPSBuZXcgQXJyYXkobCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgIGF0dHJzW2ldID0ge1xuICAgICAgICBuYW1lOiBlbC5hdHRyc0xpc3RbaV0ubmFtZSxcbiAgICAgICAgdmFsdWU6IEpTT04uc3RyaW5naWZ5KGVsLmF0dHJzTGlzdFtpXS52YWx1ZSlcbiAgICAgIH07XG4gICAgfVxuICB9IGVsc2UgaWYgKCFlbC5wcmUpIHtcbiAgICAvLyBub24gcm9vdCBub2RlIGluIHByZSBibG9ja3Mgd2l0aCBubyBhdHRyaWJ1dGVzXG4gICAgZWwucGxhaW4gPSB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NFbGVtZW50IChlbGVtZW50LCBvcHRpb25zKSB7XG4gIHByb2Nlc3NLZXkoZWxlbWVudCk7XG5cbiAgLy8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhpcyBpcyBhIHBsYWluIGVsZW1lbnQgYWZ0ZXJcbiAgLy8gcmVtb3Zpbmcgc3RydWN0dXJhbCBhdHRyaWJ1dGVzXG4gIGVsZW1lbnQucGxhaW4gPSAhZWxlbWVudC5rZXkgJiYgIWVsZW1lbnQuYXR0cnNMaXN0Lmxlbmd0aDtcblxuICBwcm9jZXNzUmVmKGVsZW1lbnQpO1xuICBwcm9jZXNzU2xvdChlbGVtZW50KTtcbiAgcHJvY2Vzc0NvbXBvbmVudChlbGVtZW50KTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFuc2Zvcm1zLmxlbmd0aDsgaSsrKSB7XG4gICAgZWxlbWVudCA9IHRyYW5zZm9ybXNbaV0oZWxlbWVudCwgb3B0aW9ucykgfHwgZWxlbWVudDtcbiAgfVxuICBwcm9jZXNzQXR0cnMoZWxlbWVudCk7XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NLZXkgKGVsKSB7XG4gIHZhciBleHAgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ2tleScpO1xuICBpZiAoZXhwKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgZWwudGFnID09PSAndGVtcGxhdGUnKSB7XG4gICAgICB3YXJuJDIoXCI8dGVtcGxhdGU+IGNhbm5vdCBiZSBrZXllZC4gUGxhY2UgdGhlIGtleSBvbiByZWFsIGVsZW1lbnRzIGluc3RlYWQuXCIpO1xuICAgIH1cbiAgICBlbC5rZXkgPSBleHA7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc1JlZiAoZWwpIHtcbiAgdmFyIHJlZiA9IGdldEJpbmRpbmdBdHRyKGVsLCAncmVmJyk7XG4gIGlmIChyZWYpIHtcbiAgICBlbC5yZWYgPSByZWY7XG4gICAgZWwucmVmSW5Gb3IgPSBjaGVja0luRm9yKGVsKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzRm9yIChlbCkge1xuICB2YXIgZXhwO1xuICBpZiAoKGV4cCA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWZvcicpKSkge1xuICAgIHZhciByZXMgPSBwYXJzZUZvcihleHApO1xuICAgIGlmIChyZXMpIHtcbiAgICAgIGV4dGVuZChlbCwgcmVzKTtcbiAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHdhcm4kMihcbiAgICAgICAgKFwiSW52YWxpZCB2LWZvciBleHByZXNzaW9uOiBcIiArIGV4cClcbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5cblxuXG5mdW5jdGlvbiBwYXJzZUZvciAoZXhwKSB7XG4gIHZhciBpbk1hdGNoID0gZXhwLm1hdGNoKGZvckFsaWFzUkUpO1xuICBpZiAoIWluTWF0Y2gpIHsgcmV0dXJuIH1cbiAgdmFyIHJlcyA9IHt9O1xuICByZXMuZm9yID0gaW5NYXRjaFsyXS50cmltKCk7XG4gIHZhciBhbGlhcyA9IGluTWF0Y2hbMV0udHJpbSgpLnJlcGxhY2Uoc3RyaXBQYXJlbnNSRSwgJycpO1xuICB2YXIgaXRlcmF0b3JNYXRjaCA9IGFsaWFzLm1hdGNoKGZvckl0ZXJhdG9yUkUpO1xuICBpZiAoaXRlcmF0b3JNYXRjaCkge1xuICAgIHJlcy5hbGlhcyA9IGFsaWFzLnJlcGxhY2UoZm9ySXRlcmF0b3JSRSwgJycpO1xuICAgIHJlcy5pdGVyYXRvcjEgPSBpdGVyYXRvck1hdGNoWzFdLnRyaW0oKTtcbiAgICBpZiAoaXRlcmF0b3JNYXRjaFsyXSkge1xuICAgICAgcmVzLml0ZXJhdG9yMiA9IGl0ZXJhdG9yTWF0Y2hbMl0udHJpbSgpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXMuYWxpYXMgPSBhbGlhcztcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NJZiAoZWwpIHtcbiAgdmFyIGV4cCA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWlmJyk7XG4gIGlmIChleHApIHtcbiAgICBlbC5pZiA9IGV4cDtcbiAgICBhZGRJZkNvbmRpdGlvbihlbCwge1xuICAgICAgZXhwOiBleHAsXG4gICAgICBibG9jazogZWxcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtZWxzZScpICE9IG51bGwpIHtcbiAgICAgIGVsLmVsc2UgPSB0cnVlO1xuICAgIH1cbiAgICB2YXIgZWxzZWlmID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtZWxzZS1pZicpO1xuICAgIGlmIChlbHNlaWYpIHtcbiAgICAgIGVsLmVsc2VpZiA9IGVsc2VpZjtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0lmQ29uZGl0aW9ucyAoZWwsIHBhcmVudCkge1xuICB2YXIgcHJldiA9IGZpbmRQcmV2RWxlbWVudChwYXJlbnQuY2hpbGRyZW4pO1xuICBpZiAocHJldiAmJiBwcmV2LmlmKSB7XG4gICAgYWRkSWZDb25kaXRpb24ocHJldiwge1xuICAgICAgZXhwOiBlbC5lbHNlaWYsXG4gICAgICBibG9jazogZWxcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgd2FybiQyKFxuICAgICAgXCJ2LVwiICsgKGVsLmVsc2VpZiA/ICgnZWxzZS1pZj1cIicgKyBlbC5lbHNlaWYgKyAnXCInKSA6ICdlbHNlJykgKyBcIiBcIiArXG4gICAgICBcInVzZWQgb24gZWxlbWVudCA8XCIgKyAoZWwudGFnKSArIFwiPiB3aXRob3V0IGNvcnJlc3BvbmRpbmcgdi1pZi5cIlxuICAgICk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluZFByZXZFbGVtZW50IChjaGlsZHJlbikge1xuICB2YXIgaSA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIGlmIChjaGlsZHJlbltpXS50eXBlID09PSAxKSB7XG4gICAgICByZXR1cm4gY2hpbGRyZW5baV1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY2hpbGRyZW5baV0udGV4dCAhPT0gJyAnKSB7XG4gICAgICAgIHdhcm4kMihcbiAgICAgICAgICBcInRleHQgXFxcIlwiICsgKGNoaWxkcmVuW2ldLnRleHQudHJpbSgpKSArIFwiXFxcIiBiZXR3ZWVuIHYtaWYgYW5kIHYtZWxzZSgtaWYpIFwiICtcbiAgICAgICAgICBcIndpbGwgYmUgaWdub3JlZC5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY2hpbGRyZW4ucG9wKCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFkZElmQ29uZGl0aW9uIChlbCwgY29uZGl0aW9uKSB7XG4gIGlmICghZWwuaWZDb25kaXRpb25zKSB7XG4gICAgZWwuaWZDb25kaXRpb25zID0gW107XG4gIH1cbiAgZWwuaWZDb25kaXRpb25zLnB1c2goY29uZGl0aW9uKTtcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc09uY2UgKGVsKSB7XG4gIHZhciBvbmNlJCQxID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3Ytb25jZScpO1xuICBpZiAob25jZSQkMSAhPSBudWxsKSB7XG4gICAgZWwub25jZSA9IHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc1Nsb3QgKGVsKSB7XG4gIGlmIChlbC50YWcgPT09ICdzbG90Jykge1xuICAgIGVsLnNsb3ROYW1lID0gZ2V0QmluZGluZ0F0dHIoZWwsICduYW1lJyk7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgZWwua2V5KSB7XG4gICAgICB3YXJuJDIoXG4gICAgICAgIFwiYGtleWAgZG9lcyBub3Qgd29yayBvbiA8c2xvdD4gYmVjYXVzZSBzbG90cyBhcmUgYWJzdHJhY3Qgb3V0bGV0cyBcIiArXG4gICAgICAgIFwiYW5kIGNhbiBwb3NzaWJseSBleHBhbmQgaW50byBtdWx0aXBsZSBlbGVtZW50cy4gXCIgK1xuICAgICAgICBcIlVzZSB0aGUga2V5IG9uIGEgd3JhcHBpbmcgZWxlbWVudCBpbnN0ZWFkLlwiXG4gICAgICApO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgc2xvdFNjb3BlO1xuICAgIGlmIChlbC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgIHNsb3RTY29wZSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICdzY29wZScpO1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBzbG90U2NvcGUpIHtcbiAgICAgICAgd2FybiQyKFxuICAgICAgICAgIFwidGhlIFxcXCJzY29wZVxcXCIgYXR0cmlidXRlIGZvciBzY29wZWQgc2xvdHMgaGF2ZSBiZWVuIGRlcHJlY2F0ZWQgYW5kIFwiICtcbiAgICAgICAgICBcInJlcGxhY2VkIGJ5IFxcXCJzbG90LXNjb3BlXFxcIiBzaW5jZSAyLjUuIFRoZSBuZXcgXFxcInNsb3Qtc2NvcGVcXFwiIGF0dHJpYnV0ZSBcIiArXG4gICAgICAgICAgXCJjYW4gYWxzbyBiZSB1c2VkIG9uIHBsYWluIGVsZW1lbnRzIGluIGFkZGl0aW9uIHRvIDx0ZW1wbGF0ZT4gdG8gXCIgK1xuICAgICAgICAgIFwiZGVub3RlIHNjb3BlZCBzbG90cy5cIixcbiAgICAgICAgICB0cnVlXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBlbC5zbG90U2NvcGUgPSBzbG90U2NvcGUgfHwgZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3Nsb3Qtc2NvcGUnKTtcbiAgICB9IGVsc2UgaWYgKChzbG90U2NvcGUgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnc2xvdC1zY29wZScpKSkge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBlbC5hdHRyc01hcFsndi1mb3InXSkge1xuICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgXCJBbWJpZ3VvdXMgY29tYmluZWQgdXNhZ2Ugb2Ygc2xvdC1zY29wZSBhbmQgdi1mb3Igb24gPFwiICsgKGVsLnRhZykgKyBcIj4gXCIgK1xuICAgICAgICAgIFwiKHYtZm9yIHRha2VzIGhpZ2hlciBwcmlvcml0eSkuIFVzZSBhIHdyYXBwZXIgPHRlbXBsYXRlPiBmb3IgdGhlIFwiICtcbiAgICAgICAgICBcInNjb3BlZCBzbG90IHRvIG1ha2UgaXQgY2xlYXJlci5cIixcbiAgICAgICAgICB0cnVlXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBlbC5zbG90U2NvcGUgPSBzbG90U2NvcGU7XG4gICAgfVxuICAgIHZhciBzbG90VGFyZ2V0ID0gZ2V0QmluZGluZ0F0dHIoZWwsICdzbG90Jyk7XG4gICAgaWYgKHNsb3RUYXJnZXQpIHtcbiAgICAgIGVsLnNsb3RUYXJnZXQgPSBzbG90VGFyZ2V0ID09PSAnXCJcIicgPyAnXCJkZWZhdWx0XCInIDogc2xvdFRhcmdldDtcbiAgICAgIC8vIHByZXNlcnZlIHNsb3QgYXMgYW4gYXR0cmlidXRlIGZvciBuYXRpdmUgc2hhZG93IERPTSBjb21wYXRcbiAgICAgIC8vIG9ubHkgZm9yIG5vbi1zY29wZWQgc2xvdHMuXG4gICAgICBpZiAoZWwudGFnICE9PSAndGVtcGxhdGUnICYmICFlbC5zbG90U2NvcGUpIHtcbiAgICAgICAgYWRkQXR0cihlbCwgJ3Nsb3QnLCBzbG90VGFyZ2V0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0NvbXBvbmVudCAoZWwpIHtcbiAgdmFyIGJpbmRpbmc7XG4gIGlmICgoYmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAnaXMnKSkpIHtcbiAgICBlbC5jb21wb25lbnQgPSBiaW5kaW5nO1xuICB9XG4gIGlmIChnZXRBbmRSZW1vdmVBdHRyKGVsLCAnaW5saW5lLXRlbXBsYXRlJykgIT0gbnVsbCkge1xuICAgIGVsLmlubGluZVRlbXBsYXRlID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzQXR0cnMgKGVsKSB7XG4gIHZhciBsaXN0ID0gZWwuYXR0cnNMaXN0O1xuICB2YXIgaSwgbCwgbmFtZSwgcmF3TmFtZSwgdmFsdWUsIG1vZGlmaWVycywgaXNQcm9wO1xuICBmb3IgKGkgPSAwLCBsID0gbGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBuYW1lID0gcmF3TmFtZSA9IGxpc3RbaV0ubmFtZTtcbiAgICB2YWx1ZSA9IGxpc3RbaV0udmFsdWU7XG4gICAgaWYgKGRpclJFLnRlc3QobmFtZSkpIHtcbiAgICAgIC8vIG1hcmsgZWxlbWVudCBhcyBkeW5hbWljXG4gICAgICBlbC5oYXNCaW5kaW5ncyA9IHRydWU7XG4gICAgICAvLyBtb2RpZmllcnNcbiAgICAgIG1vZGlmaWVycyA9IHBhcnNlTW9kaWZpZXJzKG5hbWUpO1xuICAgICAgaWYgKG1vZGlmaWVycykge1xuICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKG1vZGlmaWVyUkUsICcnKTtcbiAgICAgIH1cbiAgICAgIGlmIChiaW5kUkUudGVzdChuYW1lKSkgeyAvLyB2LWJpbmRcbiAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShiaW5kUkUsICcnKTtcbiAgICAgICAgdmFsdWUgPSBwYXJzZUZpbHRlcnModmFsdWUpO1xuICAgICAgICBpc1Byb3AgPSBmYWxzZTtcbiAgICAgICAgaWYgKG1vZGlmaWVycykge1xuICAgICAgICAgIGlmIChtb2RpZmllcnMucHJvcCkge1xuICAgICAgICAgICAgaXNQcm9wID0gdHJ1ZTtcbiAgICAgICAgICAgIG5hbWUgPSBjYW1lbGl6ZShuYW1lKTtcbiAgICAgICAgICAgIGlmIChuYW1lID09PSAnaW5uZXJIdG1sJykgeyBuYW1lID0gJ2lubmVySFRNTCc7IH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1vZGlmaWVycy5jYW1lbCkge1xuICAgICAgICAgICAgbmFtZSA9IGNhbWVsaXplKG5hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobW9kaWZpZXJzLnN5bmMpIHtcbiAgICAgICAgICAgIGFkZEhhbmRsZXIoXG4gICAgICAgICAgICAgIGVsLFxuICAgICAgICAgICAgICAoXCJ1cGRhdGU6XCIgKyAoY2FtZWxpemUobmFtZSkpKSxcbiAgICAgICAgICAgICAgZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIFwiJGV2ZW50XCIpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNQcm9wIHx8IChcbiAgICAgICAgICAhZWwuY29tcG9uZW50ICYmIHBsYXRmb3JtTXVzdFVzZVByb3AoZWwudGFnLCBlbC5hdHRyc01hcC50eXBlLCBuYW1lKVxuICAgICAgICApKSB7XG4gICAgICAgICAgYWRkUHJvcChlbCwgbmFtZSwgdmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFkZEF0dHIoZWwsIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChvblJFLnRlc3QobmFtZSkpIHsgLy8gdi1vblxuICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKG9uUkUsICcnKTtcbiAgICAgICAgYWRkSGFuZGxlcihlbCwgbmFtZSwgdmFsdWUsIG1vZGlmaWVycywgZmFsc2UsIHdhcm4kMik7XG4gICAgICB9IGVsc2UgeyAvLyBub3JtYWwgZGlyZWN0aXZlc1xuICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKGRpclJFLCAnJyk7XG4gICAgICAgIC8vIHBhcnNlIGFyZ1xuICAgICAgICB2YXIgYXJnTWF0Y2ggPSBuYW1lLm1hdGNoKGFyZ1JFKTtcbiAgICAgICAgdmFyIGFyZyA9IGFyZ01hdGNoICYmIGFyZ01hdGNoWzFdO1xuICAgICAgICBpZiAoYXJnKSB7XG4gICAgICAgICAgbmFtZSA9IG5hbWUuc2xpY2UoMCwgLShhcmcubGVuZ3RoICsgMSkpO1xuICAgICAgICB9XG4gICAgICAgIGFkZERpcmVjdGl2ZShlbCwgbmFtZSwgcmF3TmFtZSwgdmFsdWUsIGFyZywgbW9kaWZpZXJzKTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgbmFtZSA9PT0gJ21vZGVsJykge1xuICAgICAgICAgIGNoZWNrRm9yQWxpYXNNb2RlbChlbCwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGxpdGVyYWwgYXR0cmlidXRlXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB2YXIgcmVzID0gcGFyc2VUZXh0KHZhbHVlLCBkZWxpbWl0ZXJzKTtcbiAgICAgICAgaWYgKHJlcykge1xuICAgICAgICAgIHdhcm4kMihcbiAgICAgICAgICAgIG5hbWUgKyBcIj1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIjogXCIgK1xuICAgICAgICAgICAgJ0ludGVycG9sYXRpb24gaW5zaWRlIGF0dHJpYnV0ZXMgaGFzIGJlZW4gcmVtb3ZlZC4gJyArXG4gICAgICAgICAgICAnVXNlIHYtYmluZCBvciB0aGUgY29sb24gc2hvcnRoYW5kIGluc3RlYWQuIEZvciBleGFtcGxlLCAnICtcbiAgICAgICAgICAgICdpbnN0ZWFkIG9mIDxkaXYgaWQ9XCJ7eyB2YWwgfX1cIj4sIHVzZSA8ZGl2IDppZD1cInZhbFwiPi4nXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYWRkQXR0cihlbCwgbmFtZSwgSlNPTi5zdHJpbmdpZnkodmFsdWUpKTtcbiAgICAgIC8vICM2ODg3IGZpcmVmb3ggZG9lc24ndCB1cGRhdGUgbXV0ZWQgc3RhdGUgaWYgc2V0IHZpYSBhdHRyaWJ1dGVcbiAgICAgIC8vIGV2ZW4gaW1tZWRpYXRlbHkgYWZ0ZXIgZWxlbWVudCBjcmVhdGlvblxuICAgICAgaWYgKCFlbC5jb21wb25lbnQgJiZcbiAgICAgICAgICBuYW1lID09PSAnbXV0ZWQnICYmXG4gICAgICAgICAgcGxhdGZvcm1NdXN0VXNlUHJvcChlbC50YWcsIGVsLmF0dHJzTWFwLnR5cGUsIG5hbWUpKSB7XG4gICAgICAgIGFkZFByb3AoZWwsIG5hbWUsICd0cnVlJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrSW5Gb3IgKGVsKSB7XG4gIHZhciBwYXJlbnQgPSBlbDtcbiAgd2hpbGUgKHBhcmVudCkge1xuICAgIGlmIChwYXJlbnQuZm9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIHBhcnNlTW9kaWZpZXJzIChuYW1lKSB7XG4gIHZhciBtYXRjaCA9IG5hbWUubWF0Y2gobW9kaWZpZXJSRSk7XG4gIGlmIChtYXRjaCkge1xuICAgIHZhciByZXQgPSB7fTtcbiAgICBtYXRjaC5mb3JFYWNoKGZ1bmN0aW9uIChtKSB7IHJldFttLnNsaWNlKDEpXSA9IHRydWU7IH0pO1xuICAgIHJldHVybiByZXRcbiAgfVxufVxuXG5mdW5jdGlvbiBtYWtlQXR0cnNNYXAgKGF0dHJzKSB7XG4gIHZhciBtYXAgPSB7fTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBhdHRycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoXG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICBtYXBbYXR0cnNbaV0ubmFtZV0gJiYgIWlzSUUgJiYgIWlzRWRnZVxuICAgICkge1xuICAgICAgd2FybiQyKCdkdXBsaWNhdGUgYXR0cmlidXRlOiAnICsgYXR0cnNbaV0ubmFtZSk7XG4gICAgfVxuICAgIG1hcFthdHRyc1tpXS5uYW1lXSA9IGF0dHJzW2ldLnZhbHVlO1xuICB9XG4gIHJldHVybiBtYXBcbn1cblxuLy8gZm9yIHNjcmlwdCAoZS5nLiB0eXBlPVwieC90ZW1wbGF0ZVwiKSBvciBzdHlsZSwgZG8gbm90IGRlY29kZSBjb250ZW50XG5mdW5jdGlvbiBpc1RleHRUYWcgKGVsKSB7XG4gIHJldHVybiBlbC50YWcgPT09ICdzY3JpcHQnIHx8IGVsLnRhZyA9PT0gJ3N0eWxlJ1xufVxuXG5mdW5jdGlvbiBpc0ZvcmJpZGRlblRhZyAoZWwpIHtcbiAgcmV0dXJuIChcbiAgICBlbC50YWcgPT09ICdzdHlsZScgfHxcbiAgICAoZWwudGFnID09PSAnc2NyaXB0JyAmJiAoXG4gICAgICAhZWwuYXR0cnNNYXAudHlwZSB8fFxuICAgICAgZWwuYXR0cnNNYXAudHlwZSA9PT0gJ3RleHQvamF2YXNjcmlwdCdcbiAgICApKVxuICApXG59XG5cbnZhciBpZU5TQnVnID0gL154bWxuczpOU1xcZCsvO1xudmFyIGllTlNQcmVmaXggPSAvXk5TXFxkKzovO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gZ3VhcmRJRVNWR0J1ZyAoYXR0cnMpIHtcbiAgdmFyIHJlcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGF0dHJzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGF0dHIgPSBhdHRyc1tpXTtcbiAgICBpZiAoIWllTlNCdWcudGVzdChhdHRyLm5hbWUpKSB7XG4gICAgICBhdHRyLm5hbWUgPSBhdHRyLm5hbWUucmVwbGFjZShpZU5TUHJlZml4LCAnJyk7XG4gICAgICByZXMucHVzaChhdHRyKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBjaGVja0ZvckFsaWFzTW9kZWwgKGVsLCB2YWx1ZSkge1xuICB2YXIgX2VsID0gZWw7XG4gIHdoaWxlIChfZWwpIHtcbiAgICBpZiAoX2VsLmZvciAmJiBfZWwuYWxpYXMgPT09IHZhbHVlKSB7XG4gICAgICB3YXJuJDIoXG4gICAgICAgIFwiPFwiICsgKGVsLnRhZykgKyBcIiB2LW1vZGVsPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiPjogXCIgK1xuICAgICAgICBcIllvdSBhcmUgYmluZGluZyB2LW1vZGVsIGRpcmVjdGx5IHRvIGEgdi1mb3IgaXRlcmF0aW9uIGFsaWFzLiBcIiArXG4gICAgICAgIFwiVGhpcyB3aWxsIG5vdCBiZSBhYmxlIHRvIG1vZGlmeSB0aGUgdi1mb3Igc291cmNlIGFycmF5IGJlY2F1c2UgXCIgK1xuICAgICAgICBcIndyaXRpbmcgdG8gdGhlIGFsaWFzIGlzIGxpa2UgbW9kaWZ5aW5nIGEgZnVuY3Rpb24gbG9jYWwgdmFyaWFibGUuIFwiICtcbiAgICAgICAgXCJDb25zaWRlciB1c2luZyBhbiBhcnJheSBvZiBvYmplY3RzIGFuZCB1c2Ugdi1tb2RlbCBvbiBhbiBvYmplY3QgcHJvcGVydHkgaW5zdGVhZC5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgX2VsID0gX2VsLnBhcmVudDtcbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBFeHBhbmQgaW5wdXRbdi1tb2RlbF0gd2l0aCBkeWFubWljIHR5cGUgYmluZGluZ3MgaW50byB2LWlmLWVsc2UgY2hhaW5zXG4gKiBUdXJuIHRoaXM6XG4gKiAgIDxpbnB1dCB2LW1vZGVsPVwiZGF0YVt0eXBlXVwiIDp0eXBlPVwidHlwZVwiPlxuICogaW50byB0aGlzOlxuICogICA8aW5wdXQgdi1pZj1cInR5cGUgPT09ICdjaGVja2JveCdcIiB0eXBlPVwiY2hlY2tib3hcIiB2LW1vZGVsPVwiZGF0YVt0eXBlXVwiPlxuICogICA8aW5wdXQgdi1lbHNlLWlmPVwidHlwZSA9PT0gJ3JhZGlvJ1wiIHR5cGU9XCJyYWRpb1wiIHYtbW9kZWw9XCJkYXRhW3R5cGVdXCI+XG4gKiAgIDxpbnB1dCB2LWVsc2UgOnR5cGU9XCJ0eXBlXCIgdi1tb2RlbD1cImRhdGFbdHlwZV1cIj5cbiAqL1xuXG5mdW5jdGlvbiBwcmVUcmFuc2Zvcm1Ob2RlIChlbCwgb3B0aW9ucykge1xuICBpZiAoZWwudGFnID09PSAnaW5wdXQnKSB7XG4gICAgdmFyIG1hcCA9IGVsLmF0dHJzTWFwO1xuICAgIGlmICghbWFwWyd2LW1vZGVsJ10pIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHZhciB0eXBlQmluZGluZztcbiAgICBpZiAobWFwWyc6dHlwZSddIHx8IG1hcFsndi1iaW5kOnR5cGUnXSkge1xuICAgICAgdHlwZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3R5cGUnKTtcbiAgICB9XG4gICAgaWYgKCFtYXAudHlwZSAmJiAhdHlwZUJpbmRpbmcgJiYgbWFwWyd2LWJpbmQnXSkge1xuICAgICAgdHlwZUJpbmRpbmcgPSBcIihcIiArIChtYXBbJ3YtYmluZCddKSArIFwiKS50eXBlXCI7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVCaW5kaW5nKSB7XG4gICAgICB2YXIgaWZDb25kaXRpb24gPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1pZicsIHRydWUpO1xuICAgICAgdmFyIGlmQ29uZGl0aW9uRXh0cmEgPSBpZkNvbmRpdGlvbiA/IChcIiYmKFwiICsgaWZDb25kaXRpb24gKyBcIilcIikgOiBcIlwiO1xuICAgICAgdmFyIGhhc0Vsc2UgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1lbHNlJywgdHJ1ZSkgIT0gbnVsbDtcbiAgICAgIHZhciBlbHNlSWZDb25kaXRpb24gPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1lbHNlLWlmJywgdHJ1ZSk7XG4gICAgICAvLyAxLiBjaGVja2JveFxuICAgICAgdmFyIGJyYW5jaDAgPSBjbG9uZUFTVEVsZW1lbnQoZWwpO1xuICAgICAgLy8gcHJvY2VzcyBmb3Igb24gdGhlIG1haW4gbm9kZVxuICAgICAgcHJvY2Vzc0ZvcihicmFuY2gwKTtcbiAgICAgIGFkZFJhd0F0dHIoYnJhbmNoMCwgJ3R5cGUnLCAnY2hlY2tib3gnKTtcbiAgICAgIHByb2Nlc3NFbGVtZW50KGJyYW5jaDAsIG9wdGlvbnMpO1xuICAgICAgYnJhbmNoMC5wcm9jZXNzZWQgPSB0cnVlOyAvLyBwcmV2ZW50IGl0IGZyb20gZG91YmxlLXByb2Nlc3NlZFxuICAgICAgYnJhbmNoMC5pZiA9IFwiKFwiICsgdHlwZUJpbmRpbmcgKyBcIik9PT0nY2hlY2tib3gnXCIgKyBpZkNvbmRpdGlvbkV4dHJhO1xuICAgICAgYWRkSWZDb25kaXRpb24oYnJhbmNoMCwge1xuICAgICAgICBleHA6IGJyYW5jaDAuaWYsXG4gICAgICAgIGJsb2NrOiBicmFuY2gwXG4gICAgICB9KTtcbiAgICAgIC8vIDIuIGFkZCByYWRpbyBlbHNlLWlmIGNvbmRpdGlvblxuICAgICAgdmFyIGJyYW5jaDEgPSBjbG9uZUFTVEVsZW1lbnQoZWwpO1xuICAgICAgZ2V0QW5kUmVtb3ZlQXR0cihicmFuY2gxLCAndi1mb3InLCB0cnVlKTtcbiAgICAgIGFkZFJhd0F0dHIoYnJhbmNoMSwgJ3R5cGUnLCAncmFkaW8nKTtcbiAgICAgIHByb2Nlc3NFbGVtZW50KGJyYW5jaDEsIG9wdGlvbnMpO1xuICAgICAgYWRkSWZDb25kaXRpb24oYnJhbmNoMCwge1xuICAgICAgICBleHA6IFwiKFwiICsgdHlwZUJpbmRpbmcgKyBcIik9PT0ncmFkaW8nXCIgKyBpZkNvbmRpdGlvbkV4dHJhLFxuICAgICAgICBibG9jazogYnJhbmNoMVxuICAgICAgfSk7XG4gICAgICAvLyAzLiBvdGhlclxuICAgICAgdmFyIGJyYW5jaDIgPSBjbG9uZUFTVEVsZW1lbnQoZWwpO1xuICAgICAgZ2V0QW5kUmVtb3ZlQXR0cihicmFuY2gyLCAndi1mb3InLCB0cnVlKTtcbiAgICAgIGFkZFJhd0F0dHIoYnJhbmNoMiwgJzp0eXBlJywgdHlwZUJpbmRpbmcpO1xuICAgICAgcHJvY2Vzc0VsZW1lbnQoYnJhbmNoMiwgb3B0aW9ucyk7XG4gICAgICBhZGRJZkNvbmRpdGlvbihicmFuY2gwLCB7XG4gICAgICAgIGV4cDogaWZDb25kaXRpb24sXG4gICAgICAgIGJsb2NrOiBicmFuY2gyXG4gICAgICB9KTtcblxuICAgICAgaWYgKGhhc0Vsc2UpIHtcbiAgICAgICAgYnJhbmNoMC5lbHNlID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoZWxzZUlmQ29uZGl0aW9uKSB7XG4gICAgICAgIGJyYW5jaDAuZWxzZWlmID0gZWxzZUlmQ29uZGl0aW9uO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYnJhbmNoMFxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjbG9uZUFTVEVsZW1lbnQgKGVsKSB7XG4gIHJldHVybiBjcmVhdGVBU1RFbGVtZW50KGVsLnRhZywgZWwuYXR0cnNMaXN0LnNsaWNlKCksIGVsLnBhcmVudClcbn1cblxudmFyIG1vZGVsJDIgPSB7XG4gIHByZVRyYW5zZm9ybU5vZGU6IHByZVRyYW5zZm9ybU5vZGVcbn1cblxudmFyIG1vZHVsZXMkMSA9IFtcbiAga2xhc3MkMSxcbiAgc3R5bGUkMSxcbiAgbW9kZWwkMlxuXVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gdGV4dCAoZWwsIGRpcikge1xuICBpZiAoZGlyLnZhbHVlKSB7XG4gICAgYWRkUHJvcChlbCwgJ3RleHRDb250ZW50JywgKFwiX3MoXCIgKyAoZGlyLnZhbHVlKSArIFwiKVwiKSk7XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGh0bWwgKGVsLCBkaXIpIHtcbiAgaWYgKGRpci52YWx1ZSkge1xuICAgIGFkZFByb3AoZWwsICdpbm5lckhUTUwnLCAoXCJfcyhcIiArIChkaXIudmFsdWUpICsgXCIpXCIpKTtcbiAgfVxufVxuXG52YXIgZGlyZWN0aXZlcyQxID0ge1xuICBtb2RlbDogbW9kZWwsXG4gIHRleHQ6IHRleHQsXG4gIGh0bWw6IGh0bWxcbn1cblxuLyogICovXG5cbnZhciBiYXNlT3B0aW9ucyA9IHtcbiAgZXhwZWN0SFRNTDogdHJ1ZSxcbiAgbW9kdWxlczogbW9kdWxlcyQxLFxuICBkaXJlY3RpdmVzOiBkaXJlY3RpdmVzJDEsXG4gIGlzUHJlVGFnOiBpc1ByZVRhZyxcbiAgaXNVbmFyeVRhZzogaXNVbmFyeVRhZyxcbiAgbXVzdFVzZVByb3A6IG11c3RVc2VQcm9wLFxuICBjYW5CZUxlZnRPcGVuVGFnOiBjYW5CZUxlZnRPcGVuVGFnLFxuICBpc1Jlc2VydmVkVGFnOiBpc1Jlc2VydmVkVGFnLFxuICBnZXRUYWdOYW1lc3BhY2U6IGdldFRhZ05hbWVzcGFjZSxcbiAgc3RhdGljS2V5czogZ2VuU3RhdGljS2V5cyhtb2R1bGVzJDEpXG59O1xuXG4vKiAgKi9cblxudmFyIGlzU3RhdGljS2V5O1xudmFyIGlzUGxhdGZvcm1SZXNlcnZlZFRhZztcblxudmFyIGdlblN0YXRpY0tleXNDYWNoZWQgPSBjYWNoZWQoZ2VuU3RhdGljS2V5cyQxKTtcblxuLyoqXG4gKiBHb2FsIG9mIHRoZSBvcHRpbWl6ZXI6IHdhbGsgdGhlIGdlbmVyYXRlZCB0ZW1wbGF0ZSBBU1QgdHJlZVxuICogYW5kIGRldGVjdCBzdWItdHJlZXMgdGhhdCBhcmUgcHVyZWx5IHN0YXRpYywgaS5lLiBwYXJ0cyBvZlxuICogdGhlIERPTSB0aGF0IG5ldmVyIG5lZWRzIHRvIGNoYW5nZS5cbiAqXG4gKiBPbmNlIHdlIGRldGVjdCB0aGVzZSBzdWItdHJlZXMsIHdlIGNhbjpcbiAqXG4gKiAxLiBIb2lzdCB0aGVtIGludG8gY29uc3RhbnRzLCBzbyB0aGF0IHdlIG5vIGxvbmdlciBuZWVkIHRvXG4gKiAgICBjcmVhdGUgZnJlc2ggbm9kZXMgZm9yIHRoZW0gb24gZWFjaCByZS1yZW5kZXI7XG4gKiAyLiBDb21wbGV0ZWx5IHNraXAgdGhlbSBpbiB0aGUgcGF0Y2hpbmcgcHJvY2Vzcy5cbiAqL1xuZnVuY3Rpb24gb3B0aW1pemUgKHJvb3QsIG9wdGlvbnMpIHtcbiAgaWYgKCFyb290KSB7IHJldHVybiB9XG4gIGlzU3RhdGljS2V5ID0gZ2VuU3RhdGljS2V5c0NhY2hlZChvcHRpb25zLnN0YXRpY0tleXMgfHwgJycpO1xuICBpc1BsYXRmb3JtUmVzZXJ2ZWRUYWcgPSBvcHRpb25zLmlzUmVzZXJ2ZWRUYWcgfHwgbm87XG4gIC8vIGZpcnN0IHBhc3M6IG1hcmsgYWxsIG5vbi1zdGF0aWMgbm9kZXMuXG4gIG1hcmtTdGF0aWMkMShyb290KTtcbiAgLy8gc2Vjb25kIHBhc3M6IG1hcmsgc3RhdGljIHJvb3RzLlxuICBtYXJrU3RhdGljUm9vdHMocm9vdCwgZmFsc2UpO1xufVxuXG5mdW5jdGlvbiBnZW5TdGF0aWNLZXlzJDEgKGtleXMpIHtcbiAgcmV0dXJuIG1ha2VNYXAoXG4gICAgJ3R5cGUsdGFnLGF0dHJzTGlzdCxhdHRyc01hcCxwbGFpbixwYXJlbnQsY2hpbGRyZW4sYXR0cnMnICtcbiAgICAoa2V5cyA/ICcsJyArIGtleXMgOiAnJylcbiAgKVxufVxuXG5mdW5jdGlvbiBtYXJrU3RhdGljJDEgKG5vZGUpIHtcbiAgbm9kZS5zdGF0aWMgPSBpc1N0YXRpYyhub2RlKTtcbiAgaWYgKG5vZGUudHlwZSA9PT0gMSkge1xuICAgIC8vIGRvIG5vdCBtYWtlIGNvbXBvbmVudCBzbG90IGNvbnRlbnQgc3RhdGljLiB0aGlzIGF2b2lkc1xuICAgIC8vIDEuIGNvbXBvbmVudHMgbm90IGFibGUgdG8gbXV0YXRlIHNsb3Qgbm9kZXNcbiAgICAvLyAyLiBzdGF0aWMgc2xvdCBjb250ZW50IGZhaWxzIGZvciBob3QtcmVsb2FkaW5nXG4gICAgaWYgKFxuICAgICAgIWlzUGxhdGZvcm1SZXNlcnZlZFRhZyhub2RlLnRhZykgJiZcbiAgICAgIG5vZGUudGFnICE9PSAnc2xvdCcgJiZcbiAgICAgIG5vZGUuYXR0cnNNYXBbJ2lubGluZS10ZW1wbGF0ZSddID09IG51bGxcbiAgICApIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgbWFya1N0YXRpYyQxKGNoaWxkKTtcbiAgICAgIGlmICghY2hpbGQuc3RhdGljKSB7XG4gICAgICAgIG5vZGUuc3RhdGljID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChub2RlLmlmQ29uZGl0aW9ucykge1xuICAgICAgZm9yICh2YXIgaSQxID0gMSwgbCQxID0gbm9kZS5pZkNvbmRpdGlvbnMubGVuZ3RoOyBpJDEgPCBsJDE7IGkkMSsrKSB7XG4gICAgICAgIHZhciBibG9jayA9IG5vZGUuaWZDb25kaXRpb25zW2kkMV0uYmxvY2s7XG4gICAgICAgIG1hcmtTdGF0aWMkMShibG9jayk7XG4gICAgICAgIGlmICghYmxvY2suc3RhdGljKSB7XG4gICAgICAgICAgbm9kZS5zdGF0aWMgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBtYXJrU3RhdGljUm9vdHMgKG5vZGUsIGlzSW5Gb3IpIHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gMSkge1xuICAgIGlmIChub2RlLnN0YXRpYyB8fCBub2RlLm9uY2UpIHtcbiAgICAgIG5vZGUuc3RhdGljSW5Gb3IgPSBpc0luRm9yO1xuICAgIH1cbiAgICAvLyBGb3IgYSBub2RlIHRvIHF1YWxpZnkgYXMgYSBzdGF0aWMgcm9vdCwgaXQgc2hvdWxkIGhhdmUgY2hpbGRyZW4gdGhhdFxuICAgIC8vIGFyZSBub3QganVzdCBzdGF0aWMgdGV4dC4gT3RoZXJ3aXNlIHRoZSBjb3N0IG9mIGhvaXN0aW5nIG91dCB3aWxsXG4gICAgLy8gb3V0d2VpZ2ggdGhlIGJlbmVmaXRzIGFuZCBpdCdzIGJldHRlciBvZmYgdG8ganVzdCBhbHdheXMgcmVuZGVyIGl0IGZyZXNoLlxuICAgIGlmIChub2RlLnN0YXRpYyAmJiBub2RlLmNoaWxkcmVuLmxlbmd0aCAmJiAhKFxuICAgICAgbm9kZS5jaGlsZHJlbi5sZW5ndGggPT09IDEgJiZcbiAgICAgIG5vZGUuY2hpbGRyZW5bMF0udHlwZSA9PT0gM1xuICAgICkpIHtcbiAgICAgIG5vZGUuc3RhdGljUm9vdCA9IHRydWU7XG4gICAgICByZXR1cm5cbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5zdGF0aWNSb290ID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChub2RlLmNoaWxkcmVuKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIG1hcmtTdGF0aWNSb290cyhub2RlLmNoaWxkcmVuW2ldLCBpc0luRm9yIHx8ICEhbm9kZS5mb3IpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobm9kZS5pZkNvbmRpdGlvbnMpIHtcbiAgICAgIGZvciAodmFyIGkkMSA9IDEsIGwkMSA9IG5vZGUuaWZDb25kaXRpb25zLmxlbmd0aDsgaSQxIDwgbCQxOyBpJDErKykge1xuICAgICAgICBtYXJrU3RhdGljUm9vdHMobm9kZS5pZkNvbmRpdGlvbnNbaSQxXS5ibG9jaywgaXNJbkZvcik7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGlzU3RhdGljIChub2RlKSB7XG4gIGlmIChub2RlLnR5cGUgPT09IDIpIHsgLy8gZXhwcmVzc2lvblxuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIGlmIChub2RlLnR5cGUgPT09IDMpIHsgLy8gdGV4dFxuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgcmV0dXJuICEhKG5vZGUucHJlIHx8IChcbiAgICAhbm9kZS5oYXNCaW5kaW5ncyAmJiAvLyBubyBkeW5hbWljIGJpbmRpbmdzXG4gICAgIW5vZGUuaWYgJiYgIW5vZGUuZm9yICYmIC8vIG5vdCB2LWlmIG9yIHYtZm9yIG9yIHYtZWxzZVxuICAgICFpc0J1aWx0SW5UYWcobm9kZS50YWcpICYmIC8vIG5vdCBhIGJ1aWx0LWluXG4gICAgaXNQbGF0Zm9ybVJlc2VydmVkVGFnKG5vZGUudGFnKSAmJiAvLyBub3QgYSBjb21wb25lbnRcbiAgICAhaXNEaXJlY3RDaGlsZE9mVGVtcGxhdGVGb3Iobm9kZSkgJiZcbiAgICBPYmplY3Qua2V5cyhub2RlKS5ldmVyeShpc1N0YXRpY0tleSlcbiAgKSlcbn1cblxuZnVuY3Rpb24gaXNEaXJlY3RDaGlsZE9mVGVtcGxhdGVGb3IgKG5vZGUpIHtcbiAgd2hpbGUgKG5vZGUucGFyZW50KSB7XG4gICAgbm9kZSA9IG5vZGUucGFyZW50O1xuICAgIGlmIChub2RlLnRhZyAhPT0gJ3RlbXBsYXRlJykge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIGlmIChub2RlLmZvcikge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbi8qICAqL1xuXG52YXIgZm5FeHBSRSA9IC9eKFtcXHckX10rfFxcKFteKV0qP1xcKSlcXHMqPT58XmZ1bmN0aW9uXFxzKlxcKC87XG52YXIgc2ltcGxlUGF0aFJFID0gL15bQS1aYS16XyRdW1xcdyRdKig/OlxcLltBLVphLXpfJF1bXFx3JF0qfFxcWydbXiddKj8nXXxcXFtcIlteXCJdKj9cIl18XFxbXFxkK118XFxbW0EtWmEtel8kXVtcXHckXSpdKSokLztcblxuLy8gS2V5Ym9hcmRFdmVudC5rZXlDb2RlIGFsaWFzZXNcbnZhciBrZXlDb2RlcyA9IHtcbiAgZXNjOiAyNyxcbiAgdGFiOiA5LFxuICBlbnRlcjogMTMsXG4gIHNwYWNlOiAzMixcbiAgdXA6IDM4LFxuICBsZWZ0OiAzNyxcbiAgcmlnaHQ6IDM5LFxuICBkb3duOiA0MCxcbiAgJ2RlbGV0ZSc6IFs4LCA0Nl1cbn07XG5cbi8vIEtleWJvYXJkRXZlbnQua2V5IGFsaWFzZXNcbnZhciBrZXlOYW1lcyA9IHtcbiAgZXNjOiAnRXNjYXBlJyxcbiAgdGFiOiAnVGFiJyxcbiAgZW50ZXI6ICdFbnRlcicsXG4gIHNwYWNlOiAnICcsXG4gIC8vICM3ODA2OiBJRTExIHVzZXMga2V5IG5hbWVzIHdpdGhvdXQgYEFycm93YCBwcmVmaXggZm9yIGFycm93IGtleXMuXG4gIHVwOiBbJ1VwJywgJ0Fycm93VXAnXSxcbiAgbGVmdDogWydMZWZ0JywgJ0Fycm93TGVmdCddLFxuICByaWdodDogWydSaWdodCcsICdBcnJvd1JpZ2h0J10sXG4gIGRvd246IFsnRG93bicsICdBcnJvd0Rvd24nXSxcbiAgJ2RlbGV0ZSc6IFsnQmFja3NwYWNlJywgJ0RlbGV0ZSddXG59O1xuXG4vLyAjNDg2ODogbW9kaWZpZXJzIHRoYXQgcHJldmVudCB0aGUgZXhlY3V0aW9uIG9mIHRoZSBsaXN0ZW5lclxuLy8gbmVlZCB0byBleHBsaWNpdGx5IHJldHVybiBudWxsIHNvIHRoYXQgd2UgY2FuIGRldGVybWluZSB3aGV0aGVyIHRvIHJlbW92ZVxuLy8gdGhlIGxpc3RlbmVyIGZvciAub25jZVxudmFyIGdlbkd1YXJkID0gZnVuY3Rpb24gKGNvbmRpdGlvbikgeyByZXR1cm4gKFwiaWYoXCIgKyBjb25kaXRpb24gKyBcIilyZXR1cm4gbnVsbDtcIik7IH07XG5cbnZhciBtb2RpZmllckNvZGUgPSB7XG4gIHN0b3A6ICckZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7JyxcbiAgcHJldmVudDogJyRldmVudC5wcmV2ZW50RGVmYXVsdCgpOycsXG4gIHNlbGY6IGdlbkd1YXJkKFwiJGV2ZW50LnRhcmdldCAhPT0gJGV2ZW50LmN1cnJlbnRUYXJnZXRcIiksXG4gIGN0cmw6IGdlbkd1YXJkKFwiISRldmVudC5jdHJsS2V5XCIpLFxuICBzaGlmdDogZ2VuR3VhcmQoXCIhJGV2ZW50LnNoaWZ0S2V5XCIpLFxuICBhbHQ6IGdlbkd1YXJkKFwiISRldmVudC5hbHRLZXlcIiksXG4gIG1ldGE6IGdlbkd1YXJkKFwiISRldmVudC5tZXRhS2V5XCIpLFxuICBsZWZ0OiBnZW5HdWFyZChcIididXR0b24nIGluICRldmVudCAmJiAkZXZlbnQuYnV0dG9uICE9PSAwXCIpLFxuICBtaWRkbGU6IGdlbkd1YXJkKFwiJ2J1dHRvbicgaW4gJGV2ZW50ICYmICRldmVudC5idXR0b24gIT09IDFcIiksXG4gIHJpZ2h0OiBnZW5HdWFyZChcIididXR0b24nIGluICRldmVudCAmJiAkZXZlbnQuYnV0dG9uICE9PSAyXCIpXG59O1xuXG5mdW5jdGlvbiBnZW5IYW5kbGVycyAoXG4gIGV2ZW50cyxcbiAgaXNOYXRpdmUsXG4gIHdhcm5cbikge1xuICB2YXIgcmVzID0gaXNOYXRpdmUgPyAnbmF0aXZlT246eycgOiAnb246eyc7XG4gIGZvciAodmFyIG5hbWUgaW4gZXZlbnRzKSB7XG4gICAgcmVzICs9IFwiXFxcIlwiICsgbmFtZSArIFwiXFxcIjpcIiArIChnZW5IYW5kbGVyKG5hbWUsIGV2ZW50c1tuYW1lXSkpICsgXCIsXCI7XG4gIH1cbiAgcmV0dXJuIHJlcy5zbGljZSgwLCAtMSkgKyAnfSdcbn1cblxuZnVuY3Rpb24gZ2VuSGFuZGxlciAoXG4gIG5hbWUsXG4gIGhhbmRsZXJcbikge1xuICBpZiAoIWhhbmRsZXIpIHtcbiAgICByZXR1cm4gJ2Z1bmN0aW9uKCl7fSdcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KGhhbmRsZXIpKSB7XG4gICAgcmV0dXJuIChcIltcIiArIChoYW5kbGVyLm1hcChmdW5jdGlvbiAoaGFuZGxlcikgeyByZXR1cm4gZ2VuSGFuZGxlcihuYW1lLCBoYW5kbGVyKTsgfSkuam9pbignLCcpKSArIFwiXVwiKVxuICB9XG5cbiAgdmFyIGlzTWV0aG9kUGF0aCA9IHNpbXBsZVBhdGhSRS50ZXN0KGhhbmRsZXIudmFsdWUpO1xuICB2YXIgaXNGdW5jdGlvbkV4cHJlc3Npb24gPSBmbkV4cFJFLnRlc3QoaGFuZGxlci52YWx1ZSk7XG5cbiAgaWYgKCFoYW5kbGVyLm1vZGlmaWVycykge1xuICAgIGlmIChpc01ldGhvZFBhdGggfHwgaXNGdW5jdGlvbkV4cHJlc3Npb24pIHtcbiAgICAgIHJldHVybiBoYW5kbGVyLnZhbHVlXG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIHJldHVybiAoXCJmdW5jdGlvbigkZXZlbnQpe1wiICsgKGhhbmRsZXIudmFsdWUpICsgXCJ9XCIpIC8vIGlubGluZSBzdGF0ZW1lbnRcbiAgfSBlbHNlIHtcbiAgICB2YXIgY29kZSA9ICcnO1xuICAgIHZhciBnZW5Nb2RpZmllckNvZGUgPSAnJztcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBoYW5kbGVyLm1vZGlmaWVycykge1xuICAgICAgaWYgKG1vZGlmaWVyQ29kZVtrZXldKSB7XG4gICAgICAgIGdlbk1vZGlmaWVyQ29kZSArPSBtb2RpZmllckNvZGVba2V5XTtcbiAgICAgICAgLy8gbGVmdC9yaWdodFxuICAgICAgICBpZiAoa2V5Q29kZXNba2V5XSkge1xuICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ2V4YWN0Jykge1xuICAgICAgICB2YXIgbW9kaWZpZXJzID0gKGhhbmRsZXIubW9kaWZpZXJzKTtcbiAgICAgICAgZ2VuTW9kaWZpZXJDb2RlICs9IGdlbkd1YXJkKFxuICAgICAgICAgIFsnY3RybCcsICdzaGlmdCcsICdhbHQnLCAnbWV0YSddXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChrZXlNb2RpZmllcikgeyByZXR1cm4gIW1vZGlmaWVyc1trZXlNb2RpZmllcl07IH0pXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChrZXlNb2RpZmllcikgeyByZXR1cm4gKFwiJGV2ZW50LlwiICsga2V5TW9kaWZpZXIgKyBcIktleVwiKTsgfSlcbiAgICAgICAgICAgIC5qb2luKCd8fCcpXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGtleXMubGVuZ3RoKSB7XG4gICAgICBjb2RlICs9IGdlbktleUZpbHRlcihrZXlzKTtcbiAgICB9XG4gICAgLy8gTWFrZSBzdXJlIG1vZGlmaWVycyBsaWtlIHByZXZlbnQgYW5kIHN0b3AgZ2V0IGV4ZWN1dGVkIGFmdGVyIGtleSBmaWx0ZXJpbmdcbiAgICBpZiAoZ2VuTW9kaWZpZXJDb2RlKSB7XG4gICAgICBjb2RlICs9IGdlbk1vZGlmaWVyQ29kZTtcbiAgICB9XG4gICAgdmFyIGhhbmRsZXJDb2RlID0gaXNNZXRob2RQYXRoXG4gICAgICA/IChcInJldHVybiBcIiArIChoYW5kbGVyLnZhbHVlKSArIFwiKCRldmVudClcIilcbiAgICAgIDogaXNGdW5jdGlvbkV4cHJlc3Npb25cbiAgICAgICAgPyAoXCJyZXR1cm4gKFwiICsgKGhhbmRsZXIudmFsdWUpICsgXCIpKCRldmVudClcIilcbiAgICAgICAgOiBoYW5kbGVyLnZhbHVlO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIHJldHVybiAoXCJmdW5jdGlvbigkZXZlbnQpe1wiICsgY29kZSArIGhhbmRsZXJDb2RlICsgXCJ9XCIpXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuS2V5RmlsdGVyIChrZXlzKSB7XG4gIHJldHVybiAoXCJpZighKCdidXR0b24nIGluICRldmVudCkmJlwiICsgKGtleXMubWFwKGdlbkZpbHRlckNvZGUpLmpvaW4oJyYmJykpICsgXCIpcmV0dXJuIG51bGw7XCIpXG59XG5cbmZ1bmN0aW9uIGdlbkZpbHRlckNvZGUgKGtleSkge1xuICB2YXIga2V5VmFsID0gcGFyc2VJbnQoa2V5LCAxMCk7XG4gIGlmIChrZXlWYWwpIHtcbiAgICByZXR1cm4gKFwiJGV2ZW50LmtleUNvZGUhPT1cIiArIGtleVZhbClcbiAgfVxuICB2YXIga2V5Q29kZSA9IGtleUNvZGVzW2tleV07XG4gIHZhciBrZXlOYW1lID0ga2V5TmFtZXNba2V5XTtcbiAgcmV0dXJuIChcbiAgICBcIl9rKCRldmVudC5rZXlDb2RlLFwiICtcbiAgICAoSlNPTi5zdHJpbmdpZnkoa2V5KSkgKyBcIixcIiArXG4gICAgKEpTT04uc3RyaW5naWZ5KGtleUNvZGUpKSArIFwiLFwiICtcbiAgICBcIiRldmVudC5rZXksXCIgK1xuICAgIFwiXCIgKyAoSlNPTi5zdHJpbmdpZnkoa2V5TmFtZSkpICtcbiAgICBcIilcIlxuICApXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBvbiAoZWwsIGRpcikge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBkaXIubW9kaWZpZXJzKSB7XG4gICAgd2FybihcInYtb24gd2l0aG91dCBhcmd1bWVudCBkb2VzIG5vdCBzdXBwb3J0IG1vZGlmaWVycy5cIik7XG4gIH1cbiAgZWwud3JhcExpc3RlbmVycyA9IGZ1bmN0aW9uIChjb2RlKSB7IHJldHVybiAoXCJfZyhcIiArIGNvZGUgKyBcIixcIiArIChkaXIudmFsdWUpICsgXCIpXCIpOyB9O1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gYmluZCQxIChlbCwgZGlyKSB7XG4gIGVsLndyYXBEYXRhID0gZnVuY3Rpb24gKGNvZGUpIHtcbiAgICByZXR1cm4gKFwiX2IoXCIgKyBjb2RlICsgXCIsJ1wiICsgKGVsLnRhZykgKyBcIicsXCIgKyAoZGlyLnZhbHVlKSArIFwiLFwiICsgKGRpci5tb2RpZmllcnMgJiYgZGlyLm1vZGlmaWVycy5wcm9wID8gJ3RydWUnIDogJ2ZhbHNlJykgKyAoZGlyLm1vZGlmaWVycyAmJiBkaXIubW9kaWZpZXJzLnN5bmMgPyAnLHRydWUnIDogJycpICsgXCIpXCIpXG4gIH07XG59XG5cbi8qICAqL1xuXG52YXIgYmFzZURpcmVjdGl2ZXMgPSB7XG4gIG9uOiBvbixcbiAgYmluZDogYmluZCQxLFxuICBjbG9hazogbm9vcFxufVxuXG4vKiAgKi9cblxudmFyIENvZGVnZW5TdGF0ZSA9IGZ1bmN0aW9uIENvZGVnZW5TdGF0ZSAob3B0aW9ucykge1xuICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICB0aGlzLndhcm4gPSBvcHRpb25zLndhcm4gfHwgYmFzZVdhcm47XG4gIHRoaXMudHJhbnNmb3JtcyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAndHJhbnNmb3JtQ29kZScpO1xuICB0aGlzLmRhdGFHZW5GbnMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ2dlbkRhdGEnKTtcbiAgdGhpcy5kaXJlY3RpdmVzID0gZXh0ZW5kKGV4dGVuZCh7fSwgYmFzZURpcmVjdGl2ZXMpLCBvcHRpb25zLmRpcmVjdGl2ZXMpO1xuICB2YXIgaXNSZXNlcnZlZFRhZyA9IG9wdGlvbnMuaXNSZXNlcnZlZFRhZyB8fCBubztcbiAgdGhpcy5tYXliZUNvbXBvbmVudCA9IGZ1bmN0aW9uIChlbCkgeyByZXR1cm4gIWlzUmVzZXJ2ZWRUYWcoZWwudGFnKTsgfTtcbiAgdGhpcy5vbmNlSWQgPSAwO1xuICB0aGlzLnN0YXRpY1JlbmRlckZucyA9IFtdO1xufTtcblxuXG5cbmZ1bmN0aW9uIGdlbmVyYXRlIChcbiAgYXN0LFxuICBvcHRpb25zXG4pIHtcbiAgdmFyIHN0YXRlID0gbmV3IENvZGVnZW5TdGF0ZShvcHRpb25zKTtcbiAgdmFyIGNvZGUgPSBhc3QgPyBnZW5FbGVtZW50KGFzdCwgc3RhdGUpIDogJ19jKFwiZGl2XCIpJztcbiAgcmV0dXJuIHtcbiAgICByZW5kZXI6IChcIndpdGgodGhpcyl7cmV0dXJuIFwiICsgY29kZSArIFwifVwiKSxcbiAgICBzdGF0aWNSZW5kZXJGbnM6IHN0YXRlLnN0YXRpY1JlbmRlckZuc1xuICB9XG59XG5cbmZ1bmN0aW9uIGdlbkVsZW1lbnQgKGVsLCBzdGF0ZSkge1xuICBpZiAoZWwuc3RhdGljUm9vdCAmJiAhZWwuc3RhdGljUHJvY2Vzc2VkKSB7XG4gICAgcmV0dXJuIGdlblN0YXRpYyhlbCwgc3RhdGUpXG4gIH0gZWxzZSBpZiAoZWwub25jZSAmJiAhZWwub25jZVByb2Nlc3NlZCkge1xuICAgIHJldHVybiBnZW5PbmNlKGVsLCBzdGF0ZSlcbiAgfSBlbHNlIGlmIChlbC5mb3IgJiYgIWVsLmZvclByb2Nlc3NlZCkge1xuICAgIHJldHVybiBnZW5Gb3IoZWwsIHN0YXRlKVxuICB9IGVsc2UgaWYgKGVsLmlmICYmICFlbC5pZlByb2Nlc3NlZCkge1xuICAgIHJldHVybiBnZW5JZihlbCwgc3RhdGUpXG4gIH0gZWxzZSBpZiAoZWwudGFnID09PSAndGVtcGxhdGUnICYmICFlbC5zbG90VGFyZ2V0KSB7XG4gICAgcmV0dXJuIGdlbkNoaWxkcmVuKGVsLCBzdGF0ZSkgfHwgJ3ZvaWQgMCdcbiAgfSBlbHNlIGlmIChlbC50YWcgPT09ICdzbG90Jykge1xuICAgIHJldHVybiBnZW5TbG90KGVsLCBzdGF0ZSlcbiAgfSBlbHNlIHtcbiAgICAvLyBjb21wb25lbnQgb3IgZWxlbWVudFxuICAgIHZhciBjb2RlO1xuICAgIGlmIChlbC5jb21wb25lbnQpIHtcbiAgICAgIGNvZGUgPSBnZW5Db21wb25lbnQoZWwuY29tcG9uZW50LCBlbCwgc3RhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZGF0YSA9IGVsLnBsYWluID8gdW5kZWZpbmVkIDogZ2VuRGF0YSQyKGVsLCBzdGF0ZSk7XG5cbiAgICAgIHZhciBjaGlsZHJlbiA9IGVsLmlubGluZVRlbXBsYXRlID8gbnVsbCA6IGdlbkNoaWxkcmVuKGVsLCBzdGF0ZSwgdHJ1ZSk7XG4gICAgICBjb2RlID0gXCJfYygnXCIgKyAoZWwudGFnKSArIFwiJ1wiICsgKGRhdGEgPyAoXCIsXCIgKyBkYXRhKSA6ICcnKSArIChjaGlsZHJlbiA/IChcIixcIiArIGNoaWxkcmVuKSA6ICcnKSArIFwiKVwiO1xuICAgIH1cbiAgICAvLyBtb2R1bGUgdHJhbnNmb3Jtc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhdGUudHJhbnNmb3Jtcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29kZSA9IHN0YXRlLnRyYW5zZm9ybXNbaV0oZWwsIGNvZGUpO1xuICAgIH1cbiAgICByZXR1cm4gY29kZVxuICB9XG59XG5cbi8vIGhvaXN0IHN0YXRpYyBzdWItdHJlZXMgb3V0XG5mdW5jdGlvbiBnZW5TdGF0aWMgKGVsLCBzdGF0ZSkge1xuICBlbC5zdGF0aWNQcm9jZXNzZWQgPSB0cnVlO1xuICBzdGF0ZS5zdGF0aWNSZW5kZXJGbnMucHVzaCgoXCJ3aXRoKHRoaXMpe3JldHVybiBcIiArIChnZW5FbGVtZW50KGVsLCBzdGF0ZSkpICsgXCJ9XCIpKTtcbiAgcmV0dXJuIChcIl9tKFwiICsgKHN0YXRlLnN0YXRpY1JlbmRlckZucy5sZW5ndGggLSAxKSArIChlbC5zdGF0aWNJbkZvciA/ICcsdHJ1ZScgOiAnJykgKyBcIilcIilcbn1cblxuLy8gdi1vbmNlXG5mdW5jdGlvbiBnZW5PbmNlIChlbCwgc3RhdGUpIHtcbiAgZWwub25jZVByb2Nlc3NlZCA9IHRydWU7XG4gIGlmIChlbC5pZiAmJiAhZWwuaWZQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuSWYoZWwsIHN0YXRlKVxuICB9IGVsc2UgaWYgKGVsLnN0YXRpY0luRm9yKSB7XG4gICAgdmFyIGtleSA9ICcnO1xuICAgIHZhciBwYXJlbnQgPSBlbC5wYXJlbnQ7XG4gICAgd2hpbGUgKHBhcmVudCkge1xuICAgICAgaWYgKHBhcmVudC5mb3IpIHtcbiAgICAgICAga2V5ID0gcGFyZW50LmtleTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gICAgfVxuICAgIGlmICgha2V5KSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHN0YXRlLndhcm4oXG4gICAgICAgIFwidi1vbmNlIGNhbiBvbmx5IGJlIHVzZWQgaW5zaWRlIHYtZm9yIHRoYXQgaXMga2V5ZWQuIFwiXG4gICAgICApO1xuICAgICAgcmV0dXJuIGdlbkVsZW1lbnQoZWwsIHN0YXRlKVxuICAgIH1cbiAgICByZXR1cm4gKFwiX28oXCIgKyAoZ2VuRWxlbWVudChlbCwgc3RhdGUpKSArIFwiLFwiICsgKHN0YXRlLm9uY2VJZCsrKSArIFwiLFwiICsga2V5ICsgXCIpXCIpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGdlblN0YXRpYyhlbCwgc3RhdGUpXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuSWYgKFxuICBlbCxcbiAgc3RhdGUsXG4gIGFsdEdlbixcbiAgYWx0RW1wdHlcbikge1xuICBlbC5pZlByb2Nlc3NlZCA9IHRydWU7IC8vIGF2b2lkIHJlY3Vyc2lvblxuICByZXR1cm4gZ2VuSWZDb25kaXRpb25zKGVsLmlmQ29uZGl0aW9ucy5zbGljZSgpLCBzdGF0ZSwgYWx0R2VuLCBhbHRFbXB0eSlcbn1cblxuZnVuY3Rpb24gZ2VuSWZDb25kaXRpb25zIChcbiAgY29uZGl0aW9ucyxcbiAgc3RhdGUsXG4gIGFsdEdlbixcbiAgYWx0RW1wdHlcbikge1xuICBpZiAoIWNvbmRpdGlvbnMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGFsdEVtcHR5IHx8ICdfZSgpJ1xuICB9XG5cbiAgdmFyIGNvbmRpdGlvbiA9IGNvbmRpdGlvbnMuc2hpZnQoKTtcbiAgaWYgKGNvbmRpdGlvbi5leHApIHtcbiAgICByZXR1cm4gKFwiKFwiICsgKGNvbmRpdGlvbi5leHApICsgXCIpP1wiICsgKGdlblRlcm5hcnlFeHAoY29uZGl0aW9uLmJsb2NrKSkgKyBcIjpcIiArIChnZW5JZkNvbmRpdGlvbnMoY29uZGl0aW9ucywgc3RhdGUsIGFsdEdlbiwgYWx0RW1wdHkpKSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKFwiXCIgKyAoZ2VuVGVybmFyeUV4cChjb25kaXRpb24uYmxvY2spKSlcbiAgfVxuXG4gIC8vIHYtaWYgd2l0aCB2LW9uY2Ugc2hvdWxkIGdlbmVyYXRlIGNvZGUgbGlrZSAoYSk/X20oMCk6X20oMSlcbiAgZnVuY3Rpb24gZ2VuVGVybmFyeUV4cCAoZWwpIHtcbiAgICByZXR1cm4gYWx0R2VuXG4gICAgICA/IGFsdEdlbihlbCwgc3RhdGUpXG4gICAgICA6IGVsLm9uY2VcbiAgICAgICAgPyBnZW5PbmNlKGVsLCBzdGF0ZSlcbiAgICAgICAgOiBnZW5FbGVtZW50KGVsLCBzdGF0ZSlcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5Gb3IgKFxuICBlbCxcbiAgc3RhdGUsXG4gIGFsdEdlbixcbiAgYWx0SGVscGVyXG4pIHtcbiAgdmFyIGV4cCA9IGVsLmZvcjtcbiAgdmFyIGFsaWFzID0gZWwuYWxpYXM7XG4gIHZhciBpdGVyYXRvcjEgPSBlbC5pdGVyYXRvcjEgPyAoXCIsXCIgKyAoZWwuaXRlcmF0b3IxKSkgOiAnJztcbiAgdmFyIGl0ZXJhdG9yMiA9IGVsLml0ZXJhdG9yMiA/IChcIixcIiArIChlbC5pdGVyYXRvcjIpKSA6ICcnO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgc3RhdGUubWF5YmVDb21wb25lbnQoZWwpICYmXG4gICAgZWwudGFnICE9PSAnc2xvdCcgJiZcbiAgICBlbC50YWcgIT09ICd0ZW1wbGF0ZScgJiZcbiAgICAhZWwua2V5XG4gICkge1xuICAgIHN0YXRlLndhcm4oXG4gICAgICBcIjxcIiArIChlbC50YWcpICsgXCIgdi1mb3I9XFxcIlwiICsgYWxpYXMgKyBcIiBpbiBcIiArIGV4cCArIFwiXFxcIj46IGNvbXBvbmVudCBsaXN0cyByZW5kZXJlZCB3aXRoIFwiICtcbiAgICAgIFwidi1mb3Igc2hvdWxkIGhhdmUgZXhwbGljaXQga2V5cy4gXCIgK1xuICAgICAgXCJTZWUgaHR0cHM6Ly92dWVqcy5vcmcvZ3VpZGUvbGlzdC5odG1sI2tleSBmb3IgbW9yZSBpbmZvLlwiLFxuICAgICAgdHJ1ZSAvKiB0aXAgKi9cbiAgICApO1xuICB9XG5cbiAgZWwuZm9yUHJvY2Vzc2VkID0gdHJ1ZTsgLy8gYXZvaWQgcmVjdXJzaW9uXG4gIHJldHVybiAoYWx0SGVscGVyIHx8ICdfbCcpICsgXCIoKFwiICsgZXhwICsgXCIpLFwiICtcbiAgICBcImZ1bmN0aW9uKFwiICsgYWxpYXMgKyBpdGVyYXRvcjEgKyBpdGVyYXRvcjIgKyBcIil7XCIgK1xuICAgICAgXCJyZXR1cm4gXCIgKyAoKGFsdEdlbiB8fCBnZW5FbGVtZW50KShlbCwgc3RhdGUpKSArXG4gICAgJ30pJ1xufVxuXG5mdW5jdGlvbiBnZW5EYXRhJDIgKGVsLCBzdGF0ZSkge1xuICB2YXIgZGF0YSA9ICd7JztcblxuICAvLyBkaXJlY3RpdmVzIGZpcnN0LlxuICAvLyBkaXJlY3RpdmVzIG1heSBtdXRhdGUgdGhlIGVsJ3Mgb3RoZXIgcHJvcGVydGllcyBiZWZvcmUgdGhleSBhcmUgZ2VuZXJhdGVkLlxuICB2YXIgZGlycyA9IGdlbkRpcmVjdGl2ZXMoZWwsIHN0YXRlKTtcbiAgaWYgKGRpcnMpIHsgZGF0YSArPSBkaXJzICsgJywnOyB9XG5cbiAgLy8ga2V5XG4gIGlmIChlbC5rZXkpIHtcbiAgICBkYXRhICs9IFwia2V5OlwiICsgKGVsLmtleSkgKyBcIixcIjtcbiAgfVxuICAvLyByZWZcbiAgaWYgKGVsLnJlZikge1xuICAgIGRhdGEgKz0gXCJyZWY6XCIgKyAoZWwucmVmKSArIFwiLFwiO1xuICB9XG4gIGlmIChlbC5yZWZJbkZvcikge1xuICAgIGRhdGEgKz0gXCJyZWZJbkZvcjp0cnVlLFwiO1xuICB9XG4gIC8vIHByZVxuICBpZiAoZWwucHJlKSB7XG4gICAgZGF0YSArPSBcInByZTp0cnVlLFwiO1xuICB9XG4gIC8vIHJlY29yZCBvcmlnaW5hbCB0YWcgbmFtZSBmb3IgY29tcG9uZW50cyB1c2luZyBcImlzXCIgYXR0cmlidXRlXG4gIGlmIChlbC5jb21wb25lbnQpIHtcbiAgICBkYXRhICs9IFwidGFnOlxcXCJcIiArIChlbC50YWcpICsgXCJcXFwiLFwiO1xuICB9XG4gIC8vIG1vZHVsZSBkYXRhIGdlbmVyYXRpb24gZnVuY3Rpb25zXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhdGUuZGF0YUdlbkZucy5sZW5ndGg7IGkrKykge1xuICAgIGRhdGEgKz0gc3RhdGUuZGF0YUdlbkZuc1tpXShlbCk7XG4gIH1cbiAgLy8gYXR0cmlidXRlc1xuICBpZiAoZWwuYXR0cnMpIHtcbiAgICBkYXRhICs9IFwiYXR0cnM6e1wiICsgKGdlblByb3BzKGVsLmF0dHJzKSkgKyBcIn0sXCI7XG4gIH1cbiAgLy8gRE9NIHByb3BzXG4gIGlmIChlbC5wcm9wcykge1xuICAgIGRhdGEgKz0gXCJkb21Qcm9wczp7XCIgKyAoZ2VuUHJvcHMoZWwucHJvcHMpKSArIFwifSxcIjtcbiAgfVxuICAvLyBldmVudCBoYW5kbGVyc1xuICBpZiAoZWwuZXZlbnRzKSB7XG4gICAgZGF0YSArPSAoZ2VuSGFuZGxlcnMoZWwuZXZlbnRzLCBmYWxzZSwgc3RhdGUud2FybikpICsgXCIsXCI7XG4gIH1cbiAgaWYgKGVsLm5hdGl2ZUV2ZW50cykge1xuICAgIGRhdGEgKz0gKGdlbkhhbmRsZXJzKGVsLm5hdGl2ZUV2ZW50cywgdHJ1ZSwgc3RhdGUud2FybikpICsgXCIsXCI7XG4gIH1cbiAgLy8gc2xvdCB0YXJnZXRcbiAgLy8gb25seSBmb3Igbm9uLXNjb3BlZCBzbG90c1xuICBpZiAoZWwuc2xvdFRhcmdldCAmJiAhZWwuc2xvdFNjb3BlKSB7XG4gICAgZGF0YSArPSBcInNsb3Q6XCIgKyAoZWwuc2xvdFRhcmdldCkgKyBcIixcIjtcbiAgfVxuICAvLyBzY29wZWQgc2xvdHNcbiAgaWYgKGVsLnNjb3BlZFNsb3RzKSB7XG4gICAgZGF0YSArPSAoZ2VuU2NvcGVkU2xvdHMoZWwuc2NvcGVkU2xvdHMsIHN0YXRlKSkgKyBcIixcIjtcbiAgfVxuICAvLyBjb21wb25lbnQgdi1tb2RlbFxuICBpZiAoZWwubW9kZWwpIHtcbiAgICBkYXRhICs9IFwibW9kZWw6e3ZhbHVlOlwiICsgKGVsLm1vZGVsLnZhbHVlKSArIFwiLGNhbGxiYWNrOlwiICsgKGVsLm1vZGVsLmNhbGxiYWNrKSArIFwiLGV4cHJlc3Npb246XCIgKyAoZWwubW9kZWwuZXhwcmVzc2lvbikgKyBcIn0sXCI7XG4gIH1cbiAgLy8gaW5saW5lLXRlbXBsYXRlXG4gIGlmIChlbC5pbmxpbmVUZW1wbGF0ZSkge1xuICAgIHZhciBpbmxpbmVUZW1wbGF0ZSA9IGdlbklubGluZVRlbXBsYXRlKGVsLCBzdGF0ZSk7XG4gICAgaWYgKGlubGluZVRlbXBsYXRlKSB7XG4gICAgICBkYXRhICs9IGlubGluZVRlbXBsYXRlICsgXCIsXCI7XG4gICAgfVxuICB9XG4gIGRhdGEgPSBkYXRhLnJlcGxhY2UoLywkLywgJycpICsgJ30nO1xuICAvLyB2LWJpbmQgZGF0YSB3cmFwXG4gIGlmIChlbC53cmFwRGF0YSkge1xuICAgIGRhdGEgPSBlbC53cmFwRGF0YShkYXRhKTtcbiAgfVxuICAvLyB2LW9uIGRhdGEgd3JhcFxuICBpZiAoZWwud3JhcExpc3RlbmVycykge1xuICAgIGRhdGEgPSBlbC53cmFwTGlzdGVuZXJzKGRhdGEpO1xuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbmZ1bmN0aW9uIGdlbkRpcmVjdGl2ZXMgKGVsLCBzdGF0ZSkge1xuICB2YXIgZGlycyA9IGVsLmRpcmVjdGl2ZXM7XG4gIGlmICghZGlycykgeyByZXR1cm4gfVxuICB2YXIgcmVzID0gJ2RpcmVjdGl2ZXM6Wyc7XG4gIHZhciBoYXNSdW50aW1lID0gZmFsc2U7XG4gIHZhciBpLCBsLCBkaXIsIG5lZWRSdW50aW1lO1xuICBmb3IgKGkgPSAwLCBsID0gZGlycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBkaXIgPSBkaXJzW2ldO1xuICAgIG5lZWRSdW50aW1lID0gdHJ1ZTtcbiAgICB2YXIgZ2VuID0gc3RhdGUuZGlyZWN0aXZlc1tkaXIubmFtZV07XG4gICAgaWYgKGdlbikge1xuICAgICAgLy8gY29tcGlsZS10aW1lIGRpcmVjdGl2ZSB0aGF0IG1hbmlwdWxhdGVzIEFTVC5cbiAgICAgIC8vIHJldHVybnMgdHJ1ZSBpZiBpdCBhbHNvIG5lZWRzIGEgcnVudGltZSBjb3VudGVycGFydC5cbiAgICAgIG5lZWRSdW50aW1lID0gISFnZW4oZWwsIGRpciwgc3RhdGUud2Fybik7XG4gICAgfVxuICAgIGlmIChuZWVkUnVudGltZSkge1xuICAgICAgaGFzUnVudGltZSA9IHRydWU7XG4gICAgICByZXMgKz0gXCJ7bmFtZTpcXFwiXCIgKyAoZGlyLm5hbWUpICsgXCJcXFwiLHJhd05hbWU6XFxcIlwiICsgKGRpci5yYXdOYW1lKSArIFwiXFxcIlwiICsgKGRpci52YWx1ZSA/IChcIix2YWx1ZTooXCIgKyAoZGlyLnZhbHVlKSArIFwiKSxleHByZXNzaW9uOlwiICsgKEpTT04uc3RyaW5naWZ5KGRpci52YWx1ZSkpKSA6ICcnKSArIChkaXIuYXJnID8gKFwiLGFyZzpcXFwiXCIgKyAoZGlyLmFyZykgKyBcIlxcXCJcIikgOiAnJykgKyAoZGlyLm1vZGlmaWVycyA/IChcIixtb2RpZmllcnM6XCIgKyAoSlNPTi5zdHJpbmdpZnkoZGlyLm1vZGlmaWVycykpKSA6ICcnKSArIFwifSxcIjtcbiAgICB9XG4gIH1cbiAgaWYgKGhhc1J1bnRpbWUpIHtcbiAgICByZXR1cm4gcmVzLnNsaWNlKDAsIC0xKSArICddJ1xuICB9XG59XG5cbmZ1bmN0aW9uIGdlbklubGluZVRlbXBsYXRlIChlbCwgc3RhdGUpIHtcbiAgdmFyIGFzdCA9IGVsLmNoaWxkcmVuWzBdO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAoXG4gICAgZWwuY2hpbGRyZW4ubGVuZ3RoICE9PSAxIHx8IGFzdC50eXBlICE9PSAxXG4gICkpIHtcbiAgICBzdGF0ZS53YXJuKCdJbmxpbmUtdGVtcGxhdGUgY29tcG9uZW50cyBtdXN0IGhhdmUgZXhhY3RseSBvbmUgY2hpbGQgZWxlbWVudC4nKTtcbiAgfVxuICBpZiAoYXN0LnR5cGUgPT09IDEpIHtcbiAgICB2YXIgaW5saW5lUmVuZGVyRm5zID0gZ2VuZXJhdGUoYXN0LCBzdGF0ZS5vcHRpb25zKTtcbiAgICByZXR1cm4gKFwiaW5saW5lVGVtcGxhdGU6e3JlbmRlcjpmdW5jdGlvbigpe1wiICsgKGlubGluZVJlbmRlckZucy5yZW5kZXIpICsgXCJ9LHN0YXRpY1JlbmRlckZuczpbXCIgKyAoaW5saW5lUmVuZGVyRm5zLnN0YXRpY1JlbmRlckZucy5tYXAoZnVuY3Rpb24gKGNvZGUpIHsgcmV0dXJuIChcImZ1bmN0aW9uKCl7XCIgKyBjb2RlICsgXCJ9XCIpOyB9KS5qb2luKCcsJykpICsgXCJdfVwiKVxuICB9XG59XG5cbmZ1bmN0aW9uIGdlblNjb3BlZFNsb3RzIChcbiAgc2xvdHMsXG4gIHN0YXRlXG4pIHtcbiAgcmV0dXJuIChcInNjb3BlZFNsb3RzOl91KFtcIiArIChPYmplY3Qua2V5cyhzbG90cykubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHJldHVybiBnZW5TY29wZWRTbG90KGtleSwgc2xvdHNba2V5XSwgc3RhdGUpXG4gICAgfSkuam9pbignLCcpKSArIFwiXSlcIilcbn1cblxuZnVuY3Rpb24gZ2VuU2NvcGVkU2xvdCAoXG4gIGtleSxcbiAgZWwsXG4gIHN0YXRlXG4pIHtcbiAgaWYgKGVsLmZvciAmJiAhZWwuZm9yUHJvY2Vzc2VkKSB7XG4gICAgcmV0dXJuIGdlbkZvclNjb3BlZFNsb3Qoa2V5LCBlbCwgc3RhdGUpXG4gIH1cbiAgdmFyIGZuID0gXCJmdW5jdGlvbihcIiArIChTdHJpbmcoZWwuc2xvdFNjb3BlKSkgKyBcIil7XCIgK1xuICAgIFwicmV0dXJuIFwiICsgKGVsLnRhZyA9PT0gJ3RlbXBsYXRlJ1xuICAgICAgPyBlbC5pZlxuICAgICAgICA/ICgoZWwuaWYpICsgXCI/XCIgKyAoZ2VuQ2hpbGRyZW4oZWwsIHN0YXRlKSB8fCAndW5kZWZpbmVkJykgKyBcIjp1bmRlZmluZWRcIilcbiAgICAgICAgOiBnZW5DaGlsZHJlbihlbCwgc3RhdGUpIHx8ICd1bmRlZmluZWQnXG4gICAgICA6IGdlbkVsZW1lbnQoZWwsIHN0YXRlKSkgKyBcIn1cIjtcbiAgcmV0dXJuIChcIntrZXk6XCIgKyBrZXkgKyBcIixmbjpcIiArIGZuICsgXCJ9XCIpXG59XG5cbmZ1bmN0aW9uIGdlbkZvclNjb3BlZFNsb3QgKFxuICBrZXksXG4gIGVsLFxuICBzdGF0ZVxuKSB7XG4gIHZhciBleHAgPSBlbC5mb3I7XG4gIHZhciBhbGlhcyA9IGVsLmFsaWFzO1xuICB2YXIgaXRlcmF0b3IxID0gZWwuaXRlcmF0b3IxID8gKFwiLFwiICsgKGVsLml0ZXJhdG9yMSkpIDogJyc7XG4gIHZhciBpdGVyYXRvcjIgPSBlbC5pdGVyYXRvcjIgPyAoXCIsXCIgKyAoZWwuaXRlcmF0b3IyKSkgOiAnJztcbiAgZWwuZm9yUHJvY2Vzc2VkID0gdHJ1ZTsgLy8gYXZvaWQgcmVjdXJzaW9uXG4gIHJldHVybiBcIl9sKChcIiArIGV4cCArIFwiKSxcIiArXG4gICAgXCJmdW5jdGlvbihcIiArIGFsaWFzICsgaXRlcmF0b3IxICsgaXRlcmF0b3IyICsgXCIpe1wiICtcbiAgICAgIFwicmV0dXJuIFwiICsgKGdlblNjb3BlZFNsb3Qoa2V5LCBlbCwgc3RhdGUpKSArXG4gICAgJ30pJ1xufVxuXG5mdW5jdGlvbiBnZW5DaGlsZHJlbiAoXG4gIGVsLFxuICBzdGF0ZSxcbiAgY2hlY2tTa2lwLFxuICBhbHRHZW5FbGVtZW50LFxuICBhbHRHZW5Ob2RlXG4pIHtcbiAgdmFyIGNoaWxkcmVuID0gZWwuY2hpbGRyZW47XG4gIGlmIChjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICB2YXIgZWwkMSA9IGNoaWxkcmVuWzBdO1xuICAgIC8vIG9wdGltaXplIHNpbmdsZSB2LWZvclxuICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPT09IDEgJiZcbiAgICAgIGVsJDEuZm9yICYmXG4gICAgICBlbCQxLnRhZyAhPT0gJ3RlbXBsYXRlJyAmJlxuICAgICAgZWwkMS50YWcgIT09ICdzbG90J1xuICAgICkge1xuICAgICAgcmV0dXJuIChhbHRHZW5FbGVtZW50IHx8IGdlbkVsZW1lbnQpKGVsJDEsIHN0YXRlKVxuICAgIH1cbiAgICB2YXIgbm9ybWFsaXphdGlvblR5cGUgPSBjaGVja1NraXBcbiAgICAgID8gZ2V0Tm9ybWFsaXphdGlvblR5cGUoY2hpbGRyZW4sIHN0YXRlLm1heWJlQ29tcG9uZW50KVxuICAgICAgOiAwO1xuICAgIHZhciBnZW4gPSBhbHRHZW5Ob2RlIHx8IGdlbk5vZGU7XG4gICAgcmV0dXJuIChcIltcIiArIChjaGlsZHJlbi5tYXAoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGdlbihjLCBzdGF0ZSk7IH0pLmpvaW4oJywnKSkgKyBcIl1cIiArIChub3JtYWxpemF0aW9uVHlwZSA/IChcIixcIiArIG5vcm1hbGl6YXRpb25UeXBlKSA6ICcnKSlcbiAgfVxufVxuXG4vLyBkZXRlcm1pbmUgdGhlIG5vcm1hbGl6YXRpb24gbmVlZGVkIGZvciB0aGUgY2hpbGRyZW4gYXJyYXkuXG4vLyAwOiBubyBub3JtYWxpemF0aW9uIG5lZWRlZFxuLy8gMTogc2ltcGxlIG5vcm1hbGl6YXRpb24gbmVlZGVkIChwb3NzaWJsZSAxLWxldmVsIGRlZXAgbmVzdGVkIGFycmF5KVxuLy8gMjogZnVsbCBub3JtYWxpemF0aW9uIG5lZWRlZFxuZnVuY3Rpb24gZ2V0Tm9ybWFsaXphdGlvblR5cGUgKFxuICBjaGlsZHJlbixcbiAgbWF5YmVDb21wb25lbnRcbikge1xuICB2YXIgcmVzID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIHZhciBlbCA9IGNoaWxkcmVuW2ldO1xuICAgIGlmIChlbC50eXBlICE9PSAxKSB7XG4gICAgICBjb250aW51ZVxuICAgIH1cbiAgICBpZiAobmVlZHNOb3JtYWxpemF0aW9uKGVsKSB8fFxuICAgICAgICAoZWwuaWZDb25kaXRpb25zICYmIGVsLmlmQ29uZGl0aW9ucy5zb21lKGZ1bmN0aW9uIChjKSB7IHJldHVybiBuZWVkc05vcm1hbGl6YXRpb24oYy5ibG9jayk7IH0pKSkge1xuICAgICAgcmVzID0gMjtcbiAgICAgIGJyZWFrXG4gICAgfVxuICAgIGlmIChtYXliZUNvbXBvbmVudChlbCkgfHxcbiAgICAgICAgKGVsLmlmQ29uZGl0aW9ucyAmJiBlbC5pZkNvbmRpdGlvbnMuc29tZShmdW5jdGlvbiAoYykgeyByZXR1cm4gbWF5YmVDb21wb25lbnQoYy5ibG9jayk7IH0pKSkge1xuICAgICAgcmVzID0gMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBuZWVkc05vcm1hbGl6YXRpb24gKGVsKSB7XG4gIHJldHVybiBlbC5mb3IgIT09IHVuZGVmaW5lZCB8fCBlbC50YWcgPT09ICd0ZW1wbGF0ZScgfHwgZWwudGFnID09PSAnc2xvdCdcbn1cblxuZnVuY3Rpb24gZ2VuTm9kZSAobm9kZSwgc3RhdGUpIHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gMSkge1xuICAgIHJldHVybiBnZW5FbGVtZW50KG5vZGUsIHN0YXRlKVxuICB9IGlmIChub2RlLnR5cGUgPT09IDMgJiYgbm9kZS5pc0NvbW1lbnQpIHtcbiAgICByZXR1cm4gZ2VuQ29tbWVudChub2RlKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBnZW5UZXh0KG5vZGUpXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuVGV4dCAodGV4dCkge1xuICByZXR1cm4gKFwiX3YoXCIgKyAodGV4dC50eXBlID09PSAyXG4gICAgPyB0ZXh0LmV4cHJlc3Npb24gLy8gbm8gbmVlZCBmb3IgKCkgYmVjYXVzZSBhbHJlYWR5IHdyYXBwZWQgaW4gX3MoKVxuICAgIDogdHJhbnNmb3JtU3BlY2lhbE5ld2xpbmVzKEpTT04uc3RyaW5naWZ5KHRleHQudGV4dCkpKSArIFwiKVwiKVxufVxuXG5mdW5jdGlvbiBnZW5Db21tZW50IChjb21tZW50KSB7XG4gIHJldHVybiAoXCJfZShcIiArIChKU09OLnN0cmluZ2lmeShjb21tZW50LnRleHQpKSArIFwiKVwiKVxufVxuXG5mdW5jdGlvbiBnZW5TbG90IChlbCwgc3RhdGUpIHtcbiAgdmFyIHNsb3ROYW1lID0gZWwuc2xvdE5hbWUgfHwgJ1wiZGVmYXVsdFwiJztcbiAgdmFyIGNoaWxkcmVuID0gZ2VuQ2hpbGRyZW4oZWwsIHN0YXRlKTtcbiAgdmFyIHJlcyA9IFwiX3QoXCIgKyBzbG90TmFtZSArIChjaGlsZHJlbiA/IChcIixcIiArIGNoaWxkcmVuKSA6ICcnKTtcbiAgdmFyIGF0dHJzID0gZWwuYXR0cnMgJiYgKFwie1wiICsgKGVsLmF0dHJzLm1hcChmdW5jdGlvbiAoYSkgeyByZXR1cm4gKChjYW1lbGl6ZShhLm5hbWUpKSArIFwiOlwiICsgKGEudmFsdWUpKTsgfSkuam9pbignLCcpKSArIFwifVwiKTtcbiAgdmFyIGJpbmQkJDEgPSBlbC5hdHRyc01hcFsndi1iaW5kJ107XG4gIGlmICgoYXR0cnMgfHwgYmluZCQkMSkgJiYgIWNoaWxkcmVuKSB7XG4gICAgcmVzICs9IFwiLG51bGxcIjtcbiAgfVxuICBpZiAoYXR0cnMpIHtcbiAgICByZXMgKz0gXCIsXCIgKyBhdHRycztcbiAgfVxuICBpZiAoYmluZCQkMSkge1xuICAgIHJlcyArPSAoYXR0cnMgPyAnJyA6ICcsbnVsbCcpICsgXCIsXCIgKyBiaW5kJCQxO1xuICB9XG4gIHJldHVybiByZXMgKyAnKSdcbn1cblxuLy8gY29tcG9uZW50TmFtZSBpcyBlbC5jb21wb25lbnQsIHRha2UgaXQgYXMgYXJndW1lbnQgdG8gc2h1biBmbG93J3MgcGVzc2ltaXN0aWMgcmVmaW5lbWVudFxuZnVuY3Rpb24gZ2VuQ29tcG9uZW50IChcbiAgY29tcG9uZW50TmFtZSxcbiAgZWwsXG4gIHN0YXRlXG4pIHtcbiAgdmFyIGNoaWxkcmVuID0gZWwuaW5saW5lVGVtcGxhdGUgPyBudWxsIDogZ2VuQ2hpbGRyZW4oZWwsIHN0YXRlLCB0cnVlKTtcbiAgcmV0dXJuIChcIl9jKFwiICsgY29tcG9uZW50TmFtZSArIFwiLFwiICsgKGdlbkRhdGEkMihlbCwgc3RhdGUpKSArIChjaGlsZHJlbiA/IChcIixcIiArIGNoaWxkcmVuKSA6ICcnKSArIFwiKVwiKVxufVxuXG5mdW5jdGlvbiBnZW5Qcm9wcyAocHJvcHMpIHtcbiAgdmFyIHJlcyA9ICcnO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHByb3AgPSBwcm9wc1tpXTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICB7XG4gICAgICByZXMgKz0gXCJcXFwiXCIgKyAocHJvcC5uYW1lKSArIFwiXFxcIjpcIiArICh0cmFuc2Zvcm1TcGVjaWFsTmV3bGluZXMocHJvcC52YWx1ZSkpICsgXCIsXCI7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXMuc2xpY2UoMCwgLTEpXG59XG5cbi8vICMzODk1LCAjNDI2OFxuZnVuY3Rpb24gdHJhbnNmb3JtU3BlY2lhbE5ld2xpbmVzICh0ZXh0KSB7XG4gIHJldHVybiB0ZXh0XG4gICAgLnJlcGxhY2UoL1xcdTIwMjgvZywgJ1xcXFx1MjAyOCcpXG4gICAgLnJlcGxhY2UoL1xcdTIwMjkvZywgJ1xcXFx1MjAyOScpXG59XG5cbi8qICAqL1xuXG4vLyB0aGVzZSBrZXl3b3JkcyBzaG91bGQgbm90IGFwcGVhciBpbnNpZGUgZXhwcmVzc2lvbnMsIGJ1dCBvcGVyYXRvcnMgbGlrZVxuLy8gdHlwZW9mLCBpbnN0YW5jZW9mIGFuZCBpbiBhcmUgYWxsb3dlZFxudmFyIHByb2hpYml0ZWRLZXl3b3JkUkUgPSBuZXcgUmVnRXhwKCdcXFxcYicgKyAoXG4gICdkbyxpZixmb3IsbGV0LG5ldyx0cnksdmFyLGNhc2UsZWxzZSx3aXRoLGF3YWl0LGJyZWFrLGNhdGNoLGNsYXNzLGNvbnN0LCcgK1xuICAnc3VwZXIsdGhyb3csd2hpbGUseWllbGQsZGVsZXRlLGV4cG9ydCxpbXBvcnQscmV0dXJuLHN3aXRjaCxkZWZhdWx0LCcgK1xuICAnZXh0ZW5kcyxmaW5hbGx5LGNvbnRpbnVlLGRlYnVnZ2VyLGZ1bmN0aW9uLGFyZ3VtZW50cydcbikuc3BsaXQoJywnKS5qb2luKCdcXFxcYnxcXFxcYicpICsgJ1xcXFxiJyk7XG5cbi8vIHRoZXNlIHVuYXJ5IG9wZXJhdG9ycyBzaG91bGQgbm90IGJlIHVzZWQgYXMgcHJvcGVydHkvbWV0aG9kIG5hbWVzXG52YXIgdW5hcnlPcGVyYXRvcnNSRSA9IG5ldyBSZWdFeHAoJ1xcXFxiJyArIChcbiAgJ2RlbGV0ZSx0eXBlb2Ysdm9pZCdcbikuc3BsaXQoJywnKS5qb2luKCdcXFxccypcXFxcKFteXFxcXCldKlxcXFwpfFxcXFxiJykgKyAnXFxcXHMqXFxcXChbXlxcXFwpXSpcXFxcKScpO1xuXG4vLyBzdHJpcCBzdHJpbmdzIGluIGV4cHJlc3Npb25zXG52YXIgc3RyaXBTdHJpbmdSRSA9IC8nKD86W14nXFxcXF18XFxcXC4pKid8XCIoPzpbXlwiXFxcXF18XFxcXC4pKlwifGAoPzpbXmBcXFxcXXxcXFxcLikqXFwkXFx7fFxcfSg/OlteYFxcXFxdfFxcXFwuKSpgfGAoPzpbXmBcXFxcXXxcXFxcLikqYC9nO1xuXG4vLyBkZXRlY3QgcHJvYmxlbWF0aWMgZXhwcmVzc2lvbnMgaW4gYSB0ZW1wbGF0ZVxuZnVuY3Rpb24gZGV0ZWN0RXJyb3JzIChhc3QpIHtcbiAgdmFyIGVycm9ycyA9IFtdO1xuICBpZiAoYXN0KSB7XG4gICAgY2hlY2tOb2RlKGFzdCwgZXJyb3JzKTtcbiAgfVxuICByZXR1cm4gZXJyb3JzXG59XG5cbmZ1bmN0aW9uIGNoZWNrTm9kZSAobm9kZSwgZXJyb3JzKSB7XG4gIGlmIChub2RlLnR5cGUgPT09IDEpIHtcbiAgICBmb3IgKHZhciBuYW1lIGluIG5vZGUuYXR0cnNNYXApIHtcbiAgICAgIGlmIChkaXJSRS50ZXN0KG5hbWUpKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IG5vZGUuYXR0cnNNYXBbbmFtZV07XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgIGlmIChuYW1lID09PSAndi1mb3InKSB7XG4gICAgICAgICAgICBjaGVja0Zvcihub2RlLCAoXCJ2LWZvcj1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIlwiKSwgZXJyb3JzKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG9uUkUudGVzdChuYW1lKSkge1xuICAgICAgICAgICAgY2hlY2tFdmVudCh2YWx1ZSwgKG5hbWUgKyBcIj1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIlwiKSwgZXJyb3JzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2hlY2tFeHByZXNzaW9uKHZhbHVlLCAobmFtZSArIFwiPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiXCIpLCBlcnJvcnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAobm9kZS5jaGlsZHJlbikge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNoZWNrTm9kZShub2RlLmNoaWxkcmVuW2ldLCBlcnJvcnMpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT09IDIpIHtcbiAgICBjaGVja0V4cHJlc3Npb24obm9kZS5leHByZXNzaW9uLCBub2RlLnRleHQsIGVycm9ycyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tFdmVudCAoZXhwLCB0ZXh0LCBlcnJvcnMpIHtcbiAgdmFyIHN0aXBwZWQgPSBleHAucmVwbGFjZShzdHJpcFN0cmluZ1JFLCAnJyk7XG4gIHZhciBrZXl3b3JkTWF0Y2ggPSBzdGlwcGVkLm1hdGNoKHVuYXJ5T3BlcmF0b3JzUkUpO1xuICBpZiAoa2V5d29yZE1hdGNoICYmIHN0aXBwZWQuY2hhckF0KGtleXdvcmRNYXRjaC5pbmRleCAtIDEpICE9PSAnJCcpIHtcbiAgICBlcnJvcnMucHVzaChcbiAgICAgIFwiYXZvaWQgdXNpbmcgSmF2YVNjcmlwdCB1bmFyeSBvcGVyYXRvciBhcyBwcm9wZXJ0eSBuYW1lOiBcIiArXG4gICAgICBcIlxcXCJcIiArIChrZXl3b3JkTWF0Y2hbMF0pICsgXCJcXFwiIGluIGV4cHJlc3Npb24gXCIgKyAodGV4dC50cmltKCkpXG4gICAgKTtcbiAgfVxuICBjaGVja0V4cHJlc3Npb24oZXhwLCB0ZXh0LCBlcnJvcnMpO1xufVxuXG5mdW5jdGlvbiBjaGVja0ZvciAobm9kZSwgdGV4dCwgZXJyb3JzKSB7XG4gIGNoZWNrRXhwcmVzc2lvbihub2RlLmZvciB8fCAnJywgdGV4dCwgZXJyb3JzKTtcbiAgY2hlY2tJZGVudGlmaWVyKG5vZGUuYWxpYXMsICd2LWZvciBhbGlhcycsIHRleHQsIGVycm9ycyk7XG4gIGNoZWNrSWRlbnRpZmllcihub2RlLml0ZXJhdG9yMSwgJ3YtZm9yIGl0ZXJhdG9yJywgdGV4dCwgZXJyb3JzKTtcbiAgY2hlY2tJZGVudGlmaWVyKG5vZGUuaXRlcmF0b3IyLCAndi1mb3IgaXRlcmF0b3InLCB0ZXh0LCBlcnJvcnMpO1xufVxuXG5mdW5jdGlvbiBjaGVja0lkZW50aWZpZXIgKFxuICBpZGVudCxcbiAgdHlwZSxcbiAgdGV4dCxcbiAgZXJyb3JzXG4pIHtcbiAgaWYgKHR5cGVvZiBpZGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICB0cnkge1xuICAgICAgbmV3IEZ1bmN0aW9uKChcInZhciBcIiArIGlkZW50ICsgXCI9X1wiKSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZXJyb3JzLnB1c2goKFwiaW52YWxpZCBcIiArIHR5cGUgKyBcIiBcXFwiXCIgKyBpZGVudCArIFwiXFxcIiBpbiBleHByZXNzaW9uOiBcIiArICh0ZXh0LnRyaW0oKSkpKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tFeHByZXNzaW9uIChleHAsIHRleHQsIGVycm9ycykge1xuICB0cnkge1xuICAgIG5ldyBGdW5jdGlvbigoXCJyZXR1cm4gXCIgKyBleHApKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHZhciBrZXl3b3JkTWF0Y2ggPSBleHAucmVwbGFjZShzdHJpcFN0cmluZ1JFLCAnJykubWF0Y2gocHJvaGliaXRlZEtleXdvcmRSRSk7XG4gICAgaWYgKGtleXdvcmRNYXRjaCkge1xuICAgICAgZXJyb3JzLnB1c2goXG4gICAgICAgIFwiYXZvaWQgdXNpbmcgSmF2YVNjcmlwdCBrZXl3b3JkIGFzIHByb3BlcnR5IG5hbWU6IFwiICtcbiAgICAgICAgXCJcXFwiXCIgKyAoa2V5d29yZE1hdGNoWzBdKSArIFwiXFxcIlxcbiAgUmF3IGV4cHJlc3Npb246IFwiICsgKHRleHQudHJpbSgpKVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXJyb3JzLnB1c2goXG4gICAgICAgIFwiaW52YWxpZCBleHByZXNzaW9uOiBcIiArIChlLm1lc3NhZ2UpICsgXCIgaW5cXG5cXG5cIiArXG4gICAgICAgIFwiICAgIFwiICsgZXhwICsgXCJcXG5cXG5cIiArXG4gICAgICAgIFwiICBSYXcgZXhwcmVzc2lvbjogXCIgKyAodGV4dC50cmltKCkpICsgXCJcXG5cIlxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGNyZWF0ZUZ1bmN0aW9uIChjb2RlLCBlcnJvcnMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKGNvZGUpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGVycm9ycy5wdXNoKHsgZXJyOiBlcnIsIGNvZGU6IGNvZGUgfSk7XG4gICAgcmV0dXJuIG5vb3BcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVDb21waWxlVG9GdW5jdGlvbkZuIChjb21waWxlKSB7XG4gIHZhciBjYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIGNvbXBpbGVUb0Z1bmN0aW9ucyAoXG4gICAgdGVtcGxhdGUsXG4gICAgb3B0aW9ucyxcbiAgICB2bVxuICApIHtcbiAgICBvcHRpb25zID0gZXh0ZW5kKHt9LCBvcHRpb25zKTtcbiAgICB2YXIgd2FybiQkMSA9IG9wdGlvbnMud2FybiB8fCB3YXJuO1xuICAgIGRlbGV0ZSBvcHRpb25zLndhcm47XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgLy8gZGV0ZWN0IHBvc3NpYmxlIENTUCByZXN0cmljdGlvblxuICAgICAgdHJ5IHtcbiAgICAgICAgbmV3IEZ1bmN0aW9uKCdyZXR1cm4gMScpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoZS50b1N0cmluZygpLm1hdGNoKC91bnNhZmUtZXZhbHxDU1AvKSkge1xuICAgICAgICAgIHdhcm4kJDEoXG4gICAgICAgICAgICAnSXQgc2VlbXMgeW91IGFyZSB1c2luZyB0aGUgc3RhbmRhbG9uZSBidWlsZCBvZiBWdWUuanMgaW4gYW4gJyArXG4gICAgICAgICAgICAnZW52aXJvbm1lbnQgd2l0aCBDb250ZW50IFNlY3VyaXR5IFBvbGljeSB0aGF0IHByb2hpYml0cyB1bnNhZmUtZXZhbC4gJyArXG4gICAgICAgICAgICAnVGhlIHRlbXBsYXRlIGNvbXBpbGVyIGNhbm5vdCB3b3JrIGluIHRoaXMgZW52aXJvbm1lbnQuIENvbnNpZGVyICcgK1xuICAgICAgICAgICAgJ3JlbGF4aW5nIHRoZSBwb2xpY3kgdG8gYWxsb3cgdW5zYWZlLWV2YWwgb3IgcHJlLWNvbXBpbGluZyB5b3VyICcgK1xuICAgICAgICAgICAgJ3RlbXBsYXRlcyBpbnRvIHJlbmRlciBmdW5jdGlvbnMuJ1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjaGVjayBjYWNoZVxuICAgIHZhciBrZXkgPSBvcHRpb25zLmRlbGltaXRlcnNcbiAgICAgID8gU3RyaW5nKG9wdGlvbnMuZGVsaW1pdGVycykgKyB0ZW1wbGF0ZVxuICAgICAgOiB0ZW1wbGF0ZTtcbiAgICBpZiAoY2FjaGVba2V5XSkge1xuICAgICAgcmV0dXJuIGNhY2hlW2tleV1cbiAgICB9XG5cbiAgICAvLyBjb21waWxlXG4gICAgdmFyIGNvbXBpbGVkID0gY29tcGlsZSh0ZW1wbGF0ZSwgb3B0aW9ucyk7XG5cbiAgICAvLyBjaGVjayBjb21waWxhdGlvbiBlcnJvcnMvdGlwc1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoY29tcGlsZWQuZXJyb3JzICYmIGNvbXBpbGVkLmVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgd2FybiQkMShcbiAgICAgICAgICBcIkVycm9yIGNvbXBpbGluZyB0ZW1wbGF0ZTpcXG5cXG5cIiArIHRlbXBsYXRlICsgXCJcXG5cXG5cIiArXG4gICAgICAgICAgY29tcGlsZWQuZXJyb3JzLm1hcChmdW5jdGlvbiAoZSkgeyByZXR1cm4gKFwiLSBcIiArIGUpOyB9KS5qb2luKCdcXG4nKSArICdcXG4nLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoY29tcGlsZWQudGlwcyAmJiBjb21waWxlZC50aXBzLmxlbmd0aCkge1xuICAgICAgICBjb21waWxlZC50aXBzLmZvckVhY2goZnVuY3Rpb24gKG1zZykgeyByZXR1cm4gdGlwKG1zZywgdm0pOyB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyB0dXJuIGNvZGUgaW50byBmdW5jdGlvbnNcbiAgICB2YXIgcmVzID0ge307XG4gICAgdmFyIGZuR2VuRXJyb3JzID0gW107XG4gICAgcmVzLnJlbmRlciA9IGNyZWF0ZUZ1bmN0aW9uKGNvbXBpbGVkLnJlbmRlciwgZm5HZW5FcnJvcnMpO1xuICAgIHJlcy5zdGF0aWNSZW5kZXJGbnMgPSBjb21waWxlZC5zdGF0aWNSZW5kZXJGbnMubWFwKGZ1bmN0aW9uIChjb2RlKSB7XG4gICAgICByZXR1cm4gY3JlYXRlRnVuY3Rpb24oY29kZSwgZm5HZW5FcnJvcnMpXG4gICAgfSk7XG5cbiAgICAvLyBjaGVjayBmdW5jdGlvbiBnZW5lcmF0aW9uIGVycm9ycy5cbiAgICAvLyB0aGlzIHNob3VsZCBvbmx5IGhhcHBlbiBpZiB0aGVyZSBpcyBhIGJ1ZyBpbiB0aGUgY29tcGlsZXIgaXRzZWxmLlxuICAgIC8vIG1vc3RseSBmb3IgY29kZWdlbiBkZXZlbG9wbWVudCB1c2VcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKCghY29tcGlsZWQuZXJyb3JzIHx8ICFjb21waWxlZC5lcnJvcnMubGVuZ3RoKSAmJiBmbkdlbkVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgd2FybiQkMShcbiAgICAgICAgICBcIkZhaWxlZCB0byBnZW5lcmF0ZSByZW5kZXIgZnVuY3Rpb246XFxuXFxuXCIgK1xuICAgICAgICAgIGZuR2VuRXJyb3JzLm1hcChmdW5jdGlvbiAocmVmKSB7XG4gICAgICAgICAgICB2YXIgZXJyID0gcmVmLmVycjtcbiAgICAgICAgICAgIHZhciBjb2RlID0gcmVmLmNvZGU7XG5cbiAgICAgICAgICAgIHJldHVybiAoKGVyci50b1N0cmluZygpKSArIFwiIGluXFxuXFxuXCIgKyBjb2RlICsgXCJcXG5cIik7XG4gICAgICAgIH0pLmpvaW4oJ1xcbicpLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIChjYWNoZVtrZXldID0gcmVzKVxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBjcmVhdGVDb21waWxlckNyZWF0b3IgKGJhc2VDb21waWxlKSB7XG4gIHJldHVybiBmdW5jdGlvbiBjcmVhdGVDb21waWxlciAoYmFzZU9wdGlvbnMpIHtcbiAgICBmdW5jdGlvbiBjb21waWxlIChcbiAgICAgIHRlbXBsYXRlLFxuICAgICAgb3B0aW9uc1xuICAgICkge1xuICAgICAgdmFyIGZpbmFsT3B0aW9ucyA9IE9iamVjdC5jcmVhdGUoYmFzZU9wdGlvbnMpO1xuICAgICAgdmFyIGVycm9ycyA9IFtdO1xuICAgICAgdmFyIHRpcHMgPSBbXTtcbiAgICAgIGZpbmFsT3B0aW9ucy53YXJuID0gZnVuY3Rpb24gKG1zZywgdGlwKSB7XG4gICAgICAgICh0aXAgPyB0aXBzIDogZXJyb3JzKS5wdXNoKG1zZyk7XG4gICAgICB9O1xuXG4gICAgICBpZiAob3B0aW9ucykge1xuICAgICAgICAvLyBtZXJnZSBjdXN0b20gbW9kdWxlc1xuICAgICAgICBpZiAob3B0aW9ucy5tb2R1bGVzKSB7XG4gICAgICAgICAgZmluYWxPcHRpb25zLm1vZHVsZXMgPVxuICAgICAgICAgICAgKGJhc2VPcHRpb25zLm1vZHVsZXMgfHwgW10pLmNvbmNhdChvcHRpb25zLm1vZHVsZXMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIG1lcmdlIGN1c3RvbSBkaXJlY3RpdmVzXG4gICAgICAgIGlmIChvcHRpb25zLmRpcmVjdGl2ZXMpIHtcbiAgICAgICAgICBmaW5hbE9wdGlvbnMuZGlyZWN0aXZlcyA9IGV4dGVuZChcbiAgICAgICAgICAgIE9iamVjdC5jcmVhdGUoYmFzZU9wdGlvbnMuZGlyZWN0aXZlcyB8fCBudWxsKSxcbiAgICAgICAgICAgIG9wdGlvbnMuZGlyZWN0aXZlc1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY29weSBvdGhlciBvcHRpb25zXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgaWYgKGtleSAhPT0gJ21vZHVsZXMnICYmIGtleSAhPT0gJ2RpcmVjdGl2ZXMnKSB7XG4gICAgICAgICAgICBmaW5hbE9wdGlvbnNba2V5XSA9IG9wdGlvbnNba2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGNvbXBpbGVkID0gYmFzZUNvbXBpbGUodGVtcGxhdGUsIGZpbmFsT3B0aW9ucyk7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBlcnJvcnMucHVzaC5hcHBseShlcnJvcnMsIGRldGVjdEVycm9ycyhjb21waWxlZC5hc3QpKTtcbiAgICAgIH1cbiAgICAgIGNvbXBpbGVkLmVycm9ycyA9IGVycm9ycztcbiAgICAgIGNvbXBpbGVkLnRpcHMgPSB0aXBzO1xuICAgICAgcmV0dXJuIGNvbXBpbGVkXG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbXBpbGU6IGNvbXBpbGUsXG4gICAgICBjb21waWxlVG9GdW5jdGlvbnM6IGNyZWF0ZUNvbXBpbGVUb0Z1bmN0aW9uRm4oY29tcGlsZSlcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbi8vIGBjcmVhdGVDb21waWxlckNyZWF0b3JgIGFsbG93cyBjcmVhdGluZyBjb21waWxlcnMgdGhhdCB1c2UgYWx0ZXJuYXRpdmVcbi8vIHBhcnNlci9vcHRpbWl6ZXIvY29kZWdlbiwgZS5nIHRoZSBTU1Igb3B0aW1pemluZyBjb21waWxlci5cbi8vIEhlcmUgd2UganVzdCBleHBvcnQgYSBkZWZhdWx0IGNvbXBpbGVyIHVzaW5nIHRoZSBkZWZhdWx0IHBhcnRzLlxudmFyIGNyZWF0ZUNvbXBpbGVyID0gY3JlYXRlQ29tcGlsZXJDcmVhdG9yKGZ1bmN0aW9uIGJhc2VDb21waWxlIChcbiAgdGVtcGxhdGUsXG4gIG9wdGlvbnNcbikge1xuICB2YXIgYXN0ID0gcGFyc2UodGVtcGxhdGUudHJpbSgpLCBvcHRpb25zKTtcbiAgaWYgKG9wdGlvbnMub3B0aW1pemUgIT09IGZhbHNlKSB7XG4gICAgb3B0aW1pemUoYXN0LCBvcHRpb25zKTtcbiAgfVxuICB2YXIgY29kZSA9IGdlbmVyYXRlKGFzdCwgb3B0aW9ucyk7XG4gIHJldHVybiB7XG4gICAgYXN0OiBhc3QsXG4gICAgcmVuZGVyOiBjb2RlLnJlbmRlcixcbiAgICBzdGF0aWNSZW5kZXJGbnM6IGNvZGUuc3RhdGljUmVuZGVyRm5zXG4gIH1cbn0pO1xuXG4vKiAgKi9cblxudmFyIHJlZiQxID0gY3JlYXRlQ29tcGlsZXIoYmFzZU9wdGlvbnMpO1xudmFyIGNvbXBpbGVUb0Z1bmN0aW9ucyA9IHJlZiQxLmNvbXBpbGVUb0Z1bmN0aW9ucztcblxuLyogICovXG5cbi8vIGNoZWNrIHdoZXRoZXIgY3VycmVudCBicm93c2VyIGVuY29kZXMgYSBjaGFyIGluc2lkZSBhdHRyaWJ1dGUgdmFsdWVzXG52YXIgZGl2O1xuZnVuY3Rpb24gZ2V0U2hvdWxkRGVjb2RlIChocmVmKSB7XG4gIGRpdiA9IGRpdiB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgZGl2LmlubmVySFRNTCA9IGhyZWYgPyBcIjxhIGhyZWY9XFxcIlxcblxcXCIvPlwiIDogXCI8ZGl2IGE9XFxcIlxcblxcXCIvPlwiO1xuICByZXR1cm4gZGl2LmlubmVySFRNTC5pbmRleE9mKCcmIzEwOycpID4gMFxufVxuXG4vLyAjMzY2MzogSUUgZW5jb2RlcyBuZXdsaW5lcyBpbnNpZGUgYXR0cmlidXRlIHZhbHVlcyB3aGlsZSBvdGhlciBicm93c2VycyBkb24ndFxudmFyIHNob3VsZERlY29kZU5ld2xpbmVzID0gaW5Ccm93c2VyID8gZ2V0U2hvdWxkRGVjb2RlKGZhbHNlKSA6IGZhbHNlO1xuLy8gIzY4Mjg6IGNocm9tZSBlbmNvZGVzIGNvbnRlbnQgaW4gYVtocmVmXVxudmFyIHNob3VsZERlY29kZU5ld2xpbmVzRm9ySHJlZiA9IGluQnJvd3NlciA/IGdldFNob3VsZERlY29kZSh0cnVlKSA6IGZhbHNlO1xuXG4vKiAgKi9cblxudmFyIGlkVG9UZW1wbGF0ZSA9IGNhY2hlZChmdW5jdGlvbiAoaWQpIHtcbiAgdmFyIGVsID0gcXVlcnkoaWQpO1xuICByZXR1cm4gZWwgJiYgZWwuaW5uZXJIVE1MXG59KTtcblxudmFyIG1vdW50ID0gVnVlLnByb3RvdHlwZS4kbW91bnQ7XG5WdWUucHJvdG90eXBlLiRtb3VudCA9IGZ1bmN0aW9uIChcbiAgZWwsXG4gIGh5ZHJhdGluZ1xuKSB7XG4gIGVsID0gZWwgJiYgcXVlcnkoZWwpO1xuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoZWwgPT09IGRvY3VtZW50LmJvZHkgfHwgZWwgPT09IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgIFwiRG8gbm90IG1vdW50IFZ1ZSB0byA8aHRtbD4gb3IgPGJvZHk+IC0gbW91bnQgdG8gbm9ybWFsIGVsZW1lbnRzIGluc3RlYWQuXCJcbiAgICApO1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICB2YXIgb3B0aW9ucyA9IHRoaXMuJG9wdGlvbnM7XG4gIC8vIHJlc29sdmUgdGVtcGxhdGUvZWwgYW5kIGNvbnZlcnQgdG8gcmVuZGVyIGZ1bmN0aW9uXG4gIGlmICghb3B0aW9ucy5yZW5kZXIpIHtcbiAgICB2YXIgdGVtcGxhdGUgPSBvcHRpb25zLnRlbXBsYXRlO1xuICAgIGlmICh0ZW1wbGF0ZSkge1xuICAgICAgaWYgKHR5cGVvZiB0ZW1wbGF0ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKHRlbXBsYXRlLmNoYXJBdCgwKSA9PT0gJyMnKSB7XG4gICAgICAgICAgdGVtcGxhdGUgPSBpZFRvVGVtcGxhdGUodGVtcGxhdGUpO1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICF0ZW1wbGF0ZSkge1xuICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgKFwiVGVtcGxhdGUgZWxlbWVudCBub3QgZm91bmQgb3IgaXMgZW1wdHk6IFwiICsgKG9wdGlvbnMudGVtcGxhdGUpKSxcbiAgICAgICAgICAgICAgdGhpc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodGVtcGxhdGUubm9kZVR5cGUpIHtcbiAgICAgICAgdGVtcGxhdGUgPSB0ZW1wbGF0ZS5pbm5lckhUTUw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHdhcm4oJ2ludmFsaWQgdGVtcGxhdGUgb3B0aW9uOicgKyB0ZW1wbGF0ZSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGVsKSB7XG4gICAgICB0ZW1wbGF0ZSA9IGdldE91dGVySFRNTChlbCk7XG4gICAgfVxuICAgIGlmICh0ZW1wbGF0ZSkge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgICAgICBtYXJrKCdjb21waWxlJyk7XG4gICAgICB9XG5cbiAgICAgIHZhciByZWYgPSBjb21waWxlVG9GdW5jdGlvbnModGVtcGxhdGUsIHtcbiAgICAgICAgc2hvdWxkRGVjb2RlTmV3bGluZXM6IHNob3VsZERlY29kZU5ld2xpbmVzLFxuICAgICAgICBzaG91bGREZWNvZGVOZXdsaW5lc0ZvckhyZWY6IHNob3VsZERlY29kZU5ld2xpbmVzRm9ySHJlZixcbiAgICAgICAgZGVsaW1pdGVyczogb3B0aW9ucy5kZWxpbWl0ZXJzLFxuICAgICAgICBjb21tZW50czogb3B0aW9ucy5jb21tZW50c1xuICAgICAgfSwgdGhpcyk7XG4gICAgICB2YXIgcmVuZGVyID0gcmVmLnJlbmRlcjtcbiAgICAgIHZhciBzdGF0aWNSZW5kZXJGbnMgPSByZWYuc3RhdGljUmVuZGVyRm5zO1xuICAgICAgb3B0aW9ucy5yZW5kZXIgPSByZW5kZXI7XG4gICAgICBvcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IHN0YXRpY1JlbmRlckZucztcblxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgICAgICBtYXJrKCdjb21waWxlIGVuZCcpO1xuICAgICAgICBtZWFzdXJlKChcInZ1ZSBcIiArICh0aGlzLl9uYW1lKSArIFwiIGNvbXBpbGVcIiksICdjb21waWxlJywgJ2NvbXBpbGUgZW5kJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBtb3VudC5jYWxsKHRoaXMsIGVsLCBoeWRyYXRpbmcpXG59O1xuXG4vKipcbiAqIEdldCBvdXRlckhUTUwgb2YgZWxlbWVudHMsIHRha2luZyBjYXJlXG4gKiBvZiBTVkcgZWxlbWVudHMgaW4gSUUgYXMgd2VsbC5cbiAqL1xuZnVuY3Rpb24gZ2V0T3V0ZXJIVE1MIChlbCkge1xuICBpZiAoZWwub3V0ZXJIVE1MKSB7XG4gICAgcmV0dXJuIGVsLm91dGVySFRNTFxuICB9IGVsc2Uge1xuICAgIHZhciBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoZWwuY2xvbmVOb2RlKHRydWUpKTtcbiAgICByZXR1cm4gY29udGFpbmVyLmlubmVySFRNTFxuICB9XG59XG5cblZ1ZS5jb21waWxlID0gY29tcGlsZVRvRnVuY3Rpb25zO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFZ1ZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3Z1ZS9kaXN0L3Z1ZS5jb21tb24uanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3Z1ZS9kaXN0L3Z1ZS5jb21tb24uanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgZztcclxuXHJcbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXHJcbmcgPSAoZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn0pKCk7XHJcblxyXG50cnkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxyXG5cdGcgPSBnIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSB8fCAoMSxldmFsKShcInRoaXNcIik7XHJcbn0gY2F0Y2goZSkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXHJcblx0aWYodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIilcclxuXHRcdGcgPSB3aW5kb3c7XHJcbn1cclxuXHJcbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cclxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3NcclxuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBnO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3dlYnBhY2svYnVpbGRpbi9nbG9iYWwuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyByZXF1aXJlKCcuL2Jvb3RzdHJhcCcpO1xuXG5pbXBvcnQgVnVlIGZyb20gJ3Z1ZSdcbmltcG9ydCBGcmFtZXdvcms3IGZyb20gJ2ZyYW1ld29yazcvZGlzdC9mcmFtZXdvcms3LmVzbS5idW5kbGUuanMnO1xuaW1wb3J0IEZyYW1ld29yazdWdWUgZnJvbSAnZnJhbWV3b3JrNy12dWUvZGlzdC9mcmFtZXdvcms3LXZ1ZS5lc20uYnVuZGxlLmpzJztcblZ1ZS51c2UoRnJhbWV3b3JrN1Z1ZSwgRnJhbWV3b3JrNylcblxuY29uc3QgYXBwID0gbmV3IFZ1ZSh7XG4gICAgZWw6ICcjYXBwJyxcbiAgICBmcmFtZXdvcms3OiB7XG4gICAgICAgIHJvb3Q6ICcjYXBwJyxcbiAgICAgICAgaWQ6ICdtb3ZlLWFwcCcsXG4gICAgICAgIG5hbWU6ICdNb3ZlJyxcbiAgICAgICAgdGhlbWU6ICdpb3MnLFxuICAgICAgICAvLyByb3V0ZXM6IHJvdXRlcyxcbiAgICB9XG59KTtcblxuXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9yZXNvdXJjZXMvYXNzZXRzL2pzL2xvZ2luLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==